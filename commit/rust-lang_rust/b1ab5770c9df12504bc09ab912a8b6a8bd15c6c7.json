{"sha": "b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7", "node_id": "C_kwDOAAsO6NoAKGIxYWI1NzcwYzlkZjEyNTA0YmMwOWFiOTEyYThiNmE4YmQxNWM2Yzc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-10T20:56:19Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-10T20:56:19Z"}, "message": "Enable qualifier completions for derives", "tree": {"sha": "0d350e840d5fee486c6f7ba30f12802ca260ddcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d350e840d5fee486c6f7ba30f12802ca260ddcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7", "html_url": "https://github.com/rust-lang/rust/commit/b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2abe19e46aafd57e7edbcb7b254318e252c76c3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2abe19e46aafd57e7edbcb7b254318e252c76c3f", "html_url": "https://github.com/rust-lang/rust/commit/2abe19e46aafd57e7edbcb7b254318e252c76c3f"}], "stats": {"total": 206, "additions": 123, "deletions": 83}, "files": [{"sha": "1edc92d5d628a3ba2d01f112567990f765c2c1eb", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 87, "deletions": 53, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7", "patch": "@@ -1,77 +1,111 @@\n //! Completion for derives\n-use hir::{HasAttrs, Macro};\n+use hir::{HasAttrs, ScopeDef};\n use ide_db::SymbolKind;\n use itertools::Itertools;\n use syntax::SmolStr;\n \n use crate::{\n-    context::{CompletionContext, PathCompletionCtx, PathKind},\n+    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n     item::CompletionItem,\n     Completions,\n };\n \n pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n-    match ctx.path_context {\n-        // FIXME: Enable qualified completions\n-        Some(PathCompletionCtx { kind: Some(PathKind::Derive), qualifier: None, .. }) => (),\n+    let (qualifier, is_absolute_path) = match ctx.path_context {\n+        Some(PathCompletionCtx {\n+            kind: Some(PathKind::Derive),\n+            ref qualifier,\n+            is_absolute_path,\n+            ..\n+        }) => (qualifier, is_absolute_path),\n         _ => return,\n-    }\n+    };\n \n     let core = ctx.famous_defs().core();\n \n-    for (name, mac) in get_derives_in_scope(ctx) {\n-        if ctx.existing_derives.contains(&mac) {\n-            continue;\n-        }\n+    match qualifier {\n+        Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+            if *is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n \n-        let name = name.to_smol_str();\n-        let (label, lookup) = match (core, mac.module(ctx.db).krate()) {\n-            // show derive dependencies for `core`/`std` derives\n-            (Some(core), mac_krate) if core == mac_krate => {\n-                if let Some(derive_completion) = DEFAULT_DERIVE_DEPENDENCIES\n-                    .iter()\n-                    .find(|derive_completion| derive_completion.label == name)\n-                {\n-                    let mut components = vec![derive_completion.label];\n-                    components.extend(derive_completion.dependencies.iter().filter(\n-                        |&&dependency| {\n-                            !ctx.existing_derives\n-                                .iter()\n-                                .map(|it| it.name(ctx.db))\n-                                .any(|it| it.to_smol_str() == dependency)\n-                        },\n-                    ));\n-                    let lookup = components.join(\", \");\n-                    let label = Itertools::intersperse(components.into_iter().rev(), \", \");\n-                    (SmolStr::from_iter(label), Some(lookup))\n-                } else {\n-                    (name, None)\n+            let module = match resolution {\n+                Some(hir::PathResolution::Def(hir::ModuleDef::Module(it))) => it,\n+                _ => return,\n+            };\n+\n+            for (name, def) in module.scope(ctx.db, ctx.module) {\n+                let add_def = match def {\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n+                        !ctx.existing_derives.contains(&mac) && mac.is_derive(ctx.db)\n+                    }\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n+                    _ => false,\n+                };\n+                if add_def {\n+                    acc.add_resolution(ctx, name, def);\n                 }\n             }\n-            _ => (name, None),\n-        };\n-\n-        let mut item = CompletionItem::new(SymbolKind::Derive, ctx.source_range(), label);\n-        if let Some(docs) = mac.docs(ctx.db) {\n-            item.documentation(docs);\n+            return;\n         }\n-        if let Some(lookup) = lookup {\n-            item.lookup_by(lookup);\n-        }\n-        item.add_to(acc);\n-    }\n-}\n+        None if is_absolute_path => acc.add_crate_roots(ctx),\n+        // only show modules in a fresh UseTree\n+        None => {\n+            ctx.process_all_names(&mut |name, def| {\n+                let mac = match def {\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac))\n+                        if !ctx.existing_derives.contains(&mac) && mac.is_derive(ctx.db) =>\n+                    {\n+                        mac\n+                    }\n+                    ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => {\n+                        return acc.add_resolution(ctx, name, def);\n+                    }\n+                    _ => return,\n+                };\n \n-fn get_derives_in_scope(ctx: &CompletionContext) -> Vec<(hir::Name, Macro)> {\n-    let mut result = Vec::default();\n-    ctx.process_all_names(&mut |name, scope_def| {\n-        if let hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) = scope_def {\n-            if mac.kind(ctx.db) == hir::MacroKind::Derive {\n-                result.push((name, mac));\n-            }\n+                match (core, mac.module(ctx.db).krate()) {\n+                    // show derive dependencies for `core`/`std` derives\n+                    (Some(core), mac_krate) if core == mac_krate && qualifier.is_none() => {}\n+                    _ => return acc.add_resolution(ctx, name, def),\n+                };\n+\n+                let name_ = name.to_smol_str();\n+                let find = DEFAULT_DERIVE_DEPENDENCIES\n+                    .iter()\n+                    .find(|derive_completion| derive_completion.label == name_);\n+\n+                match find {\n+                    Some(derive_completion) => {\n+                        let mut components = vec![derive_completion.label];\n+                        components.extend(derive_completion.dependencies.iter().filter(\n+                            |&&dependency| {\n+                                !ctx.existing_derives\n+                                    .iter()\n+                                    .map(|it| it.name(ctx.db))\n+                                    .any(|it| it.to_smol_str() == dependency)\n+                            },\n+                        ));\n+                        let lookup = components.join(\", \");\n+                        let label = Itertools::intersperse(components.into_iter().rev(), \", \");\n+\n+                        let mut item = CompletionItem::new(\n+                            SymbolKind::Derive,\n+                            ctx.source_range(),\n+                            SmolStr::from_iter(label),\n+                        );\n+                        if let Some(docs) = mac.docs(ctx.db) {\n+                            item.documentation(docs);\n+                        }\n+                        item.lookup_by(lookup);\n+                        item.add_to(acc);\n+                    }\n+                    None => acc.add_resolution(ctx, name, def),\n+                }\n+            });\n+            acc.add_nameref_keywords(ctx);\n         }\n-    });\n-    result\n+    }\n }\n \n struct DeriveDependencies {"}, {"sha": "647fd742e63354f489fdb569750fe80823d2e5d2", "filename": "crates/ide_completion/src/tests/attribute.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs?ref=b1ab5770c9df12504bc09ab912a8b6a8bd15c6c7", "patch": "@@ -688,13 +688,17 @@ mod derive {\n #[derive($0)] struct Test;\n \"#,\n             expect![[r#\"\n-                de Default\n+                md core\n+                de Default                pub macro Default\n                 de Clone, Copy\n-                de PartialEq\n+                de PartialEq              pub macro PartialEq\n                 de PartialEq, Eq\n                 de PartialEq, Eq, PartialOrd, Ord\n-                de Clone\n+                de Clone                  pub macro Clone\n                 de PartialEq, PartialOrd\n+                kw self::\n+                kw super::\n+                kw crate::\n             \"#]],\n         );\n     }\n@@ -707,12 +711,16 @@ mod derive {\n #[derive(serde::Serialize, PartialEq, $0)] struct Test;\n \"#,\n             expect![[r#\"\n-                de Default\n+                md core\n+                de Default             pub macro Default\n                 de Clone, Copy\n                 de Eq\n                 de Eq, PartialOrd, Ord\n-                de Clone\n+                de Clone               pub macro Clone\n                 de PartialOrd\n+                kw self::\n+                kw super::\n+                kw crate::\n             \"#]],\n         )\n     }\n@@ -725,36 +733,20 @@ mod derive {\n #[derive($0 serde::Serialize, PartialEq)] struct Test;\n \"#,\n             expect![[r#\"\n-                de Default\n+                md core\n+                de Default             pub macro Default\n                 de Clone, Copy\n                 de Eq\n                 de Eq, PartialOrd, Ord\n-                de Clone\n+                de Clone               pub macro Clone\n                 de PartialOrd\n+                kw self::\n+                kw super::\n+                kw crate::\n             \"#]],\n         )\n     }\n \n-    #[test]\n-    fn derive_no_attrs() {\n-        check_derive(\n-            r#\"\n-//- proc_macros: identity\n-//- minicore: derive\n-#[derive($0)] struct Test;\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-        check_derive(\n-            r#\"\n-//- proc_macros: identity\n-//- minicore: derive\n-#[derive(i$0)] struct Test;\n-\"#,\n-            expect![[r#\"\"#]],\n-        );\n-    }\n-\n     #[test]\n     fn derive_flyimport() {\n         check_derive(\n@@ -764,6 +756,11 @@ mod derive {\n #[derive(der$0)] struct Test;\n \"#,\n             expect![[r#\"\n+                md proc_macros\n+                md core\n+                kw self::\n+                kw super::\n+                kw crate::\n                 de DeriveIdentity (use proc_macros::DeriveIdentity) pub macro derive_identity\n             \"#]],\n         );\n@@ -775,7 +772,12 @@ use proc_macros::DeriveIdentity;\n #[derive(der$0)] struct Test;\n \"#,\n             expect![[r#\"\n-                de DeriveIdentity\n+                de DeriveIdentity pub macro derive_identity\n+                md proc_macros\n+                md core\n+                kw self::\n+                kw super::\n+                kw crate::\n             \"#]],\n         );\n     }\n@@ -805,15 +807,19 @@ use proc_macros::DeriveIdentity;\n //- minicore: derive, copy, clone\n #[derive(proc_macros::$0)] struct Test;\n \"#,\n-            expect![[r#\"\"#]],\n+            expect![[r#\"\n+                de DeriveIdentity pub macro derive_identity\n+            \"#]],\n         );\n         check_derive(\n             r#\"\n //- proc_macros: derive_identity\n //- minicore: derive, copy, clone\n #[derive(proc_macros::C$0)] struct Test;\n \"#,\n-            expect![[r#\"\"#]],\n+            expect![[r#\"\n+                de DeriveIdentity pub macro derive_identity\n+            \"#]],\n         );\n     }\n }"}]}