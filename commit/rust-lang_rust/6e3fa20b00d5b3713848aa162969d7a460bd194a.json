{"sha": "6e3fa20b00d5b3713848aa162969d7a460bd194a", "node_id": "C_kwDOAAsO6NoAKDZlM2ZhMjBiMDBkNWIzNzEzODQ4YWExNjI5NjlkN2E0NjBiZDE5NGE", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-05-19T11:34:54Z"}, "committer": {"name": "Alan Egerton", "email": "eggyal@gmail.com", "date": "2021-11-26T07:17:59Z"}, "message": "Make `TypeFoldable` implementors short-circuit on error\n\nCo-authored-by: Alan Egerton <eggyal@gmail.com>", "tree": {"sha": "c6e4ce735e875dff44f4e99c710796d05a3ca5a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6e4ce735e875dff44f4e99c710796d05a3ca5a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e3fa20b00d5b3713848aa162969d7a460bd194a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEm/Nz5g9hEBdpmKVOB8rDzKfgZD8FAmGgisgACgkQB8rDzKfg\nZD8A8Q/8CjSoHGtZl9WiGQrgf5sfLxXYQygTBVrtxgaA2hI4fUTvdxFmZb/vcWOH\nWC89j4ApKz4qqoln7MyBQ729yAQHEIjat18TM7aR5r+H1dAqN2uxMymRuoAfdo+P\n3kibPBkKHmLLOa2W1eXEB2WyHbLfrotdUvWtTS0Ocv0NFWxhIvfnRb8LTQMM6KSU\n/8fkEi661+U2QnUiOszKz8THQLbQZXPFWQIQMebIIe/qXh4qpTv3XZwQs5ne6qfe\nXeyppIyG6FgJW0Fwxr11j+TkoRjjUk3nzb8+Wd5gWCydCIoy4dKxJTxnMQ4srRG6\nxYposmO+0QzSI21AESsqzbVw7Ta6ezLctGQ6sbzjyip7hT7E4VuiktYoO2FI4hS9\n9uhe7P9YWZ3AhyejtO5KH9Q2F9xrTaF00LT8wl8582SjrQ9n0h5hAN9n3uCTPu/Z\nAfC9Sf3/Rykj3yugjaHqdt9DT3oWBFLt17+mbGv23paEnyb+eivLKHWBQJQ1R2h6\n5R/FBh+UuZkU7gutDE+G+PovHYb4e7mHSPqPpZ9PQQ4K5Um8RuqdMbHnTsbzyGxp\nhfB7bTZhAmotr6YgDt5I5IDX5PQUhamDQSFR504QQEAEH7O3Ti2kUWzmjmmR5pqn\nz5vS9+SlE6wvzhgfVjQmW7DXaUnl8KNXO75Y4JrZ3RuaHPjH8YY=\n=9eh2\n-----END PGP SIGNATURE-----", "payload": "tree c6e4ce735e875dff44f4e99c710796d05a3ca5a6\nparent c5f0d0ebb4eca79491d30bfb6f32a4541faeaa25\nauthor LeSeulArtichaut <leseulartichaut@gmail.com> 1621424094 +0200\ncommitter Alan Egerton <eggyal@gmail.com> 1637911079 +0000\n\nMake `TypeFoldable` implementors short-circuit on error\n\nCo-authored-by: Alan Egerton <eggyal@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e3fa20b00d5b3713848aa162969d7a460bd194a", "html_url": "https://github.com/rust-lang/rust/commit/6e3fa20b00d5b3713848aa162969d7a460bd194a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e3fa20b00d5b3713848aa162969d7a460bd194a/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eggyal", "id": 3089613, "node_id": "MDQ6VXNlcjMwODk2MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3089613?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eggyal", "html_url": "https://github.com/eggyal", "followers_url": "https://api.github.com/users/eggyal/followers", "following_url": "https://api.github.com/users/eggyal/following{/other_user}", "gists_url": "https://api.github.com/users/eggyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/eggyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eggyal/subscriptions", "organizations_url": "https://api.github.com/users/eggyal/orgs", "repos_url": "https://api.github.com/users/eggyal/repos", "events_url": "https://api.github.com/users/eggyal/events{/privacy}", "received_events_url": "https://api.github.com/users/eggyal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5f0d0ebb4eca79491d30bfb6f32a4541faeaa25", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f0d0ebb4eca79491d30bfb6f32a4541faeaa25", "html_url": "https://github.com/rust-lang/rust/commit/c5f0d0ebb4eca79491d30bfb6f32a4541faeaa25"}], "stats": {"total": 503, "additions": 299, "deletions": 204}, "files": [{"sha": "1307c68ba0b182f9501ff4364542b4132e63085c", "filename": "compiler/rustc_data_structures/src/functor.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -2,12 +2,16 @@ use rustc_index::vec::{Idx, IndexVec};\n use std::mem;\n use std::ptr;\n \n-pub trait IdFunctor {\n+pub trait IdFunctor: Sized {\n     type Inner;\n \n     fn map_id<F>(self, f: F) -> Self\n     where\n         F: FnMut(Self::Inner) -> Self::Inner;\n+\n+    fn try_map_id<F, E>(self, f: F) -> Result<Self, E>\n+    where\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>;\n }\n \n impl<T> IdFunctor for Box<T> {\n@@ -31,6 +35,25 @@ impl<T> IdFunctor for Box<T> {\n             raw.assume_init()\n         }\n     }\n+\n+    #[inline]\n+    fn try_map_id<F, E>(self, mut f: F) -> Result<Self, E>\n+    where\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n+    {\n+        let raw = Box::into_raw(self);\n+        Ok(unsafe {\n+            // SAFETY: The raw pointer points to a valid value of type `T`.\n+            let value = ptr::read(raw);\n+            // SAFETY: Converts `Box<T>` to `Box<MaybeUninit<T>>` which is the\n+            // inverse of `Box::assume_init()` and should be safe.\n+            let mut raw: Box<mem::MaybeUninit<T>> = Box::from_raw(raw.cast());\n+            // SAFETY: Write the mapped value back into the `Box`.\n+            ptr::write(raw.as_mut_ptr(), f(value)?);\n+            // SAFETY: We just initialized `raw`.\n+            raw.assume_init()\n+        })\n+    }\n }\n \n impl<T> IdFunctor for Vec<T> {\n@@ -55,6 +78,35 @@ impl<T> IdFunctor for Vec<T> {\n         }\n         self\n     }\n+\n+    #[inline]\n+    fn try_map_id<F, E>(mut self, mut f: F) -> Result<Self, E>\n+    where\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n+    {\n+        // FIXME: We don't really care about panics here and leak\n+        // far more than we should, but that should be fine for now.\n+        let len = self.len();\n+        let mut error = Ok(());\n+        unsafe {\n+            self.set_len(0);\n+            let start = self.as_mut_ptr();\n+            for i in 0..len {\n+                let p = start.add(i);\n+                match f(ptr::read(p)) {\n+                    Ok(value) => ptr::write(p, value),\n+                    Err(err) => {\n+                        error = Err(err);\n+                        break;\n+                    }\n+                }\n+            }\n+            // Even if we encountered an error, set the len back\n+            // so we don't leak memory.\n+            self.set_len(len);\n+        }\n+        error.map(|()| self)\n+    }\n }\n \n impl<T> IdFunctor for Box<[T]> {\n@@ -67,6 +119,14 @@ impl<T> IdFunctor for Box<[T]> {\n     {\n         Vec::from(self).map_id(f).into()\n     }\n+\n+    #[inline]\n+    fn try_map_id<F, E>(self, f: F) -> Result<Self, E>\n+    where\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n+    {\n+        Vec::from(self).try_map_id(f).map(Into::into)\n+    }\n }\n \n impl<I: Idx, T> IdFunctor for IndexVec<I, T> {\n@@ -79,4 +139,12 @@ impl<I: Idx, T> IdFunctor for IndexVec<I, T> {\n     {\n         IndexVec::from_raw(self.raw.map_id(f))\n     }\n+\n+    #[inline]\n+    fn try_map_id<F, E>(self, f: F) -> Result<Self, E>\n+    where\n+        F: FnMut(Self::Inner) -> Result<Self::Inner, E>,\n+    {\n+        self.raw.try_map_id(f).map(IndexVec::from_raw)\n+    }\n }"}, {"sha": "1ce5f35691000f9262c3547b51859bf8e209fe07", "filename": "compiler/rustc_infer/src/traits/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -60,13 +60,13 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n // TypeFoldable implementations.\n \n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        traits::Obligation {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(traits::Obligation {\n             cause: self.cause,\n             recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder),\n-            param_env: self.param_env.fold_with(folder),\n-        }\n+            predicate: self.predicate.fold_with(folder)?,\n+            param_env: self.param_env.fold_with(folder)?,\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}, {"sha": "769f009b492067c7141a871334025929f9b912aa", "filename": "compiler/rustc_macros/src/type_foldable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Ftype_foldable.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -17,7 +17,7 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n         vi.construct(|_, index| {\n             let bind = &bindings[index];\n             quote! {\n-                ::rustc_middle::ty::fold::TypeFoldable::fold_with(#bind, __folder)\n+                ::rustc_middle::ty::fold::TypeFoldable::fold_with(#bind, __folder)?\n             }\n         })\n     });\n@@ -28,8 +28,8 @@ pub fn type_foldable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::\n             fn super_fold_with<__F: ::rustc_middle::ty::fold::TypeFolder<'tcx>>(\n                 self,\n                 __folder: &mut __F\n-            ) -> Self {\n-                match self { #body_fold }\n+            ) -> Result<Self, __F::Error> {\n+                Ok(match self { #body_fold })\n             }\n \n             fn super_visit_with<__F: ::rustc_middle::ty::fold::TypeVisitor<'tcx>>("}, {"sha": "c0cf265b2287957f1edd0fb8eb5513d00f2c165d", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -55,8 +55,8 @@ macro_rules! TrivialTypeFoldableImpls {\n                 fn super_fold_with<F: $crate::ty::fold::TypeFolder<$tcx>>(\n                     self,\n                     _: &mut F\n-                ) -> $ty {\n-                    self\n+                ) -> ::std::result::Result<$ty, F::Error> {\n+                    Ok(self)\n                 }\n \n                 fn super_visit_with<F: $crate::ty::fold::TypeVisitor<$tcx>>(\n@@ -98,7 +98,7 @@ macro_rules! EnumTypeFoldableImpl {\n             fn super_fold_with<V: $crate::ty::fold::TypeFolder<$tcx>>(\n                 self,\n                 folder: &mut V,\n-            ) -> Self {\n+            ) -> ::std::result::Result<Self, V::Error> {\n                 EnumTypeFoldableImpl!(@FoldVariants(self, folder) input($($variants)*) output())\n             }\n \n@@ -112,9 +112,9 @@ macro_rules! EnumTypeFoldableImpl {\n     };\n \n     (@FoldVariants($this:expr, $folder:expr) input() output($($output:tt)*)) => {\n-        match $this {\n+        Ok(match $this {\n             $($output)*\n-        }\n+        })\n     };\n \n     (@FoldVariants($this:expr, $folder:expr)\n@@ -126,7 +126,7 @@ macro_rules! EnumTypeFoldableImpl {\n                 output(\n                     $variant ( $($variant_arg),* ) => {\n                         $variant (\n-                            $($crate::ty::fold::TypeFoldable::fold_with($variant_arg, $folder)),*\n+                            $($crate::ty::fold::TypeFoldable::fold_with($variant_arg, $folder)?),*\n                         )\n                     }\n                     $($output)*\n@@ -145,7 +145,7 @@ macro_rules! EnumTypeFoldableImpl {\n                         $variant {\n                             $($variant_arg: $crate::ty::fold::TypeFoldable::fold_with(\n                                 $variant_arg, $folder\n-                            )),* }\n+                            )?),* }\n                     }\n                     $($output)*\n                 )"}, {"sha": "a05b8a1da8d7f008a8b9def9e6395eccff64ac93", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -2760,11 +2760,11 @@ impl UserTypeProjection {\n TrivialTypeFoldableAndLiftImpls! { ProjectionKind, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        UserTypeProjection {\n-            base: self.base.fold_with(folder),\n-            projs: self.projs.fold_with(folder),\n-        }\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(UserTypeProjection {\n+            base: self.base.fold_with(folder)?,\n+            projs: self.projs.fold_with(folder)?,\n+        })\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>("}, {"sha": "df7c6d9cf66501a41b67d809f66a4999f259af78", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 91, "deletions": 84, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -16,37 +16,39 @@ TrivialTypeFoldableAndLiftImpls! {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         use crate::mir::TerminatorKind::*;\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n             SwitchInt { discr, switch_ty, targets } => SwitchInt {\n-                discr: discr.fold_with(folder),\n-                switch_ty: switch_ty.fold_with(folder),\n+                discr: discr.fold_with(folder)?,\n+                switch_ty: switch_ty.fold_with(folder)?,\n                 targets,\n             },\n             Drop { place, target, unwind } => {\n-                Drop { place: place.fold_with(folder), target, unwind }\n+                Drop { place: place.fold_with(folder)?, target, unwind }\n             }\n             DropAndReplace { place, value, target, unwind } => DropAndReplace {\n-                place: place.fold_with(folder),\n-                value: value.fold_with(folder),\n+                place: place.fold_with(folder)?,\n+                value: value.fold_with(folder)?,\n                 target,\n                 unwind,\n             },\n             Yield { value, resume, resume_arg, drop } => Yield {\n-                value: value.fold_with(folder),\n+                value: value.fold_with(folder)?,\n                 resume,\n-                resume_arg: resume_arg.fold_with(folder),\n+                resume_arg: resume_arg.fold_with(folder)?,\n                 drop,\n             },\n             Call { func, args, destination, cleanup, from_hir_call, fn_span } => {\n-                let dest = destination.map(|(loc, dest)| (loc.fold_with(folder), dest));\n+                let dest = destination\n+                    .map(|(loc, dest)| (loc.fold_with(folder).map(|loc| (loc, dest))))\n+                    .transpose()?;\n \n                 Call {\n-                    func: func.fold_with(folder),\n-                    args: args.fold_with(folder),\n+                    func: func.fold_with(folder)?,\n+                    args: args.fold_with(folder)?,\n                     destination: dest,\n                     cleanup,\n                     from_hir_call,\n@@ -57,15 +59,15 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 use AssertKind::*;\n                 let msg = match msg {\n                     BoundsCheck { len, index } => {\n-                        BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n+                        BoundsCheck { len: len.fold_with(folder)?, index: index.fold_with(folder)? }\n                     }\n-                    Overflow(op, l, r) => Overflow(op, l.fold_with(folder), r.fold_with(folder)),\n-                    OverflowNeg(op) => OverflowNeg(op.fold_with(folder)),\n-                    DivisionByZero(op) => DivisionByZero(op.fold_with(folder)),\n-                    RemainderByZero(op) => RemainderByZero(op.fold_with(folder)),\n+                    Overflow(op, l, r) => Overflow(op, l.fold_with(folder)?, r.fold_with(folder)?),\n+                    OverflowNeg(op) => OverflowNeg(op.fold_with(folder)?),\n+                    DivisionByZero(op) => DivisionByZero(op.fold_with(folder)?),\n+                    RemainderByZero(op) => RemainderByZero(op.fold_with(folder)?),\n                     ResumedAfterReturn(_) | ResumedAfterPanic(_) => msg,\n                 };\n-                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n+                Assert { cond: cond.fold_with(folder)?, expected, msg, target, cleanup }\n             }\n             GeneratorDrop => GeneratorDrop,\n             Resume => Resume,\n@@ -78,13 +80,13 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n             InlineAsm { template, operands, options, line_spans, destination } => InlineAsm {\n                 template,\n-                operands: operands.fold_with(folder),\n+                operands: operands.fold_with(folder)?,\n                 options,\n                 line_spans,\n                 destination,\n             },\n         };\n-        Terminator { source_info: self.source_info, kind }\n+        Ok(Terminator { source_info: self.source_info, kind })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -140,8 +142,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -150,8 +152,11 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(Place {\n+            local: self.local.fold_with(folder)?,\n+            projection: self.projection.fold_with(folder)?,\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -161,7 +166,7 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_place_elems(v))\n     }\n \n@@ -171,47 +176,49 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         use crate::mir::Rvalue::*;\n-        match self {\n-            Use(op) => Use(op.fold_with(folder)),\n-            Repeat(op, len) => Repeat(op.fold_with(folder), len.fold_with(folder)),\n-            ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)),\n-            Ref(region, bk, place) => Ref(region.fold_with(folder), bk, place.fold_with(folder)),\n-            AddressOf(mutability, place) => AddressOf(mutability, place.fold_with(folder)),\n-            Len(place) => Len(place.fold_with(folder)),\n-            Cast(kind, op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n+        Ok(match self {\n+            Use(op) => Use(op.fold_with(folder)?),\n+            Repeat(op, len) => Repeat(op.fold_with(folder)?, len.fold_with(folder)?),\n+            ThreadLocalRef(did) => ThreadLocalRef(did.fold_with(folder)?),\n+            Ref(region, bk, place) => Ref(region.fold_with(folder)?, bk, place.fold_with(folder)?),\n+            AddressOf(mutability, place) => AddressOf(mutability, place.fold_with(folder)?),\n+            Len(place) => Len(place.fold_with(folder)?),\n+            Cast(kind, op, ty) => Cast(kind, op.fold_with(folder)?, ty.fold_with(folder)?),\n             BinaryOp(op, box (rhs, lhs)) => {\n-                BinaryOp(op, Box::new((rhs.fold_with(folder), lhs.fold_with(folder))))\n+                BinaryOp(op, Box::new((rhs.fold_with(folder)?, lhs.fold_with(folder)?)))\n             }\n             CheckedBinaryOp(op, box (rhs, lhs)) => {\n-                CheckedBinaryOp(op, Box::new((rhs.fold_with(folder), lhs.fold_with(folder))))\n+                CheckedBinaryOp(op, Box::new((rhs.fold_with(folder)?, lhs.fold_with(folder)?)))\n             }\n-            UnaryOp(op, val) => UnaryOp(op, val.fold_with(folder)),\n-            Discriminant(place) => Discriminant(place.fold_with(folder)),\n-            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n+            UnaryOp(op, val) => UnaryOp(op, val.fold_with(folder)?),\n+            Discriminant(place) => Discriminant(place.fold_with(folder)?),\n+            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)?),\n             Aggregate(kind, fields) => {\n-                let kind = kind.map_id(|kind| match kind {\n-                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n-                    AggregateKind::Tuple => AggregateKind::Tuple,\n-                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n-                        def,\n-                        v,\n-                        substs.fold_with(folder),\n-                        user_ty.fold_with(folder),\n-                        n,\n-                    ),\n-                    AggregateKind::Closure(id, substs) => {\n-                        AggregateKind::Closure(id, substs.fold_with(folder))\n-                    }\n-                    AggregateKind::Generator(id, substs, movablity) => {\n-                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n-                    }\n-                });\n-                Aggregate(kind, fields.fold_with(folder))\n+                let kind = kind.try_map_id(|kind| {\n+                    Ok(match kind {\n+                        AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)?),\n+                        AggregateKind::Tuple => AggregateKind::Tuple,\n+                        AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n+                            def,\n+                            v,\n+                            substs.fold_with(folder)?,\n+                            user_ty.fold_with(folder)?,\n+                            n,\n+                        ),\n+                        AggregateKind::Closure(id, substs) => {\n+                            AggregateKind::Closure(id, substs.fold_with(folder)?)\n+                        }\n+                        AggregateKind::Generator(id, substs, movablity) => {\n+                            AggregateKind::Generator(id, substs.fold_with(folder)?, movablity)\n+                        }\n+                    })\n+                })?;\n+                Aggregate(kind, fields.fold_with(folder)?)\n             }\n-            ShallowInitBox(op, ty) => ShallowInitBox(op.fold_with(folder), ty.fold_with(folder)),\n-        }\n+            ShallowInitBox(op, ty) => ShallowInitBox(op.fold_with(folder)?, ty.fold_with(folder)?),\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -265,12 +272,12 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        match self {\n-            Operand::Copy(place) => Operand::Copy(place.fold_with(folder)),\n-            Operand::Move(place) => Operand::Move(place.fold_with(folder)),\n-            Operand::Constant(c) => Operand::Constant(c.fold_with(folder)),\n-        }\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(match self {\n+            Operand::Copy(place) => Operand::Copy(place.fold_with(folder)?),\n+            Operand::Move(place) => Operand::Move(place.fold_with(folder)?),\n+            Operand::Constant(c) => Operand::Constant(c.fold_with(folder)?),\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -282,19 +289,19 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         use crate::mir::ProjectionElem::*;\n \n-        match self {\n+        Ok(match self {\n             Deref => Deref,\n-            Field(f, ty) => Field(f, ty.fold_with(folder)),\n-            Index(v) => Index(v.fold_with(folder)),\n+            Field(f, ty) => Field(f, ty.fold_with(folder)?),\n+            Index(v) => Index(v.fold_with(folder)?),\n             Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n             ConstantIndex { offset, min_length, from_end } => {\n                 ConstantIndex { offset, min_length, from_end }\n             }\n             Subslice { from, to, from_end } => Subslice { from, to, from_end },\n-        }\n+        })\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(\n@@ -312,39 +319,39 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        Constant {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(Constant {\n             span: self.span,\n-            user_ty: self.user_ty.fold_with(folder),\n-            literal: self.literal.fold_with(folder),\n-        }\n+            user_ty: self.user_ty.fold_with(folder)?,\n+            literal: self.literal.fold_with(folder)?,\n+        })\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.literal.visit_with(visitor)?;\n@@ -354,14 +361,14 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ConstantKind<'tcx> {\n     #[inline(always)]\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_mir_const(self)\n     }\n \n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         match self {\n-            ConstantKind::Ty(c) => ConstantKind::Ty(c.fold_with(folder)),\n-            ConstantKind::Val(v, t) => ConstantKind::Val(v, t.fold_with(folder)),\n+            ConstantKind::Ty(c) => Ok(ConstantKind::Ty(c.fold_with(folder)?)),\n+            ConstantKind::Val(v, t) => Ok(ConstantKind::Val(v, t.fold_with(folder)?)),\n         }\n     }\n "}, {"sha": "3b77b5a9d46d56562532596d2ffff13fcd84385b", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -179,8 +179,8 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n }\n \n impl TypeFoldable<'tcx> for hir::Constness {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE"}, {"sha": "2d6926703726c63e146b1d93f3555cdbe35ffd55", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -1260,8 +1260,11 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ParamEnv<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ParamEnv<'tcx> {\n-    fn super_fold_with<F: ty::fold::TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        ParamEnv::new(self.caller_bounds().fold_with(folder), self.reveal().fold_with(folder))\n+    fn super_fold_with<F: ty::fold::TypeFolder<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        Ok(ParamEnv::new(self.caller_bounds().fold_with(folder)?, self.reveal().fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}, {"sha": "a2612df5a442f6d12012c97237d111f4af3695c0", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -669,8 +669,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n \n /// AdtDefs are basically the same as a DefId.\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -679,8 +679,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::AdtDef {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> (T, U) {\n-        (self.0.fold_with(folder), self.1.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<(T, U), F::Error> {\n+        Ok((self.0.fold_with(folder)?, self.1.fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -692,8 +692,8 @@ impl<'tcx, T: TypeFoldable<'tcx>, U: TypeFoldable<'tcx>> TypeFoldable<'tcx> for\n impl<'tcx, A: TypeFoldable<'tcx>, B: TypeFoldable<'tcx>, C: TypeFoldable<'tcx>> TypeFoldable<'tcx>\n     for (A, B, C)\n {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> (A, B, C) {\n-        (self.0.fold_with(folder), self.1.fold_with(folder), self.2.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<(A, B, C), F::Error> {\n+        Ok((self.0.fold_with(folder)?, self.1.fold_with(folder)?, self.2.fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -718,9 +718,9 @@ EnumTypeFoldableImpl! {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         // FIXME: Reuse the `Rc` here.\n-        Rc::new((*self).clone().fold_with(folder))\n+        Ok(Rc::new((*self).clone().fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -729,9 +729,9 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         // FIXME: Reuse the `Arc` here.\n-        Arc::new((*self).clone().fold_with(folder))\n+        Ok(Arc::new((*self).clone().fold_with(folder)?))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -740,8 +740,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_id(|value| value.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|value| value.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -750,8 +750,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_id(|t| t.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|t| t.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -760,8 +760,8 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_id(|t| t.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|t| t.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -770,11 +770,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<'tcx, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_bound(|ty| ty.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_bound(|ty| ty.fold_with(folder))\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_binder(self)\n     }\n \n@@ -788,7 +788,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<'tcx, T> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_poly_existential_predicates(v))\n     }\n \n@@ -798,7 +798,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::Existentia\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_type_list(v))\n     }\n \n@@ -808,7 +808,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_projs(v))\n     }\n \n@@ -818,24 +818,24 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         use crate::ty::InstanceDef::*;\n-        Self {\n-            substs: self.substs.fold_with(folder),\n+        Ok(Self {\n+            substs: self.substs.fold_with(folder)?,\n             def: match self.def {\n-                Item(def) => Item(def.fold_with(folder)),\n-                VtableShim(did) => VtableShim(did.fold_with(folder)),\n-                ReifyShim(did) => ReifyShim(did.fold_with(folder)),\n-                Intrinsic(did) => Intrinsic(did.fold_with(folder)),\n-                FnPtrShim(did, ty) => FnPtrShim(did.fold_with(folder), ty.fold_with(folder)),\n-                Virtual(did, i) => Virtual(did.fold_with(folder), i),\n+                Item(def) => Item(def.fold_with(folder)?),\n+                VtableShim(did) => VtableShim(did.fold_with(folder)?),\n+                ReifyShim(did) => ReifyShim(did.fold_with(folder)?),\n+                Intrinsic(did) => Intrinsic(did.fold_with(folder)?),\n+                FnPtrShim(did, ty) => FnPtrShim(did.fold_with(folder)?, ty.fold_with(folder)?),\n+                Virtual(did, i) => Virtual(did.fold_with(folder)?, i),\n                 ClosureOnceShim { call_once, track_caller } => {\n-                    ClosureOnceShim { call_once: call_once.fold_with(folder), track_caller }\n+                    ClosureOnceShim { call_once: call_once.fold_with(folder)?, track_caller }\n                 }\n-                DropGlue(did, ty) => DropGlue(did.fold_with(folder), ty.fold_with(folder)),\n-                CloneShim(did, ty) => CloneShim(did.fold_with(folder), ty.fold_with(folder)),\n+                DropGlue(did, ty) => DropGlue(did.fold_with(folder)?, ty.fold_with(folder)?),\n+                CloneShim(did, ty) => CloneShim(did.fold_with(folder)?, ty.fold_with(folder)?),\n             },\n-        }\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -860,8 +860,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        Self { instance: self.instance.fold_with(folder), promoted: self.promoted }\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(Self { instance: self.instance.fold_with(folder)?, promoted: self.promoted })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -870,26 +870,26 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         let kind = match *self.kind() {\n-            ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)),\n-            ty::Array(typ, sz) => ty::Array(typ.fold_with(folder), sz.fold_with(folder)),\n-            ty::Slice(typ) => ty::Slice(typ.fold_with(folder)),\n-            ty::Adt(tid, substs) => ty::Adt(tid, substs.fold_with(folder)),\n+            ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)?),\n+            ty::Array(typ, sz) => ty::Array(typ.fold_with(folder)?, sz.fold_with(folder)?),\n+            ty::Slice(typ) => ty::Slice(typ.fold_with(folder)?),\n+            ty::Adt(tid, substs) => ty::Adt(tid, substs.fold_with(folder)?),\n             ty::Dynamic(trait_ty, region) => {\n-                ty::Dynamic(trait_ty.fold_with(folder), region.fold_with(folder))\n+                ty::Dynamic(trait_ty.fold_with(folder)?, region.fold_with(folder)?)\n             }\n-            ty::Tuple(ts) => ty::Tuple(ts.fold_with(folder)),\n-            ty::FnDef(def_id, substs) => ty::FnDef(def_id, substs.fold_with(folder)),\n-            ty::FnPtr(f) => ty::FnPtr(f.fold_with(folder)),\n-            ty::Ref(r, ty, mutbl) => ty::Ref(r.fold_with(folder), ty.fold_with(folder), mutbl),\n+            ty::Tuple(ts) => ty::Tuple(ts.fold_with(folder)?),\n+            ty::FnDef(def_id, substs) => ty::FnDef(def_id, substs.fold_with(folder)?),\n+            ty::FnPtr(f) => ty::FnPtr(f.fold_with(folder)?),\n+            ty::Ref(r, ty, mutbl) => ty::Ref(r.fold_with(folder)?, ty.fold_with(folder)?, mutbl),\n             ty::Generator(did, substs, movability) => {\n-                ty::Generator(did, substs.fold_with(folder), movability)\n+                ty::Generator(did, substs.fold_with(folder)?, movability)\n             }\n-            ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)),\n-            ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)),\n-            ty::Projection(data) => ty::Projection(data.fold_with(folder)),\n-            ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)),\n+            ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)?),\n+            ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)?),\n+            ty::Projection(data) => ty::Projection(data.fold_with(folder)?),\n+            ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)?),\n \n             ty::Bool\n             | ty::Char\n@@ -903,13 +903,13 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             | ty::Bound(..)\n             | ty::Placeholder(..)\n             | ty::Never\n-            | ty::Foreign(..) => return self,\n+            | ty::Foreign(..) => return Ok(self),\n         };\n \n-        if *self.kind() == kind { self } else { folder.tcx().mk_ty(kind) }\n+        Ok(if *self.kind() == kind { self } else { folder.tcx().mk_ty(kind) })\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_ty(self)\n     }\n \n@@ -961,11 +961,11 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_region(self)\n     }\n \n@@ -979,13 +979,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_predicate(self)\n     }\n \n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        let new = self.inner.kind.fold_with(folder);\n-        folder.tcx().reuse_or_mk_predicate(self, new)\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        let new = self.inner.kind.fold_with(folder)?;\n+        Ok(folder.tcx().reuse_or_mk_predicate(self, new))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1006,7 +1006,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_predicates(v))\n     }\n \n@@ -1016,8 +1016,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        self.map_id(|x| x.fold_with(folder))\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        self.try_map_id(|x| x.fold_with(folder))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1026,17 +1026,17 @@ impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        let ty = self.ty.fold_with(folder);\n-        let val = self.val.fold_with(folder);\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        let ty = self.ty.fold_with(folder)?;\n+        let val = self.val.fold_with(folder)?;\n         if ty != self.ty || val != self.val {\n-            folder.tcx().mk_const(ty::Const { ty, val })\n+            Ok(folder.tcx().mk_const(ty::Const { ty, val }))\n         } else {\n-            self\n+            Ok(self)\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.fold_const(self)\n     }\n \n@@ -1051,16 +1051,16 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        match self {\n-            ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)),\n-            ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)),\n-            ty::ConstKind::Unevaluated(uv) => ty::ConstKind::Unevaluated(uv.fold_with(folder)),\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(match self {\n+            ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)?),\n+            ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)?),\n+            ty::ConstKind::Unevaluated(uv) => ty::ConstKind::Unevaluated(uv.fold_with(folder)?),\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(..)\n             | ty::ConstKind::Error(_) => self,\n-        }\n+        })\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1077,8 +1077,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Self {\n-        self\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> ControlFlow<V::BreakTy> {\n@@ -1090,7 +1090,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         ty::Unevaluated {\n             def: self.def,\n-            substs_: Some(self.substs(folder.tcx()).fold_with(folder)),\n+            substs_: Some(self.substs(folder.tcx()).fold_with(folder)?),\n             promoted: self.promoted,\n         }\n     }\n@@ -1115,7 +1115,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx, ()> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         ty::Unevaluated {\n             def: self.def,\n-            substs_: Some(self.substs(folder.tcx()).fold_with(folder)),\n+            substs_: Some(self.substs(folder.tcx()).fold_with(folder)?),\n             promoted: self.promoted,\n         }\n     }"}, {"sha": "fcbf15b3bca47adbbdf71c79dd693cf89f75b0c0", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -1101,6 +1101,18 @@ impl<'tcx, T> Binder<'tcx, T> {\n         Binder(value, self.1)\n     }\n \n+    pub fn try_map_bound<F, U: TypeFoldable<'tcx>, E>(self, f: F) -> Result<Binder<'tcx, U>, E>\n+    where\n+        F: FnOnce(T) -> Result<U, E>,\n+    {\n+        let value = f(self.0)?;\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(self.1);\n+            value.visit_with(&mut validator);\n+        }\n+        Ok(Binder(value, self.1))\n+    }\n+\n     /// Wraps a `value` in a binder, using the same bound variables as the\n     /// current `Binder`. This should not be used if the new value *changes*\n     /// the bound variables. Note: the (old or new) value itself does not"}, {"sha": "67cf21a9556fa8a3d00d729c42ebebe4539b4cdd", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3fa20b00d5b3713848aa162969d7a460bd194a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=6e3fa20b00d5b3713848aa162969d7a460bd194a", "patch": "@@ -153,11 +153,11 @@ impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         match self.unpack() {\n-            GenericArgKind::Lifetime(lt) => lt.fold_with(folder).into(),\n-            GenericArgKind::Type(ty) => ty.fold_with(folder).into(),\n-            GenericArgKind::Const(ct) => ct.fold_with(folder).into(),\n+            GenericArgKind::Lifetime(lt) => lt.fold_with(folder).map(Into::into),\n+            GenericArgKind::Type(ty) => ty.fold_with(folder).map(Into::into),\n+            GenericArgKind::Const(ct) => ct.fold_with(folder).map(Into::into),\n         }\n     }\n \n@@ -372,7 +372,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n         // The match arms are in order of frequency. The 1, 2, and 0 cases are\n@@ -381,22 +381,27 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n         // calling `intern_substs`.\n         match self.len() {\n             1 => {\n-                let param0 = self[0].fold_with(folder);\n-                if param0 == self[0] { self } else { folder.tcx().intern_substs(&[param0]) }\n+                let param0 = self[0].fold_with(folder)?;\n+                if param0 == self[0] { Ok(self) } else { Ok(folder.tcx().intern_substs(&[param0])) }\n             }\n             2 => {\n-                let param0 = self[0].fold_with(folder);\n-                let param1 = self[1].fold_with(folder);\n+                let param0 = self[0].fold_with(folder)?;\n+                let param1 = self[1].fold_with(folder)?;\n                 if param0 == self[0] && param1 == self[1] {\n-                    self\n+                    Ok(self)\n                 } else {\n-                    folder.tcx().intern_substs(&[param0, param1])\n+                    Ok(folder.tcx().intern_substs(&[param0, param1]))\n                 }\n             }\n-            0 => self,\n+            0 => Ok(self),\n             _ => {\n-                let params: SmallVec<[_; 8]> = self.iter().map(|k| k.fold_with(folder)).collect();\n-                if params[..] == self[..] { self } else { folder.tcx().intern_substs(&params) }\n+                let params: SmallVec<[_; 8]> =\n+                    self.iter().map(|k| k.fold_with(folder)).collect::<Result<_, _>>()?;\n+                if params[..] == self[..] {\n+                    Ok(self)\n+                } else {\n+                    Ok(folder.tcx().intern_substs(&params))\n+                }\n             }\n         }\n     }"}]}