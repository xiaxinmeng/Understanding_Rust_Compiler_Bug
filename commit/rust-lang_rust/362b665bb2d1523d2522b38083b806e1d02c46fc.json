{"sha": "362b665bb2d1523d2522b38083b806e1d02c46fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MmI2NjViYjJkMTUyM2QyNTIyYjM4MDgzYjgwNmUxZDAyYzQ2ZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-13T11:31:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-13T11:31:30Z"}, "message": "Auto merge of #34608 - apasel422:ll, r=bluss\n\nReplace `LinkedList`'s use of `Box` with `Shared`\n\nCloses #34417", "tree": {"sha": "bb54604d291537576ca4e2446fecf2724d57983c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb54604d291537576ca4e2446fecf2724d57983c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/362b665bb2d1523d2522b38083b806e1d02c46fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/362b665bb2d1523d2522b38083b806e1d02c46fc", "html_url": "https://github.com/rust-lang/rust/commit/362b665bb2d1523d2522b38083b806e1d02c46fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/362b665bb2d1523d2522b38083b806e1d02c46fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ab18ce6f7e147a71e953b9a01ed09aff6b95972", "html_url": "https://github.com/rust-lang/rust/commit/2ab18ce6f7e147a71e953b9a01ed09aff6b95972"}, {"sha": "6d3bf6e6f5e7d30c6d6feb77615979246f520e62", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d3bf6e6f5e7d30c6d6feb77615979246f520e62", "html_url": "https://github.com/rust-lang/rust/commit/6d3bf6e6f5e7d30c6d6feb77615979246f520e62"}], "stats": {"total": 635, "additions": 283, "deletions": 352}, "files": [{"sha": "dbede94f0bf1b668a8fa37173858c44cb2fc757a", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 283, "deletions": 352, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/362b665bb2d1523d2522b38083b806e1d02c46fc/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362b665bb2d1523d2522b38083b806e1d02c46fc/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=362b665bb2d1523d2522b38083b806e1d02c46fc", "patch": "@@ -13,19 +13,14 @@\n //! The `LinkedList` allows pushing and popping elements at either end and is thus\n //! efficiently usable as a double-ended queue.\n \n-// LinkedList is constructed like a singly-linked list over the field `next`.\n-// including the last link being None; each Node owns its `next` field.\n-//\n-// Backlinks over LinkedList::prev are raw pointers that form a full chain in\n-// the reverse direction.\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::{Box, IntermediateBox};\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::iter::FromIterator;\n+use core::marker::PhantomData;\n use core::mem;\n use core::ops::{BoxPlace, InPlace, Place, Placer};\n use core::ptr::{self, Shared};\n@@ -35,222 +30,156 @@ use super::SpecExtend;\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinkedList<T> {\n-    length: usize,\n-    list_head: Link<T>,\n-    list_tail: Rawlink<Node<T>>,\n-}\n-\n-type Link<T> = Option<Box<Node<T>>>;\n-\n-struct Rawlink<T> {\n-    p: Option<Shared<T>>,\n+    head: Option<Shared<Node<T>>>,\n+    tail: Option<Shared<Node<T>>>,\n+    len: usize,\n+    marker: PhantomData<Box<Node<T>>>,\n }\n \n-impl<T> Copy for Rawlink<T> {}\n-unsafe impl<T: Send> Send for Rawlink<T> {}\n-unsafe impl<T: Sync> Sync for Rawlink<T> {}\n-\n struct Node<T> {\n-    next: Link<T>,\n-    prev: Rawlink<Node<T>>,\n-    value: T,\n+    next: Option<Shared<Node<T>>>,\n+    prev: Option<Shared<Node<T>>>,\n+    element: T,\n }\n \n-/// An iterator over references to the items of a `LinkedList`.\n+/// An iterator over references to the elements of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    head: &'a Link<T>,\n-    tail: Rawlink<Node<T>>,\n-    nelem: usize,\n+    head: Option<Shared<Node<T>>>,\n+    tail: Option<Shared<Node<T>>>,\n+    len: usize,\n+    marker: PhantomData<&'a Node<T>>,\n }\n \n // FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> {\n-        Iter {\n-            head: self.head.clone(),\n-            tail: self.tail,\n-            nelem: self.nelem,\n-        }\n+    fn clone(&self) -> Self {\n+        Iter { ..*self }\n     }\n }\n \n-/// An iterator over mutable references to the items of a `LinkedList`.\n+/// An iterator over mutable references to the elements of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     list: &'a mut LinkedList<T>,\n-    head: Rawlink<Node<T>>,\n-    tail: Rawlink<Node<T>>,\n-    nelem: usize,\n+    head: Option<Shared<Node<T>>>,\n+    tail: Option<Shared<Node<T>>>,\n+    len: usize,\n }\n \n-/// An iterator over the items of a `LinkedList`.\n+/// An iterator over the elements of a `LinkedList`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     list: LinkedList<T>,\n }\n \n-/// Rawlink is a type like Option<T> but for holding a raw pointer\n-impl<T> Rawlink<T> {\n-    /// Like Option::None for Rawlink\n-    fn none() -> Rawlink<T> {\n-        Rawlink { p: None }\n-    }\n-\n-    /// Like Option::Some for Rawlink\n-    fn some(n: &mut T) -> Rawlink<T> {\n-        unsafe { Rawlink { p: Some(Shared::new(n)) } }\n-    }\n-\n-    /// Convert the `Rawlink` into an Option value\n-    ///\n-    /// **unsafe** because:\n-    ///\n-    /// - Dereference of raw pointer.\n-    /// - Returns reference of arbitrary lifetime.\n-    unsafe fn resolve<'a>(&self) -> Option<&'a T> {\n-        self.p.map(|p| &**p)\n-    }\n-\n-    /// Convert the `Rawlink` into an Option value\n-    ///\n-    /// **unsafe** because:\n-    ///\n-    /// - Dereference of raw pointer.\n-    /// - Returns reference of arbitrary lifetime.\n-    unsafe fn resolve_mut<'a>(&mut self) -> Option<&'a mut T> {\n-        self.p.map(|p| &mut **p)\n-    }\n-\n-    /// Return the `Rawlink` and replace with `Rawlink::none()`\n-    fn take(&mut self) -> Rawlink<T> {\n-        mem::replace(self, Rawlink::none())\n-    }\n-}\n-\n-impl<'a, T> From<&'a mut Link<T>> for Rawlink<Node<T>> {\n-    fn from(node: &'a mut Link<T>) -> Self {\n-        match node.as_mut() {\n-            None => Rawlink::none(),\n-            Some(ptr) => Rawlink::some(ptr),\n-        }\n-    }\n-}\n-\n-impl<T> Clone for Rawlink<T> {\n-    #[inline]\n-    fn clone(&self) -> Rawlink<T> {\n-        Rawlink { p: self.p }\n-    }\n-}\n-\n impl<T> Node<T> {\n-    fn new(v: T) -> Node<T> {\n+    fn new(element: T) -> Self {\n         Node {\n-            value: v,\n             next: None,\n-            prev: Rawlink::none(),\n+            prev: None,\n+            element: element,\n         }\n     }\n \n-    /// Update the `prev` link on `next`, then set self's next pointer.\n-    ///\n-    /// `self.next` should be `None` when you call this\n-    /// (otherwise a Node is probably being dropped by mistake).\n-    fn set_next(&mut self, mut next: Box<Node<T>>) {\n-        debug_assert!(self.next.is_none());\n-        next.prev = Rawlink::some(self);\n-        self.next = Some(next);\n+    fn into_element(self: Box<Self>) -> T {\n+        self.element\n     }\n }\n \n-/// Clear the .prev field on `next`, then return `Some(next)`\n-fn link_no_prev<T>(mut next: Box<Node<T>>) -> Link<T> {\n-    next.prev = Rawlink::none();\n-    Some(next)\n-}\n-\n // private methods\n impl<T> LinkedList<T> {\n-    /// Add a Node first in the list\n+    /// Adds the given node to the front of the list.\n     #[inline]\n-    fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n-        match self.list_head {\n-            None => {\n-                self.list_head = link_no_prev(new_head);\n-                self.list_tail = Rawlink::from(&mut self.list_head);\n-            }\n-            Some(ref mut head) => {\n-                new_head.prev = Rawlink::none();\n-                head.prev = Rawlink::some(&mut *new_head);\n-                mem::swap(head, &mut new_head);\n-                head.next = Some(new_head);\n+    fn push_front_node(&mut self, mut node: Box<Node<T>>) {\n+        unsafe {\n+            node.next = self.head;\n+            node.prev = None;\n+            let node = Some(Shared::new(Box::into_raw(node)));\n+\n+            match self.head {\n+                None => self.tail = node,\n+                Some(head) => (**head).prev = node,\n             }\n+\n+            self.head = node;\n+            self.len += 1;\n         }\n-        self.length += 1;\n     }\n \n-    /// Remove the first Node and return it, or None if the list is empty\n+    /// Removes and returns the node at the front of the list.\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n-        self.list_head.take().map(|mut front_node| {\n-            self.length -= 1;\n-            match front_node.next.take() {\n-                Some(node) => self.list_head = link_no_prev(node),\n-                None => self.list_tail = Rawlink::none(),\n+        self.head.map(|node| unsafe {\n+            let node = Box::from_raw(*node);\n+            self.head = node.next;\n+\n+            match self.head {\n+                None => self.tail = None,\n+                Some(head) => (**head).prev = None,\n             }\n-            front_node\n+\n+            self.len -= 1;\n+            node\n         })\n     }\n \n-    /// Add a Node last in the list\n+    /// Adds the given node to the back of the list.\n     #[inline]\n-    fn push_back_node(&mut self, new_tail: Box<Node<T>>) {\n-        match unsafe { self.list_tail.resolve_mut() } {\n-            None => return self.push_front_node(new_tail),\n-            Some(tail) => {\n-                tail.set_next(new_tail);\n-                self.list_tail = Rawlink::from(&mut tail.next);\n+    fn push_back_node(&mut self, mut node: Box<Node<T>>) {\n+        unsafe {\n+            node.next = None;\n+            node.prev = self.tail;\n+            let node = Some(Shared::new(Box::into_raw(node)));\n+\n+            match self.tail {\n+                None => self.head = node,\n+                Some(tail) => (**tail).next = node,\n             }\n+\n+            self.tail = node;\n+            self.len += 1;\n         }\n-        self.length += 1;\n     }\n \n-    /// Remove the last Node and return it, or None if the list is empty\n+    /// Removes and returns the node at the back of the list.\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n-        unsafe {\n-            self.list_tail.resolve_mut().and_then(|tail| {\n-                self.length -= 1;\n-                self.list_tail = tail.prev;\n-                match tail.prev.resolve_mut() {\n-                    None => self.list_head.take(),\n-                    Some(tail_prev) => tail_prev.next.take(),\n-                }\n-            })\n-        }\n+        self.tail.map(|node| unsafe {\n+            let node = Box::from_raw(*node);\n+            self.tail = node.prev;\n+\n+            match self.tail {\n+                None => self.head = None,\n+                Some(tail) => (**tail).next = None,\n+            }\n+\n+            self.len -= 1;\n+            node\n+        })\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for LinkedList<T> {\n     #[inline]\n-    fn default() -> LinkedList<T> {\n-        LinkedList::new()\n+    fn default() -> Self {\n+        Self::new()\n     }\n }\n \n impl<T> LinkedList<T> {\n     /// Creates an empty `LinkedList`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> LinkedList<T> {\n+    pub fn new() -> Self {\n         LinkedList {\n-            list_head: None,\n-            list_tail: Rawlink::none(),\n-            length: 0,\n+            head: None,\n+            tail: None,\n+            len: 0,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -281,38 +210,30 @@ impl<T> LinkedList<T> {\n     /// println!(\"{}\", b.len()); // prints 0\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn append(&mut self, other: &mut LinkedList<T>) {\n-        match unsafe { self.list_tail.resolve_mut() } {\n-            None => {\n-                self.length = other.length;\n-                self.list_head = other.list_head.take();\n-                self.list_tail = other.list_tail.take();\n-            }\n-            Some(tail) => {\n-                // Carefully empty `other`.\n-                let o_tail = other.list_tail.take();\n-                let o_length = other.length;\n-                match other.list_head.take() {\n-                    None => return,\n-                    Some(node) => {\n-                        tail.set_next(node);\n-                        self.list_tail = o_tail;\n-                        self.length += o_length;\n-                    }\n+    pub fn append(&mut self, other: &mut Self) {\n+        match self.tail {\n+            None => mem::swap(self, other),\n+            Some(tail) => if let Some(other_head) = other.head.take() {\n+                unsafe {\n+                    (**tail).next = Some(other_head);\n+                    (**other_head).prev = Some(tail);\n                 }\n-            }\n+\n+                self.tail = other.tail.take();\n+                self.len += mem::replace(&mut other.len, 0);\n+            },\n         }\n-        other.length = 0;\n     }\n \n     /// Provides a forward iterator.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n-            nelem: self.len(),\n-            head: &self.list_head,\n-            tail: self.list_tail,\n+            head: self.head,\n+            tail: self.tail,\n+            len: self.len,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -321,9 +242,9 @@ impl<T> LinkedList<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut {\n-            nelem: self.len(),\n-            head: Rawlink::from(&mut self.list_head),\n-            tail: self.list_tail,\n+            head: self.head,\n+            tail: self.tail,\n+            len: self.len,\n             list: self,\n         }\n     }\n@@ -346,7 +267,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.list_head.is_none()\n+        self.head.is_none()\n     }\n \n     /// Returns the length of the `LinkedList`.\n@@ -373,7 +294,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n-        self.length\n+        self.len\n     }\n \n     /// Removes all elements from the `LinkedList`.\n@@ -400,7 +321,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        *self = LinkedList::new()\n+        *self = Self::new();\n     }\n \n     /// Returns `true` if the `LinkedList` contains an element equal to the\n@@ -431,7 +352,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        self.list_head.as_ref().map(|head| &head.value)\n+        self.head.map(|node| unsafe { &(**node).element })\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n@@ -458,7 +379,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        self.list_head.as_mut().map(|head| &mut head.value)\n+        self.head.map(|node| unsafe { &mut (**node).element })\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n@@ -479,7 +400,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        unsafe { self.list_tail.resolve().map(|tail| &tail.value) }\n+        self.tail.map(|node| unsafe { &(**node).element })\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -506,7 +427,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        unsafe { self.list_tail.resolve_mut().map(|tail| &mut tail.value) }\n+        self.tail.map(|node| unsafe { &mut (**node).element })\n     }\n \n     /// Adds an element first in the list.\n@@ -529,7 +450,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n-        self.push_front_node(box Node::new(elt))\n+        self.push_front_node(box Node::new(elt));\n     }\n \n     /// Removes the first element and returns it, or `None` if the list is\n@@ -555,7 +476,7 @@ impl<T> LinkedList<T> {\n     ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map(|box Node { value, .. }| value)\n+        self.pop_front_node().map(Node::into_element)\n     }\n \n     /// Appends an element to the back of a list\n@@ -572,7 +493,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, elt: T) {\n-        self.push_back_node(box Node::new(elt))\n+        self.push_back_node(box Node::new(elt));\n     }\n \n     /// Removes the last element from a list and returns it, or `None` if\n@@ -591,7 +512,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n-        self.pop_back_node().map(|box Node { value, .. }| value)\n+        self.pop_back_node().map(Node::into_element)\n     }\n \n     /// Splits the list into two at the given index. Returns everything after the given index,\n@@ -624,14 +545,14 @@ impl<T> LinkedList<T> {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::replace(self, LinkedList::new());\n+            return mem::replace(self, Self::new());\n         } else if at == len {\n-            return LinkedList::new();\n+            return Self::new();\n         }\n \n         // Below, we iterate towards the `i-1`th node, either from the start or the end,\n         // depending on which would be faster.\n-        let mut split_node = if at - 1 <= len - 1 - (at - 1) {\n+        let split_node = if at - 1 <= len - 1 - (at - 1) {\n             let mut iter = self.iter_mut();\n             // instead of skipping using .skip() (which creates a new struct),\n             // we skip manually so we can access the head field without\n@@ -651,25 +572,25 @@ impl<T> LinkedList<T> {\n \n         // The split node is the new tail node of the first part and owns\n         // the head of the second part.\n-        let mut second_part_head;\n+        let second_part_head;\n \n         unsafe {\n-            second_part_head = split_node.resolve_mut().unwrap().next.take();\n-            match second_part_head {\n-                None => {}\n-                Some(ref mut head) => head.prev = Rawlink::none(),\n+            second_part_head = (**split_node.unwrap()).next.take();\n+            if let Some(head) = second_part_head {\n+                (**head).prev = None;\n             }\n         }\n \n         let second_part = LinkedList {\n-            list_head: second_part_head,\n-            list_tail: self.list_tail,\n-            length: len - at,\n+            head: second_part_head,\n+            tail: self.tail,\n+            len: len - at,\n+            marker: PhantomData,\n         };\n \n         // Fix the tail ptr of the first part\n-        self.list_tail = split_node;\n-        self.length = at;\n+        self.tail = split_node;\n+        self.len = at;\n \n         second_part\n     }\n@@ -729,129 +650,100 @@ impl<T> LinkedList<T> {\n impl<T> Drop for LinkedList<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n-        // Dissolve the linked_list in a loop.\n-        // Just dropping the list_head can lead to stack exhaustion\n-        // when length is >> 1_000_000\n-        while let Some(mut head_) = self.list_head.take() {\n-            self.list_head = head_.next.take();\n-        }\n-        self.length = 0;\n-        self.list_tail = Rawlink::none();\n+        while let Some(_) = self.pop_front_node() {}\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> Iterator for Iter<'a, A> {\n-    type Item = &'a A;\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a A> {\n-        if self.nelem == 0 {\n-            return None;\n+    fn next(&mut self) -> Option<&'a T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.head.map(|node| unsafe {\n+                let node = &**node;\n+                self.len -= 1;\n+                self.head = node.next;\n+                &node.element\n+            })\n         }\n-        self.head.as_ref().map(|head| {\n-            self.nelem -= 1;\n-            self.head = &head.next;\n-            &head.value\n-        })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.nelem, Some(self.nelem))\n+        (self.len, Some(self.len))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a A> {\n-        if self.nelem == 0 {\n-            return None;\n-        }\n-        unsafe {\n-            self.tail.resolve().map(|prev| {\n-                self.nelem -= 1;\n-                self.tail = prev.prev;\n-                &prev.value\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.tail.map(|node| unsafe {\n+                let node = &**node;\n+                self.len -= 1;\n+                self.tail = node.prev;\n+                &node.element\n             })\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> Iterator for IterMut<'a, A> {\n-    type Item = &'a mut A;\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<&'a mut A> {\n-        if self.nelem == 0 {\n-            return None;\n-        }\n-        unsafe {\n-            self.head.resolve_mut().map(|next| {\n-                self.nelem -= 1;\n-                self.head = Rawlink::from(&mut next.next);\n-                &mut next.value\n+    fn next(&mut self) -> Option<&'a mut T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.head.map(|node| unsafe {\n+                let node = &mut **node;\n+                self.len -= 1;\n+                self.head = node.next;\n+                &mut node.element\n             })\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.nelem, Some(self.nelem))\n+        (self.len, Some(self.len))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut A> {\n-        if self.nelem == 0 {\n-            return None;\n-        }\n-        unsafe {\n-            self.tail.resolve_mut().map(|prev| {\n-                self.nelem -= 1;\n-                self.tail = prev.prev;\n-                &mut prev.value\n+    fn next_back(&mut self) -> Option<&'a mut T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.tail.map(|node| unsafe {\n+                let node = &mut **node;\n+                self.len -= 1;\n+                self.tail = node.prev;\n+                &mut node.element\n             })\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n-\n-// private methods for IterMut\n-impl<'a, A> IterMut<'a, A> {\n-    fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) {\n-        // Insert before `self.head` so that it is between the\n-        // previously yielded element and self.head.\n-        //\n-        // The inserted node will not appear in further iteration.\n-        match unsafe { self.head.resolve_mut() } {\n-            None => {\n-                self.list.push_back_node(ins_node);\n-            }\n-            Some(node) => {\n-                let prev_node = match unsafe { node.prev.resolve_mut() } {\n-                    None => return self.list.push_front_node(ins_node),\n-                    Some(prev) => prev,\n-                };\n-                let node_own = prev_node.next.take().unwrap();\n-                ins_node.set_next(node_own);\n-                prev_node.set_next(ins_node);\n-                self.list.length += 1;\n-            }\n-        }\n-    }\n-}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-impl<'a, A> IterMut<'a, A> {\n-    /// Inserts `elt` just after the element most recently returned by `.next()`.\n+impl<'a, T> IterMut<'a, T> {\n+    /// Inserts the given element just after the element most recently returned by `.next()`.\n     /// The inserted element does not appear in the iteration.\n     ///\n     /// # Examples\n@@ -878,8 +770,27 @@ impl<'a, A> IterMut<'a, A> {\n     #[unstable(feature = \"linked_list_extras\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\",\n                issue = \"27794\")]\n-    pub fn insert_next(&mut self, elt: A) {\n-        self.insert_next_node(box Node::new(elt))\n+    pub fn insert_next(&mut self, element: T) {\n+        match self.head {\n+            None => self.list.push_back(element),\n+            Some(head) => unsafe {\n+                let prev = match (**head).prev {\n+                    None => return self.list.push_front(element),\n+                    Some(prev) => prev,\n+                };\n+\n+                let node = Some(Shared::new(Box::into_raw(box Node {\n+                    next: Some(head),\n+                    prev: Some(prev),\n+                    element: element,\n+                })));\n+\n+                (**prev).next = node;\n+                (**head).prev = node;\n+\n+                self.list.len += 1;\n+            }\n+        }\n     }\n \n     /// Provides a reference to the next element, without changing the iterator.\n@@ -903,46 +814,47 @@ impl<'a, A> IterMut<'a, A> {\n     #[unstable(feature = \"linked_list_extras\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\",\n                issue = \"27794\")]\n-    pub fn peek_next(&mut self) -> Option<&mut A> {\n-        if self.nelem == 0 {\n-            return None;\n+    pub fn peek_next(&mut self) -> Option<&mut T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.head.map(|node| unsafe { &mut (**node).element })\n         }\n-        unsafe { self.head.resolve_mut().map(|head| &mut head.value) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Iterator for IntoIter<A> {\n-    type Item = A;\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<T> {\n         self.list.pop_front()\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.list.length, Some(self.list.length))\n+        (self.list.len, Some(self.list.len))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> DoubleEndedIterator for IntoIter<A> {\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option<T> {\n         self.list.pop_back()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> ExactSizeIterator for IntoIter<A> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for LinkedList<A> {\n-    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> LinkedList<A> {\n-        let mut ret = LinkedList::new();\n-        ret.extend(iter);\n-        ret\n+impl<T> FromIterator<T> for LinkedList<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n+        let mut list = Self::new();\n+        list.extend(iter);\n+        list\n     }\n }\n \n@@ -973,15 +885,15 @@ impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n-    fn into_iter(mut self) -> IterMut<'a, T> {\n+    fn into_iter(self) -> IterMut<'a, T> {\n         self.iter_mut()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for LinkedList<A> {\n-    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n-        <Self as SpecExtend<T>>::spec_extend(self, iter);\n+impl<T> Extend<T> for LinkedList<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n }\n \n@@ -1007,50 +919,50 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for LinkedList<A> {\n-    fn eq(&self, other: &LinkedList<A>) -> bool {\n-        self.len() == other.len() && self.iter().eq(other.iter())\n+impl<T: PartialEq> PartialEq for LinkedList<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.len() == other.len() && self.iter().eq(other)\n     }\n \n-    fn ne(&self, other: &LinkedList<A>) -> bool {\n-        self.len() != other.len() || self.iter().ne(other.iter())\n+    fn ne(&self, other: &Self) -> bool {\n+        self.len() != other.len() || self.iter().ne(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for LinkedList<A> {}\n+impl<T: Eq> Eq for LinkedList<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for LinkedList<A> {\n-    fn partial_cmp(&self, other: &LinkedList<A>) -> Option<Ordering> {\n-        self.iter().partial_cmp(other.iter())\n+impl<T: PartialOrd> PartialOrd for LinkedList<T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.iter().partial_cmp(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for LinkedList<A> {\n+impl<T: Ord> Ord for LinkedList<T> {\n     #[inline]\n-    fn cmp(&self, other: &LinkedList<A>) -> Ordering {\n-        self.iter().cmp(other.iter())\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.iter().cmp(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> Clone for LinkedList<A> {\n-    fn clone(&self) -> LinkedList<A> {\n+impl<T: Clone> Clone for LinkedList<T> {\n+    fn clone(&self) -> Self {\n         self.iter().cloned().collect()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: fmt::Debug> fmt::Debug for LinkedList<A> {\n+impl<T: fmt::Debug> fmt::Debug for LinkedList<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_list().entries(self.iter()).finish()\n+        f.debug_list().entries(self).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Hash> Hash for LinkedList<A> {\n+impl<T: Hash> Hash for LinkedList<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);\n         for elt in self {\n@@ -1062,7 +974,7 @@ impl<A: Hash> Hash for LinkedList<A> {\n unsafe fn finalize<T>(node: IntermediateBox<Node<T>>) -> Box<Node<T>> {\n     let mut node = node.finalize();\n     ptr::write(&mut node.next, None);\n-    ptr::write(&mut node.prev, Rawlink::none());\n+    ptr::write(&mut node.prev, None);\n     node\n }\n \n@@ -1094,7 +1006,7 @@ impl<'a, T> Placer<T> for FrontPlace<'a, T> {\n            issue = \"30172\")]\n impl<'a, T> Place<T> for FrontPlace<'a, T> {\n     fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).value }\n+        unsafe { &mut (*self.node.pointer()).element }\n     }\n }\n \n@@ -1138,7 +1050,7 @@ impl<'a, T> Placer<T> for BackPlace<'a, T> {\n            issue = \"30172\")]\n impl<'a, T> Place<T> for BackPlace<'a, T> {\n     fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).value }\n+        unsafe { &mut (*self.node.pointer()).element }\n     }\n }\n \n@@ -1162,6 +1074,24 @@ fn assert_covariance() {\n     fn c<'a>(x: IntoIter<&'static str>) -> IntoIter<&'a str> { x }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send> Send for LinkedList<T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Sync for LinkedList<T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n+\n #[cfg(test)]\n mod tests {\n     use std::clone::Clone;\n@@ -1179,38 +1109,40 @@ mod tests {\n     }\n \n     pub fn check_links<T>(list: &LinkedList<T>) {\n-        let mut len = 0;\n-        let mut last_ptr: Option<&Node<T>> = None;\n-        let mut node_ptr: &Node<T>;\n-        match list.list_head {\n-            None => {\n-                assert_eq!(0, list.length);\n-                return;\n-            }\n-            Some(ref node) => node_ptr = &**node,\n-        }\n-        loop {\n-            match unsafe { (last_ptr, node_ptr.prev.resolve()) } {\n-                (None, None) => {}\n-                (None, _) => panic!(\"prev link for list_head\"),\n-                (Some(p), Some(pptr)) => {\n-                    assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n+        unsafe {\n+            let mut len = 0;\n+            let mut last_ptr: Option<&Node<T>> = None;\n+            let mut node_ptr: &Node<T>;\n+            match list.head {\n+                None => {\n+                    assert_eq!(0, list.len);\n+                    return;\n                 }\n-                _ => panic!(\"prev link is none, not good\"),\n+                Some(node) => node_ptr = &**node,\n             }\n-            match node_ptr.next {\n-                Some(ref next) => {\n-                    last_ptr = Some(node_ptr);\n-                    node_ptr = &**next;\n-                    len += 1;\n+            loop {\n+                match (last_ptr, node_ptr.prev) {\n+                    (None, None) => {}\n+                    (None, _) => panic!(\"prev link for head\"),\n+                    (Some(p), Some(pptr)) => {\n+                        assert_eq!(p as *const Node<T>, *pptr as *const Node<T>);\n+                    }\n+                    _ => panic!(\"prev link is none, not good\"),\n                 }\n-                None => {\n-                    len += 1;\n-                    break;\n+                match node_ptr.next {\n+                    Some(next) => {\n+                        last_ptr = Some(node_ptr);\n+                        node_ptr = &**next;\n+                        len += 1;\n+                    }\n+                    None => {\n+                        len += 1;\n+                        break;\n+                    }\n                 }\n             }\n+            assert_eq!(len, list.len);\n         }\n-        assert_eq!(len, list.length);\n     }\n \n     #[test]\n@@ -1359,7 +1291,6 @@ mod tests {\n         }\n     }\n \n-\n     #[cfg(test)]\n     fn fuzz_test(sz: i32) {\n         let mut m: LinkedList<_> = LinkedList::new();"}]}