{"sha": "ad76741bca51d169d0e167223435bcc08fc2a3af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNzY3NDFiY2E1MWQxNjlkMGUxNjcyMjM0MzViY2MwOGZjMmEzYWY=", "commit": {"author": {"name": "David Lukes", "email": "dafydd.lukes@gmail.com", "date": "2018-02-19T16:26:29Z"}, "committer": {"name": "David Lukes", "email": "dafydd.lukes@gmail.com", "date": "2018-03-05T12:13:55Z"}, "message": "Move license template parsing into config phase", "tree": {"sha": "4e8634fc81f4ce80533e358a5a57d83e0e4e6eea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8634fc81f4ce80533e358a5a57d83e0e4e6eea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad76741bca51d169d0e167223435bcc08fc2a3af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad76741bca51d169d0e167223435bcc08fc2a3af", "html_url": "https://github.com/rust-lang/rust/commit/ad76741bca51d169d0e167223435bcc08fc2a3af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad76741bca51d169d0e167223435bcc08fc2a3af/comments", "author": {"login": "dlukes", "id": 2734517, "node_id": "MDQ6VXNlcjI3MzQ1MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2734517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlukes", "html_url": "https://github.com/dlukes", "followers_url": "https://api.github.com/users/dlukes/followers", "following_url": "https://api.github.com/users/dlukes/following{/other_user}", "gists_url": "https://api.github.com/users/dlukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlukes/subscriptions", "organizations_url": "https://api.github.com/users/dlukes/orgs", "repos_url": "https://api.github.com/users/dlukes/repos", "events_url": "https://api.github.com/users/dlukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dlukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dlukes", "id": 2734517, "node_id": "MDQ6VXNlcjI3MzQ1MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2734517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlukes", "html_url": "https://github.com/dlukes", "followers_url": "https://api.github.com/users/dlukes/followers", "following_url": "https://api.github.com/users/dlukes/following{/other_user}", "gists_url": "https://api.github.com/users/dlukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlukes/subscriptions", "organizations_url": "https://api.github.com/users/dlukes/orgs", "repos_url": "https://api.github.com/users/dlukes/repos", "events_url": "https://api.github.com/users/dlukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dlukes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d012d52b4da4286932a43587d8072d149dc9454a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d012d52b4da4286932a43587d8072d149dc9454a", "html_url": "https://github.com/rust-lang/rust/commit/d012d52b4da4286932a43587d8072d149dc9454a"}], "stats": {"total": 384, "additions": 238, "deletions": 146}, "files": [{"sha": "02e9b2d107836532d1643e5ec9feb53fad97581f", "filename": "src/config/config_type.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ad76741bca51d169d0e167223435bcc08fc2a3af/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad76741bca51d169d0e167223435bcc08fc2a3af/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=ad76741bca51d169d0e167223435bcc08fc2a3af", "patch": "@@ -78,6 +78,9 @@ macro_rules! create_config {\n \n         #[derive(Clone)]\n         pub struct Config {\n+            // if a license_template_path has been specified, successfully read, parsed and compiled\n+            // into a regex, it will be stored here\n+            pub license_template: Option<Regex>,\n             // For each config item, we store a bool indicating whether it has\n             // been accessed and the value, and a bool whether the option was\n             // manually initialised, or taken from the default,\n@@ -118,8 +121,10 @@ macro_rules! create_config {\n             $(\n             pub fn $i(&mut self, value: $ty) {\n                 (self.0).$i.2 = value;\n-                if stringify!($i) == \"use_small_heuristics\" {\n-                    self.0.set_heuristics();\n+                match stringify!($i) {\n+                    \"use_small_heuristics\" => self.0.set_heuristics(),\n+                    \"license_template_path\" => self.0.set_license_template(),\n+                    &_ => (),\n                 }\n             }\n             )+\n@@ -189,6 +194,7 @@ macro_rules! create_config {\n                 }\n             )+\n                 self.set_heuristics();\n+                self.set_license_template();\n                 self\n             }\n \n@@ -276,8 +282,10 @@ macro_rules! create_config {\n                     _ => panic!(\"Unknown config key in override: {}\", key)\n                 }\n \n-                if key == \"use_small_heuristics\" {\n-                    self.set_heuristics();\n+                match key {\n+                    \"use_small_heuristics\" => self.set_heuristics(),\n+                    \"license_template_path\" => self.set_license_template(),\n+                    &_ => (),\n                 }\n             }\n \n@@ -382,12 +390,50 @@ macro_rules! create_config {\n                     self.set().width_heuristics(WidthHeuristics::null());\n                 }\n             }\n+\n+            fn set_license_template(&mut self) {\n+                let license_template_path = self.license_template_path();\n+                let mut license_template_file = match File::open(&license_template_path) {\n+                    Ok(file) => file,\n+                    Err(e) => {\n+                        eprintln!(\"Warning: unable to open license template file {:?}: {}\",\n+                                  license_template_path, e);\n+                        return;\n+                    }\n+                };\n+                let mut license_template_str = String::new();\n+                match license_template_file.read_to_string(&mut license_template_str) {\n+                    Ok(_) => (),\n+                    Err(e) => {\n+                        eprintln!(\"Warning: unable to read from license template file {:?}: {}\",\n+                                  license_template_path, e);\n+                        return;\n+                    }\n+                }\n+                let license_template_parsed = match parse_license_template(&license_template_str) {\n+                    Ok(string) => string,\n+                    Err(e) => {\n+                        eprintln!(\"Warning: unable to parse license template file {:?}: {}\",\n+                                  license_template_path, e);\n+                        return;\n+                    }\n+                };\n+                self.license_template = match Regex::new(&license_template_parsed) {\n+                    Ok(re) => Some(re),\n+                    Err(e) => {\n+                        eprintln!(\"Warning: regex syntax error in placeholder, unable to compile \\\n+                                   license template from file {:?}: {}\", license_template_path, e);\n+                        return;\n+                    }\n+                }\n+            }\n         }\n \n         // Template for the default configuration\n         impl Default for Config {\n             fn default() -> Config {\n                 Config {\n+                    license_template: None,\n                     $(\n                         $i: (Cell::new(false), false, $def, $stb),\n                     )+"}, {"sha": "53078716414fa3215f0c5e21eb6927a507f293db", "filename": "src/config/mod.rs", "status": "modified", "additions": 177, "deletions": 2, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/ad76741bca51d169d0e167223435bcc08fc2a3af/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad76741bca51d169d0e167223435bcc08fc2a3af/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=ad76741bca51d169d0e167223435bcc08fc2a3af", "patch": "@@ -15,6 +15,8 @@ use std::fs::File;\n use std::io::{Error, ErrorKind, Read};\n use std::path::{Path, PathBuf};\n \n+use regex::Regex;\n+\n #[macro_use]\n mod config_type;\n #[macro_use]\n@@ -50,7 +52,7 @@ create_config! {\n     comment_width: usize, 80, false,\n         \"Maximum length of comments. No effect unless wrap_comments = true\";\n     normalize_comments: bool, false, true, \"Convert /* */ comments to // comments where possible\";\n-    license_template: String, String::default(), false, \"Check for license\";\n+    license_template_path: String, String::default(), false, \"Beginning of file must match license template\";\n \n     // Single line expressions and items.\n     empty_item_single_line: bool, true, false,\n@@ -172,9 +174,145 @@ pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n     Ok(None)\n }\n \n+/// Convert the license template into a string which can be turned into a regex.\n+///\n+/// The license template could use regex syntax directly, but that would require a lot of manual\n+/// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n+/// subparts delimited by `{` and `}`. Additionally:\n+///\n+/// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n+/// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n+///\n+/// This function parses this input format and builds a properly escaped *string* representation of\n+/// the equivalent regular expression. It **does not** however guarantee that the returned string is\n+/// a syntactically valid regular expression.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// assert_eq!(\n+///     rustfmt_config::parse_license_template(\n+///         r\"\n+/// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n+/// // file at the top-level directory of this distribution and at\n+/// // {}.\n+/// //\n+/// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+/// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+/// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+/// // option. This file may not be copied, modified, or distributed\n+/// // except according to those terms.\n+/// \"\n+///     ).unwrap(),\n+///     r\"^\n+/// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n+/// // file at the top\\-level directory of this distribution and at\n+/// // .*?\\.\n+/// //\n+/// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n+/// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n+/// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n+/// // option\\. This file may not be copied, modified, or distributed\n+/// // except according to those terms\\.\n+/// \"\n+/// );\n+/// ```\n+pub fn parse_license_template(template: &str) -> Result<String, String> {\n+    // the template is parsed using a state machine\n+    enum State {\n+        Lit,\n+        LitEsc,\n+        // the u32 keeps track of brace nesting\n+        Re(u32),\n+        ReEsc(u32),\n+    }\n+\n+    let mut parsed = String::from(\"^\");\n+    let mut buffer = String::new();\n+    let mut state = State::Lit;\n+    let mut linum = 1;\n+    // keeps track of last line on which a regex placeholder was started\n+    let mut open_brace_line = 0;\n+    for chr in template.chars() {\n+        if chr == '\\n' {\n+            linum += 1;\n+        }\n+        state = match state {\n+            State::Lit => match chr {\n+                '{' => {\n+                    parsed.push_str(&regex::escape(&buffer));\n+                    buffer.clear();\n+                    open_brace_line = linum;\n+                    State::Re(1)\n+                }\n+                '}' => return Err(format!(\"escape or balance closing brace on l. {}\", linum)),\n+                '\\\\' => State::LitEsc,\n+                _ => {\n+                    buffer.push(chr);\n+                    State::Lit\n+                }\n+            },\n+            State::LitEsc => {\n+                buffer.push(chr);\n+                State::Lit\n+            }\n+            State::Re(brace_nesting) => {\n+                match chr {\n+                    '{' => {\n+                        buffer.push(chr);\n+                        State::Re(brace_nesting + 1)\n+                    }\n+                    '}' => {\n+                        match brace_nesting {\n+                            1 => {\n+                                // default regex for empty placeholder {}\n+                                if buffer.is_empty() {\n+                                    buffer = \".*?\".to_string();\n+                                }\n+                                parsed.push_str(&buffer);\n+                                buffer.clear();\n+                                State::Lit\n+                            }\n+                            _ => {\n+                                buffer.push(chr);\n+                                State::Re(brace_nesting - 1)\n+                            }\n+                        }\n+                    }\n+                    '\\\\' => {\n+                        buffer.push(chr);\n+                        State::ReEsc(brace_nesting)\n+                    }\n+                    _ => {\n+                        buffer.push(chr);\n+                        State::Re(brace_nesting)\n+                    }\n+                }\n+            }\n+            State::ReEsc(brace_nesting) => {\n+                buffer.push(chr);\n+                State::Re(brace_nesting)\n+            }\n+        }\n+    }\n+    match state {\n+        State::Re(_) | State::ReEsc(_) => {\n+            return Err(format!(\n+                \"escape or balance opening brace on l. {}\",\n+                open_brace_line\n+            ));\n+        }\n+        State::LitEsc => return Err(format!(\"incomplete escape sequence on l. {}\", linum)),\n+        _ => (),\n+    }\n+    parsed.push_str(&regex::escape(&buffer));\n+\n+    Ok(parsed)\n+}\n+\n #[cfg(test)]\n mod test {\n-    use super::Config;\n+    use super::{parse_license_template, Config};\n \n     #[test]\n     fn test_config_set() {\n@@ -211,6 +349,43 @@ mod test {\n         assert_eq!(config.was_set().verbose(), false);\n     }\n \n+    #[test]\n+    fn test_parse_license_template() {\n+        assert_eq!(\n+            parse_license_template(\"literal (.*)\").unwrap(),\n+            r\"^literal \\(\\.\\*\\)\"\n+        );\n+        assert_eq!(\n+            parse_license_template(r\"escaping \\}\").unwrap(),\n+            r\"^escaping \\}\"\n+        );\n+        assert!(parse_license_template(\"unbalanced } without escape\").is_err());\n+        assert_eq!(\n+            parse_license_template(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n+            r\"^\\d+ place-?holders?\"\n+        );\n+        assert_eq!(\n+            parse_license_template(\"default {}\").unwrap(),\n+            \"^default .*?\"\n+        );\n+        assert_eq!(\n+            parse_license_template(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n+            r\"^unbalanced nested braces \\{{3}\"\n+        );\n+        assert_eq!(\n+            parse_license_template(\"parsing error }\").unwrap_err(),\n+            \"escape or balance closing brace on l. 1\"\n+        );\n+        assert_eq!(\n+            parse_license_template(\"parsing error {\\nsecond line\").unwrap_err(),\n+            \"escape or balance opening brace on l. 1\"\n+        );\n+        assert_eq!(\n+            parse_license_template(r\"parsing error \\\").unwrap_err(),\n+            \"incomplete escape sequence on l. 1\"\n+        );\n+    }\n+\n     // FIXME(#2183) these tests cannot be run in parallel because they use env vars\n     // #[test]\n     // fn test_as_not_nightly_channel() {"}, {"sha": "e53f8bfb90762afda4e0d940932eb1f2eadd4bf7", "filename": "src/lib.rs", "status": "modified", "additions": 11, "deletions": 140, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ad76741bca51d169d0e167223435bcc08fc2a3af/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad76741bca51d169d0e167223435bcc08fc2a3af/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ad76741bca51d169d0e167223435bcc08fc2a3af", "patch": "@@ -43,7 +43,6 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, FilePathMapping};\n pub use syntax::codemap::FileName;\n use syntax::parse::{self, ParseSess};\n-use regex::Regex;\n \n use checkstyle::{output_footer, output_header};\n use comment::{CharClasses, FullCodeCharKind};\n@@ -102,8 +101,6 @@ pub enum ErrorKind {\n     BadIssue(Issue),\n     // License check has failed\n     LicenseCheck,\n-    // License template could not be parsed\n-    ParsingLicense,\n }\n \n impl fmt::Display for ErrorKind {\n@@ -117,7 +114,6 @@ impl fmt::Display for ErrorKind {\n             ErrorKind::TrailingWhitespace => write!(fmt, \"left behind trailing whitespace\"),\n             ErrorKind::BadIssue(issue) => write!(fmt, \"found {}\", issue),\n             ErrorKind::LicenseCheck => write!(fmt, \"license check failed\"),\n-            ErrorKind::ParsingLicense => write!(fmt, \"parsing regex in license template failed\"),\n         }\n     }\n }\n@@ -136,8 +132,7 @@ impl FormattingError {\n         match self.kind {\n             ErrorKind::LineOverflow(..)\n             | ErrorKind::TrailingWhitespace\n-            | ErrorKind::LicenseCheck\n-            | ErrorKind::ParsingLicense => \"error:\",\n+            | ErrorKind::LicenseCheck => \"error:\",\n             ErrorKind::BadIssue(_) => \"WARNING:\",\n         }\n     }\n@@ -415,82 +410,6 @@ fn should_report_error(\n     }\n }\n \n-fn check_license(text: &str, license_template: &str) -> Result<bool, regex::Error> {\n-    // the template is parsed using a state machine\n-    enum State {\n-        Lit,\n-        LitEsc,\n-        // the u32 keeps track of brace nesting\n-        Re(u32),\n-        ReEsc(u32),\n-    }\n-\n-    let mut template_re = String::from(\"^\");\n-    let mut buffer = String::new();\n-    let mut state = State::Lit;\n-    for chr in license_template.chars() {\n-        state = match state {\n-            State::Lit => match chr {\n-                '{' => {\n-                    template_re.push_str(&regex::escape(&buffer));\n-                    buffer.clear();\n-                    State::Re(1)\n-                }\n-                '}' => panic!(\"license template syntax error\"),\n-                '\\\\' => State::LitEsc,\n-                _ => {\n-                    buffer.push(chr);\n-                    State::Lit\n-                }\n-            },\n-            State::LitEsc => {\n-                buffer.push(chr);\n-                State::Lit\n-            }\n-            State::Re(brace_nesting) => {\n-                match chr {\n-                    '{' => {\n-                        buffer.push(chr);\n-                        State::Re(brace_nesting + 1)\n-                    }\n-                    '}' => {\n-                        match brace_nesting {\n-                            1 => {\n-                                // default regex for empty placeholder {}\n-                                if buffer.is_empty() {\n-                                    buffer = \".*?\".to_string();\n-                                }\n-                                template_re.push_str(&buffer);\n-                                buffer.clear();\n-                                State::Lit\n-                            }\n-                            _ => {\n-                                buffer.push(chr);\n-                                State::Re(brace_nesting - 1)\n-                            }\n-                        }\n-                    }\n-                    '\\\\' => {\n-                        buffer.push(chr);\n-                        State::ReEsc(brace_nesting)\n-                    }\n-                    _ => {\n-                        buffer.push(chr);\n-                        State::Re(brace_nesting)\n-                    }\n-                }\n-            }\n-            State::ReEsc(brace_nesting) => {\n-                buffer.push(chr);\n-                State::Re(brace_nesting)\n-            }\n-        }\n-    }\n-    template_re.push_str(&regex::escape(&buffer));\n-    let template_re = Regex::new(&template_re)?;\n-    Ok(template_re.is_match(text))\n-}\n-\n // Formatting done on a char by char or line by line basis.\n // FIXME(#20) other stuff for parity with make tidy\n fn format_lines(\n@@ -513,28 +432,15 @@ fn format_lines(\n     let allow_issue_seek = !issue_seeker.is_disabled();\n \n     // Check license.\n-    if config.was_set().license_template() {\n-        match check_license(text, &config.license_template()) {\n-            Ok(check) => {\n-                if !check {\n-                    errors.push(FormattingError {\n-                        line: cur_line,\n-                        kind: ErrorKind::LicenseCheck,\n-                        is_comment: false,\n-                        is_string: false,\n-                        line_buffer: String::new(),\n-                    });\n-                }\n-            }\n-            Err(_) => {\n-                errors.push(FormattingError {\n-                    line: cur_line,\n-                    kind: ErrorKind::ParsingLicense,\n-                    is_comment: false,\n-                    is_string: false,\n-                    line_buffer: String::new(),\n-                });\n-            }\n+    if let Some(ref license_template) = config.license_template {\n+        if !license_template.is_match(text) {\n+            errors.push(FormattingError {\n+                line: cur_line,\n+                kind: ErrorKind::LicenseCheck,\n+                is_comment: false,\n+                is_string: false,\n+                line_buffer: String::new(),\n+            });\n         }\n     }\n \n@@ -964,7 +870,7 @@ pub fn run(input: Input, config: &Config) -> Summary {\n \n #[cfg(test)]\n mod test {\n-    use super::{check_license, format_code_block, format_snippet, Config};\n+    use super::{format_code_block, format_snippet, Config};\n \n     #[test]\n     fn test_no_panic_on_format_snippet_and_format_code_block() {\n@@ -1050,39 +956,4 @@ false,\n };\";\n         assert!(test_format_inner(format_code_block, code_block, expected));\n     }\n-\n-    #[test]\n-    fn test_check_license() {\n-        assert!(check_license(\"literal matching\", \"literal matching\").unwrap());\n-        assert!(!check_license(\"literal no match\", \"literal matching\").unwrap());\n-        assert!(\n-            check_license(\n-                \"Regex start and end: 2018\",\n-                r\"{[Rr]egex} start {} end: {\\d+}\"\n-            ).unwrap()\n-        );\n-        assert!(!check_license(\n-            \"Regex start and end no match: 2018\",\n-            r\"{[Rr]egex} start {} end: {\\d+}\"\n-        ).unwrap());\n-        assert!(\n-            check_license(\n-                \"Regex in the middle: 2018 (tm)\",\n-                r\"Regex {} middle: {\\d+} (tm)\"\n-            ).unwrap()\n-        );\n-        assert!(!check_license(\n-            \"Regex in the middle no match: 2018 (tm)\",\n-            r\"Regex {} middle: {\\d+} (tm)\"\n-        ).unwrap());\n-        assert!(!check_license(\"default doesn't match\\nacross lines\", \"default {} lines\").unwrap());\n-        assert!(check_license(\"\", \"this is not a valid {[regex}\").is_err());\n-        assert!(\n-            check_license(\n-                \"parse unbalanced nested delimiters{{{\",\n-                r\"parse unbalanced nested delimiters{\\{{3}}\"\n-            ).unwrap()\n-        );\n-        assert!(check_license(\"escaping }\", r\"escaping \\}\").unwrap());\n-    }\n }"}]}