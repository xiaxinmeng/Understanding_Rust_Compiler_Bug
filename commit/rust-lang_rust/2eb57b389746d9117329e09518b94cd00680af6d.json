{"sha": "2eb57b389746d9117329e09518b94cd00680af6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYjU3YjM4OTc0NmQ5MTE3MzI5ZTA5NTE4Yjk0Y2QwMDY4MGFmNmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-02-24T23:48:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-24T23:48:57Z"}, "message": "Merge pull request #2486 from topecongiro/lazy_statics\n\nFormat `lazy_static!`", "tree": {"sha": "f7c4f2ee3ff283089929cc9a5d14ba9b3f9c4048", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7c4f2ee3ff283089929cc9a5d14ba9b3f9c4048"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eb57b389746d9117329e09518b94cd00680af6d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJakfnpCRBK7hj4Ov3rIwAAdHIIAATZz17dgP5/tXnU82Lo/iLv\nWi3/rvcvjjw/ISisxZ39XSd3yivry2ev1cfXRwo3pOtrVv+1TpkGIClVF1uXthiu\n0ATVhsW4MFt495q436RzujjLgx46564hPEAPj9UdZ/RIXaoO/Yhm6Pup+iAJtlWF\n84neqaNzsva+VFKmeK3Mz+ZSMZfD9Xsd6B4T3OuftvZhbhz8qczh3Din4RrbX6N2\nTlNicIJOcy7KX779yCnl43dWvTwknbZ74jTkf+7mutdYm8Wf5Rq4gezCPFYzdoIB\nUPcDt6YJnLNg1bDOp3P13iPr4eNT8bmX+tqhL1nXwbwmzSRzNMaIFc3tUTINZsY=\n=XOXb\n-----END PGP SIGNATURE-----\n", "payload": "tree f7c4f2ee3ff283089929cc9a5d14ba9b3f9c4048\nparent fd774dbba3068b5915ebb8d216a34a63bc974121\nparent b080e79a2fdb3c52ad76197eec9278ea0b3b40d0\nauthor Nick Cameron <nrc@ncameron.org> 1519516137 +1300\ncommitter GitHub <noreply@github.com> 1519516137 +1300\n\nMerge pull request #2486 from topecongiro/lazy_statics\n\nFormat `lazy_static!`"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb57b389746d9117329e09518b94cd00680af6d", "html_url": "https://github.com/rust-lang/rust/commit/2eb57b389746d9117329e09518b94cd00680af6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eb57b389746d9117329e09518b94cd00680af6d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd774dbba3068b5915ebb8d216a34a63bc974121", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd774dbba3068b5915ebb8d216a34a63bc974121", "html_url": "https://github.com/rust-lang/rust/commit/fd774dbba3068b5915ebb8d216a34a63bc974121"}, {"sha": "b080e79a2fdb3c52ad76197eec9278ea0b3b40d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b080e79a2fdb3c52ad76197eec9278ea0b3b40d0", "html_url": "https://github.com/rust-lang/rust/commit/b080e79a2fdb3c52ad76197eec9278ea0b3b40d0"}], "stats": {"total": 170, "additions": 166, "deletions": 4}, "files": [{"sha": "6d65cd76eba0858ac3c03023bde280e891772d7f", "filename": "rustfmt-core/src/macros.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fmacros.rs?ref=2eb57b389746d9117329e09518b94cd00680af6d", "patch": "@@ -155,7 +155,8 @@ pub fn rewrite_macro(\n     };\n \n     let ts: TokenStream = mac.node.stream();\n-    if ts.is_empty() && !contains_comment(context.snippet(mac.span)) {\n+    let has_comment = contains_comment(context.snippet(mac.span));\n+    if ts.is_empty() && !has_comment {\n         return match style {\n             MacroStyle::Parens if position == MacroPosition::Item => {\n                 Some(format!(\"{}();\", macro_name))\n@@ -165,6 +166,13 @@ pub fn rewrite_macro(\n             MacroStyle::Braces => Some(format!(\"{}{{}}\", macro_name)),\n         };\n     }\n+    // Format well-known macros which cannot be parsed as a valid AST.\n+    // TODO: Maybe add more macros?\n+    if macro_name == \"lazy_static!\" && !has_comment {\n+        if let success @ Some(..) = format_lazy_static(context, shape, &ts) {\n+            return success;\n+        }\n+    }\n \n     let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n     let mut arg_vec = Vec::new();\n@@ -848,6 +856,82 @@ impl MacroBranch {\n     }\n }\n \n+/// Format `lazy_static!` from https://crates.io/crates/lazy_static.\n+///\n+/// # Expected syntax\n+///\n+/// ```\n+/// lazy_static! {\n+///     [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n+///     [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n+///     ...\n+///     [pub] static ref NAME_N: TYPE_N = EXPR_N;\n+/// }\n+/// ```\n+fn format_lazy_static(context: &RewriteContext, shape: Shape, ts: &TokenStream) -> Option<String> {\n+    let mut result = String::with_capacity(1024);\n+    let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n+    let nested_shape = shape.block_indent(context.config.tab_spaces());\n+\n+    result.push_str(\"lazy_static! {\");\n+    result.push_str(&nested_shape.indent.to_string_with_newline(context.config));\n+\n+    macro parse_or($method:ident $(,)* $($arg:expr),* $(,)*) {\n+        match parser.$method($($arg,)*) {\n+            Ok(val) => {\n+                if parser.sess.span_diagnostic.has_errors() {\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                    return None;\n+                } else {\n+                    val\n+                }\n+            }\n+            Err(mut err) => {\n+                err.cancel();\n+                parser.sess.span_diagnostic.reset_err_count();\n+                return None;\n+            }\n+        }\n+    }\n+\n+    while parser.token != Token::Eof {\n+        // Parse a `lazy_static!` item.\n+        let vis = ::utils::format_visibility(&parse_or!(parse_visibility, false));\n+        parser.eat_keyword(symbol::keywords::Static);\n+        parser.eat_keyword(symbol::keywords::Ref);\n+        let id = parse_or!(parse_ident);\n+        parser.eat(&Token::Colon);\n+        let ty = parse_or!(parse_ty);\n+        parser.eat(&Token::Eq);\n+        let expr = parse_or!(parse_expr);\n+        parser.eat(&Token::Semi);\n+\n+        // Rewrite as a static item.\n+        let mut stmt = String::with_capacity(128);\n+        stmt.push_str(&format!(\n+            \"{}static ref {}: {} =\",\n+            vis,\n+            id,\n+            ty.rewrite(context, shape)?\n+        ));\n+        result.push_str(&::expr::rewrite_assign_rhs(\n+            context,\n+            stmt,\n+            &*expr,\n+            nested_shape.sub_width(1)?,\n+        )?);\n+        result.push(';');\n+        if parser.token != Token::Eof {\n+            result.push_str(&nested_shape.indent.to_string_with_newline(context.config));\n+        }\n+    }\n+\n+    result.push_str(&shape.indent.to_string_with_newline(context.config));\n+    result.push('}');\n+\n+    Some(result)\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "aab37b91d55c8ad429209e005bd43c4720f2b601", "filename": "rustfmt-core/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Ftests%2Flib.rs?ref=2eb57b389746d9117329e09518b94cd00680af6d", "patch": "@@ -623,8 +623,10 @@ impl ConfigurationSection {\n         file: &mut Enumerate<I>,\n     ) -> Option<ConfigurationSection> {\n         lazy_static! {\n-            static ref CONFIG_NAME_REGEX: regex::Regex = regex::Regex::new(r\"^## `([^`]+)`\").expect(\"Failed creating configuration pattern\");\n-            static ref CONFIG_VALUE_REGEX: regex::Regex = regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#).expect(\"Failed creating configuration value pattern\");\n+            static ref CONFIG_NAME_REGEX: regex::Regex =\n+                regex::Regex::new(r\"^## `([^`]+)`\").expect(\"Failed creating configuration pattern\");\n+            static ref CONFIG_VALUE_REGEX: regex::Regex = regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#)\n+                .expect(\"Failed creating configuration value pattern\");\n         }\n \n         loop {"}, {"sha": "c1c74fb830753955e33645072060b335300ee219", "filename": "rustfmt-core/tests/source/lazy_static.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Ftests%2Fsource%2Flazy_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Ftests%2Fsource%2Flazy_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Ftests%2Fsource%2Flazy_static.rs?ref=2eb57b389746d9117329e09518b94cd00680af6d", "patch": "@@ -0,0 +1,37 @@\n+// Format `lazy_static!`.\n+\n+lazy_static! {\n+static ref CONFIG_NAME_REGEX: regex::Regex =\n+regex::Regex::new(r\"^## `([^`]+)`\").expect(\"Failed creating configuration pattern\");\n+static ref CONFIG_VALUE_REGEX: regex::Regex = regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#)\n+.expect(\"Failed creating configuration value pattern\");\n+}\n+\n+// We need to be able to format `lazy_static!` without known syntax.\n+lazy_static!(\n+    xxx,\n+yyyy ,\n+    zzzzz\n+);\n+\n+lazy_static!{\n+}\n+\n+// #2354\n+lazy_static ! {\n+pub static ref Sbase64_encode_string : :: lisp :: LispSubrRef = {\n+let subr = :: remacs_sys :: Lisp_Subr {\n+header : :: remacs_sys :: Lisp_Vectorlike_Header {\n+size : (\n+( :: remacs_sys :: PseudovecType :: PVEC_SUBR as :: libc :: ptrdiff_t ) << ::\n+remacs_sys :: PSEUDOVECTOR_AREA_BITS ) , } , function : self ::\n+Fbase64_encode_string as * const :: libc :: c_void , min_args : 1i16 ,\n+max_args : 2i16 , symbol_name : ( b\"base64-encode-string\\x00\" ) . as_ptr (  )\n+as * const :: libc :: c_char , intspec : :: std :: ptr :: null (  ) , doc : ::\n+std :: ptr :: null (  ) , lang : :: remacs_sys :: Lisp_Subr_Lang_Rust , } ;\n+unsafe {\n+let ptr = :: remacs_sys :: xmalloc (\n+:: std :: mem :: size_of :: < :: remacs_sys :: Lisp_Subr > (  ) ) as * mut ::\n+remacs_sys :: Lisp_Subr ; :: std :: ptr :: copy_nonoverlapping (\n+& subr , ptr , 1 ) ; :: std :: mem :: forget ( subr ) ; :: lisp :: ExternalPtr\n+:: new ( ptr ) } } ; }"}, {"sha": "edce6e7b8945320a0bbf42ada842eb4de5ff449f", "filename": "rustfmt-core/tests/target/lazy_static.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Ftests%2Ftarget%2Flazy_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Ftests%2Ftarget%2Flazy_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Ftests%2Ftarget%2Flazy_static.rs?ref=2eb57b389746d9117329e09518b94cd00680af6d", "patch": "@@ -0,0 +1,39 @@\n+// Format `lazy_static!`.\n+\n+lazy_static! {\n+    static ref CONFIG_NAME_REGEX: regex::Regex =\n+        regex::Regex::new(r\"^## `([^`]+)`\").expect(\"Failed creating configuration pattern\");\n+    static ref CONFIG_VALUE_REGEX: regex::Regex = regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#)\n+        .expect(\"Failed creating configuration value pattern\");\n+}\n+\n+// We need to be able to format `lazy_static!` without known syntax.\n+lazy_static!(xxx, yyyy, zzzzz);\n+\n+lazy_static!{}\n+\n+// #2354\n+lazy_static! {\n+    pub static ref Sbase64_encode_string: ::lisp::LispSubrRef = {\n+        let subr = ::remacs_sys::Lisp_Subr {\n+            header: ::remacs_sys::Lisp_Vectorlike_Header {\n+                size: ((::remacs_sys::PseudovecType::PVEC_SUBR as ::libc::ptrdiff_t)\n+                    << ::remacs_sys::PSEUDOVECTOR_AREA_BITS),\n+            },\n+            function: self::Fbase64_encode_string as *const ::libc::c_void,\n+            min_args: 1i16,\n+            max_args: 2i16,\n+            symbol_name: (b\"base64-encode-string\\x00\").as_ptr() as *const ::libc::c_char,\n+            intspec: ::std::ptr::null(),\n+            doc: ::std::ptr::null(),\n+            lang: ::remacs_sys::Lisp_Subr_Lang_Rust,\n+        };\n+        unsafe {\n+            let ptr = ::remacs_sys::xmalloc(::std::mem::size_of::<::remacs_sys::Lisp_Subr>())\n+                as *mut ::remacs_sys::Lisp_Subr;\n+            ::std::ptr::copy_nonoverlapping(&subr, ptr, 1);\n+            ::std::mem::forget(subr);\n+            ::lisp::ExternalPtr::new(ptr)\n+        }\n+    };\n+}"}, {"sha": "6b84ff2cea0733445ee20c32988394146d6378e0", "filename": "rustfmt-core/tests/target/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Ftests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb57b389746d9117329e09518b94cd00680af6d/rustfmt-core%2Ftests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Ftests%2Ftarget%2Fmacros.rs?ref=2eb57b389746d9117329e09518b94cd00680af6d", "patch": "@@ -207,7 +207,7 @@ fn issue_1921() {\n             acc += 1;\n             acc += 2;\n             acc\n-        }\n+        };\n     }\n }\n "}]}