{"sha": "dd6df0d20ed94b46125e7b2039205674f01c95b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNmRmMGQyMGVkOTRiNDYxMjVlN2IyMDM5MjA1Njc0ZjAxYzk1Yjk=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-11-04T02:42:03Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-11-09T16:10:13Z"}, "message": "Move pretty parsing into Session options\n\nThis allows us to query whether PpmEveryBodyLoops is set during\nexpansion and run the everybody loops pass.", "tree": {"sha": "636993f487790eab872ca5670c07f264ed51dbd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/636993f487790eab872ca5670c07f264ed51dbd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd6df0d20ed94b46125e7b2039205674f01c95b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd6df0d20ed94b46125e7b2039205674f01c95b9", "html_url": "https://github.com/rust-lang/rust/commit/dd6df0d20ed94b46125e7b2039205674f01c95b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd6df0d20ed94b46125e7b2039205674f01c95b9/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "516a817dbde4d834aeccf6fbbdf52bb2164cc20b", "url": "https://api.github.com/repos/rust-lang/rust/commits/516a817dbde4d834aeccf6fbbdf52bb2164cc20b", "html_url": "https://github.com/rust-lang/rust/commit/516a817dbde4d834aeccf6fbbdf52bb2164cc20b"}], "stats": {"total": 580, "additions": 300, "deletions": 280}, "files": [{"sha": "8b157d2b3f4bc3ddb19cbb2fac3058a3ef3e5541", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd6df0d20ed94b46125e7b2039205674f01c95b9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dd6df0d20ed94b46125e7b2039205674f01c95b9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dd6df0d20ed94b46125e7b2039205674f01c95b9", "patch": "@@ -3506,6 +3506,7 @@ dependencies = [\n  \"rustc_mir\",\n  \"rustc_plugin\",\n  \"rustc_plugin_impl\",\n+ \"rustc_resolve\",\n  \"rustc_save_analysis\",\n  \"rustc_target\",\n  \"serialize\","}, {"sha": "4a14960aa69bd8f340083adeb07ee77e5b7a8af0", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/dd6df0d20ed94b46125e7b2039205674f01c95b9/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6df0d20ed94b46125e7b2039205674f01c95b9/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=dd6df0d20ed94b46125e7b2039205674f01c95b9", "patch": "@@ -1,10 +1,13 @@\n //! Contains infrastructure for configuring the compiler, including parsing\n //! command-line options.\n \n+// ignore-tidy-filelength\n+\n use crate::lint;\n use crate::middle::cstore;\n use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n+use crate::hir::map as hir_map;\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -440,6 +443,8 @@ top_level_options!(\n         // `true` if we're emitting JSON blobs about each artifact produced\n         // by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n+\n+        pretty: Option<(PpMode, Option<UserIdentifiedItem>)> [UNTRACKED],\n     }\n );\n \n@@ -621,6 +626,7 @@ impl Default for Options {\n             remap_path_prefix: Vec::new(),\n             edition: DEFAULT_EDITION,\n             json_artifact_notifications: false,\n+            pretty: None,\n         }\n     }\n }\n@@ -2516,6 +2522,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let remap_path_prefix = parse_remap_path_prefix(matches, error_format);\n \n+    let pretty = parse_pretty(matches, &debugging_opts, error_format);\n+\n     Options {\n         crate_types,\n         optimize: opt_level,\n@@ -2546,6 +2554,73 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         remap_path_prefix,\n         edition,\n         json_artifact_notifications,\n+        pretty,\n+    }\n+}\n+\n+fn parse_pretty(\n+    matches: &getopts::Matches,\n+    debugging_opts: &DebuggingOptions,\n+    efmt: ErrorOutputType,\n+) -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n+    let pretty = if debugging_opts.unstable_options {\n+        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+            // stable pretty-print variants only\n+            parse_pretty_inner(efmt, &a, false)\n+        })\n+    } else {\n+        None\n+    };\n+\n+    return if pretty.is_none() {\n+        debugging_opts.unpretty.as_ref().map(|a| {\n+            // extended with unstable pretty-print variants\n+            parse_pretty_inner(efmt, &a, true)\n+        })\n+    } else {\n+        pretty\n+    };\n+\n+    fn parse_pretty_inner(\n+        efmt: ErrorOutputType,\n+        name: &str,\n+        extended: bool,\n+    ) -> (PpMode, Option<UserIdentifiedItem>) {\n+        use PpMode::*;\n+        use PpSourceMode::*;\n+        let mut split = name.splitn(2, '=');\n+        let first = split.next().unwrap();\n+        let opt_second = split.next();\n+        let first = match (first, extended) {\n+            (\"normal\", _) => PpmSource(PpmNormal),\n+            (\"identified\", _) => PpmSource(PpmIdentified),\n+            (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n+            (\"expanded\", _) => PpmSource(PpmExpanded),\n+            (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n+            (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n+            (\"hir\", true) => PpmHir(PpmNormal),\n+            (\"hir,identified\", true) => PpmHir(PpmIdentified),\n+            (\"hir,typed\", true) => PpmHir(PpmTyped),\n+            (\"hir-tree\", true) => PpmHirTree(PpmNormal),\n+            (\"mir\", true) => PpmMir,\n+            (\"mir-cfg\", true) => PpmMirCFG,\n+            _ => {\n+                if extended {\n+                    early_error(efmt, &format!(\"argument to `unpretty` must be one of `normal`, \\\n+                                        `expanded`, `identified`, `expanded,identified`, \\\n+                                        `expanded,hygiene`, `everybody_loops`, \\\n+                                        `hir`, `hir,identified`, `hir,typed`, `hir-tree`, \\\n+                                        `mir` or `mir-cfg`; got {}\",\n+                                        name));\n+                } else {\n+                    early_error(efmt, &format!(\"argument to `pretty` must be one of `normal`, \\\n+                                        `expanded`, `identified`, or `expanded,identified`; got {}\",\n+                                        name));\n+                }\n+            }\n+        };\n+        let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n+        (first, opt_second)\n     }\n }\n \n@@ -2656,6 +2731,151 @@ impl fmt::Display for CrateType {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum PpSourceMode {\n+    PpmNormal,\n+    PpmEveryBodyLoops,\n+    PpmExpanded,\n+    PpmIdentified,\n+    PpmExpandedIdentified,\n+    PpmExpandedHygiene,\n+    PpmTyped,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum PpMode {\n+    PpmSource(PpSourceMode),\n+    PpmHir(PpSourceMode),\n+    PpmHirTree(PpSourceMode),\n+    PpmMir,\n+    PpmMirCFG,\n+}\n+\n+impl PpMode {\n+    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+        use PpMode::*;\n+        use PpSourceMode::*;\n+        match *self {\n+            PpmSource(PpmNormal) |\n+            PpmSource(PpmEveryBodyLoops) |\n+            PpmSource(PpmIdentified) => opt_uii.is_some(),\n+\n+            PpmSource(PpmExpanded) |\n+            PpmSource(PpmExpandedIdentified) |\n+            PpmSource(PpmExpandedHygiene) |\n+            PpmHir(_) |\n+            PpmHirTree(_) |\n+            PpmMir |\n+            PpmMirCFG => true,\n+            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n+        }\n+    }\n+\n+    pub fn needs_analysis(&self) -> bool {\n+        use PpMode::*;\n+        match *self {\n+            PpmMir | PpmMirCFG => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum UserIdentifiedItem {\n+    ItemViaNode(ast::NodeId),\n+    ItemViaPath(Vec<String>),\n+}\n+\n+impl FromStr for UserIdentifiedItem {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n+        use UserIdentifiedItem::*;\n+        Ok(s.parse()\n+            .map(ast::NodeId::from_u32)\n+            .map(ItemViaNode)\n+            .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n+    }\n+}\n+\n+pub enum NodesMatchingUII<'a> {\n+    NodesMatchingDirect(std::option::IntoIter<ast::NodeId>),\n+    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n+}\n+\n+impl<'a> Iterator for NodesMatchingUII<'a> {\n+    type Item = ast::NodeId;\n+\n+    fn next(&mut self) -> Option<ast::NodeId> {\n+        use NodesMatchingUII::*;\n+        match self {\n+            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n+            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        use NodesMatchingUII::*;\n+        match self {\n+            &NodesMatchingDirect(ref iter) => iter.size_hint(),\n+            &NodesMatchingSuffix(ref iter) => iter.size_hint(),\n+        }\n+    }\n+}\n+\n+impl UserIdentifiedItem {\n+    pub fn reconstructed_input(&self) -> String {\n+        use UserIdentifiedItem::*;\n+        match *self {\n+            ItemViaNode(node_id) => node_id.to_string(),\n+            ItemViaPath(ref parts) => parts.join(\"::\"),\n+        }\n+    }\n+\n+    pub fn all_matching_node_ids<'a, 'hir>(&'a self,\n+                                       map: &'a hir_map::Map<'hir>)\n+                                       -> NodesMatchingUII<'a> {\n+        use UserIdentifiedItem::*;\n+        use NodesMatchingUII::*;\n+        match *self {\n+            ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n+            ItemViaPath(ref parts) => {\n+                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n+            }\n+        }\n+    }\n+\n+    pub fn to_one_node_id(self,\n+                      user_option: &str,\n+                      sess: &Session,\n+                      map: &hir_map::Map<'_>)\n+                      -> ast::NodeId {\n+        let fail_because = |is_wrong_because| -> ast::NodeId {\n+            let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n+                                   {}, which {}\",\n+                                  user_option,\n+                                  self.reconstructed_input(),\n+                                  is_wrong_because);\n+            sess.fatal(&message)\n+        };\n+\n+        let mut saw_node = ast::DUMMY_NODE_ID;\n+        let mut seen = 0;\n+        for node in self.all_matching_node_ids(map) {\n+            saw_node = node;\n+            seen += 1;\n+            if seen > 1 {\n+                fail_because(\"does not resolve uniquely\");\n+            }\n+        }\n+        if seen == 0 {\n+            fail_because(\"does not resolve to any item\");\n+        }\n+\n+        assert!(seen == 1);\n+        return saw_node;\n+    }\n+}\n+\n /// Command-line arguments passed to the compiler have to be incorporated with\n /// the dependency tracking system for incremental compilation. This module\n /// provides some utilities to make this more convenient."}, {"sha": "7973a804f1a460a372b3bbde3ff429c189b8b8a6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dd6df0d20ed94b46125e7b2039205674f01c95b9/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6df0d20ed94b46125e7b2039205674f01c95b9/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=dd6df0d20ed94b46125e7b2039205674f01c95b9", "patch": "@@ -25,8 +25,6 @@ extern crate lazy_static;\n \n pub extern crate rustc_plugin_impl as plugin;\n \n-use pretty::{PpMode, UserIdentifiedItem};\n-\n //use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n@@ -285,19 +283,17 @@ pub fn run_compiler(\n             return sess.compile_status();\n         }\n \n-        let pretty_info = parse_pretty(sess, &matches);\n-\n         compiler.parse()?;\n \n-        if let Some((ppm, opt_uii)) = pretty_info {\n+        if let Some((ppm, opt_uii)) = &sess.opts.pretty {\n             if ppm.needs_ast_map(&opt_uii) {\n                 compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n                     let expanded_crate = compiler.expansion()?.take().0;\n                     pretty::print_after_hir_lowering(\n                         tcx,\n                         compiler.input(),\n                         &expanded_crate,\n-                        ppm,\n+                        *ppm,\n                         opt_uii.clone(),\n                         compiler.output_file().as_ref().map(|p| &**p),\n                     );\n@@ -309,7 +305,7 @@ pub fn run_compiler(\n                     sess,\n                     &compiler.input(),\n                     &krate,\n-                    ppm,\n+                    *ppm,\n                     compiler.output_file().as_ref().map(|p| &**p),\n                 );\n             }\n@@ -468,28 +464,6 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>, Option\n     }\n }\n \n-fn parse_pretty(sess: &Session,\n-                matches: &getopts::Matches)\n-                -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n-    let pretty = if sess.opts.debugging_opts.unstable_options {\n-        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-            // stable pretty-print variants only\n-            pretty::parse_pretty(sess, &a, false)\n-        })\n-    } else {\n-        None\n-    };\n-\n-    if pretty.is_none() {\n-        sess.opts.debugging_opts.unpretty.as_ref().map(|a| {\n-            // extended with unstable pretty-print variants\n-            pretty::parse_pretty(sess, &a, true)\n-        })\n-    } else {\n-        pretty\n-    }\n-}\n-\n // Whether to stop or continue compilation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Compilation {"}, {"sha": "23253dc4dadec9733fa37f5fe2768ea9cfd40f43", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 70, "deletions": 250, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/dd6df0d20ed94b46125e7b2039205674f01c95b9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6df0d20ed94b46125e7b2039205674f01c95b9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=dd6df0d20ed94b46125e7b2039205674f01c95b9", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::print as pprust_hir;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::Session;\n-use rustc::session::config::Input;\n+use rustc::session::config::{PpMode, PpSourceMode, UserIdentifiedItem, Input};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::ErrorReported;\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n@@ -17,103 +17,15 @@ use syntax_pos::FileName;\n use std::cell::Cell;\n use std::fs::File;\n use std::io::Write;\n-use std::option;\n use std::path::Path;\n-use std::str::FromStr;\n \n pub use self::UserIdentifiedItem::*;\n pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n-use self::NodesMatchingUII::*;\n use crate::abort_on_err;\n \n use crate::source_name;\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum PpSourceMode {\n-    PpmNormal,\n-    PpmEveryBodyLoops,\n-    PpmExpanded,\n-    PpmIdentified,\n-    PpmExpandedIdentified,\n-    PpmExpandedHygiene,\n-    PpmTyped,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum PpMode {\n-    PpmSource(PpSourceMode),\n-    PpmHir(PpSourceMode),\n-    PpmHirTree(PpSourceMode),\n-    PpmMir,\n-    PpmMirCFG,\n-}\n-\n-impl PpMode {\n-    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n-        match *self {\n-            PpmSource(PpmNormal) |\n-            PpmSource(PpmEveryBodyLoops) |\n-            PpmSource(PpmIdentified) => opt_uii.is_some(),\n-\n-            PpmSource(PpmExpanded) |\n-            PpmSource(PpmExpandedIdentified) |\n-            PpmSource(PpmExpandedHygiene) |\n-            PpmHir(_) |\n-            PpmHirTree(_) |\n-            PpmMir |\n-            PpmMirCFG => true,\n-            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n-        }\n-    }\n-\n-    pub fn needs_analysis(&self) -> bool {\n-        match *self {\n-            PpmMir | PpmMirCFG => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-pub fn parse_pretty(sess: &Session,\n-                    name: &str,\n-                    extended: bool)\n-                    -> (PpMode, Option<UserIdentifiedItem>) {\n-    let mut split = name.splitn(2, '=');\n-    let first = split.next().unwrap();\n-    let opt_second = split.next();\n-    let first = match (first, extended) {\n-        (\"normal\", _) => PpmSource(PpmNormal),\n-        (\"identified\", _) => PpmSource(PpmIdentified),\n-        (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n-        (\"expanded\", _) => PpmSource(PpmExpanded),\n-        (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n-        (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n-        (\"hir\", true) => PpmHir(PpmNormal),\n-        (\"hir,identified\", true) => PpmHir(PpmIdentified),\n-        (\"hir,typed\", true) => PpmHir(PpmTyped),\n-        (\"hir-tree\", true) => PpmHirTree(PpmNormal),\n-        (\"mir\", true) => PpmMir,\n-        (\"mir-cfg\", true) => PpmMirCFG,\n-        _ => {\n-            if extended {\n-                sess.fatal(&format!(\"argument to `unpretty` must be one of `normal`, \\\n-                                     `expanded`, `identified`, `expanded,identified`, \\\n-                                     `expanded,hygiene`, `everybody_loops`, \\\n-                                     `hir`, `hir,identified`, `hir,typed`, `hir-tree`, \\\n-                                     `mir` or `mir-cfg`; got {}\",\n-                                    name));\n-            } else {\n-                sess.fatal(&format!(\"argument to `pretty` must be one of `normal`, `expanded`, \\\n-                                     `identified`, or `expanded,identified`; got {}\",\n-                                    name));\n-            }\n-        }\n-    };\n-    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n-    (first, opt_second)\n-}\n-\n \n \n // This slightly awkward construction is to allow for each PpMode to\n@@ -129,76 +41,74 @@ pub fn parse_pretty(sess: &Session,\n // (The `use_once_payload` is working around the current lack of once\n // functions in the compiler.)\n \n-impl PpSourceMode {\n-    /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<'tcx, A, F>(\n-        &self,\n-        sess: &'tcx Session,\n-        tcx: Option<TyCtxt<'tcx>>,\n-        f: F,\n-    ) -> A\n-    where\n-        F: FnOnce(&dyn PrinterSupport) -> A,\n-    {\n-        match *self {\n-            PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n-                let annotation = NoAnn {\n-                    sess,\n-                    tcx,\n-                };\n-                f(&annotation)\n-            }\n+/// Constructs a `PrinterSupport` object and passes it to `f`.\n+fn call_with_pp_support<'tcx, A, F>(\n+    ppmode: &PpSourceMode,\n+    sess: &'tcx Session,\n+    tcx: Option<TyCtxt<'tcx>>,\n+    f: F,\n+) -> A\n+where\n+    F: FnOnce(&dyn PrinterSupport) -> A,\n+{\n+    match *ppmode {\n+        PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n+            let annotation = NoAnn {\n+                sess,\n+                tcx,\n+            };\n+            f(&annotation)\n+        }\n \n-            PpmIdentified | PpmExpandedIdentified => {\n-                let annotation = IdentifiedAnnotation {\n-                    sess,\n-                    tcx,\n-                };\n-                f(&annotation)\n-            }\n-            PpmExpandedHygiene => {\n-                let annotation = HygieneAnnotation {\n-                    sess,\n-                };\n-                f(&annotation)\n-            }\n-            _ => panic!(\"Should use call_with_pp_support_hir\"),\n+        PpmIdentified | PpmExpandedIdentified => {\n+            let annotation = IdentifiedAnnotation {\n+                sess,\n+                tcx,\n+            };\n+            f(&annotation)\n+        }\n+        PpmExpandedHygiene => {\n+            let annotation = HygieneAnnotation {\n+                sess,\n+            };\n+            f(&annotation)\n+        }\n+        _ => panic!(\"Should use call_with_pp_support_hir\"),\n+    }\n+}\n+fn call_with_pp_support_hir<A, F>(ppmode: &PpSourceMode, tcx: TyCtxt<'_>, f: F) -> A\n+where\n+    F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n+{\n+    match *ppmode {\n+        PpmNormal => {\n+            let annotation = NoAnn {\n+                sess: tcx.sess,\n+                tcx: Some(tcx),\n+            };\n+            f(&annotation, tcx.hir().forest.krate())\n         }\n-    }\n-    fn call_with_pp_support_hir<A, F>(&self, tcx: TyCtxt<'_>, f: F) -> A\n-    where\n-        F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n-    {\n-        match *self {\n-            PpmNormal => {\n-                let annotation = NoAnn {\n-                    sess: tcx.sess,\n-                    tcx: Some(tcx),\n-                };\n-                f(&annotation, tcx.hir().forest.krate())\n-            }\n \n-            PpmIdentified => {\n-                let annotation = IdentifiedAnnotation {\n-                    sess: tcx.sess,\n-                    tcx: Some(tcx),\n-                };\n+        PpmIdentified => {\n+            let annotation = IdentifiedAnnotation {\n+                sess: tcx.sess,\n+                tcx: Some(tcx),\n+            };\n+            f(&annotation, tcx.hir().forest.krate())\n+        }\n+        PpmTyped => {\n+            abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n+\n+            let empty_tables = ty::TypeckTables::empty(None);\n+            let annotation = TypedAnnotation {\n+                tcx,\n+                tables: Cell::new(&empty_tables)\n+            };\n+            tcx.dep_graph.with_ignore(|| {\n                 f(&annotation, tcx.hir().forest.krate())\n-            }\n-            PpmTyped => {\n-                abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n-\n-                let empty_tables = ty::TypeckTables::empty(None);\n-                let annotation = TypedAnnotation {\n-                    tcx,\n-                    tables: Cell::new(&empty_tables)\n-                };\n-                tcx.dep_graph.with_ignore(|| {\n-                    f(&annotation, tcx.hir().forest.krate())\n-                })\n-            }\n-            _ => panic!(\"Should use call_with_pp_support\"),\n+            })\n         }\n+        _ => panic!(\"Should use call_with_pp_support\"),\n     }\n }\n \n@@ -480,96 +390,6 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub enum UserIdentifiedItem {\n-    ItemViaNode(ast::NodeId),\n-    ItemViaPath(Vec<String>),\n-}\n-\n-impl FromStr for UserIdentifiedItem {\n-    type Err = ();\n-    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n-        Ok(s.parse()\n-            .map(ast::NodeId::from_u32)\n-            .map(ItemViaNode)\n-            .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n-    }\n-}\n-\n-enum NodesMatchingUII<'a> {\n-    NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n-}\n-\n-impl<'a> Iterator for NodesMatchingUII<'a> {\n-    type Item = ast::NodeId;\n-\n-    fn next(&mut self) -> Option<ast::NodeId> {\n-        match self {\n-            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n-            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self {\n-            &NodesMatchingDirect(ref iter) => iter.size_hint(),\n-            &NodesMatchingSuffix(ref iter) => iter.size_hint(),\n-        }\n-    }\n-}\n-\n-impl UserIdentifiedItem {\n-    fn reconstructed_input(&self) -> String {\n-        match *self {\n-            ItemViaNode(node_id) => node_id.to_string(),\n-            ItemViaPath(ref parts) => parts.join(\"::\"),\n-        }\n-    }\n-\n-    fn all_matching_node_ids<'a, 'hir>(&'a self,\n-                                       map: &'a hir_map::Map<'hir>)\n-                                       -> NodesMatchingUII<'a> {\n-        match *self {\n-            ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n-            ItemViaPath(ref parts) => {\n-                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n-            }\n-        }\n-    }\n-\n-    fn to_one_node_id(self,\n-                      user_option: &str,\n-                      sess: &Session,\n-                      map: &hir_map::Map<'_>)\n-                      -> ast::NodeId {\n-        let fail_because = |is_wrong_because| -> ast::NodeId {\n-            let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n-                                   {}, which {}\",\n-                                  user_option,\n-                                  self.reconstructed_input(),\n-                                  is_wrong_because);\n-            sess.fatal(&message)\n-        };\n-\n-        let mut saw_node = ast::DUMMY_NODE_ID;\n-        let mut seen = 0;\n-        for node in self.all_matching_node_ids(map) {\n-            saw_node = node;\n-            seen += 1;\n-            if seen > 1 {\n-                fail_because(\"does not resolve uniquely\");\n-            }\n-        }\n-        if seen == 0 {\n-            fail_because(\"does not resolve to any item\");\n-        }\n-\n-        assert!(seen == 1);\n-        return saw_node;\n-    }\n-}\n-\n fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n     let src_name = source_name(input);\n     let src = String::clone(&sess.source_map()\n@@ -605,7 +425,7 @@ pub fn print_after_parsing(sess: &Session,\n     if let PpmSource(s) = ppm {\n         // Silently ignores an identified node.\n         let out = &mut out;\n-        s.call_with_pp_support(sess, None, move |annotation| {\n+        call_with_pp_support(&s, sess, None, move |annotation| {\n             debug!(\"pretty printing source code {:?}\", s);\n             let sess = annotation.sess();\n             *out = pprust::print_crate(sess.source_map(),\n@@ -650,7 +470,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                 // Silently ignores an identified node.\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support(tcx.sess, Some(tcx), move |annotation| {\n+                call_with_pp_support(&s, tcx.sess, Some(tcx), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     *out = pprust::print_crate(sess.source_map(),\n@@ -666,7 +486,7 @@ pub fn print_after_hir_lowering<'tcx>(\n             (PpmHir(s), None) => {\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support_hir(tcx, move |annotation, krate| {\n+                call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     *out = pprust_hir::print_crate(sess.source_map(),\n@@ -680,7 +500,7 @@ pub fn print_after_hir_lowering<'tcx>(\n \n             (PpmHirTree(s), None) => {\n                 let out = &mut out;\n-                s.call_with_pp_support_hir(tcx, move |_annotation, krate| {\n+                call_with_pp_support_hir(&s, tcx, move |_annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     *out = format!(\"{:#?}\", krate);\n                 });\n@@ -689,7 +509,7 @@ pub fn print_after_hir_lowering<'tcx>(\n             (PpmHir(s), Some(uii)) => {\n                 let out = &mut out;\n                 let src = src.clone();\n-                s.call_with_pp_support_hir(tcx, move |annotation, _| {\n+                call_with_pp_support_hir(&s, tcx, move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let hir_map = annotation.hir_map().expect(\"-Z unpretty missing HIR map\");\n@@ -714,7 +534,7 @@ pub fn print_after_hir_lowering<'tcx>(\n \n             (PpmHirTree(s), Some(uii)) => {\n                 let out = &mut out;\n-                s.call_with_pp_support_hir(tcx, move |_annotation, _krate| {\n+                call_with_pp_support_hir(&s, tcx, move |_annotation, _krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     for node_id in uii.all_matching_node_ids(tcx.hir()) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);"}, {"sha": "04a0b0e761961b9d1d730ab43fc2a7be4ac146c2", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dd6df0d20ed94b46125e7b2039205674f01c95b9/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6df0d20ed94b46125e7b2039205674f01c95b9/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=dd6df0d20ed94b46125e7b2039205674f01c95b9", "patch": "@@ -16,6 +16,7 @@ use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n use rustc::session::Session;\n use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType};\n+use rustc::session::config::{PpMode, PpSourceMode};\n use rustc::session::search_paths::PathKind;\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -394,7 +395,11 @@ fn configure_and_expand_inner<'a>(\n \n     // If we're actually rustdoc then there's no need to actually compile\n     // anything, so switch everything to just looping\n-    if sess.opts.actually_rustdoc {\n+    let mut should_loop = sess.opts.actually_rustdoc;\n+    if let Some((PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops), _)) = sess.opts.pretty {\n+        should_loop |= true;\n+    }\n+    if should_loop {\n         util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }\n "}]}