{"sha": "b07059056463272788042a263b6cf8eb8be2533a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNzA1OTA1NjQ2MzI3Mjc4ODA0MmEyNjNiNmNmOGViOGJlMjUzM2E=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T22:41:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T22:42:23Z"}, "message": "libsyntax: De-export libsyntax. rs=deexporting", "tree": {"sha": "732c24f16156ae8302dde8a54de48aa433cb1803", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/732c24f16156ae8302dde8a54de48aa433cb1803"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b07059056463272788042a263b6cf8eb8be2533a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b07059056463272788042a263b6cf8eb8be2533a", "html_url": "https://github.com/rust-lang/rust/commit/b07059056463272788042a263b6cf8eb8be2533a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b07059056463272788042a263b6cf8eb8be2533a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a80a65b3b7affa9b070785bf2dd34a25aea3932a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a80a65b3b7affa9b070785bf2dd34a25aea3932a", "html_url": "https://github.com/rust-lang/rust/commit/a80a65b3b7affa9b070785bf2dd34a25aea3932a"}], "stats": {"total": 1189, "additions": 579, "deletions": 610}, "files": [{"sha": "e4ad518cc801cdbba76a5f39a2ba0587c5fabcff", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -101,16 +101,13 @@ use core::vec;\n use std::map;\n use std::map::HashMap;\n \n-export expand_auto_encode;\n-export expand_auto_decode;\n-\n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n     pub use ext;\n     pub use parse;\n }\n \n-fn expand_auto_encode(\n+pub fn expand_auto_encode(\n     cx: ext_ctxt,\n     span: span,\n     _mitem: ast::meta_item,\n@@ -165,7 +162,7 @@ fn expand_auto_encode(\n     }\n }\n \n-fn expand_auto_decode(\n+pub fn expand_auto_decode(\n     cx: ext_ctxt,\n     span: span,\n     _mitem: ast::meta_item,"}, {"sha": "d0974e0654c40f492228e6f4338d3caf4a394ba3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -32,38 +32,38 @@ use std::map::HashMap;\n // is now probably a redundant AST node, can be merged with\n // ast::mac_invoc_tt.\n \n-struct MacroDef {\n+pub struct MacroDef {\n     name: ~str,\n     ext: SyntaxExtension\n }\n \n-type ItemDecorator =\n+pub type ItemDecorator =\n     fn@(ext_ctxt, span, ast::meta_item, ~[@ast::item]) -> ~[@ast::item];\n \n-struct SyntaxExpanderTT {\n+pub struct SyntaxExpanderTT {\n     expander: SyntaxExpanderTTFun,\n     span: Option<span>\n }\n \n-type SyntaxExpanderTTFun = fn@(ext_ctxt, span, ~[ast::token_tree])\n-    -> MacResult;\n+pub type SyntaxExpanderTTFun = fn@(ext_ctxt, span, ~[ast::token_tree])\n+                                -> MacResult;\n \n-struct SyntaxExpanderTTItem {\n+pub struct SyntaxExpanderTTItem {\n     expander: SyntaxExpanderTTItemFun,\n     span: Option<span>\n }\n \n-type SyntaxExpanderTTItemFun\n+pub type SyntaxExpanderTTItemFun\n     = fn@(ext_ctxt, span, ast::ident, ~[ast::token_tree]) -> MacResult;\n \n-enum MacResult {\n+pub enum MacResult {\n     MRExpr(@ast::expr),\n     MRItem(@ast::item),\n     MRAny(fn@()-> @ast::expr, fn@()-> Option<@ast::item>, fn@()->@ast::stmt),\n     MRDef(MacroDef)\n }\n \n-enum SyntaxExtension {\n+pub enum SyntaxExtension {\n \n     // #[auto_encode] and such\n     ItemDecorator(ItemDecorator),\n@@ -78,7 +78,7 @@ enum SyntaxExtension {\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-fn syntax_expander_table() -> HashMap<~str, SyntaxExtension> {\n+pub fn syntax_expander_table() -> HashMap<~str, SyntaxExtension> {\n     fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> SyntaxExtension {\n         NormalTT(SyntaxExpanderTT{expander: f, span: None})\n     }\n@@ -161,7 +161,7 @@ fn syntax_expander_table() -> HashMap<~str, SyntaxExtension> {\n // One of these is made during expansion and incrementally updated as we go;\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n-trait ext_ctxt {\n+pub trait ext_ctxt {\n     fn codemap() -> @CodeMap;\n     fn parse_sess() -> parse::parse_sess;\n     fn cfg() -> ast::crate_cfg;\n@@ -187,8 +187,8 @@ trait ext_ctxt {\n     fn ident_of(st: ~str) -> ast::ident;\n }\n \n-fn mk_ctxt(parse_sess: parse::parse_sess,\n-           cfg: ast::crate_cfg) -> ext_ctxt {\n+pub fn mk_ctxt(parse_sess: parse::parse_sess,\n+               cfg: ast::crate_cfg) -> ext_ctxt {\n     type ctxt_repr = {parse_sess: parse::parse_sess,\n                       cfg: ast::crate_cfg,\n                       mut backtrace: Option<@ExpnInfo>,\n@@ -281,7 +281,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n     move ((move imp) as ext_ctxt)\n }\n \n-fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n+pub fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n         ast::lit_str(s) => return *s,\n@@ -291,9 +291,9 @@ fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     }\n }\n \n-fn expr_to_ident(cx: ext_ctxt,\n-                 expr: @ast::expr,\n-                 err_msg: ~str) -> ast::ident {\n+pub fn expr_to_ident(cx: ext_ctxt,\n+                     expr: @ast::expr,\n+                     err_msg: ~str) -> ast::ident {\n     match expr.node {\n       ast::expr_path(p) => {\n         if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n@@ -305,15 +305,17 @@ fn expr_to_ident(cx: ext_ctxt,\n     }\n }\n \n-fn check_zero_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n-                  name: &str) {\n+pub fn check_zero_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n+                      name: &str) {\n     if tts.len() != 0 {\n         cx.span_fatal(sp, fmt!(\"%s takes no arguments\", name));\n     }\n }\n \n-fn get_single_str_from_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n-                           name: &str) -> ~str {\n+pub fn get_single_str_from_tts(cx: ext_ctxt,\n+                               sp: span,\n+                               tts: &[ast::token_tree],\n+                               name: &str) -> ~str {\n     if tts.len() != 1 {\n         cx.span_fatal(sp, fmt!(\"%s takes 1 argument.\", name));\n     }\n@@ -325,8 +327,8 @@ fn get_single_str_from_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n     }\n }\n \n-fn get_exprs_from_tts(cx: ext_ctxt, tts: ~[ast::token_tree])\n-    -> ~[@ast::expr] {\n+pub fn get_exprs_from_tts(cx: ext_ctxt, tts: ~[ast::token_tree])\n+                       -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),\n                                        tts);"}, {"sha": "d4da5a2034e6c64ae838c2ab3448ffa602989abf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 124, "deletions": 110, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -19,7 +19,10 @@ use ext::build;\n use core::dvec;\n use core::option;\n \n-fn mk_expr(cx: ext_ctxt, sp: codemap::span, expr: ast::expr_) -> @ast::expr {\n+pub fn mk_expr(cx: ext_ctxt,\n+               sp: codemap::span,\n+               expr: ast::expr_)\n+            -> @ast::expr {\n     @ast::expr {\n         id: cx.next_id(),\n         callee_id: cx.next_id(),\n@@ -28,161 +31,163 @@ fn mk_expr(cx: ext_ctxt, sp: codemap::span, expr: ast::expr_) -> @ast::expr {\n     }\n }\n \n-fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n+pub fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n     let sp_lit = @ast::spanned { node: lit, span: sp };\n     mk_expr(cx, sp, ast::expr_lit(sp_lit))\n }\n-fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n+pub fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n     let lit = ast::lit_int(i as i64, ast::ty_i);\n     return mk_lit(cx, sp, lit);\n }\n-fn mk_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n+pub fn mk_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u);\n     return mk_lit(cx, sp, lit);\n }\n-fn mk_u8(cx: ext_ctxt, sp: span, u: u8) -> @ast::expr {\n+pub fn mk_u8(cx: ext_ctxt, sp: span, u: u8) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u8);\n     return mk_lit(cx, sp, lit);\n }\n-fn mk_binary(cx: ext_ctxt, sp: span, op: ast::binop,\n-             lhs: @ast::expr, rhs: @ast::expr)\n-   -> @ast::expr {\n+pub fn mk_binary(cx: ext_ctxt, sp: span, op: ast::binop,\n+                 lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_binary(op, lhs, rhs))\n }\n-fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n-    -> @ast::expr {\n+pub fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n+             -> @ast::expr {\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n-fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::path {\n+pub fn mk_raw_path(sp: span, idents: ~[ast::ident]) -> @ast::path {\n     let p = @ast::path { span: sp,\n                          global: false,\n                          idents: idents,\n                          rp: None,\n                          types: ~[] };\n     return p;\n }\n-fn mk_raw_path_(sp: span,\n-                idents: ~[ast::ident],\n-                +types: ~[@ast::Ty])\n-             -> @ast::path {\n+pub fn mk_raw_path_(sp: span,\n+                    idents: ~[ast::ident],\n+                    +types: ~[@ast::Ty])\n+                 -> @ast::path {\n     @ast::path { span: sp,\n                  global: false,\n                  idents: idents,\n                  rp: None,\n                  types: move types }\n }\n-fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::path {\n+pub fn mk_raw_path_global(sp: span, idents: ~[ast::ident]) -> @ast::path {\n     @ast::path { span: sp,\n                  global: true,\n                  idents: idents,\n                  rp: None,\n                  types: ~[] }\n }\n-fn mk_path(cx: ext_ctxt, sp: span, idents: ~[ast::ident]) ->\n-    @ast::expr {\n+pub fn mk_path(cx: ext_ctxt, sp: span, idents: ~[ast::ident]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n }\n-fn mk_path_global(cx: ext_ctxt, sp: span, idents: ~[ast::ident]) ->\n-    @ast::expr {\n+pub fn mk_path_global(cx: ext_ctxt, sp: span, idents: ~[ast::ident])\n+                   -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path_global(sp, idents)))\n }\n-fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n-    -> @ast::expr {\n+pub fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n+               -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n }\n-fn mk_access(cx: ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n-    -> @ast::expr {\n+pub fn mk_access(cx: ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n+              -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n     return mk_access_(cx, sp, pathexpr, m);\n }\n-fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n }\n-fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n-            args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n+                args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, false))\n }\n-fn mk_call(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n-             args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n+               args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n-fn mk_call_global(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n-                  args: ~[@ast::expr]) -> @ast::expr {\n+pub fn mk_call_global(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n+                      args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path_global(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n-fn mk_base_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n-   @ast::expr {\n+pub fn mk_base_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+                  -> @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     mk_expr(cx, sp, vecexpr)\n }\n-fn mk_vstore_e(cx: ext_ctxt, sp: span, expr: @ast::expr,\n-               vst: ast::expr_vstore) ->\n+pub fn mk_vstore_e(cx: ext_ctxt, sp: span, expr: @ast::expr,\n+                   vst: ast::expr_vstore) ->\n    @ast::expr {\n     mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n }\n-fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n-   @ast::expr {\n+pub fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+                  -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n }\n-fn mk_slice_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n-   @ast::expr {\n+pub fn mk_slice_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+                   -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_slice)\n }\n-fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n-   @ast::expr {\n+pub fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+                   -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_fixed(None))\n }\n-fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+pub fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);\n }\n-fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+pub fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n-fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n-    -> ast::field {\n+pub fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n+             -> ast::field {\n     ast::spanned {\n         node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n         span: sp,\n     }\n }\n-fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n-    ~[ast::field] {\n+pub fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}])\n+              -> ~[ast::field] {\n     move fields.map(|f| mk_field(sp, f))\n }\n-fn mk_rec_e(cx: ext_ctxt, sp: span,\n-            fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n-    @ast::expr {\n+pub fn mk_rec_e(cx: ext_ctxt,\n+                sp: span,\n+                fields: ~[{ident: ast::ident, ex: @ast::expr}])\n+             -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_rec(mk_fields(sp, fields),\n                                   option::None::<@ast::expr>))\n }\n-fn mk_struct_e(cx: ext_ctxt, sp: span,\n-               ctor_path: ~[ast::ident],\n-               fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n-    @ast::expr {\n+pub fn mk_struct_e(cx: ext_ctxt,\n+                   sp: span,\n+                   ctor_path: ~[ast::ident],\n+                   fields: ~[{ident: ast::ident, ex: @ast::expr}])\n+                -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path(sp, ctor_path),\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-fn mk_global_struct_e(cx: ext_ctxt, sp: span,\n-               ctor_path: ~[ast::ident],\n-               fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n-    @ast::expr {\n+pub fn mk_global_struct_e(cx: ext_ctxt,\n+                          sp: span,\n+                          ctor_path: ~[ast::ident],\n+                          fields: ~[{ident: ast::ident, ex: @ast::expr}])\n+                       -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-fn mk_glob_use(cx: ext_ctxt, sp: span,\n-               path: ~[ast::ident]) -> @ast::view_item {\n+pub fn mk_glob_use(cx: ext_ctxt,\n+                   sp: span,\n+                   path: ~[ast::ident]) -> @ast::view_item {\n     let glob = @ast::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,\n@@ -192,8 +197,8 @@ fn mk_glob_use(cx: ext_ctxt, sp: span,\n                       vis: ast::private,\n                       span: sp }\n }\n-fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n-            ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n+pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n+                ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n \n     let pat = @ast::pat {\n         id: cx.next_id(),\n@@ -217,10 +222,10 @@ fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n     let decl = ast::spanned {node: ast::decl_local(~[local]), span: sp};\n     @ast::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n-fn mk_block(cx: ext_ctxt, span: span,\n-            view_items: ~[@ast::view_item],\n-            stmts: ~[@ast::stmt],\n-            expr: Option<@ast::expr>) -> @ast::expr {\n+pub fn mk_block(cx: ext_ctxt, span: span,\n+                view_items: ~[@ast::view_item],\n+                stmts: ~[@ast::stmt],\n+                expr: Option<@ast::expr>) -> @ast::expr {\n     let blk = ast::spanned {\n         node: ast::blk_ {\n              view_items: view_items,\n@@ -233,7 +238,10 @@ fn mk_block(cx: ext_ctxt, span: span,\n     };\n     mk_expr(cx, span, ast::expr_block(blk))\n }\n-fn mk_block_(cx: ext_ctxt, span: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n+pub fn mk_block_(cx: ext_ctxt,\n+                 span: span,\n+                 +stmts: ~[@ast::stmt])\n+              -> ast::blk {\n     ast::spanned {\n         node: ast::blk_ {\n             view_items: ~[],\n@@ -245,7 +253,10 @@ fn mk_block_(cx: ext_ctxt, span: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n         span: span,\n     }\n }\n-fn mk_simple_block(cx: ext_ctxt, span: span, expr: @ast::expr) -> ast::blk {\n+pub fn mk_simple_block(cx: ext_ctxt,\n+                       span: span,\n+                       expr: @ast::expr)\n+                    -> ast::blk {\n     ast::spanned {\n         node: ast::blk_ {\n             view_items: ~[],\n@@ -257,80 +268,83 @@ fn mk_simple_block(cx: ext_ctxt, span: span, expr: @ast::expr) -> ast::blk {\n         span: span,\n     }\n }\n-fn mk_copy(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_copy(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n }\n-fn mk_managed(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_managed(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n-fn mk_pat(cx: ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n+pub fn mk_pat(cx: ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n     @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n-fn mk_pat_ident(cx: ext_ctxt, span: span, ident: ast::ident) -> @ast::pat {\n+pub fn mk_pat_ident(cx: ext_ctxt,\n+                    span: span,\n+                    ident: ast::ident)\n+                 -> @ast::pat {\n     mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_value)\n }\n-fn mk_pat_ident_with_binding_mode(cx: ext_ctxt,\n-                                  span: span,\n-                                  ident: ast::ident,\n-                                  bm: ast::binding_mode) -> @ast::pat {\n+pub fn mk_pat_ident_with_binding_mode(cx: ext_ctxt,\n+                                      span: span,\n+                                      ident: ast::ident,\n+                                      bm: ast::binding_mode) -> @ast::pat {\n     let path = mk_raw_path(span, ~[ ident ]);\n     let pat = ast::pat_ident(bm, path, None);\n     mk_pat(cx, span, move pat)\n }\n-fn mk_pat_enum(cx: ext_ctxt,\n-               span: span,\n-               path: @ast::path,\n-               +subpats: ~[@ast::pat])\n-            -> @ast::pat {\n+pub fn mk_pat_enum(cx: ext_ctxt,\n+                   span: span,\n+                   path: @ast::path,\n+                   +subpats: ~[@ast::pat])\n+                -> @ast::pat {\n     let pat = ast::pat_enum(path, Some(move subpats));\n     mk_pat(cx, span, move pat)\n }\n-fn mk_pat_struct(cx: ext_ctxt,\n-                 span: span,\n-                 path: @ast::path,\n-                 +field_pats: ~[ast::field_pat])\n-              -> @ast::pat {\n+pub fn mk_pat_struct(cx: ext_ctxt,\n+                     span: span,\n+                     path: @ast::path,\n+                     +field_pats: ~[ast::field_pat])\n+                  -> @ast::pat {\n     let pat = ast::pat_struct(path, move field_pats, false);\n     mk_pat(cx, span, move pat)\n }\n-fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n+pub fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n     let lit_expr = ast::expr_lit(@ast::spanned { node: ast::lit_bool(value),\n                                                  span: span });\n     build::mk_expr(cx, span, move lit_expr)\n }\n-fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n+pub fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n     @ast::spanned { node: move stmt_, span: span }\n }\n-fn mk_ty_path(cx: ext_ctxt,\n-              span: span,\n-              idents: ~[ ast::ident ])\n-           -> @ast::Ty {\n+pub fn mk_ty_path(cx: ext_ctxt,\n+                  span: span,\n+                  idents: ~[ ast::ident ])\n+               -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n     let ty = @ast::Ty { id: cx.next_id(), node: move ty, span: span };\n     ty\n }\n-fn mk_ty_path_global(cx: ext_ctxt,\n-                     span: span,\n-                     idents: ~[ ast::ident ])\n-                  -> @ast::Ty {\n+pub fn mk_ty_path_global(cx: ext_ctxt,\n+                         span: span,\n+                         idents: ~[ ast::ident ])\n+                      -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     let ty = ast::ty_path(ty, cx.next_id());\n     let ty = @ast::Ty { id: cx.next_id(), node: move ty, span: span };\n     ty\n }\n-fn mk_simple_ty_path(cx: ext_ctxt,\n-                     span: span,\n-                     ident: ast::ident)\n-                  -> @ast::Ty {\n+pub fn mk_simple_ty_path(cx: ext_ctxt,\n+                         span: span,\n+                         ident: ast::ident)\n+                      -> @ast::Ty {\n     mk_ty_path(cx, span, ~[ ident ])\n }\n-fn mk_arg(cx: ext_ctxt,\n-          span: span,\n-          ident: ast::ident,\n-          ty: @ast::Ty)\n-       -> ast::arg {\n+pub fn mk_arg(cx: ext_ctxt,\n+              span: span,\n+              ident: ast::ident,\n+              ty: @ast::Ty)\n+           -> ast::arg {\n     let arg_pat = mk_pat_ident(cx, span, ident);\n     ast::arg {\n         mode: ast::infer(cx.next_id()),\n@@ -340,13 +354,13 @@ fn mk_arg(cx: ext_ctxt,\n         id: cx.next_id()\n     }\n }\n-fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+pub fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n     ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n }\n-fn mk_ty_param(cx: ext_ctxt,\n-               ident: ast::ident,\n-               bounds: @~[ast::ty_param_bound])\n-            -> ast::ty_param {\n+pub fn mk_ty_param(cx: ext_ctxt,\n+                   ident: ast::ident,\n+                   bounds: @~[ast::ty_param_bound])\n+                -> ast::ty_param {\n     ast::ty_param { ident: ident, id: cx.next_id(), bounds: bounds }\n }\n "}, {"sha": "d83a9f39c5b0dcfcc7f3923fc003b0c741157e8a", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -13,7 +13,7 @@ use core::prelude::*;\n use ext::base::*;\n use ext::base;\n \n-fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for tts.eachi |i, e| {"}, {"sha": "4420c020a0b1da0ef9646c2eb18dcab8f84e6e1f", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -22,9 +22,7 @@ use ext::build::mk_uniq_str;\n use core::option;\n use core::os;\n \n-export expand_syntax_ext;\n-\n-fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n \n     let var = get_single_str_from_tts(cx, sp, tts, \"env!\");"}, {"sha": "0ab94710f40571713eb4556bfd2e3228d1045458", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -22,11 +22,10 @@ use core::option;\n use core::vec;\n use std::map::HashMap;\n \n-fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n-               e: expr_, s: span, fld: ast_fold,\n-               orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n-    -> (expr_, span)\n-{\n+pub fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n+                   e: expr_, s: span, fld: ast_fold,\n+                   orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n+                -> (expr_, span) {\n     return match e {\n       // expr_mac should really be expr_ext or something; it's the\n       // entry-point for all syntax extensions.\n@@ -88,11 +87,10 @@ fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n //\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n-fn expand_mod_items(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n-                    module_: ast::_mod, fld: ast_fold,\n-                    orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n-    -> ast::_mod\n-{\n+pub fn expand_mod_items(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n+                        module_: ast::_mod, fld: ast_fold,\n+                        orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n+                     -> ast::_mod {\n     // Fold the contents first:\n     let module_ = orig(module_, fld);\n \n@@ -125,11 +123,10 @@ fn expand_mod_items(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n \n \n // When we enter a module, record it, for the sake of `module!`\n-fn expand_item(exts: HashMap<~str, SyntaxExtension>,\n-               cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n-               orig: fn@(&&v: @ast::item, ast_fold) -> Option<@ast::item>)\n-    -> Option<@ast::item>\n-{\n+pub fn expand_item(exts: HashMap<~str, SyntaxExtension>,\n+                   cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n+                   orig: fn@(&&v: @ast::item, ast_fold) -> Option<@ast::item>)\n+                -> Option<@ast::item> {\n     let is_mod = match it.node {\n       ast::item_mod(_) | ast::item_foreign_mod(_) => true,\n       _ => false\n@@ -152,9 +149,9 @@ fn expand_item(exts: HashMap<~str, SyntaxExtension>,\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n-                   cx: ext_ctxt, &&it: @ast::item,\n-                   fld: ast_fold) -> Option<@ast::item> {\n+pub fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n+                       cx: ext_ctxt, &&it: @ast::item,\n+                       fld: ast_fold) -> Option<@ast::item> {\n \n     let (pth, tts) = match it.node {\n         item_mac(ast::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n@@ -211,11 +208,10 @@ fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n     return maybe_it;\n }\n \n-fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n-               && s: stmt_, sp: span, fld: ast_fold,\n-               orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n-    -> (stmt_, span)\n-{\n+pub fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n+                   && s: stmt_, sp: span, fld: ast_fold,\n+                   orig: fn@(&&s: stmt_, span, ast_fold) -> (stmt_, span))\n+                -> (stmt_, span) {\n \n     let (mac, pth, tts, semi) = match s {\n         stmt_mac(ref mac, semi) => {\n@@ -267,7 +263,7 @@ fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n }\n \n \n-fn new_span(cx: ext_ctxt, sp: span) -> span {\n+pub fn new_span(cx: ext_ctxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n@@ -277,7 +273,7 @@ fn new_span(cx: ext_ctxt, sp: span) -> span {\n // is substantially more mature, these should move from here, into a\n // compiled part of libcore at very least.\n \n-fn core_macros() -> ~str {\n+pub fn core_macros() -> ~str {\n     return\n ~\"{\n     macro_rules! ignore (($($x:tt)*) => (()))\n@@ -327,8 +323,8 @@ fn core_macros() -> ~str {\n }\";\n }\n \n-fn expand_crate(parse_sess: parse::parse_sess,\n-                cfg: ast::crate_cfg, c: @crate) -> @crate {\n+pub fn expand_crate(parse_sess: parse::parse_sess,\n+                    cfg: ast::crate_cfg, c: @crate) -> @crate {\n     let exts = syntax_expander_table();\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);"}, {"sha": "845d26f77cb4024da712565ced73b674f5394f19", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -25,9 +25,7 @@ use ext::base;\n use ext::build::*;\n use extfmt::ct::*;\n \n-export expand_syntax_ext;\n-\n-fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     let args = get_exprs_from_tts(cx, copy tts);\n     if args.len() == 0 {"}, {"sha": "f713e5ce7d839ba512906d9c670448f065ea5d13", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -17,8 +17,10 @@ use print;\n use core::io::WriterUtil;\n use core::option;\n \n-fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, tt: ~[ast::token_tree])\n-    -> base::MacResult {\n+pub fn expand_syntax_ext(cx: ext_ctxt,\n+                         sp: codemap::span,\n+                         tt: ~[ast::token_tree])\n+                      -> base::MacResult {\n \n     cx.print_backtrace();\n     io::stdout().write_line("}, {"sha": "b0a8f49c7a2435e57195caf99fe2c8d3a4bed524", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -40,7 +40,7 @@ updating the states using rule (2) until there are no changes.\n use core::prelude::*;\n \n use ext::base::ext_ctxt;\n-use ext::pipes::protocol;\n+use ext::pipes::proto::protocol;\n \n use core::str;\n use std::bitv::{Bitv};"}, {"sha": "8f0f00f42c015e9b27fccecd72014e3b1b854d91", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -56,17 +56,16 @@ use parse::parser::Parser;\n \n use core::option::None;\n \n-mod ast_builder;\n-mod parse_proto;\n-mod pipec;\n-mod proto;\n-mod check;\n-mod liveness;\n+pub mod ast_builder;\n+pub mod parse_proto;\n+pub mod pipec;\n+pub mod proto;\n+pub mod check;\n+pub mod liveness;\n \n \n-fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n-                tt: ~[ast::token_tree]) -> base::MacResult\n-{\n+pub fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n+                tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,"}, {"sha": "07dacc7c1b3b50a2b6b93fd590d6acb360b3ae3f", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -21,25 +21,16 @@ use core::result;\n use core::str;\n use core::vec;\n \n-export expand_line;\n-export expand_col;\n-export expand_file;\n-export expand_stringify;\n-export expand_mod;\n-export expand_include;\n-export expand_include_str;\n-export expand_include_bin;\n-\n /* line!(): expands to the current line number */\n-fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_line(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n     let loc = cx.codemap().lookup_char_pos(sp.lo);\n     base::MRExpr(mk_uint(cx, sp, loc.line))\n }\n \n /* col!(): expands to the current column number */\n-fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n     let loc = cx.codemap().lookup_char_pos(sp.lo);\n@@ -49,29 +40,29 @@ fn expand_col(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-fn expand_file(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_file(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n     let Loc { file: @FileMap { name: filename, _ }, _ } =\n         cx.codemap().lookup_char_pos(sp.lo);\n     base::MRExpr(mk_base_str(cx, sp, filename))\n }\n \n-fn expand_stringify(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_stringify(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n     base::MRExpr(mk_base_str(cx, sp, s))\n }\n \n-fn expand_mod(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_mod(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(mk_base_str(cx, sp,\n                               str::connect(cx.mod_path().map(\n                                   |x| cx.str_of(*x)), ~\"::\")))\n }\n \n-fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n@@ -80,7 +71,7 @@ fn expand_include(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     base::MRExpr(p.parse_expr())\n }\n \n-fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n@@ -94,7 +85,7 @@ fn expand_include_str(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, sp, result::unwrap(res)))\n }\n \n-fn expand_include_bin(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n+pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {"}, {"sha": "a87882c4f207a56c046a3f2132b0bf5b21d1a10f", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -18,8 +18,8 @@ use parse::parser::Parser;\n \n use core::option::None;\n \n-fn expand_trace_macros(cx: ext_ctxt, sp: span,\n-                       tt: ~[ast::token_tree]) -> base::MacResult {\n+pub fn expand_trace_macros(cx: ext_ctxt, sp: span,\n+                           tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,"}, {"sha": "4c0550b3c3ad197b23dbe9c3d88aa4a0fed7b23e", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -101,18 +101,18 @@ eof: [a $( a )* a b \u00b7]\n /* to avoid costly uniqueness checks, we require that `match_seq` always has a\n nonempty body. */\n \n-enum matcher_pos_up { /* to break a circularity */\n+pub enum matcher_pos_up { /* to break a circularity */\n     matcher_pos_up(Option<matcher_pos>)\n }\n \n-fn is_some(&&mpu: matcher_pos_up) -> bool {\n+pub fn is_some(&&mpu: matcher_pos_up) -> bool {\n     match &mpu {\n       &matcher_pos_up(None) => false,\n       _ => true\n     }\n }\n \n-type matcher_pos = ~{\n+pub type matcher_pos = ~{\n     elts: ~[ast::matcher], // maybe should be /&? Need to understand regions.\n     sep: Option<Token>,\n     mut idx: uint,\n@@ -122,14 +122,14 @@ type matcher_pos = ~{\n     sp_lo: BytePos,\n };\n \n-fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n+pub fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n     match &mpu {\n       &matcher_pos_up(Some(ref mp)) => copy (*mp),\n       _ => fail\n     }\n }\n \n-fn count_names(ms: &[matcher]) -> uint {\n+pub fn count_names(ms: &[matcher]) -> uint {\n     vec::foldl(0u, ms, |ct, m| {\n         ct + match m.node {\n           match_tok(_) => 0u,\n@@ -139,8 +139,8 @@ fn count_names(ms: &[matcher]) -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n-    -> matcher_pos {\n+pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n+                        -> matcher_pos {\n     let mut match_idx_hi = 0u;\n     for ms.each() |elt| {\n         match elt.node {\n@@ -177,15 +177,15 @@ fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n // only on the nesting depth of ast::match_seqs in the originating\n // ast::matcher it was derived from.\n \n-enum named_match {\n+pub enum named_match {\n     matched_seq(~[@named_match], codemap::span),\n     matched_nonterminal(nonterminal)\n }\n \n-type earley_item = matcher_pos;\n+pub type earley_item = matcher_pos;\n \n-fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n-    -> HashMap<ident,@named_match> {\n+pub fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n+            -> HashMap<ident,@named_match> {\n     fn n_rec(p_s: parse_sess, m: matcher, res: ~[@named_match],\n              ret_val: HashMap<ident, @named_match>) {\n         match m {\n@@ -211,23 +211,26 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n     return ret_val;\n }\n \n-enum parse_result {\n+pub enum parse_result {\n     success(HashMap<ident, @named_match>),\n     failure(codemap::span, ~str),\n     error(codemap::span, ~str)\n }\n \n-fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n-                 ms: ~[matcher]) -> HashMap<ident, @named_match> {\n+pub fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n+                     ms: ~[matcher]) -> HashMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n       failure(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str)),\n       error(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str))\n     }\n }\n \n-fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n-    -> parse_result {\n+pub fn parse(sess: parse_sess,\n+             cfg: ast::crate_cfg,\n+             rdr: reader,\n+             ms: ~[matcher])\n+          -> parse_result {\n     let mut cur_eis = ~[];\n     cur_eis.push(initial_matcher_pos(ms, None, rdr.peek().sp.lo));\n \n@@ -398,7 +401,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n     }\n }\n \n-fn parse_nt(p: Parser, name: ~str) -> nonterminal {\n+pub fn parse_nt(p: Parser, name: ~str) -> nonterminal {\n     match name {\n       ~\"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),"}, {"sha": "f7ef79db466a60c637a0eb5965930b89fae7471a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -29,8 +29,8 @@ use print;\n use core::io;\n use std::map::HashMap;\n \n-fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n-                     arg: ~[ast::token_tree]) -> base::MacResult {\n+pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n+                         arg: ~[ast::token_tree]) -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n         ast::spanned { node: m, span: dummy_sp() }"}, {"sha": "b3b1e04976a86383444c82193a09b4fa34057f88", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -23,8 +23,6 @@ use core::vec;\n use std;\n use std::map::HashMap;\n \n-export tt_reader,  new_tt_reader, dup_tt_reader, tt_next_token;\n-\n enum tt_frame_up { /* to break a circularity */\n     tt_frame_up(Option<tt_frame>)\n }\n@@ -40,7 +38,7 @@ type tt_frame = @{\n     up: tt_frame_up,\n };\n \n-type tt_reader = @{\n+pub type tt_reader = @{\n     sp_diag: span_handler,\n     interner: @ident_interner,\n     mut cur: tt_frame,\n@@ -56,10 +54,10 @@ type tt_reader = @{\n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n-fn new_tt_reader(sp_diag: span_handler, itr: @ident_interner,\n-                 interp: Option<std::map::HashMap<ident,@named_match>>,\n-                 src: ~[ast::token_tree])\n-    -> tt_reader {\n+pub fn new_tt_reader(sp_diag: span_handler, itr: @ident_interner,\n+                     interp: Option<std::map::HashMap<ident,@named_match>>,\n+                     src: ~[ast::token_tree])\n+                  -> tt_reader {\n     let r = @{sp_diag: sp_diag, interner: itr,\n               mut cur: @{readme: src, mut idx: 0u, dotdotdoted: false,\n                          sep: None, up: tt_frame_up(option::None)},\n@@ -88,7 +86,7 @@ pure fn dup_tt_frame(&&f: tt_frame) -> tt_frame {\n      }\n }\n \n-pure fn dup_tt_reader(&&r: tt_reader) -> tt_reader {\n+pub pure fn dup_tt_reader(&&r: tt_reader) -> tt_reader {\n     @{sp_diag: r.sp_diag, interner: r.interner,\n       mut cur: dup_tt_frame(r.cur),\n       interpolations: r.interpolations,\n@@ -151,7 +149,7 @@ fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n }\n \n \n-fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n+pub fn tt_next_token(&&r: tt_reader) -> {tok: Token, sp: span} {\n     let ret_val = { tok: r.cur_tok, sp: r.cur_span };\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */"}, {"sha": "e8557558f174468fe12bcdabe30278f814619f33", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -17,26 +17,7 @@ use codemap::span;\n use core::option;\n use core::vec;\n \n-export ast_fold_fns;\n-export ast_fold;\n-export default_ast_fold;\n-export make_fold;\n-export noop_fold_crate;\n-export noop_fold_item;\n-export noop_fold_expr;\n-export noop_fold_pat;\n-export noop_fold_mod;\n-export noop_fold_ty;\n-export noop_fold_block;\n-export noop_fold_item_underscore;\n-export wrap;\n-export fold_ty_param;\n-export fold_ty_params;\n-export fold_fn_decl;\n-export extensions;\n-export AstFoldFns;\n-\n-trait ast_fold {\n+pub trait ast_fold {\n     fn fold_crate(crate) -> crate;\n     fn fold_view_item(&&v: @view_item) -> @view_item;\n     fn fold_foreign_item(&&v: @foreign_item) -> @foreign_item;\n@@ -64,7 +45,7 @@ trait ast_fold {\n \n // We may eventually want to be able to fold over type parameters, too\n \n-struct AstFoldFns {\n+pub struct AstFoldFns {\n     //unlike the others, item_ is non-trivial\n     fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n@@ -91,7 +72,7 @@ struct AstFoldFns {\n     new_span: fn@(span) -> span\n }\n \n-type ast_fold_fns = @AstFoldFns;\n+pub type ast_fold_fns = @AstFoldFns;\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n@@ -141,7 +122,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n               span: fld.new_span(m.span) }\n }\n \n-fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n+pub fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n         inputs: decl.inputs.map(|x| fold_arg_(*x, fld)),\n         output: fld.fold_ty(decl.output),\n@@ -156,17 +137,17 @@ fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n     }\n }\n \n-fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n+pub fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n     ast::ty_param { ident: /* FIXME (#2543) */ copy tp.ident,\n                     id: fld.new_id(tp.id),\n                     bounds: @tp.bounds.map(|x| fold_ty_param_bound(*x, fld) )}\n }\n \n-fn fold_ty_params(tps: ~[ty_param], fld: ast_fold) -> ~[ty_param] {\n+pub fn fold_ty_params(tps: ~[ty_param], fld: ast_fold) -> ~[ty_param] {\n     tps.map(|x| fold_ty_param(*x, fld))\n }\n \n-fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n+pub fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = |x| fold_meta_item_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n@@ -212,7 +193,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n     }\n }\n \n-fn noop_fold_item(&&i: @item, fld: ast_fold) -> Option<@item> {\n+pub fn noop_fold_item(&&i: @item, fld: ast_fold) -> Option<@item> {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     Some(@ast::item { ident: fld.fold_ident(i.ident),\n@@ -231,7 +212,7 @@ fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n                span: sf.span }\n }\n \n-fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n+pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n     return match i {\n           item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n           item_fn(decl, purity, typms, ref body) => {\n@@ -328,7 +309,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n }\n \n \n-fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n+pub fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n     ast::blk_ {\n         view_items: b.view_items.map(|x| fld.fold_view_item(*x)),\n         stmts: b.stmts.map(|x| fld.fold_stmt(*x)),\n@@ -356,7 +337,7 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n     }\n }\n \n-fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n+pub fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     return match p {\n           pat_wild => pat_wild,\n           pat_ident(binding_mode, pth, sub) => {\n@@ -412,15 +393,15 @@ fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n     }\n }\n \n-fn wrap<T>(f: fn@(T, ast_fold) -> T)\n+pub fn wrap<T>(f: fn@(T, ast_fold) -> T)\n     -> fn@(T, span, ast_fold) -> (T, span)\n {\n     return fn@(x: T, s: span, fld: ast_fold) -> (T, span) {\n         (f(x, fld), s)\n     }\n }\n \n-fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n+pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: ast_fold) -> field {\n         spanned {\n             node: ast::field_ {\n@@ -545,7 +526,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n         }\n }\n \n-fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n+pub fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: mt, fld: ast_fold) -> mt {\n         mt { ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl }\n@@ -586,7 +567,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n }\n \n // ...nor do modules\n-fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n+pub fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n     ast::_mod {\n         view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n         items: vec::filter_map(m.items, |x| fld.fold_item(*x)),\n@@ -693,7 +674,7 @@ fn noop_id(i: node_id) -> node_id { return i; }\n \n fn noop_span(sp: span) -> span { return sp; }\n \n-fn default_ast_fold() -> ast_fold_fns {\n+pub fn default_ast_fold() -> ast_fold_fns {\n     return @AstFoldFns {fold_crate: wrap(noop_fold_crate),\n           fold_view_item: noop_fold_view_item,\n           fold_foreign_item: noop_fold_foreign_item,\n@@ -719,7 +700,7 @@ fn default_ast_fold() -> ast_fold_fns {\n           new_span: noop_span};\n }\n \n-impl ast_fold_fns: ast_fold {\n+pub impl ast_fold_fns: ast_fold {\n     /* naturally, a macro to write these would be nice */\n     fn fold_crate(c: crate) -> crate {\n         let (n, s) = (self.fold_crate)(c.node, c.span, self as ast_fold);\n@@ -833,13 +814,13 @@ impl ast_fold_fns: ast_fold {\n     }\n }\n \n-impl ast_fold {\n+pub impl ast_fold {\n     fn fold_attributes(attrs: ~[attribute]) -> ~[attribute] {\n         attrs.map(|x| fold_attribute_(*x, self))\n     }\n }\n \n-fn make_fold(afp: ast_fold_fns) -> ast_fold {\n+pub fn make_fold(afp: ast_fold_fns) -> ast_fold {\n     afp as ast_fold\n }\n "}, {"sha": "caab03afb7612fd280020fdf5d94e5b73254967e", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -13,10 +13,6 @@ use attr::parser_attr;\n use ast_util::mk_sp;\n use codemap::span;\n \n-export eval_crate_directives_to_mod;\n-export eval_src_mod;\n-export eval_src_mod_from_path;\n-\n type ctx =\n     @{sess: parse::parse_sess,\n       cfg: ast::crate_cfg};\n@@ -31,8 +27,8 @@ fn eval_crate_directives(cx: ctx,\n     }\n }\n \n-fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n-                                prefix: &Path, suffix: &Option<Path>)\n+pub fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n+                                    prefix: &Path, suffix: &Option<Path>)\n     -> (ast::_mod, ~[ast::attribute]) {\n     let (cview_items, citems, cattrs)\n         = parse_companion_mod(cx, prefix, suffix);\n@@ -95,19 +91,19 @@ fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n     }\n }\n \n-fn eval_src_mod(cx: ctx, prefix: &Path,\n-                outer_attrs: ~[ast::attribute],\n-                id: ast::ident, sp: span\n-               ) -> (ast::item_, ~[ast::attribute]) {\n+pub fn eval_src_mod(cx: ctx, prefix: &Path,\n+                    outer_attrs: ~[ast::attribute],\n+                    id: ast::ident, sp: span)\n+                 -> (ast::item_, ~[ast::attribute]) {\n     let file_path = Path(cdir_path_opt(\n         cx.sess.interner.get(id) + ~\".rs\", outer_attrs));\n     eval_src_mod_from_path(cx, prefix, &file_path, outer_attrs, sp)\n }\n \n-fn eval_src_mod_from_path(cx: ctx, prefix: &Path, path: &Path,\n-                          outer_attrs: ~[ast::attribute],\n-                          sp: span\n-                         ) -> (ast::item_, ~[ast::attribute]) {\n+pub fn eval_src_mod_from_path(cx: ctx, prefix: &Path, path: &Path,\n+                              outer_attrs: ~[ast::attribute],\n+                              sp: span)\n+                           -> (ast::item_, ~[ast::attribute]) {\n     let full_path = if path.is_absolute {\n         copy *path\n     } else {"}, {"sha": "d3487fa845f4bb969283dfe13ea8ea32aa8a0263", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -69,9 +69,9 @@ use core::vec;\n  * line (which it can't) and so naturally place the content on its own line to\n  * avoid combining it with other lines and making matters even worse.\n  */\n-enum breaks { consistent, inconsistent, }\n+pub enum breaks { consistent, inconsistent, }\n \n-impl breaks : cmp::Eq {\n+pub impl breaks : cmp::Eq {\n     pure fn eq(&self, other: &breaks) -> bool {\n         match ((*self), (*other)) {\n             (consistent, consistent) => true,\n@@ -83,13 +83,19 @@ impl breaks : cmp::Eq {\n     pure fn ne(&self, other: &breaks) -> bool { !(*self).eq(other) }\n }\n \n-type break_t = {offset: int, blank_space: int};\n+pub type break_t = {offset: int, blank_space: int};\n \n-type begin_t = {offset: int, breaks: breaks};\n+pub type begin_t = {offset: int, breaks: breaks};\n \n-enum token { STRING(@~str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n+pub enum token {\n+    STRING(@~str, int),\n+    BREAK(break_t),\n+    BEGIN(begin_t),\n+    END,\n+    EOF,\n+}\n \n-impl token {\n+pub impl token {\n     fn is_eof() -> bool {\n         match self { EOF => true, _ => false }\n     }\n@@ -103,7 +109,7 @@ impl token {\n     }\n }\n \n-fn tok_str(++t: token) -> ~str {\n+pub fn tok_str(++t: token) -> ~str {\n     match t {\n       STRING(s, len) => return fmt!(\"STR(%s,%d)\", *s, len),\n       BREAK(_) => return ~\"BREAK\",\n@@ -113,8 +119,8 @@ fn tok_str(++t: token) -> ~str {\n     }\n }\n \n-fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n-           lim: uint) -> ~str {\n+pub fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n+               lim: uint) -> ~str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n     let mut i = left;\n@@ -131,13 +137,13 @@ fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n     return s;\n }\n \n-enum print_stack_break { fits, broken(breaks), }\n+pub enum print_stack_break { fits, broken(breaks), }\n \n-type print_stack_elt = {offset: int, pbreak: print_stack_break};\n+pub type print_stack_elt = {offset: int, pbreak: print_stack_break};\n \n-const size_infinity: int = 0xffff;\n+pub const size_infinity: int = 0xffff;\n \n-fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n+pub fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n@@ -241,7 +247,7 @@ fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n  * the method called 'pretty_print', and the 'PRINT' process is the method\n  * called 'print'.\n  */\n-type printer_ = {\n+pub type printer_ = {\n     out: io::Writer,\n     buf_len: uint,\n     mut margin: int, // width of lines we're constrained to\n@@ -268,11 +274,11 @@ type printer_ = {\n     mut pending_indentation: int,\n };\n \n-enum printer {\n+pub enum printer {\n     printer_(@printer_)\n }\n \n-impl printer {\n+pub impl printer {\n     fn last_token() -> token { self.token[self.right] }\n     // be very careful with this!\n     fn replace_last_token(t: token) { self.token[self.right] = t; }\n@@ -533,45 +539,45 @@ impl printer {\n }\n \n // Convenience functions to talk to the printer.\n-fn box(p: printer, indent: uint, b: breaks) {\n+pub fn box(p: printer, indent: uint, b: breaks) {\n     p.pretty_print(BEGIN({offset: indent as int, breaks: b}));\n }\n \n-fn ibox(p: printer, indent: uint) { box(p, indent, inconsistent); }\n+pub fn ibox(p: printer, indent: uint) { box(p, indent, inconsistent); }\n \n-fn cbox(p: printer, indent: uint) { box(p, indent, consistent); }\n+pub fn cbox(p: printer, indent: uint) { box(p, indent, consistent); }\n \n-fn break_offset(p: printer, n: uint, off: int) {\n+pub fn break_offset(p: printer, n: uint, off: int) {\n     p.pretty_print(BREAK({offset: off, blank_space: n as int}));\n }\n \n-fn end(p: printer) { p.pretty_print(END); }\n+pub fn end(p: printer) { p.pretty_print(END); }\n \n-fn eof(p: printer) { p.pretty_print(EOF); }\n+pub fn eof(p: printer) { p.pretty_print(EOF); }\n \n-fn word(p: printer, wrd: ~str) {\n+pub fn word(p: printer, wrd: ~str) {\n     p.pretty_print(STRING(@wrd, str::len(wrd) as int));\n }\n \n-fn huge_word(p: printer, wrd: ~str) {\n+pub fn huge_word(p: printer, wrd: ~str) {\n     p.pretty_print(STRING(@wrd, size_infinity));\n }\n \n-fn zero_word(p: printer, wrd: ~str) { p.pretty_print(STRING(@wrd, 0)); }\n+pub fn zero_word(p: printer, wrd: ~str) { p.pretty_print(STRING(@wrd, 0)); }\n \n-fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n+pub fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n \n-fn zerobreak(p: printer) { spaces(p, 0u); }\n+pub fn zerobreak(p: printer) { spaces(p, 0u); }\n \n-fn space(p: printer) { spaces(p, 1u); }\n+pub fn space(p: printer) { spaces(p, 1u); }\n \n-fn hardbreak(p: printer) { spaces(p, size_infinity as uint); }\n+pub fn hardbreak(p: printer) { spaces(p, size_infinity as uint); }\n \n-fn hardbreak_tok_offset(off: int) -> token {\n+pub fn hardbreak_tok_offset(off: int) -> token {\n     return BREAK({offset: off, blank_space: size_infinity});\n }\n \n-fn hardbreak_tok() -> token { return hardbreak_tok_offset(0); }\n+pub fn hardbreak_tok() -> token { return hardbreak_tok_offset(0); }\n \n \n //"}, {"sha": "a0243215e697c2c7cadea52f3ae7658fa82c567c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 192, "deletions": 179, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -38,23 +38,23 @@ use core::u64;\n use core::vec;\n \n // The ps is stored here to prevent recursive type.\n-enum ann_node {\n+pub enum ann_node {\n     node_block(ps, ast::blk),\n     node_item(ps, @ast::item),\n     node_expr(ps, @ast::expr),\n     node_pat(ps, @ast::pat),\n }\n-struct pp_ann {\n+pub struct pp_ann {\n     pre: fn@(ann_node),\n     post: fn@(ann_node)\n }\n \n-fn no_ann() -> pp_ann {\n+pub fn no_ann() -> pp_ann {\n     fn ignore(_node: ann_node) { }\n     return pp_ann {pre: ignore, post: ignore};\n }\n \n-type ps =\n+pub type ps =\n     @{s: pp::printer,\n       cm: Option<@CodeMap>,\n       intr: @token::ident_interner,\n@@ -65,17 +65,17 @@ type ps =\n       boxes: DVec<pp::breaks>,\n       ann: pp_ann};\n \n-fn ibox(s: ps, u: uint) {\n+pub fn ibox(s: ps, u: uint) {\n     s.boxes.push(pp::inconsistent);\n     pp::ibox(s.s, u);\n }\n \n-fn end(s: ps) {\n+pub fn end(s: ps) {\n     s.boxes.pop();\n     pp::end(s.s);\n }\n \n-fn rust_printer(writer: io::Writer, intr: @ident_interner) -> ps {\n+pub fn rust_printer(writer: io::Writer, intr: @ident_interner) -> ps {\n     return @{s: pp::mk_printer(writer, default_columns),\n              cm: None::<@CodeMap>,\n              intr: intr,\n@@ -87,18 +87,18 @@ fn rust_printer(writer: io::Writer, intr: @ident_interner) -> ps {\n              ann: no_ann()};\n }\n \n-const indent_unit: uint = 4u;\n-const match_indent_unit: uint = 2u;\n+pub const indent_unit: uint = 4u;\n+pub const match_indent_unit: uint = 2u;\n \n-const default_columns: uint = 78u;\n+pub const default_columns: uint = 78u;\n \n // Requires you to pass an input filename and reader so that\n // it can scan the input text for comments and literals to\n // copy forward.\n-fn print_crate(cm: @CodeMap, intr: @ident_interner,\n-               span_diagnostic: diagnostic::span_handler,\n-               crate: @ast::crate, filename: ~str, in: io::Reader,\n-               out: io::Writer, ann: pp_ann, is_expanded: bool) {\n+pub fn print_crate(cm: @CodeMap, intr: @ident_interner,\n+                   span_diagnostic: diagnostic::span_handler,\n+                   crate: @ast::crate, filename: ~str, in: io::Reader,\n+                   out: io::Writer, ann: pp_ann, is_expanded: bool) {\n     let r = comments::gather_comments_and_literals(span_diagnostic,\n                                                    filename, in);\n     let s =\n@@ -117,50 +117,50 @@ fn print_crate(cm: @CodeMap, intr: @ident_interner,\n     print_crate_(s, crate);\n }\n \n-fn print_crate_(s: ps, &&crate: @ast::crate) {\n+pub fn print_crate_(s: ps, &&crate: @ast::crate) {\n     print_mod(s, crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n }\n \n-fn ty_to_str(ty: @ast::Ty, intr: @ident_interner) -> ~str {\n+pub fn ty_to_str(ty: @ast::Ty, intr: @ident_interner) -> ~str {\n     to_str(ty, print_type, intr)\n }\n \n-fn pat_to_str(pat: @ast::pat, intr: @ident_interner) -> ~str {\n+pub fn pat_to_str(pat: @ast::pat, intr: @ident_interner) -> ~str {\n     to_str(pat, print_irrefutable_pat, intr)\n }\n \n-fn expr_to_str(e: @ast::expr, intr: @ident_interner) -> ~str {\n+pub fn expr_to_str(e: @ast::expr, intr: @ident_interner) -> ~str {\n     to_str(e, print_expr, intr)\n }\n \n-fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n+pub fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n     to_str(tt, print_tt, intr)\n }\n \n-fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n+pub fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n     to_str(tts, print_tts, intr)\n }\n \n-fn stmt_to_str(s: ast::stmt, intr: @ident_interner) -> ~str {\n+pub fn stmt_to_str(s: ast::stmt, intr: @ident_interner) -> ~str {\n     to_str(s, print_stmt, intr)\n }\n \n-fn item_to_str(i: @ast::item, intr: @ident_interner) -> ~str {\n+pub fn item_to_str(i: @ast::item, intr: @ident_interner) -> ~str {\n     to_str(i, print_item, intr)\n }\n \n-fn typarams_to_str(tps: ~[ast::ty_param], intr: @ident_interner) -> ~str {\n+pub fn typarams_to_str(tps: ~[ast::ty_param], intr: @ident_interner) -> ~str {\n     to_str(tps, print_type_params, intr)\n }\n \n-fn path_to_str(&&p: @ast::path, intr: @ident_interner) -> ~str {\n+pub fn path_to_str(&&p: @ast::path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n-fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n-              params: ~[ast::ty_param], intr: @ident_interner) -> ~str {\n+pub fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n+                  params: ~[ast::ty_param], intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         print_fn(s, decl, None, name, params, None, ast::inherited);\n@@ -170,7 +170,7 @@ fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n     }\n }\n \n-fn block_to_str(blk: ast::blk, intr: @ident_interner) -> ~str {\n+pub fn block_to_str(blk: ast::blk, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         // containing cbox, will be closed by print-block at }\n@@ -182,39 +182,39 @@ fn block_to_str(blk: ast::blk, intr: @ident_interner) -> ~str {\n     }\n }\n \n-fn meta_item_to_str(mi: @ast::meta_item, intr: @ident_interner) -> ~str {\n+pub fn meta_item_to_str(mi: @ast::meta_item, intr: @ident_interner) -> ~str {\n     to_str(mi, print_meta_item, intr)\n }\n \n-fn attribute_to_str(attr: ast::attribute, intr: @ident_interner) -> ~str {\n+pub fn attribute_to_str(attr: ast::attribute, intr: @ident_interner) -> ~str {\n     to_str(attr, print_attribute, intr)\n }\n \n-fn variant_to_str(var: ast::variant, intr: @ident_interner) -> ~str {\n+pub fn variant_to_str(var: ast::variant, intr: @ident_interner) -> ~str {\n     to_str(var, print_variant, intr)\n }\n \n-fn cbox(s: ps, u: uint) {\n+pub fn cbox(s: ps, u: uint) {\n     s.boxes.push(pp::consistent);\n     pp::cbox(s.s, u);\n }\n \n-fn box(s: ps, u: uint, b: pp::breaks) {\n+pub fn box(s: ps, u: uint, b: pp::breaks) {\n     s.boxes.push(b);\n     pp::box(s.s, u, b);\n }\n \n-fn nbsp(s: ps) { word(s.s, ~\" \"); }\n+pub fn nbsp(s: ps) { word(s.s, ~\" \"); }\n \n-fn word_nbsp(s: ps, w: ~str) { word(s.s, w); nbsp(s); }\n+pub fn word_nbsp(s: ps, w: ~str) { word(s.s, w); nbsp(s); }\n \n-fn word_space(s: ps, w: ~str) { word(s.s, w); space(s.s); }\n+pub fn word_space(s: ps, w: ~str) { word(s.s, w); space(s.s); }\n \n-fn popen(s: ps) { word(s.s, ~\"(\"); }\n+pub fn popen(s: ps) { word(s.s, ~\"(\"); }\n \n-fn pclose(s: ps) { word(s.s, ~\")\"); }\n+pub fn pclose(s: ps) { word(s.s, ~\")\"); }\n \n-fn head(s: ps, w: ~str) {\n+pub fn head(s: ps, w: ~str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n@@ -225,46 +225,46 @@ fn head(s: ps, w: ~str) {\n     }\n }\n \n-fn bopen(s: ps) {\n+pub fn bopen(s: ps) {\n     word(s.s, ~\"{\");\n     end(s); // close the head-box\n }\n \n-fn bclose_(s: ps, span: codemap::span, indented: uint) {\n+pub fn bclose_(s: ps, span: codemap::span, indented: uint) {\n     bclose_maybe_open(s, span, indented, true);\n }\n-fn bclose_maybe_open (s: ps, span: codemap::span, indented: uint,\n-                     close_box: bool) {\n+pub fn bclose_maybe_open (s: ps, span: codemap::span, indented: uint,\n+                          close_box: bool) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n     word(s.s, ~\"}\");\n     if close_box {\n         end(s); // close the outer-box\n     }\n }\n-fn bclose(s: ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n+pub fn bclose(s: ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n \n-fn is_begin(s: ps) -> bool {\n+pub fn is_begin(s: ps) -> bool {\n     match s.s.last_token() { pp::BEGIN(_) => true, _ => false }\n }\n \n-fn is_end(s: ps) -> bool {\n+pub fn is_end(s: ps) -> bool {\n     match s.s.last_token() { pp::END => true, _ => false }\n }\n \n-fn is_bol(s: ps) -> bool {\n+pub fn is_bol(s: ps) -> bool {\n     return s.s.last_token().is_eof() || s.s.last_token().is_hardbreak_tok();\n }\n \n-fn in_cbox(s: ps) -> bool {\n+pub fn in_cbox(s: ps) -> bool {\n     let len = s.boxes.len();\n     if len == 0u { return false; }\n     return s.boxes[len - 1u] == pp::consistent;\n }\n \n-fn hardbreak_if_not_bol(s: ps) { if !is_bol(s) { hardbreak(s.s); } }\n-fn space_if_not_bol(s: ps) { if !is_bol(s) { space(s.s); } }\n-fn break_offset_if_not_bol(s: ps, n: uint, off: int) {\n+pub fn hardbreak_if_not_bol(s: ps) { if !is_bol(s) { hardbreak(s.s); } }\n+pub fn space_if_not_bol(s: ps) { if !is_bol(s) { space(s.s); } }\n+pub fn break_offset_if_not_bol(s: ps, n: uint, off: int) {\n     if !is_bol(s) {\n         break_offset(s.s, n, off);\n     } else {\n@@ -279,15 +279,15 @@ fn break_offset_if_not_bol(s: ps, n: uint, off: int) {\n \n // Synthesizes a comment that was not textually present in the original source\n // file.\n-fn synth_comment(s: ps, text: ~str) {\n+pub fn synth_comment(s: ps, text: ~str) {\n     word(s.s, ~\"/*\");\n     space(s.s);\n     word(s.s, text);\n     space(s.s);\n     word(s.s, ~\"*/\");\n }\n \n-fn commasep<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN)) {\n+pub fn commasep<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n@@ -298,8 +298,8 @@ fn commasep<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN)) {\n }\n \n \n-fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n-                     get_span: fn(IN) -> codemap::span) {\n+pub fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n+                         get_span: fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n     let mut i = 0u;\n@@ -317,29 +317,29 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n     end(s);\n }\n \n-fn commasep_exprs(s: ps, b: breaks, exprs: ~[@ast::expr]) {\n+pub fn commasep_exprs(s: ps, b: breaks, exprs: ~[@ast::expr]) {\n     fn expr_span(&&expr: @ast::expr) -> codemap::span { return expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-fn print_mod(s: ps, _mod: ast::_mod, attrs: ~[ast::attribute]) {\n+pub fn print_mod(s: ps, _mod: ast::_mod, attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n     }\n     for _mod.items.each |item| { print_item(s, *item); }\n }\n \n-fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n-                     attrs: ~[ast::attribute]) {\n+pub fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n+                         attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n     }\n     for nmod.items.each |item| { print_foreign_item(s, *item); }\n }\n \n-fn print_region(s: ps, prefix: ~str, region: @ast::region, sep: ~str) {\n+pub fn print_region(s: ps, prefix: ~str, region: @ast::region, sep: ~str) {\n     word(s.s, prefix);\n     match region.node {\n         ast::re_anon => {\n@@ -358,11 +358,11 @@ fn print_region(s: ps, prefix: ~str, region: @ast::region, sep: ~str) {\n     word(s.s, sep);\n }\n \n-fn print_type(s: ps, &&ty: @ast::Ty) {\n+pub fn print_type(s: ps, &&ty: @ast::Ty) {\n     print_type_ex(s, ty, false);\n }\n \n-fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n+pub fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n@@ -432,7 +432,7 @@ fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n     end(s);\n }\n \n-fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n+pub fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -456,7 +456,7 @@ fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n     }\n }\n \n-fn print_item(s: ps, &&item: @ast::item) {\n+pub fn print_item(s: ps, &&item: @ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -591,9 +591,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n     (s.ann.post)(ann_node);\n }\n \n-fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n-                  params: ~[ast::ty_param], ident: ast::ident,\n-                  span: codemap::span, visibility: ast::visibility) {\n+pub fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n+                      params: ~[ast::ty_param], ident: ast::ident,\n+                      span: codemap::span, visibility: ast::visibility) {\n     let mut newtype =\n         vec::len(enum_definition.variants) == 1u &&\n         ident == enum_definition.variants[0].node.name;\n@@ -626,7 +626,9 @@ fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n     }\n }\n \n-fn print_variants(s: ps, variants: ~[ast::variant], span: codemap::span) {\n+pub fn print_variants(s: ps,\n+                      variants: ~[ast::variant],\n+                      span: codemap::span) {\n     bopen(s);\n     for variants.each |v| {\n         space_if_not_bol(s);\n@@ -641,32 +643,35 @@ fn print_variants(s: ps, variants: ~[ast::variant], span: codemap::span) {\n     bclose(s, span);\n }\n \n-fn visibility_to_str(vis: ast::visibility) -> ~str {\n+pub fn visibility_to_str(vis: ast::visibility) -> ~str {\n     match vis {\n         ast::private => ~\"priv\",\n         ast::public => ~\"pub\",\n         ast::inherited => ~\"\"\n     }\n }\n \n-fn visibility_qualified(vis: ast::visibility, s: ~str) -> ~str {\n+pub fn visibility_qualified(vis: ast::visibility, s: ~str) -> ~str {\n     match vis {\n         ast::private | ast::public =>\n         visibility_to_str(vis) + \" \" + s,\n         ast::inherited => s\n     }\n }\n \n-fn print_visibility(s: ps, vis: ast::visibility) {\n+pub fn print_visibility(s: ps, vis: ast::visibility) {\n     match vis {\n         ast::private | ast::public =>\n         word_nbsp(s, visibility_to_str(vis)),\n         ast::inherited => ()\n     }\n }\n \n-fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n-                ident: ast::ident, span: codemap::span) {\n+pub fn print_struct(s: ps,\n+                    struct_def: @ast::struct_def,\n+                    tps: ~[ast::ty_param],\n+                    ident: ast::ident,\n+                    span: codemap::span) {\n     print_ident(s, ident);\n     nbsp(s);\n     print_type_params(s, tps);\n@@ -731,7 +736,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n /// appropriate macro, transcribe back into the grammar we just parsed from,\n /// and then pretty-print the resulting AST nodes (so, e.g., we print\n /// expression arguments as expressions). It can be done! I think.\n-fn print_tt(s: ps, tt: ast::token_tree) {\n+pub fn print_tt(s: ps, tt: ast::token_tree) {\n     match tt {\n       ast::tt_delim(ref tts) => print_tts(s, *tts),\n       ast::tt_tok(_, ref tk) => {\n@@ -754,7 +759,7 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n     }\n }\n \n-fn print_tts(s: ps, &&tts: &[ast::token_tree]) {\n+pub fn print_tts(s: ps, &&tts: &[ast::token_tree]) {\n     ibox(s, 0);\n     for tts.eachi |i, tt| {\n         if i != 0 {\n@@ -765,7 +770,7 @@ fn print_tts(s: ps, &&tts: &[ast::token_tree]) {\n     end(s);\n }\n \n-fn print_variant(s: ps, v: ast::variant) {\n+pub fn print_variant(s: ps, v: ast::variant) {\n     print_visibility(s, v.node.vis);\n     match v.node.kind {\n         ast::tuple_variant_kind(args) => {\n@@ -797,7 +802,7 @@ fn print_variant(s: ps, v: ast::variant) {\n     }\n }\n \n-fn print_ty_method(s: ps, m: ast::ty_method) {\n+pub fn print_ty_method(s: ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n@@ -807,14 +812,14 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n     word(s.s, ~\";\");\n }\n \n-fn print_trait_method(s: ps, m: ast::trait_method) {\n+pub fn print_trait_method(s: ps, m: ast::trait_method) {\n     match m {\n       required(ref ty_m) => print_ty_method(s, (*ty_m)),\n       provided(m)    => print_method(s, m)\n     }\n }\n \n-fn print_method(s: ps, meth: @ast::method) {\n+pub fn print_method(s: ps, meth: @ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n@@ -825,7 +830,7 @@ fn print_method(s: ps, meth: @ast::method) {\n     print_block_with_attrs(s, meth.body, meth.attrs);\n }\n \n-fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n+pub fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n@@ -836,7 +841,7 @@ fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n+pub fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n@@ -853,7 +858,7 @@ fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-fn print_attribute(s: ps, attr: ast::attribute) {\n+pub fn print_attribute(s: ps, attr: ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n@@ -868,7 +873,7 @@ fn print_attribute(s: ps, attr: ast::attribute) {\n }\n \n \n-fn print_stmt(s: ps, st: ast::stmt) {\n+pub fn print_stmt(s: ps, st: ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n     match st.node {\n       ast::stmt_decl(decl, _) => {\n@@ -893,36 +898,43 @@ fn print_stmt(s: ps, st: ast::stmt) {\n     maybe_print_trailing_comment(s, st.span, None);\n }\n \n-fn print_block(s: ps, blk: ast::blk) {\n+pub fn print_block(s: ps, blk: ast::blk) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n-fn print_block_unclosed(s: ps, blk: ast::blk) {\n+pub fn print_block_unclosed(s: ps, blk: ast::blk) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, ~[],\n                                  false);\n }\n \n-fn print_block_unclosed_indent(s: ps, blk: ast::blk, indented: uint) {\n+pub fn print_block_unclosed_indent(s: ps, blk: ast::blk, indented: uint) {\n     print_possibly_embedded_block_(s, blk, block_normal, indented, ~[],\n                                    false);\n }\n \n-fn print_block_with_attrs(s: ps, blk: ast::blk, attrs: ~[ast::attribute]) {\n+pub fn print_block_with_attrs(s: ps,\n+                              blk: ast::blk,\n+                              attrs: ~[ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n                                   true);\n }\n \n-enum embed_type { block_block_fn, block_normal, }\n+pub enum embed_type { block_block_fn, block_normal, }\n \n-fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n-                                 indented: uint) {\n+pub fn print_possibly_embedded_block(s: ps,\n+                                     blk: ast::blk,\n+                                     embedded: embed_type,\n+                                     indented: uint) {\n     print_possibly_embedded_block_(\n         s, blk, embedded, indented, ~[], true);\n }\n \n-fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n-                                  indented: uint, attrs: ~[ast::attribute],\n-                                  close_box: bool) {\n+pub fn print_possibly_embedded_block_(s: ps,\n+                                      blk: ast::blk,\n+                                      embedded: embed_type,\n+                                      indented: uint,\n+                                      attrs: ~[ast::attribute],\n+                                      close_box: bool) {\n     match blk.node.rules {\n       ast::unsafe_blk => word_space(s, ~\"unsafe\"),\n       ast::default_blk => ()\n@@ -953,8 +965,8 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n     (s.ann.post)(ann_node);\n }\n \n-fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n-            elseopt: Option<@ast::expr>, chk: bool) {\n+pub fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n+                elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, ~\"if\");\n     if chk { word_nbsp(s, ~\"check\"); }\n     print_expr(s, test);\n@@ -993,7 +1005,7 @@ fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n     do_else(s, elseopt);\n }\n \n-fn print_mac(s: ps, m: ast::mac) {\n+pub fn print_mac(s: ps, m: ast::mac) {\n     match m.node {\n       ast::mac_invoc_tt(pth, ref tts) => {\n         print_path(s, pth, false);\n@@ -1005,7 +1017,7 @@ fn print_mac(s: ps, m: ast::mac) {\n     }\n }\n \n-fn print_vstore(s: ps, t: ast::vstore) {\n+pub fn print_vstore(s: ps, t: ast::vstore) {\n     match t {\n         ast::vstore_fixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n         ast::vstore_fixed(None) => word(s.s, ~\"_\"),\n@@ -1015,7 +1027,7 @@ fn print_vstore(s: ps, t: ast::vstore) {\n     }\n }\n \n-fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n+pub fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n     match t {\n       ast::expr_vstore_fixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n       ast::expr_vstore_fixed(None) => word(s.s, ~\"_\"),\n@@ -1033,10 +1045,10 @@ fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n     }\n }\n \n-fn print_call_pre(s: ps,\n-                  has_block: bool,\n-                  base_args: &mut ~[@ast::expr])\n-               -> Option<@ast::expr> {\n+pub fn print_call_pre(s: ps,\n+                      has_block: bool,\n+                      base_args: &mut ~[@ast::expr])\n+                   -> Option<@ast::expr> {\n     if has_block {\n         let blk_arg = base_args.pop();\n         match blk_arg.node {\n@@ -1050,10 +1062,10 @@ fn print_call_pre(s: ps,\n     }\n }\n \n-fn print_call_post(s: ps,\n-                   has_block: bool,\n-                   blk: &Option<@ast::expr>,\n-                   base_args: &mut ~[@ast::expr]) {\n+pub fn print_call_post(s: ps,\n+                       has_block: bool,\n+                       blk: &Option<@ast::expr>,\n+                       base_args: &mut ~[@ast::expr]) {\n     if !has_block || !base_args.is_empty() {\n         popen(s);\n         commasep_exprs(s, inconsistent, *base_args);\n@@ -1077,7 +1089,7 @@ fn print_call_post(s: ps,\n     }\n }\n \n-fn print_expr(s: ps, &&expr: @ast::expr) {\n+pub fn print_expr(s: ps, &&expr: @ast::expr) {\n     fn print_field(s: ps, field: ast::field) {\n         ibox(s, indent_unit);\n         if field.node.mutbl == ast::m_mutbl { word_nbsp(s, ~\"mut\"); }\n@@ -1439,15 +1451,15 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n     end(s);\n }\n \n-fn print_local_decl(s: ps, loc: @ast::local) {\n+pub fn print_local_decl(s: ps, loc: @ast::local) {\n     print_irrefutable_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n       _ => { word_space(s, ~\":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n-fn print_decl(s: ps, decl: @ast::decl) {\n+pub fn print_decl(s: ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n     match decl.node {\n       ast::decl_local(locs) => {\n@@ -1481,16 +1493,18 @@ fn print_decl(s: ps, decl: @ast::decl) {\n     }\n }\n \n-fn print_ident(s: ps, ident: ast::ident) { word(s.s, *s.intr.get(ident)); }\n+pub fn print_ident(s: ps, ident: ast::ident) {\n+    word(s.s, *s.intr.get(ident));\n+}\n \n-fn print_for_decl(s: ps, loc: @ast::local, coll: @ast::expr) {\n+pub fn print_for_decl(s: ps, loc: @ast::local, coll: @ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n     word_space(s, ~\"in\");\n     print_expr(s, coll);\n }\n \n-fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n+pub fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, ~\"::\"); }\n     let mut first = true;\n@@ -1517,15 +1531,15 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     }\n }\n \n-fn print_irrefutable_pat(s: ps, &&pat: @ast::pat) {\n+pub fn print_irrefutable_pat(s: ps, &&pat: @ast::pat) {\n     print_pat(s, pat, false)\n }\n \n-fn print_refutable_pat(s: ps, &&pat: @ast::pat) {\n+pub fn print_refutable_pat(s: ps, &&pat: @ast::pat) {\n     print_pat(s, pat, true)\n }\n \n-fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n+pub fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n@@ -1650,7 +1664,7 @@ fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n }\n \n // Returns whether it printed anything\n-fn print_self_ty(s: ps, self_ty: ast::self_ty_) -> bool {\n+pub fn print_self_ty(s: ps, self_ty: ast::self_ty_) -> bool {\n     match self_ty {\n       ast::sty_static | ast::sty_by_ref => { return false; }\n       ast::sty_value => { word(s.s, ~\"self\"); }\n@@ -1667,13 +1681,13 @@ fn print_self_ty(s: ps, self_ty: ast::self_ty_) -> bool {\n     return true;\n }\n \n-fn print_fn(s: ps,\n-            decl: ast::fn_decl,\n-            purity: Option<ast::purity>,\n-            name: ast::ident,\n-            typarams: ~[ast::ty_param],\n-            opt_self_ty: Option<ast::self_ty_>,\n-            vis: ast::visibility) {\n+pub fn print_fn(s: ps,\n+                decl: ast::fn_decl,\n+                purity: Option<ast::purity>,\n+                name: ast::ident,\n+                typarams: ~[ast::ty_param],\n+                opt_self_ty: Option<ast::self_ty_>,\n+                vis: ast::visibility) {\n     head(s, ~\"\");\n     print_fn_header_info(s, opt_self_ty, purity, ast::Many, None, vis);\n     nbsp(s);\n@@ -1682,9 +1696,9 @@ fn print_fn(s: ps,\n     print_fn_args_and_ret(s, decl, ~[], opt_self_ty);\n }\n \n-fn print_fn_args(s: ps, decl: ast::fn_decl,\n-                 cap_items: ~[ast::capture_item],\n-                 opt_self_ty: Option<ast::self_ty_>) {\n+pub fn print_fn_args(s: ps, decl: ast::fn_decl,\n+                     cap_items: ~[ast::capture_item],\n+                     opt_self_ty: Option<ast::self_ty_>) {\n     // It is unfortunate to duplicate the commasep logic, but we\n     // we want the self type, the args, and the capture clauses all\n     // in the same box.\n@@ -1709,9 +1723,9 @@ fn print_fn_args(s: ps, decl: ast::fn_decl,\n     end(s);\n }\n \n-fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n-                         cap_items: ~[ast::capture_item],\n-                         opt_self_ty: Option<ast::self_ty_>) {\n+pub fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n+                             cap_items: ~[ast::capture_item],\n+                             opt_self_ty: Option<ast::self_ty_>) {\n     popen(s);\n     print_fn_args(s, decl, cap_items, opt_self_ty);\n     pclose(s);\n@@ -1727,8 +1741,8 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n     }\n }\n \n-fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n-                       cap_items: ~[ast::capture_item]) {\n+pub fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n+                           cap_items: ~[ast::capture_item]) {\n     word(s.s, ~\"|\");\n     print_fn_args(s, decl, cap_items, None);\n     word(s.s, ~\"|\");\n@@ -1745,7 +1759,7 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-fn mode_to_str(m: ast::mode) -> ~str {\n+pub fn mode_to_str(m: ast::mode) -> ~str {\n     match m {\n       ast::expl(ast::by_move) => ~\"-\",\n       ast::expl(ast::by_ref) => ~\"&&\",\n@@ -1755,12 +1769,12 @@ fn mode_to_str(m: ast::mode) -> ~str {\n     }\n }\n \n-fn print_arg_mode(s: ps, m: ast::mode) {\n+pub fn print_arg_mode(s: ps, m: ast::mode) {\n     let ms = mode_to_str(m);\n     if ms != ~\"\" { word(s.s, ms); }\n }\n \n-fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n+pub fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n     if !bounds.is_empty() {\n         word(s.s, ~\":\");\n         let mut first = true;\n@@ -1780,7 +1794,7 @@ fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n     }\n }\n \n-fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n+pub fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n     if vec::len(params) > 0u {\n         word(s.s, ~\"<\");\n         fn printParam(s: ps, param: ast::ty_param) {\n@@ -1792,7 +1806,7 @@ fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n     }\n }\n \n-fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n+pub fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::meta_word(ref name) => word(s.s, (*name)),\n@@ -1811,7 +1825,7 @@ fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     end(s);\n }\n \n-fn print_view_path(s: ps, &&vp: @ast::view_path) {\n+pub fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, path, namespace, _) => {\n         if namespace == ast::module_ns {\n@@ -1841,11 +1855,11 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     }\n }\n \n-fn print_view_paths(s: ps, vps: ~[@ast::view_path]) {\n+pub fn print_view_paths(s: ps, vps: ~[@ast::view_path]) {\n     commasep(s, inconsistent, vps, print_view_path);\n }\n \n-fn print_view_item(s: ps, item: @ast::view_item) {\n+pub fn print_view_item(s: ps, item: @ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -1876,20 +1890,20 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n     end(s); // end outer head-block\n }\n \n-fn print_mutability(s: ps, mutbl: ast::mutability) {\n+pub fn print_mutability(s: ps, mutbl: ast::mutability) {\n     match mutbl {\n       ast::m_mutbl => word_nbsp(s, ~\"mut\"),\n       ast::m_const => word_nbsp(s, ~\"const\"),\n       ast::m_imm => {/* nothing */ }\n     }\n }\n \n-fn print_mt(s: ps, mt: ast::mt) {\n+pub fn print_mt(s: ps, mt: ast::mt) {\n     print_mutability(s, mt.mutbl);\n     print_type(s, mt.ty);\n }\n \n-fn print_arg(s: ps, input: ast::arg) {\n+pub fn print_arg(s: ps, input: ast::arg) {\n     ibox(s, indent_unit);\n     print_arg_mode(s, input.mode);\n     if input.is_mutbl {\n@@ -1916,15 +1930,15 @@ fn print_arg(s: ps, input: ast::arg) {\n     end(s);\n }\n \n-fn print_ty_fn(s: ps,\n-               opt_proto: Option<ast::Proto>,\n-               opt_region: Option<@ast::region>,\n-               purity: ast::purity,\n-               onceness: ast::Onceness,\n-               bounds: @~[ast::ty_param_bound],\n-               decl: ast::fn_decl, id: Option<ast::ident>,\n-               tps: Option<~[ast::ty_param]>,\n-               opt_self_ty: Option<ast::self_ty_>) {\n+pub fn print_ty_fn(s: ps,\n+                   opt_proto: Option<ast::Proto>,\n+                   opt_region: Option<@ast::region>,\n+                   purity: ast::purity,\n+                   onceness: ast::Onceness,\n+                   bounds: @~[ast::ty_param_bound],\n+                   decl: ast::fn_decl, id: Option<ast::ident>,\n+                   tps: Option<~[ast::ty_param]>,\n+                   opt_self_ty: Option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n \n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n@@ -1973,8 +1987,8 @@ fn print_ty_fn(s: ps,\n     end(s);\n }\n \n-fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n-                                next_pos: Option<BytePos>) {\n+pub fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n+                                    next_pos: Option<BytePos>) {\n     let mut cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }\n     match next_comment(s) {\n@@ -1994,7 +2008,7 @@ fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n     }\n }\n \n-fn print_remaining_comments(s: ps) {\n+pub fn print_remaining_comments(s: ps) {\n     // If there aren't any remaining comments, then we need to manually\n     // make sure there is a line break at the end.\n     if next_comment(s).is_none() { hardbreak(s.s); }\n@@ -2006,7 +2020,7 @@ fn print_remaining_comments(s: ps) {\n     }\n }\n \n-fn print_literal(s: ps, &&lit: @ast::lit) {\n+pub fn print_literal(s: ps, &&lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n@@ -2054,11 +2068,11 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n     }\n }\n \n-fn lit_to_str(l: @ast::lit) -> ~str {\n+pub fn lit_to_str(l: @ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n-fn next_lit(s: ps, pos: BytePos) -> Option<comments::lit> {\n+pub fn next_lit(s: ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n       Some(ref lits) => {\n         while s.cur_lit < vec::len((*lits)) {\n@@ -2073,7 +2087,7 @@ fn next_lit(s: ps, pos: BytePos) -> Option<comments::lit> {\n     }\n }\n \n-fn maybe_print_comment(s: ps, pos: BytePos) {\n+pub fn maybe_print_comment(s: ps, pos: BytePos) {\n     loop {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n@@ -2087,7 +2101,7 @@ fn maybe_print_comment(s: ps, pos: BytePos) {\n     }\n }\n \n-fn print_comment(s: ps, cmnt: comments::cmnt) {\n+pub fn print_comment(s: ps, cmnt: comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n         assert (vec::len(cmnt.lines) == 1u);\n@@ -2131,21 +2145,21 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n     }\n }\n \n-fn print_string(s: ps, st: ~str) {\n+pub fn print_string(s: ps, st: ~str) {\n     word(s.s, ~\"\\\"\");\n     word(s.s, str::escape_default(st));\n     word(s.s, ~\"\\\"\");\n }\n \n-fn to_str<T>(t: T, f: fn@(ps, T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T>(t: T, f: fn@(ps, T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         f(s, t);\n         eof(s.s);\n     }\n }\n \n-fn next_comment(s: ps) -> Option<comments::cmnt> {\n+pub fn next_comment(s: ps) -> Option<comments::cmnt> {\n     match s.comments {\n       Some(ref cmnts) => {\n         if s.cur_cmnt < vec::len((*cmnts)) {\n@@ -2156,15 +2170,15 @@ fn next_comment(s: ps) -> Option<comments::cmnt> {\n     }\n }\n \n-fn print_self_ty_if_static(s: ps,\n-                           opt_self_ty: Option<ast::self_ty_>) {\n+pub fn print_self_ty_if_static(s: ps,\n+                               opt_self_ty: Option<ast::self_ty_>) {\n     match opt_self_ty {\n         Some(ast::sty_static) => { word(s.s, ~\"static \"); }\n         _ => {}\n     }\n }\n \n-fn print_opt_purity(s: ps, opt_purity: Option<ast::purity>) {\n+pub fn print_opt_purity(s: ps, opt_purity: Option<ast::purity>) {\n     match opt_purity {\n         Some(ast::impure_fn) => { }\n         Some(purity) => {\n@@ -2174,7 +2188,7 @@ fn print_opt_purity(s: ps, opt_purity: Option<ast::purity>) {\n     }\n }\n \n-fn print_opt_proto(s: ps, opt_proto: Option<ast::Proto>) {\n+pub fn print_opt_proto(s: ps, opt_proto: Option<ast::Proto>) {\n     match opt_proto {\n         Some(ast::ProtoBare) => { word(s.s, ~\"extern \"); }\n         Some(ast::ProtoBorrowed) => { word(s.s, ~\"&\"); }\n@@ -2184,13 +2198,12 @@ fn print_opt_proto(s: ps, opt_proto: Option<ast::Proto>) {\n     };\n }\n \n-fn print_fn_header_info(s: ps,\n-                        opt_sty: Option<ast::self_ty_>,\n-                        opt_purity: Option<ast::purity>,\n-                        onceness: ast::Onceness,\n-                        opt_proto: Option<ast::Proto>,\n-                        vis: ast::visibility)\n-{\n+pub fn print_fn_header_info(s: ps,\n+                            opt_sty: Option<ast::self_ty_>,\n+                            opt_purity: Option<ast::purity>,\n+                            onceness: ast::Onceness,\n+                            opt_proto: Option<ast::Proto>,\n+                            vis: ast::visibility) {\n     print_self_ty_if_static(s, opt_sty);\n     word(s.s, visibility_qualified(vis, ~\"\"));\n     print_opt_purity(s, opt_purity);\n@@ -2199,14 +2212,14 @@ fn print_fn_header_info(s: ps,\n     print_opt_proto(s, opt_proto);\n }\n \n-fn opt_proto_to_str(opt_p: Option<ast::Proto>) -> ~str {\n+pub fn opt_proto_to_str(opt_p: Option<ast::Proto>) -> ~str {\n     match opt_p {\n       None => ~\"fn\",\n       Some(p) => proto_to_str(p)\n     }\n }\n \n-pure fn purity_to_str(p: ast::purity) -> ~str {\n+pub pure fn purity_to_str(p: ast::purity) -> ~str {\n     match p {\n       ast::impure_fn => ~\"impure\",\n       ast::unsafe_fn => ~\"unsafe\",\n@@ -2215,28 +2228,28 @@ pure fn purity_to_str(p: ast::purity) -> ~str {\n     }\n }\n \n-pure fn onceness_to_str(o: ast::Onceness) -> ~str {\n+pub pure fn onceness_to_str(o: ast::Onceness) -> ~str {\n     match o {\n         ast::Once => ~\"once\",\n         ast::Many => ~\"many\"\n     }\n }\n \n-fn print_purity(s: ps, p: ast::purity) {\n+pub fn print_purity(s: ps, p: ast::purity) {\n     match p {\n       ast::impure_fn => (),\n       _ => word_nbsp(s, purity_to_str(p))\n     }\n }\n \n-fn print_onceness(s: ps, o: ast::Onceness) {\n+pub fn print_onceness(s: ps, o: ast::Onceness) {\n     match o {\n         ast::Once => { word_nbsp(s, ~\"once\"); }\n         ast::Many => {}\n     }\n }\n \n-fn proto_to_str(p: ast::Proto) -> ~str {\n+pub fn proto_to_str(p: ast::Proto) -> ~str {\n     return match p {\n       ast::ProtoBare => ~\"extern fn\",\n       ast::ProtoBorrowed => ~\"fn&\",\n@@ -2246,7 +2259,7 @@ fn proto_to_str(p: ast::Proto) -> ~str {\n }\n \n #[cfg(test)]\n-mod test {\n+pub mod test {\n     use ast;\n     use ast_util;\n     use parse;"}, {"sha": "dc5964e6a1202c56ba8d3a5a4c63450eb0f36789", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 36, "deletions": 61, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -17,7 +17,6 @@\n #[crate_type = \"lib\"];\n \n #[legacy_modes];\n-#[legacy_exports];\n #[legacy_records];\n \n #[allow(vecs_implicitly_copyable)];\n@@ -38,76 +37,52 @@ pub mod syntax {\n     pub use parse;\n }\n \n-mod attr;\n-mod diagnostic;\n-mod codemap;\n-mod ast;\n-mod ast_util;\n-mod ast_map;\n-#[legacy_exports]\n-mod visit;\n-#[legacy_exports]\n-mod fold;\n-#[legacy_exports]\n-mod util {\n-    #[legacy_exports];\n-    #[legacy_exports]\n+pub mod attr;\n+pub mod diagnostic;\n+pub mod codemap;\n+pub mod ast;\n+pub mod ast_util;\n+pub mod ast_map;\n+pub mod visit;\n+pub mod fold;\n+pub mod util {\n     #[path = \"interner.rs\"]\n-    mod interner;\n+    pub mod interner;\n }\n \n #[path = \"parse/mod.rs\"]\n-mod parse;\n-\n-mod print {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    mod pp;\n-    #[legacy_exports]\n-    mod pprust;\n+pub mod parse;\n+\n+pub mod print {\n+    pub mod pp;\n+    pub mod pprust;\n }\n \n-mod ext {\n-    #[legacy_exports];\n-    #[legacy_exports]\n-    mod base;\n-    #[legacy_exports]\n-    mod expand;\n-\n-    mod quote;\n-    mod deriving;\n-\n-    #[legacy_exports]\n-    mod build;\n-\n-    mod tt {\n-        #[legacy_exports];\n-        #[legacy_exports]\n-        mod transcribe;\n-        #[legacy_exports]\n-        mod macro_parser;\n-        #[legacy_exports]\n-        mod macro_rules;\n+pub mod ext {\n+    pub mod base;\n+    pub mod expand;\n+\n+    pub mod quote;\n+    pub mod deriving;\n+\n+    pub mod build;\n+\n+    pub mod tt {\n+        pub mod transcribe;\n+        pub mod macro_parser;\n+        pub mod macro_rules;\n     }\n \n \n-    #[legacy_exports]\n-    mod fmt;\n-    #[legacy_exports]\n-    mod env;\n-    #[legacy_exports]\n-    mod concat_idents;\n-    #[legacy_exports]\n-    mod log_syntax;\n-    #[legacy_exports]\n-    mod auto_encode;\n-    #[legacy_exports]\n-    mod source_util;\n+    pub mod fmt;\n+    pub mod env;\n+    pub mod concat_idents;\n+    pub mod log_syntax;\n+    pub mod auto_encode;\n+    pub mod source_util;\n \n     #[path = \"pipes/mod.rs\"]\n-    #[legacy_exports]\n-    mod pipes;\n+    pub mod pipes;\n \n-    #[legacy_exports]\n-    mod trace_macros;\n+    pub mod trace_macros;\n }"}, {"sha": "23db470391a42adb7fb426b4ee3555e6c7f52cfa", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -18,33 +18,31 @@ use core::dvec::DVec;\n use std::map::HashMap;\n use std::map;\n \n-type hash_interner<T> =\n-    {map: HashMap<T, uint>,\n-     vect: DVec<T>};\n+pub type hash_interner<T> = {map: HashMap<T, uint>, vect: DVec<T>};\n \n-fn mk<T:Eq IterBytes Hash Const Copy>() -> Interner<T> {\n+pub fn mk<T:Eq IterBytes Hash Const Copy>() -> Interner<T> {\n     let m = map::HashMap::<T, uint>();\n     let hi: hash_interner<T> =\n         {map: m, vect: DVec()};\n     move ((move hi) as Interner::<T>)\n }\n \n-fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: &[T]) -> Interner<T> {\n+pub fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: &[T]) -> Interner<T> {\n     let rv = mk();\n     for init.each() |v| { rv.intern(*v); }\n     return rv;\n }\n \n \n /* when traits can extend traits, we should extend index<uint,T> to get [] */\n-trait Interner<T:Eq IterBytes Hash Const Copy> {\n+pub trait Interner<T:Eq IterBytes Hash Const Copy> {\n     fn intern(T) -> uint;\n     fn gensym(T) -> uint;\n     pure fn get(uint) -> T;\n     fn len() -> uint;\n }\n \n-impl <T:Eq IterBytes Hash Const Copy> hash_interner<T>: Interner<T> {\n+pub impl <T:Eq IterBytes Hash Const Copy> hash_interner<T>: Interner<T> {\n     fn intern(val: T) -> uint {\n         match self.map.find(val) {\n           Some(idx) => return idx,\n@@ -74,13 +72,13 @@ impl <T:Eq IterBytes Hash Const Copy> hash_interner<T>: Interner<T> {\n \n #[test]\n #[should_fail]\n-fn i1 () {\n+pub fn i1 () {\n     let i : Interner<@~str> = mk();\n     i.get(13);\n }\n \n #[test]\n-fn i2 () {\n+pub fn i2 () {\n     let i : Interner<@~str> = mk();\n     // first one is zero:\n     assert i.intern (@~\"dog\") == 0;\n@@ -105,7 +103,7 @@ fn i2 () {\n }\n \n #[test]\n-fn i3 () {\n+pub fn i3 () {\n     let i : Interner<@~str> = mk_prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n     assert i.get(0) == @~\"Alan\";\n     assert i.get(1) == @~\"Bob\";"}, {"sha": "196ee349b7934e37dbe241786d9f3828340432f4", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07059056463272788042a263b6cf8eb8be2533a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b07059056463272788042a263b6cf8eb8be2533a", "patch": "@@ -27,9 +27,9 @@ use core::vec;\n \n // Our typesystem doesn't do circular types, so the visitor record can not\n // hold functions that take visitors. A vt enum is used to break the cycle.\n-enum vt<E> { mk_vt(visitor<E>), }\n+pub enum vt<E> { mk_vt(visitor<E>), }\n \n-enum fn_kind {\n+pub enum fn_kind {\n     fk_item_fn(ident, ~[ty_param], purity), //< an item declared with fn()\n     fk_method(ident, ~[ty_param], @method),\n     fk_anon(Proto, capture_clause),  //< an anonymous function like fn@(...)\n@@ -39,7 +39,7 @@ enum fn_kind {\n \n }\n \n-fn name_of_fn(fk: fn_kind) -> ident {\n+pub fn name_of_fn(fk: fn_kind) -> ident {\n     match fk {\n       fk_item_fn(name, _, _) | fk_method(name, _, _) => {\n           /* FIXME (#2543) */ copy name\n@@ -49,7 +49,7 @@ fn name_of_fn(fk: fn_kind) -> ident {\n     }\n }\n \n-fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n+pub fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n     match fk {\n         fk_item_fn(_, tps, _) | fk_method(_, tps, _) |\n         fk_dtor(tps, _, _, _) => {\n@@ -59,7 +59,7 @@ fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n     }\n }\n \n-struct Visitor<E> {\n+pub struct Visitor<E> {\n     visit_mod: fn@(_mod, span, node_id, E, vt<E>),\n     visit_view_item: fn@(@view_item, E, vt<E>),\n     visit_foreign_item: fn@(@foreign_item, E, vt<E>),\n@@ -83,9 +83,9 @@ struct Visitor<E> {\n     visit_struct_method: fn@(@method, E, vt<E>)\n }\n \n-type visitor<E> = @Visitor<E>;\n+pub type visitor<E> = @Visitor<E>;\n \n-fn default_visitor<E>() -> visitor<E> {\n+pub fn default_visitor<E>() -> visitor<E> {\n     return @Visitor {\n         visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n         visit_view_item: |a,b,c|visit_view_item::<E>(a, b, c),\n@@ -111,18 +111,18 @@ fn default_visitor<E>() -> visitor<E> {\n     };\n }\n \n-fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n+pub fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n     (v.visit_mod)(c.node.module, c.span, crate_node_id, e, v);\n }\n \n-fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n+pub fn visit_mod<E>(m: _mod, _sp: span, _id: node_id, e: E, v: vt<E>) {\n     for m.view_items.each |vi| { (v.visit_view_item)(*vi, e, v); }\n     for m.items.each |i| { (v.visit_item)(*i, e, v); }\n }\n \n-fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n+pub fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n \n-fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n+pub fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     (v.visit_pat)(loc.node.pat, e, v);\n     (v.visit_ty)(loc.node.ty, e, v);\n     match loc.node.init {\n@@ -131,7 +131,7 @@ fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n+pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n       item_const(t, ex) => {\n         (v.visit_ty)(t, e, v);\n@@ -181,8 +181,10 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_enum_def<E>(enum_definition: ast::enum_def, tps: ~[ast::ty_param],\n-                     e: E, v: vt<E>) {\n+pub fn visit_enum_def<E>(enum_definition: ast::enum_def,\n+                         tps: ~[ast::ty_param],\n+                         e: E,\n+                         v: vt<E>) {\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(variant_args) => {\n@@ -201,9 +203,9 @@ fn visit_enum_def<E>(enum_definition: ast::enum_def, tps: ~[ast::ty_param],\n     }\n }\n \n-fn skip_ty<E>(_t: @Ty, _e: E, _v: vt<E>) {}\n+pub fn skip_ty<E>(_t: @Ty, _e: E, _v: vt<E>) {}\n \n-fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n+pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     match t.node {\n       ty_box(mt) | ty_uniq(mt) |\n       ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n@@ -229,11 +231,11 @@ fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n+pub fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n     for p.types.each |tp| { (v.visit_ty)(*tp, e, v); }\n }\n \n-fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n+pub fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n       pat_enum(path, children) => {\n         visit_path(path, e, v);\n@@ -275,7 +277,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n+pub fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n       foreign_item_fn(fd, _, tps) => {\n         (v.visit_ty_params)(tps, e, v);\n@@ -287,7 +289,7 @@ fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n+pub fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n     for bounds.each |&bound| {\n         match bound {\n             TraitTyParamBound(ty) => (v.visit_ty)(ty, e, v),\n@@ -296,13 +298,13 @@ fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n+pub fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n     for tps.each |tp| {\n         visit_ty_param_bounds(tp.bounds, e, v);\n     }\n }\n \n-fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n+pub fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     for fd.inputs.each |a| {\n         (v.visit_pat)(a.pat, e, v);\n         (v.visit_ty)(a.ty, e, v);\n@@ -314,42 +316,42 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n+pub fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n     (v.visit_fn)(fk_method(/* FIXME (#2543) */ copy m.ident,\n                          /* FIXME (#2543) */ copy m.tps, m),\n                m.decl, m.body, m.span, m.id, e, v);\n }\n \n-fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: ~[ty_param],\n-                              parent_id: def_id, e: E, v: vt<E>) {\n+pub fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: ~[ty_param],\n+                                   parent_id: def_id, e: E, v: vt<E>) {\n     (v.visit_fn)(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.attrs,\n                        dtor.node.self_id, parent_id), ast_util::dtor_dec(),\n                dtor.node.body, dtor.span, dtor.node.id, e, v)\n \n }\n \n-fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n-               _id: node_id, e: E, v: vt<E>) {\n+pub fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n+                   _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n     (v.visit_ty_params)(tps_of_fn(fk), e, v);\n     (v.visit_block)(body, e, v);\n }\n \n-fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n+pub fn visit_ty_method<E>(m: ty_method, e: E, v: vt<E>) {\n     for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n     (v.visit_ty_params)(m.tps, e, v);\n     (v.visit_ty)(m.decl.output, e, v);\n }\n \n-fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n+pub fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n     match m {\n       required(ref ty_m) => (v.visit_ty_method)((*ty_m), e, v),\n       provided(m) => visit_method_helper(m, e, v)\n     }\n }\n \n-fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n-                       id: node_id, e: E, v: vt<E>) {\n+pub fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n+                           id: node_id, e: E, v: vt<E>) {\n     for sd.fields.each |f| {\n         (v.visit_struct_field)(*f, e, v);\n     }\n@@ -358,15 +360,15 @@ fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n     };\n }\n \n-fn visit_struct_field<E>(sf: @struct_field, e: E, v: vt<E>) {\n+pub fn visit_struct_field<E>(sf: @struct_field, e: E, v: vt<E>) {\n     (v.visit_ty)(sf.node.ty, e, v);\n }\n \n-fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n+pub fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n     visit_method_helper(m, e, v);\n }\n \n-fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n+pub fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n     for b.node.view_items.each |vi| {\n         (v.visit_view_item)(*vi, e, v);\n     }\n@@ -376,7 +378,7 @@ fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n-fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n+pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n     match s.node {\n       stmt_decl(d, _) => (v.visit_decl)(d, e, v),\n       stmt_expr(ex, _) => (v.visit_expr)(ex, e, v),\n@@ -385,7 +387,7 @@ fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n+pub fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     match d.node {\n       decl_local(locs) => for locs.each |loc| {\n         (v.visit_local)(*loc, e, v)\n@@ -394,19 +396,19 @@ fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n+pub fn visit_expr_opt<E>(eo: Option<@expr>, e: E, v: vt<E>) {\n     match eo { None => (), Some(ex) => (v.visit_expr)(ex, e, v) }\n }\n \n-fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n+pub fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n-fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n+pub fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n     /* no user-serviceable parts inside */\n }\n \n-fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n+pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     match ex.node {\n       expr_vstore(x, _) => (v.visit_expr)(x, e, v),\n       expr_vec(es, _) => visit_exprs(es, e, v),\n@@ -498,7 +500,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     (v.visit_expr_post)(ex, e, v);\n }\n \n-fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n+pub fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n     for a.pats.each |p| { (v.visit_pat)(*p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n     (v.visit_block)(a.body, e, v);\n@@ -507,7 +509,7 @@ fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n // Simpler, non-context passing interface. Always walks the whole tree, simply\n // calls the given functions on the nodes.\n \n-struct SimpleVisitor {\n+pub struct SimpleVisitor {\n     visit_mod: fn@(_mod, span, node_id),\n     visit_view_item: fn@(@view_item),\n     visit_foreign_item: fn@(@foreign_item),\n@@ -530,11 +532,11 @@ struct SimpleVisitor {\n     visit_struct_method: fn@(@method)\n }\n \n-type simple_visitor = @SimpleVisitor;\n+pub type simple_visitor = @SimpleVisitor;\n \n-fn simple_ignore_ty(_t: @Ty) {}\n+pub fn simple_ignore_ty(_t: @Ty) {}\n \n-fn default_simple_visitor() -> @SimpleVisitor {\n+pub fn default_simple_visitor() -> @SimpleVisitor {\n     return @SimpleVisitor {visit_mod: |_m: _mod, _sp: span, _id: node_id| { },\n           visit_view_item: |_vi: @view_item| { },\n           visit_foreign_item: |_ni: @foreign_item| { },\n@@ -560,7 +562,7 @@ fn default_simple_visitor() -> @SimpleVisitor {\n          };\n }\n \n-fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n+pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_mod(f: fn@(_mod, span, node_id), m: _mod, sp: span, id: node_id,\n              &&e: (), v: vt<()>) {\n         f(m, sp, id);"}]}