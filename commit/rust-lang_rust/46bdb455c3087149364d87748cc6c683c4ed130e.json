{"sha": "46bdb455c3087149364d87748cc6c683c4ed130e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2YmRiNDU1YzMwODcxNDkzNjRkODc3NDhjYzZjNjgzYzRlZDEzMGU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2014-11-22T10:42:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2014-11-22T10:42:36Z"}, "message": "Merge pull request #1 from rust-lang/master\n\nUpdate from original", "tree": {"sha": "dc76887d794a06ff3da070ce0951d78f8d4eae64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc76887d794a06ff3da070ce0951d78f8d4eae64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46bdb455c3087149364d87748cc6c683c4ed130e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46bdb455c3087149364d87748cc6c683c4ed130e", "html_url": "https://github.com/rust-lang/rust/commit/46bdb455c3087149364d87748cc6c683c4ed130e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46bdb455c3087149364d87748cc6c683c4ed130e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f530aa08dfcdaeb249341bdd1a9797780b4294c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f530aa08dfcdaeb249341bdd1a9797780b4294c2", "html_url": "https://github.com/rust-lang/rust/commit/f530aa08dfcdaeb249341bdd1a9797780b4294c2"}, {"sha": "7765993d62b8f8653f79bfb8a2a8702f7ec19919", "url": "https://api.github.com/repos/rust-lang/rust/commits/7765993d62b8f8653f79bfb8a2a8702f7ec19919", "html_url": "https://github.com/rust-lang/rust/commit/7765993d62b8f8653f79bfb8a2a8702f7ec19919"}], "stats": {"total": 1068, "additions": 624, "deletions": 444}, "files": [{"sha": "83f9bbff8aa6eafea09aaa58b2b2806afe967333", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -121,6 +121,7 @@ Cole Mickens <cole.mickens@gmail.com>\n Colin Davidson <colrdavidson@gmail.com>\n Colin Sherratt <colin.sherratt@gmail.com>\n Conrad Kleinespel <conradk@conradk.com>\n+Corey Farwell <coreyf+rust@rwell.org>\n Corey Ford <corey@coreyford.name>\n Corey Richardson <corey@octayn.net>\n DJUrsus <colinvh@divitu.com>"}, {"sha": "8a6ba86dd475ecf13505e2119ed6de7e42c5a8bb", "filename": "configure", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/configure", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -893,7 +893,10 @@ CFG_PREFIX=${CFG_PREFIX%/}\n CFG_MANDIR=${CFG_MANDIR%/}\n CFG_HOST=\"$(echo $CFG_HOST | tr ',' ' ')\"\n CFG_TARGET=\"$(echo $CFG_TARGET | tr ',' ' ')\"\n-CFG_SUPPORTED_TARGET=\"$(ls ${CFG_SRC_DIR}mk/cfg)\"\n+CFG_SUPPORTED_TARGET=\"\"\n+for target_file in ${CFG_SRC_DIR}mk/cfg/*.mk; do\n+  CFG_SUPPORTED_TARGET=\"${CFG_SUPPORTED_TARGET} $(basename \"$target_file\" .mk)\"\n+done\n \n # copy host-triples to target-triples so that hosts are a subset of targets\n V_TEMP=\"\""}, {"sha": "d1f1ee6f3bdb42b88b0248baeb86319180f055f0", "filename": "mk/cfg/arm-apple-ios.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Farm-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Farm-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-apple-ios.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/arm-apple-ios"}, {"sha": "471220e2b6618ae08bb6726c0489b39ed3b5c358", "filename": "mk/cfg/arm-linux-androideabi.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Farm-linux-androideabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Farm-linux-androideabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-linux-androideabi.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/arm-linux-androideabi"}, {"sha": "b4c604b26bae04eda24ecf4b801c37fc55489e67", "filename": "mk/cfg/arm-unknown-linux-gnueabi.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabi.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/arm-unknown-linux-gnueabi"}, {"sha": "4f02de0f6b5e67893d589ffea47831a22b6a3d38", "filename": "mk/cfg/arm-unknown-linux-gnueabihf.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-unknown-linux-gnueabihf.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/arm-unknown-linux-gnueabihf"}, {"sha": "63eb590c6e4f6962a8f67487c9554acfbe728992", "filename": "mk/cfg/i386-apple-ios.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fi386-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fi386-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi386-apple-ios.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/i386-apple-ios"}, {"sha": "e935ce053e02aa273b0423522cd427446d89a326", "filename": "mk/cfg/i686-apple-darwin.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fi686-apple-darwin.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fi686-apple-darwin.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-apple-darwin.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/i686-apple-darwin"}, {"sha": "ecb405b76f0109634d007b91eff1ced4596ac964", "filename": "mk/cfg/i686-pc-windows-gnu.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fi686-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fi686-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-pc-windows-gnu.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/i686-pc-windows-gnu"}, {"sha": "1cc9c143e8d470860a269334b94929f10bcfc934", "filename": "mk/cfg/i686-unknown-linux-gnu.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-linux-gnu.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/i686-unknown-linux-gnu"}, {"sha": "c5d84966f8526f332b2a19b3d3ab3c00e1eb88b7", "filename": "mk/cfg/mips-unknown-linux-gnu.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmips-unknown-linux-gnu.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/mips-unknown-linux-gnu"}, {"sha": "eb2f300abffd8072665fab3d8c68ac8a527ee6e9", "filename": "mk/cfg/mipsel-unknown-linux-gnu.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fmipsel-unknown-linux-gnu.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/mipsel-unknown-linux-gnu"}, {"sha": "dbd67542ab75a08c994c27454a6189ba8297ef3c", "filename": "mk/cfg/x86_64-apple-darwin.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-apple-darwin.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-apple-darwin.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-darwin.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/x86_64-apple-darwin"}, {"sha": "a23e292c7bd5d8cd255ee34c8760b6972a1dc453", "filename": "mk/cfg/x86_64-pc-windows-gnu.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/x86_64-pc-windows-gnu"}, {"sha": "05414c79dd78e80be17d814240ee210c60fa33ab", "filename": "mk/cfg/x86_64-unknown-dragonfly.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-dragonfly.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/x86_64-unknown-dragonfly"}, {"sha": "4e847ea78a717e13f258003aa3b56447a837cc29", "filename": "mk/cfg/x86_64-unknown-freebsd.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-freebsd.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/x86_64-unknown-freebsd"}, {"sha": "845f9c1c52d19fedb6aeef1c3bb362bfad9ce342", "filename": "mk/cfg/x86_64-unknown-linux-gnu.mk", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "previous_filename": "mk/cfg/x86_64-unknown-linux-gnu"}, {"sha": "7ca24736cb8593b27eb916b3f50902dcef15c1cd", "filename": "mk/platform.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -113,7 +113,7 @@ $(foreach cvar,CC CXX CPP CFLAGS CXXFLAGS CPPFLAGS, \\\n \n CFG_RLIB_GLOB=lib$(1)-*.rlib\n \n-include $(wildcard $(CFG_SRC_DIR)mk/cfg/*)\n+include $(wildcard $(CFG_SRC_DIR)mk/cfg/*.mk)\n \n # The -Qunused-arguments sidesteps spurious warnings from clang\n define FILTER_FLAGS"}, {"sha": "9bf45de0a17d45deba904d9e3aa1d73cdc372bce", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -1566,7 +1566,7 @@ fn _arm_exec_compiled_test(config: &Config,\n \n     let mut exitcode: int = 0;\n     for c in exitcode_out.as_slice().chars() {\n-        if !c.is_digit() { break; }\n+        if !c.is_numeric() { break; }\n         exitcode = exitcode * 10 + match c {\n             '0' ... '9' => c as int - ('0' as int),\n             _ => 101,"}, {"sha": "ed487a308e199d6a3d19fdfe8f16b0c1d3ebe6cf", "filename": "src/etc/vim/compiler/cargo.vim", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -1,29 +1,35 @@\n \" Vim compiler file\n \" Compiler:         Cargo Compiler\n \" Maintainer:       Damien Radtke <damienradtke@gmail.com>\n-\" Latest Revision:  2014 Sep 18\n+\" Latest Revision:  2014 Sep 24\n \n-if exists(\"current_compiler\")\n+if exists('current_compiler')\n   finish\n endif\n+runtime compiler/rustc.vim\n let current_compiler = \"cargo\"\n \n-if exists(\":CompilerSet\") != 2\n+if exists(':CompilerSet') != 2\n     command -nargs=* CompilerSet setlocal <args>\n endif\n \n-CompilerSet errorformat&\n-CompilerSet makeprg=cargo\\ $*\n+if exists('g:cargo_makeprg_params')\n+    execute 'CompilerSet makeprg=cargo\\ '.escape(g:cargo_makeprg_params, ' \\|\"').'\\ $*'\n+else\n+    CompilerSet makeprg=cargo\\ $*\n+endif\n \n \" Allow a configurable global Cargo.toml name. This makes it easy to\n \" support variations like 'cargo.toml'.\n-if !exists('g:cargo_toml_name')\n-    let g:cargo_toml_name = 'Cargo.toml'\n-endif\n+let s:cargo_manifest_name = get(g:, 'cargo_manifest_name', 'Cargo.toml')\n \n-let s:toml_dir = fnamemodify(findfile(g:cargo_toml_name, '.;'), ':p:h').'/'\n+function! s:is_absolute(path)\n+    return a:path[0] == '/' || a:path =~ '[A-Z]\\+:'\n+endfunction\n \n-if s:toml_dir != ''\n+let s:local_manifest = findfile(s:cargo_manifest_name, '.;')\n+if s:local_manifest != ''\n+    let s:local_manifest = fnamemodify(s:local_manifest, ':p:h').'/'\n     augroup cargo\n         au!\n         au QuickfixCmdPost make call s:FixPaths()\n@@ -33,15 +39,25 @@ if s:toml_dir != ''\n     \" to be relative to the current directory instead of Cargo.toml.\n     function! s:FixPaths()\n         let qflist = getqflist()\n+        let manifest = s:local_manifest\n         for qf in qflist\n-            if !qf['valid']\n+            if !qf.valid\n+                let m = matchlist(qf.text, '(file://\\(.*\\))$')\n+                if !empty(m)\n+                    let manifest = m[1].'/'\n+                    \" Manually strip another slash if needed; usually just an\n+                    \" issue on Windows.\n+                    if manifest =~ '^/[A-Z]\\+:/'\n+                        let manifest = manifest[1:]\n+                    endif\n+                endif\n                 continue\n             endif\n-            let filename = bufname(qf['bufnr'])\n-            if stridx(filename, s:toml_dir) == -1\n-                let filename = s:toml_dir.filename\n+            let filename = bufname(qf.bufnr)\n+            if s:is_absolute(filename)\n+                continue\n             endif\n-            let qf['filename'] = simplify(s:toml_dir.bufname(qf['bufnr']))\n+            let qf.filename = simplify(manifest.filename)\n             call remove(qf, 'bufnr')\n         endfor\n         call setqflist(qflist, 'r')"}, {"sha": "e117b0c155b762d979ae96324ee1991b338737ef", "filename": "src/etc/vim/doc/rust.txt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Fetc%2Fvim%2Fdoc%2Frust.txt", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Fetc%2Fvim%2Fdoc%2Frust.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fdoc%2Frust.txt?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -88,6 +88,13 @@ g:ftplugin_rust_source_path~\n \t    let g:ftplugin_rust_source_path = $HOME.'/dev/rust'\n <\n \n+                                                       *g:cargo_manifest_name*\n+g:cargo_manifest_name~\n+\tSet this option to the name of the manifest file for your projects. If\n+\tnot specified it defaults to 'Cargo.toml' : >\n+\t    let g:cargo_manifest_name = 'Cargo.toml'\n+<\n+\n ==============================================================================\n COMMANDS                                                       *rust-commands*\n "}, {"sha": "0fe40081a46235f6d527f7b87c7df43e828930b3", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -630,7 +630,9 @@ pub trait StrAllocating: Str {\n         let me = self.as_slice();\n         let mut out = String::with_capacity(me.len());\n         for c in me.chars() {\n-            c.escape_default(|c| out.push(c));\n+            for c in c.escape_default() {\n+                out.push(c);\n+            }\n         }\n         out\n     }\n@@ -640,7 +642,9 @@ pub trait StrAllocating: Str {\n         let me = self.as_slice();\n         let mut out = String::with_capacity(me.len());\n         for c in me.chars() {\n-            c.escape_unicode(|c| out.push(c));\n+            for c in c.escape_unicode() {\n+                out.push(c);\n+            }\n         }\n         out\n     }\n@@ -1189,7 +1193,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_left_chars(chars), \"foo1bar12\");\n-        assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\");\n+        assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_numeric()), \"foo1bar123\");\n     }\n \n     #[test]\n@@ -1204,7 +1208,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_right_chars(chars), \"12foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_numeric()), \"123foo1bar\");\n     }\n \n     #[test]\n@@ -1219,7 +1223,7 @@ mod tests {\n         assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n         let chars: &[char] = &['1', '2'];\n         assert_eq!(\"12foo1bar12\".trim_chars(chars), \"foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_numeric()), \"foo1bar\");\n     }\n \n     #[test]"}, {"sha": "272b36847991f8eb97b4d746c7673e554bab8870", "filename": "src/libcore/char.rs", "status": "modified", "additions": 207, "deletions": 61, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -17,7 +17,7 @@\n \n use mem::transmute;\n use option::{None, Option, Some};\n-use iter::range_step;\n+use iter::{range_step, Iterator, RangeStep};\n use slice::SlicePrelude;\n \n // UTF-8 ranges and tags for encoding characters\n@@ -63,10 +63,12 @@ static MAX_THREE_B: u32 =  0x10000u32;\n */\n \n /// The highest valid code point\n+#[stable]\n pub const MAX: char = '\\U0010ffff';\n \n /// Converts from `u32` to a `char`\n #[inline]\n+#[unstable = \"pending decisions about costructors for primitives\"]\n pub fn from_u32(i: u32) -> Option<char> {\n     // catch out-of-bounds and surrogates\n     if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n@@ -96,11 +98,9 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// This just wraps `to_digit()`.\n ///\n #[inline]\n+#[deprecated = \"use the Char::is_digit method\"]\n pub fn is_digit_radix(c: char, radix: uint) -> bool {\n-    match to_digit(c, radix) {\n-        Some(_) => true,\n-        None    => false,\n-    }\n+    c.is_digit(radix)\n }\n \n ///\n@@ -118,18 +118,9 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n /// Panics if given a `radix` outside the range `[0..36]`.\n ///\n #[inline]\n+#[deprecated = \"use the Char::to_digit method\"]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n-    if radix > 36 {\n-        panic!(\"to_digit: radix is too high (maximum 36)\");\n-    }\n-    let val = match c {\n-      '0' ... '9' => c as uint - ('0' as uint),\n-      'a' ... 'z' => c as uint + 10u - ('a' as uint),\n-      'A' ... 'Z' => c as uint + 10u - ('A' as uint),\n-      _ => return None,\n-    };\n-    if val < radix { Some(val) }\n-    else { None }\n+    c.to_digit(radix)\n }\n \n ///\n@@ -145,6 +136,7 @@ pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n /// Panics if given an `radix` > 36.\n ///\n #[inline]\n+#[unstable = \"pending decisions about costructors for primitives\"]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is to high (maximum 36)\");\n@@ -171,23 +163,10 @@ pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n /// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n /// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n ///\n+#[deprecated = \"use the Char::escape_unicode method\"]\n pub fn escape_unicode(c: char, f: |char|) {\n-    // avoid calling str::to_str_radix because we don't really need to allocate\n-    // here.\n-    f('\\\\');\n-    let pad = match () {\n-        _ if c <= '\\x7f'    => { f('x'); 2 }\n-        _ if c <= '\\uffff'  => { f('u'); 4 }\n-        _                   => { f('U'); 8 }\n-    };\n-    for offset in range_step::<i32>(4 * (pad - 1), -1, -4) {\n-        let offset = offset as uint;\n-        unsafe {\n-            match ((c as i32) >> offset) & 0xf {\n-                i @ 0 ... 9 => { f(transmute('0' as i32 + i)); }\n-                i => { f(transmute('a' as i32 + (i - 10))); }\n-            }\n-        }\n+    for char in c.escape_unicode() {\n+        f(char);\n     }\n }\n \n@@ -203,32 +182,22 @@ pub fn escape_unicode(c: char, f: |char|) {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex Unicode escapes; see `escape_unicode`.\n ///\n+#[deprecated = \"use the Char::escape_default method\"]\n pub fn escape_default(c: char, f: |char|) {\n-    match c {\n-        '\\t' => { f('\\\\'); f('t'); }\n-        '\\r' => { f('\\\\'); f('r'); }\n-        '\\n' => { f('\\\\'); f('n'); }\n-        '\\\\' => { f('\\\\'); f('\\\\'); }\n-        '\\'' => { f('\\\\'); f('\\''); }\n-        '\"'  => { f('\\\\'); f('\"'); }\n-        '\\x20' ... '\\x7e' => { f(c); }\n-        _ => c.escape_unicode(f),\n+    for c in c.escape_default() {\n+        f(c);\n     }\n }\n \n /// Returns the amount of bytes this `char` would need if encoded in UTF-8\n #[inline]\n+#[deprecated = \"use the Char::len_utf8 method\"]\n pub fn len_utf8_bytes(c: char) -> uint {\n-    let code = c as u32;\n-    match () {\n-        _ if code < MAX_ONE_B   => 1u,\n-        _ if code < MAX_TWO_B   => 2u,\n-        _ if code < MAX_THREE_B => 3u,\n-        _  => 4u,\n-    }\n+    c.len_utf8()\n }\n \n /// Basic `char` manipulations.\n+#[experimental = \"trait organization may change\"]\n pub trait Char {\n     /// Checks if a `char` parses as a numeric digit in the given radix.\n     ///\n@@ -243,7 +212,24 @@ pub trait Char {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    fn is_digit_radix(&self, radix: uint) -> bool;\n+    #[deprecated = \"use is_digit\"]\n+    fn is_digit_radix(self, radix: uint) -> bool;\n+\n+    /// Checks if a `char` parses as a numeric digit in the given radix.\n+    ///\n+    /// Compared to `is_digit()`, this function only recognizes the characters\n+    /// `0-9`, `a-z` and `A-Z`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n+    /// otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix > 36.\n+    #[unstable = \"pending error conventions\"]\n+    fn is_digit(self, radix: uint) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -256,7 +242,8 @@ pub trait Char {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    fn to_digit(&self, radix: uint) -> Option<uint>;\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn to_digit(self, radix: uint) -> Option<uint>;\n \n     /// Converts a number to the character representing it.\n     ///\n@@ -268,19 +255,26 @@ pub trait Char {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n+    #[deprecated = \"use the char::from_digit free function\"]\n     fn from_digit(num: uint, radix: uint) -> Option<Self>;\n \n-    /// Returns the hexadecimal Unicode escape of a character.\n+    /// Converts from `u32` to a `char`\n+    #[deprecated = \"use the char::from_u32 free function\"]\n+    fn from_u32(i: u32) -> Option<char>;\n+\n+    /// Returns an iterator that yields the hexadecimal Unicode escape\n+    /// of a character, as `char`s.\n     ///\n     /// The rules are as follows:\n     ///\n     /// * Characters in [0,0xff] get 2-digit escapes: `\\\\xNN`\n     /// * Characters in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`.\n     /// * Characters above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`.\n-    fn escape_unicode(&self, f: |char|);\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn escape_unicode(self) -> UnicodeEscapedChars;\n \n-    /// Returns a 'default' ASCII and C++11-like literal escape of a\n-    /// character.\n+    /// Returns an iterator that yields the 'default' ASCII and\n+    /// C++11-like literal escape of a character, as `char`s.\n     ///\n     /// The default is chosen with a bias toward producing literals that are\n     /// legal in a variety of languages, including C++11 and similar C-family\n@@ -291,42 +285,121 @@ pub trait Char {\n     ///   escaped.\n     /// * Any other chars in the range [0x20,0x7e] are not escaped.\n     /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n-    fn escape_default(&self, f: |char|);\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn escape_default(self) -> DefaultEscapedChars;\n+\n+    /// Returns the amount of bytes this character would need if encoded in\n+    /// UTF-8.\n+    #[deprecated = \"use len_utf8\"]\n+    fn len_utf8_bytes(self) -> uint;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n-    fn len_utf8_bytes(&self) -> uint;\n+    #[unstable = \"pending trait organization\"]\n+    fn len_utf8(self) -> uint;\n+\n+    /// Returns the amount of bytes this character would need if encoded in\n+    /// UTF-16.\n+    #[unstable = \"pending trait organization\"]\n+    fn len_utf16(self) -> uint;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n+    #[unstable = \"pending trait organization\"]\n     fn encode_utf8(&self, dst: &mut [u8]) -> Option<uint>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n+    #[unstable = \"pending trait organization\"]\n     fn encode_utf16(&self, dst: &mut [u16]) -> Option<uint>;\n }\n \n+#[experimental = \"trait is experimental\"]\n impl Char for char {\n-    fn is_digit_radix(&self, radix: uint) -> bool { is_digit_radix(*self, radix) }\n+    #[deprecated = \"use is_digit\"]\n+    fn is_digit_radix(self, radix: uint) -> bool { self.is_digit(radix) }\n+\n+    #[unstable = \"pending trait organization\"]\n+    fn is_digit(self, radix: uint) -> bool {\n+        match self.to_digit(radix) {\n+            Some(_) => true,\n+            None    => false,\n+        }\n+    }\n \n-    fn to_digit(&self, radix: uint) -> Option<uint> { to_digit(*self, radix) }\n+    #[unstable = \"pending trait organization\"]\n+    fn to_digit(self, radix: uint) -> Option<uint> {\n+        if radix > 36 {\n+            panic!(\"to_digit: radix is too high (maximum 36)\");\n+        }\n+        let val = match self {\n+          '0' ... '9' => self as uint - ('0' as uint),\n+          'a' ... 'z' => self as uint + 10u - ('a' as uint),\n+          'A' ... 'Z' => self as uint + 10u - ('A' as uint),\n+          _ => return None,\n+        };\n+        if val < radix { Some(val) }\n+        else { None }\n+    }\n \n+    #[deprecated = \"use the char::from_digit free function\"]\n     fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n \n-    fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }\n+    #[inline]\n+    #[deprecated = \"use the char::from_u32 free function\"]\n+    fn from_u32(i: u32) -> Option<char> { from_u32(i) }\n+\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn escape_unicode(self) -> UnicodeEscapedChars {\n+        UnicodeEscapedChars { c: self, state: UnicodeEscapedCharsState::Backslash }\n+    }\n+\n+    #[unstable = \"pending error conventions, trait organization\"]\n+    fn escape_default(self) -> DefaultEscapedChars {\n+        let init_state = match self {\n+            '\\t' => DefaultEscapedCharsState::Backslash('t'),\n+            '\\r' => DefaultEscapedCharsState::Backslash('r'),\n+            '\\n' => DefaultEscapedCharsState::Backslash('n'),\n+            '\\\\' => DefaultEscapedCharsState::Backslash('\\\\'),\n+            '\\'' => DefaultEscapedCharsState::Backslash('\\''),\n+            '\"'  => DefaultEscapedCharsState::Backslash('\"'),\n+            '\\x20' ... '\\x7e' => DefaultEscapedCharsState::Char(self),\n+            _ => DefaultEscapedCharsState::Unicode(self.escape_unicode())\n+        };\n+        DefaultEscapedChars { state: init_state }\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"use len_utf8\"]\n+    fn len_utf8_bytes(self) -> uint { self.len_utf8() }\n \n-    fn escape_default(&self, f: |char|) { escape_default(*self, f) }\n+    #[inline]\n+    #[unstable = \"pending trait organization\"]\n+    fn len_utf8(self) -> uint {\n+        let code = self as u32;\n+        match () {\n+            _ if code < MAX_ONE_B   => 1u,\n+            _ if code < MAX_TWO_B   => 2u,\n+            _ if code < MAX_THREE_B => 3u,\n+            _  => 4u,\n+        }\n+    }\n \n     #[inline]\n-    fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n+    #[unstable = \"pending trait organization\"]\n+    fn len_utf16(self) -> uint {\n+        let ch = self as u32;\n+        if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n+    }\n \n     #[inline]\n+    #[unstable = \"pending error conventions, trait organization\"]\n     fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> Option<uint> {\n         // Marked #[inline] to allow llvm optimizing it away\n         let code = *self as u32;\n@@ -354,6 +427,7 @@ impl Char for char {\n     }\n \n     #[inline]\n+    #[unstable = \"pending error conventions, trait organization\"]\n     fn encode_utf16(&self, dst: &mut [u16]) -> Option<uint> {\n         // Marked #[inline] to allow llvm optimizing it away\n         let mut ch = *self as u32;\n@@ -372,3 +446,75 @@ impl Char for char {\n         }\n     }\n }\n+\n+/// An iterator over the characters that represent a `char`, as escaped by\n+/// Rust's unicode escaping rules.\n+pub struct UnicodeEscapedChars {\n+    c: char,\n+    state: UnicodeEscapedCharsState\n+}\n+\n+enum UnicodeEscapedCharsState {\n+    Backslash,\n+    Type,\n+    Value(RangeStep<i32>),\n+}\n+\n+impl Iterator<char> for UnicodeEscapedChars {\n+    fn next(&mut self) -> Option<char> {\n+        match self.state {\n+            UnicodeEscapedCharsState::Backslash => {\n+                self.state = UnicodeEscapedCharsState::Type;\n+                Some('\\\\')\n+            }\n+            UnicodeEscapedCharsState::Type => {\n+                let (typechar, pad) = if self.c <= '\\x7f' { ('x', 2) }\n+                                      else if self.c <= '\\uffff' { ('u', 4) }\n+                                      else { ('U', 8) };\n+                self.state = UnicodeEscapedCharsState::Value(range_step(4 * (pad - 1), -1, -4i32));\n+                Some(typechar)\n+            }\n+            UnicodeEscapedCharsState::Value(ref mut range_step) => match range_step.next() {\n+                Some(offset) => {\n+                    let offset = offset as uint;\n+                    let v = match ((self.c as i32) >> offset) & 0xf {\n+                        i @ 0 ... 9 => '0' as i32 + i,\n+                        i => 'a' as i32 + (i - 10)\n+                    };\n+                    Some(unsafe { transmute(v) })\n+                }\n+                None => None\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over the characters that represent a `char`, escaped\n+/// for maximum portability.\n+pub struct DefaultEscapedChars {\n+    state: DefaultEscapedCharsState\n+}\n+\n+enum DefaultEscapedCharsState {\n+    Backslash(char),\n+    Char(char),\n+    Done,\n+    Unicode(UnicodeEscapedChars),\n+}\n+\n+impl Iterator<char> for DefaultEscapedChars {\n+    fn next(&mut self) -> Option<char> {\n+        match self.state {\n+            DefaultEscapedCharsState::Backslash(c) => {\n+                self.state = DefaultEscapedCharsState::Char(c);\n+                Some('\\\\')\n+            }\n+            DefaultEscapedCharsState::Char(c) => {\n+                self.state = DefaultEscapedCharsState::Done;\n+                Some(c)\n+            }\n+            DefaultEscapedCharsState::Done => None,\n+            DefaultEscapedCharsState::Unicode(ref mut iter) => iter.next()\n+        }\n+    }\n+}"}, {"sha": "1760c4d8e6616953953754f0f9572cce830ba2af", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -15,6 +15,7 @@ pub use self::SignificantDigits::*;\n pub use self::SignFormat::*;\n \n use char;\n+use char::Char;\n use fmt;\n use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n@@ -222,7 +223,7 @@ pub fn float_to_str_bytes_common<T: Float, U>(\n         // round the remaining ones.\n         if limit_digits && dig == digit_count {\n             let ascii2value = |chr: u8| {\n-                char::to_digit(chr as char, radix).unwrap()\n+                (chr as char).to_digit(radix).unwrap()\n             };\n             let value2ascii = |val: uint| {\n                 char::from_digit(val, radix).unwrap() as u8"}, {"sha": "8d26a970eb8baa9edd129923f1efa3d805ccb71b", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -1315,7 +1315,7 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n@@ -1336,7 +1336,7 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_digit()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n@@ -1368,7 +1368,7 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).rev().collect();\n     /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n@@ -1386,7 +1386,7 @@ pub trait StrPrelude for Sized? {\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_digit()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n@@ -1596,7 +1596,7 @@ pub trait StrPrelude for Sized? {\n     /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_numeric()), \"foo1bar\")\n     /// ```\n     fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n@@ -1612,7 +1612,7 @@ pub trait StrPrelude for Sized? {\n     /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_numeric()), \"foo1bar123\")\n     /// ```\n     fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n \n@@ -1628,7 +1628,7 @@ pub trait StrPrelude for Sized? {\n     /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_numeric()), \"123foo1bar\")\n     /// ```\n     fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n "}, {"sha": "507ddf65e55b35c9dca1b4a6d72053bc68620346", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -105,12 +105,12 @@ fn test_is_control() {\n \n #[test]\n fn test_is_digit() {\n-   assert!('2'.is_digit());\n-   assert!('7'.is_digit());\n-   assert!(!'c'.is_digit());\n-   assert!(!'i'.is_digit());\n-   assert!(!'z'.is_digit());\n-   assert!(!'Q'.is_digit());\n+   assert!('2'.is_numeric());\n+   assert!('7'.is_numeric());\n+   assert!(!'c'.is_numeric());\n+   assert!(!'i'.is_numeric());\n+   assert!(!'z'.is_numeric());\n+   assert!(!'Q'.is_numeric());\n }\n \n #[test]\n@@ -197,6 +197,14 @@ fn test_encode_utf16() {\n     check('\\U0001f4a9', &[0xd83d, 0xdca9]);\n }\n \n+#[test]\n+fn test_len_utf16() {\n+    assert!('x'.len_utf16() == 1);\n+    assert!('\\u00e9'.len_utf16() == 1);\n+    assert!('\\ua66e'.len_utf16() == 1);\n+    assert!('\\U0001f4a9'.len_utf16() == 2);\n+}\n+\n #[test]\n fn test_width() {\n     assert_eq!('\\x00'.width(false),Some(0));"}, {"sha": "d3bee557220bf77d60c2f6d60dd76be5a39295b9", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -26,7 +26,6 @@ pub use self::Alignment::*;\n pub use self::Flag::*;\n pub use self::Count::*;\n \n-use std::char;\n use std::str;\n use std::string;\n \n@@ -221,7 +220,7 @@ impl<'a> Parser<'a> {\n     fn ws(&mut self) {\n         loop {\n             match self.cur.clone().next() {\n-                Some((_, c)) if char::is_whitespace(c) => { self.cur.next(); }\n+                Some((_, c)) if c.is_whitespace() => { self.cur.next(); }\n                 Some(..) | None => { return }\n             }\n         }\n@@ -261,7 +260,7 @@ impl<'a> Parser<'a> {\n             Some(i) => { ArgumentIs(i) }\n             None => {\n                 match self.cur.clone().next() {\n-                    Some((_, c)) if char::is_alphabetic(c) => {\n+                    Some((_, c)) if c.is_alphabetic() => {\n                         ArgumentNamed(self.word())\n                     }\n                     _ => ArgumentNext\n@@ -384,7 +383,7 @@ impl<'a> Parser<'a> {\n     /// characters.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.clone().next() {\n-            Some((pos, c)) if char::is_XID_start(c) => {\n+            Some((pos, c)) if c.is_xid_start() => {\n                 self.cur.next();\n                 pos\n             }\n@@ -393,7 +392,7 @@ impl<'a> Parser<'a> {\n         let mut end;\n         loop {\n             match self.cur.clone().next() {\n-                Some((_, c)) if char::is_XID_continue(c) => {\n+                Some((_, c)) if c.is_xid_continue() => {\n                     self.cur.next();\n                 }\n                 Some((pos, _)) => { end = pos; break }\n@@ -411,7 +410,7 @@ impl<'a> Parser<'a> {\n         loop {\n             match self.cur.clone().next() {\n                 Some((_, c)) => {\n-                    match char::to_digit(c, 10) {\n+                    match c.to_digit(10) {\n                         Some(i) => {\n                             cur = cur * 10 + i;\n                             found = true;"}, {"sha": "a182f582b5f34bcd54d0aec013f5933f114e736d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -886,7 +886,7 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n     }\n \n     let machine: |&mut bool, (uint, char)| -> bool = |cont, (i, c)| {\n-        let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n+        let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n \n         state = match (state, whitespace, limit) {"}, {"sha": "3ad546edf8de2d7b0225504cd6a73e501b5d67aa", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -431,7 +431,7 @@ impl<'a> LabelText<'a> {\n             // not escaping \\\\, since Graphviz escString needs to\n             // interpret backslashes; see EscStr above.\n             '\\\\' => f(c),\n-            _ => c.escape_default(f)\n+            _ => for c in c.escape_default() { f(c) }\n         }\n     }\n     fn escape_str(s: &str) -> String {"}, {"sha": "f272bb52a1436807cb0e24c231899fa18e12c57d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -29,7 +29,7 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n-#![feature(slicing_syntax, struct_variant, tuple_indexing, unsafe_destructor)]\n+#![feature(slicing_syntax, tuple_indexing, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n \n extern crate arena;"}, {"sha": "00c68f42c3249d4ba8168f3c0468906c6eeecb2b", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -920,7 +920,7 @@ impl NonSnakeCase {\n             let mut allow_underscore = true;\n             ident.chars().all(|c| {\n                 allow_underscore = match c {\n-                    c if c.is_lowercase() || c.is_digit() => true,\n+                    c if c.is_lowercase() || c.is_numeric() => true,\n                     '_' if allow_underscore => false,\n                     _ => return false,\n                 };"}, {"sha": "68a80edc5d07f14aa24788df7b385aec7f65150b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -250,7 +250,7 @@ impl Target {\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name[]).map(|o| o.as_list()\n+                obj.find(name[]).map(|o| o.as_array()\n                     .map(|v| base.options.$key_name = v.iter()\n                         .map(|a| a.as_string().unwrap().to_string()).collect()\n                         )"}, {"sha": "3715256e3ec2be857107118321f4be110a725a99", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -27,7 +27,6 @@ use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n \n-use std::char;\n use std::io::fs::PathExtensions;\n use std::io::{fs, TempDir, Command};\n use std::io;\n@@ -262,7 +261,7 @@ pub fn sanitize(s: &str) -> String {\n \n             _ => {\n                 let mut tstr = String::new();\n-                char::escape_unicode(c, |c| tstr.push(c));\n+                for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n                 result.push_str(tstr.as_slice().slice_from(1));\n             }\n@@ -272,7 +271,7 @@ pub fn sanitize(s: &str) -> String {\n     // Underscore-qualify anything that didn't start as an ident.\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n-        ! char::is_XID_start(result.as_bytes()[0] as char) {\n+        ! (result.as_bytes()[0] as char).is_xid_start() {\n         return format!(\"_{}\", result.as_slice());\n     }\n "}, {"sha": "f89580b768ea5c62c3615a7099c9a3187471b8c9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -29,7 +29,7 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n-#![feature(slicing_syntax, struct_variant, unsafe_destructor)]\n+#![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n \n extern crate arena;"}, {"sha": "52aab752c57612087510094eff830c8550516e09", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -2033,9 +2033,9 @@ fn lit_to_string(lit: &ast::Lit) -> String {\n         ast::LitBinary(ref data) => format!(\"{}\", data),\n         ast::LitByte(b) => {\n             let mut res = String::from_str(\"b'\");\n-            (b as char).escape_default(|c| {\n+            for c in (b as char).escape_default() {\n                 res.push(c);\n-            });\n+            }\n             res.push('\\'');\n             res\n         },"}, {"sha": "97a18e9708fe2508d5ac9f547e1848ab43e5d6ab", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -101,6 +101,8 @@ pub struct Context {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n+    /// All the passes that were run on this crate.\n+    pub passes: HashSet<String>,\n }\n \n /// Indicates where an external crate can be found.\n@@ -190,6 +192,7 @@ pub struct Cache {\n     parent_stack: Vec<ast::DefId>,\n     search_index: Vec<IndexItem>,\n     privmod: bool,\n+    remove_priv: bool,\n     public_items: NodeSet,\n \n     // In rare case where a structure is defined in one module but implemented\n@@ -236,9 +239,13 @@ local_data_key!(pub cache_key: Arc<Cache>)\n local_data_key!(pub current_location_key: Vec<String> )\n \n /// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) -> io::IoResult<()> {\n+pub fn run(mut krate: clean::Crate,\n+           external_html: &ExternalHtml,\n+           dst: Path,\n+           passes: HashSet<String>) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n+        passes: passes,\n         current: Vec::new(),\n         root_path: String::new(),\n         sidebar: HashMap::new(),\n@@ -320,6 +327,7 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n         search_index: Vec::new(),\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n+        remove_priv: cx.passes.contains(\"strip-private\"),\n         privmod: false,\n         public_items: public_items,\n         orphan_methods: Vec::new(),\n@@ -767,7 +775,7 @@ impl DocFolder for Cache {\n         let orig_privmod = match item.inner {\n             clean::ModuleItem(..) => {\n                 let prev = self.privmod;\n-                self.privmod = prev || item.visibility != Some(ast::Public);\n+                self.privmod = prev || (self.remove_priv && item.visibility != Some(ast::Public));\n                 prev\n             }\n             _ => self.privmod,\n@@ -1192,7 +1200,7 @@ impl Context {\n         // these modules are recursed into, but not rendered normally (a\n         // flag on the context).\n         if !self.render_redirect_pages {\n-            self.render_redirect_pages = ignore_private_item(&item);\n+            self.render_redirect_pages = self.ignore_private_item(&item);\n         }\n \n         match item.inner {\n@@ -1211,7 +1219,7 @@ impl Context {\n                         clean::ModuleItem(m) => m,\n                         _ => unreachable!()\n                     };\n-                    this.sidebar = build_sidebar(&m);\n+                    this.sidebar = this.build_sidebar(&m);\n                     for item in m.items.into_iter() {\n                         f(this,item);\n                     }\n@@ -1230,6 +1238,40 @@ impl Context {\n             _ => Ok(())\n         }\n     }\n+\n+    fn build_sidebar(&self, m: &clean::Module) -> HashMap<String, Vec<String>> {\n+        let mut map = HashMap::new();\n+        for item in m.items.iter() {\n+            if self.ignore_private_item(item) { continue }\n+\n+            let short = shortty(item).to_static_str();\n+            let myname = match item.name {\n+                None => continue,\n+                Some(ref s) => s.to_string(),\n+            };\n+            let v = match map.entry(short.to_string()) {\n+                Vacant(entry) => entry.set(Vec::with_capacity(1)),\n+                Occupied(entry) => entry.into_mut(),\n+            };\n+            v.push(myname);\n+        }\n+\n+        for (_, items) in map.iter_mut() {\n+            items.as_mut_slice().sort();\n+        }\n+        return map;\n+    }\n+\n+    fn ignore_private_item(&self, it: &clean::Item) -> bool {\n+        match it.inner {\n+            clean::ModuleItem(ref m) => {\n+                (m.items.len() == 0 && it.doc_value().is_none()) ||\n+                (self.passes.contains(\"strip-private\") && it.visibility != Some(ast::Public))\n+            }\n+            clean::PrimitiveItem(..) => it.visibility != Some(ast::Public),\n+            _ => false,\n+        }\n+    }\n }\n \n impl<'a> Item<'a> {\n@@ -1443,7 +1485,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     try!(document(w, item));\n \n     let mut indices = range(0, items.len()).filter(|i| {\n-        !ignore_private_item(&items[*i])\n+        !cx.ignore_private_item(&items[*i])\n     }).collect::<Vec<uint>>();\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n@@ -2157,29 +2199,6 @@ impl<'a> fmt::Show for Sidebar<'a> {\n     }\n }\n \n-fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n-    let mut map = HashMap::new();\n-    for item in m.items.iter() {\n-        if ignore_private_item(item) { continue }\n-\n-        let short = shortty(item).to_static_str();\n-        let myname = match item.name {\n-            None => continue,\n-            Some(ref s) => s.to_string(),\n-        };\n-        let v = match map.entry(short.to_string()) {\n-            Vacant(entry) => entry.set(Vec::with_capacity(1)),\n-            Occupied(entry) => entry.into_mut(),\n-        };\n-        v.push(myname);\n-    }\n-\n-    for (_, items) in map.iter_mut() {\n-        items.as_mut_slice().sort();\n-    }\n-    return map;\n-}\n-\n impl<'a> fmt::Show for Source<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *self;\n@@ -2214,17 +2233,6 @@ fn item_primitive(w: &mut fmt::Formatter,\n     render_methods(w, it)\n }\n \n-fn ignore_private_item(it: &clean::Item) -> bool {\n-    match it.inner {\n-        clean::ModuleItem(ref m) => {\n-            (m.items.len() == 0 && it.doc_value().is_none()) ||\n-               it.visibility != Some(ast::Public)\n-        }\n-        clean::PrimitiveItem(..) => it.visibility != Some(ast::Public),\n-        _ => false,\n-    }\n-}\n-\n fn get_basic_keywords() -> &'static str {\n     \"rust, rustlang, rust-lang\"\n }"}, {"sha": "8770e473dea69a2317cd53f86fb284edea506158", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -16,7 +16,7 @@\n #![crate_type = \"rlib\"]\n \n #![allow(unknown_features)]\n-#![feature(globs, struct_variant, macro_rules, phase, slicing_syntax, tuple_indexing)]\n+#![feature(globs, macro_rules, phase, slicing_syntax, tuple_indexing)]\n \n extern crate arena;\n extern crate getopts;\n@@ -86,7 +86,11 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n \n local_data_key!(pub analysiskey: core::CrateAnalysis)\n \n-type Output = (clean::Crate, Vec<plugins::PluginJson> );\n+struct Output {\n+    krate: clean::Crate,\n+    json_plugins: Vec<plugins::PluginJson>,\n+    passes: Vec<String>,\n+}\n \n pub fn main() {\n     std::os::set_exit_status(main_args(std::os::args().as_slice()));\n@@ -229,24 +233,26 @@ pub fn main_args(args: &[String]) -> int {\n         (false, false) => {}\n     }\n \n-    let (krate, res) = match acquire_input(input, externs, &matches) {\n-        Ok(pair) => pair,\n+    let out = match acquire_input(input, externs, &matches) {\n+        Ok(out) => out,\n         Err(s) => {\n             println!(\"input error: {}\", s);\n             return 1;\n         }\n     };\n-\n+    let Output { krate, json_plugins, passes, } = out;\n     info!(\"going to format\");\n     match matches.opt_str(\"w\").as_ref().map(|s| s.as_slice()) {\n         Some(\"html\") | None => {\n-            match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\"))) {\n+            match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\")),\n+                                    passes.into_iter().collect()) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to generate documentation: {}\", e),\n             }\n         }\n         Some(\"json\") => {\n-            match json_output(krate, res, output.unwrap_or(Path::new(\"doc.json\"))) {\n+            match json_output(krate, json_plugins,\n+                              output.unwrap_or(Path::new(\"doc.json\"))) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to write json: {}\", e),\n             }\n@@ -397,7 +403,8 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // Run everything!\n     info!(\"Executing passes/plugins\");\n-    return pm.run_plugins(krate);\n+    let (krate, json) = pm.run_plugins(krate);\n+    return Output { krate: krate, json_plugins: json, passes: passes, };\n }\n \n /// This input format purely deserializes the json output file. No passes are\n@@ -435,7 +442,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n             // FIXME: this should read from the \"plugins\" field, but currently\n             //      Json doesn't implement decodable...\n             let plugin_output = Vec::new();\n-            Ok((krate, plugin_output))\n+            Ok(Output { krate: krate, json_plugins: plugin_output, passes: Vec::new(), })\n         }\n         Ok(..) => {\n             Err(\"malformed json input: expected an object at the \\"}, {"sha": "2a5972bb3d90b11d0fc6711ccda4d409f9805b85", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n-use std::char;\n use std::dynamic_lib::DynamicLibrary;\n use std::io::{Command, TempDir};\n use std::io;\n@@ -300,8 +299,8 @@ impl Collector {\n             // we use these headings as test names, so it's good if\n             // they're valid identifiers.\n             let name = name.chars().enumerate().map(|(i, c)| {\n-                    if (i == 0 && char::is_XID_start(c)) ||\n-                        (i != 0 && char::is_XID_continue(c)) {\n+                    if (i == 0 && c.is_xid_start()) ||\n+                        (i != 0 && c.is_xid_continue()) {\n                         c\n                     } else {\n                         '_'"}, {"sha": "d59edafb2b42cfe0674df9301468d58f68f4cdc6", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 127, "deletions": 127, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -28,7 +28,7 @@ Data types that can be encoded are JavaScript types (see the `Json` enum for mor\n * `Boolean`: equivalent to rust's `bool`\n * `Number`: equivalent to rust's `f64`\n * `String`: equivalent to rust's `String`\n-* `List`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n+* `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n array\n * `Object`: equivalent to rust's `Treemap<String, json::Json>`\n * `Null`\n@@ -223,12 +223,12 @@ pub enum Json {\n     F64(f64),\n     String(string::String),\n     Boolean(bool),\n-    List(JsonList),\n+    Array(JsonArray),\n     Object(JsonObject),\n     Null,\n }\n \n-pub type JsonList = Vec<Json>;\n+pub type JsonArray = Vec<Json>;\n pub type JsonObject = TreeMap<string::String, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n@@ -237,7 +237,7 @@ pub enum ErrorCode {\n     InvalidSyntax,\n     InvalidNumber,\n     EOFWhileParsingObject,\n-    EOFWhileParsingList,\n+    EOFWhileParsingArray,\n     EOFWhileParsingValue,\n     EOFWhileParsingString,\n     KeyMustBeAString,\n@@ -278,7 +278,7 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n         InvalidSyntax => \"invalid syntax\",\n         InvalidNumber => \"invalid number\",\n         EOFWhileParsingObject => \"EOF While parsing object\",\n-        EOFWhileParsingList => \"EOF While parsing list\",\n+        EOFWhileParsingArray => \"EOF While parsing array\",\n         EOFWhileParsingValue => \"EOF While parsing value\",\n         EOFWhileParsingString => \"EOF While parsing string\",\n         KeyMustBeAString => \"key must be a string\",\n@@ -868,7 +868,7 @@ impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n             F64(v) => v.encode(e),\n             String(ref v) => v.encode(e),\n             Boolean(v) => v.encode(e),\n-            List(ref v) => v.encode(e),\n+            Array(ref v) => v.encode(e),\n             Object(ref v) => v.encode(e),\n             Null => e.emit_nil(),\n         }\n@@ -956,16 +956,16 @@ impl Json {\n         }\n     }\n \n-    /// Returns true if the Json value is a List. Returns false otherwise.\n-    pub fn is_list<'a>(&'a self) -> bool {\n-        self.as_list().is_some()\n+    /// Returns true if the Json value is an Array. Returns false otherwise.\n+    pub fn is_array<'a>(&'a self) -> bool {\n+        self.as_array().is_some()\n     }\n \n-    /// If the Json value is a List, returns the associated vector.\n+    /// If the Json value is an Array, returns the associated vector.\n     /// Returns None otherwise.\n-    pub fn as_list<'a>(&'a self) -> Option<&'a JsonList> {\n+    pub fn as_array<'a>(&'a self) -> Option<&'a JsonArray> {\n         match self {\n-            &List(ref list) => Some(&*list),\n+            &Array(ref array) => Some(&*array),\n             _ => None\n         }\n     }\n@@ -1085,8 +1085,8 @@ impl<'a> ops::Index<&'a str, Json>  for Json {\n impl ops::Index<uint, Json> for Json {\n     fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n         match self {\n-            &List(ref v) => v.index(idx),\n-            _ => panic!(\"can only index Json with uint if it is a list\")\n+            &Array(ref v) => v.index(idx),\n+            _ => panic!(\"can only index Json with uint if it is an array\")\n         }\n     }\n }\n@@ -1096,8 +1096,8 @@ impl ops::Index<uint, Json> for Json {\n pub enum JsonEvent {\n     ObjectStart,\n     ObjectEnd,\n-    ListStart,\n-    ListEnd,\n+    ArrayStart,\n+    ArrayEnd,\n     BooleanValue(bool),\n     I64Value(i64),\n     U64Value(u64),\n@@ -1109,10 +1109,10 @@ pub enum JsonEvent {\n \n #[deriving(PartialEq, Show)]\n enum ParserState {\n-    // Parse a value in a list, true means first element.\n+    // Parse a value in an array, true means first element.\n     ParseArray(bool),\n-    // Parse ',' or ']' after an element in a list.\n-    ParseListComma,\n+    // Parse ',' or ']' after an element in an array.\n+    ParseArrayComma,\n     // Parse a key:value in an object, true means first element.\n     ParseObject(bool),\n     // Parse ',' or ']' after an element in an object.\n@@ -1601,7 +1601,7 @@ impl<T: Iterator<char>> Parser<T> {\n     fn parse(&mut self) -> JsonEvent {\n         loop {\n             // The only paths where the loop can spin a new iteration\n-            // are in the cases ParseListComma and ParseObjectComma if ','\n+            // are in the cases ParseArrayComma and ParseObjectComma if ','\n             // is parsed. In these cases the state is set to (respectively)\n             // ParseArray(false) and ParseObject(false), which always return,\n             // so there is no risk of getting stuck in an infinite loop.\n@@ -1613,10 +1613,10 @@ impl<T: Iterator<char>> Parser<T> {\n                     return self.parse_start();\n                 }\n                 ParseArray(first) => {\n-                    return self.parse_list(first);\n+                    return self.parse_array(first);\n                 }\n-                ParseListComma => {\n-                    match self.parse_list_comma_or_end() {\n+                ParseArrayComma => {\n+                    match self.parse_array_comma_or_end() {\n                         Some(evt) => { return evt; }\n                         None => {}\n                     }\n@@ -1644,14 +1644,14 @@ impl<T: Iterator<char>> Parser<T> {\n         let val = self.parse_value();\n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseArray(true) }\n+            ArrayStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseBeforeFinish }\n         };\n         return val;\n     }\n \n-    fn parse_list(&mut self, first: bool) -> JsonEvent {\n+    fn parse_array(&mut self, first: bool) -> JsonEvent {\n         if self.ch_is(']') {\n             if !first {\n                 return self.error_event(InvalidSyntax);\n@@ -1660,13 +1660,13 @@ impl<T: Iterator<char>> Parser<T> {\n                 self.state = ParseBeforeFinish;\n             } else {\n                 self.state = if self.stack.last_is_index() {\n-                    ParseListComma\n+                    ParseArrayComma\n                 } else {\n                     ParseObjectComma\n                 }\n             }\n             self.bump();\n-            return ListEnd;\n+            return ArrayEnd;\n         }\n         if first {\n             self.stack.push_index(0);\n@@ -1676,14 +1676,14 @@ impl<T: Iterator<char>> Parser<T> {\n \n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseArray(true) }\n+            ArrayStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n-            _ => { ParseListComma }\n+            _ => { ParseArrayComma }\n         };\n         return val;\n     }\n \n-    fn parse_list_comma_or_end(&mut self) -> Option<JsonEvent> {\n+    fn parse_array_comma_or_end(&mut self) -> Option<JsonEvent> {\n         if self.ch_is(',') {\n             self.stack.bump_index();\n             self.state = ParseArray(false);\n@@ -1695,15 +1695,15 @@ impl<T: Iterator<char>> Parser<T> {\n                 self.state = ParseBeforeFinish;\n             } else {\n                 self.state = if self.stack.last_is_index() {\n-                    ParseListComma\n+                    ParseArrayComma\n                 } else {\n                     ParseObjectComma\n                 }\n             }\n             self.bump();\n-            return Some(ListEnd);\n+            return Some(ArrayEnd);\n         } else if self.eof() {\n-            return Some(self.error_event(EOFWhileParsingList));\n+            return Some(self.error_event(EOFWhileParsingArray));\n         } else {\n             return Some(self.error_event(InvalidSyntax));\n         }\n@@ -1722,7 +1722,7 @@ impl<T: Iterator<char>> Parser<T> {\n                 self.state = ParseBeforeFinish;\n             } else {\n                 self.state = if self.stack.last_is_index() {\n-                    ParseListComma\n+                    ParseArrayComma\n                 } else {\n                     ParseObjectComma\n                 }\n@@ -1757,7 +1757,7 @@ impl<T: Iterator<char>> Parser<T> {\n \n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseArray(true) }\n+            ArrayStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseObjectComma }\n         };\n@@ -1770,7 +1770,7 @@ impl<T: Iterator<char>> Parser<T> {\n                 self.state = ParseBeforeFinish;\n             } else {\n                 self.state = if self.stack.last_is_index() {\n-                    ParseListComma\n+                    ParseArrayComma\n                 } else {\n                     ParseObjectComma\n                 }\n@@ -1797,7 +1797,7 @@ impl<T: Iterator<char>> Parser<T> {\n             },\n             '[' => {\n                 self.bump();\n-                ListStart\n+                ArrayStart\n             }\n             '{' => {\n                 self.bump();\n@@ -1864,21 +1864,21 @@ impl<T: Iterator<char>> Builder<T> {\n                 Ok(String(temp))\n             }\n             Some(Error(e)) => { Err(e) }\n-            Some(ListStart) => { self.build_list() }\n+            Some(ArrayStart) => { self.build_array() }\n             Some(ObjectStart) => { self.build_object() }\n             Some(ObjectEnd) => { self.parser.error(InvalidSyntax) }\n-            Some(ListEnd) => { self.parser.error(InvalidSyntax) }\n+            Some(ArrayEnd) => { self.parser.error(InvalidSyntax) }\n             None => { self.parser.error(EOFWhileParsingValue) }\n         }\n     }\n \n-    fn build_list(&mut self) -> Result<Json, BuilderError> {\n+    fn build_array(&mut self) -> Result<Json, BuilderError> {\n         self.bump();\n         let mut values = Vec::new();\n \n         loop {\n-            if self.token == Some(ListEnd) {\n-                return Ok(List(values.into_iter().collect()));\n+            if self.token == Some(ArrayEnd) {\n+                return Ok(Array(values.into_iter().collect()));\n             }\n             match self.build_value() {\n                 Ok(v) => values.push(v),\n@@ -2093,13 +2093,13 @@ impl ::Decoder<DecoderError> for Decoder {\n                     }\n                 };\n                 match o.remove(&\"fields\".to_string()) {\n-                    Some(List(l)) => {\n+                    Some(Array(l)) => {\n                         for field in l.into_iter().rev() {\n                             self.stack.push(field);\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"List\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"Array\".to_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n                         return Err(MissingFieldError(\"fields\".to_string()))\n@@ -2229,9 +2229,9 @@ impl ::Decoder<DecoderError> for Decoder {\n \n     fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_seq()\");\n-        let list = try!(expect!(self.pop(), List));\n-        let len = list.len();\n-        for v in list.into_iter().rev() {\n+        let array = try!(expect!(self.pop(), Array));\n+        let len = array.len();\n+        for v in array.into_iter().rev() {\n             self.stack.push(v);\n         }\n         f(self, len)\n@@ -2343,7 +2343,7 @@ macro_rules! tuple_impl {\n             #[allow(non_snake_case)]\n             fn to_json(&self) -> Json {\n                 match *self {\n-                    ($(ref $tyvar),*,) => List(vec![$($tyvar.to_json()),*])\n+                    ($(ref $tyvar),*,) => Array(vec![$($tyvar.to_json()),*])\n                 }\n             }\n         }\n@@ -2364,11 +2364,11 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n \n impl<A: ToJson> ToJson for [A] {\n-    fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n+    fn to_json(&self) -> Json { Array(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n impl<A: ToJson> ToJson for Vec<A> {\n-    fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n+    fn to_json(&self) -> Json { Array(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n impl<A: ToJson> ToJson for TreeMap<string::String, A> {\n@@ -2420,13 +2420,13 @@ mod tests {\n     use self::DecodeEnum::*;\n     use self::test::Bencher;\n     use {Encodable, Decodable};\n-    use super::{List, Encoder, Decoder, Error, Boolean, I64, U64, F64, String, Null,\n+    use super::{Array, Encoder, Decoder, Error, Boolean, I64, U64, F64, String, Null,\n                 PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n                 MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n                 JsonEvent, Parser, StackElement,\n-                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, U64Value,\n+                ObjectStart, ObjectEnd, ArrayStart, ArrayEnd, BooleanValue, U64Value,\n                 F64Value, StringValue, NullValue, SyntaxError, Key, Index, Stack,\n-                InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n+                InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingArray,\n                 EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n                 TrailingCharacters, TrailingComma};\n     use std::{i64, u64, f32, f64, io};\n@@ -2558,28 +2558,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_write_list() {\n-        assert_eq!(List(vec![]).to_string().into_string(), \"[]\".to_string());\n-        assert_eq!(List(vec![]).to_pretty_str().into_string(), \"[]\".to_string());\n+    fn test_write_array() {\n+        assert_eq!(Array(vec![]).to_string().into_string(), \"[]\".to_string());\n+        assert_eq!(Array(vec![]).to_pretty_str().into_string(), \"[]\".to_string());\n \n-        assert_eq!(List(vec![Boolean(true)]).to_string().into_string(), \"[true]\".to_string());\n+        assert_eq!(Array(vec![Boolean(true)]).to_string().into_string(), \"[true]\".to_string());\n         assert_eq!(\n-            List(vec![Boolean(true)]).to_pretty_str().into_string(),\n+            Array(vec![Boolean(true)]).to_pretty_str().into_string(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n             ]\".to_string()\n         );\n \n-        let long_test_list = List(vec![\n+        let long_test_array = Array(vec![\n             Boolean(false),\n             Null,\n-            List(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n+            Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n \n-        assert_eq!(long_test_list.to_string().into_string(),\n+        assert_eq!(long_test_array.to_string().into_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_string());\n         assert_eq!(\n-            long_test_list.to_pretty_str().into_string(),\n+            long_test_array.to_pretty_str().into_string(),\n             \"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -2612,7 +2612,7 @@ mod tests {\n         );\n \n         let complex_obj = mk_object(&[\n-                (\"b\".to_string(), List(vec![\n+                (\"b\".to_string(), Array(vec![\n                     mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n                     mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n                 ]))\n@@ -2644,7 +2644,7 @@ mod tests {\n \n         let a = mk_object(&[\n             (\"a\".to_string(), Boolean(true)),\n-            (\"b\".to_string(), List(vec![\n+            (\"b\".to_string(), Array(vec![\n                 mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n                 mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n             ]))\n@@ -2878,28 +2878,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_read_list() {\n+    fn test_read_array() {\n         assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingList,  1, 3)));\n+        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n         assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n         assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n         assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n \n-        assert_eq!(from_str(\"[]\"), Ok(List(vec![])));\n-        assert_eq!(from_str(\"[ ]\"), Ok(List(vec![])));\n-        assert_eq!(from_str(\"[true]\"), Ok(List(vec![Boolean(true)])));\n-        assert_eq!(from_str(\"[ false ]\"), Ok(List(vec![Boolean(false)])));\n-        assert_eq!(from_str(\"[null]\"), Ok(List(vec![Null])));\n+        assert_eq!(from_str(\"[]\"), Ok(Array(vec![])));\n+        assert_eq!(from_str(\"[ ]\"), Ok(Array(vec![])));\n+        assert_eq!(from_str(\"[true]\"), Ok(Array(vec![Boolean(true)])));\n+        assert_eq!(from_str(\"[ false ]\"), Ok(Array(vec![Boolean(false)])));\n+        assert_eq!(from_str(\"[null]\"), Ok(Array(vec![Null])));\n         assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(vec![U64(3), U64(1)])));\n+                     Ok(Array(vec![U64(3), U64(1)])));\n         assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(vec![U64(3), U64(2)])));\n+                     Ok(Array(vec![U64(3), U64(2)])));\n         assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(vec![U64(2), List(vec![U64(4), U64(1)])])));\n+               Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n     }\n \n     #[test]\n-    fn test_decode_list() {\n+    fn test_decode_array() {\n         let v: Vec<()> = super::decode(\"[]\").unwrap();\n         assert_eq!(v, vec![]);\n \n@@ -2967,7 +2967,7 @@ mod tests {\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object(&[\n                       (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), List(vec![Boolean(true)]))\n+                      (\"b\".to_string(), Array(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n                       \"{\\\n@@ -2980,7 +2980,7 @@ mod tests {\n                       }\").unwrap(),\n                   mk_object(&[\n                       (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), List(vec![\n+                      (\"b\".to_string(), Array(vec![\n                           Boolean(true),\n                           String(\"foo\\nbar\".to_string()),\n                           mk_object(&[\n@@ -3097,7 +3097,7 @@ mod tests {\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n                                   ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"List\".to_string(), \"null\".to_string()));\n+                                  ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n                                   MissingFieldError(\"w\".to_string()));\n     }\n@@ -3110,7 +3110,7 @@ mod tests {\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n                                 MissingFieldError(\"fields\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"List\".to_string(), \"null\".to_string()));\n+                                ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n                                 UnknownVariantError(\"C\".to_string()));\n     }\n@@ -3139,10 +3139,10 @@ mod tests {\n     #[test]\n     fn test_index(){\n         let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n-        let ref list = json_value[\"animals\"];\n-        assert_eq!(list[0].as_string().unwrap(), \"dog\");\n-        assert_eq!(list[1].as_string().unwrap(), \"cat\");\n-        assert_eq!(list[2].as_string().unwrap(), \"mouse\");\n+        let ref array = json_value[\"animals\"];\n+        assert_eq!(array[0].as_string().unwrap(), \"dog\");\n+        assert_eq!(array[1].as_string().unwrap(), \"cat\");\n+        assert_eq!(array[2].as_string().unwrap(), \"mouse\");\n     }\n \n     #[test]\n@@ -3159,17 +3159,17 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_is_list(){\n+    fn test_is_array(){\n         let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        assert!(json_value.is_list());\n+        assert!(json_value.is_array());\n     }\n \n     #[test]\n-    fn test_as_list(){\n+    fn test_as_array(){\n         let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        let json_list = json_value.as_list();\n+        let json_array = json_value.as_array();\n         let expected_length = 3;\n-        assert!(json_list.is_some() && json_list.unwrap().len() == expected_length);\n+        assert!(json_array.is_some() && json_array.unwrap().len() == expected_length);\n     }\n \n     #[test]\n@@ -3328,15 +3328,15 @@ mod tests {\n         tree.insert(\"hello\".into_string(), String(\"guten tag\".into_string()));\n         tree.insert(\"goodbye\".into_string(), String(\"sayonara\".into_string()));\n \n-        let json = List(\n+        let json = Array(\n             // The following layout below should look a lot like\n             // the pretty-printed JSON (indent * x)\n             vec!\n             ( // 0x\n                 String(\"greetings\".into_string()), // 1x\n                 Object(tree), // 1x + 2x + 2x + 1x\n             ) // 0x\n-            // End JSON list (7 lines)\n+            // End JSON array (7 lines)\n         );\n \n         // Helper function for counting indents\n@@ -3425,19 +3425,19 @@ mod tests {\n             vec![\n                 (ObjectStart,             vec![]),\n                   (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n-                  (ListStart,             vec![Key(\"array\")]),\n+                  (ArrayStart,            vec![Key(\"array\")]),\n                     (U64Value(0),         vec![Key(\"array\"), Index(0)]),\n                     (U64Value(1),         vec![Key(\"array\"), Index(1)]),\n                     (U64Value(2),         vec![Key(\"array\"), Index(2)]),\n                     (U64Value(3),         vec![Key(\"array\"), Index(3)]),\n                     (U64Value(4),         vec![Key(\"array\"), Index(4)]),\n                     (U64Value(5),         vec![Key(\"array\"), Index(5)]),\n-                  (ListEnd,               vec![Key(\"array\")]),\n-                  (ListStart,             vec![Key(\"idents\")]),\n+                  (ArrayEnd,              vec![Key(\"array\")]),\n+                  (ArrayStart,            vec![Key(\"idents\")]),\n                     (NullValue,           vec![Key(\"idents\"), Index(0)]),\n                     (BooleanValue(true),  vec![Key(\"idents\"), Index(1)]),\n                     (BooleanValue(false), vec![Key(\"idents\"), Index(2)]),\n-                  (ListEnd,               vec![Key(\"idents\")]),\n+                  (ArrayEnd,              vec![Key(\"idents\")]),\n                 (ObjectEnd,               vec![]),\n             ]\n         );\n@@ -3495,9 +3495,9 @@ mod tests {\n             vec![\n                 (ObjectStart,           vec![]),\n                   (F64Value(1.0),       vec![Key(\"a\")]),\n-                  (ListStart,           vec![Key(\"b\")]),\n+                  (ArrayStart,          vec![Key(\"b\")]),\n                     (BooleanValue(true),vec![Key(\"b\"), Index(0)]),\n-                  (ListEnd,             vec![Key(\"b\")]),\n+                  (ArrayEnd,            vec![Key(\"b\")]),\n                 (ObjectEnd,             vec![]),\n             ]\n         );\n@@ -3513,95 +3513,95 @@ mod tests {\n             vec![\n                 (ObjectStart,                   vec![]),\n                   (F64Value(1.0),               vec![Key(\"a\")]),\n-                  (ListStart,                   vec![Key(\"b\")]),\n+                  (ArrayStart,                  vec![Key(\"b\")]),\n                     (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n                     (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n                     (ObjectStart,               vec![Key(\"b\"), Index(2)]),\n                       (ObjectStart,             vec![Key(\"b\"), Index(2), Key(\"c\")]),\n                         (NullValue,             vec![Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n                       (ObjectEnd,               vec![Key(\"b\"), Index(2), Key(\"c\")]),\n                     (ObjectEnd,                 vec![Key(\"b\"), Index(2)]),\n-                  (ListEnd,                     vec![Key(\"b\")]),\n+                  (ArrayEnd,                    vec![Key(\"b\")]),\n                 (ObjectEnd,                     vec![]),\n             ]\n         );\n     }\n     #[test]\n     #[cfg_attr(target_word_size = \"32\", ignore)] // FIXME(#14064)\n-    fn test_read_list_streaming() {\n+    fn test_read_array_streaming() {\n         assert_stream_equal(\n             \"[]\",\n             vec![\n-                (ListStart, vec![]),\n-                (ListEnd,   vec![]),\n+                (ArrayStart, vec![]),\n+                (ArrayEnd,   vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[ ]\",\n             vec![\n-                (ListStart, vec![]),\n-                (ListEnd,   vec![]),\n+                (ArrayStart, vec![]),\n+                (ArrayEnd,   vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[true]\",\n             vec![\n-                (ListStart,              vec![]),\n+                (ArrayStart,             vec![]),\n                     (BooleanValue(true), vec![Index(0)]),\n-                (ListEnd,                vec![]),\n+                (ArrayEnd,               vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[ false ]\",\n             vec![\n-                (ListStart,               vec![]),\n+                (ArrayStart,              vec![]),\n                     (BooleanValue(false), vec![Index(0)]),\n-                (ListEnd,                 vec![]),\n+                (ArrayEnd,                vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[null]\",\n             vec![\n-                (ListStart,     vec![]),\n+                (ArrayStart,    vec![]),\n                     (NullValue, vec![Index(0)]),\n-                (ListEnd,       vec![]),\n+                (ArrayEnd,      vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[3, 1]\",\n             vec![\n-                (ListStart,     vec![]),\n+                (ArrayStart,      vec![]),\n                     (U64Value(3), vec![Index(0)]),\n                     (U64Value(1), vec![Index(1)]),\n-                (ListEnd,       vec![]),\n+                (ArrayEnd,        vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"\\n[3, 2]\\n\",\n             vec![\n-                (ListStart,     vec![]),\n+                (ArrayStart,      vec![]),\n                     (U64Value(3), vec![Index(0)]),\n                     (U64Value(2), vec![Index(1)]),\n-                (ListEnd,       vec![]),\n+                (ArrayEnd,        vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[2, [4, 1]]\",\n             vec![\n-                (ListStart,            vec![]),\n+                (ArrayStart,           vec![]),\n                     (U64Value(2),      vec![Index(0)]),\n-                    (ListStart,        vec![Index(1)]),\n+                    (ArrayStart,       vec![Index(1)]),\n                         (U64Value(4),  vec![Index(1), Index(0)]),\n                         (U64Value(1),  vec![Index(1), Index(1)]),\n-                    (ListEnd,          vec![Index(1)]),\n-                (ListEnd,              vec![]),\n+                    (ArrayEnd,         vec![Index(1)]),\n+                (ArrayEnd,             vec![]),\n             ]\n         );\n \n         assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1,  2)));\n \n         assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingList,  1, 3)));\n+        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n         assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n         assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n         assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n@@ -3693,16 +3693,16 @@ mod tests {\n         use std::collections::{HashMap,TreeMap};\n         use super::ToJson;\n \n-        let list2 = List(vec!(U64(1), U64(2)));\n-        let list3 = List(vec!(U64(1), U64(2), U64(3)));\n+        let array2 = Array(vec!(U64(1), U64(2)));\n+        let array3 = Array(vec!(U64(1), U64(2), U64(3)));\n         let object = {\n             let mut tree_map = TreeMap::new();\n             tree_map.insert(\"a\".to_string(), U64(1));\n             tree_map.insert(\"b\".to_string(), U64(2));\n             Object(tree_map)\n         };\n \n-        assert_eq!(list2.to_json(), list2);\n+        assert_eq!(array2.to_json(), array2);\n         assert_eq!(object.to_json(), object);\n         assert_eq!(3_i.to_json(), I64(3));\n         assert_eq!(4_i8.to_json(), I64(4));\n@@ -3723,12 +3723,12 @@ mod tests {\n         assert_eq!(false.to_json(), Boolean(false));\n         assert_eq!(\"abc\".to_json(), String(\"abc\".into_string()));\n         assert_eq!(\"abc\".into_string().to_json(), String(\"abc\".into_string()));\n-        assert_eq!((1u, 2u).to_json(), list2);\n-        assert_eq!((1u, 2u, 3u).to_json(), list3);\n-        assert_eq!([1u, 2].to_json(), list2);\n-        assert_eq!((&[1u, 2, 3]).to_json(), list3);\n-        assert_eq!((vec![1u, 2]).to_json(), list2);\n-        assert_eq!(vec!(1u, 2, 3).to_json(), list3);\n+        assert_eq!((1u, 2u).to_json(), array2);\n+        assert_eq!((1u, 2u, 3u).to_json(), array3);\n+        assert_eq!([1u, 2].to_json(), array2);\n+        assert_eq!((&[1u, 2, 3]).to_json(), array3);\n+        assert_eq!((vec![1u, 2]).to_json(), array2);\n+        assert_eq!(vec!(1u, 2, 3).to_json(), array3);\n         let mut tree_map = TreeMap::new();\n         tree_map.insert(\"a\".to_string(), 1u);\n         tree_map.insert(\"b\".to_string(), 2);"}, {"sha": "649298d9c0818dc294412e92e8bc787cf40a9773", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -17,6 +17,7 @@ pub use self::SignificantDigits::*;\n pub use self::SignFormat::*;\n \n use char;\n+use char::Char;\n use num;\n use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n use slice::{SlicePrelude, CloneSliceAllocPrelude};\n@@ -320,7 +321,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n         // round the remaining ones.\n         if limit_digits && dig == digit_count {\n             let ascii2value = |chr: u8| {\n-                char::to_digit(chr as char, radix).unwrap()\n+                (chr as char).to_digit(radix).unwrap()\n             };\n             let value2ascii = |val: uint| {\n                 char::from_digit(val, radix).unwrap() as u8"}, {"sha": "81022994387493e41d8e573196b3f0945441a538", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -71,7 +71,7 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n         while valid {\n             let mut i = 0;\n             for c in chars {\n-                if c.is_digit() {\n+                if c.is_numeric() {\n                     i = i * 10 + c as uint - '0' as uint;\n                 } else {\n                     break\n@@ -101,7 +101,7 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n                 first = false;\n             }\n             let mut rest = s;\n-            while rest.char_at(0).is_digit() {\n+            while rest.char_at(0).is_numeric() {\n                 rest = rest.slice_from(1);\n             }\n             let i: uint = from_str(s.slice_to(s.len() - rest.len())).unwrap();"}, {"sha": "c9d72603b8919908539e9c7ac4b03eb392a91d50", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -25,7 +25,7 @@\n \n #![allow(unknown_features)]\n #![feature(if_let, macro_rules, globs, default_type_params, phase, slicing_syntax)]\n-#![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n+#![feature(quote, unsafe_destructor, import_shadowing)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "a88029e087b155959b9e24bc405719595c09b671", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -193,7 +193,7 @@ impl<'a> StringReader<'a> {\n     fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        char::escape_default(c, |c| m.push(c));\n+        for c in c.escape_default() { m.push(c) }\n         self.fatal_span_(from_pos, to_pos, m.as_slice());\n     }\n \n@@ -202,7 +202,7 @@ impl<'a> StringReader<'a> {\n     fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        char::escape_default(c, |c| m.push(c));\n+        for c in c.escape_default() { m.push(c) }\n         self.err_span_(from_pos, to_pos, m.as_slice());\n     }\n \n@@ -645,7 +645,7 @@ impl<'a> StringReader<'a> {\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n-            match c.and_then(|cc| char::to_digit(cc, radix)) {\n+            match c.and_then(|cc| cc.to_digit(radix)) {\n                 Some(_) => {\n                     debug!(\"{} in scan_digits\", c);\n                     len += 1;\n@@ -677,7 +677,7 @@ impl<'a> StringReader<'a> {\n                     return token::Integer(self.name_from(start_bpos));\n                 }\n             }\n-        } else if c.is_digit_radix(10) {\n+        } else if c.is_digit(10) {\n             num_digits = self.scan_digits(10) + 1;\n         } else {\n             num_digits = 0;\n@@ -692,11 +692,11 @@ impl<'a> StringReader<'a> {\n         // integer literal followed by field/method access or a range pattern\n         // (`0..2` and `12.foo()`)\n         if self.curr_is('.') && !self.nextch_is('.') && !self.nextch().unwrap_or('\\0')\n-                                                             .is_XID_start() {\n+                                                             .is_xid_start() {\n             // might have stuff after the ., and if it does, it needs to start\n             // with a number\n             self.bump();\n-            if self.curr.unwrap_or('\\0').is_digit_radix(10) {\n+            if self.curr.unwrap_or('\\0').is_digit(10) {\n                 self.scan_digits(10);\n                 self.scan_float_exponent();\n             }\n@@ -1385,7 +1385,7 @@ fn ident_start(c: Option<char>) -> bool {\n     (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n         || c == '_'\n-        || (c > '\\x7f' && char::is_XID_start(c))\n+        || (c > '\\x7f' && c.is_xid_start())\n }\n \n fn ident_continue(c: Option<char>) -> bool {\n@@ -1395,7 +1395,7 @@ fn ident_continue(c: Option<char>) -> bool {\n         || (c >= 'A' && c <= 'Z')\n         || (c >= '0' && c <= '9')\n         || c == '_'\n-        || (c > '\\x7f' && char::is_XID_continue(c))\n+        || (c > '\\x7f' && c.is_xid_continue())\n }\n \n #[cfg(test)]"}, {"sha": "4ce0d74bd37f4e965e83cf282c8856a8ddcf2671", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -2756,7 +2756,9 @@ impl<'a> State<'a> {\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n-                ch.escape_default(|c| res.push(c));\n+                for c in ch.escape_default() {\n+                    res.push(c);\n+                }\n                 res.push('\\'');\n                 word(&mut self.s, res.as_slice())\n             }"}, {"sha": "cfab6494900765d30f78440dd0c22900ccc3659a", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -14,8 +14,6 @@ pub use self::Param::*;\n use self::States::*;\n use self::FormatState::*;\n use self::FormatOp::*;\n-\n-use std::char;\n use std::mem::replace;\n \n #[deriving(PartialEq)]\n@@ -298,7 +296,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             PushParam => {\n                 // params are 1-indexed\n-                stack.push(mparams[match char::to_digit(cur, 10) {\n+                stack.push(mparams[match cur.to_digit(10) {\n                     Some(d) => d - 1,\n                     None => return Err(\"bad param number\".to_string())\n                 }].clone());"}, {"sha": "369336639a7fe465b617b8c552cc0e42cffda939", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 101, "deletions": 51, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -20,12 +20,9 @@ use tables::{derived_property, property, general_category, conversions, charwidt\n \n /// Returns whether the specified `char` is considered a Unicode alphabetic\n /// code point\n+#[deprecated = \"use UnicodeChar::is_alphabetic\"]\n pub fn is_alphabetic(c: char) -> bool {\n-    match c {\n-        'a' ... 'z' | 'A' ... 'Z' => true,\n-        c if c > '\\x7f' => derived_property::Alphabetic(c),\n-        _ => false\n-    }\n+    c.is_alphabetic()\n }\n \n /// Returns whether the specified `char` satisfies the 'XID_Start' Unicode property\n@@ -34,6 +31,7 @@ pub fn is_alphabetic(c: char) -> bool {\n /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n /// mostly similar to ID_Start but modified for closure under NFKx.\n #[allow(non_snake_case)]\n+#[deprecated = \"use UnicodeChar::is_XID_start\"]\n pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n \n /// Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property\n@@ -42,6 +40,7 @@ pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n #[allow(non_snake_case)]\n+#[deprecated = \"use UnicodeChar::is_XID_continue\"]\n pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n \n ///\n@@ -50,12 +49,9 @@ pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n /// This is defined according to the terms of the Unicode Derived Core Property 'Lowercase'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_lowercase\"]\n pub fn is_lowercase(c: char) -> bool {\n-    match c {\n-        'a' ... 'z' => true,\n-        c if c > '\\x7f' => derived_property::Lowercase(c),\n-        _ => false\n-    }\n+    c.is_lowercase()\n }\n \n ///\n@@ -64,12 +60,9 @@ pub fn is_lowercase(c: char) -> bool {\n /// This is defined according to the terms of the Unicode Derived Core Property 'Uppercase'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_uppercase\"]\n pub fn is_uppercase(c: char) -> bool {\n-    match c {\n-        'A' ... 'Z' => true,\n-        c if c > '\\x7f' => derived_property::Uppercase(c),\n-        _ => false\n-    }\n+    c.is_uppercase()\n }\n \n ///\n@@ -78,12 +71,9 @@ pub fn is_uppercase(c: char) -> bool {\n /// Whitespace is defined in terms of the Unicode Property 'White_Space'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_whitespace\"]\n pub fn is_whitespace(c: char) -> bool {\n-    match c {\n-        ' ' | '\\x09' ... '\\x0d' => true,\n-        c if c > '\\x7f' => property::White_Space(c),\n-        _ => false\n-    }\n+    c.is_whitespace()\n }\n \n ///\n@@ -93,9 +83,9 @@ pub fn is_whitespace(c: char) -> bool {\n /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_alphanumeric\"]\n pub fn is_alphanumeric(c: char) -> bool {\n-    is_alphabetic(c)\n-        || is_digit(c)\n+    c.is_alphanumeric()\n }\n \n ///\n@@ -105,16 +95,14 @@ pub fn is_alphanumeric(c: char) -> bool {\n /// 'Cc'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_control\"]\n pub fn is_control(c: char) -> bool { general_category::Cc(c) }\n \n /// Indicates whether the `char` is numeric (Nd, Nl, or No)\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_numeric\"]\n pub fn is_digit(c: char) -> bool {\n-    match c {\n-        '0' ... '9' => true,\n-        c if c > '\\x7f' => general_category::N(c),\n-        _ => false\n-    }\n+    c.is_numeric()\n }\n \n /// Convert a char to its uppercase equivalent\n@@ -132,6 +120,7 @@ pub fn is_digit(c: char) -> bool {\n ///\n /// Returns the char itself if no conversion was made\n #[inline]\n+#[deprecated = \"use UnicodeChar::to_uppercase\"]\n pub fn to_uppercase(c: char) -> char {\n     conversions::to_upper(c)\n }\n@@ -145,6 +134,7 @@ pub fn to_uppercase(c: char) -> char {\n ///\n /// Returns the char itself if no conversion if possible\n #[inline]\n+#[deprecated = \"use UnicodeChar::to_lowercase\"]\n pub fn to_lowercase(c: char) -> char {\n     conversions::to_lower(c)\n }\n@@ -158,15 +148,17 @@ pub fn to_lowercase(c: char) -> char {\n /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n /// recommends that these characters be treated as 1 column (i.e.,\n /// `is_cjk` = `false`) if the context cannot be reliably determined.\n+#[deprecated = \"use UnicodeChar::width\"]\n pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n     charwidth::width(c, is_cjk)\n }\n \n /// Useful functions for Unicode characters.\n+#[experimental = \"pending prelude organization\"]\n pub trait UnicodeChar {\n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n-    fn is_alphabetic(&self) -> bool;\n+    fn is_alphabetic(self) -> bool;\n \n     /// Returns whether the specified character satisfies the 'XID_Start'\n     /// Unicode property.\n@@ -175,7 +167,16 @@ pub trait UnicodeChar {\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n     #[allow(non_snake_case)]\n-    fn is_XID_start(&self) -> bool;\n+    #[deprecated = \"use is_xid_start\"]\n+    fn is_XID_start(self) -> bool;\n+\n+    /// Returns whether the specified character satisfies the 'XID_Start'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Start' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to ID_Start but modified for closure under NFKx.\n+    fn is_xid_start(self) -> bool;\n \n     /// Returns whether the specified `char` satisfies the 'XID_Continue'\n     /// Unicode property.\n@@ -184,40 +185,48 @@ pub trait UnicodeChar {\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n     #[allow(non_snake_case)]\n-    fn is_XID_continue(&self) -> bool;\n+    #[deprecated = \"use is_xid_continue\"]\n+    fn is_XID_continue(self) -> bool;\n \n+    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Continue' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n+    fn is_xid_continue(self) -> bool;\n \n     /// Indicates whether a character is in lowercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n-    fn is_lowercase(&self) -> bool;\n+    fn is_lowercase(self) -> bool;\n \n     /// Indicates whether a character is in uppercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n-    fn is_uppercase(&self) -> bool;\n+    fn is_uppercase(self) -> bool;\n \n     /// Indicates whether a character is whitespace.\n     ///\n     /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n-    fn is_whitespace(&self) -> bool;\n+    fn is_whitespace(self) -> bool;\n \n     /// Indicates whether a character is alphanumeric.\n     ///\n     /// Alphanumericness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-    fn is_alphanumeric(&self) -> bool;\n+    fn is_alphanumeric(self) -> bool;\n \n     /// Indicates whether a character is a control code point.\n     ///\n     /// Control code points are defined in terms of the Unicode General\n     /// Category `Cc`.\n-    fn is_control(&self) -> bool;\n+    fn is_control(self) -> bool;\n \n     /// Indicates whether the character is numeric (Nd, Nl, or No).\n-    fn is_digit(&self) -> bool;\n+    fn is_numeric(self) -> bool;\n \n     /// Converts a character to its lowercase equivalent.\n     ///\n@@ -228,7 +237,7 @@ pub trait UnicodeChar {\n     ///\n     /// Returns the lowercase equivalent of the character, or the character\n     /// itself if no conversion is possible.\n-    fn to_lowercase(&self) -> char;\n+    fn to_lowercase(self) -> char;\n \n     /// Converts a character to its uppercase equivalent.\n     ///\n@@ -250,7 +259,7 @@ pub trait UnicodeChar {\n     /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    fn to_uppercase(&self) -> char;\n+    fn to_uppercase(self) -> char;\n \n     /// Returns this character's displayed width in columns, or `None` if it is a\n     /// control character other than `'\\x00'`.\n@@ -261,31 +270,72 @@ pub trait UnicodeChar {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    fn width(&self, is_cjk: bool) -> Option<uint>;\n+    #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    fn width(self, is_cjk: bool) -> Option<uint>;\n }\n \n+#[experimental = \"pending prelude organization\"]\n impl UnicodeChar for char {\n-    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }\n+    fn is_alphabetic(self) -> bool {\n+        match self {\n+            'a' ... 'z' | 'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Alphabetic(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_XID_start(&self) -> bool { is_XID_start(*self) }\n+    #[deprecated = \"use is_xid_start\"]\n+    fn is_XID_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }\n+    #[deprecated = \"use is_xid_continue\"]\n+    fn is_XID_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    fn is_lowercase(&self) -> bool { is_lowercase(*self) }\n+    fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    fn is_uppercase(&self) -> bool { is_uppercase(*self) }\n+    fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n+    fn is_lowercase(self) -> bool {\n+        match self {\n+            'a' ... 'z' => true,\n+            c if c > '\\x7f' => derived_property::Lowercase(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n+    fn is_uppercase(self) -> bool {\n+        match self {\n+            'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Uppercase(c),\n+            _ => false\n+        }\n+    }\n+\n+    fn is_whitespace(self) -> bool {\n+        match self {\n+            ' ' | '\\x09' ... '\\x0d' => true,\n+            c if c > '\\x7f' => property::White_Space(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_control(&self) -> bool { is_control(*self) }\n+    fn is_alphanumeric(self) -> bool {\n+        self.is_alphabetic() || self.is_numeric()\n+    }\n+\n+    fn is_control(self) -> bool { general_category::Cc(self) }\n \n-    fn is_digit(&self) -> bool { is_digit(*self) }\n+    fn is_numeric(self) -> bool {\n+        match self {\n+            '0' ... '9' => true,\n+            c if c > '\\x7f' => general_category::N(c),\n+            _ => false\n+        }\n+    }\n \n-    fn to_lowercase(&self) -> char { to_lowercase(*self) }\n+    fn to_lowercase(self) -> char { conversions::to_lower(self) }\n \n-    fn to_uppercase(&self) -> char { to_uppercase(*self) }\n+    fn to_uppercase(self) -> char { conversions::to_upper(self) }\n \n-    fn width(&self, is_cjk: bool) -> Option<uint> { width(*self, is_cjk) }\n+    #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "56b1f0907d5a4c4c4338042f23d87fc092316936", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -24,13 +24,13 @@ use core::iter::{Filter, AdditiveIterator, Iterator, DoubleEndedIterator};\n use core::kinds::Sized;\n use core::option::{Option, None, Some};\n use core::str::{CharSplits, StrPrelude};\n-use u_char;\n use u_char::UnicodeChar;\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n+/// FIXME: This should be opaque\n pub type Words<'a> =\n-    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n+    Filter<'a, &'a str, CharSplits<'a, |char|:'a -> bool>>;\n \n /// Methods for Unicode string slices\n pub trait UnicodeStrPrelude for Sized? {\n@@ -143,14 +143,15 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn words(&self) -> Words {\n-        self.split(u_char::is_whitespace).filter(|s| !s.is_empty())\n+        let f = |c: char| c.is_whitespace();\n+        self.split(f).filter(|s| !s.is_empty())\n     }\n \n     #[inline]\n-    fn is_whitespace(&self) -> bool { self.chars().all(u_char::is_whitespace) }\n+    fn is_whitespace(&self) -> bool { self.chars().all(|c| c.is_whitespace()) }\n \n     #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.chars().all(u_char::is_alphanumeric) }\n+    fn is_alphanumeric(&self) -> bool { self.chars().all(|c| c.is_alphanumeric()) }\n \n     #[inline]\n     fn width(&self, is_cjk: bool) -> uint {\n@@ -164,12 +165,12 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn trim_left(&self) -> &str {\n-        self.trim_left_chars(u_char::is_whitespace)\n+        self.trim_left_chars(|c: char| c.is_whitespace())\n     }\n \n     #[inline]\n     fn trim_right(&self) -> &str {\n-        self.trim_right_chars(u_char::is_whitespace)\n+        self.trim_right_chars(|c: char| c.is_whitespace())\n     }\n }\n "}, {"sha": "7096146a43af9ebdaee737c33a8b7ee5b546729c", "filename": "src/test/auxiliary/issue-8044.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fissue-8044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fissue-8044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-8044.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n pub struct BTree<V> {\n     pub node: TreeItem<V>,\n }"}, {"sha": "c7387dd284ebf3537cb4f1d2db7be36d6f79ebf6", "filename": "src/test/auxiliary/namespaced_enum_emulate_flat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, struct_variant)]\n+#![feature(globs)]\n \n pub use Foo::*;\n "}, {"sha": "5b21d130d1704eb8198518c7424bca700334141f", "filename": "src/test/auxiliary/namespaced_enums.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(struct_variant)]\n \n pub enum Foo {\n     A,"}, {"sha": "0bdda23508038a8245d8f3bc8d6b14ef1ee1a6e5", "filename": "src/test/auxiliary/struct_variant_privacy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fstruct_variant_privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fstruct_variant_privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_variant_privacy.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(struct_variant)]\n \n enum Bar {\n     Baz { a: int }"}, {"sha": "76fd619f689648adba8e8cc2c444c3e50c8f3099", "filename": "src/test/auxiliary/struct_variant_xc_aux.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -11,8 +11,6 @@\n #![crate_name=\"struct_variant_xc_aux\"]\n #![crate_type = \"lib\"]\n \n-#![feature(struct_variant)]\n-\n pub enum Enum {\n     Variant(u8),\n     StructVariant { arg: u8 }"}, {"sha": "9cda56a774380e2295f8a342db0d56d6850f2abc", "filename": "src/test/debuginfo/borrowed-enum.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -40,7 +40,6 @@\n // lldb-check:[...]$2 = TheOnlyCase(4820353753753434)\n \n #![allow(unused_variables)]\n-#![feature(struct_variant)]\n \n // The first element is to ensure proper alignment, irrespective of the machines word size. Since\n // the size of the discriminant value is machine dependent, this has be taken into account when"}, {"sha": "258c49afcc42c84f4422f7b170cc808b6f5066fc", "filename": "src/test/debuginfo/by-value-non-immediate-argument.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fby-value-non-immediate-argument.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -71,8 +71,6 @@\n // lldb-check:[...]$6 = Case1 { x: 0, y: 8970181431921507452 }\n // lldb-command:continue\n \n-#![feature(struct_variant)]\n-\n #[deriving(Clone)]\n struct Struct {\n     a: int,"}, {"sha": "9a42cd92fdc877c7b4e5c151ee73530d595ca7c6", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -64,8 +64,6 @@\n // gdb-command: print nested_variant2\n // gdb-check:$14 = NestedVariant2 = {abc = NestedStruct = {regular_struct = RegularStruct = {the_first_field = 117, the_second_field = 118.5, the_third_field = false, the_fourth_field = \"NestedStructString10\"}, tuple_struct = TupleStruct = {119.5, 120}, empty_struct = EmptyStruct, c_style_enum = CStyleEnumVar3, mixed_enum = MixedEnumStructVar = {field1 = 121.5, field2 = -122}}}\n \n-#![feature(struct_variant)]\n-\n use self::CStyleEnum::{CStyleEnumVar1, CStyleEnumVar2, CStyleEnumVar3};\n use self::MixedEnum::{MixedEnumCStyleVar, MixedEnumTupleVar, MixedEnumStructVar};\n use self::NestedEnum::{NestedVariant1, NestedVariant2};"}, {"sha": "d69d432fcb30f64815e13ec6be10c1aaeb7b78de", "filename": "src/test/debuginfo/generic-static-method-on-struct-and-enum.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-static-method-on-struct-and-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -31,8 +31,6 @@\n // gdb-check:$5 = 5\n // gdb-command:continue\n \n-#![feature(struct_variant)]\n-\n struct Struct {\n     x: int\n }"}, {"sha": "5e967266421722ed7bae849775a2e17851d05801", "filename": "src/test/debuginfo/generic-struct-style-enum.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -29,8 +29,6 @@\n // gdb-command:print univariant\n // gdb-check:$4 = {{a = -1}}\n \n-#![feature(struct_variant)]\n-\n use self::Regular::{Case1, Case2, Case3};\n use self::Univariant::TheOnlyCase;\n "}, {"sha": "d86aa54f451eeb87821ecc666bf9441a9d72a201", "filename": "src/test/debuginfo/method-on-enum.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmethod-on-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -113,8 +113,6 @@\n // lldb-check:[...]$14 = -10\n // lldb-command:continue\n \n-#![feature(struct_variant)]\n-\n enum Enum {\n     Variant1 { x: u16, y: u16 },\n     Variant2 (u32)"}, {"sha": "11c594bac599af4202d698119faaf2bed70cbdf4", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -62,8 +62,6 @@\n // lldb-check:[...]$5 = Void\n \n \n-#![feature(struct_variant)]\n-\n // If a struct has exactly two variants, one of them is empty, and the other one\n // contains a non-nullable pointer, then this value is used as the discriminator.\n // The test cases in this file make sure that something readable is generated for"}, {"sha": "032b8b1fa262fdaba624fb83eb5278e04e3efc7b", "filename": "src/test/debuginfo/recursive-struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -69,7 +69,6 @@\n // gdb-command:continue\n \n #![allow(unused_variables)]\n-#![feature(struct_variant)]\n \n use self::Opt::{Empty, Val};\n "}, {"sha": "f808e7f8a90ff578710da5008c23ca1bbab381fd", "filename": "src/test/debuginfo/static-method-on-struct-and-enum.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fstatic-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fstatic-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstatic-method-on-struct-and-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -54,8 +54,6 @@\n // lldb-check:[...]$4 = 5\n // lldb-command:continue\n \n-#![feature(struct_variant)]\n-\n struct Struct {\n     x: int\n }"}, {"sha": "48c6c2d79fb43afb30103c8f571721a5d7d475d4", "filename": "src/test/debuginfo/struct-style-enum.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -49,7 +49,6 @@\n // lldb-check:[...]$3 = TheOnlyCase { a: -1 }\n \n #![allow(unused_variables)]\n-#![feature(struct_variant)]\n \n use self::Regular::{Case1, Case2, Case3};\n use self::Univariant::TheOnlyCase;"}, {"sha": "3c0a4a21b4fceb92125e897c1c60e9d72a084c6b", "filename": "src/test/debuginfo/unique-enum.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Fdebuginfo%2Funique-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -42,7 +42,6 @@\n // lldb-check:[...]$2 = TheOnlyCase(123234)\n \n #![allow(unused_variables)]\n-#![feature(struct_variant)]\n \n // The first element is to ensure proper alignment, irrespective of the machines word size. Since\n // the size of the discriminant value is machine dependent, this has be taken into account when"}, {"sha": "ac48752b0a944aef659bf9436c40fd8822217eed", "filename": "src/test/run-pass/const-enum-structlike.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n enum E {\n     S0 { s: String },\n     S1 { u: uint }"}, {"sha": "0c70102d57e2008381dcf128180810d59d7726a1", "filename": "src/test/run-pass/deriving-cmp-generic-struct-enum.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -10,8 +10,6 @@\n \n // no-pretty-expanded FIXME #15189\n \n-#![feature(struct_variant)]\n-\n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n enum ES<T> {\n     ES1 { x: T },"}, {"sha": "7bee4bc7b0d20df43ea38164e839bc7777f2823d", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -13,8 +13,6 @@\n \n // ignore-test FIXME(#5121)\n \n-#![feature(struct_variant)]\n-\n extern crate rand;\n extern crate rbml;\n extern crate serialize;"}, {"sha": "544c0052433dc7ee64242b72056f241a2773d4ad", "filename": "src/test/run-pass/deriving-rand.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-rand.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n use std::rand;\n \n #[deriving(Rand)]"}, {"sha": "df4bc1ae1d09cd6125a6cd9d429c4e6a35f41723", "filename": "src/test/run-pass/deriving-show-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show-2.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n use std::fmt;\n \n #[deriving(Show)]"}, {"sha": "ccfaac8378fa81e60b3f66ad2fdfa8035ef3d63b", "filename": "src/test/run-pass/deriving-show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant, macro_rules)]\n+#![feature(macro_rules)]\n \n #[deriving(Show)]\n struct Unit;"}, {"sha": "b091787b1ee235237e4c1e94f41f820d917ede8b", "filename": "src/test/run-pass/deriving-via-extension-struct-like-enum-variant.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n #[deriving(PartialEq, Show)]\n enum S {\n     X { x: int, y: int },"}, {"sha": "15f028e1716f081232e198ce1d2d61b909b9cc06", "filename": "src/test/run-pass/drop-trait-enum.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n use std::task;\n \n #[deriving(PartialEq, Show)]"}, {"sha": "4a3a1156698aa32e73bb81e2abc3a97f12e73eae", "filename": "src/test/run-pass/enum-variants.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fenum-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-variants.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -10,7 +10,6 @@\n \n #![allow(dead_assignment)]\n #![allow(unused_variable)]\n-#![feature(struct_variant)]\n \n enum Animal {\n     Dog (String, f64),"}, {"sha": "9440e0c2874a0cfc1ec1b000bbd2aaa21c30adb0", "filename": "src/test/run-pass/issue-11085.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-11085.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-11085.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11085.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -10,8 +10,6 @@\n \n // compile-flags: --cfg foo\n \n-#![feature(struct_variant)]\n-\n struct Foo {\n     #[cfg(fail)]\n     bar: baz,"}, {"sha": "687de48474058dd857b1cb5543317b8d68f6a257", "filename": "src/test/run-pass/issue-11577.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-11577.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-11577.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11577.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n // Destructuring struct variants would ICE where regular structs wouldn't\n \n enum Foo {"}, {"sha": "1155027d426da833262e0f9e1bb80ec4a25d22d5", "filename": "src/test/run-pass/issue-14837.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-14837.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-14837.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14837.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n #[deny(dead_code)]\n pub enum Foo {\n     Bar {"}, {"sha": "4f66139789b1e88a00d30af91bb700d90d50d01d", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -59,7 +59,7 @@ fn add_interfaces(store: int, managed_ip: String, device: HashMap<String, json::\n -> Vec<(String, object)> {\n     match device[\"interfaces\".to_string()]\n     {\n-        json::List(ref interfaces) =>\n+        json::Array(ref interfaces) =>\n         {\n           interfaces.iter().map(|interface| {\n                 add_interface(store, managed_ip.clone(), (*interface).clone())"}, {"sha": "a9e1ffcb34510ecdc4af67b7a53a4dcd308ffbb6", "filename": "src/test/run-pass/issue-5530.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-5530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-5530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5530.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n enum Enum {\n     Foo { foo: uint },\n     Bar { bar: uint }"}, {"sha": "b7e6facc58187a44868ea261e697da5a7e61ff83", "filename": "src/test/run-pass/issue-8351-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-8351-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-8351-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8351-1.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n enum E {\n     Foo{f: int},\n     Bar,"}, {"sha": "40e0b3a8eeccb6e9f162597349e3774ea9d21220", "filename": "src/test/run-pass/issue-8351-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-8351-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fissue-8351-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8351-2.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n enum E {\n     Foo{f: int, b: bool},\n     Bar,"}, {"sha": "85fa61266a338fdd5d183cf2a930de49e5881794", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n struct NewBool(bool);\n \n enum Direction {"}, {"sha": "5cc512abfe37c6aa516181a0743a84ea3a9ded86", "filename": "src/test/run-pass/match-enum-struct-0.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -10,8 +10,6 @@\n \n // regression test for issue #5625\n \n-#![feature(struct_variant)]\n-\n enum E {\n     Foo{f : int},\n     Bar"}, {"sha": "fdfadf8eb444fd55dbd7851818bdf26747bdb230", "filename": "src/test/run-pass/match-enum-struct-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n enum E {\n     Foo{f : int},\n     Bar"}, {"sha": "2f8e184033ae74f3d18f35907d58bd5479b6d4be", "filename": "src/test/run-pass/match-in-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules, struct_variant)]\n+#![feature(macro_rules)]\n \n enum Foo {\n     B { b1: int, bb1: int},"}, {"sha": "680cdf14e8f2a8832fe7679e8536f2780f540957", "filename": "src/test/run-pass/namespaced-enum-emulate-flat-xc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat-xc.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:namespaced_enum_emulate_flat.rs\n-#![feature(struct_variant)]\n \n extern crate namespaced_enum_emulate_flat;\n "}, {"sha": "676fe6500818e37f01b2ba6eee9face47eb098bc", "filename": "src/test/run-pass/namespaced-enum-emulate-flat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, struct_variant)]\n+#![feature(globs)]\n \n pub use Foo::*;\n use nest::{Bar, D, E, F};"}, {"sha": "cc4985927f19025a16c6c9b3a94c5699c0498d44", "filename": "src/test/run-pass/namespaced-enum-glob-import-xcrate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import-xcrate.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // aux-build:namespaced_enums.rs\n-#![feature(globs, struct_variant)]\n+#![feature(globs)]\n \n extern crate namespaced_enums;\n "}, {"sha": "137dd543566bd748531c17bcb2e66d65a6424ba4", "filename": "src/test/run-pass/namespaced-enum-glob-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, struct_variant)]\n+#![feature(globs)]\n \n mod m2 {\n     pub enum Foo {"}, {"sha": "7545908dcbbf6ad71a051a288b6e6c96540b29ec", "filename": "src/test/run-pass/namespaced-enums-xcrate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enums-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enums-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enums-xcrate.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:namespaced_enums.rs\n-#![feature(struct_variant)]\n \n extern crate namespaced_enums;\n "}, {"sha": "13f70f6a740aef76ed24b76fd1a9d67544e73064", "filename": "src/test/run-pass/namespaced-enums.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fnamespaced-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enums.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(struct_variant)]\n \n enum Foo {\n     A,"}, {"sha": "364c6da980393263bd5075f6e753371738d61858", "filename": "src/test/run-pass/struct-like-variant-construct.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-like-variant-construct.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n enum Foo {\n     Bar {\n         a: int,"}, {"sha": "3afa44a3142b40b8d40fac406b3cd4417f17946f", "filename": "src/test/run-pass/struct-like-variant-match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-like-variant-match.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n enum Foo {\n     Bar {\n         x: int,"}, {"sha": "aad3ba01a487e24c21bdac5c354c0cc1045c54af", "filename": "src/test/run-pass/struct-variant-field-visibility.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fstruct-variant-field-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fstruct-variant-field-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-variant-field-visibility.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n mod foo {\n     pub enum Foo {\n         Bar { a: int }"}, {"sha": "d28d47c0cfb85f6249850e955c0f8e67d4a92659", "filename": "src/test/run-pass/unsized2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized2.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -9,8 +9,6 @@\n // except according to those terms.\n //\n // ignore-lexer-test FIXME #15879\n-#![feature(struct_variant)]\n-\n \n // Test sized-ness checking in substitution.\n "}, {"sha": "e078fa1485d14978fac563396a35283ea35ee889", "filename": "src/test/run-pass/variant-structs-trivial.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fvariant-structs-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46bdb455c3087149364d87748cc6c683c4ed130e/src%2Ftest%2Frun-pass%2Fvariant-structs-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariant-structs-trivial.rs?ref=46bdb455c3087149364d87748cc6c683c4ed130e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(struct_variant)]\n-\n enum Foo {\n     Bar { x: int },\n     Baz { y: int }"}]}