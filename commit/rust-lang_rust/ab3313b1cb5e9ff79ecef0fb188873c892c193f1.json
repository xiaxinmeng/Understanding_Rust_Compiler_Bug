{"sha": "ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "node_id": "C_kwDOAAsO6NoAKGFiMzMxM2IxY2I1ZTlmZjc5ZWNlZjBmYjE4ODg3M2M4OTJjMTkzZjE", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-20T15:26:48Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-21T15:46:01Z"}, "message": "Add new type-mismatch diagnostic", "tree": {"sha": "5c5a506d31e0feb05894503026e9948f7f7e4e6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c5a506d31e0feb05894503026e9948f7f7e4e6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "html_url": "https://github.com/rust-lang/rust/commit/ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d30dd67d34fcac0cd47bc64485239e0c2616e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d30dd67d34fcac0cd47bc64485239e0c2616e13", "html_url": "https://github.com/rust-lang/rust/commit/2d30dd67d34fcac0cd47bc64485239e0c2616e13"}], "stats": {"total": 232, "additions": 151, "deletions": 81}, "files": [{"sha": "49551bf6101db094f02cad51b3abd126d159a21a", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "patch": "@@ -28,7 +28,6 @@ macro_rules! diagnostics {\n }\n \n diagnostics![\n-    AddReferenceHere,\n     BreakOutsideOfLoop,\n     InactiveCode,\n     IncorrectCase,\n@@ -38,11 +37,10 @@ diagnostics![\n     MismatchedArgCount,\n     MissingFields,\n     MissingMatchArms,\n-    MissingOkOrSomeInTailExpr,\n     MissingUnsafe,\n     NoSuchField,\n-    RemoveThisSemicolon,\n     ReplaceFilterMapNextWithFindMap,\n+    TypeMismatch,\n     UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n     UnresolvedImport,\n@@ -147,29 +145,17 @@ pub struct MismatchedArgCount {\n     pub found: usize,\n }\n \n-#[derive(Debug)]\n-pub struct RemoveThisSemicolon {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-}\n-\n-#[derive(Debug)]\n-pub struct MissingOkOrSomeInTailExpr {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-    // `Some` or `Ok` depending on whether the return type is Result or Option\n-    pub required: String,\n-    pub expected: Type,\n-}\n-\n #[derive(Debug)]\n pub struct MissingMatchArms {\n     pub file: HirFileId,\n     pub match_expr: AstPtr<ast::Expr>,\n }\n \n #[derive(Debug)]\n-pub struct AddReferenceHere {\n+pub struct TypeMismatch {\n     pub expr: InFile<AstPtr<ast::Expr>>,\n-    pub mutability: Mutability,\n+    pub expected: Type,\n+    pub actual: Type,\n }\n \n pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "035ae2d408b067cbd7d048b27285b6c0d7f99184", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "patch": "@@ -85,12 +85,11 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AddReferenceHere, AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingOkOrSomeInTailExpr, MissingUnsafe, NoSuchField,\n-        RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-        UnresolvedProcMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n+        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n+        MissingUnsafe, NoSuchField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n+        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo},\n@@ -1163,6 +1162,28 @@ impl DefWithBody {\n                 }\n             }\n         }\n+        for (expr, mismatch) in infer.expr_type_mismatches() {\n+            let expr =\n+                source_map.expr_syntax(expr).expect(\"break outside of loop in synthetic syntax\");\n+            acc.push(\n+                TypeMismatch {\n+                    expr,\n+                    expected: Type::new(\n+                        db,\n+                        krate,\n+                        DefWithBodyId::from(self),\n+                        mismatch.expected.clone(),\n+                    ),\n+                    actual: Type::new(\n+                        db,\n+                        krate,\n+                        DefWithBodyId::from(self),\n+                        mismatch.actual.clone(),\n+                    ),\n+                }\n+                .into(),\n+            );\n+        }\n \n         for expr in hir_ty::diagnostics::missing_unsafe(db, self.into()) {\n             match source_map.expr_syntax(expr) {\n@@ -1259,25 +1280,6 @@ impl DefWithBody {\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n-                BodyValidationDiagnostic::RemoveThisSemicolon { expr } => {\n-                    match source_map.expr_syntax(expr) {\n-                        Ok(expr) => acc.push(RemoveThisSemicolon { expr }.into()),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n-                BodyValidationDiagnostic::MissingOkOrSomeInTailExpr { expr, required } => {\n-                    match source_map.expr_syntax(expr) {\n-                        Ok(expr) => acc.push(\n-                            MissingOkOrSomeInTailExpr {\n-                                expr,\n-                                required,\n-                                expected: self.body_type(db),\n-                            }\n-                            .into(),\n-                        ),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n                 BodyValidationDiagnostic::MissingMatchArms { match_expr } => {\n                     match source_map.expr_syntax(match_expr) {\n                         Ok(source_ptr) => {\n@@ -1299,12 +1301,7 @@ impl DefWithBody {\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n-                BodyValidationDiagnostic::AddReferenceHere { arg_expr, mutability } => {\n-                    match source_map.expr_syntax(arg_expr) {\n-                        Ok(expr) => acc.push(AddReferenceHere { expr, mutability }.into()),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n+                _ => {} // TODO fixme\n             }\n         }\n \n@@ -2618,6 +2615,14 @@ impl Type {\n         Type { krate, env: environment, ty }\n     }\n \n+    pub fn reference(inner: &Type, m: Mutability) -> Type {\n+        inner.derived(TyKind::Ref(\n+            if m.is_mut() { hir_ty::Mutability::Mut } else { hir_ty::Mutability::Not },\n+            hir_ty::static_lifetime(),\n+            inner.ty.clone(),\n+        ).intern(Interner))\n+    }\n+\n     fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n         let resolver = lexical_env.resolver(db.upcast());\n         let environment = resolver\n@@ -2659,6 +2664,12 @@ impl Type {\n         matches!(self.ty.kind(Interner), TyKind::Ref(..))\n     }\n \n+    pub fn as_reference(&self) -> Option<(Type, Mutability)> {\n+        let (ty, _lt, m) = self.ty.as_reference()?;\n+        let m = Mutability::from_mutable(matches!(m, hir_ty::Mutability::Mut));\n+        Some((self.derived(ty.clone()), m))\n+    }\n+\n     pub fn is_slice(&self) -> bool {\n         matches!(self.ty.kind(Interner), TyKind::Slice(..))\n     }"}, {"sha": "8e9336a0cc49f1926c4f0b90a7f9d95c27ceca11", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "patch": "@@ -38,6 +38,22 @@ impl Mutability {\n             Mutability::Mut => \"mut \",\n         }\n     }\n+\n+    /// Returns `true` if the mutability is [`Mut`].\n+    ///\n+    /// [`Mut`]: Mutability::Mut\n+    #[must_use]\n+    pub fn is_mut(&self) -> bool {\n+        matches!(self, Self::Mut)\n+    }\n+\n+    /// Returns `true` if the mutability is [`Shared`].\n+    ///\n+    /// [`Shared`]: Mutability::Shared\n+    #[must_use]\n+    pub fn is_shared(&self) -> bool {\n+        matches!(self, Self::Shared)\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "2b7105362503859dc9a5177290dadb6112863f8d", "filename": "crates/ide_diagnostics/src/handlers/field_shorthand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs?ref=ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "patch": "@@ -108,13 +108,13 @@ mod tests {\n         check_diagnostics(\n             r#\"\n struct A { a: &'static str }\n-fn main() { A { a: \"hello\" } }\n+fn main() { A { a: \"hello\" }; }\n \"#,\n         );\n         check_diagnostics(\n             r#\"\n struct A(usize);\n-fn main() { A { 0: 0 } }\n+fn main() { A { 0: 0 }; }\n \"#,\n         );\n \n@@ -123,14 +123,14 @@ fn main() { A { 0: 0 } }\n struct A { a: &'static str }\n fn main() {\n     let a = \"haha\";\n-    A { a$0: a }\n+    A { a$0: a };\n }\n \"#,\n             r#\"\n struct A { a: &'static str }\n fn main() {\n     let a = \"haha\";\n-    A { a }\n+    A { a };\n }\n \"#,\n         );\n@@ -141,15 +141,15 @@ struct A { a: &'static str, b: &'static str }\n fn main() {\n     let a = \"haha\";\n     let b = \"bb\";\n-    A { a$0: a, b }\n+    A { a$0: a, b };\n }\n \"#,\n             r#\"\n struct A { a: &'static str, b: &'static str }\n fn main() {\n     let a = \"haha\";\n     let b = \"bb\";\n-    A { a, b }\n+    A { a, b };\n }\n \"#,\n         );"}, {"sha": "fe6a8683c110df2624b5c3b2595dedb6735a1342", "filename": "crates/ide_diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "patch": "@@ -278,6 +278,7 @@ fn main() {\n     match (true, false) {\n         (true, false, true) => (),\n         (true) => (),\n+      // ^^^^  error: expected (bool, bool), found bool\n     }\n     match (true, false) { (true,) => {} }\n     match (0) { () => () }"}, {"sha": "2f8bda9efa7f9c35c6b3407d974be3aee505eafd", "filename": "crates/ide_diagnostics/src/handlers/type_mismatch.rs", "status": "renamed", "additions": 77, "deletions": 20, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "patch": "@@ -1,37 +1,62 @@\n-use hir::db::AstDatabase;\n+use hir::{db::AstDatabase, HirDisplay, Type};\n use ide_db::source_change::SourceChange;\n-use syntax::AstNode;\n+use syntax::{AstNode, TextRange};\n use text_edit::TextEdit;\n \n use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n \n-// Diagnostic: add-reference-here\n+// Diagnostic: type-mismatch\n //\n-// This diagnostic is triggered when there's a missing referencing of expression.\n-pub(crate) fn add_reference_here(\n-    ctx: &DiagnosticsContext<'_>,\n-    d: &hir::AddReferenceHere,\n-) -> Diagnostic {\n-    Diagnostic::new(\n-        \"add-reference-here\",\n-        \"add reference here\",\n+// This diagnostic is triggered when the type of an expression does not match\n+// the expected type.\n+pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Diagnostic {\n+    let mut diag = Diagnostic::new(\n+        \"type-mismatch\",\n+        format!(\n+            \"expected {}, found {}\",\n+            d.expected.display(ctx.sema.db),\n+            d.actual.display(ctx.sema.db)\n+        ),\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n-    .with_fixes(fixes(ctx, d))\n+    .with_fixes(fixes(ctx, d));\n+    if diag.fixes.is_none() {\n+        diag.experimental = true;\n+    }\n+    diag\n }\n \n-fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::AddReferenceHere) -> Option<Vec<Assist>> {\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Option<Vec<Assist>> {\n+    let mut fixes = Vec::new();\n+\n+    add_reference(ctx, d, &mut fixes);\n+\n+    if fixes.is_empty() {\n+        None\n+    } else {\n+        Some(fixes)\n+    }\n+}\n+\n+fn add_reference(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch, acc: &mut Vec<Assist>) -> Option<()> {\n     let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let arg_expr = d.expr.value.to_node(&root);\n+    let expr_node = d.expr.value.to_node(&root);\n+\n+    let range = ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range;\n \n-    let arg_with_ref = format!(\"&{}{}\", d.mutability.as_keyword_for_ref(), arg_expr.syntax());\n+    let (_, mutability) = d.expected.as_reference()?;\n+    let actual_with_ref = Type::reference(&d.actual, mutability);\n+    if !actual_with_ref.could_coerce_to(ctx.sema.db, &d.expected) {\n+        return None;\n+    }\n+\n+    let ampersands = format!(\"&{}\", mutability.as_keyword_for_ref());\n \n-    let arg_range = arg_expr.syntax().text_range();\n-    let edit = TextEdit::replace(arg_range, arg_with_ref);\n+    let edit = TextEdit::insert(expr_node.syntax().text_range().start(), ampersands);\n     let source_change =\n         SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n-\n-    Some(vec![fix(\"add_reference_here\", \"Add reference here\", source_change, arg_range)])\n+    acc.push(fix(\"add_reference_here\", \"Add reference here\", source_change, range));\n+    Some(())\n }\n \n #[cfg(test)]\n@@ -44,7 +69,7 @@ mod tests {\n             r#\"\n fn main() {\n     test(123);\n-       //^^^ \ud83d\udca1 error: add reference here\n+       //^^^ \ud83d\udca1 error: expected &i32, found i32\n }\n fn test(arg: &i32) {}\n \"#,\n@@ -91,6 +116,7 @@ fn test(arg: &mut i32) {}\n     fn test_add_reference_to_array() {\n         check_fix(\n             r#\"\n+//- minicore: coerce_unsized\n fn main() {\n     test($0[1, 2, 3]);\n }\n@@ -105,6 +131,37 @@ fn test(arg: &[i32]) {}\n         );\n     }\n \n+    #[test]\n+    fn test_add_reference_with_autoderef() {\n+        check_fix(\n+            r#\"\n+//- minicore: coerce_unsized, deref\n+struct Foo;\n+struct Bar;\n+impl core::ops::Deref for Foo {\n+    type Target = Bar;\n+}\n+\n+fn main() {\n+    test($0Foo);\n+}\n+fn test(arg: &Bar) {}\n+            \"#,\n+            r#\"\n+struct Foo;\n+struct Bar;\n+impl core::ops::Deref for Foo {\n+    type Target = Bar;\n+}\n+\n+fn main() {\n+    test(&Foo);\n+}\n+fn test(arg: &Bar) {}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_add_reference_to_method_call() {\n         check_fix(", "previous_filename": "crates/ide_diagnostics/src/handlers/add_reference_here.rs"}, {"sha": "7ea8fcde2da4881504c5228fc9d45ac87b423a9a", "filename": "crates/ide_diagnostics/src/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Flib.rs?ref=ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "patch": "@@ -24,7 +24,7 @@\n //! don't yet have a great pattern for how to do them properly.\n \n mod handlers {\n-    pub(crate) mod add_reference_here;\n+    // pub(crate) mod add_reference_here;\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n@@ -34,17 +34,18 @@ mod handlers {\n     pub(crate) mod mismatched_arg_count;\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n-    pub(crate) mod missing_ok_or_some_in_tail_expr;\n+    // pub(crate) mod missing_ok_or_some_in_tail_expr;\n     pub(crate) mod missing_unsafe;\n     pub(crate) mod no_such_field;\n-    pub(crate) mod remove_this_semicolon;\n+    // pub(crate) mod remove_this_semicolon;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod unimplemented_builtin_macro;\n     pub(crate) mod unresolved_extern_crate;\n     pub(crate) mod unresolved_import;\n     pub(crate) mod unresolved_macro_call;\n     pub(crate) mod unresolved_module;\n     pub(crate) mod unresolved_proc_macro;\n+    pub(crate) mod type_mismatch;\n \n     // The handlers below are unusual, the implement the diagnostics as well.\n     pub(crate) mod field_shorthand;\n@@ -191,19 +192,17 @@ pub fn diagnostics(\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n-            AnyDiagnostic::AddReferenceHere(d) => handlers::add_reference_here::add_reference_here(&ctx, &d),\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n-            AnyDiagnostic::MissingOkOrSomeInTailExpr(d) => handlers::missing_ok_or_some_in_tail_expr::missing_ok_or_some_in_tail_expr(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n-            AnyDiagnostic::RemoveThisSemicolon(d) => handlers::remove_this_semicolon::remove_this_semicolon(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n+            AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => handlers::unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => handlers::unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n             AnyDiagnostic::UnresolvedImport(d) => handlers::unresolved_import::unresolved_import(&ctx, &d),"}]}