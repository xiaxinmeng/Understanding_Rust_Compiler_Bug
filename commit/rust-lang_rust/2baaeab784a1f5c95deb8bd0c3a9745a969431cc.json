{"sha": "2baaeab784a1f5c95deb8bd0c3a9745a969431cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYWFlYWI3ODRhMWY1Yzk1ZGViOGJkMGMzYTk3NDVhOTY5NDMxY2M=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-04T01:06:57Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-08-04T22:30:09Z"}, "message": "Implement the occurs check\n\nIn the writeback phase, the typechecker now checks that it isn't\nreplacing a type variable T with a type that contains T. It\nalso does an occurs check in do_autoderef in order to avoid\ngetting into an infinite chain of derefs.\n\nI'm a bit worried that there are more places where the occurs\ncheck needs to happen where I'm not doing it now, though.\n\nCloses #768", "tree": {"sha": "2737fd99c554bbd07d3acc94bb9bebbe700ea8e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2737fd99c554bbd07d3acc94bb9bebbe700ea8e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2baaeab784a1f5c95deb8bd0c3a9745a969431cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2baaeab784a1f5c95deb8bd0c3a9745a969431cc", "html_url": "https://github.com/rust-lang/rust/commit/2baaeab784a1f5c95deb8bd0c3a9745a969431cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7d4b4fc38aaeb153647e64564918467c92c9324", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d4b4fc38aaeb153647e64564918467c92c9324", "html_url": "https://github.com/rust-lang/rust/commit/d7d4b4fc38aaeb153647e64564918467c92c9324"}], "stats": {"total": 101, "additions": 87, "deletions": 14}, "files": [{"sha": "ba4910c361610987879163e1c708c41cd284918b", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2baaeab784a1f5c95deb8bd0c3a9745a969431cc", "patch": "@@ -184,6 +184,7 @@ export type_param;\n export unify;\n export variant_info;\n export walk_ty;\n+export occurs_check_fails;\n \n // Data types\n tag mode { mo_val; mo_alias(bool); }\n@@ -655,6 +656,7 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_str. {/* no-op */ }\n       ty_istr. {/* no-op */ }\n       ty_type. {/* no-op */ }\n+      ty_task. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_box(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_vec(tm) { walk_ty(cx, walker, tm.ty); }\n@@ -686,6 +688,9 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n         walk_ty(cx, walker, sub);\n         for tp: t  in tps { walk_ty(cx, walker, tp); }\n       }\n+      ty_constr(sub, _) {\n+        walk_ty(cx, walker, sub);\n+      }\n       ty_var(_) {/* no-op */ }\n       ty_param(_,_) {/* no-op */ }\n     }\n@@ -1393,6 +1398,24 @@ fn type_param(cx: &ctxt, ty: &t) -> option::t[uint] {\n     ret none;\n }\n \n+// Returns an ivec of all the type variables\n+// occurring in t. It may contain duplicates.\n+fn vars_in_type(cx:&ctxt, ty: &t) -> int[] {\n+    fn collect_var(cx:&ctxt, vars: &@mutable int[], ty: t) {\n+        alt struct(cx, ty) {\n+          ty_var(v) {\n+            *vars += ~[v];\n+          }\n+          _ {}\n+        }\n+    }\n+    let rslt: @mutable int[] = @mutable (~[]);\n+    walk_ty(cx, bind collect_var(cx, rslt, _), ty);\n+    // Works because of a \"convenient\" bug that lets us\n+    // return a mutable ivec as if it's immutable\n+    ret *rslt;\n+}\n+\n fn type_autoderef(cx: &ctxt, t: &ty::t) -> ty::t {\n     let t1: ty::t = t;\n     while true {\n@@ -1990,6 +2013,28 @@ fn is_lval(expr: &@ast::expr) -> bool {\n     }\n }\n \n+fn occurs_check_fails(tcx: &ctxt, sp: &option::t[span], vid: int, rt: &t)\n+    -> bool {\n+    // Occurs check!\n+    if ivec::member(vid, vars_in_type(tcx, rt)) {\n+        alt sp {\n+          some (s) {\n+            // Maybe this should be span_err -- however, there's an\n+            // assertion later on that the type doesn't contain\n+            // variables, so in this case we have to be sure to die.\n+            tcx.sess.span_fatal(s,\n+                                \"Type inference failed because I \\\n+               could not find a type\\n that's both of the form \" +\n+               ty_to_str(tcx, ty::mk_var(tcx, (vid)))\n+              + \" and of the form \" + ty_to_str(tcx, rt)\n+              + \". Such a type would have to be infinitely \\\n+               large.\");\n+          }\n+          _ { ret true; }\n+        }\n+    }\n+    else { ret false; }\n+}\n \n // Type unification via Robinson's algorithm (Robinson 1965). Implemented as\n // described in Hoder and Voronkov:\n@@ -2318,9 +2363,6 @@ mod unify {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n-        // TODO: occurs check, to make sure we don't loop forever when\n-        // unifying e.g. 'a and option['a]\n-\n         // Fast path.\n \n         if eq_ty(expected, actual) { ret ures_ok(expected); }\n@@ -2694,9 +2736,15 @@ mod unify {\n     }\n \n     // Fixups and substitutions\n-    fn fixup_vars(tcx: ty_ctxt, vb: @var_bindings, typ: t) -> fixup_result {\n-        fn subst_vars(tcx: ty_ctxt, vb: @var_bindings,\n+    //    Takes an optional span - complain about occurs check violations\n+    //    iff the span is present (so that if we already know we're going\n+    //    to error anyway, we don't complain)\n+    fn fixup_vars(tcx: ty_ctxt, sp: &option::t[span],\n+                  vb: @var_bindings, typ: t) -> fixup_result {\n+        fn subst_vars(tcx: ty_ctxt, sp: &option::t[span], vb: @var_bindings,\n                       unresolved: @mutable option::t[int], vid: int) -> t {\n+            // Should really return a fixup_result instead of a t, but fold_ty\n+            // doesn't allow returning anything but a t.\n             if vid as uint >= ufindivec::set_count(vb.sets) {\n                 *unresolved = some(vid);\n                 ret ty::mk_var(tcx, vid);\n@@ -2705,29 +2753,33 @@ mod unify {\n             alt smallintmap::find[t](vb.types, root_id) {\n               none. { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n               some(rt) {\n+                if occurs_check_fails(tcx, sp, vid, rt) {\n+                 // Return the type unchanged, so we can error out downstream\n+                    ret rt;\n+                }\n                 ret fold_ty(tcx,\n-                            fm_var(bind subst_vars(tcx, vb, unresolved, _)),\n-                            rt);\n+                  fm_var(bind subst_vars(tcx, sp, vb, unresolved, _)), rt);\n               }\n             }\n         }\n         let unresolved = @mutable none[int];\n         let rty =\n-            fold_ty(tcx, fm_var(bind subst_vars(tcx, vb, unresolved, _)),\n+            fold_ty(tcx, fm_var(bind subst_vars(tcx, sp, vb, unresolved, _)),\n                     typ);\n         let ur = *unresolved;\n         alt ur {\n           none. { ret fix_ok(rty); }\n           some(var_id) { ret fix_err(var_id); }\n         }\n     }\n-    fn resolve_type_var(tcx: &ty_ctxt, vb: &@var_bindings, vid: int) ->\n+    fn resolve_type_var(tcx: &ty_ctxt, sp: &option::t[span],\n+                        vb: &@var_bindings, vid: int) ->\n        fixup_result {\n         if vid as uint >= ufindivec::set_count(vb.sets) { ret fix_err(vid); }\n         let root_id = ufindivec::find(vb.sets, vid as uint);\n         alt smallintmap::find[t](vb.types, root_id) {\n           none. { ret fix_err(vid); }\n-          some(rt) { ret fixup_vars(tcx, vb, rt); }\n+          some(rt) { ret fixup_vars(tcx, sp, vb, rt); }\n         }\n     }\n }"}, {"sha": "e5a8f7eba8a4333d4a1d5c1865707196a837a22e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2baaeab784a1f5c95deb8bd0c3a9745a969431cc", "patch": "@@ -879,7 +879,18 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n     let t1 = t;\n     while true {\n         alt structure_of(fcx, sp, t1) {\n-          ty::ty_box(inner) { t1 = inner.ty; }\n+          ty::ty_box(inner) {\n+            alt ty::struct(fcx.ccx.tcx, t1) {\n+              ty::ty_var(v1) {\n+                if ty::occurs_check_fails(fcx.ccx.tcx, some(sp), v1,\n+                                          ty::mk_box(fcx.ccx.tcx, inner)) {\n+                    break;\n+                }\n+              }\n+              _ {}\n+            }\n+            t1 = inner.ty;\n+          }\n           ty::ty_res(_, inner, tps) {\n             t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n           }\n@@ -942,7 +953,7 @@ fn do_fn_block_coerce(fcx: &@fn_ctxt, sp: &span, actual: &ty::t,\n \n \n fn resolve_type_vars_if_possible(fcx: &@fn_ctxt, typ: ty::t) -> ty::t {\n-    alt ty::unify::fixup_vars(fcx.ccx.tcx, fcx.var_bindings, typ) {\n+    alt ty::unify::fixup_vars(fcx.ccx.tcx, none, fcx.var_bindings, typ) {\n       fix_ok(new_type) { ret new_type; }\n       fix_err(_) { ret typ; }\n     }\n@@ -1073,7 +1084,8 @@ mod writeback {\n     fn resolve_type_vars_in_type(fcx: &@fn_ctxt, sp: &span, typ: ty::t) ->\n        option::t[ty::t] {\n         if !ty::type_contains_vars(fcx.ccx.tcx, typ) { ret some(typ); }\n-        alt ty::unify::fixup_vars(fcx.ccx.tcx, fcx.var_bindings, typ) {\n+        alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp),\n+                                  fcx.var_bindings, typ) {\n           fix_ok(new_type) { ret some(new_type); }\n           fix_err(vid) {\n             fcx.ccx.tcx.sess.span_err(sp,\n@@ -1139,7 +1151,7 @@ mod writeback {\n         if !wbcx.success { ret; }\n         let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n         let fix_rslt =\n-            ty::unify::resolve_type_var(wbcx.fcx.ccx.tcx,\n+            ty::unify::resolve_type_var(wbcx.fcx.ccx.tcx, some(l.span),\n                                         wbcx.fcx.var_bindings, var_id);\n         alt fix_rslt {\n           fix_ok(lty) { write::ty_only(wbcx.fcx.ccx.tcx, l.node.id, lty); }"}, {"sha": "9b5536e57c36e46450ebbdd849154a7abff15708", "filename": "src/test/compile-fail/occurs-check-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs?ref=2baaeab784a1f5c95deb8bd0c3a9745a969431cc", "patch": "@@ -0,0 +1,5 @@\n+// error-pattern: Type inference failed because I could not find\n+fn main() {\n+    let f = @f;\n+    f();\n+}\n\\ No newline at end of file"}, {"sha": "a2bd12fcc354a80ae93935f445cd608f1d5f92ff", "filename": "src/test/compile-fail/occurs-check.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2baaeab784a1f5c95deb8bd0c3a9745a969431cc/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=2baaeab784a1f5c95deb8bd0c3a9745a969431cc", "patch": "@@ -0,0 +1,4 @@\n+// error-pattern: Type inference failed because I could not find\n+fn main() {\n+    let f = @f;\n+}"}]}