{"sha": "3038968f2895df915ca397864e96338edaa32e4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMzg5NjhmMjg5NWRmOTE1Y2EzOTc4NjRlOTYzMzhlZGFhMzJlNGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-15T22:53:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-15T23:20:35Z"}, "message": "rustc: Perform some AST surgery to separate out class fields from methods", "tree": {"sha": "f8bbc81702ce4683b0e9859efb4ca16346ab7c32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8bbc81702ce4683b0e9859efb4ca16346ab7c32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3038968f2895df915ca397864e96338edaa32e4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3038968f2895df915ca397864e96338edaa32e4b", "html_url": "https://github.com/rust-lang/rust/commit/3038968f2895df915ca397864e96338edaa32e4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3038968f2895df915ca397864e96338edaa32e4b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "353c632c2dce8eb990410f20e4991006f1fcb3eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/353c632c2dce8eb990410f20e4991006f1fcb3eb", "html_url": "https://github.com/rust-lang/rust/commit/353c632c2dce8eb990410f20e4991006f1fcb3eb"}], "stats": {"total": 609, "additions": 301, "deletions": 308}, "files": [{"sha": "cb46f6feabcd097c65165f15ff1d1bf69309574a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -717,10 +717,27 @@ type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n #[auto_serialize]\n enum visibility { public, private, inherited }\n \n+#[auto_serialize]\n+type struct_field_ = {\n+    kind: struct_field_kind,\n+    id: node_id,\n+    ty: @ty\n+};\n+\n+#[auto_serialize]\n+type struct_field = spanned<struct_field_>;\n+\n+#[auto_serialize]\n+enum struct_field_kind {\n+    named_field(ident, class_mutability, visibility),\n+    unnamed_field   // element of a tuple-like struct\n+}\n+\n #[auto_serialize]\n type struct_def = {\n-    traits: ~[@trait_ref],   /* traits this class implements */\n-    members: ~[@class_member], /* methods, etc. */\n+    traits: ~[@trait_ref],   /* traits this struct implements */\n+    fields: ~[@struct_field], /* fields */\n+    methods: ~[@method],    /* methods */\n     /* (not including ctor or dtor) */\n     /* ctor is optional, and will soon go away */\n     ctor: option<class_ctor>,\n@@ -750,15 +767,6 @@ enum item_ {\n     item_mac(mac),\n }\n \n-#[auto_serialize]\n-type class_member = spanned<class_member_>;\n-\n-#[auto_serialize]\n-enum class_member_ {\n-    instance_var(ident, @ty, class_mutability, node_id, visibility),\n-    class_method(@method)\n-}\n-\n #[auto_serialize]\n enum class_mutability { class_mutable, class_immutable }\n "}, {"sha": "c9b6b87942724eb95076603ad1d303a67606d24a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -248,7 +248,6 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n \n fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n                   ident: ast::ident, id: ast::node_id, cx: ctx, _v: vt) {\n-    let (_, ms) = ast_util::split_class_items(struct_def.members);\n     // Map trait refs to their parent classes. This is\n     // so we can find the self_ty\n     for struct_def.traits.each |p| {\n@@ -260,7 +259,7 @@ fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n     let d_id = ast_util::local_def(id);\n     let p = extend(cx, ident);\n      // only need to handle methods\n-    do vec::iter(ms) |m| { map_method(d_id, p, m, cx); }\n+    do vec::iter(struct_def.methods) |m| { map_method(d_id, p, m, cx); }\n }\n \n fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {"}, {"sha": "0495ea7cd34c586b8d5a13bc47d146e6f77746ba", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -295,16 +295,6 @@ pure fn unguarded_pat(a: arm) -> option<~[@pat]> {\n     if is_unguarded(a) { some(/* FIXME (#2543) */ copy a.pats) } else { none }\n }\n \n-pure fn class_item_ident(ci: @class_member) -> ident {\n-    match ci.node {\n-      instance_var(i,_,_,_,_) => /* FIXME (#2543) */ copy i,\n-      class_method(it) => /* FIXME (#2543) */ copy it.ident\n-    }\n-}\n-\n-type ivar = {ident: ident, ty: @ty, cm: class_mutability,\n-             id: node_id, vis: visibility};\n-\n fn public_methods(ms: ~[@method]) -> ~[@method] {\n     vec::filter(ms,\n                 |m| match m.vis {\n@@ -313,23 +303,6 @@ fn public_methods(ms: ~[@method]) -> ~[@method] {\n                 })\n }\n \n-fn split_class_items(cs: ~[@class_member]) -> (~[ivar], ~[@method]) {\n-    let mut vs = ~[], ms = ~[];\n-    for cs.each |c| {\n-      match c.node {\n-        instance_var(i, t, cm, id, vis) => {\n-          vec::push(vs, {ident: /* FIXME (#2543) */ copy i,\n-                         ty: t,\n-                         cm: cm,\n-                         id: id,\n-                         vis: vis});\n-        }\n-        class_method(m) => vec::push(ms, m)\n-      }\n-    };\n-    (vs, ms)\n-}\n-\n // extract a ty_method from a trait_method. if the trait_method is\n // a default, pull out the useful fields to make a ty_method\n fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n@@ -355,11 +328,11 @@ fn split_trait_methods(trait_methods: ~[trait_method])\n     (reqd, provd)\n }\n \n-pure fn class_member_visibility(ci: @class_member) -> visibility {\n-  match ci.node {\n-     instance_var(_, _, _, _, vis) => vis,\n-     class_method(m) => m.vis\n-  }\n+pure fn struct_field_visibility(field: ast::struct_field) -> visibility {\n+    match field.node.kind {\n+        ast::named_field(_, _, visibility) => visibility,\n+        ast::unnamed_field => ast::public\n+    }\n }\n \n trait inlined_item_utils {\n@@ -570,11 +543,11 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n                               _id: node_id) {\n         },\n \n-        visit_class_item: fn@(c: @class_member) {\n-            match c.node {\n-              instance_var(_, _, _, id,_) => vfn(id),\n-              class_method(_) => ()\n-            }\n+        visit_struct_field: fn@(f: @struct_field) {\n+            vfn(f.node.id);\n+        },\n+\n+        visit_struct_method: fn@(_m: @method) {\n         }\n     })\n }"}, {"sha": "705f21895b66a87a82d9dba63595c6cf8b80b6d1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -24,7 +24,7 @@ trait ast_fold {\n     fn fold_view_item(&&@view_item) -> @view_item;\n     fn fold_foreign_item(&&@foreign_item) -> @foreign_item;\n     fn fold_item(&&@item) -> option<@item>;\n-    fn fold_class_item(&&@class_member) -> @class_member;\n+    fn fold_struct_field(&&@struct_field) -> @struct_field;\n     fn fold_item_underscore(item_) -> item_;\n     fn fold_method(&&@method) -> @method;\n     fn fold_block(blk) -> blk;\n@@ -55,7 +55,7 @@ type ast_fold_precursor = @{\n     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n     fold_foreign_item: fn@(&&@foreign_item, ast_fold) -> @foreign_item,\n     fold_item: fn@(&&@item, ast_fold) -> option<@item>,\n-    fold_class_item: fn@(&&@class_member, ast_fold) -> @class_member,\n+    fold_struct_field: fn@(&&@struct_field, ast_fold) -> @struct_field,\n     fold_item_underscore: fn@(item_, ast_fold) -> item_,\n     fold_method: fn@(&&@method, ast_fold) -> @method,\n     fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n@@ -214,16 +214,12 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> option<@item> {\n                span: fld.new_span(i.span)});\n }\n \n-fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n-    -> @class_member {\n-    @{node: match ci.node {\n-        instance_var(ident, t, cm, id, p) => {\n-           instance_var(/* FIXME (#2543) */ copy ident,\n-                        fld.fold_ty(t), cm, id, p)\n-        }\n-        class_method(m) => class_method(fld.fold_method(m))\n-      },\n-      span: ci.span}\n+fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n+                       -> @struct_field {\n+    @{node: {kind: copy sf.node.kind,\n+             id: sf.node.id,\n+             ty: fld.fold_ty(sf.node.ty)},\n+      span: sf.span}\n }\n \n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n@@ -295,7 +291,8 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n             with dtor}};\n     return @{\n         traits: vec::map(struct_def.traits, |p| fold_trait_ref(p, fld)),\n-        members: vec::map(struct_def.members, |x| fld.fold_class_item(x)),\n+        fields: vec::map(struct_def.fields, |f| fold_struct_field(f, fld)),\n+        methods: vec::map(struct_def.methods, |m| fld.fold_method(m)),\n         ctor: resulting_optional_constructor,\n         dtor: dtor\n     };\n@@ -306,6 +303,13 @@ fn fold_trait_ref(&&p: @trait_ref, fld: ast_fold) -> @trait_ref {\n      impl_id: fld.new_id(p.impl_id)}\n }\n \n+fn fold_struct_field(&&f: @struct_field, fld: ast_fold) -> @struct_field {\n+    @{node: {kind: copy f.node.kind,\n+             id: fld.new_id(f.node.id),\n+             ty: fld.fold_ty(f.node.ty)},\n+      span: fld.new_span(f.span)}\n+}\n+\n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     return @{ident: fld.fold_ident(m.ident),\n           attrs: /* FIXME (#2543) */ copy m.attrs,\n@@ -570,8 +574,9 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                     with dtor}};\n             kind = struct_variant_kind(@{\n                 traits: ~[],\n-                members: vec::map(struct_def.members,\n-                                  |x| fld.fold_class_item(x)),\n+                fields: vec::map(struct_def.fields,\n+                                 |f| fld.fold_struct_field(f)),\n+                methods: vec::map(struct_def.methods, |m| fld.fold_method(m)),\n                 ctor: none,\n                 dtor: dtor\n             })\n@@ -644,7 +649,7 @@ fn default_ast_fold() -> ast_fold_precursor {\n           fold_view_item: noop_fold_view_item,\n           fold_foreign_item: noop_fold_foreign_item,\n           fold_item: noop_fold_item,\n-          fold_class_item: noop_fold_class_item,\n+          fold_struct_field: noop_fold_struct_field,\n           fold_item_underscore: noop_fold_item_underscore,\n           fold_method: noop_fold_method,\n           fold_block: wrap(noop_fold_block),\n@@ -692,16 +697,11 @@ impl ast_fold_precursor: ast_fold {\n     fn fold_item(&&i: @item) -> option<@item> {\n         return self.fold_item(i, self as ast_fold);\n     }\n-    fn fold_class_item(&&ci: @class_member) -> @class_member {\n-        @{node: match ci.node {\n-           instance_var(nm, t, mt, id, p) => {\n-               instance_var(/* FIXME (#2543) */ copy nm,\n-                            (self as ast_fold).fold_ty(t), mt, id, p)\n-           }\n-           class_method(m) => {\n-               class_method(self.fold_method(m, self as ast_fold))\n-           }\n-          }, span: self.new_span(ci.span)}\n+    fn fold_struct_field(&&sf: @struct_field) -> @struct_field {\n+        @{node: {kind: copy sf.node.kind,\n+                 id: sf.node.id,\n+                 ty: (self as ast_fold).fold_ty(sf.node.ty)},\n+          span: self.new_span(sf.span)}\n     }\n     fn fold_item_underscore(i: item_) ->\n        item_ {"}, {"sha": "09930bc2553b9326a7c4af0a8d8889d1400330d0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -21,7 +21,7 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              bound_copy, bound_send, bound_trait, bound_owned, box, by_copy,\n              by_move, by_mutbl_ref, by_ref, by_val, capture_clause,\n              capture_item, cdir_dir_mod, cdir_src_mod, cdir_view_item,\n-             class_immutable, class_member, class_method, class_mutable,\n+             class_immutable, class_mutable,\n              crate, crate_cfg, crate_directive, decl, decl_item, decl_local,\n              default_blk, deref, div, enum_def, enum_variant_kind, expl, expr,\n              expr_, expr_addr_of, expr_match, expr_again, expr_assert,\n@@ -33,20 +33,21 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              expr_struct, expr_tup, expr_unary, expr_unary_move, expr_vec,\n              expr_vstore, expr_while, extern_fn, field, fn_decl, foreign_item,\n              foreign_item_fn, foreign_mod, ident, impure_fn, infer, inherited,\n-             init_assign, init_move, initializer, instance_var, item, item_,\n+             init_assign, init_move, initializer, item, item_,\n              item_class, item_const, item_enum, item_fn, item_foreign_mod,\n              item_impl, item_mac, item_mod, item_trait, item_ty, lit, lit_,\n              lit_bool, lit_float, lit_int, lit_int_unsuffixed, lit_nil,\n              lit_str, lit_uint, local, m_const, m_imm, m_mutbl, mac_, mac_aq,\n              mac_ellipsis, mac_invoc, mac_invoc_tt, mac_var, matcher,\n              match_nonterminal, match_seq, match_tok, method, mode, mt, mul,\n-             mutability, neg, noreturn, not, pat, pat_box, pat_enum,\n+             mutability, named_field, neg, noreturn, not, pat, pat_box, pat_enum,\n              pat_ident, pat_lit, pat_range, pat_rec, pat_struct, pat_tup,\n              pat_uniq, pat_wild, path, private, proto, proto_bare,\n              proto_block, proto_box, proto_uniq, provided, public, pure_fn,\n              purity, re_anon, re_named, region, rem, required, ret_style,\n              return_val, self_ty, shl, shr, stmt, stmt_decl, stmt_expr,\n-             stmt_semi, struct_def, struct_variant_kind, subtract, sty_box,\n+             stmt_semi, struct_def, struct_field, struct_variant_kind,\n+             subtract, sty_box,\n              sty_by_ref, sty_region, sty_static, sty_uniq, sty_value,\n              token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok,\n              tt_nonterminal, ty, ty_, ty_bot, ty_box, ty_field, ty_fn,\n@@ -94,6 +95,11 @@ enum pexpr {\n     pexpr(@expr),\n }\n \n+enum class_member {\n+    field_member(@struct_field),\n+    method_member(@method)\n+}\n+\n /*\n   So that we can distinguish a class ctor or dtor\n   from other class members\n@@ -2043,8 +2049,11 @@ class parser {\n         let name = self.parse_ident();\n         self.expect(token::COLON);\n         let ty = self.parse_ty(false);\n-        return @{node: instance_var(name, ty, is_mutbl, self.get_id(), pr),\n-              span: mk_sp(lo, self.last_span.hi)};\n+        return @field_member(@spanned(lo, self.last_span.hi, {\n+            kind: named_field(name, is_mutbl, pr),\n+            id: self.get_id(),\n+            ty: ty\n+        }));\n     }\n \n     fn parse_stmt(+first_item_attrs: ~[attribute]) -> @stmt {\n@@ -2556,7 +2565,8 @@ class parser {\n             { self.parse_trait_ref_list(token::LBRACE) }\n         else { ~[] };\n         self.expect(token::LBRACE);\n-        let mut ms: ~[@class_member] = ~[];\n+        let mut fields: ~[@struct_field] = ~[];\n+        let mut methods: ~[@method] = ~[];\n         let ctor_id = self.get_id();\n         let mut the_ctor : option<(fn_decl, ~[attribute], blk,\n                                    codemap::span)> = none;\n@@ -2589,7 +2599,16 @@ class parser {\n                     }\n                   }\n               }\n-              members(mms) => { ms = vec::append(ms, mms); }\n+              members(mms) => {\n+                for mms.each |mm| {\n+                    match mm {\n+                        @field_member(struct_field) =>\n+                            vec::push(fields, struct_field),\n+                        @method_member(the_method_member) =>\n+                            vec::push(methods, the_method_member)\n+                    }\n+                }\n+              }\n             }\n         }\n         let actual_dtor = do option::map(the_dtor) |dtor| {\n@@ -2605,7 +2624,8 @@ class parser {\n             (class_name,\n              item_class(@{\n                 traits: traits,\n-                members: ms,\n+                fields: move fields,\n+                methods: move methods,\n                 ctor: some({\n                  node: {id: ctor_id,\n                         attrs: ct_attrs,\n@@ -2621,7 +2641,8 @@ class parser {\n             (class_name,\n              item_class(@{\n                     traits: traits,\n-                    members: ms,\n+                    fields: move fields,\n+                    methods: move methods,\n                     ctor: none,\n                     dtor: actual_dtor\n              }, ty_params),\n@@ -2647,7 +2668,7 @@ class parser {\n             return a_var;\n         } else {\n             let m = self.parse_method(vis);\n-            return @{node: class_method(m), span: m.span};\n+            return @method_member(m);\n         }\n     }\n \n@@ -2883,7 +2904,8 @@ class parser {\n \n     fn parse_struct_def(path: @path) -> @struct_def {\n         let mut the_dtor: option<(blk, ~[attribute], codemap::span)> = none;\n-        let mut ms: ~[@class_member] = ~[];\n+        let mut fields: ~[@struct_field] = ~[];\n+        let mut methods: ~[@method] = ~[];\n         while self.token != token::RBRACE {\n             match self.parse_class_item(path) {\n                 ctor_decl(*) => {\n@@ -2906,8 +2928,16 @@ class parser {\n                         }\n                     }\n                 }\n-                members(mms) =>\n-                    ms = vec::append(ms, mms)\n+                members(mms) => {\n+                    for mms.each |mm| {\n+                        match mm {\n+                            @field_member(struct_field) =>\n+                                vec::push(fields, struct_field),\n+                            @method_member(the_method_member) =>\n+                                vec::push(methods, the_method_member)\n+                        }\n+                    }\n+                }\n             }\n         }\n         self.bump();\n@@ -2922,7 +2952,8 @@ class parser {\n \n         return @{\n             traits: ~[],\n-            members: ms,\n+            fields: move fields,\n+            methods: move methods,\n             ctor: none,\n             dtor: actual_dtor\n         };"}, {"sha": "edcdd7d2baf1e34ae864d3cbd9a072e73f0769dd", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 39, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -629,45 +629,29 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n       head(s, ~\"drop\");\n       print_block(s, dtor.node.body);\n     }\n-    for struct_def.members.each |ci| {\n-            /*\n-               FIXME (#1893): collect all private items and print\n-               them in a single \"priv\" section\n-\n-               tjc: I'm not going to fix this yet b/c we might\n-               change how exports work, including for class items\n-             */\n-       hardbreak_if_not_bol(s);\n-       maybe_print_comment(s, ci.span.lo);\n-       let pr = ast_util::class_member_visibility(ci);\n-       match pr {\n-          ast::private => {\n-              head(s, ~\"priv\");\n-              bopen(s);\n-              hardbreak_if_not_bol(s);\n-          }\n-          _ => ()\n-       }\n-       match ci.node {\n-          ast::instance_var(nm, t, mt, _,_) => {\n-              word_nbsp(s, ~\"let\");\n-              match mt {\n-                ast::class_mutable => word_nbsp(s, ~\"mut\"),\n-                _ => ()\n-              }\n-              word(s.s, *nm);\n-              word_nbsp(s, ~\":\");\n-              print_type(s, t);\n-              word(s.s, ~\";\");\n-          }\n-          ast::class_method(m) => {\n-              print_method(s, m);\n-          }\n-       }\n-       match pr {\n-           ast::private => bclose(s, ci.span),\n-           _ => ()\n-       }\n+    for struct_def.fields.each |field| {\n+        match field.node.kind {\n+            ast::unnamed_field => {} // We don't print here.\n+            ast::named_field(ident, mutability, visibility) => {\n+                hardbreak_if_not_bol(s);\n+                maybe_print_comment(s, field.span.lo);\n+                if visibility == ast::private {\n+                    head(s, ~\"priv\");\n+                    bopen(s);\n+                    hardbreak_if_not_bol(s);\n+                }\n+                if mutability == ast::class_mutable {\n+                    word_nbsp(s, ~\"mut\");\n+                }\n+                word(s.s, *ident);\n+                word_nbsp(s, ~\":\");\n+                print_type(s, field.node.ty);\n+                word(s.s, ~\";\");\n+            }\n+        }\n+    }\n+    for struct_def.methods.each |method| {\n+        print_method(s, method);\n     }\n     bclose(s, span);\n }"}, {"sha": "f9d861f15e1ee5f1cd967e74d03ebd86dac2a1b7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -63,7 +63,8 @@ type visitor<E> =\n       visit_trait_method: fn@(trait_method, E, vt<E>),\n       visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id, E,\n                             vt<E>),\n-      visit_class_item: fn@(@class_member, E, vt<E>)};\n+      visit_struct_field: fn@(@struct_field, E, vt<E>),\n+      visit_struct_method: fn@(@method, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n     return @{visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n@@ -85,7 +86,8 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_trait_method: |a,b,c|visit_trait_method::<E>(a, b, c),\n           visit_struct_def: |a,b,c,d,e,f|visit_struct_def::<E>(a, b, c,\n                                                                d, e, f),\n-          visit_class_item: |a,b,c|visit_class_item::<E>(a, b, c)};\n+          visit_struct_field: |a,b,c|visit_struct_field::<E>(a, b, c),\n+          visit_struct_method: |a,b,c|visit_struct_method::<E>(a, b, c)};\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n@@ -183,13 +185,6 @@ fn visit_enum_def<E>(enum_definition: ast::enum_def, tps: ~[ast::ty_param],\n     }\n }\n \n-fn visit_class_item<E>(cm: @class_member, e:E, v:vt<E>) {\n-    match cm.node {\n-      instance_var(_, t, _, _, _) => v.visit_ty(t, e, v),\n-      class_method(m) => visit_method_helper(m, e, v)\n-    }\n-}\n-\n fn skip_ty<E>(_t: @ty, _e: E, _v: vt<E>) {}\n \n fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n@@ -332,8 +327,11 @@ fn visit_trait_method<E>(m: trait_method, e: E, v: vt<E>) {\n \n fn visit_struct_def<E>(sd: @struct_def, nm: ast::ident, tps: ~[ty_param],\n                        id: node_id, e: E, v: vt<E>) {\n-    for sd.members.each |m| {\n-       v.visit_class_item(m, e, v);\n+    for sd.fields.each |f| {\n+        v.visit_struct_field(f, e, v);\n+    }\n+    for sd.methods.each |m| {\n+        v.visit_struct_method(m, e, v);\n     }\n     for sd.traits.each |p| { visit_path(p.path, e, v); }\n     do option::iter(sd.ctor) |ctor| {\n@@ -344,6 +342,14 @@ fn visit_struct_def<E>(sd: @struct_def, nm: ast::ident, tps: ~[ty_param],\n     };\n }\n \n+fn visit_struct_field<E>(sf: @struct_field, e: E, v: vt<E>) {\n+    v.visit_ty(sf.node.ty, e, v);\n+}\n+\n+fn visit_struct_method<E>(m: @method, e: E, v: vt<E>) {\n+    visit_method_helper(m, e, v);\n+}\n+\n fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n     for b.node.view_items.each |vi| { v.visit_view_item(vi, e, v); }\n     for b.node.stmts.each |s| { v.visit_stmt(s, e, v); }\n@@ -492,7 +498,8 @@ type simple_visitor =\n       visit_ty_method: fn@(ty_method),\n       visit_trait_method: fn@(trait_method),\n       visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id),\n-      visit_class_item: fn@(@class_member)};\n+      visit_struct_field: fn@(@struct_field),\n+      visit_struct_method: fn@(@method)};\n \n fn simple_ignore_ty(_t: @ty) {}\n \n@@ -517,7 +524,8 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_trait_method: fn@(_m: trait_method) { },\n           visit_struct_def: fn@(_sd: @struct_def, _nm: ident,\n                                 _tps: ~[ty_param], _id: node_id) { },\n-          visit_class_item: fn@(_c: @class_member) {}\n+          visit_struct_field: fn@(_f: @struct_field) { },\n+          visit_struct_method: fn@(_m: @method) { }\n          };\n }\n \n@@ -607,11 +615,14 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     } else {\n         |a,b,c| v_ty(v.visit_ty, a, b, c)\n     };\n-    fn v_class_item(f: fn@(@class_member),\n-                    cm: @class_member, &&e: (),\n-                    v: vt<()>) {\n-        f(cm);\n-        visit_class_item(cm, e, v);\n+    fn v_struct_field(f: fn@(@struct_field), sf: @struct_field, &&e: (),\n+                      v: vt<()>) {\n+        f(sf);\n+        visit_struct_field(sf, e, v);\n+    }\n+    fn v_struct_method(f: fn@(@method), m: @method, &&e: (), v: vt<()>) {\n+        f(m);\n+        visit_struct_method(m, e, v);\n     }\n     return mk_vt(@{visit_mod: |a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e),\n                 visit_view_item: |a,b,c|\n@@ -639,8 +650,10 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                     v_trait_method(v.visit_trait_method, a, b, c),\n                 visit_struct_def: |a,b,c,d,e,f|\n                     v_struct_def(v.visit_struct_def, a, b, c, d, e, f),\n-                visit_class_item: |a,b,c|\n-                    v_class_item(v.visit_class_item, a, b, c)\n+                visit_struct_field: |a,b,c|\n+                    v_struct_field(v.visit_struct_field, a, b, c),\n+                visit_struct_method: |a,b,c|\n+                    v_struct_method(v.visit_struct_method, a, b, c)\n                });\n }\n "}, {"sha": "6678b6e036aed983537c84ca9cb9cc0595440d24", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -745,11 +745,12 @@ fn get_class_fields(cdata: cmd, id: ast::node_id) -> ~[ty::field_ty] {\n }\n \n fn family_has_type_params(fam_ch: char) -> bool {\n-    match check fam_ch {\n-      'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' | 'e' => false,\n+    match fam_ch {\n+      'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' | 'e' | 'N' => false,\n       'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' | 'C'\n           | 'a' | 'S'\n-          => true\n+          => true,\n+      _ => fail fmt!(\"'%c' is not a family\", fam_ch)\n     }\n }\n "}, {"sha": "968f051710bd9c1a41ee5ec43c1f18649df0f1b4", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 64, "deletions": 44, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -158,19 +158,27 @@ fn encode_foreign_module_item_paths(ebml_w: ebml::writer, nmod: foreign_mod,\n }\n \n fn encode_class_item_paths(ebml_w: ebml::writer,\n-     items: ~[@class_member], path: ~[ident], &index: ~[entry<~str>]) {\n-    for items.each |it| {\n-     match ast_util::class_member_visibility(it) {\n-          private => again,\n-          public | inherited => {\n-              let (id, ident) = match it.node {\n-                 instance_var(v, _, _, vid, _) => (vid, v),\n-                 class_method(it) => (it.id, it.ident)\n-              };\n-              add_to_index(ebml_w, path, index, ident);\n-              encode_named_def_id(ebml_w, ident, local_def(id));\n-          }\n-       }\n+                           fields: ~[@ast::struct_field],\n+                           methods: ~[@ast::method],\n+                           path: ~[ident],\n+                           &index: ~[entry<~str>]) {\n+    for fields.each |field| {\n+        match field.node.kind {\n+            ast::named_field(ident, _, visibility) => {\n+                if visibility == private { again; }\n+                let (id, ident) = (field.node.id, ident);\n+                add_to_index(ebml_w, path, index, ident);\n+                encode_named_def_id(ebml_w, ident, local_def(id));\n+            }\n+            ast::unnamed_field => {}\n+        }\n+    }\n+\n+    for methods.each |method| {\n+        if method.vis == private { again; }\n+        let (id, ident) = (method.id, method.ident);\n+        add_to_index(ebml_w, path, index, ident);\n+        encode_named_def_id(ebml_w, ident, local_def(id));\n     }\n }\n \n@@ -257,7 +265,8 @@ fn encode_struct_def(ebml_w: ebml::writer,\n     }\n \n     encode_class_item_paths(ebml_w,\n-                            struct_def.members,\n+                            struct_def.fields,\n+                            struct_def.methods,\n                             vec::append_one(path, ident),\n                             index);\n }\n@@ -527,32 +536,38 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          id: node_id, path: ast_map::path,\n                          class_tps: ~[ty_param],\n-                         items: ~[@class_member],\n+                         fields: ~[@struct_field],\n+                         methods: ~[@method],\n                          global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let index = @mut ~[];\n     let tcx = ecx.tcx;\n-    for items.each |ci| {\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-      match ci.node {\n-        instance_var(nm, _, mt, id, vis) => {\n-          vec::push(*index, {val: id, pos: ebml_w.writer.tell()});\n-          vec::push(*global_index, {val: id, pos: ebml_w.writer.tell()});\n-          ebml_w.start_tag(tag_items_data_item);\n-          debug!{\"encode_info_for_class: doing %s %d\", *nm, id};\n-          encode_visibility(ebml_w, vis);\n-          encode_name(ebml_w, nm);\n-          encode_path(ebml_w, path, ast_map::path_name(nm));\n-          encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n-          encode_mutability(ebml_w, mt);\n-          encode_def_id(ebml_w, local_def(id));\n-          ebml_w.end_tag();\n+    for fields.each |field| {\n+        match field.node.kind {\n+            named_field(nm, mt, vis) => {\n+                let id = field.node.id;\n+                vec::push(*index, {val: id, pos: ebml_w.writer.tell()});\n+                vec::push(*global_index, {val: id, pos: ebml_w.writer.tell()});\n+                ebml_w.start_tag(tag_items_data_item);\n+                debug!{\"encode_info_for_class: doing %s %d\", *nm, id};\n+                encode_visibility(ebml_w, vis);\n+                encode_name(ebml_w, nm);\n+                encode_path(ebml_w, path, ast_map::path_name(nm));\n+                encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n+                encode_mutability(ebml_w, mt);\n+                encode_def_id(ebml_w, local_def(id));\n+                ebml_w.end_tag();\n+            }\n+            unnamed_field => {}\n         }\n-        class_method(m) => {\n-           match m.vis {\n-              public | inherited => {\n+    }\n+\n+    for methods.each |m| {\n+        match m.vis {\n+            public | inherited => {\n                 vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n                 vec::push(*global_index,\n                           {val: m.id, pos: ebml_w.writer.tell()});\n@@ -564,10 +579,9 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                        vec::append(class_tps, m.tps));\n             }\n             _ => { /* don't encode private methods */ }\n-          }\n         }\n-      }\n-    };\n+    }\n+\n     *index\n }\n \n@@ -738,7 +752,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n            the index, and the index needs to be in the item for the\n            class itself */\n         let idx = encode_info_for_class(ecx, ebml_w, item.id, path, tps,\n-                                        struct_def.members, index);\n+                                        struct_def.fields, struct_def.methods,\n+                                        index);\n         /* Encode the dtor */\n         do option::iter(struct_def.dtor) |dtor| {\n             vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n@@ -779,15 +794,20 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        let (fs,ms) = ast_util::split_class_items(struct_def.members);\n-        for fs.each |f| {\n-           ebml_w.start_tag(tag_item_field);\n-           encode_visibility(ebml_w, f.vis);\n-           encode_name(ebml_w, f.ident);\n-           encode_def_id(ebml_w, local_def(f.id));\n-           ebml_w.end_tag();\n+        for struct_def.fields.each |f| {\n+            match f.node.kind {\n+                named_field(ident, mutability, vis) => {\n+                   ebml_w.start_tag(tag_item_field);\n+                   encode_visibility(ebml_w, vis);\n+                   encode_name(ebml_w, ident);\n+                   encode_def_id(ebml_w, local_def(f.node.id));\n+                   ebml_w.end_tag();\n+                }\n+                unnamed_field => {}\n+            }\n         }\n-        for ms.each |m| {\n+\n+        for struct_def.methods.each |m| {\n            match m.vis {\n               private => { /* do nothing */ }\n               public | inherited => {"}, {"sha": "9eef85600fc1d52f68603d43e132b0002649c2ae", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -12,7 +12,7 @@ import syntax::ast::{bitand, bitor, bitxor};\n import syntax::ast::{blk, bound_const, bound_copy, bound_owned, bound_send};\n import syntax::ast::{bound_trait, binding_mode,\n                      capture_clause, class_ctor, class_dtor};\n-import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n+import syntax::ast::{crate, crate_num, decl_item};\n import syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n import syntax::ast::{def_foreign_mod, def_id, def_label, def_local, def_mod};\n import syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n@@ -27,15 +27,15 @@ import syntax::ast::{expr_binary, expr_break, expr_cast, expr_field, expr_fn};\n import syntax::ast::{expr_fn_block, expr_index, expr_loop};\n import syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n import syntax::ast::{foreign_item, foreign_item_fn, ge, gt, ident, trait_ref};\n-import syntax::ast::{impure_fn, instance_var, item, item_class, item_const};\n+import syntax::ast::{impure_fn, item, item_class, item_const};\n import syntax::ast::{item_enum, item_fn, item_mac, item_foreign_mod};\n import syntax::ast::{item_impl, item_mod, item_trait, item_ty, le, local};\n import syntax::ast::{local_crate, lt, method, mul, ne, neg, node_id, pat};\n import syntax::ast::{pat_enum, pat_ident, path, prim_ty, pat_box, pat_uniq};\n import syntax::ast::{pat_lit, pat_range, pat_rec, pat_struct, pat_tup};\n import syntax::ast::{pat_wild, provided, required, rem, self_ty_, shl};\n-import syntax::ast::{stmt_decl, struct_variant_kind, sty_static, subtract};\n-import syntax::ast::{tuple_variant_kind, ty};\n+import syntax::ast::{stmt_decl, struct_field, struct_variant_kind};\n+import syntax::ast::{sty_static, subtract, tuple_variant_kind, ty};\n import syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n import syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, ty_param};\n import syntax::ast::{ty_path, ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8};\n@@ -1021,23 +1021,16 @@ class Resolver {\n                 // bindings.\n \n                 let mut method_infos = ~[];\n-                for struct_definition.members.each |class_member| {\n-                    match class_member.node {\n-                        class_method(method) => {\n-                            // XXX: Combine with impl method code below.\n-                            method_infos += ~[\n-                                @{\n-                                    did: local_def(method.id),\n-                                    n_tps: method.tps.len(),\n-                                    ident: method.ident,\n-                                    self_type: method.self_ty.node\n-                                }\n-                            ];\n-                        }\n-                        instance_var(*) => {\n-                            // Don't need to do anything with this.\n+                for struct_definition.methods.each |method| {\n+                    // XXX: Combine with impl method code below.\n+                    method_infos += ~[\n+                        @{\n+                            did: local_def(method.id),\n+                            n_tps: method.tps.len(),\n+                            ident: method.ident,\n+                            self_type: method.self_ty.node\n                         }\n-                    }\n+                    ];\n                 }\n \n                 let impl_info = @{\n@@ -3195,7 +3188,8 @@ class Resolver {\n                 self.resolve_class(item.id,\n                                    @copy ty_params,\n                                    struct_def.traits,\n-                                   struct_def.members,\n+                                   struct_def.fields,\n+                                   struct_def.methods,\n                                    struct_def.ctor,\n                                    struct_def.dtor,\n                                    visitor);\n@@ -3435,7 +3429,8 @@ class Resolver {\n     fn resolve_class(id: node_id,\n                      type_parameters: @~[ty_param],\n                      traits: ~[@trait_ref],\n-                     class_members: ~[@class_member],\n+                     fields: ~[@struct_field],\n+                     methods: ~[@method],\n                      optional_constructor: option<class_ctor>,\n                      optional_destructor: option<class_dtor>,\n                      visitor: ResolveVisitor) {\n@@ -3479,19 +3474,16 @@ class Resolver {\n             }\n \n             // Resolve methods.\n-            for class_members.each |class_member| {\n-                match class_member.node {\n-                    class_method(method) => {\n-                      self.resolve_method(MethodRibKind(id,\n-                                               Provided(method.id)),\n-                                          method,\n-                                          outer_type_parameter_count,\n-                                          visitor);\n-                    }\n-                    instance_var(_, field_type, _, _, _) => {\n-                        self.resolve_type(field_type, visitor);\n-                    }\n-                }\n+            for methods.each |method| {\n+                self.resolve_method(MethodRibKind(id, Provided(method.id)),\n+                                    method,\n+                                    outer_type_parameter_count,\n+                                    visitor);\n+            }\n+\n+            // Resolve fields.\n+            for fields.each |field| {\n+                self.resolve_type(field.node.ty, visitor);\n             }\n \n             // Resolve the constructor, if applicable."}, {"sha": "3195768a1052f0f8459a8d37e59a87ebe732c97e", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -5062,8 +5062,7 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     // If there are ty params, the ctor will get monomorphized\n \n     // Translate methods\n-    let (_, ms) = ast_util::split_class_items(struct_def.members);\n-    impl::trans_impl(ccx, *path, ident, ms, tps);\n+    impl::trans_impl(ccx, *path, ident, struct_def.methods, tps);\n }\n \n fn trans_trait(ccx: @crate_ctxt, tps: ~[ast::ty_param],"}, {"sha": "1d7771b57d53563fce794c56b51a2ad1c3dc3759", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -7,7 +7,7 @@ import driver::session::session;\n import syntax::{ast, ast_map};\n import ast_map::{path, path_mod, path_name, node_id_to_str};\n import driver::session::expect;\n-import syntax::ast_util::{local_def, split_class_items};\n+import syntax::ast_util::local_def;\n import metadata::csearch;\n import back::{link, abi};\n import lib::llvm::llvm;\n@@ -163,8 +163,7 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n           }\n           ast_map::node_item(@{node:\n               ast::item_class(struct_def, _), _}, _) => {\n-            let (_,ms) = split_class_items(struct_def.members);\n-            method_from_methods(ms, name)\n+            method_from_methods(struct_def.methods, name)\n           }\n         }\n     } else {"}, {"sha": "62107e76bdbb7bc90e01aa84722f969ecab462e6", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -126,16 +126,11 @@ fn traverse_public_item(cx: ctx, item: @item) {\n                 traverse_inline_body(cx, dtor.node.body);\n             }\n         }\n-        for vec::each(struct_def.members) |item| {\n-            match item.node {\n-              class_method(m) => {\n-                cx.rmap.insert(m.id, ());\n-                if tps.len() > 0u ||\n-                   attr::find_inline_attr(m.attrs) != attr::ia_none {\n-                    traverse_inline_body(cx, m.body);\n-                }\n-              }\n-              _ => ()\n+        for vec::each(struct_def.methods) |m| {\n+            cx.rmap.insert(m.id, ());\n+            if tps.len() > 0 ||\n+                    attr::find_inline_attr(m.attrs) != attr::ia_none {\n+                traverse_inline_body(cx, m.body);\n             }\n         }\n       }"}, {"sha": "8936e203e0d9871de89da993a328c6c856c6bd88", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -8,8 +8,7 @@ import driver::session;\n import session::session;\n import syntax::{ast, ast_map};\n import syntax::ast_util;\n-import syntax::ast_util::{is_local, local_def, split_class_items,\n-                          new_def_hash};\n+import syntax::ast_util::{is_local, local_def, new_def_hash};\n import syntax::codemap::span;\n import metadata::csearch;\n import util::ppaux::{region_to_str, explain_region, vstore_to_str};\n@@ -3006,10 +3005,10 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n     match cx.items.find(did.node) {\n        some(ast_map::node_item(i,_)) => {\n          match i.node {\n-                 ast::item_class(struct_def, _) => {\n-               class_field_tys(struct_def.members)\n-           }\n-           _ => cx.sess.bug(~\"class ID bound to non-class\")\n+            ast::item_class(struct_def, _) => {\n+               class_field_tys(struct_def.fields)\n+            }\n+            _ => cx.sess.bug(~\"class ID bound to non-class\")\n          }\n        }\n        _ => {\n@@ -3062,9 +3061,9 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n           some(ast_map::node_item(@{\n             node: item_class(struct_def, _), _\n           }, _)) => {\n-            let (_,ms) = split_class_items(struct_def.members);\n-            vec::map(ms, |m| {name: m.ident, id: m.id,\n-                              vis: m.vis})\n+            vec::map(struct_def.methods, |m| {name: m.ident,\n+                                              id: m.id,\n+                                              vis: m.vis})\n           }\n           _ => {\n             cx.sess.bug(~\"lookup_class_method_ids: id not bound to a class\");\n@@ -3087,15 +3086,17 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n     }\n }\n \n-fn class_field_tys(items: ~[@class_member]) -> ~[field_ty] {\n+fn class_field_tys(fields: ~[@struct_field]) -> ~[field_ty] {\n     let mut rslt = ~[];\n-    for items.each |it| {\n-       match it.node {\n-          instance_var(nm, _, cm, id, vis) => {\n-              vec::push(rslt, {ident: nm, id: ast_util::local_def(id),\n-                        vis: vis, mutability: cm});\n-          }\n-          class_method(_) => ()\n+    for fields.each |field| {\n+        match field.node.kind {\n+            named_field(ident, mutability, visibility) => {\n+                vec::push(rslt, {ident: ident,\n+                                 id: ast_util::local_def(field.node.id),\n+                                 vis: visibility,\n+                                 mutability: mutability});\n+            }\n+            unnamed_field => {}\n        }\n     }\n     rslt"}, {"sha": "2d2bf15c5a23fe4b1963f9770cc991a314fa2520", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -43,8 +43,7 @@ import syntax::{ast, ast_util, ast_map};\n import ast::spanned;\n import ast::{required, provided};\n import syntax::ast_map::node_id_to_str;\n-import syntax::ast_util::{local_def, respan, split_class_items,\n-                          split_trait_methods};\n+import syntax::ast_util::{local_def, respan, split_trait_methods};\n import syntax::visit;\n import metadata::csearch;\n import driver::session::session;"}, {"sha": "0c04d71e3d7272f97b76c3a13987f322a4591eea", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -372,19 +372,6 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method,\n     check_bare_fn(ccx, method.decl, method.body, method.id, some(self_info));\n }\n \n-fn check_class_member(ccx: @crate_ctxt, self_ty: ty::t,\n-                      node_id: ast::node_id,\n-                      cm: @ast::class_member) {\n-    match cm.node {\n-      ast::instance_var(_,t,_,_,_) => (),\n-      ast::class_method(m) => {\n-        let class_t = {self_ty: self_ty, node_id: node_id,\n-                       explicit_self: m.self_ty.node};\n-        check_method(ccx, m, class_t)\n-      }\n-    }\n-}\n-\n fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n                              ~[(ast::ident, span)]) {\n     let field_names = hashmap::<@~str, span>(|x| str::hash(*x),\n@@ -435,13 +422,13 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n         write_ty_to_tcx(tcx, dtor.node.self_id, class_t.self_ty);\n     };\n \n-    // typecheck the members\n-    for struct_def.members.each |m| {\n-        check_class_member(ccx, self_ty, id, m);\n+    // typecheck the methods\n+    for struct_def.methods.each |m| {\n+        check_method(ccx, m, {self_ty: self_ty, node_id: id,\n+                              explicit_self: m.self_ty.node});\n     }\n     // Check that there's at least one field\n-    let (fields,_) = split_class_items(struct_def.members);\n-    if fields.len() < 1u {\n+    if struct_def.fields.len() < 1u {\n         ccx.tcx.sess.span_err(span, ~\"a class must have at least one field\");\n     }\n     // Check that the class is instantiable"}, {"sha": "c8a9f850aa05de8ed1208fd7df913c3acf0406ed", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -17,7 +17,7 @@ import middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n import middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_var};\n import middle::typeck::infer::{infer_ctxt, mk_subty};\n import middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n-import syntax::ast::{class_method, crate, def_id, def_mod, instance_var};\n+import syntax::ast::{crate, def_id, def_mod};\n import syntax::ast::{item, item_class, item_const, item_enum, item_fn};\n import syntax::ast::{item_foreign_mod, item_impl, item_mac, item_mod};\n import syntax::ast::{item_trait, item_ty, local_crate, method, node_id};\n@@ -650,20 +650,13 @@ class CoherenceChecker {\n                                id: node_id)\n                             -> @Impl {\n         let mut methods = ~[];\n-        for struct_def.members.each |class_member| {\n-            match class_member.node {\n-                instance_var(*) => {\n-                    // Nothing to do.\n-                }\n-                class_method(ast_method) => {\n-                    push(methods, @{\n-                        did: local_def(ast_method.id),\n-                        n_tps: ast_method.tps.len(),\n-                        ident: ast_method.ident,\n-                        self_type: ast_method.self_ty.node\n-                    });\n-                }\n-            }\n+        for struct_def.methods.each |ast_method| {\n+            push(methods, @{\n+                did: local_def(ast_method.id),\n+                n_tps: ast_method.tps.len(),\n+                ident: ast_method.ident,\n+                self_type: ast_method.self_ty.node\n+            });\n         }\n \n         return @{ did: local_def(id), ident: ident, methods: methods };"}, {"sha": "c98746f945a62fceadcefd911b668cc44230ae59", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3038968f2895df915ca397864e96338edaa32e4b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3038968f2895df915ca397864e96338edaa32e4b", "patch": "@@ -215,10 +215,9 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n         });\n       }\n       ast_map::node_item(@{node: ast::item_class(struct_def, _), _}, _) => {\n-        let (_,ms) = split_class_items(struct_def.members);\n         // All methods need to be stored, since lookup_method\n         // relies on the same method cache for self-calls\n-        store_methods::<@ast::method>(ccx, id, ms, |m| {\n+        store_methods::<@ast::method>(ccx, id, struct_def.methods, |m| {\n             ty_of_method(ccx, m, rp)\n         });\n       }\n@@ -369,11 +368,12 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n fn convert_field(ccx: @crate_ctxt,\n                  rp: bool,\n                  bounds: @~[ty::param_bounds],\n-                 v: ast_util::ivar) {\n-    let tt = ccx.to_ty(type_rscope(rp), v.ty);\n-    write_ty_to_tcx(ccx.tcx, v.id, tt);\n+                 v: @ast::struct_field) {\n+    let tt = ccx.to_ty(type_rscope(rp), v.node.ty);\n+    write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n-    ccx.tcx.tcache.insert(local_def(v.id), {bounds: bounds, rp: rp, ty: tt});\n+    ccx.tcx.tcache.insert(local_def(v.node.id),\n+                          {bounds: bounds, rp: rp, ty: tt});\n }\n \n type converted_method = {mty: ty::method, id: ast::node_id, span: span};\n@@ -505,13 +505,12 @@ fn convert_struct(ccx: @crate_ctxt, rp: bool, struct_def: @ast::struct_def,\n     ensure_trait_methods(ccx, id, tpt.ty);\n \n     // Write the type of each of the members\n-    let (fields, methods) = split_class_items(struct_def.members);\n-    for fields.each |f| {\n+    for struct_def.fields.each |f| {\n        convert_field(ccx, rp, tpt.bounds, f);\n     }\n     let {bounds, substs} = mk_substs(ccx, tps, rp);\n     let selfty = ty::mk_class(tcx, local_def(id), substs);\n-    let cms = convert_methods(ccx, methods, rp, bounds, selfty);\n+    let cms = convert_methods(ccx, struct_def.methods, rp, bounds, selfty);\n     for struct_def.traits.each |trait_ref| {\n         check_methods_against_trait(ccx, tps, rp, selfty, trait_ref, cms);\n         // trait_ref.impl_id represents (class, trait) pair"}]}