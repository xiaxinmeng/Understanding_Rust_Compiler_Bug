{"sha": "21c48c3e823ed21266e96779d700946db957a965", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxYzQ4YzNlODIzZWQyMTI2NmU5Njc3OWQ3MDA5NDZkYjk1N2E5NjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-21T01:18:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-21T01:18:15Z"}, "message": "Auto merge of #24648 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #24514, #24516, #24571, #24577, #24625, #24627, #24628, #24629, #24630, #24631, #24632, #24642, #24643, #24647\n- Failed merges: #24640", "tree": {"sha": "f21a1a73533f5c9ebc85c4c3a08d00aaca15cd7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f21a1a73533f5c9ebc85c4c3a08d00aaca15cd7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21c48c3e823ed21266e96779d700946db957a965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21c48c3e823ed21266e96779d700946db957a965", "html_url": "https://github.com/rust-lang/rust/commit/21c48c3e823ed21266e96779d700946db957a965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21c48c3e823ed21266e96779d700946db957a965/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f46c4e158d395cf6e186bf6afdf1705c12071cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f46c4e158d395cf6e186bf6afdf1705c12071cbe", "html_url": "https://github.com/rust-lang/rust/commit/f46c4e158d395cf6e186bf6afdf1705c12071cbe"}, {"sha": "9ddcc38b6e880c89567d3082558974d70f23d864", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ddcc38b6e880c89567d3082558974d70f23d864", "html_url": "https://github.com/rust-lang/rust/commit/9ddcc38b6e880c89567d3082558974d70f23d864"}], "stats": {"total": 1829, "additions": 995, "deletions": 834}, "files": [{"sha": "d918a320e63a909c3298c213cb2188ddab0492b0", "filename": "src/doc/reference.md", "status": "modified", "additions": 22, "deletions": 115, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -973,8 +973,7 @@ Use declarations support a number of convenient shortcuts:\n \n An example of `use` declarations:\n \n-```\n-# #![feature(core)]\n+```rust\n use std::option::Option::{Some, None};\n use std::collections::hash_map::{self, HashMap};\n \n@@ -1031,16 +1030,17 @@ declarations.\n An example of what will and will not work for `use` items:\n \n ```\n-# #![feature(core)]\n # #![allow(unused_imports)]\n-use foo::core::iter;  // good: foo is at the root of the crate\n use foo::baz::foobaz;    // good: foo is at the root of the crate\n \n mod foo {\n-    extern crate core;\n \n-    use foo::core::iter; // good: foo is at crate root\n-//  use core::iter;      // bad:  core is not at the crate root\n+    mod example {\n+        pub mod iter {}\n+    }\n+\n+    use foo::example::iter; // good: foo is at crate root\n+//  use example::iter;      // bad:  core is not at the crate root\n     use self::baz::foobaz;  // good: self refers to module 'foo'\n     use foo::bar::foobar;   // good: foo is at crate root\n \n@@ -1368,17 +1368,14 @@ a = Animal::Cat;\n \n Enumeration constructors can have either named or unnamed fields:\n \n-```\n-# #![feature(struct_variant)]\n-# fn main() {\n+```rust\n enum Animal {\n     Dog (String, f64),\n     Cat { name: String, weight: f64 }\n }\n \n let mut a: Animal = Animal::Dog(\"Cocoa\".to_string(), 37.2);\n a = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n-# }\n ```\n \n In this example, `Cat` is a _struct-like enum variant_,\n@@ -1718,17 +1715,6 @@ Functions within external blocks are declared in the same way as other Rust\n functions, with the exception that they may not have a body and are instead\n terminated by a semicolon.\n \n-```\n-# #![feature(libc)]\n-extern crate libc;\n-use libc::{c_char, FILE};\n-\n-extern {\n-    fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n-}\n-# fn main() {}\n-```\n-\n Functions within external blocks may be called by Rust code, just like\n functions defined in Rust. The Rust compiler automatically translates between\n the Rust ABI and the foreign ABI.\n@@ -1739,7 +1725,7 @@ By default external blocks assume that the library they are calling uses the\n standard C \"cdecl\" ABI. Other ABIs may be specified using an `abi` string, as\n shown here:\n \n-```{.ignore}\n+```ignore\n // Interface to the Windows API\n extern \"stdcall\" { }\n ```\n@@ -3231,55 +3217,7 @@ expression.\n \n In a pattern whose head expression has an `enum` type, a placeholder (`_`)\n stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n-fields of a particular variant. For example:\n-\n-```\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n-enum List<X> { Nil, Cons(X, Box<List<X>>) }\n-\n-fn main() {\n-    let x: List<i32> = List::Cons(10, box List::Cons(11, box List::Nil));\n-\n-    match x {\n-        List::Cons(_, box List::Nil) => panic!(\"singleton list\"),\n-        List::Cons(..)               => return,\n-        List::Nil                    => panic!(\"empty list\")\n-    }\n-}\n-```\n-\n-The first pattern matches lists constructed by applying `Cons` to any head\n-value, and a tail value of `box Nil`. The second pattern matches _any_ list\n-constructed with `Cons`, ignoring the values of its arguments. The difference\n-between `_` and `..` is that the pattern `C(_)` is only type-correct if `C` has\n-exactly one argument, while the pattern `C(..)` is type-correct for any enum\n-variant `C`, regardless of how many arguments `C` has.\n-\n-Used inside an array pattern, `..` stands for any number of elements, when the\n-`advanced_slice_patterns` feature gate is turned on. This wildcard can be used\n-at most once for a given array, which implies that it cannot be used to\n-specifically match elements that are at an unknown distance from both ends of a\n-array, like `[.., 42, ..]`. If preceded by a variable name, it will bind the\n-corresponding slice to the variable. Example:\n-\n-```\n-# #![feature(advanced_slice_patterns, slice_patterns)]\n-fn is_symmetric(list: &[u32]) -> bool {\n-    match list {\n-        [] | [_]                   => true,\n-        [x, inside.., y] if x == y => is_symmetric(inside),\n-        _                          => false\n-    }\n-}\n-\n-fn main() {\n-    let sym     = &[0, 1, 4, 2, 4, 1, 0];\n-    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n-    assert!(is_symmetric(sym));\n-    assert!(!is_symmetric(not_sym));\n-}\n-```\n+fields of a particular variant.\n \n A `match` behaves differently depending on whether or not the head expression\n is an [lvalue or an rvalue](#lvalues,-rvalues-and-temporaries). If the head\n@@ -3298,30 +3236,15 @@ the inside of the match.\n An example of a `match` expression:\n \n ```\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n-# fn process_pair(a: i32, b: i32) { }\n-# fn process_ten() { }\n-\n-enum List<X> { Nil, Cons(X, Box<List<X>>) }\n-\n-fn main() {\n-    let x: List<i32> = List::Cons(10, box List::Cons(11, box List::Nil));\n+let x = 1;\n \n-    match x {\n-        List::Cons(a, box List::Cons(b, _)) => {\n-            process_pair(a, b);\n-        }\n-        List::Cons(10, _) => {\n-            process_ten();\n-        }\n-        List::Nil => {\n-            return;\n-        }\n-        _ => {\n-            panic!();\n-        }\n-    }\n+match x {\n+    1 => println!(\"one\"),\n+    2 => println!(\"two\"),\n+    3 => println!(\"three\"),\n+    4 => println!(\"four\"),\n+    5 => println!(\"five\"),\n+    _ => println!(\"something else\"),\n }\n ```\n \n@@ -3334,28 +3257,12 @@ Subpatterns can also be bound to variables by the use of the syntax `variable @\n subpattern`. For example:\n \n ```\n-#![feature(box_patterns)]\n-#![feature(box_syntax)]\n-\n-enum List { Nil, Cons(u32, Box<List>) }\n+let x = 1;\n \n-fn is_sorted(list: &List) -> bool {\n-    match *list {\n-        List::Nil | List::Cons(_, box List::Nil) => true,\n-        List::Cons(x, ref r @ box List::Cons(_, _)) => {\n-            match *r {\n-                box List::Cons(y, _) => (x <= y) && is_sorted(&**r),\n-                _ => panic!()\n-            }\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let a = List::Cons(6, box List::Cons(7, box List::Cons(42, box List::Nil)));\n-    assert!(is_sorted(&a));\n+match x {\n+    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n }\n-\n ```\n \n Patterns can also dereference pointers by using the `&`, `&mut` and `box`"}, {"sha": "dfe837285c8770227fa608610073485775009e77", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -165,7 +165,7 @@ fn main() {\n \n Rust has [move semantics][move] by default, so if we want to make a copy of some\n data, we call the `clone()` method. In this example, `y` is no longer a reference\n-to the vector stored in `x`, but a copy of its first element, `\"hello\"`. Now\n+to the vector stored in `x`, but a copy of its first element, `\"Hello\"`. Now\n that we don\u2019t have a reference, our `push()` works just fine.\n \n [move]: move-semantics.html"}, {"sha": "a179f8fa55e5eca66854a4985ecfddeb592ba4c2", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -14,7 +14,6 @@\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [FFI](ffi.md)\n-    * [Deref coercions](deref-coercions.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n     * [Functions](functions.md)\n@@ -30,15 +29,15 @@\n     * [Move semantics](move-semantics.md)\n     * [Enums](enums.md)\n     * [Match](match.md)\n-    * [Patterns](patterns.md)\n     * [Structs](structs.md)\n+    * [Patterns](patterns.md)\n     * [Method Syntax](method-syntax.md)\n-    * [Drop](drop.md)\n     * [Vectors](vectors.md)\n     * [Strings](strings.md)\n+    * [Generics](generics.md)\n     * [Traits](traits.md)\n     * [Operators and Overloading](operators-and-overloading.md)\n-    * [Generics](generics.md)\n+    * [Drop](drop.md)\n     * [if let](if-let.md)\n     * [Trait Objects](trait-objects.md)\n     * [Closures](closures.md)\n@@ -53,8 +52,9 @@\n     * [Casting between types](casting-between-types.md)\n     * [Associated Types](associated-types.md)\n     * [Unsized Types](unsized-types.md)\n+    * [Deref coercions](deref-coercions.md)\n     * [Macros](macros.md)\n-    * [`unsafe` Code](unsafe-code.md)\n+    * [Raw Pointers](raw-pointers.md)\n * [Nightly Rust](nightly-rust.md)\n     * [Compiler Plugins](compiler-plugins.md)\n     * [Inline Assembly](inline-assembly.md)"}, {"sha": "90731b64a38dc5185ddba8b316a40fc7e859fac1", "filename": "src/doc/trpl/casting-between-types.md", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,3 +1,89 @@\n % Casting Between Types\n \n-Coming Soon\n+Rust, with its focus on safety, provides two different ways of casting\n+different types between each other. The first, `as`, is for safe casts.\n+In contrast, `transmute` allows for arbitrary casting, and is one of the\n+most dangerous features of Rust!\n+\n+# `as`\n+\n+The `as` keyword does basic casting:\n+\n+```rust\n+let x: i32 = 5;\n+\n+let y = x as i64;\n+```\n+\n+It only allows certain kinds of casting, however:\n+\n+```rust,ignore\n+let a = [0u8, 0u8, 0u8, 0u8];\n+\n+let b = a as u32; // four eights makes 32\n+```\n+\n+This errors with:\n+\n+```text\n+error: non-scalar cast: `[u8; 4]` as `u32`\n+let b = a as u32; // four eights makes 32\n+        ^~~~~~~~\n+```\n+\n+It\u2019s a \u2018non-scalar cast\u2019 because we have multiple values here: the four\n+elements of the array. These kinds of casts are very dangerous, because they\n+make assumptions about the way that multiple underlying strucutres are\n+implemented. For this, we need something more dangerous.\n+\n+# `transmute`\n+\n+The `transmute` function is provided by a [compiler intrinsic][intrinsics], and\n+what it does is very simple, but very scary. It tells Rust to treat a value of\n+one type as though it were another type. It does this regardless of the\n+typechecking system, and just completely trusts you.\n+\n+[intrinsic]: intrinsics.html\n+\n+In our previous example, we know that an array of four `u8`s represents a `u32`\n+properly, and so we want to do the cast. Using `transmute` instead of `as`,\n+Rust lets us:\n+\n+```rust\n+use std::mem;\n+\n+unsafe {\n+    let a = [0u8, 0u8, 0u8, 0u8];\n+\n+    let b = mem::transmute::<[u8; 4], u32>(a);\n+}\n+```\n+\n+We have to wrap the operation in an `unsafe` block, but this will compile\n+successfully. Technically, only the `mem::transmute` call itself needs to be in\n+the block, but it's nice in this case to enclose everything related, so you\n+know where to look. In this case, the details about `a` are also important, and\n+so they're in the block. You'll see code in either style, sometimes the context\n+is too far away, and wrapping all of the code in `unsafe` isn't a great idea.\n+\n+While `transmute` does very little checking, it will at least make sure that\n+the types are the same size. This errors:\n+\n+```rust,ignore\n+use std::mem;\n+\n+unsafe {\n+    let a = [0u8, 0u8, 0u8, 0u8];\n+\n+    let b = mem::transmute::<[u8; 4], u64>(a);\n+}\n+```\n+\n+with:\n+\n+```text\n+error: transmute called on types with different sizes: [u8; 4] (32 bits) to u64\n+(64 bits)\n+```\n+\n+Other than that, you're on your own!"}, {"sha": "80ea25eb35ce92125c82027c7275bf10bba3353e", "filename": "src/doc/trpl/enums.md", "status": "modified", "additions": 25, "deletions": 104, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,11 +1,9 @@\n % Enums\n \n-Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n-feature of Rust, and are used throughout the standard library. An `enum` is\n-a type which relates a set of alternates to a specific name. For example, below\n-we define `Character` to be either a `Digit` or something else. These\n-can be used via their fully scoped names: `Character::Other` (more about `::`\n-below).\n+Rust has a \u2018sum type\u2019, an `enum`. Enums are an incredibly useful feature of\n+Rust, and are used throughout the standard library. An `enum` is a type which\n+relates a set of alternates to a specific name. For example, below we define\n+`Character` to be either a `Digit` or something else.\n \n ```rust\n enum Character {\n@@ -14,14 +12,14 @@ enum Character {\n }\n ```\n \n-Most normal types are allowed as the variant components of an `enum`. Here are\n-some examples:\n+Most types are allowed as the variant components of an `enum`. Here are some\n+examples:\n \n ```rust\n struct Empty;\n struct Color(i32, i32, i32);\n struct Length(i32);\n-struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n+struct Stats { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n struct HeightDatabase(Vec<i32>);\n ```\n \n@@ -30,12 +28,12 @@ In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n value, where `Other` is only a name. However, the fact that they represent\n distinct categories of `Character` is a very useful property.\n \n-As with structures, the variants of an enum by default are not comparable with\n-equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n-support other binary operations such as `*` and `+`. As such, the following code\n-is invalid for the example `Character` type:\n+The variants of an `enum` by default are not comparable with equality operators\n+(`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not support other\n+binary operations such as `*` and `+`. As such, the following code is invalid\n+for the example `Character` type:\n \n-```{rust,ignore}\n+```rust,ignore\n // These assignments both succeed\n let ten  = Character::Digit(10);\n let four = Character::Digit(4);\n@@ -50,98 +48,21 @@ let four_is_smaller = four <= ten;\n let four_equals_ten = four == ten;\n ```\n \n-This may seem rather limiting, but it's a limitation which we can overcome.\n-There are two ways: by implementing equality ourselves, or by pattern matching\n-variants with [`match`][match] expressions, which you'll learn in the next\n-chapter. We don't know enough about Rust to implement equality yet, but we can\n-use the `Ordering` enum from the standard library, which does:\n+We use the `::` syntax to use the name of each variant: They\u2019re scoped by the name\n+of the `enum` itself. This allows both of these to work:\n \n-```\n-enum Ordering {\n-    Less,\n-    Equal,\n-    Greater,\n-}\n-```\n-\n-Because `Ordering` has already been defined for us, we will import it with the\n-`use` keyword. Here's an example of how it is used:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives\n-in the `cmp` submodule of the `std` module. We'll talk more about modules later\n-in the guide. For now, all you need to know is that you can `use` things from\n-the standard library if you need them.\n-\n-Okay, let's talk about the actual code in the example. `cmp` is a function that\n-compares two things, and returns an `Ordering`. We return either\n-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n-whether the first value is less than, greater than, or equal to the second. Note\n-that each variant of the `enum` is namespaced under the `enum` itself: it's\n-`Ordering::Greater`, not `Greater`.\n-\n-The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We then do a bunch of `if`/`else` comparisons to check which\n-one it is.\n-\n-This `Ordering::Greater` notation is too long. Let's use another form of `use`\n-to import the `enum` variants instead. This will avoid full scoping:\n-\n-```{rust}\n-use std::cmp::Ordering::{self, Equal, Less, Greater};\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Less { println!(\"less\"); }\n-    else if ordering == Greater { println!(\"greater\"); }\n-    else if ordering == Equal { println!(\"equal\"); }\n-}\n+```rust,ignore\n+Character::Digit(10);\n+Hand::Digit;\n ```\n \n-Importing variants is convenient and compact, but can also cause name conflicts,\n-so do this with caution. For this reason, it's normally considered better style\n-to `use` an enum rather than its variants directly.\n+Both variants are named `Digit`, but since they\u2019re scoped to the `enum` name,\n \n-As you can see, `enum`s are quite a powerful tool for data representation, and\n-are even more useful when they're [generic][generics] across types. Before we\n-get to generics, though, let's talk about how to use enums with pattern\n-matching, a tool that will let us deconstruct sum types (the type theory term\n-for enums) like `Ordering` in a very elegant way that avoids all these messy\n-and brittle `if`/`else`s.\n+Not supporting these operations may seem rather limiting, but it\u2019s a limitation\n+which we can overcome. There are two ways: by implementing equality ourselves,\n+or by pattern matching variants with [`match`][match] expressions, which you\u2019ll\n+learn in the next section. We don\u2019t know enough about Rust to implement\n+equality yet, but we\u2019ll find out in the [`traits`][traits] section.\n \n-[match]: ./match.html\n-[generics]: ./generics.html\n+[match]: match.html\n+[traits]: traits.html"}, {"sha": "517a6e6064253295a6292e1a6b2a3e0147f5b2bd", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 50, "deletions": 103, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,31 +1,13 @@\n % Generics\n \n Sometimes, when writing a function or data type, we may want it to work for\n-multiple types of arguments. For example, remember our `OptionalInt` type?\n+multiple types of arguments. Luckily, Rust has a feature that gives us a better\n+way: generics. Generics are called \u2018parametric polymorphism\u2019 in type theory,\n+which means that they are types or functions that have multiple forms (\u2018poly\u2019\n+is multiple, \u2018morph\u2019 is form) over a given parameter (\u2018parametric\u2019).\n \n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-```\n-\n-If we wanted to also have an `OptionalFloat64`, we would need a new enum:\n-\n-```{rust}\n-enum OptionalFloat64 {\n-    Valuef64(f64),\n-    Missingf64,\n-}\n-```\n-\n-This is really unfortunate. Luckily, Rust has a feature that gives us a better\n-way: generics. Generics are called *parametric polymorphism* in type theory,\n-which means that they are types or functions that have multiple forms (*poly*\n-is multiple, *morph* is form) over a given parameter (*parametric*).\n-\n-Anyway, enough with type theory declarations, let's check out the generic form\n-of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n+Anyway, enough with type theory, let\u2019s check out some generic code. Rust\u2019s\n+standard library provides a type, `Option<T>`, that\u2019s generic:\n \n ```rust\n enum Option<T> {\n@@ -34,144 +16,109 @@ enum Option<T> {\n }\n ```\n \n-The `<T>` part, which you've seen a few times before, indicates that this is\n+The `<T>` part, which you\u2019ve seen a few times before, indicates that this is\n a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n-we substitute that type for the same type used in the generic. Here's an\n+we substitute that type for the same type used in the generic. Here\u2019s an\n example of using `Option<T>`, with some extra type annotations:\n \n-```{rust}\n+```rust\n let x: Option<i32> = Some(5);\n ```\n \n In the type declaration, we say `Option<i32>`. Note how similar this looks to\n `Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On\n the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.\n-Since that's an `i32`, the two sides match, and Rust is happy. If they didn't\n-match, we'd get an error:\n+Since that\u2019s an `i32`, the two sides match, and Rust is happy. If they didn\u2019t\n+match, we\u2019d get an error:\n \n-```{rust,ignore}\n+```rust,ignore\n let x: Option<f64> = Some(5);\n // error: mismatched types: expected `core::option::Option<f64>`,\n // found `core::option::Option<_>` (expected f64 but found integral variable)\n ```\n \n-That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n-match up:\n+That doesn\u2019t mean we can\u2019t make `Option<T>`s that hold an `f64`! They just have\n+to match up:\n \n-```{rust}\n+```rust\n let x: Option<i32> = Some(5);\n let y: Option<f64> = Some(5.0f64);\n ```\n \n This is just fine. One definition, multiple uses.\n \n-Generics don't have to only be generic over one type. Consider Rust's built-in\n-`Result<T, E>` type:\n+Generics don\u2019t have to only be generic over one type. Consider another type from Rust\u2019s standard library that\u2019s similar, `Result<T, E>`:\n \n-```{rust}\n+```rust\n enum Result<T, E> {\n     Ok(T),\n     Err(E),\n }\n ```\n \n This type is generic over _two_ types: `T` and `E`. By the way, the capital letters\n-can be any letter you'd like. We could define `Result<T, E>` as:\n+can be any letter you\u2019d like. We could define `Result<T, E>` as:\n \n-```{rust}\n+```rust\n enum Result<A, Z> {\n     Ok(A),\n     Err(Z),\n }\n ```\n \n if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+`T`, for \u2018type\u2019, and that we use `E` for \u2018error\u2019. Rust doesn\u2019t care, however.\n \n The `Result<T, E>` type is intended to be used to return the result of a\n-computation, and to have the ability to return an error if it didn't work out.\n-Here's an example:\n-\n-```{rust}\n-let x: Result<f64, String> = Ok(2.3f64);\n-let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n-```\n+computation, and to have the ability to return an error if it didn\u2019t work out.\n \n-This particular Result will return an `f64` if there's a success, and a\n-`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n+## Generic functions\n \n-```{rust}\n-fn inverse(x: f64) -> Result<f64, String> {\n-    if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+We can write functions that take generic types with a similar syntax:\n \n-    Ok(1.0f64 / x)\n+```rust\n+fn takes_anything<T>(x: T) {\n+    // do something with x\n }\n ```\n \n-We don't want to take the inverse of zero, so we check to make sure that we\n-weren't passed zero. If we were, then we return an `Err`, with a message. If\n-it's okay, we return an `Ok`, with the answer.\n+The syntax has two parts: the `<T>` says \u201cthis function is generic over one\n+type, `T`\u201d, and the `x: T` says \u201cx has the type `T`.\u201d\n \n-Why does this matter? Well, remember how `match` does exhaustive matches?\n-Here's how this function gets used:\n+Multiple arguments can have the same generic type:\n \n-```{rust}\n-# fn inverse(x: f64) -> Result<f64, String> {\n-#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n-#     Ok(1.0f64 / x)\n-# }\n-let x = inverse(25.0f64);\n-\n-match x {\n-    Ok(x) => println!(\"The inverse of 25 is {}\", x),\n-    Err(msg) => println!(\"Error: {}\", msg),\n+```rust\n+fn takes_two_of_the_same_things<T>(x: T, y: T) {\n+    // ...\n }\n ```\n \n-The `match` enforces that we handle the `Err` case. In addition, because the\n-answer is wrapped up in an `Ok`, we can't just use the result without doing\n-the match:\n-\n-```{rust,ignore}\n-let x = inverse(25.0f64);\n-println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied\n-           // to type `core::result::Result<f64,collections::string::String>`\n-```\n-\n-This function is great, but there's one other problem: it only works for 64 bit\n-floating point values. What if we wanted to handle 32 bit floating point as\n-well? We'd have to write this:\n+We could write a version that takes multiple types:\n \n-```{rust}\n-fn inverse32(x: f32) -> Result<f32, String> {\n-    if x == 0.0f32 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0f32 / x)\n+```rust\n+fn takes_two_things<T, U>(x: T, y: U) {\n+    // ...\n }\n ```\n \n-Bummer. What we need is a *generic function*. Luckily, we can write one!\n-However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n-A generic version of `inverse` would look something like this:\n+Generic functions are most useful with \u2018trait bounds\u2019, which we\u2019ll cover in the\n+[section on traits][traits].\n \n-```{rust,ignore}\n-fn inverse<T>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n+[traits]: traits.html\n \n-    Ok(1.0 / x)\n-}\n-```\n+## Generic structs\n \n-Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n-We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n-of the `Result` has type `T`. However, if we try to compile that example, we'll get\n-an error:\n+You can store a generic type in a `struct` as well:\n \n-```text\n-error: binary operation `==` cannot be applied to type `T`\n ```\n+struct Point<T> {\n+    x: T,\n+    y: T,\n+}\n \n-Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n-and therefore, the first line would be wrong. What do we do?\n+let int_origin = Point { x: 0, y: 0 };\n+let float_origin = Point { x: 0.0, y: 0.0 };\n+```\n \n-To fix this example, we need to learn about another Rust feature: traits.\n+Similarly to functions, the `<T>` is where we declare the generic parameters,\n+and we then use `x: T` in the type declaration, too."}, {"sha": "7173303e3b15203109a9b094e62b2ccc989daca4", "filename": "src/doc/trpl/if-let.md", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fif-let.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fif-let.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif-let.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,3 +1,82 @@\n % if let\n \n-COMING SOON\n+`if let` allows you to combine `if` and `let` together to reduce the overhead\n+of certain kinds of pattern matches.\n+\n+For example, let\u2019s say we have some sort of `Option<T>`. We want to call a function\n+on it if it\u2019s `Some<T>`, but do nothing if it\u2019s `None`. That looks like this:\n+\n+```rust\n+# let option = Some(5);\n+# fn foo(x: i32) { }\n+match option {\n+    Some(x) => { foo(x) },\n+    None => {},\n+}\n+```\n+\n+We don\u2019t have to use `match` here, for example, we could use `if`:\n+\n+```rust\n+# let option = Some(5);\n+# fn foo(x: i32) { }\n+if option.is_some() {\n+    let x = option.unwrap();\n+    foo(x);\n+}\n+```\n+\n+Neither of these options is particularly appealing. We can use `if let` to\n+do the same thing in a nicer way:\n+\n+```rust\n+# let option = Some(5);\n+# fn foo(x: i32) { }\n+if let Some(x) = option {\n+    foo(x);\n+}\n+```\n+\n+If a [pattern][patterns] matches successfully, it binds any appropriate parts of\n+the value to the identifiers in the pattern, then evaluates the expression. If\n+the pattern doesn\u2019t match, nothing happens.\n+\n+If you\u2019d rather to do something else when the pattern does not match, you can\n+use `else`:\n+\n+```rust\n+# let option = Some(5);\n+# fn foo(x: i32) { }\n+# fn bar() { }\n+if let Some(x) = option {\n+    foo(x);\n+} else {\n+    bar();\n+}\n+```\n+\n+## `while let`\n+\n+In a similar fashion, `while let` can be used when you want to conditionally\n+loop as long as a value matches a certain pattern. It turns code like this:\n+\n+```rust\n+# let option: Option<i32> = None;\n+loop {\n+    match option {\n+        Some(x) => println!(\"{}\", x),\n+\t_ => break,\n+    }\n+}\n+```\n+\n+Into code like this:\n+\n+```rust\n+# let option: Option<i32> = None;\n+while let Some(x) = option {\n+    println!(\"{}\", x);\n+}\n+```\n+\n+[patterns]: patterns.html"}, {"sha": "1d4452754baa202886f2ee617e159a0424ff63e9", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -653,6 +653,116 @@ macro_rules! bct {\n Exercise: use macros to reduce duplication in the above definition of the\n `bct!` macro.\n \n+# Common macros\n+\n+Here are some common macros you\u2019ll see in Rust code.\n+\n+## panic!\n+\n+This macro causes the current thread to panic. You can give it a message\n+to panic with:\n+\n+```rust,no_run\n+panic!(\"oh no!\");\n+```\n+\n+## vec!\n+\n+The `vec!` macro is used throughout the book, so you\u2019ve probably seen it\n+already. It creates `Vec<T>`s with ease:\n+\n+```rust\n+let v = vec![1, 2, 3, 4, 5];\n+```\n+\n+It also lets you make vectors with repeating values. For example, a hundred\n+zeroes:\n+\n+```rust\n+let v = vec![0; 100];\n+```\n+\n+## assert! and assert_eq!\n+\n+These two macros are used in tests. `assert!` takes a boolean, and `assert_eq!`\n+takes two values and compares them. Truth passes, success `panic!`s. Like\n+this:\n+\n+```rust,no_run\n+// A-ok!\n+\n+assert!(true);\n+assert_eq!(5, 3 + 2);\n+\n+// nope :(\n+\n+assert!(5 < 3);\n+assert_eq!(5, 3);\n+```\n+## try!\n+\n+`try!` is used for error handling. It takes something that can return a\n+`Result<T, E>`, and gives `T` if it\u2019s a `Ok<T>`, and `return`s with the\n+`Err(E)` if it\u2019s that. Like this:\n+\n+```rust,no_run\n+use std::fs::File;\n+\n+fn foo() -> std::io::Result<()> {\n+    let f = try!(File::create(\"foo.txt\"));\n+\n+    Ok(())\n+}\n+```\n+\n+This is cleaner than doing this:\n+\n+```rust,no_run\n+use std::fs::File;\n+\n+fn foo() -> std::io::Result<()> {\n+    let f = File::create(\"foo.txt\");\n+\n+    let f = match f {\n+        Ok(t) => t,\n+        Err(e) => return Err(e),\n+    };\n+\n+    Ok(())\n+}\n+```\n+\n+## unreachable!\n+\n+This macro is used when you think some code should never execute:\n+\n+```rust\n+if false {\n+    unreachable!();\n+}\n+```\n+\n+Sometimes, the compiler may make you have a different branch that you know\n+will never, ever run. In these cases, use this macro, so that if you end\n+up wrong, you\u2019ll get a `panic!` about it.\n+\n+```rust\n+let x: Option<i32> = None;\n+\n+match x {\n+    Some(_) => unreachable!(),\n+    None => println!(\"I know x is None!\"),\n+}\n+```\n+\n+## unimplemented!\n+\n+The `unimplemented!` macro can be used when you\u2019re trying to get your functions\n+to typecheck, and don\u2019t want to worry about writing out the body of the\n+function. One example of this situation is implementing a trait with multiple\n+required methods, where you want to tackle one at a time. Define the others\n+as `unimplemented!` until you\u2019re ready to write them.\n+\n # Procedural macros\n \n If Rust's macro system can't do what you need, you may want to write a"}, {"sha": "2c0c8ea73c03c5b6ec6169b609af0d8a36d615b0", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,10 +1,8 @@\n % Match\n \n-Often, a simple `if`/`else` isn\u2019t enough, because you have more than two\n-possible options. Also, `else` conditions can get incredibly complicated, so\n-what\u2019s the solution?\n-\n-Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n+Often, a simple [`if`][if]/`else` isn\u2019t enough, because you have more than two\n+possible options. Also, conditions can get quite complex. Rust\n+has a keyword, `match`, that allows you to replace complicated `if`/`else`\n groupings with something more powerful. Check it out:\n \n ```rust\n@@ -20,28 +18,31 @@ match x {\n }\n ```\n \n-`match` takes an expression and then branches based on its value. Each *arm* of\n+[if]: if.html\n+\n+`match` takes an expression and then branches based on its value. Each \u2018arm\u2019 of\n the branch is of the form `val => expression`. When the value matches, that arm\u2019s\n expression will be evaluated. It\u2019s called `match` because of the term \u2018pattern\n matching\u2019, which `match` is an implementation of. There\u2019s an [entire section on\n-patterns][patterns] coming up next, that covers all the options that fit here.\n+patterns][patterns] that covers all the patterns that are possible here.\n \n [patterns]: patterns.html\n \n-So what\u2019s the big advantage here? Well, there are a few. First of all, `match`\n-enforces *exhaustiveness checking*. Do you see that last arm, the one with the\n+So what\u2019s the big advantage? Well, there are a few. First of all, `match`\n+enforces \u2018exhaustiveness checking\u2019. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n ```text\n error: non-exhaustive patterns: `_` not covered\n ```\n \n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n-integer, Rust knows that it can have a number of different values \u2013 for example,\n-`6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n-to compile. `_` acts like a \u2018catch-all arm\u2019. If none of the other arms match,\n-the arm with `_` will, and since we have this catch-all arm, we now have an arm\n-for every possible value of `x`, and so our program will compile successfully.\n+integer, Rust knows that it can have a number of different values \u2013 for\n+example, `6`. Without the `_`, however, there is no arm that could match, and\n+so Rust refuses to compile the code. `_` acts like a \u2018catch-all arm\u2019. If none\n+of the other arms match, the arm with `_` will, and since we have this\n+catch-all arm, we now have an arm for every possible value of `x`, and so our\n+program will compile successfully.\n \n `match` is also an expression, which means we can use it on the right-hand\n side of a `let` binding or directly where an expression is used:\n@@ -59,4 +60,4 @@ let numer = match x {\n };\n ```\n \n-Sometimes, it\u2019s a nice way of converting things.\n+Sometimes it\u2019s a nice way of converting something from one type to another."}, {"sha": "5853f3d679c5f5231f185af1d1d940eed1a30c70", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -3,27 +3,26 @@\n Functions are great, but if you want to call a bunch of them on some data, it\n can be awkward. Consider this code:\n \n-```{rust,ignore}\n+```rust,ignore\n baz(bar(foo)));\n ```\n \n-We would read this left-to right, and so we see \"baz bar foo.\" But this isn't the\n-order that the functions would get called in, that's inside-out: \"foo bar baz.\"\n-Wouldn't it be nice if we could do this instead?\n+We would read this left-to right, and so we see \u2018baz bar foo\u2019. But this isn\u2019t the\n+order that the functions would get called in, that\u2019s inside-out: \u2018foo bar baz\u2019.\n+Wouldn\u2019t it be nice if we could do this instead?\n \n-```{rust,ignore}\n+```rust,ignore\n foo.bar().baz();\n ```\n \n Luckily, as you may have guessed with the leading question, you can! Rust provides\n-the ability to use this *method call syntax* via the `impl` keyword.\n+the ability to use this \u2018method call syntax\u2019 via the `impl` keyword.\n \n ## Method calls\n \n-Here's how it works:\n+Here\u2019s how it works:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -44,15 +43,23 @@ fn main() {\n \n This will print `12.566371`.\n \n-We've made a struct that represents a circle. We then write an `impl` block,\n-and inside it, define a method, `area`. Methods take a  special first\n-parameter, of which there are three variants: `self`, `&self`, and `&mut self`.\n-You can think of this first parameter as being the `foo` in `foo.bar()`. The three\n-variants correspond to the three kinds of things `foo` could be: `self` if it's\n-just a value on the stack, `&self` if it's a reference, and `&mut self` if it's\n-a mutable reference. We should default to using `&self`, as you should prefer\n-borrowing over taking ownership, as well as taking immutable references\n-over mutable ones. Here's an example of all three variants:\n+\n+\n+We\u2019ve made a struct that represents a circle. We then write an `impl` block,\n+and inside it, define a method, `area`.\n+\n+Methods take a  special first parameter, of which there are three variants:\n+`self`, `&self`, and `&mut self`. You can think of this first parameter as\n+being the `foo` in `foo.bar()`. The three variants correspond to the three\n+kinds of things `foo` could be: `self` if it\u2019s just a value on the stack,\n+`&self` if it\u2019s a reference, and `&mut self` if it\u2019s a mutable reference.\n+Because we took the `&self` parameter to `area`, we can use it just like any\n+other parameter. Because we know it\u2019s a `Circle`, we can access the `radius`\n+just like we would with any other struct. \n+\n+We should default to using `&self`, as you should prefer borrowing over taking\n+ownership, as well as taking immutable references over mutable ones. Here\u2019s an\n+example of all three variants:\n \n ```rust\n struct Circle {\n@@ -76,20 +83,13 @@ impl Circle {\n }\n ```\n \n-Finally, as you may remember, the value of the area of a circle is `\u03c0*r\u00b2`.\n-Because we took the `&self` parameter to `area`, we can use it just like any\n-other parameter. Because we know it's a `Circle`, we can access the `radius`\n-just like we would with any other struct. An import of \u03c0 and some\n-multiplications later, and we have our area.\n-\n ## Chaining method calls\n \n So, now we know how to call a method, such as `foo.bar()`. But what about our\n-original example, `foo.bar().baz()`? This is called 'method chaining', and we\n+original example, `foo.bar().baz()`? This is called \u2018method chaining\u2019, and we\n can do it by returning `self`.\n \n ```\n-# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -124,13 +124,13 @@ fn grow(&self) -> Circle {\n # Circle } }\n ```\n \n-We just say we're returning a `Circle`. With this method, we can grow a new\n+We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n circle to any arbitrary size.\n \n ## Static methods\n \n-You can also define methods that do not take a `self` parameter. Here's a\n-pattern that's very common in Rust code:\n+You can also define methods that do not take a `self` parameter. Here\u2019s a\n+pattern that\u2019s very common in Rust code:\n \n ```\n struct Circle {\n@@ -154,20 +154,19 @@ fn main() {\n }\n ```\n \n-This *static method* builds a new `Circle` for us. Note that static methods\n+This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n are called with the `Struct::method()` syntax, rather than the `ref.method()`\n syntax.\n \n ## Builder Pattern\n \n-Let's say that we want our users to be able to create Circles, but we will\n+Let\u2019s say that we want our users to be able to create Circles, but we will\n allow them to only set the properties they care about. Otherwise, the `x`\n-and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn't\n+and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn\u2019t\n have method overloading, named arguments, or variable arguments. We employ\n the builder pattern instead. It looks like this:\n \n ```\n-# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -224,9 +223,9 @@ fn main() {\n }\n ```\n \n-What we've done here is make another struct, `CircleBuilder`. We've defined our\n-builder methods on it. We've also defined our `area()` method on `Circle`. We\n+What we\u2019ve done here is make another struct, `CircleBuilder`. We\u2019ve defined our\n+builder methods on it. We\u2019ve also defined our `area()` method on `Circle`. We\n also made one more method on `CircleBuilder`: `finalize()`. This method creates\n-our final `Circle` from the builder. Now, we've used the type system to enforce\n+our final `Circle` from the builder. Now, we\u2019ve used the type system to enforce\n our concerns: we can use the methods on `CircleBuilder` to constrain making\n `Circle`s in any way we choose."}, {"sha": "97a3dfe8a7640c688070a6e059b570273e43dab2", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -21,6 +21,8 @@ match x {\n }\n ```\n \n+This prints `one`.\n+\n # Multiple patterns\n \n You can match multiple patterns with `|`:\n@@ -35,6 +37,8 @@ match x {\n }\n ```\n \n+This prints `one or two`.\n+\n # Ranges\n \n You can match a range of values with `...`:\n@@ -48,7 +52,21 @@ match x {\n }\n ```\n \n-Ranges are mostly used with integers and single characters.\n+This prints `one through five`.\n+\n+Ranges are mostly used with integers and `char`s:\n+\n+```rust\n+let x = '\ud83d\udc85';\n+\n+match x {\n+    'a' ... 'j' => println!(\"early letter\"),\n+    'k' ... 'z' => println!(\"late letter\"),\n+    _ => println!(\"something else\"),\n+}\n+```\n+\n+This prints `something else`\n \n # Bindings\n \n@@ -64,6 +82,8 @@ match x {\n }\n ```\n \n+This prints `got a range element 1`.\n+\n # Ignoring variants\n \n If you\u2019re matching on an enum which has variants, you can use `..` to\n@@ -83,6 +103,8 @@ match x {\n }\n ```\n \n+This prints `Got an int!`.\n+\n # Guards\n \n You can introduce \u2018match guards\u2019 with `if`:\n@@ -102,6 +124,8 @@ match x {\n }\n ```\n \n+This prints `Got an int!`\n+\n # ref and ref mut\n \n If you want to get a [reference][ref], use the `ref` keyword:\n@@ -114,6 +138,8 @@ match x {\n }\n ```\n \n+This prints `Got a reference to 5`.\n+\n [ref]: references-and-borrowing.html\n \n Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n@@ -130,7 +156,7 @@ match x {\n \n # Destructuring\n \n-If you have a compound data type, like a `struct`, you can destructure it\n+If you have a compound data type, like a [`struct`][struct], you can destructure it\n inside of a pattern:\n \n ```rust\n@@ -146,6 +172,8 @@ match origin {\n }\n ```\n \n+[struct]: structs.html\n+\n If we only care about some of the values, we don\u2019t have to give them all names:\n \n ```rust\n@@ -161,6 +189,8 @@ match origin {\n }\n ```\n \n+This prints `x is 0`.\n+\n You can do this kind of match on any member, not just the first:\n \n ```rust\n@@ -176,6 +206,8 @@ match origin {\n }\n ```\n \n+This prints `y is 0`.\n+\n This \u2018destructuring\u2019 behavior works on any compound data type, like\n [tuples][tuples] or [enums][enums].\n \n@@ -187,10 +219,10 @@ This \u2018destructuring\u2019 behavior works on any compound data type, like\n Whew! That\u2019s a lot of different ways to match things, and they can all be\n mixed and matched, depending on what you\u2019re doing:\n \n-```{rust,ignore}\n+```rust,ignore\n match x {\n     Foo { x: Some(ref name), y: None } => ...\n }\n ```\n \n-Patterns are very powerful.  Make good use of them.\n+Patterns are very powerful. Make good use of them."}, {"sha": "ab6ff18501ed57253ae562890bc27c420300256f", "filename": "src/doc/trpl/raw-pointers.md", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fraw-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fraw-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fraw-pointers.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -0,0 +1,122 @@\n+% Raw Pointers\n+\n+Rust has a number of different smart pointer types in its standard library, but\n+there are two types that are extra-special. Much of Rust\u2019s safety comes from\n+compile-time checks, but raw pointers don\u2019t have such guarantees, and are\n+[unsafe][unsafe] to use.\n+\n+`*const T` and `*mut T` are called \u2018raw pointers\u2019 in Rust. Sometimes, when\n+writing certain kinds of libraries, you\u2019ll need to get around Rust\u2019s safety\n+guarantees for some reason. In this case, you can use raw pointers to implement\n+your library, while exposing a safe interface for your users. For example, `*`\n+pointers are allowed to alias, allowing them to be used to write\n+shared-ownership types, and even thread-safe shared memory types (the `Rc<T>`\n+and `Arc<T>` types are both implemented entirely in Rust).\n+\n+Here are some things to remember about raw pointers that are different than\n+other pointer types. They:\n+\n+- are not guaranteed to point to valid memory and are not even\n+  guaranteed to be non-null (unlike both `Box` and `&`);\n+- do not have any automatic clean-up, unlike `Box`, and so require\n+  manual resource management;\n+- are plain-old-data, that is, they don't move ownership, again unlike\n+  `Box`, hence the Rust compiler cannot protect against bugs like\n+  use-after-free;\n+- lack any form of lifetimes, unlike `&`, and so the compiler cannot\n+  reason about dangling pointers; and\n+- have no guarantees about aliasing or mutability other than mutation\n+  not being allowed directly through a `*const T`.\n+\n+# Basics\n+\n+Creating a raw pointer is perfectly safe:\n+\n+```rust\n+let x = 5;\n+let raw = &x as *const i32;\n+\n+let mut y = 10;\n+let raw_mut = &mut y as *mut i32;\n+```\n+\n+However, dereferencing one is not. This won\u2019t work:\n+\n+```rust,ignore\n+let x = 5;\n+let raw = &x as *const i32;\n+\n+println!(\"raw points at {}\", *raw);\n+```\n+\n+It gives this error:\n+\n+```text\n+error: dereference of unsafe pointer requires unsafe function or block [E0133]\n+     println!(\"raw points at{}\", *raw);\n+                                 ^~~~\n+```\n+\n+When you dereference a raw pointer, you\u2019re taking responsibility that it\u2019s not\n+pointing somewhere that would be incorrect. As such, you need `unsafe`:\n+\n+```rust\n+let x = 5;\n+let raw = &x as *const i32;\n+\n+let points_at = unsafe { *raw };\n+\n+println!(\"raw points at {}\", points_at);\n+```\n+\n+For more operations on raw pointers, see [their API documentation][rawapi].\n+\n+[unsafe]: unsafe.html\n+[rawapi]: ../std/primitive.pointer.html\n+\n+# FFI\n+\n+Raw pointers are useful for FFI: Rust\u2019s `*const T` and `*mut T` are similar to\n+C\u2019s `const T*` and `T*`, respectfully. For more about this use, consult the\n+[FFI chapter][ffi].\n+\n+[ffi]: ffi.md\n+\n+# References and raw pointers\n+\n+At runtime, a raw pointer `*` and a reference pointing to the same piece of\n+data have an identical representation. In fact, an `&T` reference will\n+implicitly coerce to an `*const T` raw pointer in safe code and similarly for\n+the `mut` variants (both coercions can be performed explicitly with,\n+respectively, `value as *const T` and `value as *mut T`).\n+\n+Going the opposite direction, from `*const` to a reference `&`, is not safe. A\n+`&T` is always valid, and so, at a minimum, the raw pointer `*const T` has to\n+point to a valid instance of type `T`. Furthermore, the resulting pointer must\n+satisfy the aliasing and mutability laws of references. The compiler assumes\n+these properties are true for any references, no matter how they are created,\n+and so any conversion from raw pointers is asserting that they hold. The\n+programmer *must* guarantee this.\n+\n+The recommended method for the conversion is\n+\n+```rust\n+let i: u32 = 1;\n+\n+// explicit cast\n+let p_imm: *const u32 = &i as *const u32;\n+let mut m: u32 = 2;\n+\n+// implicit coercion\n+let p_mut: *mut u32 = &mut m;\n+\n+unsafe {\n+    let ref_imm: &u32 = &*p_imm;\n+    let ref_mut: &mut u32 = &mut *p_mut;\n+}\n+```\n+\n+The `&*x` dereferencing style is preferred to using a `transmute`. The latter\n+is far more powerful than necessary, and the more restricted operation is\n+harder to use incorrectly; for example, it requires that `x` is a pointer\n+(unlike `transmute`)."}, {"sha": "de165b70fc4028d5846fa4bc8384bc21dea0d966", "filename": "src/doc/trpl/slice-patterns.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslice-patterns.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -16,3 +16,27 @@ fn main() {\n }\n ```\n \n+The `advanced_slice_patterns` gate lets you use `..` to indicate any number of\n+elements inside a pattern matching a slice. This wildcard can only be used once\n+for a given array. If there's an identifier before the `..`, the result of the\n+slice will be bound to that name. For example:\n+\n+```rust\n+#![feature(advanced_slice_patterns, slice_patterns)]\n+\n+fn is_symmetric(list: &[u32]) -> bool {\n+    match list {\n+        [] | [_] => true,\n+        [x, inside.., y] if x == y => is_symmetric(inside),\n+        _ => false\n+    }\n+}\n+\n+fn main() {\n+    let sym = &[0, 1, 4, 2, 4, 1, 0];\n+    assert!(is_symmetric(sym));\n+\n+    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n+    assert!(!is_symmetric(not_sym));\n+}\n+```"}, {"sha": "6ed4c7cb1b379bea10ec9e1d1e1546cb965ed1c9", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 91, "deletions": 23, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,36 +1,34 @@\n % Strings\n \n-Strings are an important concept for any programmer to master. Rust's string\n+Strings are an important concept for any programmer to master. Rust\u2019s string\n handling system is a bit different from other languages, due to its systems\n focus. Any time you have a data structure of variable size, things can get\n-tricky, and strings are a re-sizable data structure. That being said, Rust's\n+tricky, and strings are a re-sizable data structure. That being said, Rust\u2019s\n strings also work differently than in some other systems languages, such as C.\n \n-Let's dig into the details. A *string* is a sequence of Unicode scalar values\n-encoded as a stream of UTF-8 bytes. All strings are guaranteed to be\n-validly encoded UTF-8 sequences. Additionally, strings are not null-terminated\n-and can contain null bytes.\n+Let\u2019s dig into the details. A \u2018string\u2019 is a sequence of Unicode scalar values\n+encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid\n+encoding of UTF-8 sequences. Additionally, unlike some systems languages,\n+strings are not null-terminated and can contain null bytes.\n \n-Rust has two main types of strings: `&str` and `String`.\n+Rust has two main types of strings: `&str` and `String`. Let\u2019s talk about\n+`&str` first. These are called \u2018string slices\u2019. String literals are of the type\n+`&'static str`:\n \n-The first kind is a `&str`. These are called *string slices*. String literals\n-are of the type `&str`:\n-\n-```{rust}\n-let string = \"Hello there.\"; // string: &str\n+```rust\n+let string = \"Hello there.\"; // string: &'static str\n ```\n \n-This string is statically allocated, meaning that it's saved inside our\n+This string is statically allocated, meaning that it\u2019s saved inside our\n compiled program, and exists for the entire duration it runs. The `string`\n binding is a reference to this statically allocated string. String slices\n have a fixed size, and cannot be mutated.\n \n-A `String`, on the other hand, is a heap-allocated string. This string\n-is growable, and is also guaranteed to be UTF-8. `String`s are\n-commonly created by converting from a string slice using the\n-`to_string` method.\n+A `String`, on the other hand, is a heap-allocated string. This string is\n+growable, and is also guaranteed to be UTF-8. `String`s are commonly created by\n+converting from a string slice using the `to_string` method.\n \n-```{rust}\n+```rust\n let mut s = \"Hello\".to_string(); // mut s: String\n println!(\"{}\", s);\n \n@@ -54,8 +52,78 @@ fn main() {\n Viewing a `String` as a `&str` is cheap, but converting the `&str` to a\n `String` involves allocating memory. No reason to do that unless you have to!\n \n-That's the basics of strings in Rust! They're probably a bit more complicated\n-than you are used to, if you come from a scripting language, but when the\n-low-level details matter, they really matter. Just remember that `String`s\n-allocate memory and control their data, while `&str`s are a reference to\n-another string, and you'll be all set.\n+## Indexing\n+\n+Because strings are valid UTF-8, strings do not support indexing:\n+\n+```rust,ignore\n+let s = \"hello\";\n+\n+println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n+```\n+\n+Usually, access to a vector with `[]` is very fast. But, because each character\n+in a UTF-8 encoded string can be multiple bytes, you have to walk over the\n+string to find the n\u1d57\u02b0 letter of a string. This is a significantly more\n+expensive operation, and we don\u2019t want to be misleading. Furthermore, \u2018letter\u2019\n+isn\u2019t something defined in Unicode, exactly. We can choose to look at a string as\n+individual bytes, or as codepoints:\n+\n+```rust\n+let hachiko = \"\u5fe0\u72ac\u30cf\u30c1\u516c\";\n+\n+for b in hachiko.as_bytes() {\n+print!(\"{}, \", b);\n+}\n+\n+println!(\"\");\n+\n+for c in hachiko.chars() {\n+print!(\"{}, \", c);\n+}\n+\n+println!(\"\");\n+```\n+\n+This prints:\n+\n+```text\n+229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, \n+\u5fe0, \u72ac, \u30cf, \u30c1, \u516c, \n+```\n+\n+As you can see, there are more bytes than `char`s.\n+\n+You can get something similar to an index like this:\n+\n+```rust\n+# let hachiko = \"\u5fe0\u72ac\u30cf\u30c1\u516c\";\n+let dog = hachiko.chars().nth(1); // kinda like hachiko[1]\n+```\n+\n+This emphasizes that we have to go through the whole list of `chars`.\n+\n+## Concatenation\n+\n+If you have a `String`, you can concatenate a `&str` to the end of it:\n+\n+```rust\n+let hello = \"Hello \".to_string();\n+let world = \"world!\";\n+\n+let hello_world = hello + world;\n+```\n+\n+But if you have two `String`s, you need an `&`:\n+\n+```rust\n+let hello = \"Hello \".to_string();\n+let world = \"world!\".to_string();\n+\n+let hello_world = hello + &world;\n+```\n+\n+This is because `&String` can automatically coerece to a `&str`. This is a\n+feature called \u2018[`Deref` coercions][dc]\u2019.\n+\n+[dc]: deref-coercions.html"}, {"sha": "ff249d6043c102039601ae04257c4835182458d8", "filename": "src/doc/trpl/structs.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,6 +1,6 @@\n % Structs\n \n-Structs are a way of creating more complex datatypes. For example, if we were\n+Structs are a way of creating more complex data types. For example, if we were\n doing calculations involving coordinates in 2D space, we would need both an `x`\n and a `y` value:\n \n@@ -24,12 +24,12 @@ fn main() {\n }\n ```\n \n-There\u2019s a lot going on here, so let\u2019s break it down. We declare a struct with\n-the `struct` keyword, and then with a name. By convention, structs begin with a\n-capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n+There\u2019s a lot going on here, so let\u2019s break it down. We declare a `struct` with\n+the `struct` keyword, and then with a name. By convention, `struct`s begin with\n+a capital letter and are camel cased: `PointInSpace`, not `Point_In_Space`.\n \n We can create an instance of our struct via `let`, as usual, but we use a `key:\n-value` style syntax to set each field. The order doesn't need to be the same as\n+value` style syntax to set each field. The order doesn\u2019t need to be the same as\n in the original declaration.\n \n Finally, because fields have names, we can access the field through dot"}, {"sha": "7330e42ccf689dd8cbf1fb18d0fac01897c19d79", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 100, "deletions": 188, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,10 +1,9 @@\n % Traits\n \n-Do you remember the `impl` keyword, used to call a function with method\n-syntax?\n+Do you remember the `impl` keyword, used to call a function with [method\n+syntax][methodsyntax]?\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -18,11 +17,12 @@ impl Circle {\n }\n ```\n \n+[methodsyntax]: method-syntax.html\n+\n Traits are similar, except that we define a trait with just the method\n signature, then implement the trait for that struct. Like this:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -41,20 +41,13 @@ impl HasArea for Circle {\n ```\n \n As you can see, the `trait` block looks very similar to the `impl` block,\n-but we don't define a body, just a type signature. When we `impl` a trait,\n+but we don\u2019t define a body, just a type signature. When we `impl` a trait,\n we use `impl Trait for Item`, rather than just `impl Item`.\n \n-So what's the big deal? Remember the error we were getting with our generic\n-`inverse` function?\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n We can use traits to constrain our generics. Consider this function, which\n does not compile, and gives us a similar error:\n \n-```{rust,ignore}\n+```rust,ignore\n fn print_area<T>(shape: T) {\n     println!(\"This shape has an area of {}\", shape.area());\n }\n@@ -66,11 +59,11 @@ Rust complains:\n error: type `T` does not implement any method in scope named `area`\n ```\n \n-Because `T` can be any type, we can't be sure that it implements the `area`\n-method. But we can add a *trait constraint* to our generic `T`, ensuring\n+Because `T` can be any type, we can\u2019t be sure that it implements the `area`\n+method. But we can add a \u2018trait constraint\u2019 to our generic `T`, ensuring\n that it does:\n \n-```{rust}\n+```rust\n # trait HasArea {\n #     fn area(&self) -> f64;\n # }\n@@ -83,10 +76,9 @@ The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n Because traits define function type signatures, we can be sure that any type\n which implements `HasArea` will have an `.area()` method.\n \n-Here's an extended example of how this works:\n+Here\u2019s an extended example of how this works:\n \n-```{rust}\n-# #![feature(core)]\n+```rust\n trait HasArea {\n     fn area(&self) -> f64;\n }\n@@ -144,10 +136,10 @@ This shape has an area of 3.141593\n This shape has an area of 1\n ```\n \n-As you can see, `print_area` is now generic, but also ensures that we\n-have passed in the correct types. If we pass in an incorrect type:\n+As you can see, `print_area` is now generic, but also ensures that we have\n+passed in the correct types. If we pass in an incorrect type:\n \n-```{rust,ignore}\n+```rust,ignore\n print_area(5);\n ```\n \n@@ -157,11 +149,11 @@ We get a compile-time error:\n error: failed to find an implementation of trait main::HasArea for int\n ```\n \n-So far, we've only added trait implementations to structs, but you can\n-implement a trait for any type. So technically, we _could_ implement\n-`HasArea` for `i32`:\n+So far, we\u2019ve only added trait implementations to structs, but you can\n+implement a trait for any type. So technically, we _could_ implement `HasArea`\n+for `i32`:\n \n-```{rust}\n+```rust\n trait HasArea {\n     fn area(&self) -> f64;\n }\n@@ -181,102 +173,57 @@ It is considered poor style to implement methods on such primitive types, even\n though it is possible.\n \n This may seem like the Wild West, but there are two other restrictions around\n-implementing traits that prevent this from getting out of hand. First, traits\n-must be `use`d in any scope where you wish to use the trait's method. So for\n-example, this does not work:\n+implementing traits that prevent this from getting out of hand. The first is\n+that if the trait isn\u2019t defined in your scope, it doesn\u2019t apply. Here\u2019s an\n+example: the standard library provides a [`Write`][write] trait which adds\n+extra functionality to `File`s, for doing file I/O. By default, a `File`\n+won\u2019t have its methods:\n \n-```{rust,ignore}\n-mod shapes {\n-    use std::f64::consts;\n+[write]: ../std/io/trait.Write.html\n \n-    trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    struct Circle {\n-        x: f64,\n-        y: f64,\n-        radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n-\n-    println!(\"{}\", c.area());\n-}\n+```rust,ignore\n+let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n+let result = f.write(\"whatever\".as_bytes());\n+# result.unwrap(); // ignore the erorr\n ```\n \n-Now that we've moved the structs and traits into their own module, we get an\n-error:\n+Here\u2019s the error:\n \n ```text\n-error: type `shapes::Circle` does not implement any method in scope named `area`\n-```\n+error: type `std::fs::File` does not implement any method in scope named `write`\n \n-If we add a `use` line right above `main` and make the right things public,\n-everything is fine:\n-\n-```{rust}\n-# #![feature(core)]\n-mod shapes {\n-    use std::f64::consts;\n-\n-    pub trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    pub struct Circle {\n-        pub x: f64,\n-        pub y: f64,\n-        pub radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n+let result = f.write(b\u201dwhatever\u201d);\n+               ^~~~~~~~~~~~~~~~~~\n+```\n \n-use shapes::HasArea;\n+We need to `use` the `Write` trait first:\n \n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n+```rust,ignore\n+use std::io::Write;\n \n-    println!(\"{}\", c.area());\n-}\n+let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n+let result = f.write(\"whatever\".as_bytes());\n+# result.unwrap(); // ignore the erorr\n ```\n \n+This will compile without error.\n+\n This means that even if someone does something bad like add methods to `int`,\n-it won't affect you, unless you `use` that trait.\n+it won\u2019t affect you, unless you `use` that trait.\n \n-There's one more restriction on implementing traits. Either the trait or the\n-type you're writing the `impl` for must be inside your crate. So, we could\n-implement the `HasArea` type for `i32`, because `HasArea` is in our crate.  But\n+There\u2019s one more restriction on implementing traits. Either the trait or the\n+type you\u2019re writing the `impl` for must be defined by you. So, we could\n+implement the `HasArea` type for `i32`, because `HasArea` is in our code. But\n if we tried to implement `Float`, a trait provided by Rust, for `i32`, we could\n-not, because both the trait and the type aren't in our crate.\n+not, because neither the trait nor the type are in our code.\n \n One last thing about traits: generic functions with a trait bound use\n-*monomorphization* (*mono*: one, *morph*: form), so they are statically\n-dispatched. What's that mean? Check out the chapter on [trait\n-objects](trait-objects.html) for more.\n+\u2018monomorphization\u2019 (mono: one, morph: form), so they are statically dispatched.\n+What\u2019s that mean? Check out the chapter on [trait objects][to] for more details.\n+\n+[to]: trait-objects.html\n \n-## Multiple trait bounds\n+# Multiple trait bounds\n \n You\u2019ve seen that you can bound a generic type parameter with a trait:\n \n@@ -299,10 +246,10 @@ fn foo<T: Clone + Debug>(x: T) {\n \n `T` now needs to be both `Clone` as well as `Debug`.\n \n-## Where clause\n+# Where clause\n \n Writing functions with only a few generic types and a small number of trait\n-bounds isn't too bad, but as the number increases, the syntax gets increasingly\n+bounds isn\u2019t too bad, but as the number increases, the syntax gets increasingly\n awkward:\n \n ```\n@@ -318,7 +265,7 @@ fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n The name of the function is on the far left, and the parameter list is on the\n far right. The bounds are getting in the way.\n \n-Rust has a solution, and it's called a '`where` clause':\n+Rust has a solution, and it\u2019s called a \u2018`where` clause\u2019:\n \n ```\n use std::fmt::Debug;\n@@ -389,84 +336,9 @@ This shows off the additional feature of `where` clauses: they allow bounds\n where the left-hand side is an arbitrary type (`i32` in this case), not just a\n plain type parameter (like `T`).\n \n-## Our `inverse` Example\n-\n-Back in [Generics](generics.html), we were trying to write code like this:\n-\n-```{rust,ignore}\n-fn inverse<T>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-If we try to compile it, we get this error:\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n-This is because `T` is too generic: we don't know if a random `T` can be\n-compared. For that, we can use trait bounds. It doesn't quite work, but try\n-this:\n-\n-```{rust,ignore}\n-fn inverse<T: PartialEq>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-You should get this error:\n-\n-```text\n-error: mismatched types:\n- expected `T`,\n-    found `_`\n-(expected type parameter,\n-    found floating-point variable)\n-```\n-\n-So this won't work. While our `T` is `PartialEq`, we expected to have another `T`,\n-but instead, we found a floating-point variable. We need a different bound. `Float`\n-to the rescue:\n-\n-```\n-# #![feature(std_misc)]\n-use std::num::Float;\n-\n-fn inverse<T: Float>(x: T) -> Result<T, String> {\n-    if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n-\n-    let one: T = Float::one();\n-    Ok(one / x)\n-}\n-```\n-\n-We've had to replace our generic `0.0` and `1.0` with the appropriate methods\n-from the `Float` trait. Both `f32` and `f64` implement `Float`, so our function\n-works just fine:\n-\n-```\n-# #![feature(std_misc)]\n-# use std::num::Float;\n-# fn inverse<T: Float>(x: T) -> Result<T, String> {\n-#     if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n-#     let one: T = Float::one();\n-#     Ok(one / x)\n-# }\n-println!(\"the inverse of {} is {:?}\", 2.0f32, inverse(2.0f32));\n-println!(\"the inverse of {} is {:?}\", 2.0f64, inverse(2.0f64));\n-\n-println!(\"the inverse of {} is {:?}\", 0.0f32, inverse(0.0f32));\n-println!(\"the inverse of {} is {:?}\", 0.0f64, inverse(0.0f64));\n-```\n-\n-## Default methods\n+# Default methods\n \n-There's one last feature of traits we should cover: default methods. It's\n+There\u2019s one last feature of traits we should cover: default methods. It\u2019s\n easiest just to show an example:\n \n ```rust\n@@ -477,8 +349,8 @@ trait Foo {\n }\n ```\n \n-Implementors of the `Foo` trait need to implement `bar()`, but they don't\n-need to implement `baz()`. They'll get this default behavior. They can\n+Implementors of the `Foo` trait need to implement `bar()`, but they don\u2019t\n+need to implement `baz()`. They\u2019ll get this default behavior. They can\n override the default if they so choose:\n \n ```rust\n@@ -506,3 +378,43 @@ default.baz(); // prints \"We called baz.\"\n let over = OverrideDefault;\n over.baz(); // prints \"Override baz!\"\n ```\n+\n+# Inheritance\n+\n+Sometimes, implementing a trait requires implementing another trait:\n+\n+```rust\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+trait FooBar : Foo {\n+    fn foobar(&self);\n+}\n+```\n+\n+Implementors of `FooBar` must also implement `Foo`, like this:\n+\n+```rust\n+# trait Foo {\n+#     fn foo(&self);\n+# }\n+# trait FooBar : Foo {\n+#     fn foobar(&self);\n+# }\n+struct Baz;\n+\n+impl Foo for Baz {\n+    fn foo(&self) { println!(\"foo\"); }\n+}\n+\n+impl FooBar for Baz {\n+    fn foobar(&self) { println!(\"foobar\"); }\n+}\n+```\n+\n+If we forget to implement `Foo`, Rust will tell us:\n+\n+```text\n+error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]\n+```"}, {"sha": "ab5e8ed16ad2328e25d908046a48f60930ceb408", "filename": "src/doc/trpl/unsafe-code.md", "status": "modified", "additions": 113, "deletions": 168, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe-code.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,183 +1,128 @@\n % Unsafe Code\n \n-# Introduction\n-\n-Rust aims to provide safe abstractions over the low-level details of\n-the CPU and operating system, but sometimes one needs to drop down and\n-write code at that level. This guide aims to provide an overview of\n-the dangers and power one gets with Rust's unsafe subset.\n-\n-Rust provides an escape hatch in the form of the `unsafe { ... }`\n-block which allows the programmer to dodge some of the compiler's\n-checks and do a wide range of operations, such as:\n-\n-- dereferencing [raw pointers](#raw-pointers)\n-- calling a function via FFI ([covered by the FFI guide](ffi.html))\n-- casting between types bitwise (`transmute`, aka \"reinterpret cast\")\n-- [inline assembly](#inline-assembly)\n-\n-Note that an `unsafe` block does not relax the rules about lifetimes\n-of `&` and the freezing of borrowed data.\n-\n-Any use of `unsafe` is the programmer saying \"I know more than you\" to\n-the compiler, and, as such, the programmer should be very sure that\n-they actually do know more about why that piece of code is valid.  In\n-general, one should try to minimize the amount of unsafe code in a\n-code base; preferably by using the bare minimum `unsafe` blocks to\n-build safe interfaces.\n-\n-> **Note**: the low-level details of the Rust language are still in\n-> flux, and there is no guarantee of stability or backwards\n-> compatibility. In particular, there may be changes that do not cause\n-> compilation errors, but do cause semantic changes (such as invoking\n-> undefined behaviour). As such, extreme care is required.\n-\n-# Pointers\n-\n-## References\n-\n-One of Rust's biggest features is memory safety.  This is achieved in\n-part via [the ownership system](ownership.html), which is how the\n-compiler can guarantee that every `&` reference is always valid, and,\n-for example, never pointing to freed memory.\n-\n-These restrictions on `&` have huge advantages. However, they also\n-constrain how we can use them. For example, `&` doesn't behave\n-identically to C's pointers, and so cannot be used for pointers in\n-foreign function interfaces (FFI). Additionally, both immutable (`&`)\n-and mutable (`&mut`) references have some aliasing and freezing\n-guarantees, required for memory safety.\n-\n-In particular, if you have an `&T` reference, then the `T` must not be\n-modified through that reference or any other reference. There are some\n-standard library types, e.g. `Cell` and `RefCell`, that provide inner\n-mutability by replacing compile time guarantees with dynamic checks at\n-runtime.\n-\n-An `&mut` reference has a different constraint: when an object has an\n-`&mut T` pointing into it, then that `&mut` reference must be the only\n-such usable path to that object in the whole program. That is, an\n-`&mut` cannot alias with any other references.\n-\n-Using `unsafe` code to incorrectly circumvent and violate these\n-restrictions is undefined behaviour. For example, the following\n-creates two aliasing `&mut` pointers, and is invalid.\n-\n-```\n-use std::mem;\n-let mut x: u8 = 1;\n-\n-let ref_1: &mut u8 = &mut x;\n-let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };\n-\n-// oops, ref_1 and ref_2 point to the same piece of data (x) and are\n-// both usable\n-*ref_1 = 10;\n-*ref_2 = 20;\n+Rust\u2019s main draw is its powerful static guarantees about behavior. But safety\n+checks are conservative by nature: there are some programs that are actually\n+safe, but the compiler is not able to verify this is true. To write these kinds\n+of programs, we need to tell the compiler to relax its restrictions a bit. For\n+this, Rust has a keyword, `unsafe`. Code using `unsafe` has less restrictions\n+than normal code does.\n+\n+Let\u2019s go over the syntax, and then we\u2019ll talk semantics. `unsafe` is used in\n+two contexts. The first one is to mark a function as unsafe:\n+\n+```rust\n+unsafe fn danger_will_robinson() {\n+    // scary stuff \n+}\n ```\n \n-## Raw pointers\n-\n-Rust offers two additional pointer types (*raw pointers*), written as\n-`*const T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n-respectively; indeed, one of their most common uses is for FFI,\n-interfacing with external C libraries.\n-\n-Raw pointers have much fewer guarantees than other pointer types\n-offered by the Rust language and libraries. For example, they\n-\n-- are not guaranteed to point to valid memory and are not even\n-  guaranteed to be non-null (unlike both `Box` and `&`);\n-- do not have any automatic clean-up, unlike `Box`, and so require\n-  manual resource management;\n-- are plain-old-data, that is, they don't move ownership, again unlike\n-  `Box`, hence the Rust compiler cannot protect against bugs like\n-  use-after-free;\n-- lack any form of lifetimes, unlike `&`, and so the compiler cannot\n-  reason about dangling pointers; and\n-- have no guarantees about aliasing or mutability other than mutation\n-  not being allowed directly through a `*const T`.\n-\n-Fortunately, they come with a redeeming feature: the weaker guarantees\n-mean weaker restrictions. The missing restrictions make raw pointers\n-appropriate as a building block for implementing things like smart\n-pointers and vectors inside libraries. For example, `*` pointers are\n-allowed to alias, allowing them to be used to write shared-ownership\n-types like reference counted and garbage collected pointers, and even\n-thread-safe shared memory types (`Rc` and the `Arc` types are both\n-implemented entirely in Rust).\n-\n-There are two things that you are required to be careful about\n-(i.e. require an `unsafe { ... }` block) with raw pointers:\n-\n-- dereferencing: they can have any value: so possible results include\n-  a crash, a read of uninitialised memory, a use-after-free, or\n-  reading data as normal.\n-- pointer arithmetic via the `offset` [intrinsic](#intrinsics) (or\n-  `.offset` method): this intrinsic uses so-called \"in-bounds\"\n-  arithmetic, that is, it is only defined behaviour if the result is\n-  inside (or one-byte-past-the-end) of the object from which the\n-  original pointer came.\n-\n-The latter assumption allows the compiler to optimize more\n-effectively. As can be seen, actually *creating* a raw pointer is not\n-unsafe, and neither is converting to an integer.\n-\n-### References and raw pointers\n-\n-At runtime, a raw pointer `*` and a reference pointing to the same\n-piece of data have an identical representation. In fact, an `&T`\n-reference will implicitly coerce to an `*const T` raw pointer in safe code\n-and similarly for the `mut` variants (both coercions can be performed\n-explicitly with, respectively, `value as *const T` and `value as *mut T`).\n-\n-Going the opposite direction, from `*const` to a reference `&`, is not\n-safe. A `&T` is always valid, and so, at a minimum, the raw pointer\n-`*const T` has to point to a valid instance of type `T`. Furthermore,\n-the resulting pointer must satisfy the aliasing and mutability laws of\n-references. The compiler assumes these properties are true for any\n-references, no matter how they are created, and so any conversion from\n-raw pointers is asserting that they hold. The programmer *must*\n-guarantee this.\n-\n-The recommended method for the conversion is\n+All functions called from [FFI][ffi] must be marked as `unsafe`, for example.\n+The second use of `unsafe` is an unsafe block:\n \n-```\n-let i: u32 = 1;\n-// explicit cast\n-let p_imm: *const u32 = &i as *const u32;\n-let mut m: u32 = 2;\n-// implicit coercion\n-let p_mut: *mut u32 = &mut m;\n+[ffi]: ffi.html\n \n+```rust\n unsafe {\n-    let ref_imm: &u32 = &*p_imm;\n-    let ref_mut: &mut u32 = &mut *p_mut;\n+    // scary stuff\n }\n ```\n \n-The `&*x` dereferencing style is preferred to using a `transmute`.\n-The latter is far more powerful than necessary, and the more\n-restricted operation is harder to use incorrectly; for example, it\n-requires that `x` is a pointer (unlike `transmute`).\n+It\u2019s important to be able to explicitly delineate code that may have bugs that\n+cause big problems. If a Rust program segfaults, you can be sure it\u2019s somewhere\n+in the sections marked `unsafe`.\n+\n+# What does \u2018safe\u2019 mean?\n+\n+Safe, in the context of Rust, means \u201cdoesn\u2019t do anything unsafe.\u201d Easy!\n+\n+Okay, let\u2019s try again: what is not safe to do? Here\u2019s a list:\n+\n+* Data races\n+* Dereferencing a null/dangling raw pointer\n+* Reads of [undef][undef] (uninitialized) memory\n+* Breaking the [pointer aliasing rules][aliasing] with raw pointers.\n+* `&mut T` and `&T` follow LLVM\u2019s scoped [noalias][noalias] model, except if\n+  the `&T` contains an `UnsafeCell<U>`. Unsafe code must not violate these\n+  aliasing guarantees.\n+* Mutating an immutable value/reference without `UnsafeCell<U>`\n+* Invoking undefined behavior via compiler intrinsics:\n+  * Indexing outside of the bounds of an object with `std::ptr::offset`\n+    (`offset` intrinsic), with\n+    the exception of one byte past the end which is permitted.\n+  * Using `std::ptr::copy_nonoverlapping_memory` (`memcpy32`/`memcpy64`\n+    intrinsics) on overlapping buffers\n+* Invalid values in primitive types, even in private fields/locals:\n+  * Null/dangling references or boxes\n+  * A value other than `false` (0) or `true` (1) in a `bool`\n+  * A discriminant in an `enum` not included in its type definition\n+  * A value in a `char` which is a surrogate or above `char::MAX`\n+  * Non-UTF-8 byte sequences in a `str`\n+* Unwinding into Rust from foreign code or unwinding from Rust into foreign\n+  code.\n+\n+[noalias]: http://llvm.org/docs/LangRef.html#noalias\n+[undef]: http://llvm.org/docs/LangRef.html#undefined-values\n+[aliasing]: http://llvm.org/docs/LangRef.html#pointer-aliasing-rules\n+\n+Whew! That\u2019s a bunch of stuff. It\u2019s also important to notice all kinds of\n+behaviors that are certainly bad, but are expressly _not_ unsafe:\n+\n+* Deadlocks\n+* Reading data from private fields\n+* Leaks due to reference count cycles\n+* Exiting without calling destructors\n+* Sending signals\n+* Accessing/modifying the file system\n+* Integer overflow\n+\n+Rust cannot prevent all kinds of software problems. Buggy code can and will be\n+written in Rust. These things arne\u2019t great, but they don\u2019t qualify as `unsafe`\n+specifically.\n+\n+# Unsafe Superpowers\n+\n+In both unsafe functions and unsafe blocks, Rust will let you do three things\n+that you normally can not do. Just three. Here they are:\n+\n+1. Access or update a [static mutable variable][static].\n+2. Dereference a raw pointer.\n+3. Call unsafe functions. This is the most powerful ability.\n+\n+That\u2019s it. It\u2019s important that `unsafe` does not, for example, \u2018turn off the\n+borrow checker\u2019. Adding `unsafe` to some random Rust code doesn\u2019t change its\n+semantics, it won\u2019t just start accepting anything.\n+\n+But it will let you write things that _do_ break some of the rules. Let\u2019s go\n+over these three abilities in order.\n+\n+## Access or update a `static mut`\n+\n+Rust has a feature called \u2018`static mut`\u2019 which allows for mutable global state.\n+Doing so can cause a data race, and as such is inherently not safe. For more\n+details, see the [static][static] section of the book.\n+\n+[static]: static.html\n+\n+## Dereference a raw pointer\n+\n+Raw pointers let you do arbitrary pointer arithmetic, and can cause a number of\n+different memory safety and security issues. In some senses, the ability to\n+dereference an arbitrary pointer is one of the most dangerous things you can\n+do. For more on raw pointers, see [their section of the book][rawpointers].\n+\n+[rawpointers]: raw-pointers.html\n \n+## Call unsafe functions\n \n+This last ability works with both aspects of `unsafe`: you can only call\n+functions marked `unsafe` from inside an unsafe block.\n \n-## Making the unsafe safe(r)\n+This ability is powerful and varied. Rust exposes some [compiler\n+intrinsics][intrinsics] as unsafe functions, and some unsafe functions bypass\n+safety checks, trading safety for speed.\n \n-There are various ways to expose a safe interface around some unsafe\n-code:\n+I\u2019ll repeat again: even though you _can_ do arbitrary things in unsafe blocks\n+and functions doesn\u2019t mean you should. The compiler will act as though you\u2019re\n+upholding its invariants, so be careful!\n \n-- store pointers privately (i.e. not in public fields of public\n-  structs), so that you can see and control all reads and writes to\n-  the pointer in one place.\n-- use `assert!()` a lot: since you can't rely on the protection of the\n-  compiler & type-system to ensure that your `unsafe` code is correct\n-  at compile-time, use `assert!()` to verify that it is doing the\n-  right thing at run-time.\n-- implement the `Drop` for resource clean-up via a destructor, and use\n-  RAII (Resource Acquisition Is Initialization). This reduces the need\n-  for any manual memory management by users, and automatically ensures\n-  that clean-up is always run, even when the thread panics.\n-- ensure that any data stored behind a raw pointer is destroyed at the\n-  appropriate time.\n+[intrinsics]: intrinsics.html"}, {"sha": "965cb218c699a1ecec1a4d5a2ed3dc9b675a9b21", "filename": "src/doc/trpl/vectors.md", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fdoc%2Ftrpl%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvectors.md?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -1,37 +1,58 @@\n % Vectors\n \n-A *vector* is a dynamic or \"growable\" array, implemented as the standard\n-library type [`Vec<T>`](../std/vec/) (Where `<T>` is a [Generic](./generics.md)\n-statement). Vectors always allocate their data on the heap. Vectors are to\n-[slices][slices] what [`String`][string] is to `&str`. You can\n-create them with the `vec!` macro:\n-\n-```{rust}\n-let v = vec![1, 2, 3]; // v: Vec<i32>\n-```\n+A \u2018vector\u2019 is a dynamic or \u2018growable\u2019 array, implemented as the standard\n+library type [`Vec<T>`][vec]. That `<T>` is a [generic][generic], meaning we\n+can have vectors of any type. Vectors always allocate their data on the heap.\n+You can create them with the `vec!` macro:\n \n-[slices]: primitive-types.html#slices\n-[string]: strings.html\n+```rust\n+let v = vec![1, 2, 3, 4, 5]; // v: Vec<i32>\n+```\n \n-(Notice that unlike the `println!` macro we've used in the past, we use square\n-brackets `[]` with `vec!`. Rust allows you to use either in either situation,\n+(Notice that unlike the `println!` macro we\u2019ve used in the past, we use square\n+brackets `[]` with `vec!` macro. Rust allows you to use either in either situation,\n this is just convention.)\n \n-There's an alternate form of `vec!` for repeating an initial value:\n+There\u2019s an alternate form of `vec!` for repeating an initial value:\n \n ```\n let v = vec![0; 10]; // ten zeroes\n ```\n \n-You can get the length of, iterate over, and subscript vectors just like\n-arrays. In addition, (mutable) vectors can grow automatically:\n+## Accessing elements\n \n-```{rust}\n-let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>\n+To get the value at a particular index in the vector, we use `[]`s:\n \n-nums.push(4);\n+```rust\n+let v = vec![1, 2, 3, 4, 5];\n \n-println!(\"The length of nums is now {}\", nums.len()); // Prints 4\n+println!(\"The third element of v is {}\", v[2]);\n ```\n \n-Vectors have many more useful methods.\n+The indices count from `0`, so the third element is `v[2]`.\n+\n+## Iterating\n+\n+Once you have a vector, you can iterate through its elements with `for`. There\n+are three versions:\n+\n+```rust\n+let mut v = vec![1, 2, 3, 4, 5];\n+\n+for i in &v {\n+    println!(\"A reference to {}\", i);\n+}\n+\n+for i in &mut v {\n+    println!(\"A mutable reference to {}\", i);\n+}\n+\n+for i in v {\n+    println!(\"Take ownership of the vector and its element {}\", i);\n+}\n+```\n+\n+Vectors have many more useful methods, which you can read about in [their\n+API documentation][vec].\n+\n+[vec]: ../std/vec/index.html"}, {"sha": "3afc34be2cac8dc3cc9edb9a054a32ce90154310", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -103,7 +103,7 @@ use heap::deallocate;\n /// use std::thread;\n ///\n /// fn main() {\n-///     let numbers: Vec<_> = (0..100u32).map(|i| i as f32).collect();\n+///     let numbers: Vec<_> = (0..100u32).collect();\n ///     let shared_numbers = Arc::new(numbers);\n ///\n ///     for _ in 0..10 {"}, {"sha": "009266c3d2c61d9db3a703b987f1abb185874ff3", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -10,14 +10,9 @@\n \n //! A pointer type for heap allocation.\n //!\n-//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n-//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n-//! drop their contents when they go out of scope.\n-//!\n-//! Boxes are useful in two situations: recursive data structures, and\n-//! occasionally when returning data. [The Pointer chapter of the\n-//! Book](../../../book/pointers.html#best-practices-1) explains these cases in\n-//! detail.\n+//! `Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in\n+//! Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of\n+//! scope.\n //!\n //! # Examples\n //!\n@@ -43,6 +38,16 @@\n //! ```\n //!\n //! This will print `Cons(1, Box(Cons(2, Box(Nil))))`.\n+//!\n+//! Recursive structures must be boxed, because if the definition of `Cons` looked like this:\n+//!\n+//! ```rust,ignore\n+//! Cons(T, List<T>),\n+//! ```\n+//!\n+//! It wouldn't work. This is because the size of a `List` depends on how many elements are in the\n+//! list, and so we don't know how much memory to allocate for a `Cons`. By introducing a `Box`,\n+//! which has a defined size, we know how big `Cons` needs to be.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "4c7441b1d2a654534289d69fe672e6364d6657fa", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -133,6 +133,7 @@ const MIN_ALIGN: usize = 16;\n \n #[cfg(feature = \"external_funcs\")]\n mod imp {\n+    #[allow(improper_ctypes)]\n     extern {\n         fn rust_allocate(size: usize, align: usize) -> *mut u8;\n         fn rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);"}, {"sha": "3dc193fdc62f26ad3cb63706ccb435d825152497", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -246,7 +246,7 @@\n //!\n //! ```ignore\n //! format!      // described above\n-//! write!       // first argument is a &mut old_io::Writer, the destination\n+//! write!       // first argument is a &mut io::Write, the destination\n //! writeln!     // same as write but appends a newline\n //! print!       // the format string is printed to the standard output\n //! println!     // same as print but appends a newline"}, {"sha": "dd59ceff577a8c427fc8565761cfdc9697c85157", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -14,27 +14,6 @@\n //! implement comparison operators. Rust programs may implement `PartialOrd` to overload the `<`,\n //! `<=`, `>`, and `>=` operators, and may implement `PartialEq` to overload the `==` and `!=`\n //! operators.\n-//!\n-//! For example, to define a type with a customized definition for the PartialEq operators, you\n-//! could do the following:\n-//!\n-//! ```\n-//! # #![feature(core)]\n-//! struct FuzzyNum {\n-//!     num: i32,\n-//! }\n-//!\n-//! impl PartialEq for FuzzyNum {\n-//!     // Our custom eq allows numbers which are near each other to be equal! :D\n-//!     fn eq(&self, other: &FuzzyNum) -> bool {\n-//!         (self.num - other.num).abs() < 5\n-//!     }\n-//! }\n-//!\n-//! // Now these binary operators will work when applied!\n-//! assert!(FuzzyNum { num: 37 } == FuzzyNum { num: 34 });\n-//! assert!(FuzzyNum { num: 25 } != FuzzyNum { num: 57 });\n-//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "5c862d73537ad7749485bfe5ff5f08e0115a79dc", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -341,7 +341,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n ///\n-/// Created with `str::bytes`\n+/// Created with the method `.bytes()`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<slice::Iter<'a, u8>, BytesDeref>);\n@@ -636,10 +636,10 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n generate_pattern_iterators! {\n     forward:\n-        /// Return type of `str::split()`\n+        /// Created with the method `.split()`.\n         struct Split;\n     reverse:\n-        /// Return type of `str::rsplit()`\n+        /// Created with the method `.rsplit()`.\n         struct RSplit;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -650,10 +650,10 @@ generate_pattern_iterators! {\n \n generate_pattern_iterators! {\n     forward:\n-        /// Return type of `str::split_terminator()`\n+        /// Created with the method `.split_terminator()`.\n         struct SplitTerminator;\n     reverse:\n-        /// Return type of `str::rsplit_terminator()`\n+        /// Created with the method `.rsplit_terminator()`.\n         struct RSplitTerminator;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -696,10 +696,10 @@ impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n \n generate_pattern_iterators! {\n     forward:\n-        /// Return type of `str::splitn()`\n+        /// Created with the method `.splitn()`.\n         struct SplitN;\n     reverse:\n-        /// Return type of `str::rsplitn()`\n+        /// Created with the method `.rsplitn()`.\n         struct RSplitN;\n     stability:\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -730,10 +730,10 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n \n generate_pattern_iterators! {\n     forward:\n-        /// Return type of `str::match_indices()`\n+        /// Created with the method `.match_indices()`.\n         struct MatchIndices;\n     reverse:\n-        /// Return type of `str::rmatch_indices()`\n+        /// Created with the method `.rmatch_indices()`.\n         struct RMatchIndices;\n     stability:\n         #[unstable(feature = \"core\",\n@@ -771,10 +771,10 @@ impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n \n generate_pattern_iterators! {\n     forward:\n-        /// Return type of `str::matches()`\n+        /// Created with the method `.matches()`.\n         struct Matches;\n     reverse:\n-        /// Return type of `str::rmatches()`\n+        /// Created with the method `.rmatches()`.\n         struct RMatches;\n     stability:\n         #[unstable(feature = \"core\", reason = \"type got recently added\")]\n@@ -783,7 +783,7 @@ generate_pattern_iterators! {\n     delegate double ended;\n }\n \n-/// Return type of `str::lines()`\n+/// Created with the method `.lines()`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Lines<'a>(SplitTerminator<'a, char>);\n@@ -811,7 +811,7 @@ impl<'a> DoubleEndedIterator for Lines<'a> {\n     }\n }\n \n-/// Return type of `str::lines_any()`\n+/// Created with the method `.lines_any()`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct LinesAny<'a>(Map<Lines<'a>, LinesAnyMap>);"}, {"sha": "c12ac501c45a2a14fb510dcb90462a4b63610a65", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21c48c3e823ed21266e96779d700946db957a965/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c48c3e823ed21266e96779d700946db957a965/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=21c48c3e823ed21266e96779d700946db957a965", "patch": "@@ -923,6 +923,8 @@ impl NonSnakeCase {\n                 allow_underscore = match c {\n                     '_' if !allow_underscore => return false,\n                     '_' => false,\n+                    // It would be more obvious to use `c.is_lowercase()`,\n+                    // but some characters do not have a lowercase form\n                     c if !c.is_uppercase() => true,\n                     _ => return false,\n                 };"}]}