{"sha": "50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "node_id": "C_kwDOAAsO6NoAKDUwZjE5MmY4NmExMmQ0YjM5ZDhmN2YwNjFmYmQ4ZTBiYTgwMDc5MzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-15T08:37:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-15T08:37:11Z"}, "message": "Auto merge of #9649 - Alexendoo:from-over-into-suggestion, r=llogiq\n\nAdd a suggestion and a note about orphan rules for `from_over_into`\n\nAdds a machine applicable suggestion to convert the `Into` impl into a `From` one to `from_over_into`\n\nAlso adds a note explaining that `impl From<Local> for Foreign` is fine if the `Into` type is foreign\n\nCloses #7444\nAddresses half of #9638\n\nchangelog: [`from_over_into`] Add a suggestion and a note about orphan rules", "tree": {"sha": "d527a401b8761b2fcf51c042499f2587e0162cba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d527a401b8761b2fcf51c042499f2587e0162cba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "html_url": "https://github.com/rust-lang/rust/commit/50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b510557f892abcefcf9813dea79a74c69371e12f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b510557f892abcefcf9813dea79a74c69371e12f", "html_url": "https://github.com/rust-lang/rust/commit/b510557f892abcefcf9813dea79a74c69371e12f"}, {"sha": "4b8df8dc92c9e29ded57e1efa4d11d641e4b0ba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b8df8dc92c9e29ded57e1efa4d11d641e4b0ba7", "html_url": "https://github.com/rust-lang/rust/commit/4b8df8dc92c9e29ded57e1efa4d11d641e4b0ba7"}], "stats": {"total": 400, "additions": 375, "deletions": 25}, "files": [{"sha": "95eda4ea88275b2a270bf0648ab96168d9c88140", "filename": "clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 154, "deletions": 22, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "patch": "@@ -1,11 +1,19 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{meets_msrv, msrvs};\n-use if_chain::if_chain;\n-use rustc_hir as hir;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::macros::span_is_local;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::{meets_msrv, msrvs, path_def_id};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_path, Visitor};\n+use rustc_hir::{\n+    GenericArg, GenericArgs, HirId, Impl, ImplItemKind, ImplItemRef, Item, ItemKind, PatKind, Path, PathSegment, Ty,\n+    TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n+use rustc_span::{Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -54,28 +62,152 @@ impl FromOverInto {\n impl_lint_pass!(FromOverInto => [FROM_OVER_INTO]);\n \n impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !meets_msrv(self.msrv, msrvs::RE_REBALANCING_COHERENCE) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if !meets_msrv(self.msrv, msrvs::RE_REBALANCING_COHERENCE) || !span_is_local(item.span) {\n             return;\n         }\n \n-        if_chain! {\n-            if let hir::ItemKind::Impl{ .. } = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n-            if cx.tcx.is_diagnostic_item(sym::Into, impl_trait_ref.def_id);\n-\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    FROM_OVER_INTO,\n-                    cx.tcx.sess.source_map().guess_head_span(item.span),\n-                    \"an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\",\n-                    None,\n-                    &format!(\"consider to implement `From<{}>` instead\", impl_trait_ref.self_ty()),\n-                );\n-            }\n+        if let ItemKind::Impl(Impl {\n+            of_trait: Some(hir_trait_ref),\n+            self_ty,\n+            items: [impl_item_ref],\n+            ..\n+        }) = item.kind\n+            && let Some(into_trait_seg) = hir_trait_ref.path.segments.last()\n+            // `impl Into<target_ty> for self_ty`\n+            && let Some(GenericArgs { args: [GenericArg::Type(target_ty)], .. }) = into_trait_seg.args\n+            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n+            && cx.tcx.is_diagnostic_item(sym::Into, middle_trait_ref.def_id)\n+        {\n+            span_lint_and_then(\n+                cx,\n+                FROM_OVER_INTO,\n+                cx.tcx.sess.source_map().guess_head_span(item.span),\n+                \"an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\",\n+                |diag| {\n+                    // If the target type is likely foreign mention the orphan rules as it's a common source of confusion\n+                    if path_def_id(cx, target_ty.peel_refs()).map_or(true, |id| !id.is_local()) {\n+                        diag.help(\n+                            \"`impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\\n\\\n+                            https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\"\n+                        );\n+                    }\n+\n+                    let message = format!(\"replace the `Into` implentation with `From<{}>`\", middle_trait_ref.self_ty());\n+                    if let Some(suggestions) = convert_to_from(cx, into_trait_seg, target_ty, self_ty, impl_item_ref) {\n+                        diag.multipart_suggestion(message, suggestions, Applicability::MachineApplicable);\n+                    } else {\n+                        diag.help(message);\n+                    }\n+                },\n+            );\n         }\n     }\n \n     extract_msrv_attr!(LateContext);\n }\n+\n+/// Finds the occurences of `Self` and `self`\n+struct SelfFinder<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    /// Occurences of `Self`\n+    upper: Vec<Span>,\n+    /// Occurences of `self`\n+    lower: Vec<Span>,\n+    /// If any of the `self`/`Self` usages were from an expansion, or the body contained a binding\n+    /// already named `val`\n+    invalid: bool,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SelfFinder<'a, 'tcx> {\n+    type NestedFilter = OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'tcx>, _id: HirId) {\n+        for segment in path.segments {\n+            match segment.ident.name {\n+                kw::SelfLower => self.lower.push(segment.ident.span),\n+                kw::SelfUpper => self.upper.push(segment.ident.span),\n+                _ => continue,\n+            }\n+        }\n+\n+        self.invalid |= path.span.from_expansion();\n+        if !self.invalid {\n+            walk_path(self, path);\n+        }\n+    }\n+\n+    fn visit_name(&mut self, name: Symbol) {\n+        if name == sym::val {\n+            self.invalid = true;\n+        }\n+    }\n+}\n+\n+fn convert_to_from(\n+    cx: &LateContext<'_>,\n+    into_trait_seg: &PathSegment<'_>,\n+    target_ty: &Ty<'_>,\n+    self_ty: &Ty<'_>,\n+    impl_item_ref: &ImplItemRef,\n+) -> Option<Vec<(Span, String)>> {\n+    let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n+    let ImplItemKind::Fn(ref sig, body_id) = impl_item.kind else { return None };\n+    let body = cx.tcx.hir().body(body_id);\n+    let [input] = body.params else { return None };\n+    let PatKind::Binding(.., self_ident, None) = input.pat.kind else { return None };\n+\n+    let from = snippet_opt(cx, self_ty.span)?;\n+    let into = snippet_opt(cx, target_ty.span)?;\n+\n+    let mut suggestions = vec![\n+        // impl Into<T> for U  ->  impl From<T> for U\n+        //      ~~~~                    ~~~~\n+        (into_trait_seg.ident.span, String::from(\"From\")),\n+        // impl Into<T> for U  ->  impl Into<U> for U\n+        //           ~                       ~\n+        (target_ty.span, from.clone()),\n+        // impl Into<T> for U  ->  impl Into<T> for T\n+        //                  ~                       ~\n+        (self_ty.span, into),\n+        // fn into(self) -> T  ->  fn from(self) -> T\n+        //    ~~~~                    ~~~~\n+        (impl_item.ident.span, String::from(\"from\")),\n+        // fn into([mut] self) -> T  ->  fn into([mut] v: T) -> T\n+        //               ~~~~                          ~~~~\n+        (self_ident.span, format!(\"val: {from}\")),\n+        // fn into(self) -> T  ->  fn into(self) -> Self\n+        //                  ~                       ~~~~\n+        (sig.decl.output.span(), String::from(\"Self\")),\n+    ];\n+\n+    let mut finder = SelfFinder {\n+        cx,\n+        upper: Vec::new(),\n+        lower: Vec::new(),\n+        invalid: false,\n+    };\n+    finder.visit_expr(body.value);\n+\n+    if finder.invalid {\n+        return None;\n+    }\n+\n+    // don't try to replace e.g. `Self::default()` with `&[T]::default()`\n+    if !finder.upper.is_empty() && !matches!(self_ty.kind, TyKind::Path(_)) {\n+        return None;\n+    }\n+\n+    for span in finder.upper {\n+        suggestions.push((span, from.clone()));\n+    }\n+    for span in finder.lower {\n+        suggestions.push((span, String::from(\"val\")));\n+    }\n+\n+    Some(suggestions)\n+}"}, {"sha": "e66dc43b0473edcb17a13b2120552039b48675ef", "filename": "tests/ui/from_over_into.fixed", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.fixed?ref=50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+\n+#![warn(clippy::from_over_into)]\n+#![allow(unused)]\n+\n+// this should throw an error\n+struct StringWrapper(String);\n+\n+impl From<String> for StringWrapper {\n+    fn from(val: String) -> Self {\n+        StringWrapper(val)\n+    }\n+}\n+\n+struct SelfType(String);\n+\n+impl From<String> for SelfType {\n+    fn from(val: String) -> Self {\n+        SelfType(String::new())\n+    }\n+}\n+\n+#[derive(Default)]\n+struct X;\n+\n+impl X {\n+    const FOO: &'static str = \"a\";\n+}\n+\n+struct SelfKeywords;\n+\n+impl From<X> for SelfKeywords {\n+    fn from(val: X) -> Self {\n+        let _ = X::default();\n+        let _ = X::FOO;\n+        let _: X = val;\n+\n+        SelfKeywords\n+    }\n+}\n+\n+struct ExplicitPaths(bool);\n+\n+impl core::convert::From<crate::ExplicitPaths> for bool {\n+    fn from(mut val: crate::ExplicitPaths) -> Self {\n+        let in_closure = || val.0;\n+\n+        val.0 = false;\n+        val.0\n+    }\n+}\n+\n+// this is fine\n+struct A(String);\n+\n+impl From<String> for A {\n+    fn from(s: String) -> A {\n+        A(s)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "74c7be6af79e1a5f8df29ca037a8b026406f1a9d", "filename": "tests/ui/from_over_into.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.rs?ref=50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "patch": "@@ -1,4 +1,7 @@\n+// run-rustfix\n+\n #![warn(clippy::from_over_into)]\n+#![allow(unused)]\n \n // this should throw an error\n struct StringWrapper(String);\n@@ -9,6 +12,44 @@ impl Into<StringWrapper> for String {\n     }\n }\n \n+struct SelfType(String);\n+\n+impl Into<SelfType> for String {\n+    fn into(self) -> SelfType {\n+        SelfType(Self::new())\n+    }\n+}\n+\n+#[derive(Default)]\n+struct X;\n+\n+impl X {\n+    const FOO: &'static str = \"a\";\n+}\n+\n+struct SelfKeywords;\n+\n+impl Into<SelfKeywords> for X {\n+    fn into(self) -> SelfKeywords {\n+        let _ = Self::default();\n+        let _ = Self::FOO;\n+        let _: Self = self;\n+\n+        SelfKeywords\n+    }\n+}\n+\n+struct ExplicitPaths(bool);\n+\n+impl core::convert::Into<bool> for crate::ExplicitPaths {\n+    fn into(mut self) -> bool {\n+        let in_closure = || self.0;\n+\n+        self.0 = false;\n+        self.0\n+    }\n+}\n+\n // this is fine\n struct A(String);\n "}, {"sha": "6cf83e258071c9ad7810354cfa482141b3eadc1b", "filename": "tests/ui/from_over_into.stderr", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.stderr?ref=50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "patch": "@@ -1,11 +1,62 @@\n error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n-  --> $DIR/from_over_into.rs:6:1\n+  --> $DIR/from_over_into.rs:9:1\n    |\n LL | impl Into<StringWrapper> for String {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider to implement `From<std::string::String>` instead\n    = note: `-D clippy::from-over-into` implied by `-D warnings`\n+help: replace the `Into` implentation with `From<std::string::String>`\n+   |\n+LL ~ impl From<String> for StringWrapper {\n+LL ~     fn from(val: String) -> Self {\n+LL ~         StringWrapper(val)\n+   |\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into.rs:17:1\n+   |\n+LL | impl Into<SelfType> for String {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace the `Into` implentation with `From<std::string::String>`\n+   |\n+LL ~ impl From<String> for SelfType {\n+LL ~     fn from(val: String) -> Self {\n+LL ~         SelfType(String::new())\n+   |\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into.rs:32:1\n+   |\n+LL | impl Into<SelfKeywords> for X {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace the `Into` implentation with `From<X>`\n+   |\n+LL ~ impl From<X> for SelfKeywords {\n+LL ~     fn from(val: X) -> Self {\n+LL ~         let _ = X::default();\n+LL ~         let _ = X::FOO;\n+LL ~         let _: X = val;\n+   |\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into.rs:44:1\n+   |\n+LL | impl core::convert::Into<bool> for crate::ExplicitPaths {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n+           https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n+help: replace the `Into` implentation with `From<ExplicitPaths>`\n+   |\n+LL ~ impl core::convert::From<crate::ExplicitPaths> for bool {\n+LL ~     fn from(mut val: crate::ExplicitPaths) -> Self {\n+LL ~         let in_closure = || val.0;\n+LL | \n+LL ~         val.0 = false;\n+LL ~         val.0\n+   |\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n "}, {"sha": "3b280b7488ae7c8b1bc79b7215407c9cc8e35492", "filename": "tests/ui/from_over_into_unfixable.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into_unfixable.rs?ref=50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "patch": "@@ -0,0 +1,35 @@\n+#![warn(clippy::from_over_into)]\n+\n+struct InMacro(String);\n+\n+macro_rules! in_macro {\n+    ($e:ident) => {\n+        $e\n+    };\n+}\n+\n+impl Into<InMacro> for String {\n+    fn into(self) -> InMacro {\n+        InMacro(in_macro!(self))\n+    }\n+}\n+\n+struct WeirdUpperSelf;\n+\n+impl Into<WeirdUpperSelf> for &'static [u8] {\n+    fn into(self) -> WeirdUpperSelf {\n+        let _ = Self::default();\n+        WeirdUpperSelf\n+    }\n+}\n+\n+struct ContainsVal;\n+\n+impl Into<u8> for ContainsVal {\n+    fn into(self) -> u8 {\n+        let val = 1;\n+        val + 1\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6f6ce351921be1138cff9de30e36625f2c091ef4", "filename": "tests/ui/from_over_into_unfixable.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f192f86a12d4b39d8f7f061fbd8e0ba8007932/tests%2Fui%2Ffrom_over_into_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into_unfixable.stderr?ref=50f192f86a12d4b39d8f7f061fbd8e0ba8007932", "patch": "@@ -0,0 +1,29 @@\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into_unfixable.rs:11:1\n+   |\n+LL | impl Into<InMacro> for String {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: replace the `Into` implentation with `From<std::string::String>`\n+   = note: `-D clippy::from-over-into` implied by `-D warnings`\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into_unfixable.rs:19:1\n+   |\n+LL | impl Into<WeirdUpperSelf> for &'static [u8] {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: replace the `Into` implentation with `From<&'static [u8]>`\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into_unfixable.rs:28:1\n+   |\n+LL | impl Into<u8> for ContainsVal {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n+           https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n+   = help: replace the `Into` implentation with `From<ContainsVal>`\n+\n+error: aborting due to 3 previous errors\n+"}]}