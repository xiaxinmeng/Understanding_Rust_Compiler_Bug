{"sha": "244f893ed704a60841d4615445d540a21a8d7722", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NGY4OTNlZDcwNGE2MDg0MWQ0NjE1NDQ1ZDU0MGEyMWE4ZDc3MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-20T08:31:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-20T08:31:16Z"}, "message": "Auto merge of #40659 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 9 pull requests\n\n- Successful merges: #40241, #40281, #40398, #40521, #40532, #40554, #40566, #40581, #40587\n- Failed merges:", "tree": {"sha": "ef03d7fdd32204abf7e236da22fb99f85fe7922e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef03d7fdd32204abf7e236da22fb99f85fe7922e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/244f893ed704a60841d4615445d540a21a8d7722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/244f893ed704a60841d4615445d540a21a8d7722", "html_url": "https://github.com/rust-lang/rust/commit/244f893ed704a60841d4615445d540a21a8d7722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/244f893ed704a60841d4615445d540a21a8d7722/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6738cd4d473668f7af381826d634e573d15e1f11", "url": "https://api.github.com/repos/rust-lang/rust/commits/6738cd4d473668f7af381826d634e573d15e1f11", "html_url": "https://github.com/rust-lang/rust/commit/6738cd4d473668f7af381826d634e573d15e1f11"}, {"sha": "d49f86901cf1128cdc00b7a1b276f6bf266bf937", "url": "https://api.github.com/repos/rust-lang/rust/commits/d49f86901cf1128cdc00b7a1b276f6bf266bf937", "html_url": "https://github.com/rust-lang/rust/commit/d49f86901cf1128cdc00b7a1b276f6bf266bf937"}], "stats": {"total": 1848, "additions": 906, "deletions": 942}, "files": [{"sha": "a9a6fabb5b23c5ee95e864d79cef0599bf983f83", "filename": "src/Cargo.lock", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -27,7 +27,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -48,14 +48,24 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"arena\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"atty\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"bitflags\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -65,19 +75,19 @@ dependencies = [\n  \"build_helper 0.1.0\",\n  \"cmake 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -94,25 +104,25 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"clap\"\n-version = \"2.20.5\"\n+version = \"2.21.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vec_map 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cmake\"\n version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -130,7 +140,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -140,7 +150,7 @@ dependencies = [\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -186,7 +196,7 @@ name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -195,7 +205,7 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.43\"\n+version = \"0.3.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -221,7 +231,7 @@ dependencies = [\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -274,7 +284,7 @@ name = \"mdbook\"\n version = \"0.0.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"handlebars 0.25.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -397,11 +407,28 @@ name = \"regex-syntax\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rls-data\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rls-span\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mdbook 0.0.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -435,7 +462,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-serialize\"\n-version = \"0.3.22\"\n+version = \"0.3.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -577,7 +604,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -690,8 +717,10 @@ name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"rls-data 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"serialize 0.0.0\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -751,7 +780,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -799,7 +828,7 @@ dependencies = [\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -904,7 +933,7 @@ name = \"toml\"\n version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -940,7 +969,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"vec_map\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -961,15 +990,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [metadata]\n \"checksum aho-corasick 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0638fd549427caa90c499814196d1b9e3725eb4d15d7339d6de073a680ed0ca2\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n+\"checksum atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d912da0db7fa85514874458ca3651fe2cddace8d0b0505571dbdcd41ab490159\"\n \"checksum bitflags 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f67931368edf3a9a51d29886d245f1c3db2f1ef0dcc9e35ff70341b78c10d23\"\n-\"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n-\"checksum clap 2.20.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7db281b0520e97fbd15cd615dcd8f8bcad0c26f5f7d5effe705f090f39e9a758\"\n+\"checksum bitflags 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e1ab483fc81a8143faa7203c4a3c02888ebd1a782e37e41fa34753ba9a162\"\n+\"checksum clap 2.21.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74a80f603221c9cd9aa27a28f52af452850051598537bb6b359c38a7d61e5cda\"\n \"checksum cmake 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1acc68a3f714627af38f9f5d09706a28584ba60dfe2cca68f40bf779f941b25\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3856f1697098606fc6cb97a93de88ca3f3bc35bb878c725920e6e82ecf05e83\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.43 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c07c758b972368e703a562686adb39125707cc1ef3399da8c019fc6c2498a75d\"\n+\"checksum gcc 0.3.44 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a32cd40070d7611ab76343dcb3204b2bb28c8a9450989a83a3d590248142f439\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum handlebars 0.25.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b2249f6f0dc5a3bb2b3b1a8f797dfccbc4b053344d773d654ad565e51427d335\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n@@ -987,7 +1017,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0aad603e8d7fb67da22dbdf1f4b826ce8829e406124109e73cf1b2454b93a71c\"\n \"checksum regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4278c17d0f6d62dfef0ab00028feb45bd7d2102843f80763474eeb1be8a10c01\"\n \"checksum regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9191b1f57603095f105d317e375d19b1c9c5c3185ea9633a99a6dcbed04457\"\n-\"checksum rustc-serialize 0.3.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"237546c689f20bb44980270c73c3b9edd0891c1be49cc1274406134a66d3957b\"\n+\"checksum rls-data 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"af1dfff00189fd7b78edb9af131b0de703676c04fa8126aed77fd2c586775a4d\"\n+\"checksum rls-span 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8656f7b850ac85fb204ef94318c641bbb15a32766e12f9a589a23e4c0fbc38db\"\n+\"checksum rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"684ce48436d6465300c9ea783b6b14c4361d6b8dcbb1375b486a69cc19e2dfb0\"\n \"checksum serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a702319c807c016e51f672e5c77d6f0b46afddd744b5e437d6b8436b888b458f\"\n \"checksum serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbc45439552eb8fb86907a2c41c1fd0ef97458efb87ff7f878db466eb581824e\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n@@ -1000,7 +1032,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f\"\n \"checksum unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f2ae5ddb18e1c92664717616dd9549dde73f539f01bd7b77c2edb2446bdff91\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n-\"checksum vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cac5efe5cb0fa14ec2f84f83c701c562ee63f6dcc680861b21d65c682adfb05f\"\n+\"checksum vec_map 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8cdc8b93bd0198ed872357fb2e667f7125646b1762f16d60b2c96350d361897\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "62b7f6cb72e3baf51199d72942eb65d069a4fa89", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -94,6 +94,13 @@ fn main() {\n             cmd.arg(\"-Cprefer-dynamic\");\n         }\n \n+        // Pass the `rustbuild` feature flag to crates which rustbuild is\n+        // building. See the comment in bootstrap/lib.rs where this env var is\n+        // set for more details.\n+        if env::var_os(\"RUSTBUILD_UNSTABLE\").is_some() {\n+            cmd.arg(\"--cfg\").arg(\"rustbuild\");\n+        }\n+\n         // Help the libc crate compile by assisting it in finding the MUSL\n         // native libraries.\n         if let Some(s) = env::var_os(\"MUSL_ROOT\") {"}, {"sha": "26f3c063061972a96e3547f1ab0387e4f7bbafba", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -180,7 +180,7 @@ struct Crate {\n ///\n /// These entries currently correspond to the various output directories of the\n /// build system, with each mod generating output in a different directory.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq, Eq)]\n pub enum Mode {\n     /// This cargo is going to build the standard library, placing output in the\n     /// \"stageN-std\" directory.\n@@ -491,14 +491,35 @@ impl Build {\n         // For other crates, however, we know that we've already got a standard\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n-        if let Mode::Libstd = mode {\n+        if mode == Mode::Libstd {\n             cargo.env(\"RUSTC_SNAPSHOT\", &self.rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n             cargo.env(\"RUSTC_SNAPSHOT\", self.compiler_path(compiler))\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n+        // There are two invariants we try must maintain:\n+        // * stable crates cannot depend on unstable crates (general Rust rule),\n+        // * crates that end up in the sysroot must be unstable (rustbuild rule).\n+        //\n+        // In order to do enforce the latter, we pass the env var\n+        // `RUSTBUILD_UNSTABLE` down the line for any crates which will end up\n+        // in the sysroot. We read this in bootstrap/bin/rustc.rs and if it is\n+        // set, then we pass the `rustbuild` feature to rustc when building the\n+        // the crate.\n+        //\n+        // In turn, crates that can be used here should recognise the `rustbuild`\n+        // feature and opt-in to `rustc_private`.\n+        //\n+        // We can't always pass `rustbuild` because crates which are outside of\n+        // the comipiler, libs, and tests are stable and we don't want to make\n+        // their deps unstable (since this would break the first invariant\n+        // above).\n+        if mode != Mode::Tool {\n+            cargo.env(\"RUSTBUILD_UNSTABLE\", \"1\");\n+        }\n+\n         // Ignore incremental modes except for stage0, since we're\n         // not guaranteeing correctness acros builds if the compiler\n         // is changing under your feet.`"}, {"sha": "62a88164621913fd494c67488ce5f1c720dada64", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -367,6 +367,10 @@\n //!         like `{:08}` would yield `00000001` for the integer `1`, while the\n //!         same format would yield `-0000001` for the integer `-1`. Notice that\n //!         the negative version has one fewer zero than the positive version.\n+//!         Note that padding zeroes are always placed after the sign (if any)\n+//!         and before the digits. When used together with the `#` flag, a similar\n+//!         rule applies: padding zeroes are inserted after the prefix but before\n+//!         the digits.\n //!\n //! ## Width\n //!"}, {"sha": "58aba11e4394f6e619c60775d353cb0df68b35c8", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -34,8 +34,8 @@ pub mod reimpls {\n     macro_rules! ashl {\n         ($a:expr, $b:expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(0, a.low().wrapping_shl(\n                                         b.wrapping_sub(half_bits) as u32))\n@@ -58,8 +58,8 @@ pub mod reimpls {\n     macro_rules! ashr {\n         ($a: expr, $b: expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32)\n                                   as <$ty as LargeInt>::LowHalf,\n@@ -83,8 +83,8 @@ pub mod reimpls {\n     macro_rules! lshr {\n         ($a: expr, $b: expr, $ty:ty) => {{\n             let (a, b) = ($a, $b);\n-            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n-            let half_bits = bits >> 1;\n+            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n+            let half_bits = bits.wrapping_shr(1);\n             if b & half_bits != 0 {\n                 <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32), 0)\n             } else if b == 0 {\n@@ -370,7 +370,7 @@ pub mod reimpls {\n     macro_rules! mul {\n         ($a:expr, $b:expr, $ty: ty, $tyh: ty) => {{\n             let (a, b) = ($a, $b);\n-            let half_bits = ((::core::mem::size_of::<$tyh>() * 8) / 2) as u32;\n+            let half_bits = ::core::mem::size_of::<$tyh>().wrapping_mul(4) as u32;\n             let lower_mask = (!0u64).wrapping_shr(half_bits);\n             let mut low = (a.low() & lower_mask).wrapping_mul(b.low() & lower_mask);\n             let mut t = low.wrapping_shr(half_bits);\n@@ -478,7 +478,7 @@ pub mod reimpls {\n             let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n             if sign == -1.0 || exponent < 0 { return 0 as u128; }\n-            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+            if exponent > ::core::mem::size_of::<$outty>().wrapping_mul(8) as i32 {\n                 return !(0 as u128);\n             }\n             (if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n@@ -503,7 +503,7 @@ pub mod reimpls {\n             let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n \n             if exponent < 0 { return 0 as i128; }\n-            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+            if exponent > ::core::mem::size_of::<$outty>().wrapping_mul(8) as i32 {\n                 let ret = if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n                 return ret\n             }"}, {"sha": "0bfab92fa5d5180270491af1fb3e8320b9587da0", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -1045,6 +1045,7 @@ impl<'a> Formatter<'a> {\n             // is zero\n             Some(min) if self.sign_aware_zero_pad() => {\n                 self.fill = '0';\n+                self.align = rt::v1::Alignment::Right;\n                 write_prefix(self)?;\n                 self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                     f.buf.write_str(buf)\n@@ -1153,8 +1154,9 @@ impl<'a> Formatter<'a> {\n             // for the sign-aware zero padding, we render the sign first and\n             // behave as if we had no sign from the beginning.\n             let mut formatted = formatted.clone();\n-            let mut align = self.align;\n             let old_fill = self.fill;\n+            let old_align = self.align;\n+            let mut align = old_align;\n             if self.sign_aware_zero_pad() {\n                 // a sign always goes first\n                 let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n@@ -1165,6 +1167,7 @@ impl<'a> Formatter<'a> {\n                 width = if width < sign.len() { 0 } else { width - sign.len() };\n                 align = rt::v1::Alignment::Right;\n                 self.fill = '0';\n+                self.align = rt::v1::Alignment::Right;\n             }\n \n             // remaining parts go through the ordinary padding process.\n@@ -1177,6 +1180,7 @@ impl<'a> Formatter<'a> {\n                 })\n             };\n             self.fill = old_fill;\n+            self.align = old_align;\n             ret\n         } else {\n             // this is the common case and we take a shortcut"}, {"sha": "f8d067e9696fd560cef0e8cc4cdc20b9bbce7339", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -1238,6 +1238,15 @@ extern \"rust-intrinsic\" {\n     /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n     pub fn unchecked_rem<T>(x: T, y: T) -> T;\n \n+    /// Performs an unchecked left shift, resulting in undefined behavior when\n+    /// y < 0 or y >= N, where N is the width of T in bits.\n+    #[cfg(not(stage0))]\n+    pub fn unchecked_shl<T>(x: T, y: T) -> T;\n+    /// Performs an unchecked right shift, resulting in undefined behavior when\n+    /// y < 0 or y >= N, where N is the width of T in bits.\n+    #[cfg(not(stage0))]\n+    pub fn unchecked_shr<T>(x: T, y: T) -> T;\n+\n     /// Returns (a + b) mod 2^N, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,"}, {"sha": "ccfe6364e6af6785061d76fd31c0b02edef62d39", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 99, "deletions": 18, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -177,7 +177,7 @@ macro_rules! checked_op {\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($ActualT:ident, $UnsignedT:ty, $BITS:expr,\n+    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n@@ -850,6 +850,17 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline(always)]\n+        #[cfg(stage0)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n@@ -875,6 +886,17 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline(always)]\n+        #[cfg(stage0)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n@@ -1089,6 +1111,15 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n             (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -1111,6 +1142,15 @@ macro_rules! int_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -1268,39 +1308,39 @@ macro_rules! int_impl {\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8, u8, 8,\n+    int_impl! { i8, i8, u8, 8,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16, u16, 16,\n+    int_impl! { i16, i16, u16, 16,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32, u32, 32,\n+    int_impl! { i32, i32, u32, 32,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64, u64, 64,\n+    int_impl! { i64, i64, u64, 64,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n #[lang = \"i128\"]\n impl i128 {\n-    int_impl! { i128, u128, 128,\n+    int_impl! { i128, i128, u128, 128,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1309,7 +1349,7 @@ impl i128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i16, u16, 16,\n+    int_impl! { isize, i16, u16, 16,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1318,7 +1358,7 @@ impl isize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i32, u32, 32,\n+    int_impl! { isize, i32, u32, 32,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n@@ -1327,15 +1367,15 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { i64, u64, 64,\n+    int_impl! { isize, i64, u64, 64,\n         intrinsics::add_with_overflow,\n         intrinsics::sub_with_overflow,\n         intrinsics::mul_with_overflow }\n }\n \n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n-    ($ActualT:ty, $BITS:expr,\n+    ($SelfT:ty, $ActualT:ty, $BITS:expr,\n      $ctpop:path,\n      $ctlz:path,\n      $cttz:path,\n@@ -1978,6 +2018,17 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline(always)]\n+        #[cfg(stage0)]\n         pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n@@ -2003,6 +2054,17 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n+        #[cfg(not(stage0))]\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n+        /// Stage 0\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline(always)]\n+        #[cfg(stage0)]\n         pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n@@ -2170,6 +2232,15 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n             (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -2192,6 +2263,16 @@ macro_rules! uint_impl {\n         /// ```\n         #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(not(stage0))]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+\n+        }\n+\n+        /// Stage 0\n+        #[inline]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[cfg(stage0)]\n         pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -2292,7 +2373,7 @@ macro_rules! uint_impl {\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, 8,\n+    uint_impl! { u8, u8, 8,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2304,7 +2385,7 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, 16,\n+    uint_impl! { u16, u16, 16,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2316,7 +2397,7 @@ impl u16 {\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, 32,\n+    uint_impl! { u32, u32, 32,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2328,7 +2409,7 @@ impl u32 {\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, 64,\n+    uint_impl! { u64, u64, 64,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2340,7 +2421,7 @@ impl u64 {\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, 128,\n+    uint_impl! { u128, u128, 128,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2353,7 +2434,7 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u16, 16,\n+    uint_impl! { usize, u16, 16,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2365,7 +2446,7 @@ impl usize {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u32, 32,\n+    uint_impl! { usize, u32, 32,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,\n@@ -2378,7 +2459,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { u64, 64,\n+    uint_impl! { usize, u64, 64,\n         intrinsics::ctpop,\n         intrinsics::ctlz,\n         intrinsics::cttz,"}, {"sha": "a6dad64125331cc4c6ab5d903615fffbe8be4389", "filename": "src/libproc_macro_plugin/lib.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibproc_macro_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibproc_macro_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Flib.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -13,62 +13,64 @@\n //! A library for procedural macro writers.\n //!\n //! ## Usage\n-//! This crate provides the `qquote!` macro for syntax creation.\n+//! This crate provides the `quote!` macro for syntax creation.\n //!\n-//! The `qquote!` macro uses the crate `syntax`, so users must declare `extern crate syntax;`\n+//! The `quote!` macro uses the crate `syntax`, so users must declare `extern crate syntax;`\n //! at the crate root. This is a temporary solution until we have better hygiene.\n //!\n //! ## Quasiquotation\n //!\n //! The quasiquoter creates output that, when run, constructs the tokenstream specified as\n-//! input. For example, `qquote!(5 + 5)` will produce a program, that, when run, will\n+//! input. For example, `quote!(5 + 5)` will produce a program, that, when run, will\n //! construct the TokenStream `5 | + | 5`.\n //!\n //! ### Unquoting\n //!\n-//! Unquoting is currently done as `unquote`, and works by taking the single next\n-//! TokenTree in the TokenStream as the unquoted term. Ergonomically, `unquote(foo)` works\n-//! fine, but `unquote foo` is also supported.\n+//! Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n+//! To quote `$` itself, use `$$`.\n //!\n-//! A simple example might be:\n+//! A simple example is:\n //!\n //!```\n //!fn double(tmp: TokenStream) -> TokenStream {\n-//!    qquote!(unquote(tmp) * 2)\n+//!    quote!($tmp * 2)\n //!}\n //!```\n //!\n-//! ### Large Example: Implementing Scheme's `cond`\n+//! ### Large example: Scheme's `cond`\n //!\n-//! Below is the full implementation of Scheme's `cond` operator.\n+//! Below is an example implementation of Scheme's `cond`.\n //!\n //! ```\n-//! fn cond_rec(input: TokenStream) -> TokenStream {\n-//!   if input.is_empty() { return quote!(); }\n-//!\n-//!   let next = input.slice(0..1);\n-//!   let rest = input.slice_from(1..);\n-//!\n-//!   let clause : TokenStream = match next.maybe_delimited() {\n-//!     Some(ts) => ts,\n-//!     _ => panic!(\"Invalid input\"),\n-//!   };\n-//!\n-//!   // clause is ([test]) [rhs]\n-//!   if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n-//!\n-//!   let test: TokenStream = clause.slice(0..1);\n-//!   let rhs: TokenStream = clause.slice_from(1..);\n-//!\n-//!   if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n-//!     quote!({unquote(rhs)})\n-//!   } else {\n-//!     quote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n-//!   }\n+//! fn cond(input: TokenStream) -> TokenStream {\n+//!     let mut conds = Vec::new();\n+//!     let mut input = input.trees().peekable();\n+//!     while let Some(tree) = input.next() {\n+//!         let mut cond = match tree {\n+//!             TokenTree::Delimited(_, ref delimited) => delimited.stream(),\n+//!             _ => panic!(\"Invalid input\"),\n+//!         };\n+//!         let mut trees = cond.trees();\n+//!         let test = trees.next();\n+//!         let rhs = trees.collect::<TokenStream>();\n+//!         if rhs.is_empty() {\n+//!             panic!(\"Invalid macro usage in cond: {}\", cond);\n+//!         }\n+//!         let is_else = match test {\n+//!             Some(TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"else\" => true,\n+//!             _ => false,\n+//!         };\n+//!         conds.push(if is_else || input.peek().is_none() {\n+//!             quote!({ $rhs })\n+//!         } else {\n+//!             let test = test.unwrap();\n+//!             quote!(if $test { $rhs } else)\n+//!         });\n+//!     }\n+//!\n+//!     conds.into_iter().collect()\n //! }\n //! ```\n-//!\n-\n #![crate_name = \"proc_macro_plugin\"]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n #![feature(plugin_registrar)]\n@@ -87,8 +89,8 @@ extern crate rustc_plugin;\n extern crate syntax;\n extern crate syntax_pos;\n \n-mod qquote;\n-use qquote::qquote;\n+mod quote;\n+use quote::quote;\n \n use rustc_plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n@@ -99,6 +101,6 @@ use syntax::symbol::Symbol;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(Symbol::intern(\"qquote\"),\n-                                  SyntaxExtension::ProcMacro(Box::new(qquote)));\n+    reg.register_syntax_extension(Symbol::intern(\"quote\"),\n+                                  SyntaxExtension::ProcMacro(Box::new(quote)));\n }"}, {"sha": "ad71584b61a0fbf611965a1bc8af7758494f7073", "filename": "src/libproc_macro_plugin/quote.rs", "status": "renamed", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibproc_macro_plugin%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibproc_macro_plugin%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fquote.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::DUMMY_SP;\n \n use std::iter;\n \n-pub fn qquote<'cx>(stream: TokenStream) -> TokenStream {\n+pub fn quote<'cx>(stream: TokenStream) -> TokenStream {\n     stream.quote()\n }\n \n@@ -72,28 +72,32 @@ impl Quote for TokenStream {\n             return quote!(::syntax::tokenstream::TokenStream::empty());\n         }\n \n-        struct Quote(iter::Peekable<tokenstream::Cursor>);\n+        struct Quoter(iter::Peekable<tokenstream::Cursor>);\n \n-        impl Iterator for Quote {\n+        impl Iterator for Quoter {\n             type Item = TokenStream;\n \n             fn next(&mut self) -> Option<TokenStream> {\n-                let is_unquote = match self.0.peek() {\n-                    Some(&TokenTree::Token(_, Token::Ident(ident))) if ident.name == \"unquote\" => {\n-                        self.0.next();\n-                        true\n+                let quoted_tree = if let Some(&TokenTree::Token(_, Token::Dollar)) = self.0.peek() {\n+                    self.0.next();\n+                    match self.0.next() {\n+                        Some(tree @ TokenTree::Token(_, Token::Ident(..))) => Some(tree.into()),\n+                        Some(tree @ TokenTree::Token(_, Token::Dollar)) => Some(tree.quote()),\n+                        // FIXME(jseyfried): improve these diagnostics\n+                        Some(..) => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n+                        None => panic!(\"unexpected trailing `$` in `quote!`\"),\n                     }\n-                    _ => false,\n+                } else {\n+                    self.0.next().as_ref().map(Quote::quote)\n                 };\n \n-                self.0.next().map(|tree| {\n-                    let quoted_tree = if is_unquote { tree.into() } else { tree.quote() };\n+                quoted_tree.map(|quoted_tree| {\n                     quote!(::syntax::tokenstream::TokenStream::from((unquote quoted_tree)),)\n                 })\n             }\n         }\n \n-        let quoted = Quote(self.trees().peekable()).collect::<TokenStream>();\n+        let quoted = Quoter(self.trees().peekable()).collect::<TokenStream>();\n         quote!([(unquote quoted)].iter().cloned().collect::<::syntax::tokenstream::TokenStream>())\n     }\n }", "previous_filename": "src/libproc_macro_plugin/qquote.rs"}, {"sha": "06c5150fd13ade909458604075f3dcacd69a2b9c", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -12,5 +12,8 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n syntax = { path = \"../libsyntax\" }\n-serialize = { path = \"../libserialize\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rls-data = \"0.1\"\n+rls-span = \"0.1\"\n+# FIXME(#40527) should move rustc serialize out of tree\n+rustc-serialize = \"0.3\""}, {"sha": "59340ae87ee5da6e607b7e48ce976efd988b9228", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -13,6 +13,8 @@ use std::io::Write;\n use super::external_data::*;\n use super::dump::Dump;\n \n+use rls_data::{SpanData, CratePreludeData};\n+\n pub struct CsvDumper<'b, W: 'b> {\n     output: &'b mut W\n }\n@@ -429,6 +431,6 @@ fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n fn span_extent_str(span: SpanData) -> String {\n     format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{},\\\n              file_line_end,{},file_col_end,{},byte_end,{}\",\n-             span.file_name, span.line_start, span.column_start, span.byte_start,\n-             span.line_end, span.column_end, span.byte_end)\n+             span.file_name.to_str().unwrap(), span.line_start.0, span.column_start.0,\n+             span.byte_start, span.line_end.0, span.column_end.0, span.byte_end)\n }"}, {"sha": "d4ded71a3339091fa2b53af1e650b0f3770ef25e", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -18,6 +18,8 @@ use rustc::hir::def_id::{CrateNum, DefId};\n use syntax::ast::{self, Attribute, NodeId};\n use syntax_pos::Span;\n \n+use rls_data::ExternalCrateData;\n+\n pub struct CrateData {\n     pub name: String,\n     pub number: u32,\n@@ -26,7 +28,7 @@ pub struct CrateData {\n \n /// Data for any entity in the Rust language. The actual data contained varies\n /// with the kind of entity being queried. See the nested structs for details.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub enum Data {\n     /// Data for Enums.\n     EnumData(EnumData),\n@@ -77,7 +79,7 @@ pub enum Data {\n     VariableRefData(VariableRefData),\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Debug, RustcEncodable)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug)]\n pub enum Visibility {\n     Public,\n     Restricted,\n@@ -107,24 +109,16 @@ impl<'a> From<&'a hir::Visibility> for Visibility {\n }\n \n /// Data for the prelude of a crate.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct CratePreludeData {\n     pub crate_name: String,\n     pub crate_root: String,\n     pub external_crates: Vec<ExternalCrateData>,\n     pub span: Span,\n }\n \n-/// Data for external crates in the prelude of a crate.\n-#[derive(Debug, RustcEncodable)]\n-pub struct ExternalCrateData {\n-    pub name: String,\n-    pub num: CrateNum,\n-    pub file_name: String,\n-}\n-\n /// Data for enum declarations.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct EnumData {\n     pub id: NodeId,\n     pub name: String,\n@@ -140,7 +134,7 @@ pub struct EnumData {\n }\n \n /// Data for extern crates.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ExternCrateData {\n     pub id: NodeId,\n     pub name: String,\n@@ -151,15 +145,15 @@ pub struct ExternCrateData {\n }\n \n /// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct FunctionCallData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n \n /// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct FunctionData {\n     pub id: NodeId,\n     pub name: String,\n@@ -176,14 +170,14 @@ pub struct FunctionData {\n }\n \n /// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct FunctionRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: DefId,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ImplData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -192,7 +186,7 @@ pub struct ImplData {\n     pub self_ref: Option<DefId>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n // FIXME: this struct should not exist. However, removing it requires heavy\n // refactoring of dump_visitor.rs. See PR 31838 for more info.\n pub struct ImplData2 {\n@@ -206,15 +200,15 @@ pub struct ImplData2 {\n     pub self_ref: Option<TypeRefData>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct InheritanceData {\n     pub span: Span,\n     pub base_id: DefId,\n     pub deriv_id: NodeId\n }\n \n /// Data about a macro declaration.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MacroData {\n     pub span: Span,\n     pub name: String,\n@@ -223,7 +217,7 @@ pub struct MacroData {\n }\n \n /// Data about a macro use.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MacroUseData {\n     pub span: Span,\n     pub name: String,\n@@ -236,7 +230,7 @@ pub struct MacroUseData {\n }\n \n /// Data about a method call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MethodCallData {\n     pub span: Span,\n     pub scope: NodeId,\n@@ -245,7 +239,7 @@ pub struct MethodCallData {\n }\n \n /// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct MethodData {\n     pub id: NodeId,\n     pub name: String,\n@@ -262,7 +256,7 @@ pub struct MethodData {\n }\n \n /// Data for modules.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ModData {\n     pub id: NodeId,\n     pub name: String,\n@@ -278,15 +272,15 @@ pub struct ModData {\n }\n \n /// Data for a reference to a module.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ModRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: Option<DefId>,\n     pub qualname: String\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct StructData {\n     pub span: Span,\n     pub name: String,\n@@ -302,7 +296,7 @@ pub struct StructData {\n     pub attributes: Vec<Attribute>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct StructVariantData {\n     pub span: Span,\n     pub name: String,\n@@ -317,7 +311,7 @@ pub struct StructVariantData {\n     pub attributes: Vec<Attribute>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TraitData {\n     pub span: Span,\n     pub id: NodeId,\n@@ -332,7 +326,7 @@ pub struct TraitData {\n     pub attributes: Vec<Attribute>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TupleVariantData {\n     pub span: Span,\n     pub id: NodeId,\n@@ -348,7 +342,7 @@ pub struct TupleVariantData {\n }\n \n /// Data for a typedef.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TypeDefData {\n     pub id: NodeId,\n     pub name: String,\n@@ -363,15 +357,15 @@ pub struct TypeDefData {\n }\n \n /// Data for a reference to a type or trait.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct TypeRefData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub ref_id: Option<DefId>,\n     pub qualname: String,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct UseData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -381,7 +375,7 @@ pub struct UseData {\n     pub visibility: Visibility,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct UseGlobData {\n     pub id: NodeId,\n     pub span: Span,\n@@ -391,7 +385,7 @@ pub struct UseGlobData {\n }\n \n /// Data for local and global variables (consts and statics).\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct VariableData {\n     pub id: NodeId,\n     pub kind: VariableKind,\n@@ -408,7 +402,7 @@ pub struct VariableData {\n     pub attributes: Vec<Attribute>,\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub enum VariableKind {\n     Static,\n     Const,\n@@ -418,7 +412,7 @@ pub enum VariableKind {\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct VariableRefData {\n     pub name: String,\n     pub span: Span,\n@@ -430,7 +424,7 @@ pub struct VariableRefData {\n /// Encodes information about the signature of a definition. This should have\n /// enough information to create a nice display about a definition without\n /// access to the source code.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct Signature {\n     pub span: Span,\n     pub text: String,\n@@ -444,7 +438,7 @@ pub struct Signature {\n \n /// An element of a signature. `start` and `end` are byte offsets into the `text`\n /// of the parent `Signature`.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct SigElement {\n     pub id: DefId,\n     pub start: usize,"}, {"sha": "84e1fb03f624e821068f2111b3fcefc67ee51eeb", "filename": "src/librustc_save_analysis/dump.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -10,6 +10,8 @@\n \n use super::external_data::*;\n \n+use rls_data::CratePreludeData;\n+\n pub trait Dump {\n     fn crate_prelude(&mut self, CratePreludeData) {}\n     fn enum_data(&mut self, EnumData) {}"}, {"sha": "f2aa89ba4b66e8bc9bffdb1523c3ac52c6eb58b6", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -29,7 +29,7 @@\n \n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::{Node, NodeItem};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt, AssociatedItemContainer};\n@@ -54,6 +54,8 @@ use super::external_data::{Lower, make_def_id};\n use super::span_utils::SpanUtils;\n use super::recorder;\n \n+use rls_data::ExternalCrateData;\n+\n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $sp:expr) => {\n         let $id = if let super::Data::$kind(data) = $id {\n@@ -137,7 +139,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             let lo_loc = self.span.sess.codemap().lookup_char_pos(c.span.lo);\n             ExternalCrateData {\n                 name: c.name,\n-                num: CrateNum::from_u32(c.number),\n+                num: c.number,\n                 file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             }\n         }).collect();"}, {"sha": "6fd2de97767e18d318a44257424ee7b379a48843", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 66, "deletions": 93, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -18,6 +18,9 @@ use syntax_pos::Span;\n \n use data::{self, Visibility, SigElement};\n \n+use rls_data::{SpanData, CratePreludeData, Attribute};\n+use rls_span::{Column, Row};\n+\n // FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n pub trait Lower {\n     type Target;\n@@ -35,41 +38,19 @@ pub fn null_def_id() -> DefId {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct SpanData {\n-    pub file_name: String,\n-    pub byte_start: u32,\n-    pub byte_end: u32,\n-    /// 1-based.\n-    pub line_start: usize,\n-    pub line_end: usize,\n-    /// 1-based, character offset.\n-    pub column_start: usize,\n-    pub column_end: usize,\n-}\n-\n-impl SpanData {\n-    pub fn from_span(span: Span, cm: &CodeMap) -> SpanData {\n-        let start = cm.lookup_char_pos(span.lo);\n-        let end = cm.lookup_char_pos(span.hi);\n-\n-        SpanData {\n-            file_name: start.file.name.clone(),\n-            byte_start: span.lo.0,\n-            byte_end: span.hi.0,\n-            line_start: start.line,\n-            line_end: end.line,\n-            column_start: start.col.0 + 1,\n-            column_end: end.col.0 + 1,\n-        }\n-    }\n-}\n+pub fn span_from_span(span: Span, cm: &CodeMap) -> SpanData {\n+    let start = cm.lookup_char_pos(span.lo);\n+    let end = cm.lookup_char_pos(span.hi);\n \n-/// Represent an arbitrary attribute on a code element\n-#[derive(Clone, Debug, RustcEncodable)]\n-pub struct Attribute {\n-    value: String,\n-    span: SpanData,\n+    SpanData {\n+        file_name: start.file.name.clone().into(),\n+        byte_start: span.lo.0,\n+        byte_end: span.hi.0,\n+        line_start: Row::new_one_indexed(start.line as u32),\n+        line_end: Row::new_one_indexed(end.line as u32),\n+        column_start: Column::new_one_indexed(start.col.0 as u32 + 1),\n+        column_end: Column::new_one_indexed(end.col.0 as u32 + 1),\n+    }\n }\n \n impl Lower for Vec<ast::Attribute> {\n@@ -91,20 +72,12 @@ impl Lower for Vec<ast::Attribute> {\n \n             Attribute {\n                 value: value,\n-                span: SpanData::from_span(attr.span, tcx.sess.codemap()),\n+                span: span_from_span(attr.span, tcx.sess.codemap()),\n             }\n         }).collect()\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-pub struct CratePreludeData {\n-    pub crate_name: String,\n-    pub crate_root: String,\n-    pub external_crates: Vec<data::ExternalCrateData>,\n-    pub span: SpanData,\n-}\n-\n impl Lower for data::CratePreludeData {\n     type Target = CratePreludeData;\n \n@@ -113,13 +86,13 @@ impl Lower for data::CratePreludeData {\n             crate_name: self.crate_name,\n             crate_root: self.crate_root,\n             external_crates: self.external_crates,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n         }\n     }\n }\n \n /// Data for enum declarations.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct EnumData {\n     pub id: DefId,\n     pub value: String,\n@@ -143,7 +116,7 @@ impl Lower for data::EnumData {\n             name: self.name,\n             value: self.value,\n             qualname: self.qualname,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n             visibility: self.visibility,\n@@ -155,7 +128,7 @@ impl Lower for data::EnumData {\n }\n \n /// Data for extern crates.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ExternCrateData {\n     pub id: DefId,\n     pub name: String,\n@@ -174,14 +147,14 @@ impl Lower for data::ExternCrateData {\n             name: self.name,\n             crate_num: self.crate_num,\n             location: self.location,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n         }\n     }\n }\n \n /// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct FunctionCallData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -193,15 +166,15 @@ impl Lower for data::FunctionCallData {\n \n     fn lower(self, tcx: TyCtxt) -> FunctionCallData {\n         FunctionCallData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }\n }\n \n /// Data for all kinds of functions and methods.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct FunctionData {\n     pub id: DefId,\n     pub name: String,\n@@ -226,7 +199,7 @@ impl Lower for data::FunctionData {\n             name: self.name,\n             qualname: self.qualname,\n             declaration: self.declaration,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             value: self.value,\n             visibility: self.visibility,\n@@ -239,7 +212,7 @@ impl Lower for data::FunctionData {\n }\n \n /// Data about a function call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct FunctionRefData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -251,13 +224,13 @@ impl Lower for data::FunctionRefData {\n \n     fn lower(self, tcx: TyCtxt) -> FunctionRefData {\n         FunctionRefData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }\n }\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ImplData {\n     pub id: DefId,\n     pub span: SpanData,\n@@ -272,15 +245,15 @@ impl Lower for data::ImplData {\n     fn lower(self, tcx: TyCtxt) -> ImplData {\n         ImplData {\n             id: make_def_id(self.id, &tcx.hir),\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             trait_ref: self.trait_ref,\n             self_ref: self.self_ref,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct InheritanceData {\n     pub span: SpanData,\n     pub base_id: DefId,\n@@ -292,15 +265,15 @@ impl Lower for data::InheritanceData {\n \n     fn lower(self, tcx: TyCtxt) -> InheritanceData {\n         InheritanceData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             base_id: self.base_id,\n             deriv_id: make_def_id(self.deriv_id, &tcx.hir)\n         }\n     }\n }\n \n /// Data about a macro declaration.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MacroData {\n     pub span: SpanData,\n     pub name: String,\n@@ -313,7 +286,7 @@ impl Lower for data::MacroData {\n \n     fn lower(self, tcx: TyCtxt) -> MacroData {\n         MacroData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             qualname: self.qualname,\n             docs: self.docs,\n@@ -322,7 +295,7 @@ impl Lower for data::MacroData {\n }\n \n /// Data about a macro use.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MacroUseData {\n     pub span: SpanData,\n     pub name: String,\n@@ -338,17 +311,17 @@ impl Lower for data::MacroUseData {\n \n     fn lower(self, tcx: TyCtxt) -> MacroUseData {\n         MacroUseData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             qualname: self.qualname,\n-            callee_span: SpanData::from_span(self.callee_span, tcx.sess.codemap()),\n+            callee_span: span_from_span(self.callee_span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n         }\n     }\n }\n \n /// Data about a method call.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct MethodCallData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -361,7 +334,7 @@ impl Lower for data::MethodCallData {\n \n     fn lower(self, tcx: TyCtxt) -> MethodCallData {\n         MethodCallData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             decl_id: self.decl_id,\n@@ -370,7 +343,7 @@ impl Lower for data::MethodCallData {\n }\n \n /// Data for method declarations (methods with a body are treated as functions).\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct MethodData {\n     pub id: DefId,\n     pub name: String,\n@@ -391,7 +364,7 @@ impl Lower for data::MethodData {\n \n     fn lower(self, tcx: TyCtxt) -> MethodData {\n         MethodData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             scope: make_def_id(self.scope, &tcx.hir),\n             id: make_def_id(self.id, &tcx.hir),\n@@ -408,7 +381,7 @@ impl Lower for data::MethodData {\n }\n \n /// Data for modules.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ModData {\n     pub id: DefId,\n     pub name: String,\n@@ -431,7 +404,7 @@ impl Lower for data::ModData {\n             id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             qualname: self.qualname,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             filename: self.filename,\n             items: self.items.into_iter().map(|id| make_def_id(id, &tcx.hir)).collect(),\n@@ -444,7 +417,7 @@ impl Lower for data::ModData {\n }\n \n /// Data for a reference to a module.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct ModRefData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -457,15 +430,15 @@ impl Lower for data::ModRefData {\n \n     fn lower(self, tcx: TyCtxt) -> ModRefData {\n         ModRefData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             qualname: self.qualname,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct StructData {\n     pub span: SpanData,\n     pub name: String,\n@@ -486,7 +459,7 @@ impl Lower for data::StructData {\n \n     fn lower(self, tcx: TyCtxt) -> StructData {\n         StructData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             id: make_def_id(self.id, &tcx.hir),\n             ctor_id: make_def_id(self.ctor_id, &tcx.hir),\n@@ -502,7 +475,7 @@ impl Lower for data::StructData {\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct StructVariantData {\n     pub span: SpanData,\n     pub name: String,\n@@ -522,7 +495,7 @@ impl Lower for data::StructVariantData {\n \n     fn lower(self, tcx: TyCtxt) -> StructVariantData {\n         StructVariantData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             id: make_def_id(self.id, &tcx.hir),\n             qualname: self.qualname,\n@@ -537,7 +510,7 @@ impl Lower for data::StructVariantData {\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TraitData {\n     pub span: SpanData,\n     pub name: String,\n@@ -557,7 +530,7 @@ impl Lower for data::TraitData {\n \n     fn lower(self, tcx: TyCtxt) -> TraitData {\n         TraitData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             id: make_def_id(self.id, &tcx.hir),\n             qualname: self.qualname,\n@@ -572,7 +545,7 @@ impl Lower for data::TraitData {\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TupleVariantData {\n     pub span: SpanData,\n     pub id: DefId,\n@@ -592,7 +565,7 @@ impl Lower for data::TupleVariantData {\n \n     fn lower(self, tcx: TyCtxt) -> TupleVariantData {\n         TupleVariantData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n             qualname: self.qualname,\n@@ -608,7 +581,7 @@ impl Lower for data::TupleVariantData {\n }\n \n /// Data for a typedef.\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct TypeDefData {\n     pub id: DefId,\n     pub name: String,\n@@ -629,7 +602,7 @@ impl Lower for data::TypeDefData {\n         TypeDefData {\n             id: make_def_id(self.id, &tcx.hir),\n             name: self.name,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             qualname: self.qualname,\n             value: self.value,\n             visibility: self.visibility,\n@@ -642,7 +615,7 @@ impl Lower for data::TypeDefData {\n }\n \n /// Data for a reference to a type or trait.\n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct TypeRefData {\n     pub span: SpanData,\n     pub scope: DefId,\n@@ -655,15 +628,15 @@ impl Lower for data::TypeRefData {\n \n     fn lower(self, tcx: TyCtxt) -> TypeRefData {\n         TypeRefData {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n             qualname: self.qualname,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct UseData {\n     pub id: DefId,\n     pub span: SpanData,\n@@ -679,7 +652,7 @@ impl Lower for data::UseData {\n     fn lower(self, tcx: TyCtxt) -> UseData {\n         UseData {\n             id: make_def_id(self.id, &tcx.hir),\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n             mod_id: self.mod_id,\n             scope: make_def_id(self.scope, &tcx.hir),\n@@ -688,7 +661,7 @@ impl Lower for data::UseData {\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct UseGlobData {\n     pub id: DefId,\n     pub span: SpanData,\n@@ -703,7 +676,7 @@ impl Lower for data::UseGlobData {\n     fn lower(self, tcx: TyCtxt) -> UseGlobData {\n         UseGlobData {\n             id: make_def_id(self.id, &tcx.hir),\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             names: self.names,\n             scope: make_def_id(self.scope, &tcx.hir),\n             visibility: self.visibility,\n@@ -712,7 +685,7 @@ impl Lower for data::UseGlobData {\n }\n \n /// Data for local and global variables (consts and statics).\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct VariableData {\n     pub id: DefId,\n     pub name: String,\n@@ -738,7 +711,7 @@ impl Lower for data::VariableData {\n             kind: self.kind,\n             name: self.name,\n             qualname: self.qualname,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             value: self.value,\n             type_value: self.type_value,\n@@ -753,7 +726,7 @@ impl Lower for data::VariableData {\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug, RustcEncodable)]\n+#[derive(Debug)]\n pub struct VariableRefData {\n     pub name: String,\n     pub span: SpanData,\n@@ -767,14 +740,14 @@ impl Lower for data::VariableRefData {\n     fn lower(self, tcx: TyCtxt) -> VariableRefData {\n         VariableRefData {\n             name: self.name,\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.hir),\n             ref_id: self.ref_id,\n         }\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable)]\n+#[derive(Clone, Debug)]\n pub struct Signature {\n     pub span: SpanData,\n     pub text: String,\n@@ -791,7 +764,7 @@ impl Lower for data::Signature {\n \n     fn lower(self, tcx: TyCtxt) -> Signature {\n         Signature {\n-            span: SpanData::from_span(self.span, tcx.sess.codemap()),\n+            span: span_from_span(self.span, tcx.sess.codemap()),\n             text: self.text,\n             ident_start: self.ident_start,\n             ident_end: self.ident_end,"}, {"sha": "41221ad986379b7f720875fa5ce997d95675dd8a", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "modified", "additions": 147, "deletions": 312, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -10,22 +10,22 @@\n \n use std::io::Write;\n \n-use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n use external_data::*;\n-use data::{VariableKind, Visibility, SigElement};\n+use data::{VariableKind, Visibility};\n use dump::Dump;\n-use super::Format;\n+use json_dumper::id_from_def_id;\n+\n+use rls_data::{Analysis, Import, ImportKind, Def, DefKind, CratePreludeData};\n \n \n // A dumper to dump a restricted set of JSON information, designed for use with\n // libraries distributed without their source. Clients are likely to use type\n // information here, and (for example) generate Rustdoc URLs, but don't need\n // information for navigating the source of the crate.\n // Relative to the regular JSON save-analysis info, this form is filtered to\n-// remove non-visible items, but includes some extra info for items (e.g., the\n-// parent field for finding the struct to which a field belongs).\n+// remove non-visible items.\n pub struct JsonApiDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n     result: Analysis,\n@@ -48,7 +48,7 @@ impl<'b, W: Write> Drop for JsonApiDumper<'b, W> {\n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n-            if let Some(datum) = From::from(data) {\n+            if let Some(datum) = data.into() {\n                 self.result.$bucket.push(datum);\n             }\n         }\n@@ -77,11 +77,11 @@ impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n \n     fn impl_data(&mut self, data: ImplData) {\n         if data.self_ref.is_some() {\n-            self.result.relations.push(From::from(data));\n+            self.result.relations.push(data.into());\n         }\n     }\n     fn inheritance(&mut self, data: InheritanceData) {\n-        self.result.relations.push(From::from(data));\n+        self.result.relations.push(data.into());\n     }\n }\n \n@@ -90,426 +90,261 @@ impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n // method, but not the supplied method). In both cases, we are currently\n // ignoring it.\n \n-#[derive(Debug, RustcEncodable)]\n-struct Analysis {\n-    kind: Format,\n-    prelude: Option<CratePreludeData>,\n-    imports: Vec<Import>,\n-    defs: Vec<Def>,\n-    relations: Vec<Relation>,\n-    // These two fields are dummies so that clients can parse the two kinds of\n-    // JSON data in the same way.\n-    refs: Vec<()>,\n-    macro_refs: Vec<()>,\n-}\n-\n-impl Analysis {\n-    fn new() -> Analysis {\n-        Analysis {\n-            kind: Format::JsonApi,\n-            prelude: None,\n-            imports: vec![],\n-            defs: vec![],\n-            relations: vec![],\n-            refs: vec![],\n-            macro_refs: vec![],\n-        }\n-    }\n-}\n-\n-// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n-// we use our own Id which is the same, but without the newtype.\n-#[derive(Debug, RustcEncodable)]\n-struct Id {\n-    krate: u32,\n-    index: u32,\n-}\n-\n-impl From<DefId> for Id {\n-    fn from(id: DefId) -> Id {\n-        Id {\n-            krate: id.krate.as_u32(),\n-            index: id.index.as_u32(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-struct Import {\n-    kind: ImportKind,\n-    id: Id,\n-    span: SpanData,\n-    name: String,\n-    value: String,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum ImportKind {\n-    Use,\n-    GlobUse,\n-}\n-\n-impl From<UseData> for Option<Import> {\n-    fn from(data: UseData) -> Option<Import> {\n-        match data.visibility {\n+impl Into<Option<Import>> for UseData {\n+    fn into(self) -> Option<Import> {\n+        match self.visibility {\n             Visibility::Public => Some(Import {\n                 kind: ImportKind::Use,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n+                ref_id: self.mod_id.map(|id| id_from_def_id(id)),\n+                span: self.span,\n+                name: self.name,\n                 value: String::new(),\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<UseGlobData> for Option<Import> {\n-    fn from(data: UseGlobData) -> Option<Import> {\n-        match data.visibility {\n+impl Into<Option<Import>> for UseGlobData {\n+    fn into(self) -> Option<Import> {\n+        match self.visibility {\n             Visibility::Public => Some(Import {\n                 kind: ImportKind::GlobUse,\n-                id: From::from(data.id),\n-                span: data.span,\n+                ref_id: None,\n+                span: self.span,\n                 name: \"*\".to_owned(),\n-                value: data.names.join(\", \"),\n+                value: self.names.join(\", \"),\n             }),\n             _ => None,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Def {\n-    kind: DefKind,\n-    id: Id,\n-    span: SpanData,\n-    name: String,\n-    qualname: String,\n-    value: String,\n-    parent: Option<Id>,\n-    children: Vec<Id>,\n-    decl_id: Option<Id>,\n-    docs: String,\n-    sig: Option<JsonSignature>,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum DefKind {\n-    // value = variant names\n-    Enum,\n-    // value = enum name + variant name + types\n-    Tuple,\n-    // value = [enum name +] name + fields\n-    Struct,\n-    // value = signature\n-    Trait,\n-    // value = type + generics\n-    Function,\n-    // value = type + generics\n-    Method,\n-    // No id, no value.\n-    Macro,\n-    // value = file_name\n-    Mod,\n-    // value = aliased type\n-    Type,\n-    // value = type and init expression (for all variable kinds).\n-    Static,\n-    Const,\n-    Field,\n-}\n-\n-impl From<EnumData> for Option<Def> {\n-    fn from(data: EnumData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for EnumData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Enum,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 parent: None,\n-                children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n+                children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n \n-impl From<TupleVariantData> for Option<Def> {\n-    fn from(data: TupleVariantData) -> Option<Def> {\n+impl Into<Option<Def>> for TupleVariantData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Tuple,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            parent: data.parent.map(|id| From::from(id)),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: self.parent.map(|id| id_from_def_id(id)),\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<StructVariantData> for Option<Def> {\n-    fn from(data: StructVariantData) -> Option<Def> {\n+impl Into<Option<Def>> for StructVariantData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            parent: data.parent.map(|id| From::from(id)),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: self.parent.map(|id| id_from_def_id(id)),\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<StructData> for Option<Def> {\n-    fn from(data: StructData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for StructData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n             parent: None,\n-            children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n+            children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: vec![],\n         }),\n             _ => None,\n         }\n     }\n }\n-impl From<TraitData> for Option<Def> {\n-    fn from(data: TraitData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for TraitData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Trait,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n-                children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n+                children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 parent: None,\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<FunctionData> for Option<Def> {\n-    fn from(data: FunctionData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for FunctionData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Function,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<MethodData> for Option<Def> {\n-    fn from(data: MethodData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for MethodData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Method,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n-                decl_id: data.decl_id.map(|id| From::from(id)),\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n+                decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<MacroData> for Option<Def> {\n-    fn from(data: MacroData) -> Option<Def> {\n+impl Into<Option<Def>> for MacroData {\n+    fn into(self) -> Option<Def> {\n         Some(Def {\n             kind: DefKind::Macro,\n-            id: From::from(null_def_id()),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n+            id: id_from_def_id(null_def_id()),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n             value: String::new(),\n             children: vec![],\n             parent: None,\n             decl_id: None,\n-            docs: data.docs,\n+            docs: self.docs,\n             sig: None,\n+            attributes: vec![],\n         })\n     }\n }\n-impl From<ModData> for Option<Def> {\n-    fn from(data:ModData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for ModData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Mod,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.filename,\n-                children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.filename,\n+                children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n                 parent: None,\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: Some(From::from(data.sig)),\n+                docs: self.docs,\n+                sig: Some(self.sig.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-impl From<TypeDefData> for Option<Def> {\n-    fn from(data: TypeDefData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for TypeDefData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n                 kind: DefKind::Type,\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n                 docs: String::new(),\n-                sig: data.sig.map(|s| From::from(s)),\n+                sig: self.sig.map(|s| s.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n \n-impl From<VariableData> for Option<Def> {\n-    fn from(data: VariableData) -> Option<Def> {\n-        match data.visibility {\n+impl Into<Option<Def>> for VariableData {\n+    fn into(self) -> Option<Def> {\n+        match self.visibility {\n             Visibility::Public => Some(Def {\n-                kind: match data.kind {\n+                kind: match self.kind {\n                     VariableKind::Static => DefKind::Static,\n                     VariableKind::Const => DefKind::Const,\n                     VariableKind::Local => { return None }\n                     VariableKind::Field => DefKind::Field,\n                 },\n-                id: From::from(data.id),\n-                span: data.span,\n-                name: data.name,\n-                qualname: data.qualname,\n-                value: data.value,\n+                id: id_from_def_id(self.id),\n+                span: self.span,\n+                name: self.name,\n+                qualname: self.qualname,\n+                value: self.value,\n                 children: vec![],\n-                parent: data.parent.map(|id| From::from(id)),\n+                parent: self.parent.map(|id| id_from_def_id(id)),\n                 decl_id: None,\n-                docs: data.docs,\n-                sig: data.sig.map(|s| From::from(s)),\n+                docs: self.docs,\n+                sig: self.sig.map(|s| s.into()),\n+                attributes: vec![],\n             }),\n             _ => None,\n         }\n     }\n }\n-\n-#[derive(Debug, RustcEncodable)]\n-struct Relation {\n-    span: SpanData,\n-    kind: RelationKind,\n-    from: Id,\n-    to: Id,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum RelationKind {\n-    Impl,\n-    SuperTrait,\n-}\n-\n-impl From<ImplData> for Relation {\n-    fn from(data: ImplData) -> Relation {\n-        Relation {\n-            span: data.span,\n-            kind: RelationKind::Impl,\n-            from: From::from(data.self_ref.unwrap_or(null_def_id())),\n-            to: From::from(data.trait_ref.unwrap_or(null_def_id())),\n-        }\n-    }\n-}\n-\n-impl From<InheritanceData> for Relation {\n-    fn from(data: InheritanceData) -> Relation {\n-        Relation {\n-            span: data.span,\n-            kind: RelationKind::SuperTrait,\n-            from: From::from(data.base_id),\n-            to: From::from(data.deriv_id),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSignature {\n-    span: SpanData,\n-    text: String,\n-    ident_start: usize,\n-    ident_end: usize,\n-    defs: Vec<JsonSigElement>,\n-    refs: Vec<JsonSigElement>,\n-}\n-\n-impl From<Signature> for JsonSignature {\n-    fn from(data: Signature) -> JsonSignature {\n-        JsonSignature {\n-            span: data.span,\n-            text: data.text,\n-            ident_start: data.ident_start,\n-            ident_end: data.ident_end,\n-            defs: data.defs.into_iter().map(|s| From::from(s)).collect(),\n-            refs: data.refs.into_iter().map(|s| From::from(s)).collect(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSigElement {\n-    id: Id,\n-    start: usize,\n-    end: usize,\n-}\n-\n-impl From<SigElement> for JsonSigElement {\n-    fn from(data: SigElement) -> JsonSigElement {\n-        JsonSigElement {\n-            id: From::from(data.id),\n-            start: data.start,\n-            end: data.end,\n-        }\n-    }\n-}"}, {"sha": "acc877d3947758fb20a222e51c2f6a896fe5c3e4", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 203, "deletions": 332, "changes": 535, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -13,10 +13,14 @@ use std::io::Write;\n use rustc::hir::def_id::DefId;\n use rustc_serialize::json::as_json;\n \n+use rls_data::{self, Id, Analysis, Import, ImportKind, Def, DefKind, Ref, RefKind, MacroRef,\n+               Relation, RelationKind, Signature, SigElement, CratePreludeData};\n+use rls_span::{Column, Row};\n+\n+use external_data;\n use external_data::*;\n-use data::{VariableKind, SigElement};\n+use data::{self, VariableKind};\n use dump::Dump;\n-use super::Format;\n \n pub struct JsonDumper<'b, W: Write + 'b> {\n     output: &'b mut W,\n@@ -40,7 +44,7 @@ impl<'b, W: Write> Drop for JsonDumper<'b, W> {\n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n-            self.result.$bucket.push(From::from(data));\n+            self.result.$bucket.push(data.into());\n         }\n     }\n }\n@@ -75,21 +79,22 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n     impl_fn!(macro_use, MacroUseData, macro_refs);\n \n     fn mod_data(&mut self, data: ModData) {\n-        let id: Id = From::from(data.id);\n+        let id: Id = id_from_def_id(data.id);\n         let mut def = Def {\n             kind: DefKind::Mod,\n             id: id,\n-            span: data.span,\n+            span: data.span.into(),\n             name: data.name,\n             qualname: data.qualname,\n             value: data.filename,\n-            children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+            parent: None,\n+            children: data.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n             docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            sig: Some(data.sig.into()),\n+            attributes: data.attributes.into_iter().map(|a| a.into()).collect(),\n         };\n-        if def.span.file_name != def.value {\n+        if def.span.file_name.to_str().unwrap() != def.value {\n             // If the module is an out-of-line defintion, then we'll make the\n             // defintion the first character in the module's file and turn the\n             // the declaration into a reference to it.\n@@ -99,14 +104,14 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n                 ref_id: id,\n             };\n             self.result.refs.push(rf);\n-            def.span = SpanData {\n-                file_name: def.value.clone(),\n+            def.span = rls_data::SpanData {\n+                file_name: def.value.clone().into(),\n                 byte_start: 0,\n                 byte_end: 0,\n-                line_start: 1,\n-                line_end: 1,\n-                column_start: 1,\n-                column_end: 1,\n+                line_start: Row::new_one_indexed(1),\n+                line_end: Row::new_one_indexed(1),\n+                column_start: Column::new_one_indexed(1),\n+                column_end: Column::new_one_indexed(1),\n             }\n         }\n \n@@ -115,11 +120,11 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n \n     fn impl_data(&mut self, data: ImplData) {\n         if data.self_ref.is_some() {\n-            self.result.relations.push(From::from(data));\n+            self.result.relations.push(data.into());\n         }\n     }\n     fn inheritance(&mut self, data: InheritanceData) {\n-        self.result.relations.push(From::from(data));\n+        self.result.relations.push(data.into());\n     }\n }\n \n@@ -129,476 +134,342 @@ impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n // method, but not the supplied method). In both cases, we are currently\n // ignoring it.\n \n-#[derive(Debug, RustcEncodable)]\n-struct Analysis {\n-    kind: Format,\n-    prelude: Option<CratePreludeData>,\n-    imports: Vec<Import>,\n-    defs: Vec<Def>,\n-    refs: Vec<Ref>,\n-    macro_refs: Vec<MacroRef>,\n-    relations: Vec<Relation>,\n-}\n-\n-impl Analysis {\n-    fn new() -> Analysis {\n-        Analysis {\n-            kind: Format::Json,\n-            prelude: None,\n-            imports: vec![],\n-            defs: vec![],\n-            refs: vec![],\n-            macro_refs: vec![],\n-            relations: vec![],\n-        }\n-    }\n-}\n-\n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n // we use our own Id which is the same, but without the newtype.\n-#[derive(Clone, Copy, Debug, RustcEncodable)]\n-struct Id {\n-    krate: u32,\n-    index: u32,\n-}\n-\n-impl From<DefId> for Id {\n-    fn from(id: DefId) -> Id {\n-        Id {\n-            krate: id.krate.as_u32(),\n-            index: id.index.as_u32(),\n-        }\n+pub fn id_from_def_id(id: DefId) -> Id {\n+    Id {\n+        krate: id.krate.as_u32(),\n+        index: id.index.as_u32(),\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Import {\n-    kind: ImportKind,\n-    ref_id: Option<Id>,\n-    span: SpanData,\n-    name: String,\n-    value: String,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum ImportKind {\n-    ExternCrate,\n-    Use,\n-    GlobUse,\n-}\n-\n-impl From<ExternCrateData> for Import {\n-    fn from(data: ExternCrateData) -> Import {\n+impl Into<Import> for ExternCrateData {\n+    fn into(self) -> Import {\n         Import {\n             kind: ImportKind::ExternCrate,\n             ref_id: None,\n-            span: data.span,\n-            name: data.name,\n+            span: self.span,\n+            name: self.name,\n             value: String::new(),\n         }\n     }\n }\n-impl From<UseData> for Import {\n-    fn from(data: UseData) -> Import {\n+impl Into<Import> for UseData {\n+    fn into(self) -> Import {\n         Import {\n             kind: ImportKind::Use,\n-            ref_id: data.mod_id.map(|id| From::from(id)),\n-            span: data.span,\n-            name: data.name,\n+            ref_id: self.mod_id.map(|id| id_from_def_id(id)),\n+            span: self.span,\n+            name: self.name,\n             value: String::new(),\n         }\n     }\n }\n-impl From<UseGlobData> for Import {\n-    fn from(data: UseGlobData) -> Import {\n+impl Into<Import> for UseGlobData {\n+    fn into(self) -> Import {\n         Import {\n             kind: ImportKind::GlobUse,\n             ref_id: None,\n-            span: data.span,\n+            span: self.span,\n             name: \"*\".to_owned(),\n-            value: data.names.join(\", \"),\n+            value: self.names.join(\", \"),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Def {\n-    kind: DefKind,\n-    id: Id,\n-    span: SpanData,\n-    name: String,\n-    qualname: String,\n-    value: String,\n-    children: Vec<Id>,\n-    decl_id: Option<Id>,\n-    docs: String,\n-    sig: Option<JsonSignature>,\n-    attributes: Vec<Attribute>,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum DefKind {\n-    // value = variant names\n-    Enum,\n-    // value = enum name + variant name + types\n-    Tuple,\n-    // value = [enum name +] name + fields\n-    Struct,\n-    // value = signature\n-    Trait,\n-    // value = type + generics\n-    Function,\n-    // value = type + generics\n-    Method,\n-    // No id, no value.\n-    Macro,\n-    // value = file_name\n-    Mod,\n-    // value = aliased type\n-    Type,\n-    // value = type and init expression (for all variable kinds).\n-    Local,\n-    Static,\n-    Const,\n-    Field,\n-}\n-\n-impl From<EnumData> for Def {\n-    fn from(data: EnumData) -> Def {\n+impl Into<Def> for EnumData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Enum,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n+            children: self.variants.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n \n-impl From<TupleVariantData> for Def {\n-    fn from(data: TupleVariantData) -> Def {\n+impl Into<Def> for TupleVariantData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Tuple,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<StructVariantData> for Def {\n-    fn from(data: StructVariantData) -> Def {\n+impl Into<Def> for StructVariantData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<StructData> for Def {\n-    fn from(data: StructData) -> Def {\n+impl Into<Def> for StructData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Struct,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n+            children: self.fields.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<TraitData> for Def {\n-    fn from(data: TraitData) -> Def {\n+impl Into<Def> for TraitData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Trait,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n-            children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n+            children: self.items.into_iter().map(|id| id_from_def_id(id)).collect(),\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<FunctionData> for Def {\n-    fn from(data: FunctionData) -> Def {\n+impl Into<Def> for FunctionData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Function,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<MethodData> for Def {\n-    fn from(data: MethodData) -> Def {\n+impl Into<Def> for MethodData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Method,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n-            decl_id: data.decl_id.map(|id| From::from(id)),\n-            docs: data.docs,\n-            sig: Some(From::from(data.sig)),\n-            attributes: data.attributes,\n+            decl_id: self.decl_id.map(|id| id_from_def_id(id)),\n+            docs: self.docs,\n+            sig: Some(self.sig.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<MacroData> for Def {\n-    fn from(data: MacroData) -> Def {\n+impl Into<Def> for MacroData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Macro,\n-            id: From::from(null_def_id()),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n+            id: id_from_def_id(null_def_id()),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n             value: String::new(),\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n+            docs: self.docs,\n             sig: None,\n             attributes: vec![],\n         }\n     }\n }\n-impl From<TypeDefData> for Def {\n-    fn from(data: TypeDefData) -> Def {\n+impl Into<Def> for TypeDefData {\n+    fn into(self) -> Def {\n         Def {\n             kind: DefKind::Type,\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n             docs: String::new(),\n-            sig: data.sig.map(|s| From::from(s)),\n-            attributes: data.attributes,\n+            sig: self.sig.map(|s| s.into()),\n+            attributes: self.attributes,\n         }\n     }\n }\n-impl From<VariableData> for Def {\n-    fn from(data: VariableData) -> Def {\n+impl Into<Def> for VariableData {\n+    fn into(self) -> Def {\n         Def {\n-            kind: match data.kind {\n+            kind: match self.kind {\n                 VariableKind::Static => DefKind::Static,\n                 VariableKind::Const => DefKind::Const,\n                 VariableKind::Local => DefKind::Local,\n                 VariableKind::Field => DefKind::Field,\n             },\n-            id: From::from(data.id),\n-            span: data.span,\n-            name: data.name,\n-            qualname: data.qualname,\n-            value: data.type_value,\n+            id: id_from_def_id(self.id),\n+            span: self.span,\n+            name: self.name,\n+            qualname: self.qualname,\n+            value: self.type_value,\n+            parent: None,\n             children: vec![],\n             decl_id: None,\n-            docs: data.docs,\n+            docs: self.docs,\n             sig: None,\n-            attributes: data.attributes,\n+            attributes: self.attributes,\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-enum RefKind {\n-    Function,\n-    Mod,\n-    Type,\n-    Variable,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-struct Ref {\n-    kind: RefKind,\n-    span: SpanData,\n-    ref_id: Id,\n-}\n-\n-impl From<FunctionRefData> for Ref {\n-    fn from(data: FunctionRefData) -> Ref {\n+impl Into<Ref> for FunctionRefData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Function,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id),\n         }\n     }\n }\n-impl From<FunctionCallData> for Ref {\n-    fn from(data: FunctionCallData) -> Ref {\n+impl Into<Ref> for FunctionCallData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Function,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id),\n         }\n     }\n }\n-impl From<MethodCallData> for Ref {\n-    fn from(data: MethodCallData) -> Ref {\n+impl Into<Ref> for MethodCallData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Function,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id.or(data.decl_id).unwrap_or(null_def_id())),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id.or(self.decl_id).unwrap_or(null_def_id())),\n         }\n     }\n }\n-impl From<ModRefData> for Ref {\n-    fn from(data: ModRefData) -> Ref {\n+impl Into<Ref> for ModRefData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Mod,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id.unwrap_or(null_def_id())),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id.unwrap_or(null_def_id())),\n         }\n     }\n }\n-impl From<TypeRefData> for Ref {\n-    fn from(data: TypeRefData) -> Ref {\n+impl Into<Ref> for TypeRefData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Type,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id.unwrap_or(null_def_id())),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id.unwrap_or(null_def_id())),\n         }\n     }\n }\n-impl From<VariableRefData> for Ref {\n-    fn from(data: VariableRefData) -> Ref {\n+impl Into<Ref> for VariableRefData {\n+    fn into(self) -> Ref {\n         Ref {\n             kind: RefKind::Variable,\n-            span: data.span,\n-            ref_id: From::from(data.ref_id),\n+            span: self.span,\n+            ref_id: id_from_def_id(self.ref_id),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct MacroRef {\n-    span: SpanData,\n-    qualname: String,\n-    callee_span: SpanData,\n-}\n-\n-impl From<MacroUseData> for MacroRef {\n-    fn from(data: MacroUseData) -> MacroRef {\n+impl Into<MacroRef> for MacroUseData {\n+    fn into(self) -> MacroRef {\n         MacroRef {\n-            span: data.span,\n-            qualname: data.qualname,\n-            callee_span: data.callee_span,\n+            span: self.span,\n+            qualname: self.qualname,\n+            callee_span: self.callee_span.into(),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-struct Relation {\n-    span: SpanData,\n-    kind: RelationKind,\n-    from: Id,\n-    to: Id,\n-}\n-\n-#[derive(Debug, RustcEncodable)]\n-enum RelationKind {\n-    Impl,\n-    SuperTrait,\n-}\n-\n-impl From<ImplData> for Relation {\n-    fn from(data: ImplData) -> Relation {\n+impl Into<Relation> for ImplData {\n+    fn into(self) -> Relation {\n         Relation {\n-            span: data.span,\n+            span: self.span,\n             kind: RelationKind::Impl,\n-            from: From::from(data.self_ref.unwrap_or(null_def_id())),\n-            to: From::from(data.trait_ref.unwrap_or(null_def_id())),\n+            from: id_from_def_id(self.self_ref.unwrap_or(null_def_id())),\n+            to: id_from_def_id(self.trait_ref.unwrap_or(null_def_id())),\n         }\n     }\n }\n \n-impl From<InheritanceData> for Relation {\n-    fn from(data: InheritanceData) -> Relation {\n+impl Into<Relation> for InheritanceData {\n+    fn into(self) -> Relation {\n         Relation {\n-            span: data.span,\n+            span: self.span,\n             kind: RelationKind::SuperTrait,\n-            from: From::from(data.base_id),\n-            to: From::from(data.deriv_id),\n+            from: id_from_def_id(self.base_id),\n+            to: id_from_def_id(self.deriv_id),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSignature {\n-    span: SpanData,\n-    text: String,\n-    ident_start: usize,\n-    ident_end: usize,\n-    defs: Vec<JsonSigElement>,\n-    refs: Vec<JsonSigElement>,\n-}\n-\n-impl From<Signature> for JsonSignature {\n-    fn from(data: Signature) -> JsonSignature {\n-        JsonSignature {\n-            span: data.span,\n-            text: data.text,\n-            ident_start: data.ident_start,\n-            ident_end: data.ident_end,\n-            defs: data.defs.into_iter().map(|s| From::from(s)).collect(),\n-            refs: data.refs.into_iter().map(|s| From::from(s)).collect(),\n+impl Into<Signature> for external_data::Signature {\n+    fn into(self) -> Signature {\n+        Signature {\n+            span: self.span,\n+            text: self.text,\n+            ident_start: self.ident_start,\n+            ident_end: self.ident_end,\n+            defs: self.defs.into_iter().map(|s| s.into()).collect(),\n+            refs: self.refs.into_iter().map(|s| s.into()).collect(),\n         }\n     }\n }\n \n-#[derive(Debug, RustcEncodable)]\n-pub struct JsonSigElement {\n-    id: Id,\n-    start: usize,\n-    end: usize,\n-}\n-\n-impl From<SigElement> for JsonSigElement {\n-    fn from(data: SigElement) -> JsonSigElement {\n-        JsonSigElement {\n-            id: From::from(data.id),\n-            start: data.start,\n-            end: data.end,\n+impl Into<SigElement> for data::SigElement {\n+    fn into(self) -> SigElement {\n+        SigElement {\n+            id: id_from_def_id(self.id),\n+            start: self.start,\n+            end: self.end,\n         }\n     }\n }"}, {"sha": "5e2b1df9d34f89451f28737760f2f4648dc487bc", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -26,9 +26,12 @@\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n-extern crate serialize as rustc_serialize;\n+extern crate rustc_serialize;\n extern crate syntax_pos;\n \n+extern crate rls_data;\n+extern crate rls_span;\n+\n \n mod csv_dumper;\n mod json_api_dumper;"}, {"sha": "762bf8592ffccf83049d8804013b8d00f437141d", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -261,7 +261,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"ctlz\" | \"cttz\" | \"ctpop\" | \"bswap\" |\n         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n-        \"unchecked_div\" | \"unchecked_rem\" => {\n+        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n             let sty = &arg_tys[0].sty;\n             match int_type_width_signed(sty, ccx) {\n                 Some((width, signed)) =>\n@@ -311,6 +311,13 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             } else {\n                                 bcx.urem(llargs[0], llargs[1])\n                             },\n+                        \"unchecked_shl\" => bcx.shl(llargs[0], llargs[1]),\n+                        \"unchecked_shr\" =>\n+                            if signed {\n+                                bcx.ashr(llargs[0], llargs[1])\n+                            } else {\n+                                bcx.lshr(llargs[0], llargs[1])\n+                            },\n                         _ => bug!(),\n                     },\n                 None => {"}, {"sha": "529ee107c46cee8db04acf0ff6f9ba53801b757a", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Call the generic checker.\n         let expected_arg_tys =\n-            self.expected_types_for_fn_args(call_expr.span,\n+            self.expected_inputs_for_expected_output(call_expr.span,\n                                             expected,\n                                             fn_sig.output(),\n                                             fn_sig.inputs());\n@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // do know the types expected for each argument and the return\n         // type.\n \n-        let expected_arg_tys = self.expected_types_for_fn_args(call_expr.span,\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(call_expr.span,\n                                                                expected,\n                                                                fn_sig.output().clone(),\n                                                                fn_sig.inputs());"}, {"sha": "2861fd288326b001f639e03bbf4fd7bb7f61a140", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -273,6 +273,8 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             \"unchecked_div\" | \"unchecked_rem\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n+            \"unchecked_shl\" | \"unchecked_shr\" =>\n+                (1, vec![param(0), param(0)], param(0)),\n \n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n                 (1, vec![param(0), param(0)], param(0)),"}, {"sha": "f36254a8a10eaaa3794be3c1a10deaafb1879ac0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -2292,7 +2292,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match method_fn_ty.sty {\n                 ty::TyFnDef(def_id, .., ref fty) => {\n                     // HACK(eddyb) ignore self in the definition (see above).\n-                    let expected_arg_tys = self.expected_types_for_fn_args(\n+                    let expected_arg_tys = self.expected_inputs_for_expected_output(\n                         sp,\n                         expected,\n                         fty.0.output(),\n@@ -2645,14 +2645,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         TypeAndSubsts { substs: substs, ty: substd_ty }\n     }\n \n-    /// Unifies the return type with the expected type early, for more coercions\n-    /// and forward type information on the argument expressions.\n-    fn expected_types_for_fn_args(&self,\n-                                  call_span: Span,\n-                                  expected_ret: Expectation<'tcx>,\n-                                  formal_ret: Ty<'tcx>,\n-                                  formal_args: &[Ty<'tcx>])\n-                                  -> Vec<Ty<'tcx>> {\n+    /// Unifies the output type with the expected type early, for more coercions\n+    /// and forward type information on the input expressions.\n+    fn expected_inputs_for_expected_output(&self,\n+                                           call_span: Span,\n+                                           expected_ret: Expectation<'tcx>,\n+                                           formal_ret: Ty<'tcx>,\n+                                           formal_args: &[Ty<'tcx>])\n+                                           -> Vec<Ty<'tcx>> {\n         let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n             self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n                 // Attempt to apply a subtyping relationship between the formal\n@@ -2675,7 +2675,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }).collect())\n             }).ok()\n         }).unwrap_or(vec![]);\n-        debug!(\"expected_types_for_fn_args(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n+        debug!(\"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n                formal_args, formal_ret,\n                expected_args, expected_ret);\n         expected_args\n@@ -3032,14 +3032,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_struct_fields(&self,\n                                 adt_ty: Ty<'tcx>,\n+                                expected: Expectation<'tcx>,\n                                 expr_id: ast::NodeId,\n                                 span: Span,\n                                 variant: &'tcx ty::VariantDef,\n                                 ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n-        let (substs, adt_kind, kind_name) = match adt_ty.sty {\n-            ty::TyAdt(adt, substs) => (substs, adt.adt_kind(), adt.variant_descr()),\n+\n+        let adt_ty_hint =\n+            self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n+                .get(0).cloned().unwrap_or(adt_ty);\n+\n+        let (substs, hint_substs, adt_kind, kind_name) = match (&adt_ty.sty, &adt_ty_hint.sty) {\n+            (&ty::TyAdt(adt, substs), &ty::TyAdt(_, hint_substs)) => {\n+                (substs, hint_substs, adt.adt_kind(), adt.variant_descr())\n+            }\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n@@ -3054,10 +3062,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Typecheck each field.\n         for field in ast_fields {\n-            let expected_field_type;\n+            let final_field_type;\n+            let field_type_hint;\n \n             if let Some(v_field) = remaining_fields.remove(&field.name.node) {\n-                expected_field_type = self.field_ty(field.span, v_field, substs);\n+                final_field_type = self.field_ty(field.span, v_field, substs);\n+                field_type_hint = self.field_ty(field.span, v_field, hint_substs);\n \n                 seen_fields.insert(field.name.node, field.span);\n \n@@ -3069,7 +3079,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             } else {\n                 error_happened = true;\n-                expected_field_type = tcx.types.err;\n+                final_field_type = tcx.types.err;\n+                field_type_hint = tcx.types.err;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n                                                 field.name.span,\n@@ -3091,7 +3102,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue typechecking\n-            self.check_expr_coercable_to_type(&field.expr, expected_field_type);\n+            let ty = self.check_expr_with_hint(&field.expr, field_type_hint);\n+            self.demand_coerce(&field.expr, ty, final_field_type);\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -3201,6 +3213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n+                         expected: Expectation<'tcx>,\n                          qpath: &hir::QPath,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n@@ -3219,7 +3232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n-        self.check_expr_struct_fields(struct_ty, expr.id, path_span, variant, fields,\n+        self.check_expr_struct_fields(struct_ty, expected, expr.id, path_span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             self.check_expr_has_type(base_expr, struct_ty);\n@@ -3764,7 +3777,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n           }\n           hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, qpath, fields, base_expr)\n+            self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n             self.check_field(expr, lvalue_pref, &base, field)"}, {"sha": "f3ea6c4467c401c396bccf1733a2494ea1040efa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -2241,11 +2241,11 @@ pub enum PathParameters {\n     AngleBracketed {\n         lifetimes: Vec<Lifetime>,\n         types: Vec<Type>,\n-        bindings: Vec<TypeBinding>\n+        bindings: Vec<TypeBinding>,\n     },\n     Parenthesized {\n         inputs: Vec<Type>,\n-        output: Option<Type>\n+        output: Option<Type>,\n     }\n }\n \n@@ -2260,14 +2260,14 @@ impl Clean<PathParameters> for hir::PathParameters {\n                         data.lifetimes.clean(cx)\n                     },\n                     types: data.types.clean(cx),\n-                    bindings: data.bindings.clean(cx)\n+                    bindings: data.bindings.clean(cx),\n                 }\n             }\n \n             hir::ParenthesizedParameters(ref data) => {\n                 PathParameters::Parenthesized {\n                     inputs: data.inputs.clean(cx),\n-                    output: data.output.clean(cx)\n+                    output: data.output.clean(cx),\n                 }\n             }\n         }"}, {"sha": "a255ba0ad4edf0b5067f0e368f399dcf82e6c83d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -481,7 +481,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         if is_not_debug {\n             write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n         } else {\n-            write!(w, \"{:?}{:?}\", HRef::new(did, &last.name), last.params)?;\n+            write!(w, \"{:?}{}\", HRef::new(did, &last.name), last.params)?;\n         }\n     } else {\n         if is_not_debug {\n@@ -507,7 +507,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n             } else {\n                 format!(\"{:?}\", HRef::new(did, &last.name))\n             };\n-            write!(w, \"{}{:?}\", path, last.params)?;\n+            write!(w, \"{}{}\", path, last.params)?;\n         }\n     }\n     Ok(())"}, {"sha": "3d80120f6b2bd0f90d5964d21babf77860538d2f", "filename": "src/libstd/error.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -216,6 +216,11 @@ impl<'a> From<&'a str> for Box<Error> {\n     }\n }\n \n+#[stable(feature = \"never_error\", since = \"1.18.0\")]\n+impl Error for ! {\n+    fn description(&self) -> &str { *self }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for str::ParseBoolError {\n     fn description(&self) -> &str { \"failed to parse bool\" }"}, {"sha": "d01ed1e3fe63a170a106ed92f65735d943a0f379", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -272,6 +272,7 @@\n #![feature(linkage)]\n #![feature(macro_reexport)]\n #![feature(needs_panic_runtime)]\n+#![feature(never_type)]\n #![feature(num_bits_bytes)]\n #![feature(old_wrapping)]\n #![feature(on_unimplemented)]"}, {"sha": "b75b3efda36c8d8670dae90b0541797095cc0d74", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -162,6 +162,12 @@ impl From<TokenTree> for TokenStream {\n     }\n }\n \n+impl From<Token> for TokenStream {\n+    fn from(token: Token) -> TokenStream {\n+        TokenTree::Token(DUMMY_SP, token).into()\n+    }\n+}\n+\n impl<T: Into<TokenStream>> iter::FromIterator<T> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n         TokenStream::concat(iter.into_iter().map(Into::into).collect::<Vec<_>>())"}, {"sha": "5ab786f40b9335aca5b7a36d5e0af99c8869e995", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #include \"rustllvm.h\"\n+#include \"llvm/IR/DebugInfoMetadata.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"\n #include \"llvm/IR/Instructions.h\"\n@@ -594,7 +595,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n     const char *LinkageName, LLVMRustMetadataRef File, unsigned LineNo,\n     LLVMRustMetadataRef Ty, bool IsLocalToUnit, LLVMValueRef V,\n     LLVMRustMetadataRef Decl = nullptr, uint32_t AlignInBits = 0) {\n-  Constant *InitVal = cast<Constant>(unwrap(V));\n+  llvm::GlobalVariable *InitVal = cast<llvm::GlobalVariable>(unwrap(V));\n \n #if LLVM_VERSION_GE(4, 0)\n   llvm::DIExpression *InitExpr = nullptr;\n@@ -606,26 +607,21 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n     InitExpr = Builder->createConstantValueExpression(\n         FPVal->getValueAPF().bitcastToAPInt().getZExtValue());\n   }\n-#endif\n \n-#if LLVM_VERSION_GE(4, 0)\n-  return wrap(Builder->createGlobalVariableExpression(\n+  llvm::DIGlobalVariableExpression *VarExpr = Builder->createGlobalVariableExpression(\n+      unwrapDI<DIDescriptor>(Context), Name, LinkageName,\n+      unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), IsLocalToUnit,\n+      InitExpr, unwrapDIPtr<MDNode>(Decl), AlignInBits);\n+\n+  InitVal->setMetadata(\"dbg\", VarExpr);\n+\n+  return wrap(VarExpr);\n #else\n   return wrap(Builder->createGlobalVariable(\n-#endif\n       unwrapDI<DIDescriptor>(Context), Name, LinkageName,\n       unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), IsLocalToUnit,\n-#if LLVM_VERSION_GE(4, 0)\n-      InitExpr,\n-#else\n-      InitVal,\n-#endif\n-      unwrapDIPtr<MDNode>(Decl)\n-#if LLVM_VERSION_GE(4, 0)\n-      ,\n-      AlignInBits\n+      InitVal, unwrapDIPtr<MDNode>(Decl)));\n #endif\n-      ));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable("}, {"sha": "0433b95865ef8c4591479fb9a660d93fd8b38ce2", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -49,9 +49,10 @@ fn cond(input: TokenStream) -> TokenStream {\n             _ => false,\n         };\n         conds.push(if is_else || input.peek().is_none() {\n-            qquote!({ unquote rhs })\n+            quote!({ $rhs })\n         } else {\n-            qquote!(if unquote(test.unwrap()) { unquote rhs } else)\n+            let test = test.unwrap();\n+            quote!(if $test { $rhs } else)\n         });\n     }\n "}, {"sha": "9522592a5e9e6642d79c072bf873c78e78770682", "filename": "src/test/run-pass-fulldeps/auxiliary/hello_macro.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fhello_macro.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -29,6 +29,11 @@ pub fn plugin_registrar(reg: &mut Registry) {\n \n // This macro is not very interesting, but it does contain delimited tokens with\n // no content - `()` and `{}` - which has caused problems in the past.\n+// Also, it tests that we can escape `$` via `$$`.\n fn hello(_: TokenStream) -> TokenStream {\n-    qquote!({ fn hello() {} hello(); })\n+    quote!({\n+        fn hello() {}\n+        macro_rules! m { ($$($$t:tt)*) => { $$($$t)* } }\n+        m!(hello());\n+    })\n }"}, {"sha": "0e37a7a5dcce22f8daf5d603513812ac44c0689b", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -34,21 +34,21 @@ pub fn plugin_registrar(reg: &mut Registry) {\n }\n \n fn attr_tru(_attr: TokenStream, _item: TokenStream) -> TokenStream {\n-    qquote!(fn f1() -> bool { true })\n+    quote!(fn f1() -> bool { true })\n }\n \n fn attr_identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n-    qquote!(unquote item)\n+    quote!($item)\n }\n \n fn tru(_ts: TokenStream) -> TokenStream {\n-    qquote!(true)\n+    quote!(true)\n }\n \n fn ret_tru(_ts: TokenStream) -> TokenStream {\n-    qquote!(return true;)\n+    quote!(return true;)\n }\n \n fn identity(ts: TokenStream) -> TokenStream {\n-    qquote!(unquote ts)\n+    quote!($ts)\n }"}, {"sha": "01b0ed802354c74e19f15f217738caa7bf50a685", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -22,6 +22,6 @@ use syntax::parse::token;\n use syntax::tokenstream::TokenTree;\n \n fn main() {\n-    let true_tok = TokenTree::Token(syntax_pos::DUMMY_SP, token::Ident(Ident::from_str(\"true\")));\n-    assert!(qquote!(true).eq_unspanned(&true_tok.into()));\n+    let true_tok = token::Ident(Ident::from_str(\"true\"));\n+    assert!(quote!(true).eq_unspanned(&true_tok.into()));\n }"}, {"sha": "bdbea8a419416f7db089719dcb19587c913bc711", "filename": "src/test/run-pass-fulldeps/macro-quote-test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-test.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "previous_filename": "src/test/run-pass-fulldeps/macro-quote-empty-delims.rs"}, {"sha": "cef2f879f9cd74bc69c1209713fdda0ab1a4f48a", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -160,6 +160,34 @@ pub fn main() {\n     t!(format!(\"{:?}\", -0.0), \"-0\");\n     t!(format!(\"{:?}\", 0.0), \"0\");\n \n+    // sign aware zero padding\n+    t!(format!(\"{:<3}\", 1), \"1  \");\n+    t!(format!(\"{:>3}\", 1), \"  1\");\n+    t!(format!(\"{:^3}\", 1), \" 1 \");\n+    t!(format!(\"{:03}\", 1), \"001\");\n+    t!(format!(\"{:<03}\", 1), \"001\");\n+    t!(format!(\"{:>03}\", 1), \"001\");\n+    t!(format!(\"{:^03}\", 1), \"001\");\n+    t!(format!(\"{:+03}\", 1), \"+01\");\n+    t!(format!(\"{:<+03}\", 1), \"+01\");\n+    t!(format!(\"{:>+03}\", 1), \"+01\");\n+    t!(format!(\"{:^+03}\", 1), \"+01\");\n+    t!(format!(\"{:#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:<#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:>#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:^#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:<05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:>05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:^05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:<05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:>05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:^05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:<+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:>+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:^+05}\", 1.2), \"+01.2\");\n \n     // Ergonomic format_args!\n     t!(format!(\"{0:x} {0:X}\", 15), \"f F\");"}, {"sha": "e771fc7464d00322eb20a142355f61b323a5750c", "filename": "src/test/run-pass/issue-31260.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass%2Fissue-31260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frun-pass%2Fissue-31260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-31260.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Struct<K: 'static> {\n+    pub field: K,\n+}\n+\n+// Partial fix for #31260, doesn't work without {...}.\n+static STRUCT: Struct<&'static [u8]> = Struct {\n+    field: {&[1]}\n+};\n+\n+fn main() {}"}, {"sha": "9f70fe43175b9a68d555cab7efbbeccf9c327c9c", "filename": "src/test/rustdoc/const-doc.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frustdoc%2Fconst-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244f893ed704a60841d4615445d540a21a8d7722/src%2Ftest%2Frustdoc%2Fconst-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-doc.rs?ref=244f893ed704a60841d4615445d540a21a8d7722", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+use std::marker::PhantomData;\n+\n+pub struct Foo<'a> {\n+    f: PhantomData<&'a u32>,\n+}\n+\n+pub struct ContentType {\n+    pub ttype: Foo<'static>,\n+    pub subtype: Foo<'static>,\n+    pub params: Option<Foo<'static>>,\n+}\n+\n+impl ContentType {\n+    // @has const_doc/struct.ContentType.html\n+    // @has  - '//*[@class=\"docblock\"]' 'Any: ContentType = ContentType{ttype: Foo{f: '\n+    pub const Any: ContentType = ContentType { ttype: Foo { f: PhantomData, },\n+                                               subtype: Foo { f: PhantomData, },\n+                                               params: None, };\n+}"}]}