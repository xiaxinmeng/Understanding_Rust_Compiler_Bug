{"sha": "623d8c4640b03d38edb57acbfa8242a144942bac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyM2Q4YzQ2NDBiMDNkMzhlZGI1N2FjYmZhODI0MmExNDQ5NDJiYWM=", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2019-11-23T17:16:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-23T17:16:00Z"}, "message": "Rollup merge of #4811 - mikerite:lit_repr_20191113, r=flip1995\n\nLiteral Representation Restructure\n\nThis pull request restructures the literal_representation module to be easier to understand and maintain. I split the changes into a lot of commits to make reviewing easier.\n\nchangelog: none", "tree": {"sha": "3f3abd74649f9cda34a21d2ebcd4f1e50a7c24c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f3abd74649f9cda34a21d2ebcd4f1e50a7c24c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/623d8c4640b03d38edb57acbfa8242a144942bac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd2WlQCRBK7hj4Ov3rIwAAdHIIAB7CN/jwEf6C7WGdhq5eO17h\njUHY45XS7KSDwWf2/t8CovJXHPA00I5UVTaHNCW8y0whsPjsWjo3LazvjAxLinOt\nErO3WvPKDvZmN7GF69biY7qb21cxCcX7vh2yf6FYppH32jdlUSzkNPBOoCrWVR+c\niQDjq7QbMnOi5efXd/rlObBWHbI697WbrwWMCWSFiw1M6L215glYEdTydZcNwz96\nJwbG5e7/EJZLfe7LMbu9riE4PsAr/R8bW6M4D0EBe8w7bwsw3pdkbA2LFKkO8+c0\n24AZTbXD6ub4Dm+vS69K4mkso0FTm4rfk/1SkEvgShE5EKha9upV1ZzyZxoWUFc=\n=juuz\n-----END PGP SIGNATURE-----\n", "payload": "tree 3f3abd74649f9cda34a21d2ebcd4f1e50a7c24c1\nparent 93d84d7dda18bf597ea420b0e9b5fd7bc989b10b\nparent ceb0b2d41a3a36e2e3a44a5245b14c08d688031a\nauthor Philipp Krones <hello@philkrones.com> 1574529360 +0100\ncommitter GitHub <noreply@github.com> 1574529360 +0100\n\nRollup merge of #4811 - mikerite:lit_repr_20191113, r=flip1995\n\nLiteral Representation Restructure\n\nThis pull request restructures the literal_representation module to be easier to understand and maintain. I split the changes into a lot of commits to make reviewing easier.\n\nchangelog: none\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/623d8c4640b03d38edb57acbfa8242a144942bac", "html_url": "https://github.com/rust-lang/rust/commit/623d8c4640b03d38edb57acbfa8242a144942bac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/623d8c4640b03d38edb57acbfa8242a144942bac/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93d84d7dda18bf597ea420b0e9b5fd7bc989b10b", "url": "https://api.github.com/repos/rust-lang/rust/commits/93d84d7dda18bf597ea420b0e9b5fd7bc989b10b", "html_url": "https://github.com/rust-lang/rust/commit/93d84d7dda18bf597ea420b0e9b5fd7bc989b10b"}, {"sha": "ceb0b2d41a3a36e2e3a44a5245b14c08d688031a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceb0b2d41a3a36e2e3a44a5245b14c08d688031a", "html_url": "https://github.com/rust-lang/rust/commit/ceb0b2d41a3a36e2e3a44a5245b14c08d688031a"}], "stats": {"total": 659, "additions": 393, "deletions": 266}, "files": [{"sha": "40dbaa17732ff325dfea9e013df263bea54d237e", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -1,4 +1,5 @@\n use crate::utils::span_lint_and_sugg;\n+use crate::utils::sugg::format_numeric_literal;\n use if_chain::if_chain;\n use rustc::hir;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -86,8 +87,7 @@ impl ExcessivePrecision {\n             if sym_str == s {\n                 None\n             } else {\n-                let di = super::literal_representation::DigitInfo::new(&s, true);\n-                Some(di.grouping_hint())\n+                Some(format_numeric_literal(&s, None, true))\n             }\n         } else {\n             None"}, {"sha": "8aa0e87296873f3719c9cead9ef6927b8a6b5cc7", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 268, "deletions": 251, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -114,31 +114,51 @@ pub(super) enum Radix {\n impl Radix {\n     /// Returns a reasonable digit group size for this radix.\n     #[must_use]\n-    crate fn suggest_grouping(&self) -> usize {\n+    fn suggest_grouping(&self) -> usize {\n         match *self {\n             Self::Binary | Self::Hexadecimal => 4,\n             Self::Octal | Self::Decimal => 3,\n         }\n     }\n }\n \n+/// A helper method to format numeric literals with digit grouping.\n+/// `lit` must be a valid numeric literal without suffix.\n+pub fn format_numeric_literal(lit: &str, type_suffix: Option<&str>, float: bool) -> String {\n+    NumericLiteral::new(lit, type_suffix, float).format()\n+}\n+\n #[derive(Debug)]\n-pub(super) struct DigitInfo<'a> {\n-    /// Characters of a literal between the radix prefix and type suffix.\n-    crate digits: &'a str,\n+pub(super) struct NumericLiteral<'a> {\n     /// Which radix the literal was represented in.\n-    crate radix: Radix,\n+    radix: Radix,\n     /// The radix prefix, if present.\n-    crate prefix: Option<&'a str>,\n+    prefix: Option<&'a str>,\n+\n+    /// The integer part of the number.\n+    integer: &'a str,\n+    /// The fraction part of the number.\n+    fraction: Option<&'a str>,\n+    /// The character used as exponent seperator (b'e' or b'E') and the exponent part.\n+    exponent: Option<(char, &'a str)>,\n+\n     /// The type suffix, including preceding underscore if present.\n-    crate suffix: Option<&'a str>,\n-    /// True for floating-point literals.\n-    crate float: bool,\n+    suffix: Option<&'a str>,\n }\n \n-impl<'a> DigitInfo<'a> {\n+impl<'a> NumericLiteral<'a> {\n+    fn from_lit(src: &'a str, lit: &Lit) -> Option<NumericLiteral<'a>> {\n+        if lit.kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n+            let (unsuffixed, suffix) = split_suffix(&src, &lit.kind);\n+            let float = if let LitKind::Float(..) = lit.kind { true } else { false };\n+            Some(NumericLiteral::new(unsuffixed, suffix, float))\n+        } else {\n+            None\n+        }\n+    }\n+\n     #[must_use]\n-    crate fn new(lit: &'a str, float: bool) -> Self {\n+    fn new(lit: &'a str, suffix: Option<&'a str>, float: bool) -> Self {\n         // Determine delimiter for radix prefix, if present, and radix.\n         let radix = if lit.starts_with(\"0x\") {\n             Radix::Hexadecimal\n@@ -151,131 +171,156 @@ impl<'a> DigitInfo<'a> {\n         };\n \n         // Grab part of the literal after prefix, if present.\n-        let (prefix, sans_prefix) = if let Radix::Decimal = radix {\n+        let (prefix, mut sans_prefix) = if let Radix::Decimal = radix {\n             (None, lit)\n         } else {\n             let (p, s) = lit.split_at(2);\n             (Some(p), s)\n         };\n \n-        let len = sans_prefix.len();\n-        let mut last_d = '\\0';\n-        for (d_idx, d) in sans_prefix.char_indices() {\n-            let suffix_start = if last_d == '_' { d_idx - 1 } else { d_idx };\n-            if float\n-                && (d == 'f'\n-                    || is_possible_float_suffix_index(&sans_prefix, suffix_start, len)\n-                    || ((d == 'E' || d == 'e') && !has_possible_float_suffix(&sans_prefix)))\n-                || !float && (d == 'i' || d == 'u' || is_possible_suffix_index(&sans_prefix, suffix_start, len))\n-            {\n-                let (digits, suffix) = sans_prefix.split_at(suffix_start);\n-                return Self {\n-                    digits,\n-                    radix,\n-                    prefix,\n-                    suffix: Some(suffix),\n-                    float,\n-                };\n-            }\n-            last_d = d\n+        if suffix.is_some() && sans_prefix.ends_with('_') {\n+            // The '_' before the suffix isn't part of the digits\n+            sans_prefix = &sans_prefix[..sans_prefix.len() - 1];\n         }\n \n-        // No suffix found\n+        let (integer, fraction, exponent) = Self::split_digit_parts(sans_prefix, float);\n+\n         Self {\n-            digits: sans_prefix,\n             radix,\n             prefix,\n-            suffix: None,\n-            float,\n+            integer,\n+            fraction,\n+            exponent,\n+            suffix,\n+        }\n+    }\n+\n+    fn split_digit_parts(digits: &str, float: bool) -> (&str, Option<&str>, Option<(char, &str)>) {\n+        let mut integer = digits;\n+        let mut fraction = None;\n+        let mut exponent = None;\n+\n+        if float {\n+            for (i, c) in digits.char_indices() {\n+                match c {\n+                    '.' => {\n+                        integer = &digits[..i];\n+                        fraction = Some(&digits[i + 1..]);\n+                    },\n+                    'e' | 'E' => {\n+                        if integer.len() > i {\n+                            integer = &digits[..i];\n+                        } else {\n+                            fraction = Some(&digits[integer.len() + 1..i]);\n+                        };\n+                        exponent = Some((c, &digits[i + 1..]));\n+                        break;\n+                    },\n+                    _ => {},\n+                }\n+            }\n         }\n+\n+        (integer, fraction, exponent)\n     }\n \n     /// Returns literal formatted in a sensible way.\n-    crate fn grouping_hint(&self) -> String {\n+    fn format(&self) -> String {\n+        let mut output = String::new();\n+\n+        if let Some(prefix) = self.prefix {\n+            output.push_str(prefix);\n+        }\n+\n         let group_size = self.radix.suggest_grouping();\n-        if self.digits.contains('.') {\n-            let mut parts = self.digits.split('.');\n-            let int_part_hint = parts\n-                .next()\n-                .expect(\"split always returns at least one element\")\n-                .chars()\n-                .rev()\n-                .filter(|&c| c != '_')\n-                .collect::<Vec<_>>()\n-                .chunks(group_size)\n-                .map(|chunk| chunk.iter().rev().collect())\n-                .rev()\n-                .collect::<Vec<String>>()\n-                .join(\"_\");\n-            let frac_part_hint = parts\n-                .next()\n-                .expect(\"already checked that there is a `.`\")\n-                .chars()\n-                .filter(|&c| c != '_')\n-                .collect::<Vec<_>>()\n-                .chunks(group_size)\n-                .map(|chunk| chunk.iter().collect())\n-                .collect::<Vec<String>>()\n-                .join(\"_\");\n-            let suffix_hint = match self.suffix {\n-                Some(suffix) if is_mistyped_float_suffix(suffix) => format!(\"_f{}\", &suffix[1..]),\n-                Some(suffix) => suffix.to_string(),\n-                None => String::new(),\n-            };\n-            format!(\"{}.{}{}\", int_part_hint, frac_part_hint, suffix_hint)\n-        } else if self.float && (self.digits.contains('E') || self.digits.contains('e')) {\n-            let which_e = if self.digits.contains('E') { 'E' } else { 'e' };\n-            let parts: Vec<&str> = self.digits.split(which_e).collect();\n-            let filtered_digits_vec_0 = parts[0].chars().filter(|&c| c != '_').rev().collect::<Vec<_>>();\n-            let filtered_digits_vec_1 = parts[1].chars().filter(|&c| c != '_').rev().collect::<Vec<_>>();\n-            let before_e_hint = filtered_digits_vec_0\n-                .chunks(group_size)\n-                .map(|chunk| chunk.iter().rev().collect())\n-                .rev()\n-                .collect::<Vec<String>>()\n-                .join(\"_\");\n-            let after_e_hint = filtered_digits_vec_1\n-                .chunks(group_size)\n-                .map(|chunk| chunk.iter().rev().collect())\n-                .rev()\n-                .collect::<Vec<String>>()\n-                .join(\"_\");\n-            let suffix_hint = match self.suffix {\n-                Some(suffix) if is_mistyped_float_suffix(suffix) => format!(\"_f{}\", &suffix[1..]),\n-                Some(suffix) => suffix.to_string(),\n-                None => String::new(),\n-            };\n-            format!(\n-                \"{}{}{}{}{}\",\n-                self.prefix.unwrap_or(\"\"),\n-                before_e_hint,\n-                which_e,\n-                after_e_hint,\n-                suffix_hint\n-            )\n+\n+        Self::group_digits(\n+            &mut output,\n+            self.integer,\n+            group_size,\n+            true,\n+            self.radix == Radix::Hexadecimal,\n+        );\n+\n+        if let Some(fraction) = self.fraction {\n+            output.push('.');\n+            Self::group_digits(&mut output, fraction, group_size, false, false);\n+        }\n+\n+        if let Some((separator, exponent)) = self.exponent {\n+            output.push(separator);\n+            Self::group_digits(&mut output, exponent, group_size, true, false);\n+        }\n+\n+        if let Some(suffix) = self.suffix {\n+            output.push('_');\n+            output.push_str(suffix);\n+        }\n+\n+        output\n+    }\n+\n+    fn group_digits(output: &mut String, input: &str, group_size: usize, partial_group_first: bool, pad: bool) {\n+        debug_assert!(group_size > 0);\n+\n+        let mut digits = input.chars().filter(|&c| c != '_');\n+\n+        let first_group_size;\n+\n+        if partial_group_first {\n+            first_group_size = (digits.clone().count() - 1) % group_size + 1;\n+            if pad {\n+                for _ in 0..group_size - first_group_size {\n+                    output.push('0');\n+                }\n+            }\n         } else {\n-            let filtered_digits_vec = self.digits.chars().filter(|&c| c != '_').rev().collect::<Vec<_>>();\n-            let mut hint = filtered_digits_vec\n-                .chunks(group_size)\n-                .map(|chunk| chunk.iter().rev().collect())\n-                .rev()\n-                .collect::<Vec<String>>()\n-                .join(\"_\");\n-            // Forces hexadecimal values to be grouped by 4 being filled with zeroes (e.g 0x00ab_cdef)\n-            let nb_digits_to_fill = filtered_digits_vec.len() % 4;\n-            if self.radix == Radix::Hexadecimal && nb_digits_to_fill != 0 {\n-                hint = format!(\"{:0>4}{}\", &hint[..nb_digits_to_fill], &hint[nb_digits_to_fill..]);\n+            first_group_size = group_size;\n+        }\n+\n+        for _ in 0..first_group_size {\n+            if let Some(digit) = digits.next() {\n+                output.push(digit);\n+            }\n+        }\n+\n+        for (c, i) in digits.zip((0..group_size).cycle()) {\n+            if i == 0 {\n+                output.push('_');\n             }\n-            let suffix_hint = match self.suffix {\n-                Some(suffix) if is_mistyped_suffix(suffix) => format!(\"_i{}\", &suffix[1..]),\n-                Some(suffix) => suffix.to_string(),\n-                None => String::new(),\n-            };\n-            format!(\"{}{}{}\", self.prefix.unwrap_or(\"\"), hint, suffix_hint)\n+            output.push(c);\n         }\n     }\n }\n \n+fn split_suffix<'a>(src: &'a str, lit_kind: &LitKind) -> (&'a str, Option<&'a str>) {\n+    debug_assert!(lit_kind.is_numeric());\n+    if let Some(suffix_length) = lit_suffix_length(lit_kind) {\n+        let (unsuffixed, suffix) = src.split_at(src.len() - suffix_length);\n+        (unsuffixed, Some(suffix))\n+    } else {\n+        (src, None)\n+    }\n+}\n+\n+fn lit_suffix_length(lit_kind: &LitKind) -> Option<usize> {\n+    debug_assert!(lit_kind.is_numeric());\n+    let suffix = match lit_kind {\n+        LitKind::Int(_, int_lit_kind) => match int_lit_kind {\n+            LitIntType::Signed(int_ty) => Some(int_ty.name_str()),\n+            LitIntType::Unsigned(uint_ty) => Some(uint_ty.name_str()),\n+            LitIntType::Unsuffixed => None,\n+        },\n+        LitKind::Float(_, float_lit_kind) => match float_lit_kind {\n+            LitFloatType::Suffixed(float_ty) => Some(float_ty.name_str()),\n+            LitFloatType::Unsuffixed => None,\n+        },\n+        _ => None,\n+    };\n+\n+    suffix.map(str::len)\n+}\n+\n enum WarningType {\n     UnreadableLiteral,\n     InconsistentDigitGrouping,\n@@ -285,15 +330,15 @@ enum WarningType {\n }\n \n impl WarningType {\n-    crate fn display(&self, grouping_hint: &str, cx: &EarlyContext<'_>, span: syntax_pos::Span) {\n+    fn display(&self, suggested_format: String, cx: &EarlyContext<'_>, span: syntax_pos::Span) {\n         match self {\n             Self::MistypedLiteralSuffix => span_lint_and_sugg(\n                 cx,\n                 MISTYPED_LITERAL_SUFFIXES,\n                 span,\n                 \"mistyped literal suffix\",\n                 \"did you mean to write\",\n-                grouping_hint.to_string(),\n+                suggested_format,\n                 Applicability::MaybeIncorrect,\n             ),\n             Self::UnreadableLiteral => span_lint_and_sugg(\n@@ -302,7 +347,7 @@ impl WarningType {\n                 span,\n                 \"long literal lacking separators\",\n                 \"consider\",\n-                grouping_hint.to_owned(),\n+                suggested_format,\n                 Applicability::MachineApplicable,\n             ),\n             Self::LargeDigitGroups => span_lint_and_sugg(\n@@ -311,7 +356,7 @@ impl WarningType {\n                 span,\n                 \"digit groups should be smaller\",\n                 \"consider\",\n-                grouping_hint.to_owned(),\n+                suggested_format,\n                 Applicability::MachineApplicable,\n             ),\n             Self::InconsistentDigitGrouping => span_lint_and_sugg(\n@@ -320,7 +365,7 @@ impl WarningType {\n                 span,\n                 \"digits grouped inconsistently by underscores\",\n                 \"consider\",\n-                grouping_hint.to_owned(),\n+                suggested_format,\n                 Applicability::MachineApplicable,\n             ),\n             Self::DecimalRepresentation => span_lint_and_sugg(\n@@ -329,7 +374,7 @@ impl WarningType {\n                 span,\n                 \"integer literal has a better hexadecimal representation\",\n                 \"consider\",\n-                grouping_hint.to_owned(),\n+                suggested_format,\n                 Applicability::MachineApplicable,\n             ),\n         };\n@@ -357,126 +402,125 @@ impl EarlyLintPass for LiteralDigitGrouping {\n \n impl LiteralDigitGrouping {\n     fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n-        let in_macro = in_macro(lit.span);\n-        match lit.kind {\n-            LitKind::Int(..) => {\n-                // Lint integral literals.\n-                if_chain! {\n-                    if let Some(src) = snippet_opt(cx, lit.span);\n-                    if let Some(firstch) = src.chars().next();\n-                    if char::is_digit(firstch, 10);\n-                    then {\n-                        let digit_info = DigitInfo::new(&src, false);\n-                        let _ = Self::do_lint(digit_info.digits, digit_info.suffix, in_macro).map_err(|warning_type| {\n-                            warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n-                        });\n-                    }\n+        if_chain! {\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if let Some(mut num_lit) = NumericLiteral::from_lit(&src, &lit);\n+            then {\n+                if !Self::check_for_mistyped_suffix(cx, lit.span, &mut num_lit) {\n+                    return;\n                 }\n-            },\n-            LitKind::Float(..) => {\n-                // Lint floating-point literals.\n-                if_chain! {\n-                    if let Some(src) = snippet_opt(cx, lit.span);\n-                    if let Some(firstch) = src.chars().next();\n-                    if char::is_digit(firstch, 10);\n-                    then {\n-                        let digit_info = DigitInfo::new(&src, true);\n-                        // Separate digits into integral and fractional parts.\n-                        let parts: Vec<&str> = digit_info\n-                            .digits\n-                            .split_terminator('.')\n-                            .collect();\n-\n-                        // Lint integral and fractional parts separately, and then check consistency of digit\n-                        // groups if both pass.\n-                        let _ = Self::do_lint(parts[0], digit_info.suffix, in_macro)\n-                            .map(|integral_group_size| {\n-                                if parts.len() > 1 {\n-                                    // Lint the fractional part of literal just like integral part, but reversed.\n-                                    let fractional_part = &parts[1].chars().rev().collect::<String>();\n-                                    let _ = Self::do_lint(fractional_part, None, in_macro)\n-                                        .map(|fractional_group_size| {\n-                                            let consistent = Self::parts_consistent(integral_group_size,\n-                                                                                    fractional_group_size,\n-                                                                                    parts[0].len(),\n-                                                                                    parts[1].len());\n-                                                if !consistent {\n-                                                    WarningType::InconsistentDigitGrouping.display(\n-                                                        &digit_info.grouping_hint(),\n-                                                        cx,\n-                                                        lit.span,\n-                                                    );\n-                                                }\n-                                        })\n-                                    .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),\n-                                    cx,\n-                                    lit.span));\n-                                }\n-                            })\n-                        .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, lit.span));\n+\n+                let result = (|| {\n+\n+                    let integral_group_size = Self::get_group_size(num_lit.integer.split('_'))?;\n+                    if let Some(fraction) = num_lit.fraction {\n+                        let fractional_group_size = Self::get_group_size(fraction.rsplit('_'))?;\n+\n+                        let consistent = Self::parts_consistent(integral_group_size,\n+                                                                fractional_group_size,\n+                                                                num_lit.integer.len(),\n+                                                                fraction.len());\n+                        if !consistent {\n+                            return Err(WarningType::InconsistentDigitGrouping);\n+                        };\n+                    }\n+                    Ok(())\n+                })();\n+\n+\n+                if let Err(warning_type) = result {\n+                    let should_warn = match warning_type {\n+                        | WarningType::UnreadableLiteral\n+                        | WarningType::InconsistentDigitGrouping\n+                        | WarningType::LargeDigitGroups => {\n+                            !in_macro(lit.span)\n+                        }\n+                        WarningType::DecimalRepresentation | WarningType::MistypedLiteralSuffix => {\n+                            true\n+                        }\n+                    };\n+                    if should_warn {\n+                        warning_type.display(num_lit.format(), cx, lit.span)\n                     }\n                 }\n-            },\n-            _ => (),\n+            }\n+        }\n+    }\n+\n+    // Returns `false` if the check fails\n+    fn check_for_mistyped_suffix(\n+        cx: &EarlyContext<'_>,\n+        span: syntax_pos::Span,\n+        num_lit: &mut NumericLiteral<'_>,\n+    ) -> bool {\n+        if num_lit.suffix.is_some() {\n+            return true;\n+        }\n+\n+        let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut num_lit.exponent {\n+            (exponent, &[\"32\", \"64\"][..], 'f')\n+        } else if let Some(fraction) = &mut num_lit.fraction {\n+            (fraction, &[\"32\", \"64\"][..], 'f')\n+        } else {\n+            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n+        };\n+\n+        let mut split = part.rsplit('_');\n+        let last_group = split.next().expect(\"At least one group\");\n+        if split.next().is_some() && mistyped_suffixes.contains(&last_group) {\n+            *part = &part[..part.len() - last_group.len()];\n+            let mut sugg = num_lit.format();\n+            sugg.push('_');\n+            sugg.push(missing_char);\n+            sugg.push_str(last_group);\n+            WarningType::MistypedLiteralSuffix.display(sugg, cx, span);\n+            false\n+        } else {\n+            true\n         }\n     }\n \n     /// Given the sizes of the digit groups of both integral and fractional\n     /// parts, and the length\n     /// of both parts, determine if the digits have been grouped consistently.\n     #[must_use]\n-    fn parts_consistent(int_group_size: usize, frac_group_size: usize, int_size: usize, frac_size: usize) -> bool {\n+    fn parts_consistent(\n+        int_group_size: Option<usize>,\n+        frac_group_size: Option<usize>,\n+        int_size: usize,\n+        frac_size: usize,\n+    ) -> bool {\n         match (int_group_size, frac_group_size) {\n             // No groups on either side of decimal point - trivially consistent.\n-            (0, 0) => true,\n+            (None, None) => true,\n             // Integral part has grouped digits, fractional part does not.\n-            (_, 0) => frac_size <= int_group_size,\n+            (Some(int_group_size), None) => frac_size <= int_group_size,\n             // Fractional part has grouped digits, integral part does not.\n-            (0, _) => int_size <= frac_group_size,\n+            (None, Some(frac_group_size)) => int_size <= frac_group_size,\n             // Both parts have grouped digits. Groups should be the same size.\n-            (_, _) => int_group_size == frac_group_size,\n+            (Some(int_group_size), Some(frac_group_size)) => int_group_size == frac_group_size,\n         }\n     }\n \n-    /// Performs lint on `digits` (no decimal point) and returns the group\n-    /// size on success or `WarningType` when emitting a warning.\n-    fn do_lint(digits: &str, suffix: Option<&str>, in_macro: bool) -> Result<usize, WarningType> {\n-        if let Some(suffix) = suffix {\n-            if is_mistyped_suffix(suffix) {\n-                return Err(WarningType::MistypedLiteralSuffix);\n-            }\n-        }\n-        // Grab underscore indices with respect to the units digit.\n-        let underscore_positions: Vec<usize> = digits\n-            .chars()\n-            .rev()\n-            .enumerate()\n-            .filter_map(|(idx, digit)| if digit == '_' { Some(idx) } else { None })\n-            .collect();\n-\n-        if underscore_positions.is_empty() {\n-            // Check if literal needs underscores.\n-            if !in_macro && digits.len() > 5 {\n-                Err(WarningType::UnreadableLiteral)\n+    /// Returns the size of the digit groups (or None if ungrouped) if successful,\n+    /// otherwise returns a `WarningType` for linting.\n+    fn get_group_size<'a>(groups: impl Iterator<Item = &'a str>) -> Result<Option<usize>, WarningType> {\n+        let mut groups = groups.map(str::len);\n+\n+        let first = groups.next().expect(\"At least one group\");\n+\n+        if let Some(second) = groups.next() {\n+            if !groups.all(|x| x == second) || first > second {\n+                Err(WarningType::InconsistentDigitGrouping)\n+            } else if second > 4 {\n+                Err(WarningType::LargeDigitGroups)\n             } else {\n-                Ok(0)\n+                Ok(Some(second))\n             }\n+        } else if first > 5 {\n+            Err(WarningType::UnreadableLiteral)\n         } else {\n-            // Check consistency and the sizes of the groups.\n-            let group_size = underscore_positions[0];\n-            let consistent = underscore_positions\n-                .windows(2)\n-                .all(|ps| ps[1] - ps[0] == group_size + 1)\n-                // number of digits to the left of the last group cannot be bigger than group size.\n-                && (digits.len() - underscore_positions.last()\n-                                                       .expect(\"there's at least one element\") <= group_size + 1);\n-\n-            if !consistent {\n-                return Err(WarningType::InconsistentDigitGrouping);\n-            } else if group_size > 4 {\n-                return Err(WarningType::LargeDigitGroups);\n-            }\n-            Ok(group_size)\n+            Ok(None)\n         }\n     }\n }\n@@ -511,16 +555,14 @@ impl DecimalLiteralRepresentation {\n         if_chain! {\n             if let LitKind::Int(val, _) = lit.kind;\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(firstch) = src.chars().next();\n-            if char::is_digit(firstch, 10);\n-            let digit_info = DigitInfo::new(&src, false);\n-            if digit_info.radix == Radix::Decimal;\n+            if let Some(num_lit) = NumericLiteral::from_lit(&src, &lit);\n+            if num_lit.radix == Radix::Decimal;\n             if val >= u128::from(self.threshold);\n             then {\n                 let hex = format!(\"{:#X}\", val);\n-                let digit_info = DigitInfo::new(&hex, false);\n-                let _ = Self::do_lint(digit_info.digits).map_err(|warning_type| {\n-                    warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n+                let num_lit = NumericLiteral::new(&hex, None, false);\n+                let _ = Self::do_lint(num_lit.integer).map_err(|warning_type| {\n+                    warning_type.display(num_lit.format(), cx, lit.span)\n                 });\n             }\n         }\n@@ -571,28 +613,3 @@ impl DecimalLiteralRepresentation {\n         Ok(())\n     }\n }\n-\n-#[must_use]\n-fn is_mistyped_suffix(suffix: &str) -> bool {\n-    [\"_8\", \"_16\", \"_32\", \"_64\"].contains(&suffix)\n-}\n-\n-#[must_use]\n-fn is_possible_suffix_index(lit: &str, idx: usize, len: usize) -> bool {\n-    ((len > 3 && idx == len - 3) || (len > 2 && idx == len - 2)) && is_mistyped_suffix(lit.split_at(idx).1)\n-}\n-\n-#[must_use]\n-fn is_mistyped_float_suffix(suffix: &str) -> bool {\n-    [\"_32\", \"_64\"].contains(&suffix)\n-}\n-\n-#[must_use]\n-fn is_possible_float_suffix_index(lit: &str, idx: usize, len: usize) -> bool {\n-    (len > 3 && idx == len - 3) && is_mistyped_float_suffix(lit.split_at(idx).1)\n-}\n-\n-#[must_use]\n-fn has_possible_float_suffix(lit: &str) -> bool {\n-    lit.ends_with(\"_32\") || lit.ends_with(\"_64\")\n-}"}, {"sha": "228fda9eec0aa13f376e38956010324723d39d86", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -18,6 +18,8 @@ use syntax::token;\n use syntax::util::parser::AssocOp;\n use syntax_pos::{BytePos, Pos};\n \n+pub use crate::literal_representation::format_numeric_literal;\n+\n /// A helper type to build suggestion correctly handling parenthesis.\n pub enum Sugg<'a> {\n     /// An expression that never needs parenthesis such as `1337` or `[0; 42]`."}, {"sha": "f10673adfb2dfe5ca882088d06a6449d9b3f2028", "filename": "tests/ui/inconsistent_digit_grouping.fixed", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Finconsistent_digit_grouping.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Finconsistent_digit_grouping.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_digit_grouping.fixed?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -2,6 +2,17 @@\n #[warn(clippy::inconsistent_digit_grouping)]\n #[allow(unused_variables, clippy::excessive_precision)]\n fn main() {\n+    macro_rules! mac1 {\n+        () => {\n+            1_23_456\n+        };\n+    }\n+    macro_rules! mac2 {\n+        () => {\n+            1_234.5678_f32\n+        };\n+    }\n+\n     let good = (\n         123,\n         1_234,\n@@ -12,4 +23,17 @@ fn main() {\n         1.123_456_7_f32,\n     );\n     let bad = (123_456, 12_345_678, 1_234_567, 1_234.567_8_f32, 1.234_567_8_f32);\n+\n+    // Test padding\n+    let _ = 0x0010_0000;\n+    let _ = 0x0100_0000;\n+    let _ = 0x1000_0000;\n+    let _ = 0x0001_0000_0000_u64;\n+\n+    // Test suggestion when fraction has no digits\n+    let _: f32 = 123_456.;\n+\n+    // Ignore literals in macros\n+    let _ = mac1!();\n+    let _ = mac2!();\n }"}, {"sha": "b97df0865ee81b7acfc8c2c99aaa32755c210e3e", "filename": "tests/ui/inconsistent_digit_grouping.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Finconsistent_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Finconsistent_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_digit_grouping.rs?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -2,6 +2,17 @@\n #[warn(clippy::inconsistent_digit_grouping)]\n #[allow(unused_variables, clippy::excessive_precision)]\n fn main() {\n+    macro_rules! mac1 {\n+        () => {\n+            1_23_456\n+        };\n+    }\n+    macro_rules! mac2 {\n+        () => {\n+            1_234.5678_f32\n+        };\n+    }\n+\n     let good = (\n         123,\n         1_234,\n@@ -12,4 +23,17 @@ fn main() {\n         1.123_456_7_f32,\n     );\n     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n+\n+    // Test padding\n+    let _ = 0x100000;\n+    let _ = 0x1000000;\n+    let _ = 0x10000000;\n+    let _ = 0x100000000_u64;\n+\n+    // Test suggestion when fraction has no digits\n+    let _: f32 = 1_23_456.;\n+\n+    // Ignore literals in macros\n+    let _ = mac1!();\n+    let _ = mac2!();\n }"}, {"sha": "37211efcab5f57dc486d74cf6d182a90b510b883", "filename": "tests/ui/inconsistent_digit_grouping.stderr", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Finconsistent_digit_grouping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Finconsistent_digit_grouping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finconsistent_digit_grouping.stderr?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -1,34 +1,66 @@\n error: digits grouped inconsistently by underscores\n-  --> $DIR/inconsistent_digit_grouping.rs:14:16\n+  --> $DIR/inconsistent_digit_grouping.rs:25:16\n    |\n LL |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n    |                ^^^^^^^^ help: consider: `123_456`\n    |\n    = note: `-D clippy::inconsistent-digit-grouping` implied by `-D warnings`\n \n error: digits grouped inconsistently by underscores\n-  --> $DIR/inconsistent_digit_grouping.rs:14:26\n+  --> $DIR/inconsistent_digit_grouping.rs:25:26\n    |\n LL |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n    |                          ^^^^^^^^^^ help: consider: `12_345_678`\n \n error: digits grouped inconsistently by underscores\n-  --> $DIR/inconsistent_digit_grouping.rs:14:38\n+  --> $DIR/inconsistent_digit_grouping.rs:25:38\n    |\n LL |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n    |                                      ^^^^^^^^ help: consider: `1_234_567`\n \n error: digits grouped inconsistently by underscores\n-  --> $DIR/inconsistent_digit_grouping.rs:14:48\n+  --> $DIR/inconsistent_digit_grouping.rs:25:48\n    |\n LL |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n    |                                                ^^^^^^^^^^^^^^ help: consider: `1_234.567_8_f32`\n \n error: digits grouped inconsistently by underscores\n-  --> $DIR/inconsistent_digit_grouping.rs:14:64\n+  --> $DIR/inconsistent_digit_grouping.rs:25:64\n    |\n LL |     let bad = (1_23_456, 1_234_5678, 1234_567, 1_234.5678_f32, 1.234_5678_f32);\n    |                                                                ^^^^^^^^^^^^^^ help: consider: `1.234_567_8_f32`\n \n-error: aborting due to 5 previous errors\n+error: long literal lacking separators\n+  --> $DIR/inconsistent_digit_grouping.rs:28:13\n+   |\n+LL |     let _ = 0x100000;\n+   |             ^^^^^^^^ help: consider: `0x0010_0000`\n+   |\n+   = note: `-D clippy::unreadable-literal` implied by `-D warnings`\n+\n+error: long literal lacking separators\n+  --> $DIR/inconsistent_digit_grouping.rs:29:13\n+   |\n+LL |     let _ = 0x1000000;\n+   |             ^^^^^^^^^ help: consider: `0x0100_0000`\n+\n+error: long literal lacking separators\n+  --> $DIR/inconsistent_digit_grouping.rs:30:13\n+   |\n+LL |     let _ = 0x10000000;\n+   |             ^^^^^^^^^^ help: consider: `0x1000_0000`\n+\n+error: long literal lacking separators\n+  --> $DIR/inconsistent_digit_grouping.rs:31:13\n+   |\n+LL |     let _ = 0x100000000_u64;\n+   |             ^^^^^^^^^^^^^^^ help: consider: `0x0001_0000_0000_u64`\n+\n+error: digits grouped inconsistently by underscores\n+  --> $DIR/inconsistent_digit_grouping.rs:34:18\n+   |\n+LL |     let _: f32 = 1_23_456.;\n+   |                  ^^^^^^^^^ help: consider: `123_456.`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "02daa22bb36e321b1c35dbb528a13e1f95cfcb35", "filename": "tests/ui/large_digit_groups.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Flarge_digit_groups.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Flarge_digit_groups.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_digit_groups.fixed?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -2,6 +2,12 @@\n #[warn(clippy::large_digit_groups)]\n #[allow(unused_variables)]\n fn main() {\n+    macro_rules! mac {\n+        () => {\n+            0b1_10110_i64\n+        };\n+    }\n+\n     let good = (\n         0b1011_i64,\n         0o1_234_u32,\n@@ -20,4 +26,7 @@ fn main() {\n         123_456.123_45_f64,\n         123_456.123_456_f64,\n     );\n+\n+    // Ignore literals in macros\n+    let _ = mac!();\n }"}, {"sha": "c1bb78c9d832fb7dc93eed7681ae77b9b8f97a09", "filename": "tests/ui/large_digit_groups.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Flarge_digit_groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Flarge_digit_groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_digit_groups.rs?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -2,6 +2,12 @@\n #[warn(clippy::large_digit_groups)]\n #[allow(unused_variables)]\n fn main() {\n+    macro_rules! mac {\n+        () => {\n+            0b1_10110_i64\n+        };\n+    }\n+\n     let good = (\n         0b1011_i64,\n         0o1_234_u32,\n@@ -20,4 +26,7 @@ fn main() {\n         1_23456.12345_f64,\n         1_23456.12345_6_f64,\n     );\n+\n+    // Ignore literals in macros\n+    let _ = mac!();\n }"}, {"sha": "ba8ea6b53e7f16fbf8aa9ed28a980ee318c98d53", "filename": "tests/ui/large_digit_groups.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Flarge_digit_groups.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Flarge_digit_groups.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_digit_groups.stderr?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -1,37 +1,37 @@\n error: digit groups should be smaller\n-  --> $DIR/large_digit_groups.rs:16:9\n+  --> $DIR/large_digit_groups.rs:22:9\n    |\n LL |         0b1_10110_i64,\n    |         ^^^^^^^^^^^^^ help: consider: `0b11_0110_i64`\n    |\n    = note: `-D clippy::large-digit-groups` implied by `-D warnings`\n \n error: digit groups should be smaller\n-  --> $DIR/large_digit_groups.rs:17:9\n+  --> $DIR/large_digit_groups.rs:23:9\n    |\n LL |         0x1_23456_78901_usize,\n    |         ^^^^^^^^^^^^^^^^^^^^^ help: consider: `0x0123_4567_8901_usize`\n \n error: digit groups should be smaller\n-  --> $DIR/large_digit_groups.rs:18:9\n+  --> $DIR/large_digit_groups.rs:24:9\n    |\n LL |         1_23456_f32,\n    |         ^^^^^^^^^^^ help: consider: `123_456_f32`\n \n error: digit groups should be smaller\n-  --> $DIR/large_digit_groups.rs:19:9\n+  --> $DIR/large_digit_groups.rs:25:9\n    |\n LL |         1_23456.12_f32,\n    |         ^^^^^^^^^^^^^^ help: consider: `123_456.12_f32`\n \n error: digit groups should be smaller\n-  --> $DIR/large_digit_groups.rs:20:9\n+  --> $DIR/large_digit_groups.rs:26:9\n    |\n LL |         1_23456.12345_f64,\n    |         ^^^^^^^^^^^^^^^^^ help: consider: `123_456.123_45_f64`\n \n error: digit groups should be smaller\n-  --> $DIR/large_digit_groups.rs:21:9\n+  --> $DIR/large_digit_groups.rs:27:9\n    |\n LL |         1_23456.12345_6_f64,\n    |         ^^^^^^^^^^^^^^^^^^^ help: consider: `123_456.123_456_f64`"}, {"sha": "baee77357303814e749dbc3c9909368b4e531125", "filename": "tests/ui/mistyped_literal_suffix.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Fmistyped_literal_suffix.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Fmistyped_literal_suffix.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.fixed?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -19,4 +19,6 @@ fn main() {\n     #[allow(overflowing_literals)]\n     let fail28 = 241_251_235E723_f64;\n     let fail29 = 42_279.911_f32;\n+\n+    let _ = 1.123_45E1_f32;\n }"}, {"sha": "6de447f40214b527083054f64874989a93c984f5", "filename": "tests/ui/mistyped_literal_suffix.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Fmistyped_literal_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Fmistyped_literal_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.rs?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -19,4 +19,6 @@ fn main() {\n     #[allow(overflowing_literals)]\n     let fail28 = 241251235E723_64;\n     let fail29 = 42279.911_32;\n+\n+    let _ = 1.12345E1_32;\n }"}, {"sha": "48a7ae904948c279c8c121e04526ce991e48888d", "filename": "tests/ui/mistyped_literal_suffix.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Fmistyped_literal_suffix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/623d8c4640b03d38edb57acbfa8242a144942bac/tests%2Fui%2Fmistyped_literal_suffix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.stderr?ref=623d8c4640b03d38edb57acbfa8242a144942bac", "patch": "@@ -72,5 +72,11 @@ error: mistyped literal suffix\n LL |     let fail29 = 42279.911_32;\n    |                  ^^^^^^^^^^^^ help: did you mean to write: `42_279.911_f32`\n \n-error: aborting due to 12 previous errors\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:23:13\n+   |\n+LL |     let _ = 1.12345E1_32;\n+   |             ^^^^^^^^^^^^ help: did you mean to write: `1.123_45E1_f32`\n+\n+error: aborting due to 13 previous errors\n "}]}