{"sha": "b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MWEyOGIyYTFkYjI5N2VkM2JkMTVhM2M1YWM1YzhjNDBmZWI1ODY=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-03-16T15:43:03Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-05-05T09:25:12Z"}, "message": "Rebase and use ena 0.14", "tree": {"sha": "91c95d32e7a59c1ffaa34d3c4280043313108dde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91c95d32e7a59c1ffaa34d3c4280043313108dde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "html_url": "https://github.com/rust-lang/rust/commit/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/comments", "author": null, "committer": null, "parents": [{"sha": "fba241fc6690527a3aad4bee98aca00a7c0907ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba241fc6690527a3aad4bee98aca00a7c0907ad", "html_url": "https://github.com/rust-lang/rust/commit/fba241fc6690527a3aad4bee98aca00a7c0907ad"}], "stats": {"total": 125, "additions": 70, "deletions": 55}, "files": [{"sha": "0e0ab8550c6e5b3eaa641c1a91b3c5383c6b7974", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -223,7 +223,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         &self.region_obligations\n     }\n \n-    pub(crate) fn projection_cache(&mut self) -> traits::ProjectionCache<'tcx, '_> {\n+    pub fn projection_cache(&mut self) -> traits::ProjectionCache<'tcx, '_> {\n         self.projection_cache.with_log(&mut self.undo_log)\n     }\n \n@@ -1308,19 +1308,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         mode: RegionckMode,\n     ) {\n-        assert!(\n-            self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.inner.borrow().region_obligations\n-        );\n-        let (var_infos, data) = self\n-            .inner\n-            .borrow_mut()\n-            .region_constraints\n-            .take()\n-            .expect(\"regions already resolved\")\n-            .with_log(&mut inner.undo_log)\n-            .into_infos_and_data();\n+        let (var_infos, data) = {\n+            let mut inner = self.inner.borrow_mut();\n+            let inner = &mut *inner;\n+            assert!(\n+                self.is_tainted_by_errors() || inner.region_obligations.is_empty(),\n+                \"region_obligations not empty: {:#?}\",\n+                inner.region_obligations\n+            );\n+            inner\n+                .region_constraints\n+                .take()\n+                .expect(\"regions already resolved\")\n+                .with_log(&mut inner.undo_log)\n+                .into_infos_and_data()\n+        };\n \n         let region_rels = &RegionRelations::new(\n             self.tcx,\n@@ -1686,13 +1688,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// having to resort to storing full `GenericArg`s in `stalled_on`.\n     #[inline(always)]\n     pub fn ty_or_const_infer_var_changed(&self, infer_var: TyOrConstInferVar<'tcx>) -> bool {\n+        let mut inner = self.inner.borrow_mut();\n         match infer_var {\n             TyOrConstInferVar::Ty(v) => {\n                 use self::type_variable::TypeVariableValue;\n \n                 // If `inlined_probe` returns a `Known` value, it never equals\n                 // `ty::Infer(ty::TyVar(v))`.\n-                match self.inner.borrow_mut().type_variables().inlined_probe(v) {\n+                match inner.type_variables().inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n@@ -1702,23 +1705,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which never matches a\n                 // `ty::Infer(_)`.\n-                self.inner.borrow_mut().int_unification_table().inlined_probe_value(v).is_some()\n+                inner.int_unification_table().inlined_probe_value(v).is_some()\n             }\n \n             TyOrConstInferVar::TyFloat(v) => {\n                 // If `probe_value` returns a value it's always a\n                 // `ty::Float(_)`, which never matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.inner.borrow_mut().float_unification_table().probe_value(v).is_some()\n+                inner.float_unification_table().probe_value(v).is_some()\n             }\n \n             TyOrConstInferVar::Const(v) => {\n                 // If `probe_value` returns a `Known` value, it never equals\n                 // `ty::ConstKind::Infer(ty::InferConst::Var(v))`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                match self.inner.borrow_mut().const_unification_table.probe_value(v).val {\n+                match inner.const_unification_table().probe_value(v).val {\n                     ConstVariableValue::Unknown { .. } => false,\n                     ConstVariableValue::Known { .. } => true,\n                 }"}, {"sha": "0d94e32754ac8e672ba8f60b9309564189e0de29", "filename": "src/librustc_infer/infer/undo_log.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -1,10 +1,10 @@\n use std::marker::PhantomData;\n \n-use rustc::ty;\n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::undo_log::{Rollback, Snapshots, UndoLogs};\n use rustc_data_structures::unify as ut;\n use rustc_hir as hir;\n+use rustc_middle::ty;\n \n use crate::{\n     infer::{"}, {"sha": "a8585fd293518dacbd25b8cf06cef873f91e753e", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -23,7 +23,7 @@ pub use self::project::MismatchedProjectionTypes;\n pub(crate) use self::project::UndoLog;\n pub use self::project::{\n     Normalized, NormalizedTy, ProjectionCache, ProjectionCacheEntry, ProjectionCacheKey,\n-    ProjectionCacheSnapshot, Reveal,\n+    ProjectionCacheStorage, Reveal,\n };\n crate use self::util::elaborate_predicates;\n "}, {"sha": "17bc54eed40dfcc01517eb4a1d9fb84f72740346", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -2,8 +2,12 @@\n \n use super::PredicateObligation;\n \n-use rustc_data_structures::snapshot_map::{self, SnapshotMapRef, SnapshotMapStorage};\n-use rustc_middle::ty::fold::TypeFoldable;\n+use crate::infer::InferCtxtUndoLogs;\n+\n+use rustc_data_structures::{\n+    snapshot_map::{self, SnapshotMapRef, SnapshotMapStorage},\n+    undo_log::Rollback,\n+};\n use rustc_middle::ty::{self, Ty};\n \n pub use rustc_middle::traits::Reveal;"}, {"sha": "1c71fc57bea5a23effe7bd60521ebb80572456c0", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -311,16 +311,19 @@ impl<'hir> Map<'hir> {\n     }\n \n     fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n-        if id.local_id == ItemLocalId::from_u32_const(0) {\n-            let owner = self.tcx.hir_owner(id.owner_def_id());\n+        if id.local_id == ItemLocalId::from_u32(0) {\n+            let owner = self.tcx.hir_owner(id.owner);\n             owner.map(|owner| Entry { parent: owner.parent, node: owner.node })\n         } else {\n-            let owner = self.tcx.hir_owner_items(id.owner_def_id());\n+            let owner = self.tcx.hir_owner_nodes(id.owner);\n             owner.and_then(|owner| {\n-                let item = owner.items[id.local_id].as_ref();\n-                item.map(|item| Entry {\n-                    parent: HirId { owner: id.owner, local_id: item.parent },\n-                    node: item.node,\n+                let node = owner.nodes[id.local_id].as_ref();\n+                // FIXME(eddyb) use a single generic type insted of having both\n+                // `Entry` and `ParentedNode`, which are effectively the same.\n+                // Alternatively, rewrite code using `Entry` to use `ParentedNode`.\n+                node.map(|node| Entry {\n+                    parent: HirId { owner: id.owner, local_id: node.parent },\n+                    node: node.node,\n                 })\n             })\n         }\n@@ -352,12 +355,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n-        self.tcx\n-            .hir_owner_items(DefId::local(id.hir_id.owner))\n-            .unwrap()\n-            .bodies\n-            .get(&id.hir_id.local_id)\n-            .unwrap()\n+        self.tcx.hir_owner_nodes(id.hir_id.owner).unwrap().bodies.get(&id.hir_id.local_id).unwrap()\n     }\n \n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {"}, {"sha": "7ab66411b21093ab18d14deb91c7456407709e9c", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -77,8 +77,8 @@ pub fn provide(providers: &mut Providers<'_>) {\n         let module = hir.as_local_hir_id(id);\n         &tcx.untracked_crate.modules[&module]\n     };\n-    providers.hir_owner = |tcx, id| tcx.index_hir(id.krate).map[id.index].signature;\n-    providers.hir_owner_items =\n-        |tcx, id| tcx.index_hir(id.krate).map[id.index].with_bodies.as_ref().map(|items| &**items);\n+    providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n+    providers.hir_owner_nodes =\n+        |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_ref().map(|nodes| &**nodes);\n     map::provide(providers);\n }"}, {"sha": "b0c442381484c11f244206e628856ecd234bad7b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -75,7 +75,7 @@ rustc_queries! {\n         //\n         // This can be conveniently accessed by methods on `tcx.hir()`.\n         // Avoid calling this query directly.\n-        query hir_owner(key: DefId) -> Option<&'tcx HirOwner<'tcx>> {\n+        query hir_owner(key: LocalDefId) -> Option<&'tcx crate::hir::Owner<'tcx>> {\n             eval_always\n             desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n@@ -84,7 +84,7 @@ rustc_queries! {\n         //\n         // This can be conveniently accessed by methods on `tcx.hir()`.\n         // Avoid calling this query directly.\n-        query hir_owner_items(key: DefId) -> Option<&'tcx HirOwnerItems<'tcx>> {\n+        query hir_owner_nodes(key: LocalDefId) -> Option<&'tcx crate::hir::OwnerNodes<'tcx>> {\n             eval_always\n             desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }"}, {"sha": "1e056c96acd383fd264f454927c9921064977253", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -240,9 +240,15 @@ struct FulfillProcessor<'a, 'b, 'tcx> {\n     register_region_obligations: bool,\n }\n \n-fn mk_pending(os: Vec<PredicateObligation<'tcx>>) -> Vec<PendingPredicateObligation<'tcx>> {\n+fn mk_pending(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    os: Vec<PredicateObligation<'tcx>>,\n+) -> Vec<PendingPredicateObligation<'tcx>> {\n     os.into_iter()\n-        .map(|o| PendingPredicateObligation { obligation: o, stalled_on: vec![] })\n+        .map(|mut o| {\n+            o.predicate = infcx.resolve_vars_if_possible(&o.predicate);\n+            PendingPredicateObligation { obligation: o, stalled_on: vec![] }\n+        })\n         .collect()\n }\n \n@@ -312,14 +318,16 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n+        let infcx = self.selcx.infcx();\n+\n         match obligation.predicate {\n             ty::Predicate::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(*data);\n \n                 if data.is_global() {\n                     // no type variables present, can use evaluation for better caching.\n                     // FIXME: consider caching errors too.\n-                    if self.selcx.infcx().predicate_must_hold_considering_regions(&obligation) {\n+                    if infcx.predicate_must_hold_considering_regions(&obligation) {\n                         debug!(\n                             \"selecting trait `{:?}` at depth {} evaluated to holds\",\n                             data, obligation.recursion_depth\n@@ -334,7 +342,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                             \"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n                             data, obligation.recursion_depth\n                         );\n-                        ProcessResult::Changed(mk_pending(vtable.nested_obligations()))\n+                        ProcessResult::Changed(mk_pending(infcx, vtable.nested_obligations()))\n                     }\n                     Ok(None) => {\n                         debug!(\n@@ -351,7 +359,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n                         debug!(\n                             \"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                            self.selcx.infcx().resolve_vars_if_possible(obligation),\n+                            infcx.resolve_vars_if_possible(obligation),\n                             pending_obligation.stalled_on\n                         );\n \n@@ -369,7 +377,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::RegionOutlives(ref binder) => {\n-                match self.selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n+                match infcx.region_outlives_predicate(&obligation.cause, binder) {\n                     Ok(()) => ProcessResult::Changed(vec![]),\n                     Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                 }\n@@ -428,7 +436,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                             trait_ref_type_vars(self.selcx, data.to_poly_trait_ref(tcx));\n                         ProcessResult::Unchanged\n                     }\n-                    Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n+                    Ok(Some(os)) => ProcessResult::Changed(mk_pending(infcx, os)),\n                     Err(e) => ProcessResult::Error(CodeProjectionError(e)),\n                 }\n             }\n@@ -467,7 +475,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                             vec![TyOrConstInferVar::maybe_from_ty(ty).unwrap()];\n                         ProcessResult::Unchanged\n                     }\n-                    Some(os) => ProcessResult::Changed(mk_pending(os)),\n+                    Some(os) => ProcessResult::Changed(mk_pending(infcx, os)),\n                 }\n             }\n \n@@ -485,7 +493,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                         ];\n                         ProcessResult::Unchanged\n                     }\n-                    Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n+                    Some(Ok(ok)) => ProcessResult::Changed(mk_pending(infcx, ok.obligations)),\n                     Some(Err(err)) => {\n                         let expected_found = ExpectedFound::new(\n                             subtype.skip_binder().a_is_expected,"}, {"sha": "7536b444351f2a3faf327b6e265730240b53c4c5", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -471,7 +471,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    let cache_result = infcx.inner.borrow_mut().projection_cache.try_start(cache_key);\n+    let cache_result = infcx.inner.borrow_mut().projection_cache().try_start(cache_key);\n     match cache_result {\n         Ok(()) => {}\n         Err(ProjectionCacheEntry::Ambiguous) => {\n@@ -537,7 +537,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n             if infcx.unresolved_type_vars(&ty.value).is_none() {\n-                infcx.inner.borrow_mut().projection_cache.complete_normalized(cache_key, &ty);\n+                infcx.inner.borrow_mut().projection_cache().complete_normalized(cache_key, &ty);\n             // No need to extend `obligations`.\n             } else {\n                 obligations.extend(ty.obligations);\n@@ -604,7 +604,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             };\n \n             let cache_value = prune_cache_value_obligations(infcx, &result);\n-            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, cache_value);\n+            infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, cache_value);\n             obligations.extend(result.obligations);\n             Some(result.value)\n         }\n@@ -615,7 +615,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 projected_ty\n             );\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n-            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, result.clone());\n+            infcx.inner.borrow_mut().projection_cache().insert_ty(cache_key, result.clone());\n             // No need to extend `obligations`.\n             Some(result.value)\n         }\n@@ -624,7 +624,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 \"opt_normalize_projection_type: \\\n                  too many candidates\"\n             );\n-            infcx.inner.borrow_mut().projection_cache.ambiguous(cache_key);\n+            infcx.inner.borrow_mut().projection_cache().ambiguous(cache_key);\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n@@ -634,7 +634,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Trait`, which when processed will cause the error to be\n             // reported later\n \n-            infcx.inner.borrow_mut().projection_cache.error(cache_key);\n+            infcx.inner.borrow_mut().projection_cache().error(cache_key);\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n             Some(result.value)"}, {"sha": "22e42295eedf302a992441e24eb303f17c838c92", "filename": "src/test/ui/issues/issue-70041.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Ftest%2Fui%2Fissues%2Fissue-70041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586/src%2Ftest%2Fui%2Fissues%2Fissue-70041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70041.rs?ref=b61a28b2a1db297ed3bd15a3c5ac5c8c40feb586", "patch": "@@ -2,10 +2,12 @@\n // run-pass\n \n macro_rules! regex {\n+    //~^ WARN unused macro definition\n     () => {};\n }\n \n #[allow(dead_code)]\n use regex;\n+//~^ WARN unused import\n \n fn main() {}"}]}