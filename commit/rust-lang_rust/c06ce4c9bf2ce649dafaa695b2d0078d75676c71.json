{"sha": "c06ce4c9bf2ce649dafaa695b2d0078d75676c71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNmNlNGM5YmYyY2U2NDlkYWZhYTY5NWIyZDAwNzhkNzU2NzZjNzE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-11-21T10:52:33Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-11-21T23:00:31Z"}, "message": "tutorial: alternatives to ownership\n\nThis replaces the old section on managed pointers because the syntax is\ngoing to be removed and it's currently feature gated so the examples\ndon't work out-of-the-box. Dynamic mutability coverage can be added\nafter the `Mut<T>` work has landed.", "tree": {"sha": "d441ccf975526ec583e3dd4f0e2cbdf91b89d4d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d441ccf975526ec583e3dd4f0e2cbdf91b89d4d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c06ce4c9bf2ce649dafaa695b2d0078d75676c71", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c06ce4c9bf2ce649dafaa695b2d0078d75676c71", "html_url": "https://github.com/rust-lang/rust/commit/c06ce4c9bf2ce649dafaa695b2d0078d75676c71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c06ce4c9bf2ce649dafaa695b2d0078d75676c71/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c159acb05d95d832de3cebb5e1e91ee34e550c9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c159acb05d95d832de3cebb5e1e91ee34e550c9d", "html_url": "https://github.com/rust-lang/rust/commit/c159acb05d95d832de3cebb5e1e91ee34e550c9d"}], "stats": {"total": 95, "additions": 47, "deletions": 48}, "files": [{"sha": "2a493bb468fd70f5b61098f56581ccd53617d638", "filename": "doc/tutorial.md", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c06ce4c9bf2ce649dafaa695b2d0078d75676c71/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/c06ce4c9bf2ce649dafaa695b2d0078d75676c71/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=c06ce4c9bf2ce649dafaa695b2d0078d75676c71", "patch": "@@ -890,9 +890,7 @@ calling the destructor, and the owner determines whether the object is mutable.\n \n Ownership is recursive, so mutability is inherited recursively and a destructor\n destroys the contained tree of owned objects. Variables are top-level owners\n-and destroy the contained object when they go out of scope. A box managed by\n-the garbage collector starts a new ownership tree, and the destructor is called\n-when it is collected.\n+and destroy the contained object when they go out of scope.\n \n ~~~~\n // the struct owns the objects contained in the `x` and `y` fields\n@@ -1009,51 +1007,6 @@ let mut s = r; // box becomes mutable\n let t = s; // box becomes immutable\n ~~~~\n \n-# Managed boxes\n-\n-A managed box (`@`) is a heap allocation with the lifetime managed by a\n-task-local garbage collector. It will be destroyed at some point after there\n-are no references left to the box, no later than the end of the task. Managed\n-boxes lack an owner, so they start a new ownership tree and don't inherit\n-mutability. They do own the contained object, and mutability is defined by the\n-type of the managed box (`@` or `@mut`). An object containing a managed box is\n-not `Owned`, and can't be sent between tasks.\n-\n-~~~~\n-let a = @5; // immutable\n-\n-let mut b = @5; // mutable variable, immutable box\n-b = @10;\n-\n-let c = @mut 5; // immutable variable, mutable box\n-*c = 10;\n-\n-let mut d = @mut 5; // mutable variable, mutable box\n-*d += 5;\n-d = @mut 15;\n-~~~~\n-\n-A mutable variable and an immutable variable can refer to the same box, given\n-that their types are compatible. Mutability of a box is a property of its type,\n-however, so for example a mutable handle to an immutable box cannot be\n-assigned a reference to a mutable box.\n-\n-~~~~\n-let a = @1;     // immutable box\n-let b = @mut 2; // mutable box\n-\n-let mut c : @int;       // declare a variable with type managed immutable int\n-let mut d : @mut int;   // and one of type managed mutable int\n-\n-c = a;          // box type is the same, okay\n-d = b;          // box type is the same, okay\n-~~~~\n-\n-~~~~ {.xfail-test}\n-// but b cannot be assigned to c, or a to d\n-c = b;          // error\n-~~~~\n-\n # Borrowed pointers\n \n Rust's borrowed pointers are a general purpose reference type. In contrast with\n@@ -1347,6 +1300,52 @@ defined in [`std::vec`] and [`std::str`].\n [`std::vec`]: std/vec/index.html\n [`std::str`]: std/str/index.html\n \n+# Ownership escape hatches\n+\n+Ownership can cleanly describe tree-like data structures, and borrowed pointers provide non-owning\n+references. However, more flexibility is often desired and Rust provides ways to escape from strict\n+single parent ownership.\n+\n+The standard library provides the `std::rc::Rc` pointer type to express *shared ownership* over a\n+reference counted box. As soon as all of the `Rc` pointers go out of scope, the box and the\n+contained value are destroyed.\n+\n+~~~\n+use std::rc::Rc;\n+\n+// A fixed-size array allocated in a reference-counted box\n+let x = Rc::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+let y = x.clone(); // a new owner\n+let z = x; // this moves `x` into `z`, rather than creating a new owner\n+\n+assert_eq!(*z.borrow(), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+\n+let mut a = Rc::new([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]); // the variable is mutable, but not the box\n+a = z;\n+~~~\n+\n+A garbage collected pointer is provided via `std::gc::Gc`, with a task-local garbage collector\n+having ownership of the box. It allows the creation of cycles, and the individual `Gc` pointers do\n+not have a destructor.\n+\n+~~~\n+use std::gc::Gc;\n+\n+// A fixed-size array allocated in a garbage-collected box\n+let x = Gc::new([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+let y = x; // does not perform a move, unlike with `Rc`\n+let z = x;\n+\n+assert_eq!(*z.borrow(), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+~~~\n+\n+With shared ownership, mutability cannot be inherited so the boxes are always immutable. However,\n+it's possible to use *dynamic* mutability via types like `std::cell::Cell` where freezing is handled\n+via dynamic checks and can fail at runtime.\n+\n+The `Rc` and `Gc` types are not sendable, so they cannot be used to share memory between tasks. Safe\n+immutable and mutable shared memory is provided by the `extra::arc` module.\n+\n # Closures\n \n Named functions, like those we've seen so far, may not refer to local"}]}