{"sha": "97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3Yzk5MzBhM2Y4OTkxZGEyZThiNWVkYjhkMTc0OGNhN2UyZjIwZDE=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-28T01:18:52Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-28T01:22:55Z"}, "message": "Fix `doc_markdown` and multiline quotes and links", "tree": {"sha": "072fdf247d66f675fec988c65a5e87b2d6dfebd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/072fdf247d66f675fec988c65a5e87b2d6dfebd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXSPLyAAoJEF5CfHlMukXonR4QAIlaqhMQdIU636fZ36BoJf2w\n4wDqQiS+Tq8bl9RBFRnwiedUpMlWOR88k6KUEGjg7YRj+0QP+pp8/ivYI7uJbXqT\nAKeC0R73uqEnlLtzZjE4plywKaRfsvOJaVJ2TSVNF6GS30U11wAbfmoh/CXsCvly\nyi8SYPJBMV7Vzj41n5A1VeSLCF8YNuhAC0sE+EOfwipxHGuIrZfOSt9zyGwUOlAc\n5r+6crquuVsqilMt58lhTDXixj4GqXNoG46Udmducfy2mxhFuS5VBK78BvV4lxd5\nLSw28KAeB1E1cC9sqAcrxvi3EUFt6eO9zrsfhK6/GF129jS7yUxIT6F4jgfLAjXa\nkVBVib7TWcObRZUKEHzu6otCMm1uiFtZWy0AtVV3AYI3NvE1lgcQwl7GSyCsrJT3\nphho1kT3LzaxKoiMYaECXVt2zd833Z09DFrdinvFGdzhVF4K/NnFDmTFpzPuhcSu\n6GtJwEnO4IXo+hp3q3BEdZ3BLkKQCuHnK7Vi3bY8rev3ZC6ELzGM9NkoeI9DlrFh\nXjtijx0ZEJzypWrkbz9bZV0cd9x9Vt8Pyn2prCS2SdeU+Ow1xsK/pWdtNx7pvbYc\nzDTgu68rXa9f/a1vIFoVTFIcdYXcOfulABneegvwJvrhakPEt8jpptSnoY3tyj9+\nkNfscTEa4UE8UygmoSOY\n=aUED\n-----END PGP SIGNATURE-----", "payload": "tree 072fdf247d66f675fec988c65a5e87b2d6dfebd6\nparent ac0bb4126c835ea89313cbb4f534c37bc14a2694\nauthor mcarton <cartonmartin+git@gmail.com> 1464398332 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1464398575 +0200\n\nFix `doc_markdown` and multiline quotes and links\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1", "html_url": "https://github.com/rust-lang/rust/commit/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac0bb4126c835ea89313cbb4f534c37bc14a2694", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac0bb4126c835ea89313cbb4f534c37bc14a2694", "html_url": "https://github.com/rust-lang/rust/commit/ac0bb4126c835ea89313cbb4f534c37bc14a2694"}], "stats": {"total": 133, "additions": 87, "deletions": 46}, "files": [{"sha": "af1fbaa0f7da1c727380b38d86a04acff9ba7283", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 73, "deletions": 34, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1", "patch": "@@ -66,22 +66,21 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n                     // check for multiline code blocks\n                     if real_doc.trim_left().starts_with(\"```\") {\n                         in_multiline = !in_multiline;\n-                    }\n-                    if !in_multiline {\n+                    } else if !in_multiline {\n                         docs.push((real_doc, span));\n                     }\n                 }\n             }\n         }\n     }\n \n-    for (doc, span) in docs {\n-        let _ = check_doc(cx, valid_idents, doc, span);\n+    if !docs.is_empty() {\n+        let _ = check_doc(cx, valid_idents, &docs);\n     }\n }\n \n #[allow(while_let_loop)] // #362\n-pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Span) -> Result<(), ()> {\n+pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)]) -> Result<(), ()> {\n     // In markdown, `_` can be used to emphasize something, or, is a raw `_` depending on context.\n     // There really is no markdown specification that would disambiguate this properly. This is\n     // what GitHub and Rustdoc do:\n@@ -103,12 +102,22 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n     }\n \n     #[derive(Clone, Debug)]\n+    /// This type is used to iterate through the documentation characters, keeping the span at the\n+    /// same time.\n     struct Parser<'a> {\n-        link: bool,\n-        line: &'a str,\n-        span: Span,\n+        /// First byte of the current potential match\n         current_word_begin: usize,\n+        /// List of lines and their associated span\n+        docs: &'a[(&'a str, Span)],\n+        /// Index of the current line we are parsing\n+        line: usize,\n+        /// Whether we are in a link\n+        link: bool,\n+        /// Whether we are at the beginning of a line\n         new_line: bool,\n+        /// Whether we were to the end of a line last time `next` was called\n+        reset: bool,\n+        /// The position of the current character within the current line\n         pos: usize,\n     }\n \n@@ -117,19 +126,31 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n             self.current_word_begin = self.pos;\n         }\n \n+        fn line(&self) -> (&'a str, Span) {\n+            self.docs[self.line]\n+        }\n+\n         fn peek(&self) -> Option<char> {\n-            self.line[self.pos..].chars().next()\n+            self.line().0[self.pos..].chars().next()\n         }\n \n+        #[allow(while_let_on_iterator)] // borrowck complains about for\n         fn jump_to(&mut self, n: char) -> Result<(), ()> {\n-            while let Some(c) = self.next() {\n+            while let Some((_, c)) = self.next() {\n                 if c == n {\n                     self.advance_begin();\n                     return Ok(());\n                 }\n             }\n \n-            return Err(());\n+            Err(())\n+        }\n+\n+        fn next_line(&mut self) {\n+            self.pos = 0;\n+            self.current_word_begin = 0;\n+            self.line += 1;\n+            self.new_line = true;\n         }\n \n         fn put_back(&mut self, c: char) {\n@@ -144,58 +165,77 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n             debug_assert_eq!(end as u32 as usize, end);\n             debug_assert_eq!(begin as u32 as usize, begin);\n \n-            let mut span = self.span;\n+            let (doc, mut span) = self.line();\n             span.hi = span.lo + BytePos(end as u32);\n             span.lo = span.lo + BytePos(begin as u32);\n \n-            (&self.line[begin..end], span)\n+            (&doc[begin..end], span)\n         }\n     }\n \n     impl<'a> Iterator for Parser<'a> {\n-        type Item = char;\n-\n-        fn next(&mut self) -> Option<char> {\n-            let mut chars = self.line[self.pos..].chars();\n-            let c = chars.next();\n+        type Item = (bool, char);\n+\n+        fn next(&mut self) -> Option<(bool, char)> {\n+            while self.line < self.docs.len() {\n+                if self.reset {\n+                    self.line += 1;\n+                    self.reset = false;\n+                    self.pos = 0;\n+                    self.current_word_begin = 0;\n+                }\n \n-            if let Some(c) = c {\n-                self.pos += c.len_utf8();\n-            } else {\n-                // TODO: new line\n+                let mut chars = self.line().0[self.pos..].chars();\n+                let c = chars.next();\n+\n+                if let Some(c) = c {\n+                    self.pos += c.len_utf8();\n+                    let new_line = self.new_line;\n+                    self.new_line = c == '\\n' || (self.new_line && c.is_whitespace());\n+                    return Some((new_line, c));\n+                } else if self.line == self.docs.len() - 1 {\n+                    return None;\n+                } else {\n+                    self.new_line = true;\n+                    self.reset = true;\n+                    self.pos += 1;\n+                    return Some((true, '\\n'));\n+                }\n             }\n \n-            c\n+            None\n         }\n     }\n \n     let mut parser = Parser {\n-        link: false,\n-        line: doc,\n-        span: span,\n         current_word_begin: 0,\n+        docs: docs,\n+        line: 0,\n+        link: false,\n         new_line: true,\n+        reset: false,\n         pos: 0,\n     };\n \n     loop {\n         match parser.next() {\n-            Some(c) => {\n+            Some((new_line, c)) => {\n                 match c {\n                     '#' if new_line => { // don\u2019t warn on titles\n-                        try!(parser.jump_to('\\n'));\n+                        parser.next_line();\n                     }\n                     '`' => {\n                         try!(parser.jump_to('`'));\n                     }\n                     '[' => {\n                         // Check for a reference definition `[foo]:` at the beginning of a line\n                         let mut link = true;\n-                        if parser.new_line {\n+\n+                        if new_line {\n                             let mut lookup_parser = parser.clone();\n-                            if let Some(_) = lookup_parser.find(|&c| c == ']') {\n-                                if let Some(':') = lookup_parser.next() {\n-                                    try!(lookup_parser.jump_to(')'));\n+                            if let Some(_) = lookup_parser.find(|&(_, c)| c == ']') {\n+                                if let Some((_, ':')) = lookup_parser.next() {\n+                                    lookup_parser.next_line();\n                                     parser = lookup_parser;\n                                     link = false;\n                                 }\n@@ -219,7 +259,7 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n                         parser.advance_begin();\n                     }\n                     _ => {\n-                        if let Some(c) = parser.find(|&c| !is_path_char(c)) {\n+                        if let Some((_, c)) = parser.find(|&(_, c)| !is_path_char(c)) {\n                             parser.put_back(c);\n                         }\n \n@@ -229,7 +269,6 @@ pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Sp\n                     }\n                 }\n \n-                parser.new_line = c == '\\n' || (parser.new_line && c.is_whitespace());\n             }\n             None => break,\n         }"}, {"sha": "d3b1c037f4702c185c0f190ba2694400ac236a91", "filename": "tests/compile-fail/doc.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1/tests%2Fcompile-fail%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1/tests%2Fcompile-fail%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdoc.rs?ref=97c9930a3f8991da2e8b5edb8d1748ca7e2f20d1", "patch": "@@ -68,18 +68,18 @@ fn test_units() {\n //~^ ERROR: you should put `foo_\u211d` between ticks\n /// foo_\ud83d\udca3\n /// foo_\u2764\ufe0f\n-/// [\u00dfdummy text\u00df][foo_\u00df]\n-/// [\u211ddummy text\u211d][foo_\u211d]\n-/// [\ud83d\udca3dummy tex\ud83d\udca3t][foo_\ud83d\udca3]\n-/// [\u2764\ufe0fdummy text\u2764\ufe0f][foo_\u2764\ufe0f]\n-/// [\u00dfdummy text\u00df](foo_\u00df)\n-/// [\u211ddummy text\u211d](foo_\u211d)\n-/// [\ud83d\udca3dummy tex\ud83d\udca3t](foo_\ud83d\udca3)\n-/// [\u2764\ufe0fdummy text\u2764\ufe0f](foo_\u2764\ufe0f)\n-/// [foo_\u00df]: dummy text\n-/// [foo_\u211d]: dummy text\n-/// [foo_\ud83d\udca3]: dummy text\n-/// [foo_\u2764\ufe0f]: dummy text\n+/// [\u00dfdummy text\u00df][foo_1\u00df]\n+/// [\u211ddummy text\u211d][foo_2\u211d]\n+/// [\ud83d\udca3dummy tex\ud83d\udca3t][foo3_\ud83d\udca3]\n+/// [\u2764\ufe0fdummy text\u2764\ufe0f][foo_4\u2764\ufe0f]\n+/// [\u00dfdummy text\u00df](foo_5\u00df)\n+/// [\u211ddummy text\u211d](foo_6\u211d)\n+/// [\ud83d\udca3dummy tex\ud83d\udca3t](fo7o_\ud83d\udca3)\n+/// [\u2764\ufe0fdummy text\u2764\ufe0f](foo_8\u2764\ufe0f)\n+/// [foo1_\u00df]: dummy text\n+/// [foo2_\u211d]: dummy text\n+/// [foo3_\ud83d\udca3]: dummy text\n+/// [foo4_\u2764\ufe0f]: dummy text\n /// be_sure_we_got_to_the_end_of_it\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn test_unicode() {\n@@ -146,5 +146,7 @@ fn issue883() {\n \n /// `foo_bar\n /// baz_quz`\n+/// [foo\n+/// bar](https://doc.rust-lang.org/stable/std/iter/trait.IteratorFooBar.html)\n fn multiline() {\n }"}]}