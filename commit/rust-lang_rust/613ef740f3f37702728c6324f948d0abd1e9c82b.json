{"sha": "613ef740f3f37702728c6324f948d0abd1e9c82b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxM2VmNzQwZjNmMzc3MDI3MjhjNjMyNGY5NDhkMGFiZDFlOWM4MmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-27T10:19:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-27T10:19:51Z"}, "message": "Auto merge of #80987 - GuillaumeGomez:remove-cache-key, r=jyn514\n\nRemove CACHE_KEY global\n\nWe realized in https://github.com/rust-lang/rust/pull/80914 that the cache handling (through a global) needed to be updated to make it much easier to handle.\n\nr? `@jyn514`", "tree": {"sha": "5a81d39cbe7a3aa37f887a972ca71d4ae22a3ea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a81d39cbe7a3aa37f887a972ca71d4ae22a3ea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/613ef740f3f37702728c6324f948d0abd1e9c82b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/613ef740f3f37702728c6324f948d0abd1e9c82b", "html_url": "https://github.com/rust-lang/rust/commit/613ef740f3f37702728c6324f948d0abd1e9c82b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/613ef740f3f37702728c6324f948d0abd1e9c82b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "742c972c4f92a8f213d05b82ba04797f251f125a", "url": "https://api.github.com/repos/rust-lang/rust/commits/742c972c4f92a8f213d05b82ba04797f251f125a", "html_url": "https://github.com/rust-lang/rust/commit/742c972c4f92a8f213d05b82ba04797f251f125a"}, {"sha": "d78e1ed623d0679f20bd12ae79f41629218ff916", "url": "https://api.github.com/repos/rust-lang/rust/commits/d78e1ed623d0679f20bd12ae79f41629218ff916", "html_url": "https://github.com/rust-lang/rust/commit/d78e1ed623d0679f20bd12ae79f41629218ff916"}], "stats": {"total": 1413, "additions": 791, "deletions": 622}, "files": [{"sha": "03454bb8b7ff08a110aace63c353d59ef1c7e1be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -2329,14 +2329,14 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n             if matchers.len() <= 1 {\n                 format!(\n                     \"{}macro {}{} {{\\n    ...\\n}}\",\n-                    vis.print_with_space(cx.tcx, def_id),\n+                    vis.print_with_space(cx.tcx, def_id, &cx.cache),\n                     name,\n                     matchers.iter().map(|span| span.to_src(cx)).collect::<String>(),\n                 )\n             } else {\n                 format!(\n                     \"{}macro {} {{\\n{}}}\",\n-                    vis.print_with_space(cx.tcx, def_id),\n+                    vis.print_with_space(cx.tcx, def_id, &cx.cache),\n                     name,\n                     matchers\n                         .iter()"}, {"sha": "86bce8b8707a01b77d2a32280e8706e05dfab601", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 63, "deletions": 25, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -37,7 +37,7 @@ use crate::clean::inline;\n use crate::clean::types::Type::{QPath, ResolvedPath};\n use crate::clean::Clean;\n use crate::core::DocContext;\n-use crate::formats::cache::cache;\n+use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n \n@@ -169,8 +169,8 @@ impl Item {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    crate fn links(&self) -> Vec<RenderedLink> {\n-        self.attrs.links(&self.def_id.krate)\n+    crate fn links(&self, cache: &Cache) -> Vec<RenderedLink> {\n+        self.attrs.links(&self.def_id.krate, cache)\n     }\n \n     crate fn is_crate(&self) -> bool {\n@@ -826,7 +826,7 @@ impl Attributes {\n     /// Gets links as a vector\n     ///\n     /// Cache must be populated before call\n-    crate fn links(&self, krate: &CrateNum) -> Vec<RenderedLink> {\n+    crate fn links(&self, krate: &CrateNum, cache: &Cache) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n         use crate::html::render::CURRENT_DEPTH;\n \n@@ -835,7 +835,7 @@ impl Attributes {\n             .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n                 match *did {\n                     Some(did) => {\n-                        if let Some((mut href, ..)) = href(did) {\n+                        if let Some((mut href, ..)) = href(did, cache) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push('#');\n                                 href.push_str(fragment);\n@@ -851,7 +851,6 @@ impl Attributes {\n                     }\n                     None => {\n                         if let Some(ref fragment) = *fragment {\n-                            let cache = cache();\n                             let url = match cache.extern_locations.get(krate) {\n                                 Some(&(_, _, ExternalLocation::Local)) => {\n                                     let depth = CURRENT_DEPTH.with(|l| l.get());\n@@ -1177,6 +1176,13 @@ impl GetDefId for FnRetTy {\n             DefaultReturn => None,\n         }\n     }\n+\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n+        match *self {\n+            Return(ref ty) => ty.def_id_full(cache),\n+            DefaultReturn => None,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -1299,13 +1305,31 @@ crate enum TypeKind {\n }\n \n crate trait GetDefId {\n+    /// Use this method to get the [`DefId`] of a [`clean`] AST node.\n+    /// This will return [`None`] when called on a primitive [`clean::Type`].\n+    /// Use [`Self::def_id_full`] if you want to include primitives.\n+    ///\n+    /// [`clean`]: crate::clean\n+    /// [`clean::Type`]: crate::clean::Type\n+    // FIXME: get rid of this function and always use `def_id_full`\n     fn def_id(&self) -> Option<DefId>;\n+\n+    /// Use this method to get the [DefId] of a [clean] AST node, including [PrimitiveType]s.\n+    ///\n+    /// See [`Self::def_id`] for more.\n+    ///\n+    /// [clean]: crate::clean\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId>;\n }\n \n impl<T: GetDefId> GetDefId for Option<T> {\n     fn def_id(&self) -> Option<DefId> {\n         self.as_ref().and_then(|d| d.def_id())\n     }\n+\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n+        self.as_ref().and_then(|d| d.def_id_full(cache))\n+    }\n }\n \n impl Type {\n@@ -1393,30 +1417,40 @@ impl Type {\n     }\n }\n \n-impl GetDefId for Type {\n-    fn def_id(&self) -> Option<DefId> {\n-        match *self {\n-            ResolvedPath { did, .. } => Some(did),\n-            Primitive(p) => cache().primitive_locations.get(&p).cloned(),\n-            BorrowedRef { type_: box Generic(..), .. } => {\n-                Primitive(PrimitiveType::Reference).def_id()\n-            }\n-            BorrowedRef { ref type_, .. } => type_.def_id(),\n+impl Type {\n+    fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n+        let t: PrimitiveType = match *self {\n+            ResolvedPath { did, .. } => return Some(did),\n+            Primitive(p) => return cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n+            BorrowedRef { type_: box Generic(..), .. } => PrimitiveType::Reference,\n+            BorrowedRef { ref type_, .. } => return type_.inner_def_id(cache),\n             Tuple(ref tys) => {\n                 if tys.is_empty() {\n-                    Primitive(PrimitiveType::Unit).def_id()\n+                    PrimitiveType::Unit\n                 } else {\n-                    Primitive(PrimitiveType::Tuple).def_id()\n+                    PrimitiveType::Tuple\n                 }\n             }\n-            BareFunction(..) => Primitive(PrimitiveType::Fn).def_id(),\n-            Never => Primitive(PrimitiveType::Never).def_id(),\n-            Slice(..) => Primitive(PrimitiveType::Slice).def_id(),\n-            Array(..) => Primitive(PrimitiveType::Array).def_id(),\n-            RawPointer(..) => Primitive(PrimitiveType::RawPointer).def_id(),\n-            QPath { ref self_type, .. } => self_type.def_id(),\n-            _ => None,\n-        }\n+            BareFunction(..) => PrimitiveType::Fn,\n+            Never => PrimitiveType::Never,\n+            Slice(..) => PrimitiveType::Slice,\n+            Array(..) => PrimitiveType::Array,\n+            RawPointer(..) => PrimitiveType::RawPointer,\n+            QPath { ref self_type, .. } => return self_type.inner_def_id(cache),\n+            // FIXME: remove this wildcard\n+            _ => return None,\n+        };\n+        cache.and_then(|c| Primitive(t).def_id_full(c))\n+    }\n+}\n+\n+impl GetDefId for Type {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.inner_def_id(None)\n+    }\n+\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n+        self.inner_def_id(Some(cache))\n     }\n }\n \n@@ -1817,6 +1851,10 @@ impl GetDefId for Typedef {\n     fn def_id(&self) -> Option<DefId> {\n         self.type_.def_id()\n     }\n+\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n+        self.type_.def_id_full(cache)\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "869d48fc25e07b8ce2d03d6a444a3ba279051b81", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -177,7 +177,7 @@ crate fn get_real_types(\n         return res;\n     }\n     if arg.is_full_generic() {\n-        let arg_s = Symbol::intern(&arg.print().to_string());\n+        let arg_s = Symbol::intern(&arg.print(&cx.cache).to_string());\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n             WherePredicate::BoundPredicate { ty, .. } => ty.def_id() == arg.def_id(),\n             _ => false,\n@@ -473,7 +473,7 @@ crate fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n             return Generic(kw::SelfUpper);\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(Symbol::intern(&format!(\"{:#}\", path.print())));\n+            return Generic(Symbol::intern(&format!(\"{:#}\", path.print(&cx.cache))));\n         }\n         Res::SelfTy(..) | Res::Def(DefKind::TyParam | DefKind::AssocTy, _) => true,\n         _ => false,"}, {"sha": "94773ac77ccb0e516d685c52b16a6ca4bf4d59da", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -261,7 +261,7 @@ crate struct RenderOptions {\n }\n \n /// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n-/// Later on moved into `CACHE_KEY`.\n+/// Later on moved into `cache`.\n #[derive(Default, Clone)]\n crate struct RenderInfo {\n     crate inlined: FxHashSet<DefId>,"}, {"sha": "16f11e460e6f062d8b68a6780cd1694f23176b82", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -32,6 +32,7 @@ use crate::clean;\n use crate::clean::{AttributesExt, MAX_DEF_ID};\n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::config::{OutputFormat, RenderInfo};\n+use crate::formats::cache::Cache;\n use crate::passes::{self, Condition::*, ConditionalPass};\n \n crate use rustc_session::config::{DebuggingOptions, Input, Options};\n@@ -45,9 +46,9 @@ crate struct DocContext<'tcx> {\n     ///\n     /// Most of this logic is copied from rustc_lint::late.\n     crate param_env: Cell<ParamEnv<'tcx>>,\n-    /// Later on moved into `CACHE_KEY`\n+    /// Later on moved into `cache`\n     crate renderinfo: RefCell<RenderInfo>,\n-    /// Later on moved through `clean::Crate` into `CACHE_KEY`\n+    /// Later on moved through `clean::Crate` into `cache`\n     crate external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n@@ -75,6 +76,8 @@ crate struct DocContext<'tcx> {\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     /// `map<module, set<trait>>`\n     crate module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n+    /// Fake empty cache used when cache is required as parameter.\n+    crate cache: Cache,\n }\n \n impl<'tcx> DocContext<'tcx> {\n@@ -524,6 +527,7 @@ crate fn run_global_ctxt(\n             .collect(),\n         render_options,\n         module_trait_cache: RefCell::new(FxHashMap::default()),\n+        cache: Cache::default(),\n     };\n     debug!(\"crate: {:?}\", tcx.hir().krate());\n "}, {"sha": "c506f5a37b15baf8be82405d6fc64a439c317c04", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -1,8 +1,6 @@\n-use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::mem;\n use std::path::{Path, PathBuf};\n-use std::sync::Arc;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n@@ -19,8 +17,6 @@ use crate::html::markdown::short_markdown_summary;\n use crate::html::render::cache::{extern_location, get_index_search_type, ExternalLocation};\n use crate::html::render::IndexItem;\n \n-thread_local!(crate static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n-\n /// This cache is used to store information about the [`clean::Crate`] being\n /// rendered in order to provide more useful documentation. This contains\n /// information like all implementors of a trait, all traits a type implements,\n@@ -197,6 +193,7 @@ impl Cache {\n         }\n \n         cache.stack.push(krate.name.to_string());\n+\n         krate = cache.fold_crate(krate);\n \n         for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n@@ -319,7 +316,7 @@ impl DocFolder for Cache {\n                                 .map_or_else(String::new, |x| short_markdown_summary(&x.as_str())),\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item),\n+                            search_type: get_index_search_type(&item, None),\n                         });\n \n                         for alias in item.attrs.get_doc_aliases() {\n@@ -477,7 +474,3 @@ impl DocFolder for Cache {\n         ret\n     }\n }\n-\n-crate fn cache() -> Arc<Cache> {\n-    CACHE_KEY.with(|c| c.borrow().clone())\n-}"}, {"sha": "1ce6572bbed044f7b205958c10c07a26412f41c4", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -8,6 +8,7 @@ use rustc_span::def_id::DefId;\n \n use crate::clean;\n use crate::clean::types::GetDefId;\n+use crate::formats::cache::Cache;\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n@@ -41,4 +42,8 @@ impl Impl {\n     crate fn trait_did(&self) -> Option<DefId> {\n         self.inner_impl().trait_.def_id()\n     }\n+\n+    crate fn trait_did_full(&self, cache: &Cache) -> Option<DefId> {\n+        self.inner_impl().trait_.def_id_full(cache)\n+    }\n }"}, {"sha": "6ecc4695dc8fbd287cd5ff689a1e0ab0f968a553", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -1,12 +1,10 @@\n-use std::sync::Arc;\n-\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n \n use crate::clean;\n use crate::config::{RenderInfo, RenderOptions};\n use crate::error::Error;\n-use crate::formats::cache::{Cache, CACHE_KEY};\n+use crate::formats::cache::Cache;\n \n /// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n /// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n@@ -22,20 +20,15 @@ crate trait FormatRenderer<'tcx>: Clone {\n         options: RenderOptions,\n         render_info: RenderInfo,\n         edition: Edition,\n-        cache: &mut Cache,\n+        cache: Cache,\n         tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error>;\n \n     /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n-    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error>;\n+    fn item(&mut self, item: clean::Item) -> Result<(), Error>;\n \n     /// Renders a module (should not handle recursing into children).\n-    fn mod_item_in(\n-        &mut self,\n-        item: &clean::Item,\n-        item_name: &str,\n-        cache: &Cache,\n-    ) -> Result<(), Error>;\n+    fn mod_item_in(&mut self, item: &clean::Item, item_name: &str) -> Result<(), Error>;\n \n     /// Runs after recursively rendering all sub-items of a module.\n     fn mod_item_out(&mut self, item_name: &str) -> Result<(), Error>;\n@@ -46,9 +39,10 @@ crate trait FormatRenderer<'tcx>: Clone {\n     fn after_krate(\n         &mut self,\n         krate: &clean::Crate,\n-        cache: &Cache,\n         diag: &rustc_errors::Handler,\n     ) -> Result<(), Error>;\n+\n+    fn cache(&self) -> &Cache;\n }\n \n /// Main method for rendering a crate.\n@@ -60,7 +54,7 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n     edition: Edition,\n     tcx: TyCtxt<'tcx>,\n ) -> Result<(), Error> {\n-    let (krate, mut cache) = tcx.sess.time(\"create_format_cache\", || {\n+    let (krate, cache) = tcx.sess.time(\"create_format_cache\", || {\n         Cache::from_krate(\n             render_info.clone(),\n             options.document_private,\n@@ -73,12 +67,7 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n \n     let (mut format_renderer, mut krate) = prof\n         .extra_verbose_generic_activity(\"create_renderer\", T::descr())\n-        .run(|| T::init(krate, options, render_info, edition, &mut cache, tcx))?;\n-\n-    let cache = Arc::new(cache);\n-    // Freeze the cache now that the index has been built. Put an Arc into TLS for future\n-    // parallelization opportunities\n-    CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n+        .run(|| T::init(krate, options, render_info, edition, cache, tcx))?;\n \n     let mut item = match krate.module.take() {\n         Some(i) => i,\n@@ -101,7 +90,7 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n             }\n             let _timer = prof.generic_activity_with_arg(\"render_mod_item\", name.as_str());\n \n-            cx.mod_item_in(&item, &name, &cache)?;\n+            cx.mod_item_in(&item, &name)?;\n             let module = match *item.kind {\n                 clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n                 _ => unreachable!(),\n@@ -114,9 +103,9 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n             cx.mod_item_out(&name)?;\n         } else if item.name.is_some() {\n             prof.generic_activity_with_arg(\"render_item\", &*item.name.unwrap_or(unknown).as_str())\n-                .run(|| cx.item(item, &cache))?;\n+                .run(|| cx.item(item))?;\n         }\n     }\n     prof.extra_verbose_generic_activity(\"renderer_after_krate\", T::descr())\n-        .run(|| format_renderer.after_krate(&krate, &cache, diag))\n+        .run(|| format_renderer.after_krate(&krate, diag))\n }"}, {"sha": "01915c33a07adb78654c5e8cde1f1fc6508b5a10", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 279, "deletions": 228, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -16,7 +16,7 @@ use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{self, utils::find_nearest_parent_module, PrimitiveType};\n-use crate::formats::cache::cache;\n+use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n@@ -152,159 +152,172 @@ fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Displ\n     })\n }\n \n-crate fn print_generic_bounds(bounds: &[clean::GenericBound]) -> impl fmt::Display + '_ {\n+crate fn print_generic_bounds<'a>(\n+    bounds: &'a [clean::GenericBound],\n+    cache: &'a Cache,\n+) -> impl fmt::Display + 'a {\n     display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n \n         for (i, bound) in\n-            bounds.iter().filter(|b| bounds_dup.insert(b.print().to_string())).enumerate()\n+            bounds.iter().filter(|b| bounds_dup.insert(b.print(cache).to_string())).enumerate()\n         {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            fmt::Display::fmt(&bound.print(), f)?;\n+            fmt::Display::fmt(&bound.print(cache), f)?;\n         }\n         Ok(())\n     })\n }\n \n impl clean::GenericParamDef {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| match self.kind {\n             clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n             clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n                 f.write_str(&*self.name.as_str())?;\n \n                 if !bounds.is_empty() {\n                     if f.alternate() {\n-                        write!(f, \": {:#}\", print_generic_bounds(bounds))?;\n+                        write!(f, \": {:#}\", print_generic_bounds(bounds, cache))?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds))?;\n+                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache))?;\n                     }\n                 }\n \n                 if let Some(ref ty) = default {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print())?;\n+                        write!(f, \" = {:#}\", ty.print(cache))?;\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print())?;\n+                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print(cache))?;\n                     }\n                 }\n \n                 Ok(())\n             }\n             clean::GenericParamDefKind::Const { ref ty, .. } => {\n                 if f.alternate() {\n-                    write!(f, \"const {}: {:#}\", self.name, ty.print())\n+                    write!(f, \"const {}: {:#}\", self.name, ty.print(cache))\n                 } else {\n-                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print())\n+                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print(cache))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::Generics {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| {\n             let real_params =\n                 self.params.iter().filter(|p| !p.is_synthetic_type_param()).collect::<Vec<_>>();\n             if real_params.is_empty() {\n                 return Ok(());\n             }\n             if f.alternate() {\n-                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print())))\n+                write!(f, \"<{:#}>\", comma_sep(real_params.iter().map(|g| g.print(cache))))\n             } else {\n-                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print())))\n+                write!(f, \"&lt;{}&gt;\", comma_sep(real_params.iter().map(|g| g.print(cache))))\n             }\n         })\n     }\n }\n \n-impl<'a> fmt::Display for WhereClause<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let &WhereClause { gens, indent, end_newline } = self;\n-        if gens.where_predicates.is_empty() {\n-            return Ok(());\n-        }\n-        let mut clause = String::new();\n-        if f.alternate() {\n-            clause.push_str(\" where\");\n-        } else {\n-            if end_newline {\n-                clause.push_str(\" <span class=\\\"where fmt-newline\\\">where\");\n-            } else {\n-                clause.push_str(\" <span class=\\\"where\\\">where\");\n+impl<'a> WhereClause<'a> {\n+    crate fn print<'b>(&'b self, cache: &'b Cache) -> impl fmt::Display + 'b {\n+        display_fn(move |f| {\n+            let &WhereClause { gens, indent, end_newline } = self;\n+            if gens.where_predicates.is_empty() {\n+                return Ok(());\n             }\n-        }\n-        for (i, pred) in gens.where_predicates.iter().enumerate() {\n+            let mut clause = String::new();\n             if f.alternate() {\n-                clause.push(' ');\n+                clause.push_str(\" where\");\n             } else {\n-                clause.push_str(\"<br>\");\n+                if end_newline {\n+                    clause.push_str(\" <span class=\\\"where fmt-newline\\\">where\");\n+                } else {\n+                    clause.push_str(\" <span class=\\\"where\\\">where\");\n+                }\n             }\n+            for (i, pred) in gens.where_predicates.iter().enumerate() {\n+                if f.alternate() {\n+                    clause.push(' ');\n+                } else {\n+                    clause.push_str(\"<br>\");\n+                }\n \n-            match pred {\n-                clean::WherePredicate::BoundPredicate { ty, bounds } => {\n-                    let bounds = bounds;\n-                    if f.alternate() {\n-                        clause.push_str(&format!(\n-                            \"{:#}: {:#}\",\n-                            ty.print(),\n-                            print_generic_bounds(bounds)\n-                        ));\n-                    } else {\n+                match pred {\n+                    clean::WherePredicate::BoundPredicate { ty, bounds } => {\n+                        let bounds = bounds;\n+                        if f.alternate() {\n+                            clause.push_str(&format!(\n+                                \"{:#}: {:#}\",\n+                                ty.print(cache),\n+                                print_generic_bounds(bounds, cache)\n+                            ));\n+                        } else {\n+                            clause.push_str(&format!(\n+                                \"{}: {}\",\n+                                ty.print(cache),\n+                                print_generic_bounds(bounds, cache)\n+                            ));\n+                        }\n+                    }\n+                    clean::WherePredicate::RegionPredicate { lifetime, bounds } => {\n                         clause.push_str(&format!(\n                             \"{}: {}\",\n-                            ty.print(),\n-                            print_generic_bounds(bounds)\n+                            lifetime.print(),\n+                            bounds\n+                                .iter()\n+                                .map(|b| b.print(cache).to_string())\n+                                .collect::<Vec<_>>()\n+                                .join(\" + \")\n                         ));\n                     }\n-                }\n-                clean::WherePredicate::RegionPredicate { lifetime, bounds } => {\n-                    clause.push_str(&format!(\n-                        \"{}: {}\",\n-                        lifetime.print(),\n-                        bounds\n-                            .iter()\n-                            .map(|b| b.print().to_string())\n-                            .collect::<Vec<_>>()\n-                            .join(\" + \")\n-                    ));\n-                }\n-                clean::WherePredicate::EqPredicate { lhs, rhs } => {\n-                    if f.alternate() {\n-                        clause.push_str(&format!(\"{:#} == {:#}\", lhs.print(), rhs.print()));\n-                    } else {\n-                        clause.push_str(&format!(\"{} == {}\", lhs.print(), rhs.print()));\n+                    clean::WherePredicate::EqPredicate { lhs, rhs } => {\n+                        if f.alternate() {\n+                            clause.push_str(&format!(\n+                                \"{:#} == {:#}\",\n+                                lhs.print(cache),\n+                                rhs.print(cache)\n+                            ));\n+                        } else {\n+                            clause.push_str(&format!(\n+                                \"{} == {}\",\n+                                lhs.print(cache),\n+                                rhs.print(cache)\n+                            ));\n+                        }\n                     }\n                 }\n-            }\n \n-            if i < gens.where_predicates.len() - 1 || end_newline {\n-                clause.push(',');\n+                if i < gens.where_predicates.len() - 1 || end_newline {\n+                    clause.push(',');\n+                }\n             }\n-        }\n \n-        if end_newline {\n-            // add a space so stripping <br> tags and breaking spaces still renders properly\n-            if f.alternate() {\n-                clause.push(' ');\n-            } else {\n-                clause.push_str(\"&nbsp;\");\n+            if end_newline {\n+                // add a space so stripping <br> tags and breaking spaces still renders properly\n+                if f.alternate() {\n+                    clause.push(' ');\n+                } else {\n+                    clause.push_str(\"&nbsp;\");\n+                }\n             }\n-        }\n \n-        if !f.alternate() {\n-            clause.push_str(\"</span>\");\n-            let padding = \"&nbsp;\".repeat(indent + 4);\n-            clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n-            clause.insert_str(0, &\"&nbsp;\".repeat(indent.saturating_sub(1)));\n-            if !end_newline {\n-                clause.insert_str(0, \"<br>\");\n+            if !f.alternate() {\n+                clause.push_str(\"</span>\");\n+                let padding = \"&nbsp;\".repeat(indent + 4);\n+                clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n+                clause.insert_str(0, &\"&nbsp;\".repeat(indent.saturating_sub(1)));\n+                if !end_newline {\n+                    clause.insert_str(0, \"<br>\");\n+                }\n             }\n-        }\n-        write!(f, \"{}\", clause)\n+            write!(f, \"{}\", clause)\n+        })\n     }\n }\n \n@@ -327,34 +340,34 @@ impl clean::Constant {\n }\n \n impl clean::PolyTrait {\n-    fn print(&self) -> impl fmt::Display + '_ {\n+    fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n                 if f.alternate() {\n                     write!(\n                         f,\n                         \"for<{:#}> \",\n-                        comma_sep(self.generic_params.iter().map(|g| g.print()))\n+                        comma_sep(self.generic_params.iter().map(|g| g.print(cache)))\n                     )?;\n                 } else {\n                     write!(\n                         f,\n                         \"for&lt;{}&gt; \",\n-                        comma_sep(self.generic_params.iter().map(|g| g.print()))\n+                        comma_sep(self.generic_params.iter().map(|g| g.print(cache)))\n                     )?;\n                 }\n             }\n             if f.alternate() {\n-                write!(f, \"{:#}\", self.trait_.print())\n+                write!(f, \"{:#}\", self.trait_.print(cache))\n             } else {\n-                write!(f, \"{}\", self.trait_.print())\n+                write!(f, \"{}\", self.trait_.print(cache))\n             }\n         })\n     }\n }\n \n impl clean::GenericBound {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| match self {\n             clean::GenericBound::Outlives(lt) => write!(f, \"{}\", lt.print()),\n             clean::GenericBound::TraitBound(ty, modifier) => {\n@@ -364,17 +377,17 @@ impl clean::GenericBound {\n                     hir::TraitBoundModifier::MaybeConst => \"?const\",\n                 };\n                 if f.alternate() {\n-                    write!(f, \"{}{:#}\", modifier_str, ty.print())\n+                    write!(f, \"{}{:#}\", modifier_str, ty.print(cache))\n                 } else {\n-                    write!(f, \"{}{}\", modifier_str, ty.print())\n+                    write!(f, \"{}{}\", modifier_str, ty.print(cache))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::GenericArgs {\n-    fn print(&self) -> impl fmt::Display + '_ {\n+    fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| {\n             match self {\n                 clean::GenericArgs::AngleBracketed { args, bindings } => {\n@@ -391,9 +404,9 @@ impl clean::GenericArgs {\n                             }\n                             comma = true;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", arg.print())?;\n+                                write!(f, \"{:#}\", arg.print(cache))?;\n                             } else {\n-                                write!(f, \"{}\", arg.print())?;\n+                                write!(f, \"{}\", arg.print(cache))?;\n                             }\n                         }\n                         for binding in bindings {\n@@ -402,9 +415,9 @@ impl clean::GenericArgs {\n                             }\n                             comma = true;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", binding.print())?;\n+                                write!(f, \"{:#}\", binding.print(cache))?;\n                             } else {\n-                                write!(f, \"{}\", binding.print())?;\n+                                write!(f, \"{}\", binding.print(cache))?;\n                             }\n                         }\n                         if f.alternate() {\n@@ -423,17 +436,17 @@ impl clean::GenericArgs {\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", ty.print())?;\n+                            write!(f, \"{:#}\", ty.print(cache))?;\n                         } else {\n-                            write!(f, \"{}\", ty.print())?;\n+                            write!(f, \"{}\", ty.print(cache))?;\n                         }\n                     }\n                     f.write_str(\")\")?;\n                     if let Some(ref ty) = *output {\n                         if f.alternate() {\n-                            write!(f, \" -> {:#}\", ty.print())?;\n+                            write!(f, \" -> {:#}\", ty.print(cache))?;\n                         } else {\n-                            write!(f, \" -&gt; {}\", ty.print())?;\n+                            write!(f, \" -&gt; {}\", ty.print(cache))?;\n                         }\n                     }\n                 }\n@@ -444,19 +457,19 @@ impl clean::GenericArgs {\n }\n \n impl clean::PathSegment {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| {\n             if f.alternate() {\n-                write!(f, \"{}{:#}\", self.name, self.args.print())\n+                write!(f, \"{}{:#}\", self.name, self.args.print(cache))\n             } else {\n-                write!(f, \"{}{}\", self.name, self.args.print())\n+                write!(f, \"{}{}\", self.name, self.args.print(cache))\n             }\n         })\n     }\n }\n \n impl clean::Path {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| {\n             if self.global {\n                 f.write_str(\"::\")?\n@@ -467,18 +480,17 @@ impl clean::Path {\n                     f.write_str(\"::\")?\n                 }\n                 if f.alternate() {\n-                    write!(f, \"{:#}\", seg.print())?;\n+                    write!(f, \"{:#}\", seg.print(cache))?;\n                 } else {\n-                    write!(f, \"{}\", seg.print())?;\n+                    write!(f, \"{}\", seg.print(cache))?;\n                 }\n             }\n             Ok(())\n         })\n     }\n }\n \n-crate fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n-    let cache = cache();\n+crate fn href(did: DefId, cache: &Cache) -> Option<(String, ItemType, Vec<String>)> {\n     if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n         return None;\n     }\n@@ -526,6 +538,7 @@ fn resolved_path(\n     path: &clean::Path,\n     print_all: bool,\n     use_absolute: bool,\n+    cache: &Cache,\n ) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n \n@@ -535,18 +548,22 @@ fn resolved_path(\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{}{:#}\", &last.name, last.args.print())?;\n+        write!(w, \"{}{:#}\", &last.name, last.args.print(cache))?;\n     } else {\n         let path = if use_absolute {\n-            if let Some((_, _, fqp)) = href(did) {\n-                format!(\"{}::{}\", fqp[..fqp.len() - 1].join(\"::\"), anchor(did, fqp.last().unwrap()))\n+            if let Some((_, _, fqp)) = href(did, cache) {\n+                format!(\n+                    \"{}::{}\",\n+                    fqp[..fqp.len() - 1].join(\"::\"),\n+                    anchor(did, fqp.last().unwrap(), cache)\n+                )\n             } else {\n                 last.name.to_string()\n             }\n         } else {\n-            anchor(did, &*last.name.as_str()).to_string()\n+            anchor(did, &*last.name.as_str(), cache).to_string()\n         };\n-        write!(w, \"{}{}\", path, last.args.print())?;\n+        write!(w, \"{}{}\", path, last.args.print(cache))?;\n     }\n     Ok(())\n }\n@@ -555,8 +572,8 @@ fn primitive_link(\n     f: &mut fmt::Formatter<'_>,\n     prim: clean::PrimitiveType,\n     name: &str,\n+    m: &Cache,\n ) -> fmt::Result {\n-    let m = cache();\n     let mut needs_termination = false;\n     if !f.alternate() {\n         match m.primitive_locations.get(&prim) {\n@@ -602,22 +619,25 @@ fn primitive_link(\n }\n \n /// Helper to render type parameters\n-fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display + '_ {\n+fn tybounds<'a>(\n+    param_names: &'a Option<Vec<clean::GenericBound>>,\n+    cache: &'a Cache,\n+) -> impl fmt::Display + 'a {\n     display_fn(move |f| match *param_names {\n         Some(ref params) => {\n             for param in params {\n                 write!(f, \" + \")?;\n-                fmt::Display::fmt(&param.print(), f)?;\n+                fmt::Display::fmt(&param.print(cache), f)?;\n             }\n             Ok(())\n         }\n         None => Ok(()),\n     })\n }\n \n-crate fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n+crate fn anchor<'a>(did: DefId, text: &'a str, cache: &'a Cache) -> impl fmt::Display + 'a {\n     display_fn(move |f| {\n-        if let Some((url, short_ty, fqp)) = href(did) {\n+        if let Some((url, short_ty, fqp)) = href(did, cache) {\n             write!(\n                 f,\n                 r#\"<a class=\"{}\" href=\"{}\" title=\"{} {}\">{}</a>\"#,\n@@ -633,28 +653,33 @@ crate fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n     })\n }\n \n-fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) -> fmt::Result {\n+fn fmt_type(\n+    t: &clean::Type,\n+    f: &mut fmt::Formatter<'_>,\n+    use_absolute: bool,\n+    cache: &Cache,\n+) -> fmt::Result {\n     match *t {\n         clean::Generic(name) => write!(f, \"{}\", name),\n         clean::ResolvedPath { did, ref param_names, ref path, is_generic } => {\n             if param_names.is_some() {\n                 f.write_str(\"dyn \")?;\n             }\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n-            resolved_path(f, did, path, is_generic, use_absolute)?;\n-            fmt::Display::fmt(&tybounds(param_names), f)\n+            resolved_path(f, did, path, is_generic, use_absolute, cache)?;\n+            fmt::Display::fmt(&tybounds(param_names, cache), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n-        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n+        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str(), cache),\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(\n                     f,\n                     \"{}{:#}fn{:#}{:#}\",\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi),\n-                    decl.print_generic_params(),\n-                    decl.decl.print()\n+                    decl.print_generic_params(cache),\n+                    decl.decl.print(cache)\n                 )\n             } else {\n                 write!(\n@@ -663,46 +688,46 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi)\n                 )?;\n-                primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n-                write!(f, \"{}{}\", decl.print_generic_params(), decl.decl.print())\n+                primitive_link(f, PrimitiveType::Fn, \"fn\", cache)?;\n+                write!(f, \"{}{}\", decl.print_generic_params(cache), decl.decl.print(cache))\n             }\n         }\n         clean::Tuple(ref typs) => {\n             match &typs[..] {\n-                &[] => primitive_link(f, PrimitiveType::Unit, \"()\"),\n+                &[] => primitive_link(f, PrimitiveType::Unit, \"()\", cache),\n                 &[ref one] => {\n-                    primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\", cache)?;\n                     // Carry `f.alternate()` into this display w/o branching manually.\n-                    fmt::Display::fmt(&one.print(), f)?;\n-                    primitive_link(f, PrimitiveType::Tuple, \",)\")\n+                    fmt::Display::fmt(&one.print(cache), f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \",)\", cache)\n                 }\n                 many => {\n-                    primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\", cache)?;\n                     for (i, item) in many.iter().enumerate() {\n                         if i != 0 {\n                             write!(f, \", \")?;\n                         }\n-                        fmt::Display::fmt(&item.print(), f)?;\n+                        fmt::Display::fmt(&item.print(cache), f)?;\n                     }\n-                    primitive_link(f, PrimitiveType::Tuple, \")\")\n+                    primitive_link(f, PrimitiveType::Tuple, \")\", cache)\n                 }\n             }\n         }\n         clean::Slice(ref t) => {\n-            primitive_link(f, PrimitiveType::Slice, \"[\")?;\n-            fmt::Display::fmt(&t.print(), f)?;\n-            primitive_link(f, PrimitiveType::Slice, \"]\")\n+            primitive_link(f, PrimitiveType::Slice, \"[\", cache)?;\n+            fmt::Display::fmt(&t.print(cache), f)?;\n+            primitive_link(f, PrimitiveType::Slice, \"]\", cache)\n         }\n         clean::Array(ref t, ref n) => {\n-            primitive_link(f, PrimitiveType::Array, \"[\")?;\n-            fmt::Display::fmt(&t.print(), f)?;\n+            primitive_link(f, PrimitiveType::Array, \"[\", cache)?;\n+            fmt::Display::fmt(&t.print(cache), f)?;\n             if f.alternate() {\n-                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))\n+                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n), cache)\n             } else {\n-                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", Escape(n)))\n+                primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", Escape(n)), cache)\n             }\n         }\n-        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\"),\n+        clean::Never => primitive_link(f, PrimitiveType::Never, \"!\", cache),\n         clean::RawPointer(m, ref t) => {\n             let m = match m {\n                 hir::Mutability::Mut => \"mut\",\n@@ -714,19 +739,26 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n-                            &format!(\"*{} {:#}\", m, t.print()),\n+                            &format!(\"*{} {:#}\", m, t.print(cache)),\n+                            cache,\n                         )\n                     } else {\n                         primitive_link(\n                             f,\n                             clean::PrimitiveType::RawPointer,\n-                            &format!(\"*{} {}\", m, t.print()),\n+                            &format!(\"*{} {}\", m, t.print(cache)),\n+                            cache,\n                         )\n                     }\n                 }\n                 _ => {\n-                    primitive_link(f, clean::PrimitiveType::RawPointer, &format!(\"*{} \", m))?;\n-                    fmt::Display::fmt(&t.print(), f)\n+                    primitive_link(\n+                        f,\n+                        clean::PrimitiveType::RawPointer,\n+                        &format!(\"*{} \", m),\n+                        cache,\n+                    )?;\n+                    fmt::Display::fmt(&t.print(cache), f)\n                 }\n             }\n         }\n@@ -746,13 +778,15 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print()),\n+                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, bt.print(cache)),\n+                                    cache,\n                                 )\n                             } else {\n                                 primitive_link(\n                                     f,\n                                     PrimitiveType::Slice,\n-                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print()),\n+                                    &format!(\"{}{}{}[{}]\", amp, lt, m, bt.print(cache)),\n+                                    cache,\n                                 )\n                             }\n                         }\n@@ -761,36 +795,42 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                                 f,\n                                 PrimitiveType::Slice,\n                                 &format!(\"{}{}{}[\", amp, lt, m),\n+                                cache,\n                             )?;\n                             if f.alternate() {\n-                                write!(f, \"{:#}\", bt.print())?;\n+                                write!(f, \"{:#}\", bt.print(cache))?;\n                             } else {\n-                                write!(f, \"{}\", bt.print())?;\n+                                write!(f, \"{}\", bt.print(cache))?;\n                             }\n-                            primitive_link(f, PrimitiveType::Slice, \"]\")\n+                            primitive_link(f, PrimitiveType::Slice, \"]\", cache)\n                         }\n                     }\n                 }\n                 clean::ResolvedPath { param_names: Some(ref v), .. } if !v.is_empty() => {\n                     write!(f, \"{}{}{}(\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute)?;\n+                    fmt_type(&ty, f, use_absolute, cache)?;\n                     write!(f, \")\")\n                 }\n                 clean::Generic(..) => {\n-                    primitive_link(f, PrimitiveType::Reference, &format!(\"{}{}{}\", amp, lt, m))?;\n-                    fmt_type(&ty, f, use_absolute)\n+                    primitive_link(\n+                        f,\n+                        PrimitiveType::Reference,\n+                        &format!(\"{}{}{}\", amp, lt, m),\n+                        cache,\n+                    )?;\n+                    fmt_type(&ty, f, use_absolute, cache)\n                 }\n                 _ => {\n                     write!(f, \"{}{}{}\", amp, lt, m)?;\n-                    fmt_type(&ty, f, use_absolute)\n+                    fmt_type(&ty, f, use_absolute, cache)\n                 }\n             }\n         }\n         clean::ImplTrait(ref bounds) => {\n             if f.alternate() {\n-                write!(f, \"impl {:#}\", print_generic_bounds(bounds))\n+                write!(f, \"impl {:#}\", print_generic_bounds(bounds, cache))\n             } else {\n-                write!(f, \"impl {}\", print_generic_bounds(bounds))\n+                write!(f, \"impl {}\", print_generic_bounds(bounds, cache))\n             }\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n@@ -802,15 +842,15 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n             };\n             if f.alternate() {\n                 if should_show_cast {\n-                    write!(f, \"<{:#} as {:#}>::\", self_type.print(), trait_.print())?\n+                    write!(f, \"<{:#} as {:#}>::\", self_type.print(cache), trait_.print(cache))?\n                 } else {\n-                    write!(f, \"{:#}::\", self_type.print())?\n+                    write!(f, \"{:#}::\", self_type.print(cache))?\n                 }\n             } else {\n                 if should_show_cast {\n-                    write!(f, \"&lt;{} as {}&gt;::\", self_type.print(), trait_.print())?\n+                    write!(f, \"&lt;{} as {}&gt;::\", self_type.print(cache), trait_.print(cache))?\n                 } else {\n-                    write!(f, \"{}::\", self_type.print())?\n+                    write!(f, \"{}::\", self_type.print(cache))?\n                 }\n             };\n             match *trait_ {\n@@ -825,7 +865,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 //        everything comes in as a fully resolved QPath (hard to\n                 //        look at).\n                 box clean::ResolvedPath { did, ref param_names, .. } => {\n-                    match href(did) {\n+                    match href(did, cache) {\n                         Some((ref url, _, ref path)) if !f.alternate() => {\n                             write!(\n                                 f,\n@@ -851,22 +891,27 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n }\n \n impl clean::Type {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n-        display_fn(move |f| fmt_type(self, f, false))\n+    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n+        display_fn(move |f| fmt_type(self, f, false, cache))\n     }\n }\n \n impl clean::Impl {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n-        self.print_inner(true, false)\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+        self.print_inner(true, false, cache)\n     }\n \n-    fn print_inner(&self, link_trait: bool, use_absolute: bool) -> impl fmt::Display + '_ {\n+    fn print_inner<'a>(\n+        &'a self,\n+        link_trait: bool,\n+        use_absolute: bool,\n+        cache: &'a Cache,\n+    ) -> impl fmt::Display + 'a {\n         display_fn(move |f| {\n             if f.alternate() {\n-                write!(f, \"impl{:#} \", self.generics.print())?;\n+                write!(f, \"impl{:#} \", self.generics.print(cache))?;\n             } else {\n-                write!(f, \"impl{} \", self.generics.print())?;\n+                write!(f, \"impl{} \", self.generics.print(cache))?;\n             }\n \n             if let Some(ref ty) = self.trait_ {\n@@ -875,15 +920,15 @@ impl clean::Impl {\n                 }\n \n                 if link_trait {\n-                    fmt::Display::fmt(&ty.print(), f)?;\n+                    fmt::Display::fmt(&ty.print(cache), f)?;\n                 } else {\n                     match ty {\n                         clean::ResolvedPath {\n                             param_names: None, path, is_generic: false, ..\n                         } => {\n                             let last = path.segments.last().unwrap();\n                             fmt::Display::fmt(&last.name, f)?;\n-                            fmt::Display::fmt(&last.args.print(), f)?;\n+                            fmt::Display::fmt(&last.args.print(cache), f)?;\n                         }\n                         _ => unreachable!(),\n                     }\n@@ -892,36 +937,39 @@ impl clean::Impl {\n             }\n \n             if let Some(ref ty) = self.blanket_impl {\n-                fmt_type(ty, f, use_absolute)?;\n+                fmt_type(ty, f, use_absolute, cache)?;\n             } else {\n-                fmt_type(&self.for_, f, use_absolute)?;\n+                fmt_type(&self.for_, f, use_absolute, cache)?;\n             }\n \n-            fmt::Display::fmt(\n-                &WhereClause { gens: &self.generics, indent: 0, end_newline: true },\n-                f,\n-            )?;\n+            let where_clause = WhereClause { gens: &self.generics, indent: 0, end_newline: true };\n+            fmt::Display::fmt(&where_clause.print(cache), f)?;\n             Ok(())\n         })\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n-crate fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut Buffer, use_absolute: bool) {\n-    f.from_display(i.print_inner(false, use_absolute))\n+crate fn fmt_impl_for_trait_page(\n+    i: &clean::Impl,\n+    f: &mut Buffer,\n+    use_absolute: bool,\n+    cache: &Cache,\n+) {\n+    f.from_display(i.print_inner(false, use_absolute, cache))\n }\n \n impl clean::Arguments {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| {\n             for (i, input) in self.values.iter().enumerate() {\n                 if !input.name.is_empty() {\n                     write!(f, \"{}: \", input.name)?;\n                 }\n                 if f.alternate() {\n-                    write!(f, \"{:#}\", input.type_.print())?;\n+                    write!(f, \"{:#}\", input.type_.print(cache))?;\n                 } else {\n-                    write!(f, \"{}\", input.type_.print())?;\n+                    write!(f, \"{}\", input.type_.print(cache))?;\n                 }\n                 if i + 1 < self.values.len() {\n                     write!(f, \", \")?;\n@@ -933,49 +981,49 @@ impl clean::Arguments {\n }\n \n impl clean::FnRetTy {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| match self {\n             clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print()),\n-            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print()),\n+            clean::Return(ty) if f.alternate() => write!(f, \" -> {:#}\", ty.print(cache)),\n+            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cache)),\n             clean::DefaultReturn => Ok(()),\n         })\n     }\n }\n \n impl clean::BareFunctionDecl {\n-    fn print_generic_params(&self) -> impl fmt::Display + '_ {\n-        comma_sep(self.generic_params.iter().map(|g| g.print()))\n+    fn print_generic_params<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+        comma_sep(self.generic_params.iter().map(move |g| g.print(cache)))\n     }\n }\n \n impl clean::FnDecl {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n         display_fn(move |f| {\n             let ellipsis = if self.c_variadic { \", ...\" } else { \"\" };\n             if f.alternate() {\n                 write!(\n                     f,\n                     \"({args:#}{ellipsis}){arrow:#}\",\n-                    args = self.inputs.print(),\n+                    args = self.inputs.print(cache),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print()\n+                    arrow = self.output.print(cache)\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"({args}{ellipsis}){arrow}\",\n-                    args = self.inputs.print(),\n+                    args = self.inputs.print(cache),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print()\n+                    arrow = self.output.print(cache)\n                 )\n             }\n         })\n     }\n }\n \n impl Function<'_> {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n         display_fn(move |f| {\n             let &Function { decl, header_len, indent, asyncness } = self;\n             let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n@@ -1011,11 +1059,11 @@ impl Function<'_> {\n                         }\n                         clean::SelfExplicit(ref typ) => {\n                             if f.alternate() {\n-                                args.push_str(&format!(\"self: {:#}\", typ.print()));\n+                                args.push_str(&format!(\"self: {:#}\", typ.print(cache)));\n                             } else {\n-                                args.push_str(&format!(\"self: {}\", typ.print()));\n+                                args.push_str(&format!(\"self: {}\", typ.print(cache)));\n                             }\n-                            args_plain.push_str(&format!(\"self: {:#}\", typ.print()));\n+                            args_plain.push_str(&format!(\"self: {:#}\", typ.print(cache)));\n                         }\n                     }\n                 } else {\n@@ -1029,11 +1077,11 @@ impl Function<'_> {\n                     }\n \n                     if f.alternate() {\n-                        args.push_str(&format!(\"{:#}\", input.type_.print()));\n+                        args.push_str(&format!(\"{:#}\", input.type_.print(cache)));\n                     } else {\n-                        args.push_str(&input.type_.print().to_string());\n+                        args.push_str(&input.type_.print(cache).to_string());\n                     }\n-                    args_plain.push_str(&format!(\"{:#}\", input.type_.print()));\n+                    args_plain.push_str(&format!(\"{:#}\", input.type_.print(cache)));\n                 }\n                 if i + 1 < decl.inputs.values.len() {\n                     args.push(',');\n@@ -1054,11 +1102,11 @@ impl Function<'_> {\n                 Cow::Borrowed(&decl.output)\n             };\n \n-            let arrow_plain = format!(\"{:#}\", &output.print());\n+            let arrow_plain = format!(\"{:#}\", &output.print(cache));\n             let arrow = if f.alternate() {\n-                format!(\"{:#}\", &output.print())\n+                format!(\"{:#}\", &output.print(cache))\n             } else {\n-                output.print().to_string()\n+                output.print(cache).to_string()\n             };\n \n             let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n@@ -1089,52 +1137,55 @@ impl clean::Visibility {\n         self,\n         tcx: TyCtxt<'tcx>,\n         item_did: DefId,\n+        cache: &Cache,\n     ) -> impl fmt::Display + 'tcx {\n         use rustc_span::symbol::kw;\n \n-        display_fn(move |f| match self {\n-            clean::Public => f.write_str(\"pub \"),\n-            clean::Inherited => Ok(()),\n-\n+        let to_print = match self {\n+            clean::Public => \"pub \".to_owned(),\n+            clean::Inherited => String::new(),\n             clean::Visibility::Restricted(vis_did) => {\n                 // FIXME(camelid): This may not work correctly if `item_did` is a module.\n                 //                 However, rustdoc currently never displays a module's\n                 //                 visibility, so it shouldn't matter.\n                 let parent_module = find_nearest_parent_module(tcx, item_did);\n \n                 if vis_did.index == CRATE_DEF_INDEX {\n-                    write!(f, \"pub(crate) \")\n+                    \"pub(crate) \".to_owned()\n                 } else if parent_module == Some(vis_did) {\n                     // `pub(in foo)` where `foo` is the parent module\n                     // is the same as no visibility modifier\n-                    Ok(())\n+                    String::new()\n                 } else if parent_module\n                     .map(|parent| find_nearest_parent_module(tcx, parent))\n                     .flatten()\n                     == Some(vis_did)\n                 {\n-                    write!(f, \"pub(super) \")\n+                    \"pub(super) \".to_owned()\n                 } else {\n-                    f.write_str(\"pub(\")?;\n                     let path = tcx.def_path(vis_did);\n                     debug!(\"path={:?}\", path);\n                     let first_name =\n                         path.data[0].data.get_opt_name().expect(\"modules are always named\");\n+                    // modified from `resolved_path()` to work with `DefPathData`\n+                    let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n+                    let anchor = anchor(vis_did, &last_name.as_str(), cache).to_string();\n+\n+                    let mut s = \"pub(\".to_owned();\n                     if path.data.len() != 1\n                         || (first_name != kw::SelfLower && first_name != kw::Super)\n                     {\n-                        f.write_str(\"in \")?;\n+                        s.push_str(\"in \");\n                     }\n-                    // modified from `resolved_path()` to work with `DefPathData`\n-                    let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n                     for seg in &path.data[..path.data.len() - 1] {\n-                        write!(f, \"{}::\", seg.data.get_opt_name().unwrap())?;\n+                        s.push_str(&format!(\"{}::\", seg.data.get_opt_name().unwrap()));\n                     }\n-                    let path = anchor(vis_did, &last_name.as_str()).to_string();\n-                    write!(f, \"{}) \", path)\n+                    s.push_str(&format!(\"{}) \", anchor));\n+                    s\n                 }\n             }\n-        })\n+        };\n+        display_fn(move |f| f.write_str(&to_print))\n     }\n }\n \n@@ -1179,37 +1230,37 @@ impl PrintWithSpace for hir::Mutability {\n }\n \n impl clean::Import {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n         display_fn(move |f| match self.kind {\n             clean::ImportKind::Simple(name) => {\n                 if name == self.source.path.last() {\n-                    write!(f, \"use {};\", self.source.print())\n+                    write!(f, \"use {};\", self.source.print(cache))\n                 } else {\n-                    write!(f, \"use {} as {};\", self.source.print(), name)\n+                    write!(f, \"use {} as {};\", self.source.print(cache), name)\n                 }\n             }\n             clean::ImportKind::Glob => {\n                 if self.source.path.segments.is_empty() {\n                     write!(f, \"use *;\")\n                 } else {\n-                    write!(f, \"use {}::*;\", self.source.print())\n+                    write!(f, \"use {}::*;\", self.source.print(cache))\n                 }\n             }\n         })\n     }\n }\n \n impl clean::ImportSource {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n         display_fn(move |f| match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false),\n+            Some(did) => resolved_path(f, did, &self.path, true, false, cache),\n             _ => {\n                 for seg in &self.path.segments[..self.path.segments.len() - 1] {\n                     write!(f, \"{}::\", seg.name)?;\n                 }\n                 let name = self.path.last_name();\n                 if let hir::def::Res::PrimTy(p) = self.path.res {\n-                    primitive_link(f, PrimitiveType::from(p), &*name)?;\n+                    primitive_link(f, PrimitiveType::from(p), &*name, cache)?;\n                 } else {\n                     write!(f, \"{}\", name)?;\n                 }\n@@ -1220,23 +1271,23 @@ impl clean::ImportSource {\n }\n \n impl clean::TypeBinding {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n         display_fn(move |f| {\n             f.write_str(&*self.name.as_str())?;\n             match self.kind {\n                 clean::TypeBindingKind::Equality { ref ty } => {\n                     if f.alternate() {\n-                        write!(f, \" = {:#}\", ty.print())?;\n+                        write!(f, \" = {:#}\", ty.print(cache))?;\n                     } else {\n-                        write!(f, \" = {}\", ty.print())?;\n+                        write!(f, \" = {}\", ty.print(cache))?;\n                     }\n                 }\n                 clean::TypeBindingKind::Constraint { ref bounds } => {\n                     if !bounds.is_empty() {\n                         if f.alternate() {\n-                            write!(f, \": {:#}\", print_generic_bounds(bounds))?;\n+                            write!(f, \": {:#}\", print_generic_bounds(bounds, cache))?;\n                         } else {\n-                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds))?;\n+                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cache))?;\n                         }\n                     }\n                 }\n@@ -1261,10 +1312,10 @@ crate fn print_default_space<'a>(v: bool) -> &'a str {\n }\n \n impl clean::GenericArg {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    crate fn print<'b, 'a: 'b>(&'a self, cache: &'b Cache) -> impl fmt::Display + 'b {\n         display_fn(move |f| match self {\n             clean::GenericArg::Lifetime(lt) => fmt::Display::fmt(&lt.print(), f),\n-            clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(), f),\n+            clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(cache), f),\n             clean::GenericArg::Const(ct) => fmt::Display::fmt(&ct.print(), f),\n         })\n     }"}, {"sha": "5c02be14181ed99bb525c0e171f1372cc8025f92", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -67,31 +67,31 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n \n-    let Cache { ref mut search_index, ref orphan_impl_items, ref paths, ref mut aliases, .. } =\n-        *cache;\n-\n     // Attach all orphan items to the type's definition if the type\n     // has since been learned.\n-    for &(did, ref item) in orphan_impl_items {\n-        if let Some(&(ref fqp, _)) = paths.get(&did) {\n-            search_index.push(IndexItem {\n+    for &(did, ref item) in &cache.orphan_impl_items {\n+        if let Some(&(ref fqp, _)) = cache.paths.get(&did) {\n+            cache.search_index.push(IndexItem {\n                 ty: item.type_(),\n                 name: item.name.unwrap().to_string(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n                 desc: item.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)),\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(&item),\n+                search_type: get_index_search_type(&item, None),\n             });\n             for alias in item.attrs.get_doc_aliases() {\n-                aliases\n+                cache\n+                    .aliases\n                     .entry(alias.to_lowercase())\n                     .or_insert(Vec::new())\n-                    .push(search_index.len() - 1);\n+                    .push(cache.search_index.len() - 1);\n             }\n         }\n     }\n \n+    let Cache { ref mut search_index, ref paths, ref mut aliases, .. } = *cache;\n+\n     // Reduce `DefId` in paths into smaller sequential numbers,\n     // and prune the paths that do not appear in the index.\n     let mut lastpath = String::new();\n@@ -164,7 +164,10 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     )\n }\n \n-crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+crate fn get_index_search_type(\n+    item: &clean::Item,\n+    cache: Option<&Cache>,\n+) -> Option<IndexItemFunctionType> {\n     let (all_types, ret_types) = match *item.kind {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n         clean::MethodItem(ref m, _) => (&m.all_types, &m.ret_types),\n@@ -174,25 +177,25 @@ crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionTy\n \n     let inputs = all_types\n         .iter()\n-        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty), *kind)))\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty, &cache), *kind)))\n         .filter(|a| a.ty.name.is_some())\n         .collect();\n     let output = ret_types\n         .iter()\n-        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty), *kind)))\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty, &cache), *kind)))\n         .filter(|a| a.ty.name.is_some())\n         .collect::<Vec<_>>();\n     let output = if output.is_empty() { None } else { Some(output) };\n \n     Some(IndexItemFunctionType { inputs, output })\n }\n \n-fn get_index_type(clean_type: &clean::Type) -> RenderType {\n+fn get_index_type(clean_type: &clean::Type, cache: &Option<&Cache>) -> RenderType {\n     RenderType {\n-        ty: clean_type.def_id(),\n+        ty: cache.map_or_else(|| clean_type.def_id(), |cache| clean_type.def_id_full(cache)),\n         idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n-        generics: get_generics(clean_type),\n+        generics: get_generics(clean_type, cache),\n     }\n }\n \n@@ -216,14 +219,14 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n     }\n }\n \n-fn get_generics(clean_type: &clean::Type) -> Option<Vec<Generic>> {\n+fn get_generics(clean_type: &clean::Type, cache: &Option<&Cache>) -> Option<Vec<Generic>> {\n     clean_type.generics().and_then(|types| {\n         let r = types\n             .iter()\n             .filter_map(|t| {\n                 get_index_type_name(t, false).map(|name| Generic {\n                     name: name.as_str().to_ascii_lowercase(),\n-                    defid: t.def_id(),\n+                    defid: cache.map_or_else(|| t.def_id(), |cache| t.def_id_full(cache)),\n                     idx: None,\n                 })\n             })"}, {"sha": "bb9a7be590e87f0d71750a28c453f619e0b743ff", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 282, "deletions": 273, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -69,7 +69,7 @@ use crate::clean::{self, AttributesExt, GetDefId, RenderedLink, SelfTy, TypeKind\n use crate::config::{RenderInfo, RenderOptions};\n use crate::docfs::{DocFS, PathError};\n use crate::error::Error;\n-use crate::formats::cache::{cache, Cache};\n+use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n use crate::html::escape::Escape;\n@@ -122,6 +122,7 @@ crate struct Context<'tcx> {\n     /// Storage for the errors produced while generating documentation so they\n     /// can be printed together at the end.\n     crate errors: Rc<Receiver<String>>,\n+    crate cache: Rc<Cache>,\n }\n \n crate struct SharedContext<'tcx> {\n@@ -392,7 +393,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         options: RenderOptions,\n         _render_info: RenderInfo,\n         edition: Edition,\n-        cache: &mut Cache,\n+        mut cache: Cache,\n         tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         // need to save a copy of the options for rendering the index page\n@@ -503,9 +504,8 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         krate = sources::render(&dst, &mut scx, krate)?;\n \n         // Build our search index\n-        let index = build_index(&krate, cache);\n+        let index = build_index(&krate, &mut cache);\n \n-        let cache = Arc::new(cache);\n         let mut cx = Context {\n             current: Vec::new(),\n             dst,\n@@ -515,21 +515,21 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             shared: Arc::new(scx),\n             all: Rc::new(RefCell::new(AllTypes::new())),\n             errors: Rc::new(receiver),\n+            cache: Rc::new(cache),\n         };\n \n         CURRENT_DEPTH.with(|s| s.set(0));\n \n         // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n         Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-        write_shared(&cx, &krate, index, &md_opts, &cache)?;\n+        write_shared(&cx, &krate, index, &md_opts)?;\n         Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n         Ok((cx, krate))\n     }\n \n     fn after_krate(\n         &mut self,\n         krate: &clean::Crate,\n-        cache: &Cache,\n         diag: &rustc_errors::Handler,\n     ) -> Result<(), Error> {\n         let final_file = self.dst.join(&*krate.name.as_str()).join(\"all.html\");\n@@ -551,7 +551,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             extra_scripts: &[],\n             static_extra_scripts: &[],\n         };\n-        let sidebar = if let Some(ref version) = cache.crate_version {\n+        let sidebar = if let Some(ref version) = self.cache.crate_version {\n             format!(\n                 \"<p class=\\\"location\\\">Crate {}</p>\\\n                      <div class=\\\"block version\\\">\\\n@@ -605,12 +605,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         }\n     }\n \n-    fn mod_item_in(\n-        &mut self,\n-        item: &clean::Item,\n-        item_name: &str,\n-        cache: &Cache,\n-    ) -> Result<(), Error> {\n+    fn mod_item_in(&mut self, item: &clean::Item, item_name: &str) -> Result<(), Error> {\n         // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n         // if they contain impls for public types. These modules can also\n         // contain items such as publicly re-exported structures.\n@@ -627,7 +622,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n \n         info!(\"Recursing into {}\", self.dst.display());\n \n-        let buf = self.render_item(item, false, cache);\n+        let buf = self.render_item(item, false);\n         // buf will be empty if the module is stripped and there is no redirect for it\n         if !buf.is_empty() {\n             self.shared.ensure_dir(&self.dst)?;\n@@ -658,7 +653,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         Ok(())\n     }\n \n-    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error> {\n+    fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n         // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n         // if they contain impls for public types. These modules can also\n         // contain items such as publicly re-exported structures.\n@@ -670,7 +665,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             self.render_redirect_pages = item.is_stripped();\n         }\n \n-        let buf = self.render_item(&item, true, cache);\n+        let buf = self.render_item(&item, true);\n         // buf will be empty if the item is stripped and there is no redirect for it\n         if !buf.is_empty() {\n             let name = item.name.as_ref().unwrap();\n@@ -694,14 +689,17 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         }\n         Ok(())\n     }\n+\n+    fn cache(&self) -> &Cache {\n+        &self.cache\n+    }\n }\n \n fn write_shared(\n     cx: &Context<'_>,\n     krate: &clean::Crate,\n     search_index: String,\n     options: &RenderOptions,\n-    cache: &Cache,\n ) -> Result<(), Error> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n@@ -1107,17 +1105,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cache.implementors {\n+    for (&did, imps) in &cx.cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n         // indexed, so we just skip this step in that case.\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n+        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n             Some(p) => p,\n-            None => match cache.external_paths.get(&did) {\n+            None => match cx.cache.external_paths.get(&did) {\n                 Some(p) => p,\n                 None => continue,\n             },\n@@ -1144,9 +1142,9 @@ themePicker.onblur = handleThemeButtonsBlur;\n                     None\n                 } else {\n                     Some(Implementor {\n-                        text: imp.inner_impl().print().to_string(),\n+                        text: imp.inner_impl().print(cx.cache()).to_string(),\n                         synthetic: imp.inner_impl().synthetic,\n-                        types: collect_paths_for_type(imp.inner_impl().for_.clone()),\n+                        types: collect_paths_for_type(imp.inner_impl().for_.clone(), cx.cache()),\n                     })\n                 }\n             })\n@@ -1155,7 +1153,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if implementors.is_empty() && !cache.paths.contains_key(&did) {\n+        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n             continue;\n         }\n \n@@ -1214,8 +1212,8 @@ fn write_minify(\n     }\n }\n \n-fn write_srclink(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n-    if let Some(l) = cx.src_href(item, cache) {\n+fn write_srclink(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n+    if let Some(l) = cx.src_href(item) {\n         write!(\n             buf,\n             \"<a class=\\\"srclink\\\" href=\\\"{}\\\" title=\\\"{}\\\">[src]</a>\",\n@@ -1537,7 +1535,7 @@ impl Context<'_> {\n         \"../\".repeat(self.current.len())\n     }\n \n-    fn render_item(&self, it: &clean::Item, pushname: bool, cache: &Cache) -> String {\n+    fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n         // A little unfortunate that this is done like this, but it sure\n         // does make formatting *a lot* nicer.\n         CURRENT_DEPTH.with(|slot| {\n@@ -1590,13 +1588,13 @@ impl Context<'_> {\n             layout::render(\n                 &self.shared.layout,\n                 &page,\n-                |buf: &mut _| print_sidebar(self, it, buf, cache),\n-                |buf: &mut _| print_item(self, it, buf, cache),\n+                |buf: &mut _| print_sidebar(self, it, buf),\n+                |buf: &mut _| print_item(self, it, buf),\n                 &self.shared.style_files,\n             )\n         } else {\n             let mut url = self.root_path();\n-            if let Some(&(ref names, ty)) = cache.paths.get(&it.def_id) {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n                 for name in &names[..names.len() - 1] {\n                     url.push_str(name);\n                     url.push('/');\n@@ -1647,7 +1645,7 @@ impl Context<'_> {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn src_href(&self, item: &clean::Item, cache: &Cache) -> Option<String> {\n+    fn src_href(&self, item: &clean::Item) -> Option<String> {\n         let mut root = self.root_path();\n         let mut path = String::new();\n         let cnum = item.source.cnum(self.sess());\n@@ -1667,7 +1665,7 @@ impl Context<'_> {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *cache.extern_locations.get(&cnum)? {\n+            let (krate, src_root) = match *self.cache.extern_locations.get(&cnum)? {\n                 (name, ref src, ExternalLocation::Local) => (name, src),\n                 (name, ref src, ExternalLocation::Remote(ref s)) => {\n                     root = s.to_string();\n@@ -1710,7 +1708,7 @@ where\n     write!(w, \"</div>\")\n }\n \n-fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n+fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n     debug_assert!(!item.is_stripped());\n     // Write the breadcrumb trail header for the top\n     write!(buf, \"<h1 class=\\\"fqn\\\"><span class=\\\"out-of-band\\\">\");\n@@ -1738,7 +1736,7 @@ fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, cache: &Ca\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n     if cx.shared.include_sources && !item.is_primitive() {\n-        write_srclink(cx, item, buf, cache);\n+        write_srclink(cx, item, buf);\n     }\n \n     write!(buf, \"</span>\"); // out-of-band\n@@ -1797,20 +1795,20 @@ fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, cache: &Ca\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n         }\n-        clean::TraitItem(ref t) => item_trait(buf, cx, item, t, cache),\n-        clean::StructItem(ref s) => item_struct(buf, cx, item, s, cache),\n-        clean::UnionItem(ref s) => item_union(buf, cx, item, s, cache),\n-        clean::EnumItem(ref e) => item_enum(buf, cx, item, e, cache),\n-        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t, cache),\n+        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n+        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n+        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n+        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n+        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n         clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n         clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n-        clean::PrimitiveItem(_) => item_primitive(buf, cx, item, cache),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n         clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n-        clean::ForeignTypeItem => item_foreign_type(buf, cx, item, cache),\n+        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n         clean::KeywordItem(_) => item_keyword(buf, cx, item),\n-        clean::OpaqueTyItem(ref e) => item_opaque_ty(buf, cx, item, e, cache),\n-        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta, cache),\n+        clean::OpaqueTyItem(ref e) => item_opaque_ty(buf, cx, item, e),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n         _ => {\n             // We don't generate pages for any other type.\n             unreachable!();\n@@ -1884,10 +1882,11 @@ fn document_short(\n         return;\n     }\n     if let Some(s) = item.doc_value() {\n-        let mut summary_html = MarkdownSummaryLine(&s, &item.links()).into_string();\n+        let mut summary_html = MarkdownSummaryLine(&s, &item.links(&cx.cache)).into_string();\n \n         if s.contains('\\n') {\n-            let link = format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link));\n+            let link =\n+                format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link, cx.cache()));\n \n             if let Some(idx) = summary_html.rfind(\"</p>\") {\n                 summary_html.insert_str(idx, &link);\n@@ -1922,7 +1921,7 @@ fn document_full(\n ) {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        render_markdown(w, cx, &*s, item.links(), prefix, is_hidden);\n+        render_markdown(w, cx, &*s, item.links(&cx.cache), prefix, is_hidden);\n     } else if !prefix.is_empty() {\n         write!(\n             w,\n@@ -2161,15 +2160,15 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     Some(ref src) => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {} as {};\",\n-                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n-                        anchor(myitem.def_id, &*src.as_str()),\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                        anchor(myitem.def_id, &*src.as_str(), cx.cache()),\n                         name\n                     ),\n                     None => write!(\n                         w,\n                         \"<tr><td><code>{}extern crate {};\",\n-                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n-                        anchor(myitem.def_id, &*name.as_str())\n+                        myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                        anchor(myitem.def_id, &*name.as_str(), cx.cache())\n                     ),\n                 }\n                 write!(w, \"</code></td></tr>\");\n@@ -2179,8 +2178,8 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 write!(\n                     w,\n                     \"<tr><td><code>{}{}</code></td></tr>\",\n-                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id),\n-                    import.print()\n+                    myitem.visibility.print_with_space(cx.tcx(), myitem.def_id, cx.cache()),\n+                    import.print(cx.cache())\n                 );\n             }\n \n@@ -2211,7 +2210,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                      </tr>\",\n                     name = *myitem.name.as_ref().unwrap(),\n                     stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n-                    docs = MarkdownSummaryLine(&doc_value, &myitem.links()).into_string(),\n+                    docs = MarkdownSummaryLine(&doc_value, &myitem.links(&cx.cache)).into_string(),\n                     class = myitem.type_(),\n                     add = add,\n                     stab = stab.unwrap_or_else(String::new),\n@@ -2396,9 +2395,9 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n     write!(\n         w,\n         \"{vis}const {name}: {typ}\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         name = it.name.as_ref().unwrap(),\n-        typ = c.type_.print(),\n+        typ = c.type_.print(cx.cache()),\n     );\n \n     if c.value.is_some() || c.is_literal {\n@@ -2430,24 +2429,24 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n     write!(\n         w,\n         \"{vis}static {mutability}{name}: {typ}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         mutability = s.mutability.print_with_space(),\n         name = it.name.as_ref().unwrap(),\n-        typ = s.type_.print()\n+        typ = s.type_.print(cx.cache())\n     );\n     document(w, cx, it, None)\n }\n \n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         f.header.constness.print_with_space(),\n         f.header.asyncness.print_with_space(),\n         f.header.unsafety.print_with_space(),\n         print_abi_with_space(f.header.abi),\n         it.name.as_ref().unwrap(),\n-        f.generics.print()\n+        f.generics.print(cx.cache())\n     )\n     .len();\n     write!(w, \"<pre class=\\\"rust fn\\\">\");\n@@ -2456,17 +2455,18 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n         w,\n         \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n          {name}{generics}{decl}{spotlight}{where_clause}</pre>\",\n-        vis = it.visibility.print_with_space(cx.tcx(), it.def_id),\n+        vis = it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         constness = f.header.constness.print_with_space(),\n         asyncness = f.header.asyncness.print_with_space(),\n         unsafety = f.header.unsafety.print_with_space(),\n         abi = print_abi_with_space(f.header.abi),\n         name = it.name.as_ref().unwrap(),\n-        generics = f.generics.print(),\n-        where_clause = WhereClause { gens: &f.generics, indent: 0, end_newline: true },\n+        generics = f.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &f.generics, indent: 0, end_newline: true }.print(cx.cache()),\n         decl = Function { decl: &f.decl, header_len, indent: 0, asyncness: f.header.asyncness }\n-            .print(),\n-        spotlight = spotlight_decl(&f.decl),\n+            .print(cx.cache()),\n+        spotlight = spotlight_decl(&f.decl, cx.cache()),\n     );\n     document(w, cx, it, None)\n }\n@@ -2478,7 +2478,6 @@ fn render_implementor(\n     w: &mut Buffer,\n     implementor_dups: &FxHashMap<Symbol, (DefId, bool)>,\n     aliases: &[String],\n-    cache: &Cache,\n ) {\n     // If there's already another implementor that has the same abbridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n@@ -2504,7 +2503,6 @@ fn render_implementor(\n         false,\n         false,\n         aliases,\n-        cache,\n     );\n }\n \n@@ -2513,12 +2511,11 @@ fn render_impls(\n     w: &mut Buffer,\n     traits: &[&&Impl],\n     containing_item: &clean::Item,\n-    cache: &Cache,\n ) {\n     let mut impls = traits\n         .iter()\n         .map(|i| {\n-            let did = i.trait_did().unwrap();\n+            let did = i.trait_did_full(cx.cache()).unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n             let mut buffer = if w.is_for_html() { Buffer::html() } else { Buffer::new() };\n             render_impl(\n@@ -2535,7 +2532,6 @@ fn render_impls(\n                 false,\n                 true,\n                 &[],\n-                cache,\n             );\n             buffer.into_inner()\n         })\n@@ -2544,7 +2540,7 @@ fn render_impls(\n     w.write_str(&impls.join(\"\"));\n }\n \n-fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool) -> String {\n+fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool, cache: &Cache) -> String {\n     let mut bounds = String::new();\n     if !t_bounds.is_empty() {\n         if !trait_alias {\n@@ -2554,22 +2550,22 @@ fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool) -> String {\n             if i > 0 {\n                 bounds.push_str(\" + \");\n             }\n-            bounds.push_str(&p.print().to_string());\n+            bounds.push_str(&p.print(cache).to_string());\n         }\n     }\n     bounds\n }\n \n-fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n-    let lhs = format!(\"{}\", lhs.inner_impl().print());\n-    let rhs = format!(\"{}\", rhs.inner_impl().print());\n+fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl, cache: &Cache) -> Ordering {\n+    let lhs = format!(\"{}\", lhs.inner_impl().print(cache));\n+    let rhs = format!(\"{}\", rhs.inner_impl().print(cache));\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n     compare_names(&lhs, &rhs)\n }\n \n-fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait, cache: &Cache) {\n-    let bounds = bounds(&t.bounds, false);\n+fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n+    let bounds = bounds(&t.bounds, false, cx.cache());\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n     let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n@@ -2582,16 +2578,17 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(\n             w,\n             \"{}{}{}trait {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx(), it.def_id),\n+            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n             t.unsafety.print_with_space(),\n             if t.is_auto { \"auto \" } else { \"\" },\n             it.name.as_ref().unwrap(),\n-            t.generics.print(),\n+            t.generics.print(cx.cache()),\n             bounds\n         );\n \n         if !t.generics.where_predicates.is_empty() {\n-            write!(w, \"{}\", WhereClause { gens: &t.generics, indent: 0, end_newline: true });\n+            let where_ = WhereClause { gens: &t.generics, indent: 0, end_newline: true };\n+            write!(w, \"{}\", where_.print(cx.cache()));\n         } else {\n             write!(w, \" \");\n         }\n@@ -2664,13 +2661,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         write!(w, \"{}<span class=\\\"loading-content\\\">Loading content...</span>\", extra_content)\n     }\n \n-    fn trait_item(\n-        w: &mut Buffer,\n-        cx: &Context<'_>,\n-        m: &clean::Item,\n-        t: &clean::Item,\n-        cache: &Cache,\n-    ) {\n+    fn trait_item(w: &mut Buffer, cx: &Context<'_>, m: &clean::Item, t: &clean::Item) {\n         let name = m.name.as_ref().unwrap();\n         info!(\"Documenting {} on {:?}\", name, t.name);\n         let item_type = m.type_();\n@@ -2679,7 +2670,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl, cx);\n         write!(w, \"</code>\");\n         render_stability_since(w, m, t, cx.tcx());\n-        write_srclink(cx, m, w, cache);\n+        write_srclink(cx, m, w);\n         write!(w, \"</h3>\");\n         document(w, cx, m, Some(t));\n     }\n@@ -2692,7 +2683,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             \"<div class=\\\"methods\\\">\",\n         );\n         for t in types {\n-            trait_item(w, cx, t, it, cache);\n+            trait_item(w, cx, t, it);\n         }\n         write_loading_content(w, \"</div>\");\n     }\n@@ -2705,7 +2696,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             \"<div class=\\\"methods\\\">\",\n         );\n         for t in consts {\n-            trait_item(w, cx, t, it, cache);\n+            trait_item(w, cx, t, it);\n         }\n         write_loading_content(w, \"</div>\");\n     }\n@@ -2719,7 +2710,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             \"<div class=\\\"methods\\\">\",\n         );\n         for m in required {\n-            trait_item(w, cx, m, it, cache);\n+            trait_item(w, cx, m, it);\n         }\n         write_loading_content(w, \"</div>\");\n     }\n@@ -2731,15 +2722,15 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             \"<div class=\\\"methods\\\">\",\n         );\n         for m in provided {\n-            trait_item(w, cx, m, it, cache);\n+            trait_item(w, cx, m, it);\n         }\n         write_loading_content(w, \"</div>\");\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache);\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n \n-    if let Some(implementors) = cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n@@ -2761,14 +2752,17 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         }\n \n         let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl().for_.def_id().map_or(true, |d| cache.paths.contains_key(&d))\n+            i.inner_impl()\n+                .for_\n+                .def_id_full(cx.cache())\n+                .map_or(true, |d| cx.cache.paths.contains_key(&d))\n         });\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             local.iter().partition(|i| i.inner_impl().synthetic);\n \n-        synthetic.sort_by(compare_impl);\n-        concrete.sort_by(compare_impl);\n+        synthetic.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n+        concrete.sort_by(|a, b| compare_impl(a, b, cx.cache()));\n \n         if !foreign.is_empty() {\n             write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n@@ -2792,7 +2786,6 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                     true,\n                     false,\n                     &[],\n-                    cache,\n                 );\n             }\n             write_loading_content(w, \"\");\n@@ -2805,7 +2798,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             \"<div class=\\\"item-list\\\" id=\\\"implementors-list\\\">\",\n         );\n         for implementor in concrete {\n-            render_implementor(cx, implementor, it, w, &implementor_dups, &[], cache);\n+            render_implementor(cx, implementor, it, w, &implementor_dups, &[]);\n         }\n         write_loading_content(w, \"</div>\");\n \n@@ -2823,8 +2816,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                     it,\n                     w,\n                     &implementor_dups,\n-                    &collect_paths_for_type(implementor.inner_impl().for_.clone()),\n-                    cache,\n+                    &collect_paths_for_type(implementor.inner_impl().for_.clone(), &cx.cache),\n                 );\n             }\n             write_loading_content(w, \"</div>\");\n@@ -2860,15 +2852,15 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n         } else {\n-            let (ref path, _) = cache.external_paths[&it.def_id];\n+            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n             path[..path.len() - 1].join(\"/\")\n         },\n         ty = it.type_(),\n         name = *it.name.as_ref().unwrap()\n     );\n }\n \n-fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n+fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cache: &Cache) -> String {\n     use crate::formats::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n@@ -2882,7 +2874,7 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n         AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n         AssocItemLink::Anchor(None) => anchor,\n         AssocItemLink::GotoSource(did, _) => {\n-            href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            href(did, cache).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n         }\n     }\n }\n@@ -2900,10 +2892,10 @@ fn assoc_const(\n         w,\n         \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\"><b>{}</b></a>: {}\",\n         extra,\n-        it.visibility.print_with_space(cx.tcx(), it.def_id),\n-        naive_assoc_href(it, link),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n+        naive_assoc_href(it, link, cx.cache()),\n         it.name.as_ref().unwrap(),\n-        ty.print()\n+        ty.print(cx.cache())\n     );\n }\n \n@@ -2914,19 +2906,20 @@ fn assoc_type(\n     default: Option<&clean::Type>,\n     link: AssocItemLink<'_>,\n     extra: &str,\n+    cache: &Cache,\n ) {\n     write!(\n         w,\n         \"{}type <a href=\\\"{}\\\" class=\\\"type\\\">{}</a>\",\n         extra,\n-        naive_assoc_href(it, link),\n+        naive_assoc_href(it, link, cache),\n         it.name.as_ref().unwrap()\n     );\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", print_generic_bounds(bounds))\n+        write!(w, \": {}\", print_generic_bounds(bounds, cache))\n     }\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default.print())\n+        write!(w, \" = {}\", default.print(cache))\n     }\n }\n \n@@ -3005,19 +2998,19 @@ fn render_assoc_item(\n                     ItemType::TyMethod\n                 };\n \n-                href(did).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n+                href(did, cx.cache()).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n             }\n         };\n         let mut header_len = format!(\n             \"{}{}{}{}{}{:#}fn {}{:#}\",\n-            meth.visibility.print_with_space(cx.tcx(), meth.def_id),\n+            meth.visibility.print_with_space(cx.tcx(), meth.def_id, cx.cache()),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n             print_default_space(meth.is_default()),\n             print_abi_with_space(header.abi),\n             name,\n-            g.print()\n+            g.print(cx.cache())\n         )\n         .len();\n         let (indent, end_newline) = if parent == ItemType::Trait {\n@@ -3032,18 +3025,19 @@ fn render_assoc_item(\n             \"{}{}{}{}{}{}{}fn <a href=\\\"{href}\\\" class=\\\"fnname\\\">{name}</a>\\\n              {generics}{decl}{spotlight}{where_clause}\",\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n-            meth.visibility.print_with_space(cx.tcx(), meth.def_id),\n+            meth.visibility.print_with_space(cx.tcx(), meth.def_id, cx.cache()),\n             header.constness.print_with_space(),\n             header.asyncness.print_with_space(),\n             header.unsafety.print_with_space(),\n             print_default_space(meth.is_default()),\n             print_abi_with_space(header.abi),\n             href = href,\n             name = name,\n-            generics = g.print(),\n-            decl = Function { decl: d, header_len, indent, asyncness: header.asyncness }.print(),\n-            spotlight = spotlight_decl(&d),\n-            where_clause = WhereClause { gens: g, indent, end_newline }\n+            generics = g.print(cx.cache()),\n+            decl = Function { decl: d, header_len, indent, asyncness: header.asyncness }\n+                .print(cx.cache()),\n+            spotlight = spotlight_decl(&d, cx.cache()),\n+            where_clause = WhereClause { gens: g, indent, end_newline }.print(cx.cache())\n         )\n     }\n     match *item.kind {\n@@ -3070,18 +3064,13 @@ fn render_assoc_item(\n             default.as_ref(),\n             link,\n             if parent == ItemType::Trait { \"    \" } else { \"\" },\n+            cx.cache(),\n         ),\n         _ => panic!(\"render_assoc_item called on non-associated-item\"),\n     }\n }\n \n-fn item_struct(\n-    w: &mut Buffer,\n-    cx: &Context<'_>,\n-    it: &clean::Item,\n-    s: &clean::Struct,\n-    cache: &Cache,\n-) {\n+fn item_struct(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Struct) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust struct\\\">\");\n         render_attributes(w, it, true);\n@@ -3122,16 +3111,16 @@ fn item_struct(\n                     item_type = ItemType::StructField,\n                     id = id,\n                     name = field.name.as_ref().unwrap(),\n-                    ty = ty.print()\n+                    ty = ty.print(cx.cache())\n                 );\n                 document(w, cx, field, Some(it));\n             }\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union, cache: &Cache) {\n+fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Union) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust union\\\">\");\n         render_attributes(w, it, true);\n@@ -3166,28 +3155,28 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n                 id = id,\n                 name = name,\n                 shortty = ItemType::StructField,\n-                ty = ty.print()\n+                ty = ty.print(cx.cache())\n             );\n             if let Some(stability_class) = field.stability_class(cx.tcx()) {\n                 write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n             }\n             document(w, cx, field, Some(it));\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum, cache: &Cache) {\n+fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class=\\\"rust enum\\\">\");\n         render_attributes(w, it, true);\n         write!(\n             w,\n             \"{}enum {}{}{}\",\n-            it.visibility.print_with_space(cx.tcx(), it.def_id),\n+            it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n             it.name.as_ref().unwrap(),\n-            e.generics.print(),\n-            WhereClause { gens: &e.generics, indent: 0, end_newline: true }\n+            e.generics.print(cx.cache()),\n+            WhereClause { gens: &e.generics, indent: 0, end_newline: true }.print(cx.cache())\n         );\n         if e.variants.is_empty() && !e.variants_stripped {\n             write!(w, \" {{}}\");\n@@ -3205,7 +3194,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                                 if i > 0 {\n                                     write!(w, \",&nbsp;\")\n                                 }\n-                                write!(w, \"{}\", ty.print());\n+                                write!(w, \"{}\", ty.print(cx.cache()));\n                             }\n                             write!(w, \")\");\n                         }\n@@ -3252,7 +3241,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                     if i > 0 {\n                         write!(w, \",&nbsp;\");\n                     }\n-                    write!(w, \"{}\", ty.print());\n+                    write!(w, \"{}\", ty.print(cx.cache()));\n                 }\n                 write!(w, \")\");\n             }\n@@ -3289,7 +3278,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                              </span>\",\n                             id = id,\n                             f = field.name.as_ref().unwrap(),\n-                            t = ty.print()\n+                            t = ty.print(cx.cache())\n                         );\n                         document(w, cx, field, Some(variant));\n                     }\n@@ -3299,7 +3288,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             render_stability_since(w, variant, it, cx.tcx());\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n const ALLOWED_ATTRIBUTES: &[Symbol] = &[\n@@ -3357,17 +3346,21 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n     if let Some(g) = g {\n-        write!(w, \"{}\", g.print())\n+        write!(w, \"{}\", g.print(cx.cache()))\n     }\n     match ty {\n         CtorKind::Fictive => {\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache())\n+                )\n             }\n             let mut has_visible_fields = false;\n             write!(w, \" {{\");\n@@ -3377,9 +3370,9 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility.print_with_space(cx.tcx(), field.def_id),\n+                        field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n                         field.name.as_ref().unwrap(),\n-                        ty.print()\n+                        ty.print(cx.cache())\n                     );\n                     has_visible_fields = true;\n                 }\n@@ -3409,23 +3402,31 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility.print_with_space(cx.tcx(), field.def_id),\n-                            ty.print()\n+                            field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n+                            ty.print(cx.cache())\n                         )\n                     }\n                     _ => unreachable!(),\n                 }\n             }\n             write!(w, \")\");\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n+                )\n             }\n             write!(w, \";\");\n         }\n         CtorKind::Const => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })\n+                write!(\n+                    w,\n+                    \"{}\",\n+                    WhereClause { gens: g, indent: 0, end_newline: false }.print(cx.cache())\n+                )\n             }\n             write!(w, \";\");\n         }\n@@ -3444,13 +3445,13 @@ fn render_union(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         if structhead { \"union \" } else { \"\" },\n         it.name.as_ref().unwrap()\n     );\n     if let Some(g) = g {\n-        write!(w, \"{}\", g.print());\n-        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true });\n+        write!(w, \"{}\", g.print(cx.cache()));\n+        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true }.print(cx.cache()));\n     }\n \n     write!(w, \" {{\\n{}\", tab);\n@@ -3459,9 +3460,9 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility.print_with_space(cx.tcx(), field.def_id),\n+                field.visibility.print_with_space(cx.tcx(), field.def_id, cx.cache()),\n                 field.name.as_ref().unwrap(),\n-                ty.print(),\n+                ty.print(cx.cache()),\n                 tab\n             );\n         }\n@@ -3494,10 +3495,9 @@ fn render_assoc_items(\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n-    cache: &Cache,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n-    let v = match cache.impls.get(&it) {\n+    let v = match cx.cache.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n     };\n@@ -3514,18 +3514,22 @@ fn render_assoc_items(\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n-                let id =\n-                    cx.derive_id(small_url_encode(&format!(\"deref-methods-{:#}\", type_.print())));\n-                cx.deref_id_map.borrow_mut().insert(type_.def_id().unwrap(), id.clone());\n+                let id = cx.derive_id(small_url_encode(&format!(\n+                    \"deref-methods-{:#}\",\n+                    type_.print(cx.cache())\n+                )));\n+                cx.deref_id_map\n+                    .borrow_mut()\n+                    .insert(type_.def_id_full(cx.cache()).unwrap(), id.clone());\n                 write!(\n                     w,\n                     \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n                          Methods from {trait_}&lt;Target = {type_}&gt;\\\n                          <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n                     id = id,\n-                    trait_ = trait_.print(),\n-                    type_ = type_.print(),\n+                    trait_ = trait_.print(cx.cache()),\n+                    type_ = type_.print(cx.cache()),\n                 );\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n@@ -3545,17 +3549,18 @@ fn render_assoc_items(\n                 false,\n                 true,\n                 &[],\n-                cache,\n             );\n         }\n     }\n     if !traits.is_empty() {\n-        let deref_impl =\n-            traits.iter().find(|t| t.inner_impl().trait_.def_id() == cache.deref_trait_did);\n+        let deref_impl = traits\n+            .iter()\n+            .find(|t| t.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_trait_did);\n         if let Some(impl_) = deref_impl {\n-            let has_deref_mut =\n-                traits.iter().any(|t| t.inner_impl().trait_.def_id() == cache.deref_mut_trait_did);\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, cache);\n+            let has_deref_mut = traits.iter().any(|t| {\n+                t.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_mut_trait_did\n+            });\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n \n         // If we were already one level into rendering deref methods, we don't want to render\n@@ -3570,7 +3575,7 @@ fn render_assoc_items(\n             concrete.into_iter().partition(|t| t.inner_impl().blanket_impl.is_some());\n \n         let mut impls = Buffer::empty_from(&w);\n-        render_impls(cx, &mut impls, &concrete, containing_item, cache);\n+        render_impls(cx, &mut impls, &concrete, containing_item);\n         let impls = impls.into_inner();\n         if !impls.is_empty() {\n             write!(\n@@ -3592,7 +3597,7 @@ fn render_assoc_items(\n                  </h2>\\\n                  <div id=\\\"synthetic-implementations-list\\\">\"\n             );\n-            render_impls(cx, w, &synthetic, containing_item, cache);\n+            render_impls(cx, w, &synthetic, containing_item);\n             write!(w, \"</div>\");\n         }\n \n@@ -3605,7 +3610,7 @@ fn render_assoc_items(\n                  </h2>\\\n                  <div id=\\\"blanket-implementations-list\\\">\"\n             );\n-            render_impls(cx, w, &blanket_impl, containing_item, cache);\n+            render_impls(cx, w, &blanket_impl, containing_item);\n             write!(w, \"</div>\");\n         }\n     }\n@@ -3617,7 +3622,6 @@ fn render_deref_methods(\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n-    cache: &Cache,\n ) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let (target, real_target) = impl_\n@@ -3634,25 +3638,25 @@ fn render_deref_methods(\n         .expect(\"Expected associated type binding\");\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n-    if let Some(did) = target.def_id() {\n-        if let Some(type_did) = impl_.inner_impl().for_.def_id() {\n+    if let Some(did) = target.def_id_full(cx.cache()) {\n+        if let Some(type_did) = impl_.inner_impl().for_.def_id_full(cx.cache()) {\n             // `impl Deref<Target = S> for S`\n             if did == type_did {\n                 // Avoid infinite cycles\n                 return;\n             }\n         }\n-        render_assoc_items(w, cx, container_item, did, what, cache);\n+        render_assoc_items(w, cx, container_item, did, what);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(&did) = cache.primitive_locations.get(&prim) {\n-                render_assoc_items(w, cx, container_item, did, what, cache);\n+            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n+                render_assoc_items(w, cx, container_item, did, what);\n             }\n         }\n     }\n }\n \n-fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n+fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bool {\n     let self_type_opt = match *item.kind {\n         clean::MethodItem(ref method, _) => method.decl.self_type(),\n         clean::TyMethodItem(ref method) => method.decl.self_type(),\n@@ -3666,7 +3670,7 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n                 (mutability == Mutability::Mut, false, false)\n             }\n             SelfTy::SelfExplicit(clean::ResolvedPath { did, .. }) => {\n-                (false, Some(did) == cache().owned_box_did, false)\n+                (false, Some(did) == cache.owned_box_did, false)\n             }\n             SelfTy::SelfValue => (false, false, true),\n             _ => (false, false, false),\n@@ -3678,31 +3682,31 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n     }\n }\n \n-fn spotlight_decl(decl: &clean::FnDecl) -> String {\n+fn spotlight_decl(decl: &clean::FnDecl, cache: &Cache) -> String {\n     let mut out = Buffer::html();\n     let mut trait_ = String::new();\n \n-    if let Some(did) = decl.output.def_id() {\n-        let c = cache();\n-        if let Some(impls) = c.impls.get(&did) {\n+    if let Some(did) = decl.output.def_id_full(cache) {\n+        if let Some(impls) = cache.impls.get(&did) {\n             for i in impls {\n                 let impl_ = i.inner_impl();\n-                if impl_.trait_.def_id().map_or(false, |d| c.traits[&d].is_spotlight) {\n+                if impl_.trait_.def_id_full(cache).map_or(false, |d| cache.traits[&d].is_spotlight)\n+                {\n                     if out.is_empty() {\n                         out.push_str(&format!(\n                             \"<h3 class=\\\"notable\\\">Notable traits for {}</h3>\\\n                              <code class=\\\"content\\\">\",\n-                            impl_.for_.print()\n+                            impl_.for_.print(cache)\n                         ));\n-                        trait_.push_str(&impl_.for_.print().to_string());\n+                        trait_.push_str(&impl_.for_.print(cache).to_string());\n                     }\n \n                     //use the \"where\" class here to make it small\n                     out.push_str(&format!(\n                         \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n-                        impl_.print()\n+                        impl_.print(cache)\n                     ));\n-                    let t_did = impl_.trait_.def_id().unwrap();\n+                    let t_did = impl_.trait_.def_id_full(cache).unwrap();\n                     for it in &impl_.items {\n                         if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                             out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n@@ -3713,6 +3717,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n                                 Some(&tydef.type_),\n                                 AssocItemLink::GotoSource(t_did, &FxHashSet::default()),\n                                 \"\",\n+                                cache,\n                             );\n                             out.push_str(\";</span>\");\n                         }\n@@ -3750,18 +3755,17 @@ fn render_impl(\n     // This argument is used to reference same type with different paths to avoid duplication\n     // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n     aliases: &[String],\n-    cache: &Cache,\n ) {\n-    let traits = &cache.traits;\n-    let trait_ = i.trait_did().map(|did| &traits[&did]);\n+    let traits = &cx.cache.traits;\n+    let trait_ = i.trait_did_full(cx.cache()).map(|did| &traits[&did]);\n \n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => {\n                 if is_on_foreign_type {\n-                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t)\n+                    get_id_for_impl_on_foreign_type(&i.inner_impl().for_, t, cx.cache())\n                 } else {\n-                    format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t.print())))\n+                    format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t.print(cx.cache()))))\n                 }\n             }\n             None => \"impl\".to_string(),\n@@ -3773,12 +3777,20 @@ fn render_impl(\n         };\n         if let Some(use_absolute) = use_absolute {\n             write!(w, \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">\", id, aliases);\n-            fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute);\n+            fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute, cx.cache());\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n                     if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                         write!(w, \"<span class=\\\"where fmt-newline\\\">  \");\n-                        assoc_type(w, it, &[], Some(&tydef.type_), AssocItemLink::Anchor(None), \"\");\n+                        assoc_type(\n+                            w,\n+                            it,\n+                            &[],\n+                            Some(&tydef.type_),\n+                            AssocItemLink::Anchor(None),\n+                            \"\",\n+                            cx.cache(),\n+                        );\n                         write!(w, \";</span>\");\n                     }\n                 }\n@@ -3790,7 +3802,7 @@ fn render_impl(\n                 \"<h3 id=\\\"{}\\\" class=\\\"impl\\\"{}><code class=\\\"in-band\\\">{}</code>\",\n                 id,\n                 aliases,\n-                i.inner_impl().print()\n+                i.inner_impl().print(cx.cache())\n             );\n         }\n         write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n@@ -3801,7 +3813,7 @@ fn render_impl(\n             outer_version,\n             outer_const_version,\n         );\n-        write_srclink(cx, &i.impl_item, w, cache);\n+        write_srclink(cx, &i.impl_item, w);\n         write!(w, \"</h3>\");\n \n         if trait_.is_some() {\n@@ -3817,7 +3829,7 @@ fn render_impl(\n                 \"<div class=\\\"docblock\\\">{}</div>\",\n                 Markdown(\n                     &*dox,\n-                    &i.impl_item.links(),\n+                    &i.impl_item.links(&cx.cache),\n                     &mut ids,\n                     cx.shared.codes,\n                     cx.shared.edition,\n@@ -3840,14 +3852,15 @@ fn render_impl(\n         outer_const_version: Option<&str>,\n         trait_: Option<&clean::Trait>,\n         show_def_docs: bool,\n-        cache: &Cache,\n     ) {\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n \n         let render_method_item = match render_mode {\n             RenderMode::Normal => true,\n-            RenderMode::ForDeref { mut_: deref_mut_ } => should_render_item(&item, deref_mut_),\n+            RenderMode::ForDeref { mut_: deref_mut_ } => {\n+                should_render_item(&item, deref_mut_, &cx.cache)\n+            }\n         };\n \n         let (is_hidden, extra_class) =\n@@ -3874,14 +3887,22 @@ fn render_impl(\n                         outer_version,\n                         outer_const_version,\n                     );\n-                    write_srclink(cx, item, w, cache);\n+                    write_srclink(cx, item, w);\n                     write!(w, \"</h4>\");\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", ItemType::AssocType, name));\n                 write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\"><code>\", id, item_type, extra_class);\n-                assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id), \"\");\n+                assoc_type(\n+                    w,\n+                    item,\n+                    &Vec::new(),\n+                    Some(&tydef.type_),\n+                    link.anchor(&id),\n+                    \"\",\n+                    cx.cache(),\n+                );\n                 write!(w, \"</code></h4>\");\n             }\n             clean::AssocConstItem(ref ty, ref default) => {\n@@ -3896,13 +3917,13 @@ fn render_impl(\n                     outer_version,\n                     outer_const_version,\n                 );\n-                write_srclink(cx, item, w, cache);\n+                write_srclink(cx, item, w);\n                 write!(w, \"</h4>\");\n             }\n             clean::AssocTypeItem(ref bounds, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 write!(w, \"<h4 id=\\\"{}\\\" class=\\\"{}{}\\\"><code>\", id, item_type, extra_class);\n-                assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id), \"\");\n+                assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id), \"\", cx.cache());\n                 write!(w, \"</code></h4>\");\n             }\n             clean::StrippedItem(..) => return,\n@@ -3961,7 +3982,6 @@ fn render_impl(\n             outer_const_version,\n             trait_,\n             show_def_docs,\n-            cache,\n         );\n     }\n \n@@ -3975,14 +3995,13 @@ fn render_impl(\n         outer_version: Option<&str>,\n         outer_const_version: Option<&str>,\n         show_def_docs: bool,\n-        cache: &Cache,\n     ) {\n         for trait_item in &t.items {\n             let n = trait_item.name;\n             if i.items.iter().any(|m| m.name == n) {\n                 continue;\n             }\n-            let did = i.trait_.as_ref().unwrap().def_id().unwrap();\n+            let did = i.trait_.as_ref().unwrap().def_id_full(cx.cache()).unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n             doc_impl_item(\n@@ -3997,7 +4016,6 @@ fn render_impl(\n                 outer_const_version,\n                 None,\n                 show_def_docs,\n-                cache,\n             );\n         }\n     }\n@@ -4018,29 +4036,23 @@ fn render_impl(\n                 outer_version,\n                 outer_const_version,\n                 show_def_docs,\n-                cache,\n             );\n         }\n     }\n     write!(w, \"</div>\");\n }\n \n-fn item_opaque_ty(\n-    w: &mut Buffer,\n-    cx: &Context<'_>,\n-    it: &clean::Item,\n-    t: &clean::OpaqueTy,\n-    cache: &Cache,\n-) {\n+fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n     write!(w, \"<pre class=\\\"rust opaque\\\">\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n         \"type {}{}{where_clause} = impl {bounds};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(),\n-        where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-        bounds = bounds(&t.bounds, false)\n+        t.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        bounds = bounds(&t.bounds, false, cx.cache())\n     );\n \n     document(w, cx, it, None);\n@@ -4049,25 +4061,19 @@ fn item_opaque_ty(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_trait_alias(\n-    w: &mut Buffer,\n-    cx: &Context<'_>,\n-    it: &clean::Item,\n-    t: &clean::TraitAlias,\n-    cache: &Cache,\n-) {\n+fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::TraitAlias) {\n     write!(w, \"<pre class=\\\"rust trait-alias\\\">\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n         \"trait {}{}{} = {};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(),\n-        WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-        bounds(&t.bounds, true)\n+        t.generics.print(cx.cache()),\n+        WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        bounds(&t.bounds, true, cx.cache())\n     );\n \n     document(w, cx, it, None);\n@@ -4076,25 +4082,20 @@ fn item_trait_alias(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_typedef(\n-    w: &mut Buffer,\n-    cx: &Context<'_>,\n-    it: &clean::Item,\n-    t: &clean::Typedef,\n-    cache: &Cache,\n-) {\n+fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n     write!(w, \"<pre class=\\\"rust typedef\\\">\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n         \"type {}{}{where_clause} = {type_};</pre>\",\n         it.name.as_ref().unwrap(),\n-        t.generics.print(),\n-        where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-        type_ = t.type_.print()\n+        t.generics.print(cx.cache()),\n+        where_clause =\n+            WhereClause { gens: &t.generics, indent: 0, end_newline: true }.print(cx.cache()),\n+        type_ = t.type_.print(cx.cache())\n     );\n \n     document(w, cx, it, None);\n@@ -4103,25 +4104,25 @@ fn item_typedef(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, cache: &Cache) {\n+fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     writeln!(w, \"<pre class=\\\"rust foreigntype\\\">extern {{\");\n     render_attributes(w, it, false);\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n-        it.visibility.print_with_space(cx.tcx(), it.def_id),\n+        it.visibility.print_with_space(cx.tcx(), it.def_id, cx.cache()),\n         it.name.as_ref().unwrap(),\n     );\n \n     document(w, cx, it, None);\n \n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer, cache: &Cache) {\n+fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n     let parentlen = cx.current.len() - if it.is_mod() { 1 } else { 0 };\n \n     if it.is_struct()\n@@ -4156,7 +4157,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer, cache:\n     }\n \n     if it.is_crate() {\n-        if let Some(ref version) = cache.crate_version {\n+        if let Some(ref version) = cx.cache.crate_version {\n             write!(\n                 buffer,\n                 \"<div class=\\\"block version\\\">\\\n@@ -4245,12 +4246,13 @@ fn get_methods(\n     for_deref: bool,\n     used_links: &mut FxHashSet<String>,\n     deref_mut: bool,\n+    cache: &Cache,\n ) -> Vec<String> {\n     i.items\n         .iter()\n         .filter_map(|item| match item.name {\n             Some(ref name) if !name.is_empty() && item.is_method() => {\n-                if !for_deref || should_render_item(item, deref_mut) {\n+                if !for_deref || should_render_item(item, deref_mut, cache) {\n                     Some(format!(\n                         \"<a href=\\\"#{}\\\">{}</a>\",\n                         get_next_url(used_links, format!(\"method.{}\", name)),\n@@ -4283,16 +4285,17 @@ fn small_url_encode(s: &str) -> String {\n \n fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n     let mut out = String::new();\n-    let c = cache();\n-    if let Some(v) = c.impls.get(&it.def_id) {\n+    if let Some(v) = cx.cache.impls.get(&it.def_id) {\n         let mut used_links = FxHashSet::default();\n \n         {\n             let used_links_bor = &mut used_links;\n             let mut ret = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(move |i| get_methods(i.inner_impl(), false, used_links_bor, false))\n+                .flat_map(move |i| {\n+                    get_methods(i.inner_impl(), false, used_links_bor, false, &cx.cache)\n+                })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 // We want links' order to be reproducible so we don't use unstable sort.\n@@ -4309,7 +4312,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n             if let Some(impl_) = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_some())\n-                .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n+                .find(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_trait_did)\n             {\n                 out.push_str(&sidebar_deref_methods(cx, impl_, v));\n             }\n@@ -4320,9 +4323,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n                     .iter()\n                     .filter_map(|it| {\n                         if let Some(ref i) = it.inner_impl().trait_ {\n-                            let i_display = format!(\"{:#}\", i.print());\n+                            let i_display = format!(\"{:#}\", i.print(cx.cache()));\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(&format!(\"{:#}\", i.print()));\n+                            let encoded = small_url_encode(&format!(\"{:#}\", i.print(cx.cache())));\n                             let generated = format!(\n                                 \"<a href=\\\"#impl-{}\\\">{}{}</a>\",\n                                 encoded,\n@@ -4380,7 +4383,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n \n fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> String {\n     let mut out = String::new();\n-    let c = cache();\n+    let c = cx.cache();\n \n     debug!(\"found Deref: {:?}\", impl_);\n     if let Some((target, real_target)) =\n@@ -4396,9 +4399,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> Strin\n         let deref_mut = v\n             .iter()\n             .filter(|i| i.inner_impl().trait_.is_some())\n-            .any(|i| i.inner_impl().trait_.def_id() == c.deref_mut_trait_did);\n+            .any(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == c.deref_mut_trait_did);\n         let inner_impl = target\n-            .def_id()\n+            .def_id_full(cx.cache())\n             .or_else(|| {\n                 target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n             })\n@@ -4409,18 +4412,18 @@ fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> Strin\n             let mut ret = impls\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut))\n+                .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut, c))\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 let deref_id_map = cx.deref_id_map.borrow();\n                 let id = deref_id_map\n-                    .get(&real_target.def_id().unwrap())\n+                    .get(&real_target.def_id_full(cx.cache()).unwrap())\n                     .expect(\"Deref section without derived id\");\n                 out.push_str(&format!(\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a>\",\n                     id,\n-                    Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print())),\n-                    Escape(&format!(\"{:#}\", real_target.print())),\n+                    Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(c))),\n+                    Escape(&format!(\"{:#}\", real_target.print(c))),\n                 ));\n                 // We want links' order to be reproducible so we don't use unstable sort.\n                 ret.sort();\n@@ -4429,14 +4432,14 @@ fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> Strin\n         }\n \n         // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id() {\n+        if let Some(target_did) = target.def_id_full(cx.cache()) {\n             if let Some(target_impls) = c.impls.get(&target_did) {\n                 if let Some(target_deref_impl) = target_impls\n                     .iter()\n                     .filter(|i| i.inner_impl().trait_.is_some())\n-                    .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n+                    .find(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == c.deref_trait_did)\n                 {\n-                    if let Some(type_did) = impl_.inner_impl().for_.def_id() {\n+                    if let Some(type_did) = impl_.inner_impl().for_.def_id_full(cx.cache()) {\n                         // `impl Deref<Target = S> for S`\n                         if target_did == type_did {\n                             // Avoid infinite cycles\n@@ -4473,17 +4476,21 @@ fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clea\n     }\n }\n \n-fn get_id_for_impl_on_foreign_type(for_: &clean::Type, trait_: &clean::Type) -> String {\n-    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_.print(), for_.print()))\n+fn get_id_for_impl_on_foreign_type(\n+    for_: &clean::Type,\n+    trait_: &clean::Type,\n+    cache: &Cache,\n+) -> String {\n+    small_url_encode(&format!(\"impl-{:#}-for-{:#}\", trait_.print(cache), for_.print(cache)))\n }\n \n-fn extract_for_impl_name(item: &clean::Item) -> Option<(String, String)> {\n+fn extract_for_impl_name(item: &clean::Item, cache: &Cache) -> Option<(String, String)> {\n     match *item.kind {\n         clean::ItemKind::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n                 Some((\n-                    format!(\"{:#}\", i.for_.print()),\n-                    get_id_for_impl_on_foreign_type(&i.for_, trait_),\n+                    format!(\"{:#}\", i.for_.print(cache)),\n+                    get_id_for_impl_on_foreign_type(&i.for_, trait_, cache),\n                 ))\n             } else {\n                 None\n@@ -4570,13 +4577,16 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         ));\n     }\n \n-    let c = cache();\n-\n-    if let Some(implementors) = c.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         let mut res = implementors\n             .iter()\n-            .filter(|i| i.inner_impl().for_.def_id().map_or(false, |d| !c.paths.contains_key(&d)))\n-            .filter_map(|i| extract_for_impl_name(&i.impl_item))\n+            .filter(|i| {\n+                i.inner_impl()\n+                    .for_\n+                    .def_id_full(cx.cache())\n+                    .map_or(false, |d| !cx.cache.paths.contains_key(&d))\n+            })\n+            .filter_map(|i| extract_for_impl_name(&i.impl_item, cx.cache()))\n             .collect::<Vec<_>>();\n \n         if !res.is_empty() {\n@@ -4815,9 +4825,9 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean\n     document(w, cx, it, None)\n }\n \n-fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, cache: &Cache) {\n+fn item_primitive(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n     document(w, cx, it, None);\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n@@ -4836,11 +4846,10 @@ fn make_item_keywords(it: &clean::Item) -> String {\n /// types are re-exported, we don't use the corresponding\n /// entry from the js file, as inlining will have already\n /// picked up the impl\n-fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n+fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n     let mut out = Vec::new();\n     let mut visited = FxHashSet::default();\n     let mut work = VecDeque::new();\n-    let cache = cache();\n \n     work.push_back(first_ty);\n "}, {"sha": "a8a4b74b818b617c9d60de33ce44e931efc3c708", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -32,36 +32,33 @@ crate struct JsonRenderer<'tcx> {\n     index: Rc<RefCell<FxHashMap<types::Id, types::Item>>>,\n     /// The directory where the blob will be written to.\n     out_path: PathBuf,\n+    cache: Rc<Cache>,\n }\n \n impl JsonRenderer<'_> {\n     fn sess(&self) -> &Session {\n         self.tcx.sess\n     }\n \n-    fn get_trait_implementors(\n-        &mut self,\n-        id: rustc_span::def_id::DefId,\n-        cache: &Cache,\n-    ) -> Vec<types::Id> {\n-        cache\n+    fn get_trait_implementors(&mut self, id: rustc_span::def_id::DefId) -> Vec<types::Id> {\n+        Rc::clone(&self.cache)\n             .implementors\n             .get(&id)\n             .map(|implementors| {\n                 implementors\n                     .iter()\n                     .map(|i| {\n                         let item = &i.impl_item;\n-                        self.item(item.clone(), cache).unwrap();\n+                        self.item(item.clone()).unwrap();\n                         item.def_id.into()\n                     })\n                     .collect()\n             })\n             .unwrap_or_default()\n     }\n \n-    fn get_impls(&mut self, id: rustc_span::def_id::DefId, cache: &Cache) -> Vec<types::Id> {\n-        cache\n+    fn get_impls(&mut self, id: rustc_span::def_id::DefId) -> Vec<types::Id> {\n+        Rc::clone(&self.cache)\n             .impls\n             .get(&id)\n             .map(|impls| {\n@@ -70,7 +67,7 @@ impl JsonRenderer<'_> {\n                     .filter_map(|i| {\n                         let item = &i.impl_item;\n                         if item.def_id.is_local() {\n-                            self.item(item.clone(), cache).unwrap();\n+                            self.item(item.clone()).unwrap();\n                             Some(item.def_id.into())\n                         } else {\n                             None\n@@ -81,24 +78,25 @@ impl JsonRenderer<'_> {\n             .unwrap_or_default()\n     }\n \n-    fn get_trait_items(&mut self, cache: &Cache) -> Vec<(types::Id, types::Item)> {\n-        cache\n+    fn get_trait_items(&mut self) -> Vec<(types::Id, types::Item)> {\n+        Rc::clone(&self.cache)\n             .traits\n             .iter()\n             .filter_map(|(&id, trait_item)| {\n                 // only need to synthesize items for external traits\n                 if !id.is_local() {\n-                    trait_item.items.clone().into_iter().for_each(|i| self.item(i, cache).unwrap());\n+                    trait_item.items.clone().into_iter().for_each(|i| self.item(i).unwrap());\n                     Some((\n                         id.into(),\n                         types::Item {\n                             id: id.into(),\n                             crate_id: id.krate.as_u32(),\n-                            name: cache\n+                            name: self\n+                                .cache\n                                 .paths\n                                 .get(&id)\n                                 .unwrap_or_else(|| {\n-                                    cache\n+                                    self.cache\n                                         .external_paths\n                                         .get(&id)\n                                         .expect(\"Trait should either be in local or external paths\")\n@@ -134,7 +132,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         options: RenderOptions,\n         _render_info: RenderInfo,\n         _edition: Edition,\n-        _cache: &mut Cache,\n+        cache: Cache,\n         tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         debug!(\"Initializing json renderer\");\n@@ -143,6 +141,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 tcx,\n                 index: Rc::new(RefCell::new(FxHashMap::default())),\n                 out_path: options.output,\n+                cache: Rc::new(cache),\n             },\n             krate,\n         ))\n@@ -151,18 +150,18 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n     /// Inserts an item into the index. This should be used rather than directly calling insert on\n     /// the hashmap because certain items (traits and types) need to have their mappings for trait\n     /// implementations filled out before they're inserted.\n-    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error> {\n+    fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n         // Flatten items that recursively store other items\n-        item.kind.inner_items().for_each(|i| self.item(i.clone(), cache).unwrap());\n+        item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n \n         let id = item.def_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::TraitItem(ref mut t) = new_item.inner {\n-                t.implementors = self.get_trait_implementors(id, cache)\n+                t.implementors = self.get_trait_implementors(id)\n             } else if let types::ItemEnum::StructItem(ref mut s) = new_item.inner {\n-                s.impls = self.get_impls(id, cache)\n+                s.impls = self.get_impls(id)\n             } else if let types::ItemEnum::EnumItem(ref mut e) = new_item.inner {\n-                e.impls = self.get_impls(id, cache)\n+                e.impls = self.get_impls(id)\n             }\n             let removed = self.index.borrow_mut().insert(id.into(), new_item.clone());\n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n@@ -175,27 +174,20 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         Ok(())\n     }\n \n-    fn mod_item_in(\n-        &mut self,\n-        item: &clean::Item,\n-        _module_name: &str,\n-        cache: &Cache,\n-    ) -> Result<(), Error> {\n+    fn mod_item_in(&mut self, item: &clean::Item, _module_name: &str) -> Result<(), Error> {\n         use clean::types::ItemKind::*;\n         if let ModuleItem(m) = &*item.kind {\n             for item in &m.items {\n                 match &*item.kind {\n                     // These don't have names so they don't get added to the output by default\n-                    ImportItem(_) => self.item(item.clone(), cache).unwrap(),\n-                    ExternCrateItem(_, _) => self.item(item.clone(), cache).unwrap(),\n-                    ImplItem(i) => {\n-                        i.items.iter().for_each(|i| self.item(i.clone(), cache).unwrap())\n-                    }\n+                    ImportItem(_) => self.item(item.clone()).unwrap(),\n+                    ExternCrateItem(_, _) => self.item(item.clone()).unwrap(),\n+                    ImplItem(i) => i.items.iter().for_each(|i| self.item(i.clone()).unwrap()),\n                     _ => {}\n                 }\n             }\n         }\n-        self.item(item.clone(), cache).unwrap();\n+        self.item(item.clone()).unwrap();\n         Ok(())\n     }\n \n@@ -206,30 +198,31 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n     fn after_krate(\n         &mut self,\n         krate: &clean::Crate,\n-        cache: &Cache,\n         _diag: &rustc_errors::Handler,\n     ) -> Result<(), Error> {\n         debug!(\"Done with crate\");\n         let mut index = (*self.index).clone().into_inner();\n-        index.extend(self.get_trait_items(cache));\n+        index.extend(self.get_trait_items());\n         let output = types::Crate {\n             root: types::Id(String::from(\"0:0\")),\n             crate_version: krate.version.clone(),\n-            includes_private: cache.document_private,\n+            includes_private: self.cache.document_private,\n             index,\n-            paths: cache\n+            paths: self\n+                .cache\n                 .paths\n                 .clone()\n                 .into_iter()\n-                .chain(cache.external_paths.clone().into_iter())\n+                .chain(self.cache.external_paths.clone().into_iter())\n                 .map(|(k, (path, kind))| {\n                     (\n                         k.into(),\n                         types::ItemSummary { crate_id: k.krate.as_u32(), path, kind: kind.into() },\n                     )\n                 })\n                 .collect(),\n-            external_crates: cache\n+            external_crates: self\n+                .cache\n                 .extern_locations\n                 .iter()\n                 .map(|(k, v)| {\n@@ -254,4 +247,8 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         serde_json::ser::to_writer(&file, &output).unwrap();\n         Ok(())\n     }\n+\n+    fn cache(&self) -> &Cache {\n+        &self.cache\n+    }\n }"}, {"sha": "61e14c05222773723b26b888938be2f14ba19785", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -218,7 +218,12 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n             clean::ImplItem(ref impl_) => {\n                 let filename = i.source.filename(self.ctx.sess());\n                 if let Some(ref tr) = impl_.trait_ {\n-                    debug!(\"impl {:#} for {:#} in {}\", tr.print(), impl_.for_.print(), filename,);\n+                    debug!(\n+                        \"impl {:#} for {:#} in {}\",\n+                        tr.print(&self.ctx.cache),\n+                        impl_.for_.print(&self.ctx.cache),\n+                        filename,\n+                    );\n \n                     // don't count trait impls, the missing-docs lint doesn't so we shouldn't\n                     // either\n@@ -227,7 +232,7 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                     // inherent impls *can* be documented, and those docs show up, but in most\n                     // cases it doesn't make sense, as all methods on a type are in one single\n                     // impl block\n-                    debug!(\"impl {:#} in {}\", impl_.for_.print(), filename);\n+                    debug!(\"impl {:#} in {}\", impl_.for_.print(&self.ctx.cache), filename);\n                 }\n             }\n             _ => {"}, {"sha": "e5690383e4f0bfea3cd977e94648aba957cf23fa", "filename": "src/test/rustdoc-js-std/primitive.js", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Ftest%2Frustdoc-js-std%2Fprimitive.js", "raw_url": "https://github.com/rust-lang/rust/raw/613ef740f3f37702728c6324f948d0abd1e9c82b/src%2Ftest%2Frustdoc-js-std%2Fprimitive.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fprimitive.js?ref=613ef740f3f37702728c6324f948d0abd1e9c82b", "patch": "@@ -0,0 +1,75 @@\n+const QUERY = [\n+    'i8',\n+    'u32',\n+    'str',\n+    'char',\n+    'unit',\n+    'tuple',\n+    'fn',\n+];\n+\n+const EXPECTED = [\n+    {\n+        'others': [\n+            {\n+                'path': 'std',\n+                'name': 'i8',\n+                'href': '../std/primitive.i8.html',\n+            },\n+        ]\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'std',\n+                'name': 'u32',\n+                'href': '../std/primitive.u32.html',\n+            },\n+        ]\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'std',\n+                'name': 'str',\n+                'href': '../std/primitive.str.html',\n+            },\n+        ]\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'std',\n+                'name': 'char',\n+                'href': '../std/primitive.char.html',\n+            },\n+        ]\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'std',\n+                'name': 'unit',\n+                'href': '../std/primitive.unit.html',\n+            },\n+        ]\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'std',\n+                'name': 'tuple',\n+                'href': '../std/primitive.tuple.html',\n+            },\n+        ]\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'std',\n+                'name': 'fn',\n+                'href': '../std/primitive.fn.html',\n+            },\n+        ]\n+    },\n+];"}]}