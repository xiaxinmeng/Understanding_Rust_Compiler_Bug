{"sha": "4310ba2c985c161260bbdfef5d92ceea552e9055", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMTBiYTJjOTg1YzE2MTI2MGJiZGZlZjVkOTJjZWVhNTUyZTkwNTU=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-03-16T00:03:51Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-05T20:09:27Z"}, "message": "Added test suite.", "tree": {"sha": "2ec9ae19d0e7ac3d1d8abd1696be90cf81ac396e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ec9ae19d0e7ac3d1d8abd1696be90cf81ac396e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4310ba2c985c161260bbdfef5d92ceea552e9055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4310ba2c985c161260bbdfef5d92ceea552e9055", "html_url": "https://github.com/rust-lang/rust/commit/4310ba2c985c161260bbdfef5d92ceea552e9055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4310ba2c985c161260bbdfef5d92ceea552e9055/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cad1b1847eb6c2b720858f26af16d38d658fbc1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cad1b1847eb6c2b720858f26af16d38d658fbc1a", "html_url": "https://github.com/rust-lang/rust/commit/cad1b1847eb6c2b720858f26af16d38d658fbc1a"}], "stats": {"total": 3149, "additions": 3138, "deletions": 11}, "files": [{"sha": "b161e68abafd0e2e4b638e4609dbda1e44b582cf", "filename": "src/test/run-pass/issues/issue-25700-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25700-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25700-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25700-2.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -18,5 +18,5 @@ fn record_type<Id: AstId>(i: Id::Untyped) -> u8 {\n }\n \n pub fn main() {\n-   assert_eq!(record_type::<u32>(3), 42);\n+    assert_eq!(record_type::<u32>(3), 42);\n }"}, {"sha": "0ea23ad1dbffa7ed4903aabb680dca2c0d9f5008", "filename": "src/test/ui/associated-type-bounds/auxiliary/fn-aux.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-aux.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,177 @@\n+// Traits:\n+\n+pub trait Alpha {\n+    fn alpha(self) -> usize;\n+}\n+\n+pub trait Beta {\n+    type Gamma;\n+    fn gamma(self) -> Self::Gamma;\n+}\n+\n+pub trait Delta {\n+    fn delta(self) -> usize;\n+}\n+\n+pub trait Epsilon<'a> {\n+    type Zeta;\n+    fn zeta(&'a self) -> Self::Zeta;\n+\n+    fn epsilon(&'a self) -> usize;\n+}\n+\n+pub trait Eta {\n+    fn eta(self) -> usize;\n+}\n+\n+// Assertions:\n+\n+pub fn assert_alpha<T: Alpha>(x: T) -> usize { x.alpha() }\n+pub fn assert_static<T: 'static>(_: T) -> usize { 24 }\n+pub fn assert_delta<T: Delta>(x: T) -> usize { x.delta() }\n+pub fn assert_epsilon_specific<'a, T: 'a + Epsilon<'a>>(x: &'a T) -> usize { x.epsilon() }\n+pub fn assert_epsilon_forall<T: for<'a> Epsilon<'a>>() {}\n+pub fn assert_forall_epsilon_zeta_satisfies_eta<T>(x: T) -> usize\n+where\n+    T: for<'a> Epsilon<'a>,\n+    for<'a> <T as Epsilon<'a>>::Zeta: Eta,\n+{\n+    x.epsilon() + x.zeta().eta()\n+}\n+\n+// Implementations and types:\n+\n+#[derive(Copy, Clone)]\n+pub struct BetaType;\n+\n+#[derive(Copy, Clone)]\n+pub struct GammaType;\n+\n+#[derive(Copy, Clone)]\n+pub struct ZetaType;\n+\n+impl Beta for BetaType {\n+    type Gamma = GammaType;\n+    fn gamma(self) -> Self::Gamma { GammaType }\n+}\n+\n+impl<'a> Beta for &'a BetaType {\n+    type Gamma = GammaType;\n+    fn gamma(self) -> Self::Gamma { GammaType }\n+}\n+\n+impl Beta for GammaType {\n+    type Gamma = Self;\n+    fn gamma(self) -> Self::Gamma { self }\n+}\n+\n+impl Alpha for GammaType {\n+    fn alpha(self) -> usize { 42 }\n+}\n+\n+impl Delta for GammaType {\n+    fn delta(self) -> usize { 1337 }\n+}\n+\n+impl<'a> Epsilon<'a> for GammaType {\n+    type Zeta = ZetaType;\n+    fn zeta(&'a self) -> Self::Zeta { ZetaType }\n+\n+    fn epsilon(&'a self) -> usize { 7331 }\n+}\n+\n+impl Eta for ZetaType {\n+    fn eta(self) -> usize { 7 }\n+}\n+\n+// Desugared forms to check against:\n+\n+pub fn desugared_bound<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Alpha\n+{\n+    let gamma: B::Gamma = beta.gamma();\n+    assert_alpha::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_bound_region<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: 'static,\n+{\n+    assert_static::<B::Gamma>(beta.gamma())\n+}\n+\n+pub fn desugared_bound_multi<B>(beta: B) -> usize\n+where\n+    B: Copy + Beta,\n+    B::Gamma: Alpha + 'static + Delta,\n+{\n+    assert_alpha::<B::Gamma>(beta.gamma()) +\n+    assert_static::<B::Gamma>(beta.gamma()) +\n+    assert_delta::<B::Gamma>(beta.gamma())\n+}\n+\n+pub fn desugared_bound_region_specific<'a, B>(gamma: &'a B::Gamma) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: 'a + Epsilon<'a>,\n+{\n+    assert_epsilon_specific::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_bound_region_forall<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + for<'a> Epsilon<'a>,\n+{\n+    assert_epsilon_forall::<B::Gamma>();\n+    let g1: B::Gamma = beta.gamma();\n+    let g2: B::Gamma = g1;\n+    assert_epsilon_specific::<B::Gamma>(&g1) +\n+    assert_epsilon_specific::<B::Gamma>(&g2)\n+}\n+\n+pub fn desugared_bound_region_forall2<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + for<'a> Epsilon<'a>,\n+    for<'a> <B::Gamma as Epsilon<'a>>::Zeta: Eta,\n+{\n+    let gamma = beta.gamma();\n+    assert_forall_epsilon_zeta_satisfies_eta::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_contraint_region_forall<B>(beta: B) -> usize\n+where\n+    for<'a> &'a B: Beta,\n+    for<'a> <&'a B as Beta>::Gamma: Alpha,\n+{\n+    let g1 = beta.gamma();\n+    let g2 = beta.gamma();\n+    assert_alpha(g1) + assert_alpha(g2)\n+}\n+\n+pub fn desugared_bound_nested<B>(beta: B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + Alpha + Beta,\n+    <B::Gamma as Beta>::Gamma: Delta,\n+{\n+    let go = beta.gamma();\n+    let gi = go.gamma();\n+    go.alpha() + gi.delta()\n+}\n+\n+pub fn desugared() {\n+    let beta = BetaType;\n+    let gamma = beta.gamma();\n+\n+    assert_eq!(42, desugared_bound(beta));\n+    assert_eq!(24, desugared_bound_region(beta));\n+    assert_eq!(42 + 24 + 1337, desugared_bound_multi(beta));\n+    assert_eq!(7331, desugared_bound_region_specific::<BetaType>(&gamma));\n+    assert_eq!(7331 * 2, desugared_bound_region_forall(beta));\n+    assert_eq!(42 + 1337, desugared_bound_nested(beta));\n+}"}, {"sha": "85d6c5aaf3c6f53bfb36289a7f6b7e5696815aef", "filename": "src/test/ui/associated-type-bounds/auxiliary/fn-dyn-aux.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-dyn-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-dyn-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fauxiliary%2Ffn-dyn-aux.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,182 @@\n+// Traits:\n+\n+pub trait Alpha {\n+    fn alpha(self) -> usize;\n+}\n+\n+pub trait Beta {\n+    type Gamma;\n+    fn gamma(&self) -> Self::Gamma;\n+}\n+\n+pub trait Delta {\n+    fn delta(self) -> usize;\n+}\n+\n+pub trait Epsilon<'a> {\n+    type Zeta;\n+    fn zeta(&'a self) -> Self::Zeta;\n+\n+    fn epsilon(&'a self) -> usize;\n+}\n+\n+pub trait Eta {\n+    fn eta(self) -> usize;\n+}\n+\n+// Assertions:\n+\n+pub fn assert_alpha<T: Alpha>(x: T) -> usize { x.alpha() }\n+pub fn assert_static<T: 'static>(_: T) -> usize { 24 }\n+pub fn assert_delta<T: Delta>(x: T) -> usize { x.delta() }\n+pub fn assert_epsilon_specific<'a, T: 'a + Epsilon<'a>>(x: &'a T) -> usize { x.epsilon() }\n+pub fn assert_epsilon_forall<T: for<'a> Epsilon<'a>>() {}\n+pub fn assert_forall_epsilon_zeta_satisfies_eta<T>(x: T) -> usize\n+where\n+    T: for<'a> Epsilon<'a>,\n+    for<'a> <T as Epsilon<'a>>::Zeta: Eta,\n+{\n+    x.epsilon() + x.zeta().eta()\n+}\n+\n+// Implementations and types:\n+\n+#[derive(Copy, Clone)]\n+pub struct BetaType;\n+\n+#[derive(Copy, Clone)]\n+pub struct GammaType;\n+\n+#[derive(Copy, Clone)]\n+pub struct ZetaType;\n+\n+impl<T> Beta for &(dyn Beta<Gamma = T> + Send) {\n+    type Gamma = T;\n+    fn gamma(&self) -> Self::Gamma { (*self).gamma() }\n+}\n+\n+impl Beta for BetaType {\n+    type Gamma = GammaType;\n+    fn gamma(&self) -> Self::Gamma { GammaType }\n+}\n+\n+impl<'a> Beta for &'a BetaType {\n+    type Gamma = GammaType;\n+    fn gamma(&self) -> Self::Gamma { GammaType }\n+}\n+\n+impl Beta for GammaType {\n+    type Gamma = Self;\n+    fn gamma(&self) -> Self::Gamma { Self }\n+}\n+\n+impl Alpha for GammaType {\n+    fn alpha(self) -> usize { 42 }\n+}\n+\n+impl Delta for GammaType {\n+    fn delta(self) -> usize { 1337 }\n+}\n+\n+impl<'a> Epsilon<'a> for GammaType {\n+    type Zeta = ZetaType;\n+    fn zeta(&'a self) -> Self::Zeta { ZetaType }\n+\n+    fn epsilon(&'a self) -> usize { 7331 }\n+}\n+\n+impl Eta for ZetaType {\n+    fn eta(self) -> usize { 7 }\n+}\n+\n+// Desugared forms to check against:\n+\n+pub fn desugared_bound<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Alpha\n+{\n+    let gamma: B::Gamma = beta.gamma();\n+    assert_alpha::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_bound_region<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: 'static,\n+{\n+    assert_static::<B::Gamma>(beta.gamma())\n+}\n+\n+pub fn desugared_bound_multi<B: ?Sized>(beta: B) -> usize\n+where\n+    B: Copy + Beta,\n+    B::Gamma: Alpha + 'static + Delta,\n+{\n+    assert_alpha::<B::Gamma>(beta.gamma()) +\n+    assert_static::<B::Gamma>(beta.gamma()) +\n+    assert_delta::<B::Gamma>(beta.gamma())\n+}\n+\n+pub fn desugared_bound_region_specific<'a, B: ?Sized>(gamma: &'a B::Gamma) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: 'a + Epsilon<'a>,\n+{\n+    assert_epsilon_specific::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_bound_region_forall<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + for<'a> Epsilon<'a>,\n+{\n+    assert_epsilon_forall::<B::Gamma>();\n+    let g1: B::Gamma = beta.gamma();\n+    let g2: B::Gamma = g1;\n+    assert_epsilon_specific::<B::Gamma>(&g1) +\n+    assert_epsilon_specific::<B::Gamma>(&g2)\n+}\n+\n+pub fn desugared_bound_region_forall2<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + for<'a> Epsilon<'a>,\n+    for<'a> <B::Gamma as Epsilon<'a>>::Zeta: Eta,\n+{\n+    let gamma = beta.gamma();\n+    assert_forall_epsilon_zeta_satisfies_eta::<B::Gamma>(gamma)\n+}\n+\n+pub fn desugared_contraint_region_forall<B: ?Sized>(beta: &B) -> usize\n+where\n+    for<'a> &'a B: Beta,\n+    for<'a> <&'a B as Beta>::Gamma: Alpha,\n+{\n+    let g1 = beta.gamma();\n+    let g2 = beta.gamma();\n+    assert_alpha(g1) + assert_alpha(g2)\n+}\n+\n+pub fn desugared_bound_nested<B: ?Sized>(beta: &B) -> usize\n+where\n+    B: Beta,\n+    B::Gamma: Copy + Alpha + Beta,\n+    <B::Gamma as Beta>::Gamma: Delta,\n+{\n+    let go = beta.gamma();\n+    let gi = go.gamma();\n+    go.alpha() + gi.delta()\n+}\n+\n+pub fn desugared() {\n+    let beta = BetaType;\n+    let gamma = beta.gamma();\n+\n+    assert_eq!(42, desugared_bound(&beta));\n+    assert_eq!(24, desugared_bound_region(&beta));\n+    assert_eq!(42 + 24 + 1337, desugared_bound_multi(beta));\n+    assert_eq!(7331, desugared_bound_region_specific::<BetaType>(&gamma));\n+    assert_eq!(7331 * 2, desugared_bound_region_forall(&beta));\n+    assert_eq!(42 + 1337, desugared_bound_nested(&beta));\n+}"}, {"sha": "78704a9b512396b3e81de0c5ca67845addb3425b", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,60 @@\n+// compile-fail\n+// ignore-tidy-linelength\n+\n+// NOTE: rustc cannot currently handle bounds of the form `for<'a> <Foo as Bar<'a>>::Assoc: Baz`.\n+// This should hopefully be fixed with Chalk.\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::fmt::Debug;\n+use std::iter::Once;\n+\n+trait Lam<Binder> { type App; }\n+\n+#[derive(Clone)]\n+struct L1;\n+impl<'a> Lam<&'a u8> for L1 { type App = u8; }\n+\n+#[derive(Clone)]\n+struct L2;\n+impl<'a, 'b> Lam<&'a &'b u8> for L2 { type App = u8; }\n+\n+trait Case1 {\n+    type C: Clone + Iterator<Item:\n+        Send + Iterator<Item:\n+            for<'a> Lam<&'a u8, App:\n+                Debug\n+            >\n+        > + Sync>;\n+}\n+\n+pub struct S1;\n+impl Case1 for S1 {\n+//~^ ERROR `<L1 as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug` [E0277]\n+    type C = Once<Once<L1>>;\n+}\n+\n+fn assume_case1<T: Case1>() {\n+//~^ ERROR `<_ as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug` [E0277]\n+//~| ERROR `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator [E0277]\n+//~| ERROR `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely [E0277]\n+//~| ERROR `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely [E0277]\n+    fn assert_a<_0, A>() where A: Iterator<Item = _0>, _0: Debug {}\n+    assert_a::<_, T::A>();\n+\n+    fn assert_b<_0, B>() where B: Iterator<Item = _0>, _0: 'static {}\n+    assert_b::<_, T::B>();\n+\n+    fn assert_c<_0, _1, _2, C>()\n+    where\n+        C: Clone + Iterator<Item = _2>,\n+        _2: Send + Iterator<Item = _1>,\n+        _1: for<'a> Lam<&'a u8, App = _0>,\n+        _0: Debug,\n+    {}\n+    assert_c::<_, _, _, T::C>();\n+}\n+\n+fn main() {\n+    assume_case1(S1);\n+}"}, {"sha": "aebf29cc332ab3e85957dbe16c83f3367ccd886f", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.stderr", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,85 @@\n+error[E0277]: `<L1 as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:32:6\n+   |\n+LL | impl Case1 for S1 {\n+   |      ^^^^^ `<L1 as Lam<&'a u8>>::App` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `for<'a> std::fmt::Debug` is not implemented for `<L1 as Lam<&'a u8>>::App`\n+\n+error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n+   |\n+LL | / fn assume_case1<T: Case1>() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     assert_c::<_, _, _, T::C>();\n+LL | | }\n+   | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::iter::Iterator` bound\n+\n+error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n+   |\n+LL | / fn assume_case1<T: Case1>() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     assert_c::<_, _, _, T::C>();\n+LL | | }\n+   | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Send` bound\n+note: required by `Case1`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:22:1\n+   |\n+LL | trait Case1 {\n+   | ^^^^^^^^^^^\n+\n+error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n+   |\n+LL | / fn assume_case1<T: Case1>() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     assert_c::<_, _, _, T::C>();\n+LL | | }\n+   | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n+   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync` bound\n+note: required by `Case1`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:22:1\n+   |\n+LL | trait Case1 {\n+   | ^^^^^^^^^^^\n+\n+error[E0277]: `<_ as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n+   |\n+LL | / fn assume_case1<T: Case1>() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     assert_c::<_, _, _, T::C>();\n+LL | | }\n+   | |_^ `<_ as Lam<&'a u8>>::App` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `for<'a> std::fmt::Debug` is not implemented for `<_ as Lam<&'a u8>>::App`\n+note: required by `Case1`\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:22:1\n+   |\n+LL | trait Case1 {\n+   | ^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8c9110d03ec16417389387f4ae26dfa71298f928", "filename": "src/test/ui/associated-type-bounds/bounds-on-assoc-in-trait.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,51 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::fmt::Debug;\n+use std::iter::Empty;\n+use std::ops::Range;\n+\n+trait Lam<Binder> { type App; }\n+\n+#[derive(Clone)]\n+struct L1;\n+impl<'a> Lam<&'a u8> for L1 { type App = u8; }\n+\n+#[derive(Clone)]\n+struct L2;\n+impl<'a, 'b> Lam<&'a &'b u8> for L2 { type App = u8; }\n+\n+trait Case1 {\n+    type A: Iterator<Item: Debug>;\n+\n+    type B: Iterator<Item: 'static>;\n+}\n+\n+pub struct S1;\n+impl Case1 for S1 {\n+    type A = Empty<String>;\n+    type B = Range<u16>;\n+}\n+\n+// Ensure we don't have existential desugaring:\n+\n+pub trait Foo { type Out: Baz<Assoc: Default>; }\n+pub trait Baz { type Assoc; }\n+\n+#[derive(Default)]\n+struct S2;\n+#[derive(Default)]\n+struct S3;\n+struct S4;\n+struct S5;\n+struct S6;\n+struct S7;\n+\n+impl Foo for S6 { type Out = S4; }\n+impl Foo for S7 { type Out = S5; }\n+\n+impl Baz for S4 { type Assoc = S2; }\n+impl Baz for S5 { type Assoc = S3; }\n+\n+fn main() {}"}, {"sha": "bee56d6f689903ae6db4a3a69b111077d6d8a5fe", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,161 @@\n+// compile-fail\n+// ignore-tidy-linelength\n+// error-pattern:could not find defining uses\n+\n+#![feature(associated_type_bounds)]\n+#![feature(existential_type)]\n+#![feature(impl_trait_in_bindings)]\n+#![feature(untagged_unions)]\n+\n+use std::iter;\n+\n+struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRS1: Iterator<Item: Copy, Item: Send> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n+//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+\n+fn main() {}"}, {"sha": "fbf02ddc7032fa5697e473c9082b9d7533a361da", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,627 @@\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:12:36\n+   |\n+LL | struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:14:36\n+   |\n+LL | struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:16:39\n+   |\n+LL | struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n+   |                        -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:18:45\n+   |\n+LL | struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n+   |                                 ----------  ^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:20:45\n+   |\n+LL | struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n+   |                                 ----------  ^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:22:48\n+   |\n+LL | struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n+   |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:25:34\n+   |\n+LL | enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n+   |                      ----------  ^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:27:34\n+   |\n+LL | enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n+   |                      ----------  ^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:29:37\n+   |\n+LL | enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n+   |                      -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:31:43\n+   |\n+LL | enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:33:43\n+   |\n+LL | enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:35:46\n+   |\n+LL | enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n+   |                               -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:38:35\n+   |\n+LL | union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n+   |                       ----------  ^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:40:35\n+   |\n+LL | union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n+   |                       ----------  ^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:42:38\n+   |\n+LL | union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n+   |                       -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:44:44\n+   |\n+LL | union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:46:44\n+   |\n+LL | union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:48:47\n+   |\n+LL | union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n+   |                                -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:51:32\n+   |\n+LL | fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n+   |                    ----------  ^^^^^^^^^^ re-bound here\n+   |                    |\n+   |                    `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:53:32\n+   |\n+LL | fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n+   |                    ----------  ^^^^^^^^^^ re-bound here\n+   |                    |\n+   |                    `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:55:35\n+   |\n+LL | fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n+   |                    -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                    |\n+   |                    `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:57:43\n+   |\n+LL | fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:59:43\n+   |\n+LL | fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:61:46\n+   |\n+LL | fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n+   |                               -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:70:40\n+   |\n+LL | fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:72:40\n+   |\n+LL | fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:74:43\n+   |\n+LL | fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n+   |                            -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:64:42\n+   |\n+LL | fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n+   |                              ----------  ^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:66:42\n+   |\n+LL | fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n+   |                              ----------  ^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:68:45\n+   |\n+LL | fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n+   |                              -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                              |\n+   |                              `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:77:39\n+   |\n+LL | const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n+   |                           ----------  ^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:79:39\n+   |\n+LL | const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n+   |                           ----------  ^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:81:42\n+   |\n+LL | const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n+   |                           -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                           |\n+   |                           `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:83:40\n+   |\n+LL | static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:85:40\n+   |\n+LL | static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:87:43\n+   |\n+LL | static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n+   |                            -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:90:46\n+   |\n+LL | fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:92:46\n+   |\n+LL | fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:94:49\n+   |\n+LL | fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n+   |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:97:35\n+   |\n+LL | type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n+   |                       ----------  ^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:99:35\n+   |\n+LL | type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n+   |                       ----------  ^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:101:38\n+   |\n+LL | type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n+   |                       -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                       |\n+   |                       `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:103:44\n+   |\n+LL | type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:105:44\n+   |\n+LL | type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:107:47\n+   |\n+LL | type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n+   |                                -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:110:1\n+   |\n+LL | existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:110:48\n+   |\n+LL | existential type ETAI1<T: Iterator<Item: Copy, Item: Send>>: Copy;\n+   |                                    ----------  ^^^^^^^^^^ re-bound here\n+   |                                    |\n+   |                                    `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:112:1\n+   |\n+LL | existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:112:48\n+   |\n+LL | existential type ETAI2<T: Iterator<Item: Copy, Item: Copy>>: Copy;\n+   |                                    ----------  ^^^^^^^^^^ re-bound here\n+   |                                    |\n+   |                                    `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:114:1\n+   |\n+LL | existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:114:51\n+   |\n+LL | existential type ETAI3<T: Iterator<Item: 'static, Item: 'static>>: Copy;\n+   |                                    -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                    |\n+   |                                    `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:116:1\n+   |\n+LL | existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:116:46\n+   |\n+LL | existential type ETAI4: Iterator<Item: Copy, Item: Send>;\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:118:1\n+   |\n+LL | existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:118:46\n+   |\n+LL | existential type ETAI5: Iterator<Item: Copy, Item: Copy>;\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error: could not find defining uses\n+  --> $DIR/duplicate.rs:120:1\n+   |\n+LL | existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:120:49\n+   |\n+LL | existential type ETAI6: Iterator<Item: 'static, Item: 'static>;\n+   |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:123:36\n+   |\n+LL | trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:125:36\n+   |\n+LL | trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n+   |                        ----------  ^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:127:39\n+   |\n+LL | trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n+   |                        -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                        |\n+   |                        `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:129:34\n+   |\n+LL | trait TRS1: Iterator<Item: Copy, Item: Send> {}\n+   |                      ----------  ^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:131:34\n+   |\n+LL | trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n+   |                      ----------  ^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:133:37\n+   |\n+LL | trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n+   |                      -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                      |\n+   |                      `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:135:45\n+   |\n+LL | trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n+   |                                 ----------  ^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:137:45\n+   |\n+LL | trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n+   |                                 ----------  ^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:139:48\n+   |\n+LL | trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n+   |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                 |\n+   |                                 `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:141:46\n+   |\n+LL | trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:143:46\n+   |\n+LL | trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n+   |                                  ----------  ^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:145:49\n+   |\n+LL | trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n+   |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                                  |\n+   |                                  `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:147:43\n+   |\n+LL | trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:149:43\n+   |\n+LL | trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:151:46\n+   |\n+LL | trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n+   |                               -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:154:40\n+   |\n+LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n+   |                            ----------  ^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:156:44\n+   |\n+LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n+   |                                ----------  ^^^^^^^^^^ re-bound here\n+   |                                |\n+   |                                `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/duplicate.rs:158:43\n+   |\n+LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n+   |                            -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                            |\n+   |                            `Item` bound here first\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: aborting due to 93 previous errors\n+\n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "dc0afaa934a9ee1ec7962ef757e4c833c8b8e8b3", "filename": "src/test/ui/associated-type-bounds/dyn-existential-type.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-existential-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-existential-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-existential-type.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,67 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(existential_type)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n+\n+type Et1 = Box<dyn Tr1<As1: Copy>>;\n+fn def_et1() -> Et1 { Box::new(S1) }\n+pub fn use_et1() { assert_copy(def_et1().mk()); }\n+\n+type Et2 = Box<dyn Tr1<As1: 'static>>;\n+fn def_et2() -> Et2 { Box::new(S1) }\n+pub fn use_et2() { assert_static(def_et2().mk()); }\n+\n+type Et3 = Box<dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>>;\n+fn def_et3() -> Et3 {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(&self) -> Self::As1 { 0..10 }\n+    };\n+    Box::new(A)\n+}\n+pub fn use_et3() {\n+    let _0 = def_et3().mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+type Et4 = Box<dyn Tr1<As1: for<'a> Tr2<'a>>>;\n+fn def_et4() -> Et4 {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(&self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    Box::new(A)\n+}\n+pub fn use_et4() { assert_forall_tr2(def_et4().mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "439304fd309c8d66b0f0eca57bd9632af5260588", "filename": "src/test/ui/associated-type-bounds/dyn-lcsit.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-lcsit.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,69 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(impl_trait_in_bindings)]\n+\n+#![allow(non_upper_case_globals)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+#[derive(Copy, Clone)]\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n+\n+const cdef_et1: &dyn Tr1<As1: Copy> = &S1;\n+const sdef_et1: &dyn Tr1<As1: Copy> = &S1;\n+pub fn use_et1() { assert_copy(cdef_et1.mk()); assert_copy(sdef_et1.mk()); }\n+\n+const cdef_et2: &(dyn Tr1<As1: 'static> + Sync) = &S1;\n+static sdef_et2: &(dyn Tr1<As1: 'static> + Sync) = &S1;\n+pub fn use_et2() { assert_static(cdef_et2.mk()); assert_static(sdef_et2.mk()); }\n+\n+const cdef_et3: &dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> = {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(&self) -> Self::As1 { 0..10 }\n+    };\n+    &A\n+};\n+pub fn use_et3() {\n+    let _0 = cdef_et3.mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+const cdef_et4: &(dyn Tr1<As1: for<'a> Tr2<'a>> + Sync) = {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(&self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    &A\n+};\n+static sdef_et4: &(dyn Tr1<As1: for<'a> Tr2<'a>> + Sync) = cdef_et4;\n+pub fn use_et4() { assert_forall_tr2(cdef_et4.mk()); assert_forall_tr2(sdef_et4.mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "f22a6c44cb84d8994c39a6fab0c65dbce7acdc88", "filename": "src/test/ui/associated-type-bounds/dyn-rpit-and-let.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-rpit-and-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-rpit-and-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fdyn-rpit-and-let.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,73 @@\n+// run-pass\n+\n+// FIXME: uncomment let binding types below when `impl_trait_in_bindings` feature is fixed.\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n+\n+fn def_et1() -> Box<dyn Tr1<As1: Copy>> {\n+    let x /* : Box<dyn Tr1<As1: Copy>> */ = Box::new(S1);\n+    x\n+}\n+pub fn use_et1() { assert_copy(def_et1().mk()); }\n+\n+fn def_et2() -> Box<dyn Tr1<As1: Send + 'static>> {\n+    let x /* : Box<dyn Tr1<As1: Send + 'static>> */ = Box::new(S1);\n+    x\n+}\n+pub fn use_et2() { assert_static(def_et2().mk()); }\n+\n+fn def_et3() -> Box<dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>> {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(&self) -> Self::As1 { 0..10 }\n+    };\n+    let x /* : Box<dyn Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>> */\n+        = Box::new(A);\n+    x\n+}\n+pub fn use_et3() {\n+    let _0 = def_et3().mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+fn def_et4() -> Box<dyn Tr1<As1: for<'a> Tr2<'a>>> {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(&self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    let x /* : Box<dyn Tr1<As1: for<'a> Tr2<'a>>> */ = Box::new(A);\n+    x\n+}\n+pub fn use_et4() { assert_forall_tr2(def_et4().mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "1b3e978594d69b6e0957119534ab75753b87e47d", "filename": "src/test/ui/associated-type-bounds/entails-sized-object-safety.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fentails-sized-object-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fentails-sized-object-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fentails-sized-object-safety.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,26 @@\n+// compile-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Tr1: Sized { type As1; }\n+trait Tr2<'a>: Sized { type As2; }\n+\n+trait ObjTr1 { fn foo() -> Self where Self: Tr1<As1: Copy>; }\n+fn _assert_obj_safe_1(_: Box<dyn ObjTr1>) {}\n+\n+trait ObjTr2 { fn foo() -> Self where Self: Tr1<As1: 'static>; }\n+fn _assert_obj_safe_2(_: Box<dyn ObjTr2>) {}\n+\n+trait ObjTr3 { fn foo() -> Self where Self: Tr1<As1: Into<u8> + 'static + Copy>; }\n+fn _assert_obj_safe_3(_: Box<dyn ObjTr3>) {}\n+\n+trait ObjTr4 { fn foo() -> Self where Self: Tr1<As1: for<'a> Tr2<'a>>; }\n+fn _assert_obj_safe_4(_: Box<dyn ObjTr4>) {}\n+\n+trait ObjTr5 { fn foo() -> Self where for<'a> Self: Tr1<As1: Tr2<'a>>; }\n+fn _assert_obj_safe_5(_: Box<dyn ObjTr5>) {}\n+\n+trait ObjTr6 { fn foo() -> Self where Self: for<'a> Tr1<As1: Tr2<'a, As2: for<'b> Tr2<'b>>>; }\n+fn _assert_obj_safe_6(_: Box<dyn ObjTr6>) {}\n+\n+fn main() {}"}, {"sha": "a6b0bb7070b7a4d6a765441bc164ceec0929af9b", "filename": "src/test/ui/associated-type-bounds/enum-bounds.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fenum-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fenum-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fenum-bounds.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,122 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+trait Tr3 { type As3; }\n+trait Tr4<'a> { type As4; }\n+trait Tr5 { type As5; }\n+\n+impl Tr1 for &str { type As1 = bool; }\n+impl Tr2 for bool { type As2 = u8; }\n+impl Tr3 for u8 { type As3 = fn() -> u8; }\n+impl Tr1 for () { type As1 = (usize,); }\n+impl<'a> Tr4<'a> for (usize,) { type As4 = u8; }\n+impl Tr5 for bool { type As5 = u16; }\n+\n+enum En1<T: Tr1<As1: Tr2>> {\n+    Outest(T),\n+    Outer(T::As1),\n+    Inner(<T::As1 as Tr2>::As2),\n+}\n+\n+fn wrap_en1_1<T>(x: T) -> En1<T> where T: Tr1, T::As1: Tr2 {\n+    En1::Outest(x)\n+}\n+\n+fn wrap_en1_2<T>(x: T::As1) -> En1<T> where T: Tr1, T::As1: Tr2 {\n+    En1::Outer(x)\n+}\n+\n+fn wrap_en1_3<T>(x: <T::As1 as Tr2>::As2) -> En1<T> where T: Tr1, T::As1: Tr2 {\n+    En1::Inner(x)\n+}\n+\n+enum En2<T: Tr1<As1: Tr2<As2: Tr3>>> {\n+    V0(T),\n+    V1(T::As1),\n+    V2(<T::As1 as Tr2>::As2),\n+    V3(<<T::As1 as Tr2>::As2 as Tr3>::As3),\n+}\n+\n+enum En3<T: Tr1<As1: 'static>> {\n+    V0(T),\n+    V1(&'static T::As1),\n+}\n+\n+enum En4<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l>>> {\n+    V0(&'x1 <T::As1 as Tr4<'x1>>::As4),\n+    V1(&'x2 <T::As1 as Tr4<'x2>>::As4),\n+}\n+\n+enum _En5<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l, As4: Copy>>> {\n+    _V0(&'x1 <T::As1 as Tr4<'x1>>::As4),\n+    _V1(&'x2 <T::As1 as Tr4<'x2>>::As4),\n+}\n+\n+enum En6<T>\n+where\n+    T: Tr1<As1: Tr2 + 'static + Tr5>,\n+{\n+    V0(T),\n+    V1(<T::As1 as Tr2>::As2),\n+    V2(&'static T::As1),\n+    V3(<T::As1 as Tr5>::As5),\n+}\n+\n+enum _En7<'a, 'b, T> // `<T::As1 as Tr2>::As2: 'a` is implied.\n+where\n+    T: Tr1<As1: Tr2>,\n+{\n+    V0(&'a T),\n+    V1(&'b <T::As1 as Tr2>::As2),\n+}\n+\n+fn _make_en7<'a, 'b, T>(x: _En7<'a, 'b, T>)\n+where\n+    T: Tr1<As1: Tr2>,\n+{\n+    match x {\n+        _En7::V0(x) => {\n+            let _: &'a T = &x;\n+        },\n+        _En7::V1(_) => {},\n+    }\n+}\n+\n+enum EnSelf<T> where Self: Tr1<As1: Tr2> {\n+    V0(T),\n+    V1(<Self as Tr1>::As1),\n+    V2(<<Self as Tr1>::As1 as Tr2>::As2),\n+}\n+\n+impl Tr1 for EnSelf<&'static str> { type As1 = bool; }\n+\n+fn main() {\n+    if let En1::Outest(\"foo\") = wrap_en1_1::<_>(\"foo\") {} else { panic!() };\n+    if let En1::Outer(true) = wrap_en1_2::<&str>(true) {} else { panic!() };\n+    if let En1::Inner(24u8) = wrap_en1_3::<&str>(24u8) {} else { panic!() };\n+\n+    let _ = En2::<_>::V0(\"151571\");\n+    let _ = En2::<&str>::V1(false);\n+    let _ = En2::<&str>::V2(42u8);\n+    let _ = En2::<&str>::V3(|| 12u8);\n+\n+    let _ = En3::<_>::V0(\"deadbeef\");\n+    let _ = En3::<&str>::V1(&true);\n+\n+    let f1 = (1,);\n+    let f2 = (2,);\n+    let _ = En4::<()>::V0(&f1.0);\n+    let _ = En4::<()>::V1(&f2.0);\n+\n+    let _ = En6::<_>::V0(\"bar\");\n+    let _ = En6::<&str>::V1(24u8);\n+    let _ = En6::<&str>::V2(&false);\n+    let _ = En6::<&str>::V3(12u16);\n+\n+    let _ = EnSelf::<_>::V0(\"foo\");\n+    let _ = EnSelf::<&'static str>::V1(true);\n+    let _ = EnSelf::<&'static str>::V2(24u8);\n+}"}, {"sha": "87046aec5c4ab5e5de18bc3189bb2ed21248351c", "filename": "src/test/ui/associated-type-bounds/existential-type.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fexistential-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fexistential-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fexistential-type.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,67 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(existential_type)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(self) -> Self::As1 { S2 } }\n+\n+existential type Et1: Tr1<As1: Copy>;\n+fn def_et1() -> Et1 { S1 }\n+pub fn use_et1() { assert_copy(def_et1().mk()); }\n+\n+existential type Et2: Tr1<As1: 'static>;\n+fn def_et2() -> Et2 { S1 }\n+pub fn use_et2() { assert_static(def_et2().mk()); }\n+\n+existential type Et3: Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>>;\n+fn def_et3() -> Et3 {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(self) -> Self::As1 { 0..10 }\n+    };\n+    A\n+}\n+pub fn use_et3() {\n+    let _0 = def_et3().mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+existential type Et4: Tr1<As1: for<'a> Tr2<'a>>;\n+fn def_et4() -> Et4 {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    A\n+}\n+pub fn use_et4() { assert_forall_tr2(def_et4().mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "7e208b4e70d81bd7ab85b8dd4d0f37c1b328e35e", "filename": "src/test/ui/associated-type-bounds/fn-apit.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-apit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-apit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-apit.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,58 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+fn apit_bound(beta: impl Beta<Gamma: Alpha>) -> usize {\n+    desugared_bound(beta)\n+}\n+\n+fn apit_bound_region(beta: impl Beta<Gamma: 'static>) -> usize {\n+    desugared_bound_region(beta)\n+}\n+\n+fn apit_bound_multi(\n+    beta: impl Copy + Beta<Gamma: Alpha + 'static + Delta>\n+) -> usize {\n+    desugared_bound_multi(beta)\n+}\n+\n+fn apit_bound_region_forall(\n+    beta: impl Beta<Gamma: Copy + for<'a> Epsilon<'a>>\n+) -> usize {\n+    desugared_bound_region_forall(beta)\n+}\n+\n+fn apit_bound_region_forall2(\n+    beta: impl Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>\n+) -> usize {\n+    desugared_bound_region_forall2(beta)\n+}\n+\n+fn apit_bound_nested(\n+    beta: impl Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn apit_bound_nested2(\n+    beta: impl Beta<Gamma = impl Copy + Alpha + Beta<Gamma: Delta>>\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let _gamma = beta.gamma();\n+\n+    assert_eq!(42, apit_bound(beta));\n+    assert_eq!(24, apit_bound_region(beta));\n+    assert_eq!(42 + 24 + 1337, apit_bound_multi(beta));\n+    assert_eq!(7331 * 2, apit_bound_region_forall(beta));\n+    assert_eq!(42 + 1337, apit_bound_nested(beta));\n+    assert_eq!(42 + 1337, apit_bound_nested2(beta));\n+}"}, {"sha": "434bdbe996c63202e4c8c24dd4e8f1e3bcb59dee", "filename": "src/test/ui/associated-type-bounds/fn-aux.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-aux.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,12 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+fn main() {\n+    desugared();\n+}"}, {"sha": "9ff4a50e1e6e415b0c00ba56006b6774616dfc5c", "filename": "src/test/ui/associated-type-bounds/fn-dyn-apit.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-dyn-apit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-dyn-apit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-dyn-apit.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,60 @@\n+// run-pass\n+// aux-build:fn-dyn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_dyn_aux;\n+\n+use fn_dyn_aux::*;\n+\n+// ATB, APIT (dyn trait):\n+\n+fn dyn_apit_bound(beta: &dyn Beta<Gamma: Alpha>) -> usize {\n+    desugared_bound(beta)\n+}\n+\n+fn dyn_apit_bound_region(beta: &dyn Beta<Gamma: 'static>) -> usize {\n+    desugared_bound_region(beta)\n+}\n+\n+fn dyn_apit_bound_multi(\n+    beta: &(dyn Beta<Gamma: Alpha + 'static + Delta> + Send)\n+) -> usize {\n+    desugared_bound_multi(beta)\n+}\n+\n+fn dyn_apit_bound_region_forall(\n+    beta: &dyn Beta<Gamma: Copy + for<'a> Epsilon<'a>>\n+) -> usize {\n+    desugared_bound_region_forall(beta)\n+}\n+\n+fn dyn_apit_bound_region_forall2(\n+    beta: &dyn Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>\n+) -> usize {\n+    desugared_bound_region_forall2(beta)\n+}\n+\n+fn dyn_apit_bound_nested(\n+    beta: &dyn Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn dyn_apit_bound_nested2(\n+    beta: &dyn Beta<Gamma = impl Copy + Alpha + Beta<Gamma: Delta>>\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let _gamma = beta.gamma();\n+\n+    assert_eq!(42, dyn_apit_bound(&beta));\n+    assert_eq!(24, dyn_apit_bound_region(&beta));\n+    assert_eq!(42 + 24 + 1337, dyn_apit_bound_multi(&beta));\n+    assert_eq!(7331 * 2, dyn_apit_bound_region_forall(&beta));\n+    assert_eq!(42 + 1337, dyn_apit_bound_nested(&beta));\n+    assert_eq!(42 + 1337, dyn_apit_bound_nested2(&beta));\n+}"}, {"sha": "7b188763b7a5e6f5a494f197bae43bde2b607899", "filename": "src/test/ui/associated-type-bounds/fn-inline.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-inline.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,62 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+// ATB, Type parameters, Inline bounds:\n+\n+fn inline_bound<B: Beta<Gamma: Alpha>>(beta: B) -> usize {\n+    desugared_bound(beta)\n+}\n+\n+fn inline_bound_region<B: Beta<Gamma: 'static>>(beta: B) -> usize {\n+    desugared_bound_region(beta)\n+}\n+\n+fn inline_bound_multi<B: Copy + Beta<Gamma: Alpha + 'static + Delta>>(\n+    beta: B\n+) -> usize {\n+    desugared_bound_multi(beta)\n+}\n+\n+fn inline_bound_region_specific<'a, B: Beta<Gamma: 'a + Epsilon<'a>>>(\n+    gamma: &'a B::Gamma\n+) -> usize {\n+    desugared_bound_region_specific::<B>(gamma)\n+}\n+\n+fn inline_bound_region_forall<B: Beta<Gamma: Copy + for<'a> Epsilon<'a>>>(\n+    beta: B\n+) -> usize {\n+    desugared_bound_region_forall(beta)\n+}\n+\n+fn inline_bound_region_forall2<B: Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>>(\n+    beta: B\n+) -> usize {\n+    desugared_bound_region_forall2(beta)\n+}\n+\n+fn inline_bound_nested<B: Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>>(\n+    beta: B\n+) -> usize {\n+    desugared_bound_nested(beta)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let gamma = beta.gamma();\n+\n+    assert_eq!(42, inline_bound(beta));\n+    assert_eq!(24, inline_bound_region(beta));\n+    assert_eq!(42 + 24 + 1337, inline_bound_multi(beta));\n+    assert_eq!(7331, inline_bound_region_specific::<BetaType>(&gamma));\n+    assert_eq!(7331 * 2, inline_bound_region_forall(beta));\n+    // FIXME: requires lazy normalization.\n+    // assert_eq!(7331 * 2, inline_bound_region_forall2(beta));\n+    assert_eq!(42 + 1337, inline_bound_nested(beta));\n+}"}, {"sha": "60d7149a56f25ba3baca4bb0cfcff8778fe1baa6", "filename": "src/test/ui/associated-type-bounds/fn-where.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-where.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,78 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+// ATB, Type parameters, Where-clauses:\n+\n+fn where_bound<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: Alpha>\n+{\n+    desugared_bound(beta)\n+}\n+\n+fn where_bound_region<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: 'static>\n+{\n+    desugared_bound_region(beta)\n+}\n+\n+fn where_bound_multi<B>(beta: B) -> usize\n+where\n+    B: Copy + Beta<Gamma: Alpha + 'static + Delta>,\n+{\n+    desugared_bound_multi(beta)\n+}\n+\n+fn where_bound_region_specific<'a, B>(gamma: &'a B::Gamma) -> usize\n+where\n+    B: Beta<Gamma: 'a + Epsilon<'a>>,\n+{\n+    desugared_bound_region_specific::<B>(gamma)\n+}\n+\n+fn where_bound_region_forall<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: Copy + for<'a> Epsilon<'a>>,\n+{\n+    desugared_bound_region_forall(beta)\n+}\n+\n+fn where_bound_region_forall2<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>,\n+{\n+    desugared_bound_region_forall2(beta)\n+}\n+\n+fn where_contraint_region_forall<B>(beta: B) -> usize\n+where\n+    for<'a> &'a B: Beta<Gamma: Alpha>,\n+{\n+    desugared_contraint_region_forall(beta)\n+}\n+\n+fn where_bound_nested<B>(beta: B) -> usize\n+where\n+    B: Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>,\n+{\n+    desugared_bound_nested(beta)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let gamma = beta.gamma();\n+\n+    assert_eq!(42, where_bound(beta));\n+    assert_eq!(24, where_bound_region(beta));\n+    assert_eq!(42 + 24 + 1337, where_bound_multi(beta));\n+    assert_eq!(7331, where_bound_region_specific::<BetaType>(&gamma));\n+    assert_eq!(7331 * 2, where_bound_region_forall::<BetaType>(beta));\n+    assert_eq!(42 + 1337, where_bound_nested::<BetaType>(beta));\n+}"}, {"sha": "23790d416e1f717a73e0c4f0be41de5f43e49cdc", "filename": "src/test/ui/associated-type-bounds/fn-wrap-apit.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-wrap-apit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-wrap-apit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ffn-wrap-apit.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,64 @@\n+// run-pass\n+// aux-build:fn-aux.rs\n+\n+#![feature(associated_type_bounds)]\n+\n+extern crate fn_aux;\n+\n+use fn_aux::*;\n+\n+// ATB, APIT + Wrap:\n+\n+struct Wrap<T>(T);\n+\n+fn wrap_apit_bound(beta: Wrap<impl Beta<Gamma: Alpha>>) -> usize {\n+    desugared_bound(beta.0)\n+}\n+\n+fn wrap_apit_bound_region(beta: Wrap<impl Beta<Gamma: 'static>>) -> usize {\n+    desugared_bound_region(beta.0)\n+}\n+\n+fn wrap_apit_bound_multi(\n+    beta: Wrap<impl Copy + Beta<Gamma: Alpha + 'static + Delta>>\n+) -> usize {\n+    desugared_bound_multi(beta.0)\n+}\n+\n+fn wrap_apit_bound_region_forall(\n+    beta: Wrap<impl Beta<Gamma: Copy + for<'a> Epsilon<'a>>>\n+) -> usize {\n+    desugared_bound_region_forall(beta.0)\n+}\n+\n+fn wrap_apit_bound_region_forall2(\n+    beta: Wrap<impl Beta<Gamma: Copy + for<'a> Epsilon<'a, Zeta: Eta>>>\n+) -> usize {\n+    desugared_bound_region_forall2(beta.0)\n+}\n+\n+fn wrap_apit_bound_nested(\n+    beta: Wrap<impl Beta<Gamma: Copy + Alpha + Beta<Gamma: Delta>>>\n+) -> usize {\n+    desugared_bound_nested(beta.0)\n+}\n+\n+fn wrap_apit_bound_nested2(\n+    beta: Wrap<impl Beta<Gamma = impl Copy + Alpha + Beta<Gamma: Delta>>>\n+) -> usize {\n+    desugared_bound_nested(beta.0)\n+}\n+\n+fn main() {\n+    let beta = BetaType;\n+    let _gamma = beta.gamma();\n+\n+    assert_eq!(42, wrap_apit_bound(Wrap(beta)));\n+    assert_eq!(24, wrap_apit_bound_region(Wrap(beta)));\n+    assert_eq!(42 + 24 + 1337, wrap_apit_bound_multi(Wrap(beta)));\n+    assert_eq!(7331 * 2, wrap_apit_bound_region_forall(Wrap(beta)));\n+    // FIXME: requires lazy normalization.\n+    // assert_eq!(7331 * 2, wrap_apit_bound_region_forall2(Wrap(beta)));\n+    assert_eq!(42 + 1337, wrap_apit_bound_nested(Wrap(beta)));\n+    assert_eq!(42 + 1337, wrap_apit_bound_nested2(Wrap(beta)));\n+}"}, {"sha": "4dbaab50a61db14cc05ae38bf2f7a7408caf3638", "filename": "src/test/ui/associated-type-bounds/implied-region-constraints.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,47 @@\n+// compile-fail\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+\n+struct St<'a, 'b, T: Tr1<As1: Tr2>> { // `T: 'b` is *not* implied!\n+    f0: &'a T, // `T: 'a` is implied.\n+    f1: &'b <T::As1 as Tr2>::As2, // `<T::As1 as Tr2>::As2: 'a` is implied.\n+}\n+\n+fn _bad_st<'a, 'b, T>(x: St<'a, 'b, T>)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    // This should fail because `T: 'b` is not implied from `WF(St<'a, 'b, T>)`.\n+    let _failure_proves_not_implied_outlives_region_b: &'b T = &x.f0;\n+    //~^ ERROR lifetime mismatch [E0623]\n+}\n+\n+enum En7<'a, 'b, T> // `<T::As1 as Tr2>::As2: 'a` is implied.\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    V0(&'a T),\n+    V1(&'b <T::As1 as Tr2>::As2),\n+}\n+\n+fn _bad_en7<'a, 'b, T>(x: En7<'a, 'b, T>)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    match x {\n+        En7::V0(x) => {\n+            // Also fails for the same reason as above:\n+            let _failure_proves_not_implied_outlives_region_b: &'b T = &x;\n+            //~^ ERROR lifetime mismatch [E0623]\n+        },\n+        En7::V1(_) => {},\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b07b20272a8c05bbd52b5bbc569d54e2bbb59a35", "filename": "src/test/ui/associated-type-bounds/implied-region-constraints.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fimplied-region-constraints.stderr?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,25 @@\n+error[E0623]: lifetime mismatch\n+  --> $DIR/implied-region-constraints.rs:19:64\n+   |\n+LL | fn _bad_st<'a, 'b, T>(x: St<'a, 'b, T>)\n+   |                          -------------\n+   |                          |\n+   |                          this type is declared with multiple lifetimes...\n+...\n+LL |     let _failure_proves_not_implied_outlives_region_b: &'b T = &x.f0;\n+   |                                                                ^^^^^ ...but data with one lifetime flows into the other here\n+\n+error[E0623]: lifetime mismatch\n+  --> $DIR/implied-region-constraints.rs:40:72\n+   |\n+LL | fn _bad_en7<'a, 'b, T>(x: En7<'a, 'b, T>)\n+   |                           --------------\n+   |                           |\n+   |                           this type is declared with multiple lifetimes...\n+...\n+LL |             let _failure_proves_not_implied_outlives_region_b: &'b T = &x;\n+   |                                                                        ^^ ...but data with one lifetime flows into the other here\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0623`."}, {"sha": "1257dc6e94b397d0119ea27c9490d9dee282f3b1", "filename": "src/test/ui/associated-type-bounds/inside-adt.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,36 @@\n+// compile-fail\n+// ignore-tidy-linelength\n+// error-pattern:could not find defining uses\n+\n+#![feature(associated_type_bounds)]\n+#![feature(untagged_unions)]\n+\n+struct S1 { f: dyn Iterator<Item: Copy> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+struct S3 { f: dyn Iterator<Item: 'static> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+\n+enum E1 { V(dyn Iterator<Item: Copy>) }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+enum E3 { V(dyn Iterator<Item: 'static>) }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+\n+union U1 { f: dyn Iterator<Item: Copy> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+union U2 { f: Box<dyn Iterator<Item: Copy>> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+union U3 { f: dyn Iterator<Item: 'static> }\n+//~^ associated type bounds are not allowed within structs, enums, or unions\n+//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]"}, {"sha": "7bdd71b8296ff55359b1e86b958e44f2ba88d64f", "filename": "src/test/ui/associated-type-bounds/inside-adt.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,79 @@\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:8:29\n+   |\n+LL | struct S1 { f: dyn Iterator<Item: Copy> }\n+   |                             ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:11:33\n+   |\n+LL | struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n+   |                                 ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:14:29\n+   |\n+LL | struct S3 { f: dyn Iterator<Item: 'static> }\n+   |                             ^^^^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:18:26\n+   |\n+LL | enum E1 { V(dyn Iterator<Item: Copy>) }\n+   |                          ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:21:30\n+   |\n+LL | enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n+   |                              ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:24:26\n+   |\n+LL | enum E3 { V(dyn Iterator<Item: 'static>) }\n+   |                          ^^^^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:28:28\n+   |\n+LL | union U1 { f: dyn Iterator<Item: Copy> }\n+   |                            ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:31:32\n+   |\n+LL | union U2 { f: Box<dyn Iterator<Item: Copy>> }\n+   |                                ^^^^^^^^^^\n+\n+error: associated type bounds are not allowed within structs, enums, or unions\n+  --> $DIR/inside-adt.rs:34:28\n+   |\n+LL | union U3 { f: dyn Iterator<Item: 'static> }\n+   |                            ^^^^^^^^^^^^^\n+\n+error[E0601]: `main` function not found in crate `inside_adt`\n+   |\n+   = note: consider adding a `main` function to `$DIR/inside-adt.rs`\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: could not find defining uses\n+\n+error: aborting due to 19 previous errors\n+\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "85b6e804b4ef63cd2e1ad2f1dc81f6394089f696", "filename": "src/test/ui/associated-type-bounds/lcsit.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Flcsit.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,78 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(impl_trait_in_bindings)]\n+\n+#![allow(non_upper_case_globals)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(&self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+#[derive(Copy, Clone)]\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(&self) -> Self::As1 { S2 } }\n+\n+const cdef_et1: impl Copy + Tr1<As1: Copy> = {\n+    let x: impl Copy + Tr1<As1: Copy> = S1;\n+    x\n+};\n+static sdef_et1: impl Copy + Tr1<As1: Copy> = cdef_et1;\n+pub fn use_et1() { assert_copy(cdef_et1.mk()); assert_copy(sdef_et1.mk()); }\n+\n+const cdef_et2: impl Tr1<As1: 'static> = {\n+    let x: impl Tr1<As1: 'static> = S1;\n+    x\n+};\n+static sdef_et2: impl Tr1<As1: 'static> = cdef_et2;\n+pub fn use_et2() { assert_static(cdef_et2.mk()); assert_static(sdef_et2.mk()); }\n+\n+const cdef_et3: impl Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> = {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(&self) -> Self::As1 { 0..10 }\n+    };\n+    let x: impl Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> = A;\n+    x\n+};\n+pub fn use_et3() {\n+    let _0 = cdef_et3.mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+const cdef_et4: impl Copy + Tr1<As1: for<'a> Tr2<'a>> = {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(&self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    let x: impl Copy + Tr1<As1: for<'a> Tr2<'a>> = A;\n+    x\n+};\n+\n+static sdef_et4: impl Copy + Tr1<As1: for<'a> Tr2<'a>> = cdef_et4;\n+pub fn use_et4() { assert_forall_tr2(cdef_et4.mk()); assert_forall_tr2(sdef_et4.mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "25c2c2916f3bcf399420309562c31377c2ba85d0", "filename": "src/test/ui/associated-type-bounds/nested-lifetime-bounds.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fnested-lifetime-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fnested-lifetime-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fnested-lifetime-bounds.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,25 @@\n+// compile-fail\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::fmt::Debug;\n+\n+trait Lam<Binder> { type App; }\n+\n+fn nested_bounds<_0, _1, _2, D>()\n+where\n+    D: Clone + Iterator<Item: Send + for<'a> Iterator<Item: for<'b> Lam<&'a &'b u8, App = _0>>>,\n+    //~^ ERROR nested quantification of lifetimes [E0316]\n+    _0: Debug,\n+{}\n+\n+fn nested_bounds_desugared<_0, _1, _2, D>()\n+where\n+    D: Clone + Iterator<Item = _2>,\n+    _2: Send + for<'a> Iterator,\n+    for<'a> <_2 as Iterator>::Item: for<'b> Lam<&'a &'b u8, App = _0>,\n+    //~^ ERROR nested quantification of lifetimes [E0316]\n+    _0: Debug,\n+{}\n+\n+fn main() {}"}, {"sha": "44fa9e89d3502c3b1c8c858c7f34243827f9b1e0", "filename": "src/test/ui/associated-type-bounds/nested-lifetime-bounds.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fnested-lifetime-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fnested-lifetime-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fnested-lifetime-bounds.stderr?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,9 @@\n+error[E0316]: nested quantification of lifetimes\n+  --> $DIR/nested-lifetime-bounds.rs:20:37\n+   |\n+LL |     for<'a> <_2 as Iterator>::Item: for<'b> Lam<&'a &'b u8, App = _0>,\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0316`."}, {"sha": "7b640d5a457dfceb283376a4c64c5b70d354fcf3", "filename": "src/test/ui/associated-type-bounds/rpit.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Frpit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Frpit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Frpit.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,64 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::ops::Add;\n+\n+trait Tr1 { type As1; fn mk(self) -> Self::As1; }\n+trait Tr2<'a> { fn tr2(self) -> &'a Self; }\n+\n+fn assert_copy<T: Copy>(x: T) { let _x = x; let _x = x; }\n+fn assert_static<T: 'static>(_: T) {}\n+fn assert_forall_tr2<T: for<'a> Tr2<'a>>(_: T) {}\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; fn mk(self) -> Self::As1 { S2 } }\n+\n+fn def_et1() -> impl Tr1<As1: Copy> { S1 }\n+pub fn use_et1() { assert_copy(def_et1().mk()); }\n+\n+fn def_et2() -> impl Tr1<As1: 'static> { S1 }\n+pub fn use_et2() { assert_static(def_et2().mk()); }\n+\n+fn def_et3() -> impl Tr1<As1: Clone + Iterator<Item: Add<u8, Output: Into<u8>>>> {\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = core::ops::Range<u8>;\n+        fn mk(self) -> Self::As1 { 0..10 }\n+    };\n+    A\n+}\n+\n+pub fn use_et3() {\n+    let _0 = def_et3().mk().clone();\n+    let mut s = 0u8;\n+    for _1 in _0 {\n+        let _2 = _1 + 1u8;\n+        s += _2.into();\n+    }\n+    assert_eq!(s, (0..10).map(|x| x + 1).sum());\n+}\n+\n+fn def_et4() -> impl Tr1<As1: for<'a> Tr2<'a>> {\n+    #[derive(Copy, Clone)]\n+    struct A;\n+    impl Tr1 for A {\n+        type As1 = A;\n+        fn mk(self) -> A { A }\n+    }\n+    impl<'a> Tr2<'a> for A {\n+        fn tr2(self) -> &'a Self { &A }\n+    }\n+    A\n+}\n+\n+pub fn use_et4() { assert_forall_tr2(def_et4().mk()); }\n+\n+fn main() {\n+    let _ = use_et1();\n+    let _ = use_et2();\n+    let _ = use_et3();\n+    let _ = use_et4();\n+}"}, {"sha": "2d189cd66724a33f51eba3a319bbb8021737c98f", "filename": "src/test/ui/associated-type-bounds/struct-bounds.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fstruct-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fstruct-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fstruct-bounds.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,115 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+trait Tr3 {}\n+trait Tr4<'a> { type As4; }\n+trait Tr5 { type As5; }\n+\n+impl Tr1 for &str { type As1 = bool; }\n+impl Tr2 for bool { type As2 = u8; }\n+impl Tr3 for u8 {}\n+impl Tr1 for () { type As1 = (usize,); }\n+impl<'a> Tr4<'a> for (usize,) { type As4 = u8; }\n+impl Tr5 for bool { type As5 = u16; }\n+\n+struct St1<T: Tr1<As1: Tr2>> {\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+fn unwrap_1_st1<T: Tr1<As1: Tr2>>(x: St1<T>) -> (T, T::As1, <T::As1 as Tr2>::As2) {\n+    (x.outest, x.outer, x.inner)\n+}\n+\n+fn unwrap_2_st1<T>(x: St1<T>) -> (T, T::As1, <T::As1 as Tr2>::As2)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    unwrap_1_st1(x)\n+}\n+\n+struct St2<T: Tr1<As1: Tr2<As2: Tr3>>> {\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+struct St3<T: Tr1<As1: 'static>> {\n+    outest: T,\n+    outer: &'static T::As1,\n+}\n+\n+struct St4<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l>>> {\n+    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\n+    f2: &'x2 <T::As1 as Tr4<'x2>>::As4,\n+}\n+\n+struct St5<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l, As4: Copy>>> {\n+    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\n+    f2: &'x2 <T::As1 as Tr4<'x2>>::As4,\n+}\n+\n+struct St6<T>\n+where\n+    T: Tr1<As1: Tr2 + 'static + Tr5>,\n+{\n+    f0: T,\n+    f1: <T::As1 as Tr2>::As2,\n+    f2: &'static T::As1,\n+    f3: <T::As1 as Tr5>::As5,\n+}\n+\n+struct St7<'a, 'b, T> // `<T::As1 as Tr2>::As2: 'a` is implied.\n+where\n+    T: Tr1<As1: Tr2>,\n+{\n+    f0: &'a T,\n+    f1: &'b <T::As1 as Tr2>::As2,\n+}\n+\n+fn _use_st7<'a, 'b, T>(x: St7<'a, 'b, T>)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    let _: &'a T = &x.f0;\n+}\n+\n+struct StSelf<T> where Self: Tr1<As1: Tr2> {\n+    f2: <<Self as Tr1>::As1 as Tr2>::As2,\n+}\n+\n+impl Tr1 for StSelf<&'static str> { type As1 = bool; }\n+\n+fn main() {\n+    let st1 = St1 { outest: \"foo\", outer: true, inner: 42u8 };\n+    assert_eq!((\"foo\", true, 42), unwrap_1_st1(st1));\n+\n+    let _ = St2 { outest: \"foo\", outer: true, inner: 42u8 };\n+\n+    let _ = St3 { outest: \"foo\", outer: &true };\n+\n+    let f1 = (1,);\n+    let f2 = (2,);\n+    let st4 = St4::<()> { f1: &f1.0, f2: &f2.0, };\n+    assert_eq!((&1, &2), (st4.f1, st4.f2));\n+\n+    // FIXME: requires lazy normalization.\n+    /*\n+    let f1 = (1,);\n+    let f2 = (2,);\n+    let st5 = St5::<()> { f1: &f1.0, f2: &f2.0, };\n+    assert_eq!((&1, &2), (st5.f1, st5.f2));\n+    */\n+\n+    let st6 = St6 { f0: \"bar\", f1: 24u8, f2: &true, f3: 12u16, };\n+    assert_eq!((\"bar\", 24, &true, 12), (st6.f0, st6.f1, st6.f2, st6.f3));\n+\n+    let stself = StSelf::<&'static str> { f2: 42u8 };\n+    assert_eq!(stself.f2, 42u8);\n+}"}, {"sha": "a9081d50cfc5dd989c102a8dcca45b83bd9a50c6", "filename": "src/test/ui/associated-type-bounds/trait-params.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,116 @@\n+// compile-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+use std::iter::Once;\n+use std::ops::Range;\n+\n+pub trait Three { type A; type B; type C; }\n+pub fn assert_three<T: ?Sized + Three>() {}\n+pub fn assert_iterator<T: Iterator>() {}\n+pub fn assert_copy<T: Copy>() {}\n+pub fn assert_static<T: 'static>() {}\n+pub fn assert_send<T: Send>() {}\n+pub fn assert_forall_into<T: for<'a> Into<&'a u8>>() {}\n+\n+struct A; struct B;\n+impl<'a> Into<&'a u8> for A { fn into(self) -> &'a u8 { &0 } }\n+impl Three for B { type A = Range<u8>; type B = Range<u8>; type C = Range<u8>; }\n+\n+trait Case1<A, B, C, D, E>\n+where\n+    A: Iterator<Item: Copy>,\n+    B: Iterator<Item: 'static>,\n+    C: Iterator<Item: 'static + Copy + Send>,\n+    D: Iterator<Item: for<'a> Into<&'a u8>>,\n+    E: Three<A: Iterator<Item: Copy>, B: Iterator<Item: Copy>, C: Iterator<Item: Copy>>,\n+    Self: Three<A: 'static, B: Copy, C: Send>,\n+{\n+    fn _a() {\n+        assert_iterator::<A>();\n+        assert_copy::<A::Item>();\n+    }\n+    fn _b() {\n+        assert_iterator::<B>();\n+        assert_static::<B::Item>();\n+    }\n+    fn _c() {\n+        assert_iterator::<C>();\n+        assert_copy::<C::Item>();\n+        assert_static::<C::Item>();\n+        assert_send::<C::Item>();\n+    }\n+    fn _d() {\n+        assert_iterator::<D>();\n+        assert_forall_into::<D::Item>();\n+    }\n+    fn _e() {\n+        assert_three::<E>();\n+        assert_iterator::<E::A>();\n+        assert_iterator::<E::B>();\n+        assert_iterator::<E::C>();\n+        assert_copy::<<E::A as Iterator>::Item>();\n+        assert_copy::<<E::B as Iterator>::Item>();\n+        assert_copy::<<E::C as Iterator>::Item>();\n+    }\n+    fn _self() {\n+        assert_three::<Self>();\n+        assert_copy::<Self::B>();\n+        assert_static::<Self::A>();\n+        assert_send::<Self::C>();\n+    }\n+}\n+\n+struct DataCase1;\n+impl Three for DataCase1 { type A = u8; type B = u8; type C = u8; }\n+impl Case1<Range<u8>, Range<u8>, Range<u8>, Once<A>, B> for DataCase1 {}\n+\n+trait Case2<\n+    A: Iterator<Item: Copy>,\n+    B: Iterator<Item: 'static>,\n+    C: Iterator<Item: 'static + Copy + Send>,\n+    D: Iterator<Item: for<'a> Into<&'a u8>>,\n+    E: Three<A: Iterator<Item: Copy>, B: Iterator<Item: Copy>, C: Iterator<Item: Copy>>,\n+>:\n+    Three<A: 'static, B: Copy, C: Send>\n+{\n+    fn _a() {\n+        assert_iterator::<A>();\n+        assert_copy::<A::Item>();\n+    }\n+    fn _b() {\n+        assert_iterator::<B>();\n+        assert_static::<B::Item>();\n+    }\n+    fn _c() {\n+        assert_iterator::<C>();\n+        assert_copy::<C::Item>();\n+        assert_static::<C::Item>();\n+        assert_send::<C::Item>();\n+    }\n+    fn _d() {\n+        assert_iterator::<D>();\n+        assert_forall_into::<D::Item>();\n+    }\n+    fn _e() {\n+        assert_three::<E>();\n+        assert_iterator::<E::A>();\n+        assert_iterator::<E::B>();\n+        assert_iterator::<E::C>();\n+        assert_copy::<<E::A as Iterator>::Item>();\n+        assert_copy::<<E::B as Iterator>::Item>();\n+        assert_copy::<<E::C as Iterator>::Item>();\n+    }\n+    fn _self() {\n+        assert_three::<Self>();\n+        assert_copy::<Self::B>();\n+        assert_static::<Self::A>();\n+        assert_send::<Self::C>();\n+    }\n+}\n+\n+struct DataCase2;\n+impl Three for DataCase2 { type A = u8; type B = u8; type C = u8; }\n+impl Case2<Range<u8>, Range<u8>, Range<u8>, Once<A>, B> for DataCase2 {}\n+\n+fn main() {}"}, {"sha": "1602fdd275a2e9e7e5e16883e680c5efdf6f2f04", "filename": "src/test/ui/associated-type-bounds/type-alias.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,19 @@\n+// compile-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n+type _TaWhere2<T> where T: Iterator<Item: 'static> = T;\n+type _TaWhere3<T> where T: Iterator<Item: 'static> = T;\n+type _TaWhere4<T> where T: Iterator<Item: 'static + Copy + Send> = T;\n+type _TaWhere5<T> where T: Iterator<Item: for<'a> Into<&'a u8>> = T;\n+type _TaWhere6<T> where T: Iterator<Item: Iterator<Item: Copy>> = T;\n+\n+type _TaInline1<T: Iterator<Item: Copy>> = T;\n+type _TaInline2<T: Iterator<Item: 'static>> = T;\n+type _TaInline3<T: Iterator<Item: 'static>> = T;\n+type _TaInline4<T: Iterator<Item: 'static + Copy + Send>> = T;\n+type _TaInline5<T: Iterator<Item: for<'a> Into<&'a u8>>> = T;\n+type _TaInline6<T: Iterator<Item: Iterator<Item: Copy>>> = T;\n+\n+fn main() {}"}, {"sha": "b93fc393ae32c9a02deff95e015a51f51a4e6e4a", "filename": "src/test/ui/associated-type-bounds/type-alias.stderr", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftype-alias.stderr?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,97 @@\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:5:25\n+   |\n+LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(type_alias_bounds)] on by default\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:6:25\n+   |\n+LL | type _TaWhere2<T> where T: Iterator<Item: 'static> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:7:25\n+   |\n+LL | type _TaWhere3<T> where T: Iterator<Item: 'static> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:8:25\n+   |\n+LL | type _TaWhere4<T> where T: Iterator<Item: 'static + Copy + Send> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:9:25\n+   |\n+LL | type _TaWhere5<T> where T: Iterator<Item: for<'a> Into<&'a u8>> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: where clauses are not enforced in type aliases\n+  --> $DIR/type-alias.rs:10:25\n+   |\n+LL | type _TaWhere6<T> where T: Iterator<Item: Iterator<Item: Copy>> = T;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the clause will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:12:20\n+   |\n+LL | type _TaInline1<T: Iterator<Item: Copy>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:13:20\n+   |\n+LL | type _TaInline2<T: Iterator<Item: 'static>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:14:20\n+   |\n+LL | type _TaInline3<T: Iterator<Item: 'static>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:15:20\n+   |\n+LL | type _TaInline4<T: Iterator<Item: 'static + Copy + Send>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:16:20\n+   |\n+LL | type _TaInline5<T: Iterator<Item: for<'a> Into<&'a u8>>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+\n+warning: bounds on generic parameters are not enforced in type aliases\n+  --> $DIR/type-alias.rs:17:20\n+   |\n+LL | type _TaInline6<T: Iterator<Item: Iterator<Item: Copy>>> = T;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the bound will not be checked when the type alias is used, and should be removed\n+"}, {"sha": "ce482fff401c886b989c5e4d9bce07d29881523a", "filename": "src/test/ui/associated-type-bounds/union-bounds.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,123 @@\n+// run-pass\n+\n+#![feature(associated_type_bounds)]\n+#![feature(untagged_unions)]\n+\n+#![allow(unions_with_drop_fields, unused_assignments)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+trait Tr3 { type As3; }\n+trait Tr4<'a> { type As4; }\n+trait Tr5 { type As5; }\n+\n+impl Tr1 for &str { type As1 = bool; }\n+impl Tr2 for bool { type As2 = u8; }\n+impl Tr3 for u8 { type As3 = fn() -> u8; }\n+impl Tr1 for () { type As1 = (usize,); }\n+impl<'a> Tr4<'a> for (usize,) { type As4 = u8; }\n+impl Tr5 for bool { type As5 = u16; }\n+\n+union Un1<T: Tr1<As1: Tr2>> {\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+union Un2<T: Tr1<As1: Tr2<As2: Tr3>>> {\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+union Un3<T: Tr1<As1: 'static>> {\n+    outest: T,\n+    outer: &'static T::As1,\n+}\n+\n+union Un4<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l>>> {\n+    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\n+    f2: &'x2 <T::As1 as Tr4<'x2>>::As4,\n+}\n+\n+union _Un5<'x1, 'x2, T: Tr1<As1: for<'l> Tr4<'l, As4: Copy>>> {\n+    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\n+    f2: &'x2 <T::As1 as Tr4<'x2>>::As4,\n+}\n+\n+union Un6<T>\n+where\n+    T: Tr1<As1: Tr2 + 'static + Tr5>,\n+{\n+    f0: T,\n+    f1: <T::As1 as Tr2>::As2,\n+    f2: &'static T::As1,\n+    f3: <T::As1 as Tr5>::As5,\n+}\n+\n+union _Un7<'a, 'b, T> // `<T::As1 as Tr2>::As2: 'a` is implied.\n+where\n+    T: Tr1<As1: Tr2>,\n+{\n+    f0: &'a T,\n+    f1: &'b <T::As1 as Tr2>::As2,\n+}\n+\n+unsafe fn _use_un7<'a, 'b, T>(x: _Un7<'a, 'b, T>)\n+where\n+    T: Tr1,\n+    T::As1: Tr2,\n+{\n+    let _: &'a T = &x.f0;\n+}\n+\n+union UnSelf<T> where Self: Tr1<As1: Tr2> {\n+    f0: T,\n+    f1: <Self as Tr1>::As1,\n+    f2: <<Self as Tr1>::As1 as Tr2>::As2,\n+}\n+\n+impl Tr1 for UnSelf<&'static str> { type As1 = bool; }\n+\n+fn main() {\n+    let mut un1 = Un1 { outest: \"foo\" };\n+    un1 = Un1 { outer: true };\n+    assert_eq!(unsafe { un1.outer }, true);\n+    un1 = Un1 { inner: 42u8 };\n+    assert_eq!(unsafe { un1.inner }, 42u8);\n+\n+    let mut un2 = Un2 { outest: \"bar\" };\n+    assert_eq!(unsafe { un2.outest }, \"bar\");\n+    un2 = Un2 { outer: true };\n+    assert_eq!(unsafe { un2.outer }, true);\n+    un2 = Un2 { inner: 42u8 };\n+    assert_eq!(unsafe { un2.inner }, 42u8);\n+\n+    let mut un3 = Un3 { outest: \"baz\" };\n+    assert_eq!(unsafe { un3.outest }, \"baz\");\n+    un3 = Un3 { outer: &true };\n+    assert_eq!(unsafe { *un3.outer }, true);\n+\n+    let f1 = (1,);\n+    let f2 = (2,);\n+    let mut un4 = Un4::<()> { f1: &f1.0 };\n+    assert_eq!(1, unsafe { *un4.f1 });\n+    un4 = Un4 { f2: &f2.0 };\n+    assert_eq!(2, unsafe { *un4.f2 });\n+\n+    let mut un6 = Un6 { f0: \"bar\" };\n+    assert_eq!(unsafe { un6.f0 }, \"bar\");\n+    un6 = Un6 { f1: 24u8 };\n+    assert_eq!(unsafe { un6.f1 }, 24u8);\n+    un6 = Un6 { f2: &true };\n+    assert_eq!(unsafe { un6.f2 }, &true);\n+    un6 = Un6 { f3: 12u16 };\n+    assert_eq!(unsafe { un6.f3 }, 12u16);\n+\n+    let mut unself = UnSelf::<_> { f0: \"selfish\" };\n+    assert_eq!(unsafe { unself.f0 }, \"selfish\");\n+    unself = UnSelf { f1: true };\n+    assert_eq!(unsafe { unself.f1 }, true);\n+    unself = UnSelf { f2: 24u8 };\n+    assert_eq!(unsafe { unself.f2 }, 24u8);\n+}"}, {"sha": "6b4f5005d48f06807e516e70b4df79fe73f765e0", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,71 @@\n+#![feature(untagged_unions)]\n+\n+trait Tr1 { type As1; }\n+trait Tr2 { type As2; }\n+\n+struct S1;\n+#[derive(Copy, Clone)]\n+struct S2;\n+impl Tr1 for S1 { type As1 = S2; }\n+\n+trait _Tr3 {\n+    type A: Iterator<Item: Copy>;\n+    //~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+\n+    type B: Iterator<Item: 'static>;\n+    //~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+}\n+\n+struct _St1<T: Tr1<As1: Tr2>> {\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+enum _En1<T: Tr1<As1: Tr2>> {\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+    Outest(T),\n+    Outer(T::As1),\n+    Inner(<T::As1 as Tr2>::As2),\n+}\n+\n+union _Un1<T: Tr1<As1: Tr2>> {\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+    outest: T,\n+    outer: T::As1,\n+    inner: <T::As1 as Tr2>::As2,\n+}\n+\n+type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+\n+fn _apit(_: impl Tr1<As1: Copy>) {}\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+\n+fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+\n+const _cdef: impl Tr1<As1: Copy> = S1;\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+//~| ERROR `impl Trait` not allowed outside of function and inherent method return types [E0562]\n+// FIXME: uncomment when `impl_trait_in_bindings` feature is fixed.\n+// const _cdef_dyn: &dyn Tr1<As1: Copy> = &S1;\n+\n+static _sdef: impl Tr1<As1: Copy> = S1;\n+//~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+//~| ERROR `impl Trait` not allowed outside of function and inherent method return types [E0562]\n+// FIXME: uncomment when `impl_trait_in_bindings` feature is fixed.\n+// static _sdef_dyn: &dyn Tr1<As1: Copy> = &S1;\n+\n+fn main() {\n+    let _: impl Tr1<As1: Copy> = S1;\n+    //~^ ERROR associated type bounds are unstable (see issue #52662) [E0658]\n+    //~| ERROR `impl Trait` not allowed outside of function and inherent method return types [E0562]\n+    // FIXME: uncomment when `impl_trait_in_bindings` feature is fixed.\n+    // let _: &dyn Tr1<As1: Copy> = &S1;\n+}"}, {"sha": "9b83c1cfb33d1083d12058a5ee92fcc5bacbc17c", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.stderr", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -0,0 +1,132 @@\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:12:22\n+   |\n+LL |     type A: Iterator<Item: Copy>;\n+   |                      ^^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:15:22\n+   |\n+LL |     type B: Iterator<Item: 'static>;\n+   |                      ^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:19:20\n+   |\n+LL | struct _St1<T: Tr1<As1: Tr2>> {\n+   |                    ^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:26:18\n+   |\n+LL | enum _En1<T: Tr1<As1: Tr2>> {\n+   |                  ^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:33:19\n+   |\n+LL | union _Un1<T: Tr1<As1: Tr2>> {\n+   |                   ^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:40:37\n+   |\n+LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n+   |                                     ^^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:43:22\n+   |\n+LL | fn _apit(_: impl Tr1<As1: Copy>) {}\n+   |                      ^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:45:26\n+   |\n+LL | fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n+   |                          ^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:48:24\n+   |\n+LL | fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n+   |                        ^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:50:31\n+   |\n+LL | fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n+   |                               ^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:53:23\n+   |\n+LL | const _cdef: impl Tr1<As1: Copy> = S1;\n+   |                       ^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:59:24\n+   |\n+LL | static _sdef: impl Tr1<As1: Copy> = S1;\n+   |                        ^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0658]: associated type bounds are unstable (see issue #52662)\n+  --> $DIR/feature-gate-associated_type_bounds.rs:66:21\n+   |\n+LL |     let _: impl Tr1<As1: Copy> = S1;\n+   |                     ^^^^^^^^^\n+   |\n+   = help: add #![feature(associated_type_bounds)] to the crate attributes to enable\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-associated_type_bounds.rs:53:14\n+   |\n+LL | const _cdef: impl Tr1<As1: Copy> = S1;\n+   |              ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-associated_type_bounds.rs:59:15\n+   |\n+LL | static _sdef: impl Tr1<As1: Copy> = S1;\n+   |               ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-associated_type_bounds.rs:66:12\n+   |\n+LL |     let _: impl Tr1<As1: Copy> = S1;\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(impl_trait_in_bindings)] to the crate attributes to enable\n+\n+error: aborting due to 16 previous errors\n+\n+Some errors occurred: E0562, E0658.\n+For more information about an error, try `rustc --explain E0562`."}, {"sha": "177e5f893ed662333786b77d16ea0dd049d03592", "filename": "src/test/ui/type/type-alias-bounds.stderr", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4310ba2c985c161260bbdfef5d92ceea552e9055/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-alias-bounds.stderr?ref=4310ba2c985c161260bbdfef5d92ceea552e9055", "patch": "@@ -1,13 +1,3 @@\n-warning: duplicate auto trait `::marker[0]::Send[0]` found in type parameter bounds\n-  --> $DIR/type-alias-bounds.rs:8:14\n-   |\n-LL | type SVec<T: Send + Send> = Vec<T>;\n-   |              ^^^^   ^^^^ subsequent use of auto trait\n-   |              |\n-   |              first use of auto trait\n-   |\n-   = note: #[warn(duplicate_auto_traits_in_bounds)] on by default\n-\n warning: bounds on generic parameters are not enforced in type aliases\n   --> $DIR/type-alias-bounds.rs:8:14\n    |"}]}