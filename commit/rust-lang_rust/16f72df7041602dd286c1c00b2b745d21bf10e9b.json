{"sha": "16f72df7041602dd286c1c00b2b745d21bf10e9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZjcyZGY3MDQxNjAyZGQyODZjMWMwMGIyYjc0NWQyMWJmMTBlOWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-28T22:08:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-28T22:49:58Z"}, "message": "Merge remote-tracking branch 'erickt/time'\n\nConflicts:\n\tsrc/libstd/time.rs", "tree": {"sha": "9227bb7e7db96be0d1dd6cd77d79f8a00e61ce06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9227bb7e7db96be0d1dd6cd77d79f8a00e61ce06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16f72df7041602dd286c1c00b2b745d21bf10e9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16f72df7041602dd286c1c00b2b745d21bf10e9b", "html_url": "https://github.com/rust-lang/rust/commit/16f72df7041602dd286c1c00b2b745d21bf10e9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16f72df7041602dd286c1c00b2b745d21bf10e9b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42c2c2ab2f4dfa350dd01d33025cd5027a358d33", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c2c2ab2f4dfa350dd01d33025cd5027a358d33", "html_url": "https://github.com/rust-lang/rust/commit/42c2c2ab2f4dfa350dd01d33025cd5027a358d33"}, {"sha": "32763caa600857bc0116a9221e4a94431b5b6907", "url": "https://api.github.com/repos/rust-lang/rust/commits/32763caa600857bc0116a9221e4a94431b5b6907", "html_url": "https://github.com/rust-lang/rust/commit/32763caa600857bc0116a9221e4a94431b5b6907"}], "stats": {"total": 286, "additions": 172, "deletions": 114}, "files": [{"sha": "f4530a28633869c32cc4d6b91a7dab1dc846703e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=16f72df7041602dd286c1c00b2b745d21bf10e9b", "patch": "@@ -1643,7 +1643,7 @@ fn trans_fn(ccx: @crate_ctxt,\n             impl_id: Option<ast::def_id>) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n-                else { {sec: 0i64, nsec: 0i32} };\n+                else { time::Timespec::new(0, 0) };\n     debug!(\"trans_fn(ty_self=%?)\", ty_self);\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;"}, {"sha": "a22bbe1cd6f4b8170d6da0728d63caea7005b7e5", "filename": "src/libstd/std.rc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=16f72df7041602dd286c1c00b2b745d21bf10e9b", "patch": "@@ -96,6 +96,14 @@ mod unicode;\n pub mod test;\n pub mod serialization;\n \n+// A curious inner-module that's not exported that contains the binding\n+// 'std' so that macro-expanded references to std::serialization and such\n+// can be resolved within libcore.\n+#[doc(hidden)] // FIXME #3538\n+mod std {\n+    pub use serialization;\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "d8cbfbadb1f20501f92fab0389ba9db967b0ddd3", "filename": "src/libstd/time.rs", "status": "modified", "additions": 154, "deletions": 110, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=16f72df7041602dd286c1c00b2b745d21bf10e9b", "patch": "@@ -21,13 +21,21 @@ extern mod rustrt {\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n-pub type Timespec = {sec: i64, nsec: i32};\n+#[auto_serialize]\n+#[auto_deserialize]\n+pub struct Timespec { sec: i64, nsec: i32 }\n+\n+impl Timespec {\n+    static fn new(sec: i64, nsec: i32) -> Timespec {\n+        Timespec { sec: sec, nsec: nsec }\n+    }\n+}\n \n impl Timespec : Eq {\n     pure fn eq(&self, other: &Timespec) -> bool {\n-        (*self).sec == (*other).sec && (*self).nsec == (*other).nsec\n+        self.sec == other.sec && self.nsec == other.nsec\n     }\n-    pure fn ne(&self, other: &Timespec) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &Timespec) -> bool { !self.eq(other) }\n }\n \n /**\n@@ -38,7 +46,7 @@ pub fn get_time() -> Timespec {\n     let mut sec = 0i64;\n     let mut nsec = 0i32;\n     rustrt::get_time(&mut sec, &mut nsec);\n-    return {sec: sec, nsec: nsec};\n+    return Timespec::new(sec, nsec);\n }\n \n \n@@ -65,7 +73,9 @@ pub fn tzset() {\n     rustrt::rust_tzset();\n }\n \n-type Tm_ = {\n+#[auto_serialize]\n+#[auto_deserialize]\n+pub struct Tm {\n     tm_sec: i32, // seconds after the minute ~[0-60]\n     tm_min: i32, // minutes after the hour ~[0-59]\n     tm_hour: i32, // hours after midnight ~[0-23]\n@@ -78,37 +88,28 @@ type Tm_ = {\n     tm_gmtoff: i32, // offset from UTC in seconds\n     tm_zone: ~str, // timezone abbreviation\n     tm_nsec: i32, // nanoseconds\n-};\n-\n-impl Tm_ : Eq {\n-    pure fn eq(&self, other: &Tm_) -> bool {\n-        (*self).tm_sec == (*other).tm_sec &&\n-        (*self).tm_min == (*other).tm_min &&\n-        (*self).tm_hour == (*other).tm_hour &&\n-        (*self).tm_mday == (*other).tm_mday &&\n-        (*self).tm_mon == (*other).tm_mon &&\n-        (*self).tm_year == (*other).tm_year &&\n-        (*self).tm_wday == (*other).tm_wday &&\n-        (*self).tm_yday == (*other).tm_yday &&\n-        (*self).tm_isdst == (*other).tm_isdst &&\n-        (*self).tm_gmtoff == (*other).tm_gmtoff &&\n-        (*self).tm_zone == (*other).tm_zone &&\n-        (*self).tm_nsec == (*other).tm_nsec\n-    }\n-    pure fn ne(&self, other: &Tm_) -> bool { !(*self).eq(other) }\n-}\n-\n-pub enum Tm {\n-    Tm_(Tm_)\n }\n \n impl Tm : Eq {\n-    pure fn eq(&self, other: &Tm) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &Tm) -> bool { *(*self) != *(*other) }\n+    pure fn eq(&self, other: &Tm) -> bool {\n+        self.tm_sec == (*other).tm_sec &&\n+        self.tm_min == (*other).tm_min &&\n+        self.tm_hour == (*other).tm_hour &&\n+        self.tm_mday == (*other).tm_mday &&\n+        self.tm_mon == (*other).tm_mon &&\n+        self.tm_year == (*other).tm_year &&\n+        self.tm_wday == (*other).tm_wday &&\n+        self.tm_yday == (*other).tm_yday &&\n+        self.tm_isdst == (*other).tm_isdst &&\n+        self.tm_gmtoff == (*other).tm_gmtoff &&\n+        self.tm_zone == (*other).tm_zone &&\n+        self.tm_nsec == (*other).tm_nsec\n+    }\n+    pure fn ne(&self, other: &Tm) -> bool { !self.eq(other) }\n }\n \n pub pure fn empty_tm() -> Tm {\n-    Tm_({\n+    Tm {\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n         tm_hour: 0_i32,\n@@ -121,15 +122,15 @@ pub pure fn empty_tm() -> Tm {\n         tm_gmtoff: 0_i32,\n         tm_zone: ~\"\",\n         tm_nsec: 0_i32,\n-    })\n+    }\n }\n \n /// Returns the specified time in UTC\n pub fn at_utc(clock: Timespec) -> Tm {\n-    let mut {sec, nsec} = clock;\n+    let mut Timespec { sec, nsec } = clock;\n     let mut tm = empty_tm();\n     rustrt::rust_gmtime(sec, nsec, tm);\n-    tm\n+    move tm\n }\n \n /// Returns the current time in UTC\n@@ -139,10 +140,10 @@ pub fn now_utc() -> Tm {\n \n /// Returns the specified time in the local timezone\n pub fn at(clock: Timespec) -> Tm {\n-    let mut {sec, nsec} = clock;\n+    let mut Timespec { sec, nsec } = clock;\n     let mut tm = empty_tm();\n     rustrt::rust_localtime(sec, nsec, tm);\n-    tm\n+    move tm\n }\n \n /// Returns the current time in the local timezone\n@@ -158,10 +159,10 @@ pub pure fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n }\n \n /// Formats the time according to the format string.\n-pub pure fn strftime(format: &str, tm: Tm) -> ~str {\n+pub pure fn strftime(format: &str, tm: &Tm) -> ~str {\n     // unsafe only because do_strftime is annoying to make pure\n     // (it does IO with a str_reader)\n-    unsafe {do_strftime(format, tm)}\n+    move unsafe { do_strftime(format, tm) }\n }\n \n impl Tm {\n@@ -173,7 +174,7 @@ impl Tm {\n         } else {\n             rustrt::rust_mktime(self, &mut sec);\n         }\n-        { sec: sec, nsec: self.tm_nsec }\n+        Timespec::new(sec, self.tm_nsec)\n     }\n \n     /// Convert time to the local timezone\n@@ -193,7 +194,9 @@ impl Tm {\n     pure fn ctime() -> ~str { self.strftime(~\"%c\") }\n \n     /// Formats the time according to the format string.\n-    pure fn strftime(format: &str) -> ~str { strftime(format, self) }\n+    pure fn strftime(&self, format: &str) -> ~str {\n+        move strftime(format, self)\n+    }\n \n     /**\n      * Returns a time string formatted according to RFC 822.\n@@ -254,9 +257,9 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_strs(ss: &str, pos: uint, strs: &[(~str, i32)])\n       -> Option<(i32, uint)> {\n         let mut i = 0u;\n-        let len = vec::len(strs);\n+        let len = strs.len();\n         while i < len {\n-            let (needle, value) = strs[i];\n+            let &(needle, value) = &strs[i];\n \n             if match_str(ss, pos, needle) {\n                 return Some((value, pos + str::len(needle)));\n@@ -302,7 +305,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         }\n     }\n \n-    fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm_)\n+    fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm)\n       -> Result<uint, ~str> {\n         match ch {\n           'A' => match match_strs(s, pos, ~[\n@@ -372,22 +375,36 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid year\")\n           },\n           'c' => {\n-            parse_type(s, pos, 'a', tm)\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'b', tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'e', tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'T', tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'Y', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'a', tm),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'b', tm)),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'e', tm)),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'T', tm)),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'Y', tm))\n           }\n           'D' | 'x' => {\n-            parse_type(s, pos, 'm', tm)\n-                .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'd', tm))\n-                .chain(|pos| parse_char(s, pos, '/'))\n-                .chain(|pos| parse_type(s, pos, 'y', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'm', tm),\n+                    |pos| parse_char(s, pos, '/')),\n+                    |pos| parse_type(s, pos, 'd', tm)),\n+                    |pos| parse_char(s, pos, '/')),\n+                    |pos| parse_type(s, pos, 'y', tm))\n           }\n           'd' => match match_digits(s, pos, 2u, false) {\n             Some(item) => { let (v, pos) = item; tm.tm_mday = v; Ok(pos) }\n@@ -398,11 +415,16 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid day of the month\")\n           },\n           'F' => {\n-            parse_type(s, pos, 'Y', tm)\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'm', tm))\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'd', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'Y', tm),\n+                    |pos| parse_char(s, pos, '-')),\n+                    |pos| parse_type(s, pos, 'm', tm)),\n+                    |pos| parse_char(s, pos, '-')),\n+                    |pos| parse_type(s, pos, 'd', tm))\n           }\n           'H' => {\n             // FIXME (#2350): range check.\n@@ -483,18 +505,28 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             None => Err(~\"Invalid hour\")\n           },\n           'R' => {\n-            parse_type(s, pos, 'H', tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'H', tm),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'M', tm))\n           }\n           'r' => {\n-            parse_type(s, pos, 'I', tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', tm))\n-                .chain(|pos| parse_char(s, pos, ' '))\n-                .chain(|pos| parse_type(s, pos, 'p', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'I', tm),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'M', tm)),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'S', tm)),\n+                    |pos| parse_char(s, pos, ' ')),\n+                    |pos| parse_type(s, pos, 'p', tm))\n           }\n           'S' => {\n             // FIXME (#2350): range check.\n@@ -509,11 +541,16 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           //'s' {}\n           'T' | 'X' => {\n-            parse_type(s, pos, 'H', tm)\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'M', tm))\n-                .chain(|pos| parse_char(s, pos, ':'))\n-                .chain(|pos| parse_type(s, pos, 'S', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'H', tm),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'M', tm)),\n+                    |pos| parse_char(s, pos, ':')),\n+                    |pos| parse_type(s, pos, 'S', tm))\n           }\n           't' => parse_char(s, pos, '\\t'),\n           'u' => {\n@@ -528,11 +565,16 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             }\n           }\n           'v' => {\n-            parse_type(s, pos, 'e', tm)\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'b', tm))\n-                .chain(|pos| parse_char(s, pos, '-'))\n-                .chain(|pos| parse_type(s, pos, 'Y', tm))\n+                // FIXME(#3724): cleanup\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                result::chain(\n+                    move parse_type(s, pos, 'e', tm),\n+                    |pos| parse_char(s, pos, '-')),\n+                    |pos| parse_type(s, pos, 'b', tm)),\n+                    |pos| parse_char(s, pos, '-')),\n+                    |pos| parse_type(s, pos, 'Y', tm))\n           }\n           //'W' {}\n           'w' => {\n@@ -613,7 +655,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n \n     do io::with_str_reader(str::from_slice(format)) |rdr| {\n-        let mut tm = {\n+        let mut tm = Tm {\n             tm_sec: 0_i32,\n             tm_min: 0_i32,\n             tm_hour: 0_i32,\n@@ -635,19 +677,21 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             let {ch, next} = str::char_range_at(s, pos);\n \n             match rdr.read_char() {\n-              '%' => match parse_type(s, pos, rdr.read_char(), &mut tm) {\n-                Ok(next) => pos = next,\n-                  Err(copy e) => { result = Err(e); break; }\n-              },\n-              c => {\n-                if c != ch { break }\n-                pos = next;\n-              }\n+                '%' => {\n+                    match parse_type(s, pos, rdr.read_char(), &mut tm) {\n+                        Ok(next) => pos = next,\n+                        Err(move e) => { result = Err(move e); break; }\n+                    }\n+                },\n+                c => {\n+                    if c != ch { break }\n+                    pos = next;\n+                }\n             }\n         }\n \n         if pos == len && rdr.eof() {\n-            Ok(Tm_({\n+            Ok(Tm {\n                 tm_sec: tm.tm_sec,\n                 tm_min: tm.tm_min,\n                 tm_hour: tm.tm_hour,\n@@ -658,14 +702,14 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 tm_yday: tm.tm_yday,\n                 tm_isdst: tm.tm_isdst,\n                 tm_gmtoff: tm.tm_gmtoff,\n-                tm_zone: tm.tm_zone,\n+                tm_zone: copy tm.tm_zone,\n                 tm_nsec: tm.tm_nsec,\n-            }))\n-        } else { result }\n+            })\n+        } else { move result }\n     }\n }\n \n-priv fn do_strftime(format: &str, tm: Tm) -> ~str {\n+priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n       let die = || fmt!(\"strftime: can't understand this format %c \", ch);\n@@ -804,7 +848,7 @@ priv fn do_strftime(format: &str, tm: Tm) -> ~str {\n           //'x' {}\n           'Y' => int::str(tm.tm_year as int + 1900),\n           'y' => fmt!(\"%02d\", (tm.tm_year as int + 1900) % 100),\n-          'Z' => tm.tm_zone,\n+          'Z' => copy tm.tm_zone,\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = i32::abs(tm.tm_gmtoff) / 60_i32;\n@@ -823,13 +867,13 @@ priv fn do_strftime(format: &str, tm: Tm) -> ~str {\n     do io::with_str_reader(str::from_slice(format)) |rdr| {\n         while !rdr.eof() {\n             match rdr.read_char() {\n-                '%' => buf += parse_type(rdr.read_char(), &tm),\n+                '%' => buf += parse_type(rdr.read_char(), tm),\n                 ch => str::push_char(&mut buf, ch)\n             }\n         }\n     }\n \n-    buf\n+    move buf\n }\n \n #[cfg(test)]\n@@ -883,7 +927,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n         assert utc.tm_sec == 30_i32;\n@@ -905,7 +949,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let local = at(time);\n \n         error!(\"time_at: %?\", local);\n@@ -923,8 +967,8 @@ mod tests {\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n-        let zone = local.tm_zone;\n-        assert zone == ~\"PST\" || zone == ~\"Pacific Standard Time\";\n+        let zone = &local.tm_zone;\n+        assert *zone == ~\"PST\" || *zone == ~\"Pacific Standard Time\";\n \n         assert local.tm_nsec == 54321_i32;\n     }\n@@ -934,7 +978,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n         assert utc.to_timespec() == time;\n@@ -946,7 +990,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n         let local = at(time);\n \n@@ -1106,10 +1150,10 @@ mod tests {\n         assert test(~\"6\", ~\"%w\");\n         assert test(~\"2009\", ~\"%Y\");\n         assert test(~\"09\", ~\"%y\");\n-        assert strptime(~\"UTC\", ~\"%Z\").get().tm_zone == ~\"UTC\";\n-        assert strptime(~\"PST\", ~\"%Z\").get().tm_zone == ~\"\";\n-        assert strptime(~\"-0000\", ~\"%z\").get().tm_gmtoff == 0_i32;\n-        assert strptime(~\"-0800\", ~\"%z\").get().tm_gmtoff == 0_i32;\n+        assert result::unwrap(strptime(~\"UTC\", ~\"%Z\")).tm_zone == ~\"UTC\";\n+        assert result::unwrap(strptime(~\"PST\", ~\"%Z\")).tm_zone == ~\"\";\n+        assert result::unwrap(strptime(~\"-0000\", ~\"%z\")).tm_gmtoff == 0;\n+        assert result::unwrap(strptime(~\"-0800\", ~\"%z\")).tm_gmtoff == 0;\n         assert test(~\"%\", ~\"%%\");\n     }\n \n@@ -1118,7 +1162,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc   = at_utc(time);\n         let local = at(time);\n \n@@ -1133,7 +1177,7 @@ mod tests {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n+        let time = Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n         let local = at(time);\n "}, {"sha": "42f120484f0acecf19f15f0820dffb8ff2976732", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=16f72df7041602dd286c1c00b2b745d21bf10e9b", "patch": "@@ -265,7 +265,7 @@ priv impl ext_ctxt {\n         let path = @{span: span, global: false, idents: ~[nm],\n                      rp: None, types: ~[]};\n         @{id: self.next_id(),\n-          node: ast::pat_ident(ast::bind_by_implicit_ref,\n+          node: ast::pat_ident(ast::bind_by_ref(ast::m_imm),\n                                path,\n                                None),\n           span: span}\n@@ -887,7 +887,7 @@ fn ser_variant(\n \n     let pat_node = if pats.is_empty() {\n         ast::pat_ident(\n-            ast::bind_by_implicit_ref,\n+            ast::bind_by_ref(ast::m_imm),\n             cx.path(span, ~[v_name]),\n             None\n         )"}, {"sha": "1c81bb05bcc83f7a4c770ed64eafd10224189516", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f72df7041602dd286c1c00b2b745d21bf10e9b/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=16f72df7041602dd286c1c00b2b745d21bf10e9b", "patch": "@@ -1,3 +1,5 @@\n+#[forbid(deprecated_pattern)];\n+\n extern mod std;\n \n // These tests used to be separate files, but I wanted to refactor all\n@@ -10,6 +12,7 @@ use EBWriter = std::ebml::Writer;\n use io::Writer;\n use std::serialization::{Serializable, Deserializable, deserialize};\n use std::prettyprint;\n+use std::time;\n \n fn test_prettyprint<A: Serializable<prettyprint::Serializer>>(\n     a: &A,\n@@ -31,7 +34,7 @@ fn test_ebml<A:\n         let ebml_w = &EBWriter::Serializer(wr);\n         a1.serialize(ebml_w)\n     };\n-    let d = EBReader::Doc(@bytes);\n+    let d = EBReader::Doc(@move bytes);\n     let a2: A = deserialize(&EBReader::Deserializer(d));\n     assert *a1 == a2;\n }\n@@ -184,4 +187,7 @@ fn main() {\n     let a = &B;\n     test_prettyprint(a, &~\"B\");\n     test_ebml(a);\n+\n+    let a = &time::now();\n+    test_ebml(a);\n }"}]}