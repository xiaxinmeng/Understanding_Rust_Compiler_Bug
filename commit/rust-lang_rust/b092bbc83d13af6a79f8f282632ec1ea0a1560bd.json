{"sha": "b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwOTJiYmM4M2QxM2FmNmE3OWY4ZjI4MjYzMmVjMWVhMGExNTYwYmQ=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-14T17:20:30Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-14T17:20:30Z"}, "message": "Merge branch 'master' of github.com:rust-analyzer/rust-analyzer", "tree": {"sha": "2638559990ee6a93cd3b6d6d957b67063eb75c2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2638559990ee6a93cd3b6d6d957b67063eb75c2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "html_url": "https://github.com/rust-lang/rust/commit/b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "064095742980d4c825391f643e437520599f51d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/064095742980d4c825391f643e437520599f51d8", "html_url": "https://github.com/rust-lang/rust/commit/064095742980d4c825391f643e437520599f51d8"}, {"sha": "c82e7696e6f86cc0843c5aab9f09b5d6dd0d4bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/c82e7696e6f86cc0843c5aab9f09b5d6dd0d4bac", "html_url": "https://github.com/rust-lang/rust/commit/c82e7696e6f86cc0843c5aab9f09b5d6dd0d4bac"}], "stats": {"total": 702, "additions": 557, "deletions": 145}, "files": [{"sha": "ef0ce058617aef9108e2d3565df388bf8bbc4e90", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -1,7 +1,7 @@\n use std::iter::successors;\n \n use ra_syntax::{\n-    algo::{neighbor, SyntaxRewriter},\n+    algo::{neighbor, skip_trivia_token, SyntaxRewriter},\n     ast::{self, edit::AstNodeEdit, make},\n     AstNode, Direction, InsertPosition, SyntaxElement, T,\n };\n@@ -72,9 +72,18 @@ fn try_merge_trees(old: &ast::UseTree, new: &ast::UseTree) -> Option<ast::UseTre\n     let lhs = old.split_prefix(&lhs_prefix);\n     let rhs = new.split_prefix(&rhs_prefix);\n \n+    let should_insert_comma = lhs\n+        .use_tree_list()?\n+        .r_curly_token()\n+        .and_then(|it| skip_trivia_token(it.prev_token()?, Direction::Prev))\n+        .map(|it| it.kind() != T![,])\n+        .unwrap_or(true);\n+\n     let mut to_insert: Vec<SyntaxElement> = Vec::new();\n-    to_insert.push(make::token(T![,]).into());\n-    to_insert.push(make::tokens::single_space().into());\n+    if should_insert_comma {\n+        to_insert.push(make::token(T![,]).into());\n+        to_insert.push(make::tokens::single_space().into());\n+    }\n     to_insert.extend(\n         rhs.use_tree_list()?\n             .syntax()\n@@ -247,4 +256,22 @@ use {\n \",\n         );\n     }\n+\n+    #[test]\n+    fn test_double_comma() {\n+        check_assist(\n+            merge_imports,\n+            r\"\n+use foo::bar::baz;\n+use foo::<|>{\n+    FooBar,\n+};\n+\",\n+            r\"\n+use foo::{<|>\n+    FooBar,\n+bar::baz};\n+\",\n+        )\n+    }\n }"}, {"sha": "5cbb98d73fdcd81faa04fd1fe7340d7d4feb617d", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -1,20 +1,20 @@\n use std::collections::HashMap;\n \n-use itertools::Itertools;\n-\n use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n+use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n-    algo, ast,\n-    ast::{Name, Path, RecordLit, RecordPat},\n-    AstNode, SyntaxKind, SyntaxNode,\n+    algo,\n+    ast::{self, Path, RecordLit, RecordPat},\n+    match_ast, AstNode, SyntaxKind,\n+    SyntaxKind::*,\n+    SyntaxNode,\n };\n \n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n     AssistId,\n };\n-use ra_syntax::ast::{Expr, NameRef};\n \n // Assist: reorder_fields\n //\n@@ -59,7 +59,6 @@ fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n }\n \n fn get_fields_kind(node: &SyntaxNode) -> Vec<SyntaxKind> {\n-    use SyntaxKind::*;\n     match node.kind() {\n         RECORD_LIT => vec![RECORD_FIELD],\n         RECORD_PAT => vec![RECORD_FIELD_PAT, BIND_PAT],\n@@ -68,19 +67,14 @@ fn get_fields_kind(node: &SyntaxNode) -> Vec<SyntaxKind> {\n }\n \n fn get_field_name(node: &SyntaxNode) -> String {\n-    use SyntaxKind::*;\n-    match node.kind() {\n-        RECORD_FIELD => {\n-            if let Some(name) = node.children().find_map(NameRef::cast) {\n-                return name.to_string();\n-            }\n-            node.children().find_map(Expr::cast).map(|expr| expr.to_string()).unwrap_or_default()\n-        }\n-        BIND_PAT | RECORD_FIELD_PAT => {\n-            node.children().find_map(Name::cast).map(|n| n.to_string()).unwrap_or_default()\n+    let res = match_ast! {\n+        match node {\n+            ast::RecordField(field) => field.field_name().map(|it| it.to_string()),\n+            ast::RecordFieldPat(field) => field.field_name().map(|it| it.to_string()),\n+            _ => None,\n         }\n-        _ => String::new(),\n-    }\n+    };\n+    res.unwrap_or_default()\n }\n \n fn get_fields(record: &SyntaxNode) -> Vec<SyntaxNode> {"}, {"sha": "79abe55ce6065227463376240b8f5673941d8092", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -33,6 +33,7 @@ use crate::{\n };\n \n use super::{ExprSource, PatSource};\n+use ast::AstChildren;\n \n pub(super) fn lower(\n     db: &dyn DefDatabase,\n@@ -598,8 +599,8 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::TupleStructPat(p) => {\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::TupleStruct { path, args }\n+                let (args, ellipsis) = self.collect_tuple_pat(p.args());\n+                Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n                 let pat = self.collect_pat_opt(p.pat());\n@@ -616,10 +617,10 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat()),\n             ast::Pat::TuplePat(p) => {\n-                let args = p.args().map(|p| self.collect_pat(p)).collect();\n-                Pat::Tuple(args)\n+                let (args, ellipsis) = self.collect_tuple_pat(p.args());\n+                Pat::Tuple { args, ellipsis }\n             }\n-            ast::Pat::PlaceholderPat(_) | ast::Pat::DotDotPat(_) => Pat::Wild,\n+            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n                 let record_field_pat_list =\n@@ -637,7 +638,7 @@ impl ExprCollector<'_> {\n                 let iter = record_field_pat_list.record_field_pats().filter_map(|f| {\n                     let ast_pat = f.pat()?;\n                     let pat = self.collect_pat(ast_pat);\n-                    let name = f.name()?.as_name();\n+                    let name = f.field_name()?.as_name();\n                     Some(RecordFieldPat { name, pat })\n                 });\n                 fields.extend(iter);\n@@ -665,6 +666,9 @@ impl ExprCollector<'_> {\n                     Pat::Missing\n                 }\n             }\n+            ast::Pat::DotDotPat(_) => unreachable!(\n+                \"`DotDotPat` requires special handling and should not be mapped to a Pat.\"\n+            ),\n             // FIXME: implement\n             ast::Pat::BoxPat(_) | ast::Pat::RangePat(_) | ast::Pat::MacroPat(_) => Pat::Missing,\n         };\n@@ -679,6 +683,19 @@ impl ExprCollector<'_> {\n             self.missing_pat()\n         }\n     }\n+\n+    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Vec<PatId>, Option<usize>) {\n+        // Find the location of the `..`, if there is one. Note that we do not\n+        // consider the possiblity of there being multiple `..` here.\n+        let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::DotDotPat(_)));\n+        // We want to skip the `..` pattern here, since we account for it above.\n+        let args = args\n+            .filter(|p| !matches!(p, ast::Pat::DotDotPat(_)))\n+            .map(|p| self.collect_pat(p))\n+            .collect();\n+\n+        (args, ellipsis)\n+    }\n }\n \n impl From<ast::BinOp> for BinaryOp {"}, {"sha": "a0cdad529b3fb8404e4216df17ab6cb353a912cd", "filename": "crates/ra_hir_def/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fexpr.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -374,15 +374,15 @@ pub struct RecordFieldPat {\n pub enum Pat {\n     Missing,\n     Wild,\n-    Tuple(Vec<PatId>),\n+    Tuple { args: Vec<PatId>, ellipsis: Option<usize> },\n     Or(Vec<PatId>),\n     Record { path: Option<Path>, args: Vec<RecordFieldPat>, ellipsis: bool },\n     Range { start: ExprId, end: ExprId },\n     Slice { prefix: Vec<PatId>, slice: Option<PatId>, suffix: Vec<PatId> },\n     Path(Path),\n     Lit(ExprId),\n     Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n-    TupleStruct { path: Option<Path>, args: Vec<PatId> },\n+    TupleStruct { path: Option<Path>, args: Vec<PatId>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n }\n \n@@ -393,7 +393,7 @@ impl Pat {\n             Pat::Bind { subpat, .. } => {\n                 subpat.iter().copied().for_each(f);\n             }\n-            Pat::Or(args) | Pat::Tuple(args) | Pat::TupleStruct { args, .. } => {\n+            Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n                 args.iter().copied().for_each(f);\n             }\n             Pat::Ref { pat, .. } => f(*pat),"}, {"sha": "fecce224ee607b6a0bf9283e3de35e668dc70ec4", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -83,6 +83,15 @@ impl AsName for ast::Name {\n     }\n }\n \n+impl AsName for ast::NameOrNameRef {\n+    fn as_name(&self) -> Name {\n+        match self {\n+            ast::NameOrNameRef::Name(it) => it.as_name(),\n+            ast::NameOrNameRef::NameRef(it) => it.as_name(),\n+        }\n+    }\n+}\n+\n impl AsName for tt::Ident {\n     fn as_name(&self) -> Name {\n         Name::resolve(&self.text)"}, {"sha": "a64be9848ef1cebebdf1cd695e888812d4467f7d", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 328, "deletions": 22, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -289,7 +289,7 @@ impl PatStack {\n         Self::from_slice(&self.0[1..])\n     }\n \n-    fn replace_head_with(&self, pat_ids: &[PatId]) -> PatStack {\n+    fn replace_head_with<T: Into<PatIdOrWild> + Copy>(&self, pat_ids: &[T]) -> PatStack {\n         let mut patterns: PatStackInner = smallvec![];\n         for pat in pat_ids {\n             patterns.push((*pat).into());\n@@ -320,12 +320,14 @@ impl PatStack {\n         constructor: &Constructor,\n     ) -> MatchCheckResult<Option<PatStack>> {\n         let result = match (self.head().as_pat(cx), constructor) {\n-            (Pat::Tuple(ref pat_ids), Constructor::Tuple { arity }) => {\n-                debug_assert_eq!(\n-                    pat_ids.len(),\n-                    *arity,\n-                    \"we type check before calling this code, so we should never hit this case\",\n-                );\n+            (Pat::Tuple { args: ref pat_ids, ellipsis }, Constructor::Tuple { arity: _ }) => {\n+                if ellipsis.is_some() {\n+                    // If there are ellipsis here, we should add the correct number of\n+                    // Pat::Wild patterns to `pat_ids`. We should be able to use the\n+                    // constructors arity for this, but at the time of writing we aren't\n+                    // correctly calculating this arity when ellipsis are present.\n+                    return Err(MatchCheckErr::NotImplemented);\n+                }\n \n                 Some(self.replace_head_with(pat_ids))\n             }\n@@ -351,19 +353,47 @@ impl PatStack {\n                     Some(self.to_tail())\n                 }\n             }\n-            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(enum_constructor)) => {\n+            (\n+                Pat::TupleStruct { args: ref pat_ids, ellipsis, .. },\n+                Constructor::Enum(enum_constructor),\n+            ) => {\n                 let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n                 if !enum_variant_matches(cx, pat_id, *enum_constructor) {\n                     None\n                 } else {\n-                    // If the enum variant matches, then we need to confirm\n-                    // that the number of patterns aligns with the expected\n-                    // number of patterns for that enum variant.\n-                    if pat_ids.len() != constructor.arity(cx)? {\n-                        return Err(MatchCheckErr::MalformedMatchArm);\n+                    let constructor_arity = constructor.arity(cx)?;\n+                    if let Some(ellipsis_position) = ellipsis {\n+                        // If there are ellipsis in the pattern, the ellipsis must take the place\n+                        // of at least one sub-pattern, so `pat_ids` should be smaller than the\n+                        // constructor arity.\n+                        if pat_ids.len() < constructor_arity {\n+                            let mut new_patterns: Vec<PatIdOrWild> = vec![];\n+\n+                            for pat_id in &pat_ids[0..ellipsis_position] {\n+                                new_patterns.push((*pat_id).into());\n+                            }\n+\n+                            for _ in 0..(constructor_arity - pat_ids.len()) {\n+                                new_patterns.push(PatIdOrWild::Wild);\n+                            }\n+\n+                            for pat_id in &pat_ids[ellipsis_position..pat_ids.len()] {\n+                                new_patterns.push((*pat_id).into());\n+                            }\n+\n+                            Some(self.replace_head_with(&new_patterns))\n+                        } else {\n+                            return Err(MatchCheckErr::MalformedMatchArm);\n+                        }\n+                    } else {\n+                        // If there is no ellipsis in the tuple pattern, the number\n+                        // of patterns must equal the constructor arity.\n+                        if pat_ids.len() == constructor_arity {\n+                            Some(self.replace_head_with(pat_ids))\n+                        } else {\n+                            return Err(MatchCheckErr::MalformedMatchArm);\n+                        }\n                     }\n-\n-                    Some(self.replace_head_with(pat_ids))\n                 }\n             }\n             (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n@@ -644,7 +674,11 @@ impl Constructor {\n fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n     let res = match pat.as_pat(cx) {\n         Pat::Wild => None,\n-        Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n+        // FIXME somehow create the Tuple constructor with the proper arity. If there are\n+        // ellipsis, the arity is not equal to the number of patterns.\n+        Pat::Tuple { args: pats, ellipsis } if ellipsis.is_none() => {\n+            Some(Constructor::Tuple { arity: pats.len() })\n+        }\n         Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n             Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n             _ => return Err(MatchCheckErr::NotImplemented),\n@@ -972,6 +1006,47 @@ mod tests {\n         check_no_diagnostic(content);\n     }\n \n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_end_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (false, ..) => {},\n+                    (true, ..) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_beginning_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (.., false) => {},\n+                    (.., true) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (..) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn tuple_of_tuple_and_bools_no_arms() {\n         let content = r\"\n@@ -1315,8 +1390,9 @@ mod tests {\n             }\n         \";\n \n-        // Match arms with the incorrect type are filtered out.\n-        check_diagnostic(content);\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(content);\n     }\n \n     #[test]\n@@ -1330,8 +1406,9 @@ mod tests {\n             }\n         \";\n \n-        // Match arms with the incorrect type are filtered out.\n-        check_diagnostic(content);\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(content);\n     }\n \n     #[test]\n@@ -1344,8 +1421,9 @@ mod tests {\n             }\n         \";\n \n-        // Match arms with the incorrect type are filtered out.\n-        check_diagnostic(content);\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_no_diagnostic(content);\n     }\n \n     #[test]\n@@ -1383,6 +1461,163 @@ mod tests {\n         // we don't create a diagnostic).\n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn expr_diverges() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop {} {\n+                    Either::A => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn expr_loop_with_break() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop { break Foo::A } {\n+                    Either::A => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn expr_partially_diverges() {\n+        let content = r\"\n+            enum Either<T> {\n+                A(T),\n+                B,\n+            }\n+            fn foo() -> Either<!> {\n+                Either::B\n+            }\n+            fn test_fn() -> u32 {\n+                match foo() {\n+                    Either::A(val) => val,\n+                    Either::B => 0,\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(false, .., true) => {},\n+                    Either::A(false, .., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_2_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(.., true) => {},\n+                    Either::A(.., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(false, .., false) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis_2_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true, .., true) => {},\n+                    Either::A(true, .., false) => {},\n+                    Either::A(.., true) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_tuple_ellipsis_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool, bool, bool, bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(..) => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n }\n \n #[cfg(test)]\n@@ -1452,4 +1687,75 @@ mod false_negatives {\n         // We do not currently handle patterns with internal `or`s.\n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn expr_diverges_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop {} {\n+                    Either::A => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // Even though the match expression diverges, rustc fails\n+        // to compile here since `Either::B` is missing.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn expr_loop_missing_arm() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match loop { break Foo::A } {\n+                    Either::A => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We currently infer the type of `loop { break Foo::A }` to `!`, which\n+        // causes us to skip the diagnostic since `Either::A` doesn't type check\n+        // with `!`.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (false, ..) => {},\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently handle tuple patterns with ellipsis.\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true, false) {\n+                    (.., false) => {},\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently handle tuple patterns with ellipsis.\n+        check_no_diagnostic(content);\n+    }\n }"}, {"sha": "21abbcf1e2d157f7344219ae514e112d0d8284ab", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -161,12 +161,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let mut seen = Matrix::empty();\n         for pat in pats {\n-            // We skip any patterns whose type we cannot resolve.\n-            //\n-            // This could lead to false positives in this diagnostic, so\n-            // it might be better to skip the entire diagnostic if we either\n-            // cannot resolve a match arm or determine that the match arm has\n-            // the wrong type.\n             if let Some(pat_ty) = infer.type_of_pat.get(pat) {\n                 // We only include patterns whose type matches the type\n                 // of the match expression. If we had a InvalidMatchArmPattern\n@@ -189,8 +183,15 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                     // to the matrix here.\n                     let v = PatStack::from_pattern(pat);\n                     seen.push(&cx, v);\n+                    continue;\n                 }\n             }\n+\n+            // If we can't resolve the type of a pattern, or the pattern type doesn't\n+            // fit the match expression, we skip this diagnostic. Skipping the entire\n+            // diagnostic rather than just not including this match arm is preferred\n+            // to avoid the chance of false positives.\n+            return;\n         }\n \n         match is_useful(&cx, &seen, &PatStack::from_wild()) {"}, {"sha": "8ec4d4ace084e7c805061bc6ae21235b1b5f1c67", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -85,7 +85,7 @@ impl<'a> InferenceContext<'a> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n \n         let is_non_ref_pat = match &body[pat] {\n-            Pat::Tuple(..)\n+            Pat::Tuple { .. }\n             | Pat::Or(..)\n             | Pat::TupleStruct { .. }\n             | Pat::Record { .. }\n@@ -116,7 +116,7 @@ impl<'a> InferenceContext<'a> {\n         let expected = expected;\n \n         let ty = match &body[pat] {\n-            Pat::Tuple(ref args) => {\n+            Pat::Tuple { ref args, .. } => {\n                 let expectations = match expected.as_tuple() {\n                     Some(parameters) => &*parameters.0,\n                     _ => &[],\n@@ -155,7 +155,7 @@ impl<'a> InferenceContext<'a> {\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n             }\n-            Pat::TupleStruct { path: p, args: subpats } => {\n+            Pat::TupleStruct { path: p, args: subpats, .. } => {\n                 self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm, pat)\n             }\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {"}, {"sha": "07cbc521a3f24e8085e89a32d411a230a6a6b083", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -1,7 +1,8 @@\n-use super::{infer, infer_with_mismatches};\n use insta::assert_snapshot;\n use test_utils::covers;\n \n+use super::{infer, infer_with_mismatches};\n+\n #[test]\n fn infer_pattern() {\n     assert_snapshot!("}, {"sha": "f95b6baf3d47a677f14c40eb62deb1af5c570e07", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -208,9 +208,20 @@ mod tests {\n         }\n     }\n \n-    fn call_info(text: &str) -> CallInfo {\n+    fn call_info_helper(text: &str) -> Option<CallInfo> {\n         let (analysis, position) = single_file_with_position(text);\n-        analysis.call_info(position).unwrap().unwrap()\n+        analysis.call_info(position).unwrap()\n+    }\n+\n+    fn call_info(text: &str) -> CallInfo {\n+        let info = call_info_helper(text);\n+        assert!(info.is_some());\n+        info.unwrap()\n+    }\n+\n+    fn no_call_info(text: &str) {\n+        let info = call_info_helper(text);\n+        assert!(info.is_none());\n     }\n \n     #[test]\n@@ -558,9 +569,8 @@ fn main() {\n     }\n \n     #[test]\n-    #[should_panic]\n     fn cant_call_named_structs() {\n-        let _ = call_info(\n+        no_call_info(\n             r#\"\n struct TS { x: u32, y: i32 }\n fn main() {\n@@ -594,9 +604,8 @@ fn main() {\n     }\n \n     #[test]\n-    #[should_panic]\n     fn cant_call_enum_records() {\n-        let _ = call_info(\n+        no_call_info(\n             r#\"\n enum E {\n     /// A Variant"}, {"sha": "a8b4ce114db6e15c2eb45f9f1e896d574e7ccf7d", "filename": "crates/ra_ide/src/completion/complete_pattern.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -7,6 +7,10 @@ pub(super) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_pat_binding_or_const {\n         return;\n     }\n+    if ctx.record_pat_syntax.is_some() {\n+        return;\n+    }\n+\n     // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n     ctx.scope().process_all_names(&mut |name, res| {"}, {"sha": "83a553155b0acef7234d8cd270def130651345d1", "filename": "crates/ra_ide/src/completion/complete_record.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -2,7 +2,7 @@\n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let missing_fields = match (ctx.record_lit_pat.as_ref(), ctx.record_lit_syntax.as_ref()) {\n+    let missing_fields = match (ctx.record_pat_syntax.as_ref(), ctx.record_lit_syntax.as_ref()) {\n         (None, None) => return None,\n         (Some(_), Some(_)) => unreachable!(\"A record cannot be both a literal and a pattern\"),\n         (Some(record_pat), _) => ctx.sema.record_pattern_missing_fields(record_pat),"}, {"sha": "2d8e0776ca5e4ef91975816c5af57069c6221fb9", "filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -3,7 +3,14 @@\n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !(ctx.is_trivial_path && !ctx.is_pat_binding_or_const && !ctx.record_lit_syntax.is_some()) {\n+    if !ctx.is_trivial_path {\n+        return;\n+    }\n+\n+    if ctx.is_pat_binding_or_const\n+        || ctx.record_lit_syntax.is_some()\n+        || ctx.record_pat_syntax.is_some()\n+    {\n         return;\n     }\n "}, {"sha": "da054f7a2e917150aae2c075747887d97fa26d62", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -31,7 +31,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) function_syntax: Option<ast::FnDef>,\n     pub(super) use_item_syntax: Option<ast::UseItem>,\n     pub(super) record_lit_syntax: Option<ast::RecordLit>,\n-    pub(super) record_lit_pat: Option<ast::RecordPat>,\n+    pub(super) record_pat_syntax: Option<ast::RecordPat>,\n     pub(super) impl_def: Option<ast::ImplDef>,\n     pub(super) call_info: Option<CallInfo>,\n     pub(super) is_param: bool,\n@@ -97,7 +97,7 @@ impl<'a> CompletionContext<'a> {\n             call_info: None,\n             use_item_syntax: None,\n             record_lit_syntax: None,\n-            record_lit_pat: None,\n+            record_pat_syntax: None,\n             impl_def: None,\n             is_param: false,\n             is_pat_binding_or_const: false,\n@@ -186,6 +186,11 @@ impl<'a> CompletionContext<'a> {\n                 self.is_param = true;\n                 return;\n             }\n+            // FIXME: remove this (V) duplication and make the check more precise\n+            if name_ref.syntax().ancestors().find_map(ast::RecordFieldPatList::cast).is_some() {\n+                self.record_pat_syntax =\n+                    self.sema.find_node_at_offset_with_macros(&original_file, offset);\n+            }\n             self.classify_name_ref(original_file, name_ref, offset);\n         }\n \n@@ -215,8 +220,9 @@ impl<'a> CompletionContext<'a> {\n                 self.is_param = true;\n                 return;\n             }\n+            // FIXME: remove this (^) duplication and make the check more precise\n             if name.syntax().ancestors().find_map(ast::RecordFieldPatList::cast).is_some() {\n-                self.record_lit_pat =\n+                self.record_pat_syntax =\n                     self.sema.find_node_at_offset_with_macros(&original_file, offset);\n             }\n         }"}, {"sha": "c2a6e82e9b451bc5de48370eae4db4d929008d44", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -282,13 +282,10 @@ fn name_ref(p: &mut Parser) {\n }\n \n fn name_ref_or_index(p: &mut Parser) {\n-    if p.at(IDENT) || p.at(INT_NUMBER) {\n-        let m = p.start();\n-        p.bump_any();\n-        m.complete(p, NAME_REF);\n-    } else {\n-        p.err_and_bump(\"expected identifier\");\n-    }\n+    assert!(p.at(IDENT) || p.at(INT_NUMBER));\n+    let m = p.start();\n+    p.bump_any();\n+    m.complete(p, NAME_REF);\n }\n \n fn error_block(p: &mut Parser, message: &str) {"}, {"sha": "68fb2fc7337abca0a3b5dd36706a3fcc10477e11", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -192,14 +192,30 @@ fn record_field_pat_list(p: &mut Parser) {\n         match p.current() {\n             // A trailing `..` is *not* treated as a DOT_DOT_PAT.\n             T![.] if p.at(T![..]) => p.bump(T![..]),\n-\n-            IDENT | INT_NUMBER if p.nth(1) == T![:] => record_field_pat(p),\n             T!['{'] => error_block(p, \"expected ident\"),\n-            T![box] => {\n-                box_pat(p);\n-            }\n-            _ => {\n-                bind_pat(p, false);\n+\n+            c => {\n+                let m = p.start();\n+                match c {\n+                    // test record_field_pat\n+                    // fn foo() {\n+                    //     let S { 0: 1 } = ();\n+                    //     let S { x: 1 } = ();\n+                    // }\n+                    IDENT | INT_NUMBER if p.nth(1) == T![:] => {\n+                        name_ref_or_index(p);\n+                        p.bump(T![:]);\n+                        pattern(p);\n+                    }\n+                    T![box] => {\n+                        // FIXME: not all box patterns should be allowed\n+                        box_pat(p);\n+                    }\n+                    _ => {\n+                        bind_pat(p, false);\n+                    }\n+                }\n+                m.complete(p, RECORD_FIELD_PAT);\n             }\n         }\n         if !p.at(T!['}']) {\n@@ -210,26 +226,6 @@ fn record_field_pat_list(p: &mut Parser) {\n     m.complete(p, RECORD_FIELD_PAT_LIST);\n }\n \n-// test record_field_pat\n-// fn foo() {\n-//     let S { 0: 1 } = ();\n-//     let S { x: 1 } = ();\n-// }\n-fn record_field_pat(p: &mut Parser) {\n-    assert!(p.at(IDENT) || p.at(INT_NUMBER));\n-    assert!(p.nth(1) == T![:]);\n-\n-    let m = p.start();\n-\n-    if !p.eat(INT_NUMBER) {\n-        name(p)\n-    }\n-\n-    p.bump_any();\n-    pattern(p);\n-    m.complete(p, RECORD_FIELD_PAT);\n-}\n-\n // test placeholder_pat\n // fn main() { let _ = (); }\n fn placeholder_pat(p: &mut Parser) -> CompletedMarker {"}, {"sha": "7fca5661ef98a7ce584792f1fee20039d6bf8e0a", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -18,8 +18,8 @@ use crate::{\n pub use self::{\n     expr_extensions::{ArrayExprKind, BinOp, ElseBranch, LiteralKind, PrefixOp, RangeOp},\n     extensions::{\n-        AttrKind, FieldKind, PathSegmentKind, SelfParamKind, SlicePatComponents, StructKind,\n-        TypeBoundKind, VisibilityKind,\n+        AttrKind, FieldKind, NameOrNameRef, PathSegmentKind, SelfParamKind, SlicePatComponents,\n+        StructKind, TypeBoundKind, VisibilityKind,\n     },\n     generated::{nodes::*, tokens::*},\n     tokens::*,"}, {"sha": "f2ea5088e7ab4db48f7e8fa13071162e0709fe09", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -1,6 +1,8 @@\n //! Various extension methods to ast Nodes, which are hard to code-generate.\n //! Extensions for various expressions live in a sibling `expr_extensions` module.\n \n+use std::fmt;\n+\n use itertools::Itertools;\n use ra_parser::SyntaxKind;\n \n@@ -217,6 +219,34 @@ impl ast::RecordField {\n     }\n }\n \n+pub enum NameOrNameRef {\n+    Name(ast::Name),\n+    NameRef(ast::NameRef),\n+}\n+\n+impl fmt::Display for NameOrNameRef {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            NameOrNameRef::Name(it) => fmt::Display::fmt(it, f),\n+            NameOrNameRef::NameRef(it) => fmt::Display::fmt(it, f),\n+        }\n+    }\n+}\n+\n+impl ast::RecordFieldPat {\n+    /// Deals with field init shorthand\n+    pub fn field_name(&self) -> Option<NameOrNameRef> {\n+        if let Some(name_ref) = self.name_ref() {\n+            return Some(NameOrNameRef::NameRef(name_ref));\n+        }\n+        if let Some(ast::Pat::BindPat(pat)) = self.pat() {\n+            let name = pat.name()?;\n+            return Some(NameOrNameRef::Name(name));\n+        }\n+        None\n+    }\n+}\n+\n impl ast::EnumVariant {\n     pub fn parent_enum(&self) -> ast::EnumDef {\n         self.syntax()"}, {"sha": "188f0df968e65447e575f6a827e71aad5ed62d13", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -1806,8 +1806,8 @@ impl AstNode for RecordFieldPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ast::AttrsOwner for RecordFieldPat {}\n-impl ast::NameOwner for RecordFieldPat {}\n impl RecordFieldPat {\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }"}, {"sha": "fcd099de98881977f3fa9d5ee3f54466f68d82ae", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0102_record_field_pat_list.rast", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0102_record_field_pat_list.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0102_record_field_pat_list.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0102_record_field_pat_list.rast?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -44,18 +44,20 @@ SOURCE_FILE@[0; 119)\n             RECORD_FIELD_PAT_LIST@[40; 56)\n               L_CURLY@[40; 41) \"{\"\n               WHITESPACE@[41; 42) \" \"\n-              BIND_PAT@[42; 43)\n-                NAME@[42; 43)\n-                  IDENT@[42; 43) \"f\"\n+              RECORD_FIELD_PAT@[42; 43)\n+                BIND_PAT@[42; 43)\n+                  NAME@[42; 43)\n+                    IDENT@[42; 43) \"f\"\n               COMMA@[43; 44) \",\"\n               WHITESPACE@[44; 45) \" \"\n-              BIND_PAT@[45; 54)\n-                REF_KW@[45; 48) \"ref\"\n-                WHITESPACE@[48; 49) \" \"\n-                MUT_KW@[49; 52) \"mut\"\n-                WHITESPACE@[52; 53) \" \"\n-                NAME@[53; 54)\n-                  IDENT@[53; 54) \"g\"\n+              RECORD_FIELD_PAT@[45; 54)\n+                BIND_PAT@[45; 54)\n+                  REF_KW@[45; 48) \"ref\"\n+                  WHITESPACE@[48; 49) \" \"\n+                  MUT_KW@[49; 52) \"mut\"\n+                  WHITESPACE@[52; 53) \" \"\n+                  NAME@[53; 54)\n+                    IDENT@[53; 54) \"g\"\n               WHITESPACE@[54; 55) \" \"\n               R_CURLY@[55; 56) \"}\"\n           WHITESPACE@[56; 57) \" \"\n@@ -79,7 +81,7 @@ SOURCE_FILE@[0; 119)\n               L_CURLY@[73; 74) \"{\"\n               WHITESPACE@[74; 75) \" \"\n               RECORD_FIELD_PAT@[75; 79)\n-                NAME@[75; 76)\n+                NAME_REF@[75; 76)\n                   IDENT@[75; 76) \"h\"\n                 COLON@[76; 77) \":\"\n                 WHITESPACE@[77; 78) \" \"\n@@ -110,7 +112,7 @@ SOURCE_FILE@[0; 119)\n               L_CURLY@[101; 102) \"{\"\n               WHITESPACE@[102; 103) \" \"\n               RECORD_FIELD_PAT@[103; 107)\n-                NAME@[103; 104)\n+                NAME_REF@[103; 104)\n                   IDENT@[103; 104) \"h\"\n                 COLON@[104; 105) \":\"\n                 WHITESPACE@[105; 106) \" \""}, {"sha": "1d245f8f31b3db7c335aa2ae01745c1f27fe523a", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0143_box_pat.rast", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0143_box_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0143_box_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0143_box_pat.rast?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -44,16 +44,17 @@ SOURCE_FILE@[0; 118)\n               RECORD_FIELD_PAT_LIST@[50; 81)\n                 L_CURLY@[50; 51) \"{\"\n                 WHITESPACE@[51; 52) \" \"\n-                BOX_PAT@[52; 57)\n-                  BOX_KW@[52; 55) \"box\"\n-                  WHITESPACE@[55; 56) \" \"\n-                  BIND_PAT@[56; 57)\n-                    NAME@[56; 57)\n-                      IDENT@[56; 57) \"i\"\n+                RECORD_FIELD_PAT@[52; 57)\n+                  BOX_PAT@[52; 57)\n+                    BOX_KW@[52; 55) \"box\"\n+                    WHITESPACE@[55; 56) \" \"\n+                    BIND_PAT@[56; 57)\n+                      NAME@[56; 57)\n+                        IDENT@[56; 57) \"i\"\n                 COMMA@[57; 58) \",\"\n                 WHITESPACE@[58; 59) \" \"\n                 RECORD_FIELD_PAT@[59; 79)\n-                  NAME@[59; 60)\n+                  NAME_REF@[59; 60)\n                     IDENT@[59; 60) \"j\"\n                   COLON@[60; 61) \":\"\n                   WHITESPACE@[61; 62) \" \""}, {"sha": "cac2ffdcf8a844eca39ed7be5bce8adf9483d30e", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0145_record_field_pat.rast", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0145_record_field_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0145_record_field_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0145_record_field_pat.rast?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -25,7 +25,8 @@ SOURCE_FILE@[0; 63)\n               L_CURLY@[21; 22) \"{\"\n               WHITESPACE@[22; 23) \" \"\n               RECORD_FIELD_PAT@[23; 27)\n-                INT_NUMBER@[23; 24) \"0\"\n+                NAME_REF@[23; 24)\n+                  INT_NUMBER@[23; 24) \"0\"\n                 COLON@[24; 25) \":\"\n                 WHITESPACE@[25; 26) \" \"\n                 LITERAL_PAT@[26; 27)\n@@ -54,7 +55,7 @@ SOURCE_FILE@[0; 63)\n               L_CURLY@[46; 47) \"{\"\n               WHITESPACE@[47; 48) \" \"\n               RECORD_FIELD_PAT@[48; 52)\n-                NAME@[48; 49)\n+                NAME_REF@[48; 49)\n                   IDENT@[48; 49) \"x\"\n                 COLON@[49; 50) \":\"\n                 WHITESPACE@[50; 51) \" \""}, {"sha": "d0623ba904eafaa42cc1472ecdb88aa8dac2c935", "filename": "crates/ra_syntax/test_data/parser/ok/0063_trait_fn_patterns.rast", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0063_trait_fn_patterns.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0063_trait_fn_patterns.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0063_trait_fn_patterns.rast?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -68,14 +68,16 @@ SOURCE_FILE@[0; 170)\n               RECORD_FIELD_PAT_LIST@[59; 67)\n                 L_CURLY@[59; 60) \"{\"\n                 WHITESPACE@[60; 61) \" \"\n-                BIND_PAT@[61; 62)\n-                  NAME@[61; 62)\n-                    IDENT@[61; 62) \"a\"\n+                RECORD_FIELD_PAT@[61; 62)\n+                  BIND_PAT@[61; 62)\n+                    NAME@[61; 62)\n+                      IDENT@[61; 62) \"a\"\n                 COMMA@[62; 63) \",\"\n                 WHITESPACE@[63; 64) \" \"\n-                BIND_PAT@[64; 65)\n-                  NAME@[64; 65)\n-                    IDENT@[64; 65) \"b\"\n+                RECORD_FIELD_PAT@[64; 65)\n+                  BIND_PAT@[64; 65)\n+                    NAME@[64; 65)\n+                      IDENT@[64; 65) \"b\"\n                 WHITESPACE@[65; 66) \" \"\n                 R_CURLY@[66; 67) \"}\"\n             COLON@[67; 68) \":\""}, {"sha": "5e96b695bb2f120649bd4236bd7bc466588255ff", "filename": "crates/ra_syntax/test_data/parser/ok/0064_impl_fn_params.rast", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0064_impl_fn_params.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0064_impl_fn_params.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0064_impl_fn_params.rast?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -71,14 +71,16 @@ SOURCE_FILE@[0; 137)\n               RECORD_FIELD_PAT_LIST@[58; 66)\n                 L_CURLY@[58; 59) \"{\"\n                 WHITESPACE@[59; 60) \" \"\n-                BIND_PAT@[60; 61)\n-                  NAME@[60; 61)\n-                    IDENT@[60; 61) \"a\"\n+                RECORD_FIELD_PAT@[60; 61)\n+                  BIND_PAT@[60; 61)\n+                    NAME@[60; 61)\n+                      IDENT@[60; 61) \"a\"\n                 COMMA@[61; 62) \",\"\n                 WHITESPACE@[62; 63) \" \"\n-                BIND_PAT@[63; 64)\n-                  NAME@[63; 64)\n-                    IDENT@[63; 64) \"b\"\n+                RECORD_FIELD_PAT@[63; 64)\n+                  BIND_PAT@[63; 64)\n+                    NAME@[63; 64)\n+                      IDENT@[63; 64) \"b\"\n                 WHITESPACE@[64; 65) \" \"\n                 R_CURLY@[65; 66) \"}\"\n             COLON@[66; 67) \":\""}, {"sha": "9c02f7c6f04e9a1fa86bf78dc714f00213b5b78c", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b092bbc83d13af6a79f8f282632ec1ea0a1560bd/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=b092bbc83d13af6a79f8f282632ec1ea0a1560bd", "patch": "@@ -511,7 +511,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![..],\n             T!['}']\n         }\n-        struct RecordFieldPat: AttrsOwner, NameOwner { T![:], Pat }\n+        struct RecordFieldPat: AttrsOwner { NameRef, T![:], Pat }\n \n         struct TupleStructPat { Path, T!['('], args: [Pat], T![')'] }\n         struct TuplePat { T!['('], args: [Pat], T![')'] }"}]}