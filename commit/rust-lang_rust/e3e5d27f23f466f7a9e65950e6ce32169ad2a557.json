{"sha": "e3e5d27f23f466f7a9e65950e6ce32169ad2a557", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZTVkMjdmMjNmNDY2ZjdhOWU2NTk1MGU2Y2UzMjE2OWFkMmE1NTc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-11T17:18:52Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-14T22:40:03Z"}, "message": "Use member constraint for most opaque types in NLL\n\nThis ensures that NLL will infer suitable values for regions in opaque\ntypes when it's possible.", "tree": {"sha": "2ce58d9ae3c71b7a22e617c65574fb18565d07b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ce58d9ae3c71b7a22e617c65574fb18565d07b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3e5d27f23f466f7a9e65950e6ce32169ad2a557", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3e5d27f23f466f7a9e65950e6ce32169ad2a557", "html_url": "https://github.com/rust-lang/rust/commit/e3e5d27f23f466f7a9e65950e6ce32169ad2a557", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3e5d27f23f466f7a9e65950e6ce32169ad2a557/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd1687ef416f9a5856872c7ed40c4a1a3d8788ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea", "html_url": "https://github.com/rust-lang/rust/commit/dd1687ef416f9a5856872c7ed40c4a1a3d8788ea"}], "stats": {"total": 58, "additions": 43, "deletions": 15}, "files": [{"sha": "5ecd03e41234e88a2ef93328eed0f5fb6417a181", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e3e5d27f23f466f7a9e65950e6ce32169ad2a557/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e5d27f23f466f7a9e65950e6ce32169ad2a557/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=e3e5d27f23f466f7a9e65950e6ce32169ad2a557", "patch": "@@ -93,6 +93,18 @@ pub struct OpaqueTypeDecl<'tcx> {\n     pub origin: hir::OpaqueTyOrigin,\n }\n \n+/// Whether member constraints should be generated for all opaque types\n+pub enum GenerateMemberConstraints {\n+    /// The default, used by typeck\n+    WhenRequired,\n+    /// The borrow checker needs member constraints in any case where we don't\n+    /// have a `'static` bound. This is because the borrow checker has more\n+    /// flexibility in the values of regions. For example, given `f<'a, 'b>`\n+    /// the borrow checker can have an inference variable outlive `'a` and `'b`,\n+    /// but not be equal to `'static`.\n+    IfNoStaticBound,\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Replaces all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n@@ -315,7 +327,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"constrain_opaque_types()\");\n \n         for (&def_id, opaque_defn) in opaque_types {\n-            self.constrain_opaque_type(def_id, opaque_defn, free_region_relations);\n+            self.constrain_opaque_type(\n+                def_id,\n+                opaque_defn,\n+                GenerateMemberConstraints::WhenRequired,\n+                free_region_relations,\n+            );\n         }\n     }\n \n@@ -324,6 +341,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        mode: GenerateMemberConstraints,\n         free_region_relations: &FRR,\n     ) {\n         debug!(\"constrain_opaque_type()\");\n@@ -358,6 +376,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     op: |r| self.sub_regions(infer::CallReturn(span), required_region, r),\n                 });\n             }\n+            if let GenerateMemberConstraints::IfNoStaticBound = mode {\n+                self.generate_member_constraint(\n+                    concrete_ty,\n+                    opaque_type_generics,\n+                    opaque_defn,\n+                    def_id,\n+                );\n+            }\n             return;\n         }\n \n@@ -398,13 +424,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // we will create a \"in bound\" like `'r in\n                         // ['a, 'b, 'c]`, where `'a..'c` are the\n                         // regions that appear in the impl trait.\n+\n+                        // For now, enforce a feature gate outside of async functions.\n+                        self.member_constraint_feature_gate(opaque_defn, def_id, lr, subst_arg);\n+\n                         return self.generate_member_constraint(\n                             concrete_ty,\n                             opaque_type_generics,\n                             opaque_defn,\n                             def_id,\n-                            lr,\n-                            subst_arg,\n                         );\n                     }\n                 }\n@@ -414,6 +442,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let least_region = least_region.unwrap_or(tcx.lifetimes.re_static);\n         debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n+        if let GenerateMemberConstraints::IfNoStaticBound = mode {\n+            if least_region != tcx.lifetimes.re_static {\n+                self.generate_member_constraint(\n+                    concrete_ty,\n+                    opaque_type_generics,\n+                    opaque_defn,\n+                    def_id,\n+                );\n+            }\n+        }\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n             tcx: self.tcx,\n             op: |r| self.sub_regions(infer::CallReturn(span), least_region, r),\n@@ -434,19 +472,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         opaque_type_generics: &ty::Generics,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         opaque_type_def_id: DefId,\n-        conflict1: ty::Region<'tcx>,\n-        conflict2: ty::Region<'tcx>,\n     ) {\n-        // For now, enforce a feature gate outside of async functions.\n-        if self.member_constraint_feature_gate(\n-            opaque_defn,\n-            opaque_type_def_id,\n-            conflict1,\n-            conflict2,\n-        ) {\n-            return;\n-        }\n-\n         // Create the set of choice regions: each region in the hidden\n         // type can be equal to any of the region parameters of the\n         // opaque type definition."}, {"sha": "2a2d8642760673f0008c01ddaa086ca488fd93dc", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3e5d27f23f466f7a9e65950e6ce32169ad2a557/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e5d27f23f466f7a9e65950e6ce32169ad2a557/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=e3e5d27f23f466f7a9e65950e6ce32169ad2a557", "patch": "@@ -6,6 +6,7 @@ use std::{fmt, iter, mem};\n use either::Either;\n \n use rustc::infer::canonical::QueryRegionConstraints;\n+use rustc::infer::opaque_types::GenerateMemberConstraints;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n@@ -1345,6 +1346,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             infcx.constrain_opaque_type(\n                                 opaque_def_id,\n                                 &opaque_decl,\n+                                GenerateMemberConstraints::IfNoStaticBound,\n                                 universal_region_relations,\n                             );\n                             Ok(InferOk { value: (), obligations: vec![] })"}]}