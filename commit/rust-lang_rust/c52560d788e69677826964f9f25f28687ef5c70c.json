{"sha": "c52560d788e69677826964f9f25f28687ef5c70c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MjU2MGQ3ODhlNjk2Nzc4MjY5NjRmOWYyNWYyODY4N2VmNWM3MGM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-20T08:45:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-20T08:45:28Z"}, "message": "tweaks", "tree": {"sha": "abca4aa199b562c9b673c282132fda2c3a03d343", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abca4aa199b562c9b673c282132fda2c3a03d343"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c52560d788e69677826964f9f25f28687ef5c70c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c52560d788e69677826964f9f25f28687ef5c70c", "html_url": "https://github.com/rust-lang/rust/commit/c52560d788e69677826964f9f25f28687ef5c70c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c52560d788e69677826964f9f25f28687ef5c70c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c241aa7144b17aa423dde02cc6cd5f2964a73c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c241aa7144b17aa423dde02cc6cd5f2964a73c6", "html_url": "https://github.com/rust-lang/rust/commit/9c241aa7144b17aa423dde02cc6cd5f2964a73c6"}], "stats": {"total": 29, "additions": 15, "deletions": 14}, "files": [{"sha": "6d3c3af17f5678bd40e9a1447e28ce7113f7081b", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c52560d788e69677826964f9f25f28687ef5c70c/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c52560d788e69677826964f9f25f28687ef5c70c/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=c52560d788e69677826964f9f25f28687ef5c70c", "patch": "@@ -16,7 +16,7 @@\n //! [`Pin`] wraps a pointer type, so `Pin<Box<T>>` functions much like a regular `Box<T>`\n //! (when a `Pin<Box<T>>` gets dropped, so do its contents, and the memory gets deallocated).\n //! Similarily, `Pin<&mut T>` is a lot like `&mut T`. However, [`Pin`] does not let clients actually\n-//! obtain a `Box` or reference to pinned data, which implies that you cannot use\n+//! obtain a `Box<T>` or `&mut T` to pinned data, which implies that you cannot use\n //! operations such as [`mem::swap`]:\n //! ```\n //! use std::pin::Pin;\n@@ -29,9 +29,10 @@\n //! ```\n //!\n //! It is worth reiterating that [`Pin`] does *not* change the fact that a Rust compiler\n-//! considers all types movable.  [`mem::swap`] remains callable for any `T`. Instead, `Pin`\n+//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, `Pin`\n //! prevents certain *values* (pointed to by pointers wrapped in `Pin`) from being\n-//! moved by making it impossible to call methods like [`mem::swap`] on them.\n+//! moved by making it impossible to call methods that require `&mut T` on them\n+//! (like [`mem::swap`]).\n //!\n //! [`Pin`] can be used to wrap any pointer type, and as such it interacts with\n //! [`Deref`] and [`DerefMut`]. A `Pin<P>` where `P: Deref` should be considered\n@@ -221,7 +222,7 @@\n //!    reference we got later.\n //!\n //! On the other hand, if you decide *not* to offer any pinning projections, you\n-//! are free to `impl<T> Unpin for Container<T>`.  In the standard library,\n+//! are free to `impl<T> Unpin for Container<T>`. In the standard library,\n //! this is done for all pointer types: `Box<T>: Unpin` holds for all `T`.\n //! It makes sense to do this for pointer types, because moving the `Box<T>`\n //! does not actually move the `T`: the `Box<T>` can be freely movable even if the `T`\n@@ -341,7 +342,7 @@ impl<P: Deref> Pin<P> {\n     /// pointed to by `pointer` is pinned, meaning that the data will not be moved or\n     /// its storage invalidated until it gets dropped. If the constructed `Pin<P>` does\n     /// not guarantee that the data `P` points to is pinned, constructing a\n-    /// `Pin<P>` is unsafe. In particular,\n+    /// `Pin<P>` is unsafe.\n     ///\n     /// By using this method, you are making a promise about the `P::Deref` and\n     /// `P::DerefMut` implementations, if they exist. Most importantly, they\n@@ -353,9 +354,9 @@ impl<P: Deref> Pin<P> {\n     /// must not be possible to obtain a `&mut P::Target` and then\n     /// move out of that reference (using, for example [`mem::swap`]).\n     ///\n-    /// For example, calling `Pin::new_unchecked`\n-    /// on an `&'a mut T` is unsafe because while you are able to pin it for the given\n-    /// lifetime `'a`, you have no control over whether it is kept pinned once `'a` ends:\n+    /// For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because\n+    /// while you are able to pin it for the given lifetime `'a`, you have no control\n+    /// over whether it is kept pinned once `'a` ends:\n     /// ```\n     /// use std::mem;\n     /// use std::pin::Pin;\n@@ -395,10 +396,10 @@ impl<P: Deref> Pin<P> {\n \n     /// Gets a pinned shared reference from this pinned pointer.\n     ///\n-    /// This is a generic method to go from `&Pin<SmartPointer<T>>` to `Pin<&T>`.\n+    /// This is a generic method to go from `&Pin<Pointer<T>>` to `Pin<&T>`.\n     /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n-    /// the pointee cannot move after `Pin<SmartPointer<T>>` got created.\n-    /// \"Malicious\" implementations of `SmartPointer::Deref` are likewise\n+    /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n+    /// \"Malicious\" implementations of `Pointer::Deref` are likewise\n     /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n@@ -410,10 +411,10 @@ impl<P: Deref> Pin<P> {\n impl<P: DerefMut> Pin<P> {\n     /// Gets a pinned mutable reference from this pinned pointer.\n     ///\n-    /// This is a generic method to go from `&mut Pin<SmartPointer<T>>` to `Pin<&mut T>`.\n+    /// This is a generic method to go from `&mut Pin<Pointer<T>>` to `Pin<&mut T>`.\n     /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n-    /// the pointee cannot move after `Pin<SmartPointer<T>>` got created.\n-    /// \"Malicious\" implementations of `SmartPointer::DerefMut` are likewise\n+    /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n+    /// \"Malicious\" implementations of `Pointer::DerefMut` are likewise\n     /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]"}]}