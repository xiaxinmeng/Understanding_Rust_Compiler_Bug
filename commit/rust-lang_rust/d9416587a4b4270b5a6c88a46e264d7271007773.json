{"sha": "d9416587a4b4270b5a6c88a46e264d7271007773", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NDE2NTg3YTRiNDI3MGI1YTZjODhhNDZlMjY0ZDcyNzEwMDc3NzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T18:51:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T18:51:13Z"}, "message": "Auto merge of #51959 - tmandry:make-implied-outlives-query, r=nikomatsakis\n\nTurn implied_outlives_bounds into a query\n\nRight now all this does is remove the error reporting in `implied_outlives_bounds`, which seems to work. Farming out full tests to Travis.\n\nFor #51649. That issue is deferred so not sure what's next.\n\nr? @nikomatsakis", "tree": {"sha": "cbee80de41286db2e52d2d4d2d719157c7ef38c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbee80de41286db2e52d2d4d2d719157c7ef38c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9416587a4b4270b5a6c88a46e264d7271007773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9416587a4b4270b5a6c88a46e264d7271007773", "html_url": "https://github.com/rust-lang/rust/commit/d9416587a4b4270b5a6c88a46e264d7271007773", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9416587a4b4270b5a6c88a46e264d7271007773/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "942b384d61590c39eb635596de0370a823001817", "url": "https://api.github.com/repos/rust-lang/rust/commits/942b384d61590c39eb635596de0370a823001817", "html_url": "https://github.com/rust-lang/rust/commit/942b384d61590c39eb635596de0370a823001817"}, {"sha": "0d8f3b3628129fa0b59e6f4953ab7fd60ebe09b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8f3b3628129fa0b59e6f4953ab7fd60ebe09b9", "html_url": "https://github.com/rust-lang/rust/commit/0d8f3b3628129fa0b59e6f4953ab7fd60ebe09b9"}], "stats": {"total": 738, "additions": 503, "deletions": 235}, "files": [{"sha": "78e57c6a5d78fb01afabd86525f0662a9343abe7", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -649,6 +649,7 @@ define_dep_nodes!( <'tcx>\n     [input] OutputFilenames,\n     [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n     [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n+    [] ImpliedOutlivesBounds(CanonicalTyGoal<'tcx>),\n     [] DropckOutlives(CanonicalTyGoal<'tcx>),\n     [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n     [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),"}, {"sha": "f0b6d25e9dae8a9be8a846028db373873af127fc", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -18,8 +18,10 @@\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n \n use infer::canonical::substitute::substitute_value;\n-use infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResult,\n-                       Certainty, QueryRegionConstraint, QueryResult, SmallCanonicalVarValues};\n+use infer::canonical::{\n+    Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResult, Certainty,\n+    QueryRegionConstraint, QueryResult, SmallCanonicalVarValues,\n+};\n use infer::region_constraints::{Constraint, RegionConstraintData};\n use infer::InferCtxtBuilder;\n use infer::{InferCtxt, InferOk, InferResult, RegionObligation};\n@@ -276,9 +278,9 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n         for (index, original_value) in original_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n-            let result_value = query_result\n-                .substitute_projected(self.tcx, &result_subst,\n-                                      |v| &v.var_values[CanonicalVar::new(index)]);\n+            let result_value = query_result.substitute_projected(self.tcx, &result_subst, |v| {\n+                &v.var_values[CanonicalVar::new(index)]\n+            });\n             match (original_value.unpack(), result_value.unpack()) {\n                 (UnpackedKind::Lifetime(ty::ReErased), UnpackedKind::Lifetime(ty::ReErased)) => {\n                     // no action needed\n@@ -312,11 +314,13 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // ...also include the other query region constraints from the query.\n         output_query_region_constraints.reserve(query_result.value.region_constraints.len());\n         for r_c in query_result.value.region_constraints.iter() {\n-            output_query_region_constraints.push(r_c.map_bound(|ty::OutlivesPredicate(k1, r2)| {\n-                let k1 = substitute_value(self.tcx, &result_subst, &k1);\n-                let r2 = substitute_value(self.tcx, &result_subst, &r2);\n-                ty::OutlivesPredicate(k1, r2)\n-            }));\n+            let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n+            let k1 = substitute_value(self.tcx, &result_subst, &k1);\n+            let r2 = substitute_value(self.tcx, &result_subst, &r2);\n+            if k1 != r2.into() {\n+                output_query_region_constraints\n+                    .push(ty::Binder::bind(ty::OutlivesPredicate(k1, r2)));\n+            }\n         }\n \n         let user_result: R ="}, {"sha": "57abdd18d353cb52a5084480b76726d3ddc2b27d", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,216 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use infer::InferCtxt;\n-use syntax::ast;\n-use syntax::codemap::Span;\n-use traits::{FulfillmentContext, TraitEngine, TraitEngineExt};\n-use ty::{self, Ty, TypeFoldable};\n-use ty::outlives::Component;\n-use ty::wf;\n-\n-/// Outlives bounds are relationships between generic parameters,\n-/// whether they both be regions (`'a: 'b`) or whether types are\n-/// involved (`T: 'a`).  These relationships can be extracted from the\n-/// full set of predicates we understand or also from types (in which\n-/// case they are called implied bounds). They are fed to the\n-/// `OutlivesEnv` which in turn is supplied to the region checker and\n-/// other parts of the inference system.\n-#[derive(Debug)]\n-pub enum OutlivesBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n-    /// Implied bounds are region relationships that we deduce\n-    /// automatically.  The idea is that (e.g.) a caller must check that a\n-    /// function's argument types are well-formed immediately before\n-    /// calling that fn, and hence the *callee* can assume that its\n-    /// argument types are well-formed. This may imply certain relationships\n-    /// between generic parameters. For example:\n-    ///\n-    ///     fn foo<'a,T>(x: &'a T)\n-    ///\n-    /// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-    /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `param_env`, the where-clauses in scope\n-    /// - `body_id`, the body-id to use when normalizing assoc types.\n-    ///   Note that this may cause outlives obligations to be injected\n-    ///   into the inference context with this body-id.\n-    /// - `ty`, the type that we are supposed to assume is WF.\n-    /// - `span`, a span to use when normalizing, hopefully not important,\n-    ///   might be useful if a `bug!` occurs.\n-    pub fn implied_outlives_bounds(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        body_id: ast::NodeId,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Vec<OutlivesBound<'tcx>> {\n-        let tcx = self.tcx;\n-\n-        // Sometimes when we ask what it takes for T: WF, we get back that\n-        // U: WF is required; in that case, we push U onto this stack and\n-        // process it next. Currently (at least) these resulting\n-        // predicates are always guaranteed to be a subset of the original\n-        // type, so we need not fear non-termination.\n-        let mut wf_types = vec![ty];\n-\n-        let mut implied_bounds = vec![];\n-\n-        let mut fulfill_cx = FulfillmentContext::new();\n-\n-        while let Some(ty) = wf_types.pop() {\n-            // Compute the obligations for `ty` to be well-formed. If `ty` is\n-            // an unresolved inference variable, just substituted an empty set\n-            // -- because the return type here is going to be things we *add*\n-            // to the environment, it's always ok for this set to be smaller\n-            // than the ultimate set. (Note: normally there won't be\n-            // unresolved inference variables here anyway, but there might be\n-            // during typeck under some circumstances.)\n-            let obligations = wf::obligations(self, param_env, body_id, ty, span).unwrap_or(vec![]);\n-\n-            // NB: All of these predicates *ought* to be easily proven\n-            // true. In fact, their correctness is (mostly) implied by\n-            // other parts of the program. However, in #42552, we had\n-            // an annoying scenario where:\n-            //\n-            // - Some `T::Foo` gets normalized, resulting in a\n-            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-            //   (not sure why it couldn't immediately get\n-            //   solved). This result of `_1` got cached.\n-            // - These obligations were dropped on the floor here,\n-            //   rather than being registered.\n-            // - Then later we would get a request to normalize\n-            //   `T::Foo` which would result in `_1` being used from\n-            //   the cache, but hence without the `T: Trait<Foo=_1>`\n-            //   constraint. As a result, `_1` never gets resolved,\n-            //   and we get an ICE (in dropck).\n-            //\n-            // Therefore, we register any predicates involving\n-            // inference variables. We restrict ourselves to those\n-            // involving inference variables both for efficiency and\n-            // to avoids duplicate errors that otherwise show up.\n-            fulfill_cx.register_predicate_obligations(\n-                self,\n-                obligations\n-                    .iter()\n-                    .filter(|o| o.predicate.has_infer_types())\n-                    .cloned(),\n-            );\n-\n-            // From the full set of obligations, just filter down to the\n-            // region relationships.\n-            implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n-                assert!(!obligation.has_escaping_regions());\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(..) |\n-                    ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Projection(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::ConstEvaluatable(..) => vec![],\n-\n-                    ty::Predicate::WellFormed(subty) => {\n-                        wf_types.push(subty);\n-                        vec![]\n-                    }\n-\n-                    ty::Predicate::RegionOutlives(ref data) => match data.no_late_bound_regions() {\n-                        None => vec![],\n-                        Some(ty::OutlivesPredicate(r_a, r_b)) => {\n-                            vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n-                        }\n-                    },\n-\n-                    ty::Predicate::TypeOutlives(ref data) => match data.no_late_bound_regions() {\n-                        None => vec![],\n-                        Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                            let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n-                            let components = tcx.outlives_components(ty_a);\n-                            Self::implied_bounds_from_components(r_b, components)\n-                        }\n-                    },\n-                }\n-            }));\n-        }\n-\n-        // Ensure that those obligations that we had to solve\n-        // get solved *here*.\n-        match fulfill_cx.select_all_or_error(self) {\n-            Ok(()) => (),\n-            Err(errors) => self.report_fulfillment_errors(&errors, None, false),\n-        }\n-\n-        implied_bounds\n-    }\n-\n-    /// When we have an implied bound that `T: 'a`, we can further break\n-    /// this down to determine what relationships would have to hold for\n-    /// `T: 'a` to hold. We get to assume that the caller has validated\n-    /// those relationships.\n-    fn implied_bounds_from_components(\n-        sub_region: ty::Region<'tcx>,\n-        sup_components: Vec<Component<'tcx>>,\n-    ) -> Vec<OutlivesBound<'tcx>> {\n-        sup_components\n-            .into_iter()\n-            .flat_map(|component| {\n-                match component {\n-                    Component::Region(r) =>\n-                        vec![OutlivesBound::RegionSubRegion(sub_region, r)],\n-                    Component::Param(p) =>\n-                        vec![OutlivesBound::RegionSubParam(sub_region, p)],\n-                    Component::Projection(p) =>\n-                        vec![OutlivesBound::RegionSubProjection(sub_region, p)],\n-                    Component::EscapingProjection(_) =>\n-                    // If the projection has escaping regions, don't\n-                    // try to infer any implied bounds even for its\n-                    // free components. This is conservative, because\n-                    // the caller will still have to prove that those\n-                    // free components outlive `sub_region`. But the\n-                    // idea is that the WAY that the caller proves\n-                    // that may change in the future and we want to\n-                    // give ourselves room to get smarter here.\n-                        vec![],\n-                    Component::UnresolvedInferenceVariable(..) =>\n-                        vec![],\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n-pub fn explicit_outlives_bounds<'tcx>(\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n-    debug!(\"explicit_outlives_bounds()\");\n-    param_env\n-        .caller_bounds\n-        .into_iter()\n-        .filter_map(move |predicate| match predicate {\n-            ty::Predicate::Projection(..) |\n-            ty::Predicate::Trait(..) |\n-            ty::Predicate::Subtype(..) |\n-            ty::Predicate::WellFormed(..) |\n-            ty::Predicate::ObjectSafe(..) |\n-            ty::Predicate::ClosureKind(..) |\n-            ty::Predicate::TypeOutlives(..) |\n-            ty::Predicate::ConstEvaluatable(..) => None,\n-            ty::Predicate::RegionOutlives(ref data) => data.no_late_bound_regions().map(\n-                |ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a),\n-            ),\n-        })\n-}"}, {"sha": "7f59a6794efbd15efcc67469326c9ecdbed3a53a", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -10,7 +10,7 @@\n \n use infer::{GenericKind, InferCtxt};\n use infer::outlives::free_region_map::FreeRegionMap;\n-use infer::outlives::bounds::{self, OutlivesBound};\n+use traits::query::outlives_bounds::{self, OutlivesBound};\n use ty::{self, Ty};\n \n use syntax::ast;\n@@ -50,7 +50,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: vec![],\n         };\n \n-        env.add_outlives_bounds(None, bounds::explicit_outlives_bounds(param_env));\n+        env.add_outlives_bounds(None, outlives_bounds::explicit_outlives_bounds(param_env));\n \n         env\n     }"}, {"sha": "bb3703b2157328cd88f9b65a855d2b48dcd0749e", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -12,5 +12,4 @@\n \n pub mod env;\n pub mod free_region_map;\n-pub mod bounds;\n pub mod obligations;"}, {"sha": "35f17aebc0443481f0bfa1f913ddcc8c00915f7e", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -23,6 +23,7 @@ pub mod dropck_outlives;\n pub mod evaluate_obligation;\n pub mod normalize;\n pub mod normalize_erasing_regions;\n+pub mod outlives_bounds;\n pub mod type_op;\n \n pub type CanonicalProjectionGoal<'tcx> ="}, {"sha": "f79ce73ad928a933dc8081d8ca5dec71380ec9aa", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use rustc_data_structures::small_vec::SmallVec;\n+use traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n+use traits::query::NoSolution;\n+use ty::{self, Ty, TyCtxt};\n+\n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+use std::mem;\n+\n+/// Outlives bounds are relationships between generic parameters,\n+/// whether they both be regions (`'a: 'b`) or whether types are\n+/// involved (`T: 'a`).  These relationships can be extracted from the\n+/// full set of predicates we understand or also from types (in which\n+/// case they are called implied bounds). They are fed to the\n+/// `OutlivesEnv` which in turn is supplied to the region checker and\n+/// other parts of the inference system.\n+#[derive(Clone, Debug)]\n+pub enum OutlivesBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for self::OutlivesBound<'a> {\n+        type Lifted = self::OutlivesBound<'tcx>;\n+        (self::OutlivesBound::RegionSubRegion)(a, b),\n+        (self::OutlivesBound::RegionSubParam)(a, b),\n+        (self::OutlivesBound::RegionSubProjection)(a, b),\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for self::OutlivesBound<'tcx> {\n+        (self::OutlivesBound::RegionSubRegion)(a, b),\n+        (self::OutlivesBound::RegionSubParam)(a, b),\n+        (self::OutlivesBound::RegionSubProjection)(a, b),\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            OutlivesBound::RegionSubRegion(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            OutlivesBound::RegionSubParam(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            OutlivesBound::RegionSubProjection(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Implied bounds are region relationships that we deduce\n+    /// automatically.  The idea is that (e.g.) a caller must check that a\n+    /// function's argument types are well-formed immediately before\n+    /// calling that fn, and hence the *callee* can assume that its\n+    /// argument types are well-formed. This may imply certain relationships\n+    /// between generic parameters. For example:\n+    ///\n+    ///     fn foo<'a,T>(x: &'a T)\n+    ///\n+    /// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+    /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `param_env`, the where-clauses in scope\n+    /// - `body_id`, the body-id to use when normalizing assoc types.\n+    ///   Note that this may cause outlives obligations to be injected\n+    ///   into the inference context with this body-id.\n+    /// - `ty`, the type that we are supposed to assume is WF.\n+    /// - `span`, a span to use when normalizing, hopefully not important,\n+    ///   might be useful if a `bug!` occurs.\n+    pub fn implied_outlives_bounds(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Vec<OutlivesBound<'tcx>> {\n+        debug!(\"implied_outlives_bounds(ty = {:?})\", ty);\n+\n+        let mut orig_values = SmallVec::new();\n+        let key = self.canonicalize_query(&param_env.and(ty), &mut orig_values);\n+        let result = match self.tcx.global_tcx().implied_outlives_bounds(key) {\n+            Ok(r) => r,\n+            Err(NoSolution) => {\n+                self.tcx.sess.delay_span_bug(\n+                    span,\n+                    \"implied_outlives_bounds failed to solve all obligations\"\n+                );\n+                return vec![];\n+            }\n+        };\n+        assert!(result.value.is_proven());\n+\n+        let result = self.instantiate_query_result_and_region_obligations(\n+            &ObligationCause::misc(span, body_id), param_env, &orig_values, &result);\n+        debug!(\"implied_outlives_bounds for {:?}: {:#?}\", ty, result);\n+        let result = match result {\n+            Ok(v) => v,\n+            Err(_) => {\n+                self.tcx.sess.delay_span_bug(\n+                    span,\n+                    \"implied_outlives_bounds failed to instantiate\"\n+                );\n+                return vec![];\n+            }\n+        };\n+\n+        // Instantiation may have produced new inference variables and constraints on those\n+        // variables. Process these constraints.\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        fulfill_cx.register_predicate_obligations(self, result.obligations);\n+        if let Err(_) = fulfill_cx.select_all_or_error(self) {\n+            self.tcx.sess.delay_span_bug(\n+                span,\n+                \"implied_outlives_bounds failed to solve obligations from instantiation\"\n+            );\n+        }\n+\n+        result.value\n+    }\n+}\n+\n+pub fn explicit_outlives_bounds<'tcx>(\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n+    debug!(\"explicit_outlives_bounds()\");\n+    param_env\n+        .caller_bounds\n+        .into_iter()\n+        .filter_map(move |predicate| match predicate {\n+            ty::Predicate::Projection(..) |\n+            ty::Predicate::Trait(..) |\n+            ty::Predicate::Subtype(..) |\n+            ty::Predicate::WellFormed(..) |\n+            ty::Predicate::ObjectSafe(..) |\n+            ty::Predicate::ClosureKind(..) |\n+            ty::Predicate::TypeOutlives(..) |\n+            ty::Predicate::ConstEvaluatable(..) => None,\n+            ty::Predicate::RegionOutlives(ref data) => data.no_late_bound_regions().map(\n+                |ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a),\n+            ),\n+        })\n+}"}, {"sha": "8db33032625b262d6f3d6e37c2745ac59a4b563f", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -87,6 +87,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::implied_outlives_bounds<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTyGoal<'tcx>) -> String {\n+        format!(\"computing implied outlives bounds for `{:?}`\", goal)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::dropck_outlives<'tcx> {\n     fn describe(_tcx: TyCtxt, goal: CanonicalTyGoal<'tcx>) -> String {\n         format!(\"computing dropck types for `{:?}`\", goal)"}, {"sha": "1b1020c9bd86dbe47d18eb8d3c466909451e6d7c", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -38,6 +38,7 @@ use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal,\n                     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal, NoSolution};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n+use traits::query::outlives_bounds::OutlivesBound;\n use traits::specialization_graph;\n use traits::Clauses;\n use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n@@ -551,6 +552,13 @@ define_queries! { <'tcx>\n             ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Ty<'tcx>,\n \n+        [] fn implied_outlives_bounds: ImpliedOutlivesBounds(\n+            CanonicalTyGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n+            NoSolution,\n+        >,\n+\n         /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n         [] fn dropck_outlives: DropckOutlives(\n             CanonicalTyGoal<'tcx>"}, {"sha": "7a9827b50a176ec35910d2429fdd370f5ac2ec5d", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -1036,6 +1036,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ConstValueToAllocation |\n         DepKind::NormalizeProjectionTy |\n         DepKind::NormalizeTyAfterErasingRegions |\n+        DepKind::ImpliedOutlivesBounds |\n         DepKind::DropckOutlives |\n         DepKind::EvaluateObligation |\n         DepKind::TypeOpEq |"}, {"sha": "ad29f808285b1ae99d9b6cf3f993b546830e57b1", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -56,6 +56,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::ty::BoundRegion,\n     ::ty::ClosureKind,\n     ::ty::IntVarValue,\n+    ::ty::ParamTy,\n     ::syntax_pos::Span,\n }\n "}, {"sha": "e7930b2148156132919fc633c1217caf176ee5ef", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -25,10 +25,10 @@\n use either::Either;\n use rustc::hir::def_id::DefId;\n use rustc::hir::{self, BodyOwnerKind, HirId};\n-use rustc::infer::outlives::bounds::{self, OutlivesBound};\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n@@ -494,7 +494,10 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let num_universals = self.infcx.num_region_vars();\n \n         // Insert the facts we know from the predicates. Why? Why not.\n-        self.add_outlives_bounds(&indices, bounds::explicit_outlives_bounds(param_env));\n+        self.add_outlives_bounds(\n+            &indices,\n+            outlives_bounds::explicit_outlives_bounds(param_env),\n+        );\n \n         // Add the implied bounds from inputs and outputs.\n         for ty in inputs_and_output {"}, {"sha": "b6560fae110d52cae26b63d0a8646d6fca3562de", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -0,0 +1,185 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Provider for the `implied_outlives_bounds` query.\n+//! Do not call this query directory. See [`rustc::traits::query::implied_outlives_bounds`].\n+\n+use rustc::infer::InferCtxt;\n+use rustc::infer::canonical::{self, Canonical};\n+use rustc::traits::{TraitEngine, TraitEngineExt};\n+use rustc::traits::query::outlives_bounds::OutlivesBound;\n+use rustc::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::outlives::Component;\n+use rustc::ty::query::Providers;\n+use rustc::ty::wf;\n+use syntax::ast::DUMMY_NODE_ID;\n+use syntax::codemap::DUMMY_SP;\n+use rustc::traits::FulfillmentContext;\n+\n+use rustc_data_structures::sync::Lrc;\n+\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        implied_outlives_bounds,\n+        ..*p\n+    };\n+}\n+\n+fn implied_outlives_bounds<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: CanonicalTyGoal<'tcx>,\n+) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Vec<OutlivesBound<'tcx>>>>>,\n+        NoSolution,\n+> {\n+    tcx.infer_ctxt()\n+       .enter_canonical_trait_query(&goal, |infcx, _fulfill_cx, key| {\n+           let (param_env, ty) = key.into_parts();\n+           compute_implied_outlives_bounds(&infcx, param_env, ty)\n+       })\n+}\n+\n+fn compute_implied_outlives_bounds<'tcx>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>\n+) -> Fallible<Vec<OutlivesBound<'tcx>>> {\n+    let tcx = infcx.tcx;\n+\n+    // Sometimes when we ask what it takes for T: WF, we get back that\n+    // U: WF is required; in that case, we push U onto this stack and\n+    // process it next. Currently (at least) these resulting\n+    // predicates are always guaranteed to be a subset of the original\n+    // type, so we need not fear non-termination.\n+    let mut wf_types = vec![ty];\n+\n+    let mut implied_bounds = vec![];\n+\n+    let mut fulfill_cx = FulfillmentContext::new();\n+\n+    while let Some(ty) = wf_types.pop() {\n+        // Compute the obligations for `ty` to be well-formed. If `ty` is\n+        // an unresolved inference variable, just substituted an empty set\n+        // -- because the return type here is going to be things we *add*\n+        // to the environment, it's always ok for this set to be smaller\n+        // than the ultimate set. (Note: normally there won't be\n+        // unresolved inference variables here anyway, but there might be\n+        // during typeck under some circumstances.)\n+        let obligations =\n+            wf::obligations(infcx, param_env, DUMMY_NODE_ID, ty, DUMMY_SP).unwrap_or(vec![]);\n+\n+        // NB: All of these predicates *ought* to be easily proven\n+        // true. In fact, their correctness is (mostly) implied by\n+        // other parts of the program. However, in #42552, we had\n+        // an annoying scenario where:\n+        //\n+        // - Some `T::Foo` gets normalized, resulting in a\n+        //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n+        //   (not sure why it couldn't immediately get\n+        //   solved). This result of `_1` got cached.\n+        // - These obligations were dropped on the floor here,\n+        //   rather than being registered.\n+        // - Then later we would get a request to normalize\n+        //   `T::Foo` which would result in `_1` being used from\n+        //   the cache, but hence without the `T: Trait<Foo=_1>`\n+        //   constraint. As a result, `_1` never gets resolved,\n+        //   and we get an ICE (in dropck).\n+        //\n+        // Therefore, we register any predicates involving\n+        // inference variables. We restrict ourselves to those\n+        // involving inference variables both for efficiency and\n+        // to avoids duplicate errors that otherwise show up.\n+        fulfill_cx.register_predicate_obligations(\n+            infcx,\n+            obligations\n+                .iter()\n+                .filter(|o| o.predicate.has_infer_types())\n+                .cloned(),\n+        );\n+\n+        // From the full set of obligations, just filter down to the\n+        // region relationships.\n+        implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+            assert!(!obligation.has_escaping_regions());\n+            match obligation.predicate {\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Subtype(..) |\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::ClosureKind(..) |\n+                ty::Predicate::ObjectSafe(..) |\n+                ty::Predicate::ConstEvaluatable(..) => vec![],\n+\n+                ty::Predicate::WellFormed(subty) => {\n+                    wf_types.push(subty);\n+                    vec![]\n+                }\n+\n+                ty::Predicate::RegionOutlives(ref data) => match data.no_late_bound_regions() {\n+                    None => vec![],\n+                    Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                        vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n+                    }\n+                },\n+\n+                ty::Predicate::TypeOutlives(ref data) => match data.no_late_bound_regions() {\n+                    None => vec![],\n+                    Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                        let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                        let components = tcx.outlives_components(ty_a);\n+                        implied_bounds_from_components(r_b, components)\n+                    }\n+                },\n+            }\n+        }));\n+    }\n+\n+    // Ensure that those obligations that we had to solve\n+    // get solved *here*.\n+    match fulfill_cx.select_all_or_error(infcx) {\n+        Ok(()) => Ok(implied_bounds),\n+        Err(_) => Err(NoSolution),\n+    }\n+}\n+\n+/// When we have an implied bound that `T: 'a`, we can further break\n+/// this down to determine what relationships would have to hold for\n+/// `T: 'a` to hold. We get to assume that the caller has validated\n+/// those relationships.\n+fn implied_bounds_from_components(\n+    sub_region: ty::Region<'tcx>,\n+    sup_components: Vec<Component<'tcx>>,\n+) -> Vec<OutlivesBound<'tcx>> {\n+    sup_components\n+        .into_iter()\n+        .flat_map(|component| {\n+            match component {\n+                Component::Region(r) =>\n+                    vec![OutlivesBound::RegionSubRegion(sub_region, r)],\n+                Component::Param(p) =>\n+                    vec![OutlivesBound::RegionSubParam(sub_region, p)],\n+                Component::Projection(p) =>\n+                    vec![OutlivesBound::RegionSubProjection(sub_region, p)],\n+                Component::EscapingProjection(_) =>\n+                // If the projection has escaping regions, don't\n+                // try to infer any implied bounds even for its\n+                // free components. This is conservative, because\n+                // the caller will still have to prove that those\n+                // free components outlive `sub_region`. But the\n+                // idea is that the WAY that the caller proves\n+                // that may change in the future and we want to\n+                // give ourselves room to get smarter here.\n+                    vec![],\n+                Component::UnresolvedInferenceVariable(..) =>\n+                    vec![],\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "2a4cacb5623ecc6b7db5b94404fdff3bb8cf08da", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -33,6 +33,7 @@ extern crate syntax_pos;\n mod chalk_context;\n mod dropck_outlives;\n mod evaluate_obligation;\n+mod implied_outlives_bounds;\n mod normalize_projection_ty;\n mod normalize_erasing_regions;\n pub mod lowering;\n@@ -43,6 +44,7 @@ use rustc::ty::query::Providers;\n pub fn provide(p: &mut Providers) {\n     dropck_outlives::provide(p);\n     evaluate_obligation::provide(p);\n+    implied_outlives_bounds::provide(p);\n     lowering::provide(p);\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);"}, {"sha": "6ad97d072df86ed49119f93a096678e728680faa", "filename": "src/test/ui/issue-20831-debruijn.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fui%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fui%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-20831-debruijn.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -38,6 +38,8 @@ impl<'a> Publisher<'a> for MyStruct<'a> {\n     fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n         // Not obvious, but there is an implicit lifetime here -------^\n         //~^^ ERROR cannot infer\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n         //\n         // The fact that `Publisher` is using an implicit lifetime is\n         // what was causing the debruijn accounting to be off, so"}, {"sha": "556d8b402c4574f91e84cb867776c44d1ad895fd", "filename": "src/test/ui/issue-20831-debruijn.stderr", "status": "modified", "additions": 67, "deletions": 4, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fui%2Fissue-20831-debruijn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fui%2Fissue-20831-debruijn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-20831-debruijn.stderr?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -1,10 +1,72 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-20831-debruijn.rs:38:5\n+   |\n+LL | /     fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n+LL | |         // Not obvious, but there is an implicit lifetime here -------^\n+LL | |         //~^^ ERROR cannot infer\n+LL | |         //~| ERROR mismatched types\n+...  |\n+LL | |         self.sub = t;\n+LL | |     }\n+   | |_____^ lifetime mismatch\n+   |\n+   = note: expected type `'a`\n+              found type ``\n+note: the anonymous lifetime #2 defined on the method body at 38:5...\n+  --> $DIR/issue-20831-debruijn.rs:38:5\n+   |\n+LL | /     fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n+LL | |         // Not obvious, but there is an implicit lifetime here -------^\n+LL | |         //~^^ ERROR cannot infer\n+LL | |         //~| ERROR mismatched types\n+...  |\n+LL | |         self.sub = t;\n+LL | |     }\n+   | |_____^\n+note: ...does not necessarily outlive the lifetime 'a as defined on the impl at 36:6\n+  --> $DIR/issue-20831-debruijn.rs:36:6\n+   |\n+LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n+   |      ^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-20831-debruijn.rs:38:5\n+   |\n+LL | /     fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n+LL | |         // Not obvious, but there is an implicit lifetime here -------^\n+LL | |         //~^^ ERROR cannot infer\n+LL | |         //~| ERROR mismatched types\n+...  |\n+LL | |         self.sub = t;\n+LL | |     }\n+   | |_____^ lifetime mismatch\n+   |\n+   = note: expected type `'a`\n+              found type ``\n+note: the lifetime 'a as defined on the impl at 36:6...\n+  --> $DIR/issue-20831-debruijn.rs:36:6\n+   |\n+LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n+   |      ^^\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the method body at 38:5\n+  --> $DIR/issue-20831-debruijn.rs:38:5\n+   |\n+LL | /     fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n+LL | |         // Not obvious, but there is an implicit lifetime here -------^\n+LL | |         //~^^ ERROR cannot infer\n+LL | |         //~| ERROR mismatched types\n+...  |\n+LL | |         self.sub = t;\n+LL | |     }\n+   | |_____^\n+\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n   --> $DIR/issue-20831-debruijn.rs:38:5\n    |\n LL | /     fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n LL | |         // Not obvious, but there is an implicit lifetime here -------^\n LL | |         //~^^ ERROR cannot infer\n-LL | |         //\n+LL | |         //~| ERROR mismatched types\n ...  |\n LL | |         self.sub = t;\n LL | |     }\n@@ -16,7 +78,7 @@ note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on th\n LL | /     fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n LL | |         // Not obvious, but there is an implicit lifetime here -------^\n LL | |         //~^^ ERROR cannot infer\n-LL | |         //\n+LL | |         //~| ERROR mismatched types\n ...  |\n LL | |         self.sub = t;\n LL | |     }\n@@ -30,6 +92,7 @@ LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n            expected Publisher<'_>\n               found Publisher<'_>\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0495`.\n+Some errors occurred: E0308, E0495.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "1fd00db536cf60b10769721e4a5f3d4b49a877b5", "filename": "src/test/ui/nll/issue-52078.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fui%2Fnll%2Fissue-52078.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9416587a4b4270b5a6c88a46e264d7271007773/src%2Ftest%2Fui%2Fnll%2Fissue-52078.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52078.rs?ref=d9416587a4b4270b5a6c88a46e264d7271007773", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![allow(unused_variables)]\n+\n+// Regression test for #52078: we were failing to infer a relationship\n+// between `'a` and `'b` below due to inference variables introduced\n+// during the normalization process.\n+//\n+// compile-pass\n+\n+struct Drain<'a, T: 'a> {\n+    _marker: ::std::marker::PhantomData<&'a T>,\n+}\n+\n+trait Join {\n+    type Value;\n+    fn get(value: &mut Self::Value);\n+}\n+\n+impl<'a, T> Join for Drain<'a, T> {\n+    type Value = &'a mut Option<T>;\n+\n+    fn get<'b>(value: &'b mut Self::Value) {\n+    }\n+}\n+\n+fn main() {\n+}"}]}