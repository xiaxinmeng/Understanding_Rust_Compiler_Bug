{"sha": "eb997d76d5a1c0ed933ab76459233e3650d2771d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViOTk3ZDc2ZDVhMWMwZWQ5MzNhYjc2NDU5MjMzZTM2NTBkMjc3MWQ=", "commit": {"author": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-10-12T04:12:56Z"}, "committer": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-11-01T22:16:59Z"}, "message": "add `U: Trait` to the param env during DispatchFromDyn check\nalso updated the doc on `receiver_is_dispatchable` to reflect current state of the implementation", "tree": {"sha": "003c64c93418097eee6c7de52d62b4a785ca171a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/003c64c93418097eee6c7de52d62b4a785ca171a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb997d76d5a1c0ed933ab76459233e3650d2771d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb997d76d5a1c0ed933ab76459233e3650d2771d", "html_url": "https://github.com/rust-lang/rust/commit/eb997d76d5a1c0ed933ab76459233e3650d2771d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb997d76d5a1c0ed933ab76459233e3650d2771d/comments", "author": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5b25f8196567b5a86eb0f805852e11889d80075", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b25f8196567b5a86eb0f805852e11889d80075", "html_url": "https://github.com/rust-lang/rust/commit/b5b25f8196567b5a86eb0f805852e11889d80075"}], "stats": {"total": 67, "additions": 40, "deletions": 27}, "files": [{"sha": "1d76ccdca3161b33a2f6b7cb6b447159f955314d", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/eb997d76d5a1c0ed933ab76459233e3650d2771d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb997d76d5a1c0ed933ab76459233e3650d2771d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=eb997d76d5a1c0ed933ab76459233e3650d2771d", "patch": "@@ -437,16 +437,16 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// in the following way:\n     /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`\n     /// - require the following bound:\n-    ///       forall(T: Trait) {\n-    ///           Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n-    ///       }\n-    ///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n+    ///\n+    ///        Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+    ///\n+    ///    where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n     ///   (substitution notation).\n     ///\n     /// some examples of receiver types and their required obligation\n-    /// - `&'a mut self` requires `&'a mut T: DispatchFromDyn<&'a mut dyn Trait>`\n-    /// - `self: Rc<Self>` requires `Rc<T>: DispatchFromDyn<Rc<dyn Trait>>`\n-    /// - `self: Pin<Box<Self>>` requires `Pin<Box<T>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`\n+    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`\n+    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`\n+    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`\n     ///\n     /// The only case where the receiver is not dispatchable, but is still a valid receiver\n     /// type (just not object-safe), is when there is more than one level of pointer indirection.\n@@ -456,14 +456,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// contained by the trait object, because the object that needs to be coerced is behind\n     /// a pointer.\n     ///\n-    /// In practice, there are issues with the above bound: `where` clauses that apply to `Self`\n-    /// would have to apply to `T`, trait object types have a lot of parameters that need to\n-    /// be filled in (lifetime and type parameters, and the lifetime of the actual object), and\n-    /// I'm pretty sure using `dyn Trait` in the query causes another object-safety query for\n-    /// `Trait`, resulting in cyclic queries. So in the implementation, we use the following,\n-    /// more general bound:\n+    /// In practice, we cannot use `dyn Trait` explicitly in the obligation because it would result\n+    /// in a new check that `Trait` is object safe, creating a cycle. So instead, we fudge a little\n+    /// by introducing a new type parameter `U` such that `Self: Unsize<U>` and `U: Trait + ?Sized`,\n+    /// and use `U` in place of `dyn Trait`. Written as a chalk-style query:\n     ///\n-    ///     forall (U: ?Sized) {\n+    ///     forall (U: Trait + ?Sized) {\n     ///         if (Self: Unsize<U>) {\n     ///             Receiver: DispatchFromDyn<Receiver[Self => U]>\n     ///         }\n@@ -493,6 +491,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return false;\n         };\n \n+        // the type `U` in the query\n         // use a bogus type parameter to mimick a forall(U) query using u32::MAX for now.\n         // FIXME(mikeyhew) this is a total hack, and we should replace it when real forall queries\n         // are implemented\n@@ -501,34 +500,48 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             Name::intern(\"RustaceansAreAwesome\").as_interned_str(),\n         );\n \n-        // create a modified param env, with `Self: Unsize<U>` added to the caller bounds\n+        // `Receiver[Self => U]`\n+        let unsized_receiver_ty = self.receiver_for_self_ty(\n+            receiver_ty, unsized_self_ty, method.def_id\n+        );\n+\n+        // create a modified param env, with `Self: Unsize<U>` and `U: Trait` added to caller bounds\n+        // `U: ?Sized` is already implied here\n         let param_env = {\n             let mut param_env = self.param_env(method.def_id);\n \n-            let predicate = ty::TraitRef {\n+            // Self: Unsize<U>\n+            let unsize_predicate = ty::TraitRef {\n                 def_id: unsize_did,\n                 substs: self.mk_substs_trait(self.mk_self_type(), &[unsized_self_ty.into()]),\n             }.to_predicate();\n \n+            // U: Trait<Arg1, ..., ArgN>\n+            let trait_predicate = {\n+                let substs = Substs::for_item(self, method.container.assert_trait(), |param, _| {\n+                    if param.index == 0 {\n+                        unsized_self_ty.into()\n+                    } else {\n+                        self.mk_param_from_def(param)\n+                    }\n+                });\n+\n+                ty::TraitRef {\n+                    def_id: unsize_did,\n+                    substs,\n+                }.to_predicate()\n+            };\n+\n             let caller_bounds: Vec<Predicate<'tcx>> = param_env.caller_bounds.iter().cloned()\n-                .chain(iter::once(predicate))\n+                .chain(iter::once(unsize_predicate))\n+                .chain(iter::once(trait_predicate))\n                 .collect();\n \n             param_env.caller_bounds = self.intern_predicates(&caller_bounds);\n \n             param_env\n         };\n \n-        let receiver_substs = Substs::for_item(self, method.def_id, |param, _| {\n-            if param.index == 0 {\n-                unsized_self_ty.into()\n-            } else {\n-                self.mk_param_from_def(param)\n-            }\n-        });\n-        // the type `Receiver[Self => U]` in the query\n-        let unsized_receiver_ty = receiver_ty.subst(self, receiver_substs);\n-\n         // Receiver: DispatchFromDyn<Receiver[Self => U]>\n         let obligation = {\n             let predicate = ty::TraitRef {"}]}