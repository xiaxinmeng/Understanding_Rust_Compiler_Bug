{"sha": "49e51fe65a7762841aa7421b4c643b042c4fe4c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZTUxZmU2NWE3NzYyODQxYWE3NDIxYjRjNjQzYjA0MmM0ZmU0YzY=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-13T15:24:47Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-13T16:15:42Z"}, "message": "lifetimes: try to fix w.r.t. lifetimes from parent scopes (fixes #162)", "tree": {"sha": "6f5b505e3238fa4c11d766c8fbeac276aeea7b69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f5b505e3238fa4c11d766c8fbeac276aeea7b69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49e51fe65a7762841aa7421b4c643b042c4fe4c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49e51fe65a7762841aa7421b4c643b042c4fe4c6", "html_url": "https://github.com/rust-lang/rust/commit/49e51fe65a7762841aa7421b4c643b042c4fe4c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49e51fe65a7762841aa7421b4c643b042c4fe4c6/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09db7f3fee25684ab0783ae80595fcc227ad0074", "url": "https://api.github.com/repos/rust-lang/rust/commits/09db7f3fee25684ab0783ae80595fcc227ad0074", "html_url": "https://github.com/rust-lang/rust/commit/09db7f3fee25684ab0783ae80595fcc227ad0074"}], "stats": {"total": 67, "additions": 55, "deletions": 12}, "files": [{"sha": "c333f04ab449be72877268cec310285670f877b1", "filename": "src/lifetimes.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/49e51fe65a7762841aa7421b4c643b042c4fe4c6/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49e51fe65a7762841aa7421b4c643b042c4fe4c6/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=49e51fe65a7762841aa7421b4c643b042c4fe4c6", "patch": "@@ -18,14 +18,23 @@ impl LintPass for LifetimePass {\n         lint_array!(NEEDLESS_LIFETIMES)\n     }\n \n-    fn check_fn(&mut self, cx: &Context, kind: FnKind, decl: &FnDecl,\n-                _: &Block, span: Span, _: NodeId) {\n-        if in_external_macro(cx, span) {\n-            return;\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n+            check_fn_inner(cx, decl, None, &generics.lifetimes, item.span);\n         }\n-        if could_use_elision(kind, decl) {\n-            span_lint(cx, NEEDLESS_LIFETIMES, span,\n-                      \"explicit lifetimes given in parameter types where they could be elided\");\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+        if let MethodImplItem(ref sig, _) = item.node {\n+            check_fn_inner(cx, &*sig.decl, Some(&sig.explicit_self),\n+                           &sig.generics.lifetimes, item.span);\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+        if let MethodTraitItem(ref sig, _) = item.node {\n+            check_fn_inner(cx, &*sig.decl, Some(&sig.explicit_self),\n+                           &sig.generics.lifetimes, item.span);\n         }\n     }\n }\n@@ -39,19 +48,43 @@ enum RefLt {\n }\n use self::RefLt::*;\n \n-fn could_use_elision(kind: FnKind, func: &FnDecl) -> bool {\n+fn check_fn_inner(cx: &Context, decl: &FnDecl, slf: Option<&ExplicitSelf>,\n+                  named_lts: &[LifetimeDef], span: Span) {\n+    if in_external_macro(cx, span) {\n+        return;\n+    }\n+    if could_use_elision(decl, slf, named_lts) {\n+        span_lint(cx, NEEDLESS_LIFETIMES, span,\n+                  \"explicit lifetimes given in parameter types where they could be elided\");\n+    }\n+}\n+\n+fn could_use_elision(func: &FnDecl, slf: Option<&ExplicitSelf>,\n+                     named_lts: &[LifetimeDef]) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n+    // All lifetimes must be unnamed, 'static or defined without bounds on the\n+    // level of the current item.\n+\n+    // check named LTs\n+    let mut allowed_lts = HashSet::new();\n+    for lt in named_lts {\n+        if lt.bounds.is_empty() {\n+            allowed_lts.insert(Named(lt.lifetime.name));\n+        }\n+    }\n+    allowed_lts.insert(Unnamed);\n+    allowed_lts.insert(Static);\n \n     // these will collect all the lifetimes for references in arg/return types\n     let mut input_visitor = RefVisitor(Vec::new());\n     let mut output_visitor = RefVisitor(Vec::new());\n \n     // extract lifetime in \"self\" argument for methods (there is a \"self\" argument\n     // in func.inputs, but its type is TyInfer)\n-    if let FnKind::FkMethod(_, sig, _) = kind {\n-        match sig.explicit_self.node {\n+    if let Some(slf) = slf {\n+        match slf.node {\n             SelfRegion(ref opt_lt, _, _) => input_visitor.record(opt_lt),\n             SelfExplicit(ref ty, _) => walk_ty(&mut input_visitor, ty),\n             _ => { }\n@@ -69,6 +102,13 @@ fn could_use_elision(kind: FnKind, func: &FnDecl) -> bool {\n     let input_lts = input_visitor.into_vec();\n     let output_lts = output_visitor.into_vec();\n \n+    // check for lifetimes from higher scopes\n+    for lt in input_lts.iter().chain(output_lts.iter()) {\n+        if !allowed_lts.contains(lt) {\n+            return false;\n+        }\n+    }\n+\n     // no input lifetimes? easy case!\n     if input_lts.is_empty() {\n         return false;"}, {"sha": "7f463ec70b42ec71491a00ca64b7463e7c97b0dc", "filename": "tests/compile-fail/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49e51fe65a7762841aa7421b4c643b042c4fe4c6/tests%2Fcompile-fail%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49e51fe65a7762841aa7421b4c643b042c4fe4c6/tests%2Fcompile-fail%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flifetimes.rs?ref=49e51fe65a7762841aa7421b4c643b042c4fe4c6", "patch": "@@ -31,11 +31,13 @@ fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> { Ok(x) }\n \n type Ref<'r> = &'r u8;\n \n-fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) { }\n+fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) { } // no error, same lifetime on two params\n \n-fn lifetime_param_2<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) { }\n+fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) { }\n //~^ERROR explicit lifetimes given\n \n+fn lifetime_param_3<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) { } // no error, bounded lifetime\n+\n struct X {\n     x: u8,\n }\n@@ -68,6 +70,7 @@ fn main() {\n     let _ = deep_reference_3(&1, 2);\n     lifetime_param_1(&1, &2);\n     lifetime_param_2(&1, &2);\n+    lifetime_param_3(&1, &2);\n \n     let foo = X { x: 1 };\n     foo.self_and_out();"}]}