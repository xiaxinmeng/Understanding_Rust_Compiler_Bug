{"sha": "4f69b7fb850cae83ea3d5adfeb8520418c976403", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNjliN2ZiODUwY2FlODNlYTNkNWFkZmViODUyMDQxOGM5NzY0MDM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-05T00:20:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-12T20:06:03Z"}, "message": "Avoid comparing fields by name when possible\n\nResolve them into field indices once and then use those resolutions\n\n+ Fix rebase", "tree": {"sha": "a5c3bdf0d80f9cbc8a0624c4686dd89f444c46fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5c3bdf0d80f9cbc8a0624c4686dd89f444c46fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f69b7fb850cae83ea3d5adfeb8520418c976403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f69b7fb850cae83ea3d5adfeb8520418c976403", "html_url": "https://github.com/rust-lang/rust/commit/4f69b7fb850cae83ea3d5adfeb8520418c976403", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f69b7fb850cae83ea3d5adfeb8520418c976403/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44acea4d880b646caa00a7237ea1a17031dd2116", "url": "https://api.github.com/repos/rust-lang/rust/commits/44acea4d880b646caa00a7237ea1a17031dd2116", "html_url": "https://github.com/rust-lang/rust/commit/44acea4d880b646caa00a7237ea1a17031dd2116"}], "stats": {"total": 470, "additions": 244, "deletions": 226}, "files": [{"sha": "be9f8b8dac5c05bbced574cf89dacc6d2191eba8", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -658,6 +658,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Struct(ref qpath, ref fields, _) => {\n             visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             for field in fields {\n+                visitor.visit_id(field.node.id);\n                 visitor.visit_name(field.span, field.node.name);\n                 visitor.visit_pat(&field.node.pat)\n             }\n@@ -959,6 +960,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprStruct(ref qpath, ref fields, ref optional_base) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n             for field in fields {\n+                visitor.visit_id(field.id);\n                 visitor.visit_name(field.name.span, field.name.node);\n                 visitor.visit_expr(&field.expr)\n             }"}, {"sha": "fee076acb207eadde431c66a51b1095eb65f9385", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -2100,6 +2100,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n+            id: self.next_id().node_id,\n             name: respan(f.ident.span, self.lower_ident(f.ident)),\n             expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n@@ -2863,6 +2864,7 @@ impl<'a> LoweringContext<'a> {\n                     .map(|f| Spanned {\n                         span: f.span,\n                         node: hir::FieldPat {\n+                            id: self.next_id().node_id,\n                             name: self.lower_ident(f.node.ident),\n                             pat: self.lower_pat(&f.node.pat),\n                             is_shorthand: f.node.is_shorthand,\n@@ -3741,6 +3743,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn field(&mut self, name: Name, expr: P<hir::Expr>, span: Span) -> hir::Field {\n         hir::Field {\n+            id: self.next_id().node_id,\n             name: Spanned { node: name, span },\n             span,\n             expr,"}, {"sha": "e6080fad91d597f60410ffd2e989951490c1b835", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -827,6 +827,7 @@ impl Pat {\n /// except is_shorthand is true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n+    pub id: NodeId,\n     /// The identifier for the field\n     pub name: Name,\n     /// The pattern the field is destructured to\n@@ -1172,6 +1173,7 @@ pub struct Arm {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n+    pub id: NodeId,\n     pub name: Spanned<Name>,\n     pub expr: P<Expr>,\n     pub span: Span,"}, {"sha": "4a001802eacb48c889fa1546418056da900cdea4", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -420,11 +420,23 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Pat {\n }\n \n impl_stable_hash_for_spanned!(hir::FieldPat);\n-impl_stable_hash_for!(struct hir::FieldPat {\n-    name,\n-    pat,\n-    is_shorthand\n-});\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::FieldPat {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::FieldPat {\n+            id: _,\n+            name,\n+            ref pat,\n+            is_shorthand,\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        pat.hash_stable(hcx, hasher);\n+        is_shorthand.hash_stable(hcx, hasher);\n+    }\n+}\n \n impl_stable_hash_for!(enum hir::BindingAnnotation {\n     Unannotated,\n@@ -507,12 +519,24 @@ impl_stable_hash_for!(struct hir::Arm {\n     body\n });\n \n-impl_stable_hash_for!(struct hir::Field {\n-    name,\n-    expr,\n-    span,\n-    is_shorthand\n-});\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Field {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::Field {\n+            id: _,\n+            name,\n+            ref expr,\n+            span,\n+            is_shorthand,\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        expr.hash_stable(hcx, hasher);\n+        span.hash_stable(hcx, hasher);\n+        is_shorthand.hash_stable(hcx, hasher);\n+    }\n+}\n \n impl_stable_hash_for_spanned!(ast::Name);\n "}, {"sha": "9ec3d2e2460e944ba41900309cf4e92929e812ce", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -13,7 +13,7 @@\n // from live codes are live, and everything else is dead.\n \n use hir::map as hir_map;\n-use hir::{self, Item_, PatKind};\n+use hir::{self, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -99,10 +99,11 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.check_def_id(self.tables.type_dependent_defs()[id].def_id());\n     }\n \n-    fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n+    fn handle_field_access(&mut self, lhs: &hir::Expr, node_id: ast::NodeId) {\n         match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n-                self.insert_def_id(def.non_enum_variant().field_named(name).did);\n+                let index = self.tcx.field_index(node_id, self.tables);\n+                self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::TyTuple(..) => {}\n             _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n@@ -119,7 +120,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if let PatKind::Wild = pat.node.pat.node {\n                 continue;\n             }\n-            self.insert_def_id(variant.field_named(pat.node.name).did);\n+            let index = self.tcx.field_index(pat.node.id, self.tables);\n+            self.insert_def_id(variant.fields[index].did);\n         }\n     }\n \n@@ -182,18 +184,11 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.inherited_pub_visibility = had_inherited_pub_visibility;\n     }\n \n-    fn mark_as_used_if_union(&mut self, did: DefId, fields: &hir::HirVec<hir::Field>) {\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(did) {\n-            if let Some(hir_map::NodeItem(item)) = self.tcx.hir.find(node_id) {\n-                if let Item_::ItemUnion(ref variant, _) = item.node {\n-                    if variant.fields().len() > 1 {\n-                        for field in variant.fields() {\n-                            if fields.iter().find(|x| x.name.node == field.name).is_some() {\n-                                self.live_symbols.insert(field.id);\n-                            }\n-                        }\n-                    }\n-                }\n+    fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &hir::HirVec<hir::Field>) {\n+        if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n+            for field in fields {\n+                let index = self.tcx.field_index(field.id, self.tables);\n+                self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }\n     }\n@@ -233,14 +228,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.hir_id);\n             }\n-            hir::ExprField(ref lhs, ref name) => {\n-                self.handle_field_access(&lhs, name.node);\n+            hir::ExprField(ref lhs, ..) => {\n+                self.handle_field_access(&lhs, expr.id);\n             }\n             hir::ExprStruct(_, ref fields, _) => {\n-                if let ty::TypeVariants::TyAdt(ref def, _) = self.tables.expr_ty(expr).sty {\n-                    if def.is_union() {\n-                        self.mark_as_used_if_union(def.did, fields);\n-                    }\n+                if let ty::TypeVariants::TyAdt(ref adt, _) = self.tables.expr_ty(expr).sty {\n+                    self.mark_as_used_if_union(adt, fields);\n                 }\n             }\n             _ => ()"}, {"sha": "2cc5a4a8fe639f33d9ed125cd19083064f6bee4d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -659,11 +659,15 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match with_cmt.ty.sty {\n             ty::TyAdt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n-                for with_field in &adt.non_enum_variant().fields {\n-                    if !contains_field_named(with_field, fields) {\n+                for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n+                    let is_mentioned = fields.iter().any(|f| {\n+                        self.tcx().field_index(f.id, self.mc.tables) == f_index\n+                    });\n+                    if !is_mentioned {\n                         let cmt_field = self.mc.cat_field(\n                             &*with_expr,\n                             with_cmt.clone(),\n+                            f_index,\n                             with_field.name,\n                             with_field.ty(self.tcx(), substs)\n                         );\n@@ -687,14 +691,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // walk the with expression so that complex expressions\n         // are properly handled.\n         self.walk_expr(with_expr);\n-\n-        fn contains_field_named(field: &ty::FieldDef,\n-                                fields: &[hir::Field])\n-                                -> bool\n-        {\n-            fields.iter().any(\n-                |f| f.name.node == field.name)\n-        }\n     }\n \n     // Invoke the appropriate delegate calls for anything that gets"}, {"sha": "6f41f07dce8a779efe6e602ae1f70dc5260f99d3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -84,6 +84,7 @@ use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n use std::fmt;\n+use std::hash::{Hash, Hasher};\n use rustc_data_structures::sync::Lrc;\n use std::rc::Rc;\n use util::nodemap::ItemLocalSet;\n@@ -132,9 +133,22 @@ pub enum InteriorKind {\n     InteriorElement(InteriorOffsetKind),\n }\n \n-// FIXME: Use actual index instead of `ast::Name` with questionable hygiene\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct FieldIndex(pub ast::Name);\n+// Contains index of a field that is actually used for loan path comparisons and\n+// string representation of the field that should be used only for diagnostics.\n+#[derive(Clone, Copy, Eq)]\n+pub struct FieldIndex(pub usize, pub Name);\n+\n+impl PartialEq for FieldIndex {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.0 == rhs.0\n+    }\n+}\n+\n+impl Hash for FieldIndex {\n+    fn hash<H: Hasher>(&self, h: &mut H) {\n+        self.0.hash(h)\n+    }\n+}\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InteriorOffsetKind {\n@@ -195,7 +209,7 @@ pub enum ImmutabilityBlame<'tcx> {\n }\n \n impl<'tcx> cmt_<'tcx> {\n-    fn resolve_field(&self, field_name: Name) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n+    fn resolve_field(&self, field_index: usize) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n     {\n         let adt_def = match self.ty.sty {\n             ty::TyAdt(def, _) => def,\n@@ -212,7 +226,7 @@ impl<'tcx> cmt_<'tcx> {\n                 &adt_def.variants[0]\n             }\n         };\n-        Some((adt_def, variant_def.field_named(field_name)))\n+        Some((adt_def, &variant_def.fields[field_index]))\n     }\n \n     pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n@@ -639,7 +653,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                    expr.id,\n                    expr,\n                    base_cmt);\n-            Ok(self.cat_field(expr, base_cmt, f_name.node, expr_ty))\n+            let f_index = self.tcx.field_index(expr.id, self.tables);\n+            Ok(self.cat_field(expr, base_cmt, f_index, f_name.node, expr_ty))\n           }\n \n           hir::ExprIndex(ref base, _) => {\n@@ -967,14 +982,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn cat_field<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,\n+                                 f_index: usize,\n                                  f_name: Name,\n                                  f_ty: Ty<'tcx>)\n                                  -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt, InteriorField(FieldIndex(f_name))),\n+            cat: Categorization::Interior(base_cmt, InteriorField(FieldIndex(f_index, f_name))),\n             ty: f_ty,\n             note: NoteNone\n         });\n@@ -1262,7 +1278,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let interior = InteriorField(FieldIndex(Name::intern(&i.to_string())));\n+                let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n                 let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n@@ -1285,7 +1301,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n             for fp in field_pats {\n                 let field_ty = self.pat_ty(&fp.node.pat)?; // see (*2)\n-                let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.name, field_ty);\n+                let f_index = self.tcx.field_index(fp.node.id, self.tables);\n+                let cmt_field = self.cat_field(pat, cmt.clone(), f_index, fp.node.name, field_ty);\n                 self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n             }\n           }\n@@ -1302,7 +1319,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let interior = InteriorField(FieldIndex(Name::intern(&i.to_string())));\n+                let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n                 let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n@@ -1521,7 +1538,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n impl fmt::Debug for InteriorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(FieldIndex(name)) => write!(f, \"{}\", name),\n+            InteriorField(FieldIndex(_, info)) => write!(f, \"{}\", info),\n             InteriorElement(..) => write!(f, \"[]\"),\n         }\n     }"}, {"sha": "76ec8c21743e06653118aa839bf7a741d01eb455", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -346,6 +346,12 @@ pub struct TypeckTables<'tcx> {\n     /// method calls, including those of overloaded operators.\n     type_dependent_defs: ItemLocalMap<Def>,\n \n+    /// Resolved field indices for field accesses in expressions (`S { field }`, `obj.field`)\n+    /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n+    /// about the field you also need definition of the variant to which the field\n+    /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n+    field_indices: ItemLocalMap<usize>,\n+\n     /// Stores the canonicalized types provided by the user. See also `UserAssertTy` statement in\n     /// MIR.\n     user_provided_tys: ItemLocalMap<CanonicalTy<'tcx>>,\n@@ -426,6 +432,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         TypeckTables {\n             local_id_root,\n             type_dependent_defs: ItemLocalMap(),\n+            field_indices: ItemLocalMap(),\n             user_provided_tys: ItemLocalMap(),\n             node_types: ItemLocalMap(),\n             node_substs: ItemLocalMap(),\n@@ -468,6 +475,20 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n+    pub fn field_indices(&self) -> LocalTableInContext<usize> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.field_indices\n+        }\n+    }\n+\n+    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<usize> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.field_indices\n+        }\n+    }\n+\n     pub fn user_provided_tys(&self) -> LocalTableInContext<CanonicalTy<'tcx>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n@@ -706,6 +727,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n         let ty::TypeckTables {\n             local_id_root,\n             ref type_dependent_defs,\n+            ref field_indices,\n             ref user_provided_tys,\n             ref node_types,\n             ref node_substs,\n@@ -726,6 +748,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             type_dependent_defs.hash_stable(hcx, hasher);\n+            field_indices.hash_stable(hcx, hasher);\n             user_provided_tys.hash_stable(hcx, hasher);\n             node_types.hash_stable(hcx, hasher);\n             node_substs.hash_stable(hcx, hasher);"}, {"sha": "d0850f5ba6e9a5f98c82a0a372d9c6a0c2f438b0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -50,7 +50,7 @@ use std::vec::IntoIter;\n use std::mem;\n use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n@@ -2091,32 +2091,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> VariantDef {\n-    #[inline]\n-    pub fn find_field_named(&self, name: ast::Name) -> Option<&FieldDef> {\n-        self.index_of_field_named(name).map(|index| &self.fields[index])\n-    }\n-\n-    pub fn index_of_field_named(&self, name: ast::Name) -> Option<usize> {\n-        if let Some(index) = self.fields.iter().position(|f| f.name == name) {\n-            return Some(index);\n-        }\n-        let mut ident = name.to_ident();\n-        while ident.span.ctxt() != SyntaxContext::empty() {\n-            ident.span.remove_mark();\n-            if let Some(field) = self.fields.iter().position(|f| f.name.to_ident() == ident) {\n-                return Some(field);\n-            }\n-        }\n-        None\n-    }\n-\n-    #[inline]\n-    pub fn field_named(&self, name: ast::Name) -> &FieldDef {\n-        self.find_field_named(name).unwrap()\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n@@ -2383,6 +2357,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn field_index(self, node_id: NodeId, tables: &TypeckTables) -> usize {\n+        let hir_id = self.hir.node_to_hir_id(node_id);\n+        tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n+    }\n+\n+    pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n+        variant.fields.iter().position(|field| {\n+            self.adjust_ident(ident.modern(), variant.did, DUMMY_NODE_ID).0 == field.name.to_ident()\n+        })\n+    }\n+\n     pub fn associated_items(\n         self,\n         def_id: DefId,"}, {"sha": "77eff49d19ff615d505efc553416a8e391f803cc", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -33,7 +33,7 @@ use rustc_data_structures::fx::FxHashMap;\n use std::{cmp, fmt};\n use std::hash::Hash;\n use std::intrinsics;\n-use syntax::ast::{self, Name};\n+use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -270,42 +270,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         false\n     }\n \n-    /// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n-    /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n-    pub fn positional_element_ty(self,\n-                                 ty: Ty<'tcx>,\n-                                 i: usize,\n-                                 variant: Option<DefId>) -> Option<Ty<'tcx>> {\n-        match (&ty.sty, variant) {\n-            (&TyAdt(adt, substs), Some(vid)) => {\n-                adt.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyAdt(adt, substs), None) => {\n-                // Don't use `non_enum_variant`, this may be a univariant enum.\n-                adt.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n-            }\n-            (&TyTuple(ref v), None) => v.get(i).cloned(),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns the type of element at field `n` in struct or struct-like type `t`.\n-    /// For an enum `t`, `variant` must be some def id.\n-    pub fn named_element_ty(self,\n-                            ty: Ty<'tcx>,\n-                            n: Name,\n-                            variant: Option<DefId>) -> Option<Ty<'tcx>> {\n-        match (&ty.sty, variant) {\n-            (&TyAdt(adt, substs), Some(vid)) => {\n-                adt.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n-            }\n-            (&TyAdt(adt, substs), None) => {\n-                adt.non_enum_variant().find_field_named(n).map(|f| f.ty(self, substs))\n-            }\n-            _ => return None\n-        }\n-    }\n-\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy."}, {"sha": "e3adb51433b252a959c25ef1ec796f68e815bf66", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -107,8 +107,9 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                     ty::TyAdt(adt_def, _) if adt_def.is_union() => match result {\n                         RestrictionResult::Safe => RestrictionResult::Safe,\n                         RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n-                            for field in &adt_def.non_enum_variant().fields {\n-                                let field = InteriorKind::InteriorField(mc::FieldIndex(field.name));\n+                            for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n+                                let field =\n+                                    InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n                                 let field_ty = if field == interior {\n                                     cmt.ty\n                                 } else {"}, {"sha": "6d832d4060a1fc7d46653a3587f5aec47e9a05b3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -1336,10 +1336,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push(')');\n             }\n \n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(mc::FieldIndex(fname)))) => {\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(mc::FieldIndex(_, info)))) => {\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 out.push('.');\n-                out.push_str(&fname.as_str());\n+                out.push_str(&info.as_str());\n             }\n \n             LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n@@ -1414,7 +1414,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n impl<'tcx> fmt::Debug for InteriorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(mc::FieldIndex(name)) => write!(f, \"{}\", name),\n+            InteriorField(mc::FieldIndex(_, info)) => write!(f, \"{}\", info),\n             InteriorElement => write!(f, \"[]\"),\n         }\n     }"}, {"sha": "1f4050a5b3624dd91654e261e91a6c608a392138", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -342,8 +342,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             if let (&ty::TyAdt(adt_def, _), LpInterior(opt_variant_id, interior))\n                     = (&base_lp.ty.sty, lp_elem) {\n                 if adt_def.is_union() {\n-                    for field in &adt_def.non_enum_variant().fields {\n-                        let field = InteriorKind::InteriorField(mc::FieldIndex(field.name));\n+                    for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n+                        let field = InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n                         if field != interior {\n                             let sibling_lp_kind =\n                                 LpExtend(base_lp.clone(), mutbl, LpInterior(opt_variant_id, field));\n@@ -394,8 +394,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n             if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n                 if adt_def.is_union() {\n-                    for field in &adt_def.non_enum_variant().fields {\n-                        let field = InteriorKind::InteriorField(mc::FieldIndex(field.name));\n+                    for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n+                        let field = InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n                         let field_ty = if field == interior {\n                             lp.ty\n                         } else {"}, {"sha": "6f2c51b0f1899afaadaf2dcb99e6e43859819878", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -166,19 +166,24 @@ impl LintPass for NonShorthandFieldPatterns {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n-        if let PatKind::Struct(_, ref field_pats, _) = pat.node {\n+        if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.node {\n+            let variant = cx.tables.pat_ty(pat).ty_adt_def()\n+                                   .expect(\"struct pattern type is not an ADT\")\n+                                   .variant_of_def(cx.tables.qpath_def(qpath, pat.hir_id));\n             for fieldpat in field_pats {\n                 if fieldpat.node.is_shorthand {\n                     continue;\n                 }\n+                if fieldpat.span.ctxt().outer().expn_info().is_some() {\n+                    // Don't lint if this is a macro expansion: macro authors\n+                    // shouldn't have to worry about this kind of style issue\n+                    // (Issue #49588)\n+                    continue;\n+                }\n                 if let PatKind::Binding(_, _, name, None) = fieldpat.node.pat.node {\n-                    if name.node == fieldpat.node.name {\n-                        if let Some(_) = fieldpat.span.ctxt().outer().expn_info() {\n-                            // Don't lint if this is a macro expansion: macro authors\n-                            // shouldn't have to worry about this kind of style issue\n-                            // (Issue #49588)\n-                            return;\n-                        }\n+                    let binding_ident = ast::Ident::new(name.node, name.span);\n+                    if cx.tcx.find_field_index(binding_ident, &variant) ==\n+                       Some(cx.tcx.field_index(fieldpat.node.id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\","}, {"sha": "c0d2828094695999d1b259eea6cd9c5aede7a24a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -16,7 +16,7 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n-use rustc::ty::{self, AdtKind, VariantDef, Ty};\n+use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -420,12 +420,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ty::TyAdt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n-                            let field_refs = field_refs(&adt.variants[0], fields);\n                             ExprKind::Adt {\n                                 adt_def: adt,\n                                 variant_index: 0,\n                                 substs,\n-                                fields: field_refs,\n+                                fields: field_refs(cx, fields),\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n                                         base: base.to_ref(),\n@@ -446,12 +445,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     assert!(base.is_none());\n \n                                     let index = adt.variant_index_with_id(variant_id);\n-                                    let field_refs = field_refs(&adt.variants[index], fields);\n                                     ExprKind::Adt {\n                                         adt_def: adt,\n                                         variant_index: index,\n                                         substs,\n-                                        fields: field_refs,\n+                                        fields: field_refs(cx, fields),\n                                         base: None,\n                                     }\n                                 }\n@@ -581,19 +579,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 body: block::to_expr_ref(cx, body),\n             }\n         }\n-        hir::ExprField(ref source, name) => {\n-            let index = match cx.tables().expr_ty_adjusted(source).sty {\n-                ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n-                ty::TyTuple(..) => name.node.as_str().parse::<usize>().ok(),\n-                ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n-            };\n-            let index =\n-                index.unwrap_or_else(|| {\n-                    span_bug!(expr.span, \"no index found for field `{}`\", name.node)\n-                });\n+        hir::ExprField(ref source, ..) => {\n             ExprKind::Field {\n                 lhs: source.to_ref(),\n-                name: Field::new(index),\n+                name: Field::new(cx.tcx.field_index(expr.id, cx.tables)),\n             }\n         }\n         hir::ExprCast(ref source, _) => {\n@@ -994,13 +983,13 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n }\n \n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n-fn field_refs<'tcx>(variant: &'tcx VariantDef,\n-                    fields: &'tcx [hir::Field])\n-                    -> Vec<FieldExprRef<'tcx>> {\n+fn field_refs<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                              fields: &'tcx [hir::Field])\n+                              -> Vec<FieldExprRef<'tcx>> {\n     fields.iter()\n         .map(|field| {\n             FieldExprRef {\n-                name: Field::new(variant.index_of_field_named(field.name.node).unwrap()),\n+                name: Field::new(cx.tcx.field_index(field.id, cx.tables)),\n                 expr: field.expr.to_ref(),\n             }\n         })"}, {"sha": "8d2b73d6ba033842693aa3dd6827c1575864e8e5", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -528,28 +528,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n                 let def = self.tables.qpath_def(qpath, pat.hir_id);\n-                let adt_def = match ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    _ => {\n-                        span_bug!(\n-                            pat.span,\n-                            \"struct pattern not applied to an ADT\");\n-                    }\n-                };\n-                let variant_def = adt_def.variant_of_def(def);\n-\n                 let subpatterns =\n                     fields.iter()\n                           .map(|field| {\n-                              let index = variant_def.index_of_field_named(field.node.name);\n-                              let index = index.unwrap_or_else(|| {\n-                                  span_bug!(\n-                                      pat.span,\n-                                      \"no field with name {:?}\",\n-                                      field.node.name);\n-                              });\n                               FieldPattern {\n-                                  field: Field::new(index),\n+                                  field: Field::new(self.tcx.field_index(field.node.id,\n+                                                                         self.tables)),\n                                   pattern: self.lower_pattern(&field.node.pat),\n                               }\n                           })"}, {"sha": "ee08e6223903e39e9079c332d73189d08072c947", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -568,8 +568,10 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                     // If the expression uses FRU we need to make sure all the unmentioned fields\n                     // are checked for privacy (RFC 736). Rather than computing the set of\n                     // unmentioned fields, just check them all.\n-                    for variant_field in &variant.fields {\n-                        let field = fields.iter().find(|f| f.name.node == variant_field.name);\n+                    for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n+                        let field = fields.iter().find(|f| {\n+                            self.tcx.field_index(f.id, self.tables) == vf_index\n+                        });\n                         let (use_ctxt, span) = match field {\n                             Some(field) => (field.name.node.to_ident().span, field.span),\n                             None => (base.span, base.span),\n@@ -579,8 +581,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 } else {\n                     for field in fields {\n                         let use_ctxt = field.name.node.to_ident().span;\n-                        let field_def = variant.field_named(field.name.node);\n-                        self.check_field(use_ctxt, field.span, adt, field_def);\n+                        let index = self.tcx.field_index(field.id, self.tables);\n+                        self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                     }\n                 }\n             }\n@@ -598,8 +600,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     let use_ctxt = field.node.name.to_ident().span;\n-                    let field_def = variant.field_named(field.node.name);\n-                    self.check_field(use_ctxt, field.span, adt, field_def);\n+                    let index = self.tcx.field_index(field.node.id, self.tables);\n+                    self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                 }\n             }\n             _ => {}"}, {"sha": "abaa02a856e9cae181944eda5a8fed471205c308", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -1005,20 +1005,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 };\n                 let variant = adt.variant_of_def(self.save_ctxt.get_path_def(p.id));\n \n-                for &Spanned {\n-                    node: ref field,\n-                    span,\n-                } in fields\n-                {\n+                for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n-                    if let Some(f) = variant.find_field_named(field.ident.name) {\n+                    if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n                         if !self.span.filter_generated(sub_span, span) {\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span fund for var ref\"));\n                             self.dumper.dump_ref(Ref {\n                                 kind: RefKind::Variable,\n                                 span,\n-                                ref_id: ::id_from_def_id(f.did),\n+                                ref_id: ::id_from_def_id(variant.fields[index].did),\n                             });\n                         }\n                     }"}, {"sha": "ca19ed0df67d1ab9efa4657867dff7a861d844e3", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -553,14 +553,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 };\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n-                        let f = def.non_enum_variant().field_named(ident.name);\n+                        let variant = &def.non_enum_variant();\n+                        let index = self.tcx.find_field_index(ident, variant).unwrap();\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                         filter!(self.span_utils, sub_span, expr.span, None);\n                         let span = self.span_from_span(sub_span.unwrap());\n                         return Some(Data::RefData(Ref {\n                             kind: RefKind::Variable,\n                             span,\n-                            ref_id: id_from_def_id(f.did),\n+                            ref_id: id_from_def_id(variant.fields[index].did),\n                         }));\n                     }\n                     ty::TyTuple(..) => None,\n@@ -817,15 +818,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         field_ref: &ast::Field,\n         variant: &ty::VariantDef,\n     ) -> Option<Ref> {\n-        let f = variant.find_field_named(field_ref.ident.name)?;\n+        let index = self.tcx.find_field_index(field_ref.ident, variant).unwrap();\n         // We don't really need a sub-span here, but no harm done\n         let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n         filter!(self.span_utils, sub_span, field_ref.ident.span, None);\n         let span = self.span_from_span(sub_span.unwrap());\n         Some(Ref {\n             kind: RefKind::Variable,\n             span,\n-            ref_id: id_from_def_id(f.did),\n+            ref_id: id_from_def_id(variant.fields[index].did),\n         })\n     }\n "}, {"sha": "7b4dc60409b122b89cc35d2702795ab349784c6c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -860,7 +860,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         // Index the struct fields' types.\n         let field_map = variant.fields\n             .iter()\n-            .map(|field| (field.name, field))\n+            .enumerate()\n+            .map(|(i, field)| (field.name.to_ident(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         // Keep track of which fields have already appeared in the pattern.\n@@ -869,7 +870,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {\n-            let field_ty = match used_fields.entry(field.name) {\n+            let ident = tcx.adjust(field.name, variant.did, self.body_id).0;\n+            let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n                     struct_span_err!(tcx.sess, span, E0025,\n                                      \"field `{}` bound multiple times \\\n@@ -883,10 +885,10 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 }\n                 Vacant(vacant) => {\n                     vacant.insert(span);\n-                    field_map.get(&field.name)\n-                        .map(|f| {\n+                    field_map.get(&ident)\n+                        .map(|(i, f)| {\n+                            self.write_field_index(field.id, *i);\n                             self.tcx.check_stability(f.did, Some(pat_id), span);\n-\n                             self.field_ty(span, f, substs)\n                         })\n                         .unwrap_or_else(|| {\n@@ -958,8 +960,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         } else if !etc {\n             let unmentioned_fields = variant.fields\n                 .iter()\n-                .map(|field| field.name)\n-                .filter(|field| !used_fields.contains_key(&field))\n+                .map(|field| field.name.to_ident())\n+                .filter(|ident| !used_fields.contains_key(&ident))\n                 .collect::<Vec<_>>();\n             if unmentioned_fields.len() > 0 {\n                 let field_names = if unmentioned_fields.len() == 1 {"}, {"sha": "d8907866467ba0b0478cd0390cae8223628ee371", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -304,8 +304,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         match ty.sty {\n                             ty::TyAdt(def, substs) if !def.is_enum() => {\n-                                if let Some(field) = def.non_enum_variant()\n-                                    .find_field_named(item_name) {\n+                                let variant = &def.non_enum_variant();\n+                                if let Some(index) =\n+                                        self.tcx.find_field_index(item_name.to_ident(), variant) {\n+                                    let field = &variant.fields[index];\n                                     let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n                                     let expr_string = match snippet {\n                                         Ok(expr_string) => expr_string,"}, {"sha": "ca35153d571dbd0048cf8ada21af03d6d5832a04", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -1938,6 +1938,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn write_field_index(&self, node_id: ast::NodeId, index: usize) {\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n+    }\n+\n     // The NodeId and the ItemLocalId must identify the same item. We just pass\n     // both of them for consistency checking.\n     pub fn write_method_call(&self,\n@@ -3069,15 +3074,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let (ident, def_scope) =\n                         self.tcx.adjust(field.node, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n+                    if let Some(index) = fields.iter().position(|f| f.name.to_ident() == ident) {\n+                        let field = &fields[index];\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             let adjustments = autoderef.adjust_steps(needs);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize();\n \n+                            self.write_field_index(expr.id, index);\n                             self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n-\n                             return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3092,6 +3098,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 self.apply_adjustments(base, adjustments);\n                                 autoderef.finalize();\n \n+                                self.write_field_index(expr.id, index);\n                                 return field_ty;\n                             }\n                         }\n@@ -3284,8 +3291,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let mut remaining_fields = FxHashMap();\n-        for field in &variant.fields {\n-            remaining_fields.insert(field.name.to_ident(), field);\n+        for (i, field) in variant.fields.iter().enumerate() {\n+            remaining_fields.insert(field.name.to_ident(), (i, field));\n         }\n \n         let mut seen_fields = FxHashMap();\n@@ -3295,8 +3302,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Typecheck each field.\n         for field in ast_fields {\n             let ident = tcx.adjust(field.name.node, variant.did, self.body_id).0;\n-            let field_type = if let Some(v_field) = remaining_fields.remove(&ident) {\n-                seen_fields.insert(field.name.node, field.span);\n+            let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n+                seen_fields.insert(ident, field.span);\n+                self.write_field_index(field.id, i);\n \n                 // we don't look at stability attributes on\n                 // struct-like enums (yet...), but it's definitely not\n@@ -3308,18 +3316,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.field_ty(field.span, v_field, substs)\n             } else {\n                 error_happened = true;\n-                if let Some(_) = variant.find_field_named(field.name.node) {\n+                if let Some(prev_span) = seen_fields.get(&ident) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n                                                 field.name.span,\n                                                 E0062,\n                                                 \"field `{}` specified more than once\",\n-                                                field.name.node);\n+                                                ident);\n \n                     err.span_label(field.name.span, \"used more than once\");\n-\n-                    if let Some(prev_span) = seen_fields.get(&field.name.node) {\n-                        err.span_label(*prev_span, format!(\"first use of `{}`\", field.name.node));\n-                    }\n+                    err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n \n                     err.emit();\n                 } else {"}, {"sha": "6e0d7dd8508775719988da59e7af640fbdb57bac", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -226,13 +226,24 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         self.visit_node_id(e.span, e.hir_id);\n \n-        if let hir::ExprClosure(_, _, body, _, _) = e.node {\n-            let body = self.fcx.tcx.hir.body(body);\n-            for arg in &body.arguments {\n-                self.visit_node_id(e.span, arg.hir_id);\n-            }\n+        match e.node {\n+            hir::ExprClosure(_, _, body, _, _) => {\n+                let body = self.fcx.tcx.hir.body(body);\n+                for arg in &body.arguments {\n+                    self.visit_node_id(e.span, arg.hir_id);\n+                }\n \n-            self.visit_body(body);\n+                self.visit_body(body);\n+            }\n+            hir::ExprStruct(_, ref fields, _) => {\n+                for field in fields {\n+                    self.visit_field_id(field.id);\n+                }\n+            }\n+            hir::ExprField(..) => {\n+                self.visit_field_id(e.id);\n+            }\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, e);\n@@ -254,6 +265,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n                     .expect(\"missing binding mode\");\n                 self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n             }\n+            hir::PatKind::Struct(_, ref fields, _) => {\n+                for field in fields {\n+                    self.visit_field_id(field.node.id);\n+                }\n+            }\n             _ => {}\n         };\n \n@@ -384,6 +400,13 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_field_id(&mut self, node_id: ast::NodeId) {\n+        let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n+        if let Some(index) = self.fcx.tables.borrow_mut().field_indices_mut().remove(hir_id) {\n+            self.tables.field_indices_mut().insert(hir_id, index);\n+        }\n+    }\n+\n     fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         // Export associated path extensions and method resultions.\n         if let Some(def) = self.fcx"}, {"sha": "640e6488862788d1a90e1106166f7e5e7bc3e204", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -513,11 +513,11 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     discr: ty::VariantDiscr,\n                                     def: &hir::VariantData)\n                                     -> ty::VariantDef {\n-    let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n+    let mut seen_fields: FxHashMap<ast::Ident, Span> = FxHashMap();\n     let node_id = tcx.hir.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n         let fid = tcx.hir.local_def_id(f.id);\n-        let dup_span = seen_fields.get(&f.name).cloned();\n+        let dup_span = seen_fields.get(&f.name.to_ident()).cloned();\n         if let Some(prev_span) = dup_span {\n             struct_span_err!(tcx.sess, f.span, E0124,\n                              \"field `{}` is already declared\",\n@@ -526,7 +526,7 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 .span_label(prev_span, format!(\"`{}` first declared here\", f.name))\n                 .emit();\n         } else {\n-            seen_fields.insert(f.name, f.span);\n+            seen_fields.insert(f.name.to_ident(), f.span);\n         }\n \n         ty::FieldDef {"}, {"sha": "36244f0a3c43874df3b5f637be258a43ac155f0b", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -636,8 +636,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n     }\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n-        let id = Spanned { node: Ident::from_str(&idx.to_string()), span: sp };\n-        self.expr(sp, ast::ExprKind::Field(expr, id))\n+        let ident = Ident::from_str(&idx.to_string()).with_span_pos(sp);\n+        self.expr(sp, ast::ExprKind::Field(expr, ident))\n     }\n     fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))"}, {"sha": "a7a9ce745122c36612eecdbf51ffc331cf1e16e6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -2604,8 +2604,7 @@ impl<'a> Parser<'a> {\n                   token::Literal(token::Integer(name), _) => {\n                     let span = self.span;\n                     self.bump();\n-                    let ident = Ident { name, ctxt: span.ctxt() };\n-                    let field = ExprKind::Field(e, respan(span, ident));\n+                    let field = ExprKind::Field(e, Ident::new(name, span));\n                     e = self.mk_expr(lo.to(span), field, ThinVec::new());\n                   }\n                   token::Literal(token::Float(n), _suf) => {\n@@ -7031,7 +7030,7 @@ impl<'a> Parser<'a> {\n             match self.token {\n                 token::Ident(ident, false) if ident.name == keywords::Underscore.name() => {\n                     self.bump(); // `_`\n-                    Ok(Some(Ident { name: ident.name.gensymed(), ..ident }))\n+                    Ok(Some(Ident::new(ident.name.gensymed(), ident.span)))\n                 }\n                 _ => self.parse_ident().map(Some),\n             }"}, {"sha": "eec7df84c82f7f8eced3cbb13bece589cece0891", "filename": "src/test/compile-fail/borrowck/borrowck-uninit-field-access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f69b7fb850cae83ea3d5adfeb8520418c976403/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs?ref=4f69b7fb850cae83ea3d5adfeb8520418c976403", "patch": "@@ -36,7 +36,7 @@ fn main() {\n \n     let mut line1 = Line::default();\n     let _moved = line1.origin;\n-    let _ = line1.origin.x + 1; //[ast]~ ERROR use of collaterally moved value: `line1.origin.x`\n+    let _ = line1.origin.x + 1; //[ast]~ ERROR use of moved value: `line1.origin.x`\n                                 //[mir]~^ [E0382]\n \n     let mut line2 = Line::default();"}]}