{"sha": "07fd17f7014de6dc209c7dc4de159a2a5acea173", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZmQxN2Y3MDE0ZGU2ZGMyMDljN2RjNGRlMTU5YTJhNWFjZWExNzM=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-27T13:19:42Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-27T14:04:25Z"}, "message": "Only use LOCAL_{STDOUT,STDERR} when set_{print/panic} is used.\n\nThe thread local LOCAL_STDOUT and LOCAL_STDERR are only used by the test\ncrate to capture output from tests when running them in the same process\nin differen threads. However, every program will check these variables\non every print, even outside of testing.\n\nThis involves allocating a thread local key, and registering a thread\nlocal destructor. This can be somewhat expensive.\n\nThis change keeps a global flag (LOCAL_STREAMS) which will be set to\ntrue when either of these local streams is used. (So, effectively only\nin test and benchmark runs.) When this flag is off, these thread locals\nare not even looked at and therefore will not be initialized on the\nfirst output on every thread, which also means no thread local\ndestructors will be registered.", "tree": {"sha": "711bf0b292f07d2678bdec22bdd5f986ba8cae5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/711bf0b292f07d2678bdec22bdd5f986ba8cae5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07fd17f7014de6dc209c7dc4de159a2a5acea173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07fd17f7014de6dc209c7dc4de159a2a5acea173", "html_url": "https://github.com/rust-lang/rust/commit/07fd17f7014de6dc209c7dc4de159a2a5acea173", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07fd17f7014de6dc209c7dc4de159a2a5acea173/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8363295d555494bbaa119eba8b16a3057e6728c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8363295d555494bbaa119eba8b16a3057e6728c", "html_url": "https://github.com/rust-lang/rust/commit/b8363295d555494bbaa119eba8b16a3057e6728c"}], "stats": {"total": 64, "additions": 41, "deletions": 23}, "files": [{"sha": "814e0dfda54b825fcf6f81adaddc9d3b10c2382d", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/07fd17f7014de6dc209c7dc4de159a2a5acea173/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07fd17f7014de6dc209c7dc4de159a2a5acea173/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=07fd17f7014de6dc209c7dc4de159a2a5acea173", "patch": "@@ -9,21 +9,24 @@ use crate::cell::RefCell;\n use crate::fmt;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n use crate::lazy::SyncOnceCell;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Mutex, MutexGuard};\n use crate::sys::stdio;\n use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread::LocalKey;\n \n+static LOCAL_STREAMS: AtomicBool = AtomicBool::new(false);\n+\n thread_local! {\n-    /// Stdout used by print! and println! macros\n+    /// Used by the test crate to capture the output of the print! and println! macros.\n     static LOCAL_STDOUT: RefCell<Option<Box<dyn Write + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n thread_local! {\n-    /// Stderr used by eprint! and eprintln! macros, and panics\n+    /// Used by the test crate to capture the output of the eprint! and eprintln! macros, and panics.\n     static LOCAL_STDERR: RefCell<Option<Box<dyn Write + Send>>> = {\n         RefCell::new(None)\n     }\n@@ -890,10 +893,14 @@ impl fmt::Debug for StderrLock<'_> {\n #[doc(hidden)]\n pub fn set_panic(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write + Send>> {\n     use crate::mem;\n-    LOCAL_STDERR.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n+    let s = LOCAL_STDERR.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n+        |mut s| {\n+            let _ = s.flush();\n+            Some(s)\n+        },\n+    );\n+    LOCAL_STREAMS.store(true, Ordering::Release);\n+    s\n }\n \n /// Resets the thread-local stdout handle to the specified writer\n@@ -913,10 +920,14 @@ pub fn set_panic(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write +\n #[doc(hidden)]\n pub fn set_print(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write + Send>> {\n     use crate::mem;\n-    LOCAL_STDOUT.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n+    let s = LOCAL_STDOUT.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n+        |mut s| {\n+            let _ = s.flush();\n+            Some(s)\n+        },\n+    );\n+    LOCAL_STREAMS.store(true, Ordering::Release);\n+    s\n }\n \n /// Write `args` to output stream `local_s` if possible, `global_s`\n@@ -937,20 +948,26 @@ fn print_to<T>(\n ) where\n     T: Write,\n {\n-    let result = local_s\n-        .try_with(|s| {\n-            // Note that we completely remove a local sink to write to in case\n-            // our printing recursively panics/prints, so the recursive\n-            // panic/print goes to the global sink instead of our local sink.\n-            let prev = s.borrow_mut().take();\n-            if let Some(mut w) = prev {\n-                let result = w.write_fmt(args);\n-                *s.borrow_mut() = Some(w);\n-                return result;\n-            }\n-            global_s().write_fmt(args)\n+    let result = LOCAL_STREAMS\n+        .load(Ordering::Acquire)\n+        .then(|| {\n+            local_s\n+                .try_with(|s| {\n+                    // Note that we completely remove a local sink to write to in case\n+                    // our printing recursively panics/prints, so the recursive\n+                    // panic/print goes to the global sink instead of our local sink.\n+                    let prev = s.borrow_mut().take();\n+                    if let Some(mut w) = prev {\n+                        let result = w.write_fmt(args);\n+                        *s.borrow_mut() = Some(w);\n+                        return result;\n+                    }\n+                    global_s().write_fmt(args)\n+                })\n+                .ok()\n         })\n-        .unwrap_or_else(|_| global_s().write_fmt(args));\n+        .flatten()\n+        .unwrap_or_else(|| global_s().write_fmt(args));\n \n     if let Err(e) = result {\n         panic!(\"failed printing to {}: {}\", label, e);"}, {"sha": "410860b4a5d3f1265787ce1fa8fbfe1f3896ee1d", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07fd17f7014de6dc209c7dc4de159a2a5acea173/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07fd17f7014de6dc209c7dc4de159a2a5acea173/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=07fd17f7014de6dc209c7dc4de159a2a5acea173", "patch": "@@ -226,6 +226,7 @@\n #![feature(asm)]\n #![feature(associated_type_bounds)]\n #![feature(atomic_mut_ptr)]\n+#![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_accessible)]"}]}