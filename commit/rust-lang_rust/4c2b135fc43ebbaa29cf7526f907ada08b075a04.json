{"sha": "4c2b135fc43ebbaa29cf7526f907ada08b075a04", "node_id": "C_kwDOAAsO6NoAKDRjMmIxMzVmYzQzZWJiYWEyOWNmNzUyNmY5MDdhZGEwOGIwNzVhMDQ", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-03-07T16:41:03Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2023-03-07T20:20:21Z"}, "message": "Fix invalid inlining of reexport of reexport of private item", "tree": {"sha": "00d3079069050715a00f4f33a1b845ab7a0f0c64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00d3079069050715a00f4f33a1b845ab7a0f0c64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c2b135fc43ebbaa29cf7526f907ada08b075a04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2b135fc43ebbaa29cf7526f907ada08b075a04", "html_url": "https://github.com/rust-lang/rust/commit/4c2b135fc43ebbaa29cf7526f907ada08b075a04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c2b135fc43ebbaa29cf7526f907ada08b075a04/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c0f83d773370150a6ea1b40b36b55566e40a73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c0f83d773370150a6ea1b40b36b55566e40a73c", "html_url": "https://github.com/rust-lang/rust/commit/8c0f83d773370150a6ea1b40b36b55566e40a73c"}], "stats": {"total": 128, "additions": 85, "deletions": 43}, "files": [{"sha": "29c3afe0d9560d06b363c5846566c5fbc34fd2f4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 66, "deletions": 42, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4c2b135fc43ebbaa29cf7526f907ada08b075a04/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2b135fc43ebbaa29cf7526f907ada08b075a04/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4c2b135fc43ebbaa29cf7526f907ada08b075a04", "patch": "@@ -2065,23 +2065,81 @@ fn clean_bare_fn_ty<'tcx>(\n     BareFunctionDecl { unsafety: bare_fn.unsafety, abi: bare_fn.abi, decl, generic_params }\n }\n \n-/// This visitor is used to go through only the \"top level\" of a item and not enter any sub\n-/// item while looking for a given `Ident` which is stored into `item` if found.\n-struct OneLevelVisitor<'hir> {\n+/// Get DefId of of an item's user-visible parent.\n+///\n+/// \"User-visible\" should account for re-exporting and inlining, which is why this function isn't\n+/// just `tcx.parent(def_id)`. If the provided `path` has more than one path element, the `DefId`\n+/// of the second-to-last will be given.\n+///\n+/// ```text\n+/// use crate::foo::Bar;\n+///            ^^^ DefId of this item will be returned\n+/// ```\n+///\n+/// If the provided path has only one item, `tcx.parent(def_id)` will be returned instead.\n+fn get_path_parent_def_id(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    path: &hir::UsePath<'_>,\n+) -> Option<DefId> {\n+    if let [.., parent_segment, _] = &path.segments {\n+        match parent_segment.res {\n+            hir::def::Res::Def(_, parent_def_id) => Some(parent_def_id),\n+            _ if parent_segment.ident.name == kw::Crate => {\n+                // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n+                // circumvent it this way.\n+                Some(tcx.parent(def_id))\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        // If the path doesn't have a parent, then the parent is the current module.\n+        Some(tcx.parent(def_id))\n+    }\n+}\n+\n+/// This visitor is used to find an HIR Item based on its `use` path. This doesn't use the ordinary\n+/// name resolver because it does not walk all the way through a chain of re-exports.\n+pub(crate) struct OneLevelVisitor<'hir> {\n     map: rustc_middle::hir::map::Map<'hir>,\n-    item: Option<&'hir hir::Item<'hir>>,\n+    pub(crate) item: Option<&'hir hir::Item<'hir>>,\n     looking_for: Ident,\n     target_def_id: LocalDefId,\n }\n \n impl<'hir> OneLevelVisitor<'hir> {\n-    fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n+    pub(crate) fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n         Self { map, item: None, looking_for: Ident::empty(), target_def_id }\n     }\n \n-    fn reset(&mut self, looking_for: Ident) {\n-        self.looking_for = looking_for;\n+    pub(crate) fn find_target(\n+        &mut self,\n+        tcx: TyCtxt<'_>,\n+        def_id: DefId,\n+        path: &hir::UsePath<'_>,\n+    ) -> Option<&'hir hir::Item<'hir>> {\n+        let parent_def_id = get_path_parent_def_id(tcx, def_id, path)?;\n+        let parent = self.map.get_if_local(parent_def_id)?;\n+\n+        // We get the `Ident` we will be looking for into `item`.\n+        self.looking_for = path.segments[path.segments.len() - 1].ident;\n+        // We reset the `item`.\n         self.item = None;\n+\n+        match parent {\n+            hir::Node::Item(parent_item) => {\n+                hir::intravisit::walk_item(self, parent_item);\n+            }\n+            hir::Node::Crate(m) => {\n+                hir::intravisit::walk_mod(\n+                    self,\n+                    m,\n+                    tcx.local_def_id_to_hir_id(parent_def_id.as_local().unwrap()),\n+                );\n+            }\n+            _ => return None,\n+        }\n+        self.item\n     }\n }\n \n@@ -2129,41 +2187,7 @@ fn get_all_import_attributes<'hir>(\n             add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n         }\n \n-        let def_id = if let [.., parent_segment, _] = &path.segments {\n-            match parent_segment.res {\n-                hir::def::Res::Def(_, def_id) => def_id,\n-                _ if parent_segment.ident.name == kw::Crate => {\n-                    // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n-                    // circumvent it this way.\n-                    tcx.parent(item.owner_id.def_id.to_def_id())\n-                }\n-                _ => break,\n-            }\n-        } else {\n-            // If the path doesn't have a parent, then the parent is the current module.\n-            tcx.parent(item.owner_id.def_id.to_def_id())\n-        };\n-\n-        let Some(parent) = hir_map.get_if_local(def_id) else { break };\n-\n-        // We get the `Ident` we will be looking for into `item`.\n-        let looking_for = path.segments[path.segments.len() - 1].ident;\n-        visitor.reset(looking_for);\n-\n-        match parent {\n-            hir::Node::Item(parent_item) => {\n-                hir::intravisit::walk_item(&mut visitor, parent_item);\n-            }\n-            hir::Node::Crate(m) => {\n-                hir::intravisit::walk_mod(\n-                    &mut visitor,\n-                    m,\n-                    tcx.local_def_id_to_hir_id(def_id.as_local().unwrap()),\n-                );\n-            }\n-            _ => break,\n-        }\n-        if let Some(i) = visitor.item {\n+        if let Some(i) = visitor.find_target(tcx, item.owner_id.def_id.to_def_id(), path) {\n             item = i;\n         } else {\n             break;"}, {"sha": "44e9b49f82afd5382ac3124fe09526894ed32b96", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c2b135fc43ebbaa29cf7526f907ada08b075a04/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2b135fc43ebbaa29cf7526f907ada08b075a04/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4c2b135fc43ebbaa29cf7526f907ada08b075a04", "patch": "@@ -15,7 +15,7 @@ use rustc_span::Span;\n \n use std::mem;\n \n-use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt};\n+use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt, OneLevelVisitor};\n use crate::core;\n \n /// This module is used to store stuff from Rust's AST in a more convenient\n@@ -220,6 +220,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         renamed: Option<Symbol>,\n         glob: bool,\n         please_inline: bool,\n+        path: &hir::UsePath<'_>,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n \n@@ -263,6 +264,22 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n+        if !please_inline &&\n+            let mut visitor = OneLevelVisitor::new(self.cx.tcx.hir(), res_did) &&\n+            let Some(item) = visitor.find_target(self.cx.tcx, def_id.to_def_id(), path) &&\n+            let item_def_id = item.owner_id.def_id &&\n+            item_def_id != def_id &&\n+            self\n+                .cx\n+                .cache\n+                .effective_visibilities\n+                .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n+            !inherits_doc_hidden(self.cx.tcx, item_def_id)\n+        {\n+            // The imported item is public and not `doc(hidden)` so no need to inline it.\n+            return false;\n+        }\n+\n         let ret = match tcx.hir().get_by_def_id(res_did) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n@@ -361,6 +378,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             ident,\n                             is_glob,\n                             please_inline,\n+                            path,\n                         ) {\n                             continue;\n                         }"}]}