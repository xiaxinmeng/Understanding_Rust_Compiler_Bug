{"sha": "915fa2a378a22d197ed85f2d563f443edb10b713", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNWZhMmEzNzhhMjJkMTk3ZWQ4NWYyZDU2M2Y0NDNlZGIxMGI3MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-06T19:16:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-06T19:16:10Z"}, "message": "Auto merge of #31428 - reem:remove-mutexguard-map, r=alexcrichton\n\nIt could return in the future if it returned a different guard type, which\ncould not be used with Condvar, otherwise it is unsafe as another thread\ncan invalidate an \"inner\" reference during a Condvar::wait.\n\ncc #27746", "tree": {"sha": "3b09ff179002f4482e76ee946238897776f00fd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b09ff179002f4482e76ee946238897776f00fd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/915fa2a378a22d197ed85f2d563f443edb10b713", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/915fa2a378a22d197ed85f2d563f443edb10b713", "html_url": "https://github.com/rust-lang/rust/commit/915fa2a378a22d197ed85f2d563f443edb10b713", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/915fa2a378a22d197ed85f2d563f443edb10b713/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ad5bc01ec9726f1f3cdf2416ea88cbaa4bb8068", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ad5bc01ec9726f1f3cdf2416ea88cbaa4bb8068", "html_url": "https://github.com/rust-lang/rust/commit/3ad5bc01ec9726f1f3cdf2416ea88cbaa4bb8068"}, {"sha": "a61983f9359724c5ffabb5c0a2525aca756fe9ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61983f9359724c5ffabb5c0a2525aca756fe9ea", "html_url": "https://github.com/rust-lang/rust/commit/a61983f9359724c5ffabb5c0a2525aca756fe9ea"}], "stats": {"total": 61, "additions": 1, "deletions": 60}, "files": [{"sha": "dd801e6853aee9d86d4abb81d63e0dbac57b40d1", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/915fa2a378a22d197ed85f2d563f443edb10b713/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/915fa2a378a22d197ed85f2d563f443edb10b713/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=915fa2a378a22d197ed85f2d563f443edb10b713", "patch": "@@ -387,50 +387,6 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n             }\n         })\n     }\n-\n-    /// Transform this guard to hold a sub-borrow of the original data.\n-    ///\n-    /// Applies the supplied closure to the data, returning a new lock\n-    /// guard referencing the borrow returned by the closure.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// # #![feature(guard_map)]\n-    /// # use std::sync::{Mutex, MutexGuard};\n-    /// let x = Mutex::new(vec![1, 2]);\n-    ///\n-    /// {\n-    ///     let mut y = MutexGuard::map(x.lock().unwrap(), |v| &mut v[0]);\n-    ///     *y = 3;\n-    /// }\n-    ///\n-    /// assert_eq!(&*x.lock().unwrap(), &[3, 2]);\n-    /// ```\n-    #[unstable(feature = \"guard_map\",\n-               reason = \"recently added, needs RFC for stabilization\",\n-               issue = \"27746\")]\n-    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> MutexGuard<'mutex, U>\n-        where F: FnOnce(&'mutex mut T) -> &'mutex mut U\n-    {\n-        // Compute the new data while still owning the original lock\n-        // in order to correctly poison if the callback panics.\n-        let data = unsafe { ptr::read(&this.__data) };\n-        let new_data = cb(data);\n-\n-        // We don't want to unlock the lock by running the destructor of the\n-        // original lock, so just read the fields we need and forget it.\n-        let (poison, lock) = unsafe {\n-            (ptr::read(&this.__poison), ptr::read(&this.__lock))\n-        };\n-        mem::forget(this);\n-\n-        MutexGuard {\n-            __lock: lock,\n-            __data: new_data,\n-            __poison: poison\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -469,7 +425,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use sync::{Arc, Mutex, StaticMutex, Condvar, MutexGuard};\n+    use sync::{Arc, Mutex, StaticMutex, Condvar};\n     use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n \n@@ -713,19 +669,4 @@ mod tests {\n         let comp: &[i32] = &[4, 2, 5];\n         assert_eq!(&*mutex.lock().unwrap(), comp);\n     }\n-\n-    #[test]\n-    fn test_mutex_guard_map_panic() {\n-        let mutex = Arc::new(Mutex::new(vec![1, 2]));\n-        let mutex2 = mutex.clone();\n-\n-        thread::spawn(move || {\n-            let _ = MutexGuard::map::<usize, _>(mutex2.lock().unwrap(), |_| panic!());\n-        }).join().unwrap_err();\n-\n-        match mutex.lock() {\n-            Ok(r) => panic!(\"Lock on poisioned Mutex is Ok: {:?}\", &*r),\n-            Err(_) => {}\n-        };\n-    }\n }"}]}