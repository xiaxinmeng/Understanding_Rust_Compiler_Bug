{"sha": "2edb6438cb83c144f0ce480a47975043bbee2d4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZGI2NDM4Y2I4M2MxNDRmMGNlNDgwYTQ3OTc1MDQzYmJlZTJkNGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-29T22:49:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-29T22:49:07Z"}, "message": "rollup merge of #24921: tamird/bitflags-associated-const\n\nConflicts:\n\tsrc/librustc/lib.rs", "tree": {"sha": "3b0ebb9195271dbb1310ce6f84794aa08761f8fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b0ebb9195271dbb1310ce6f84794aa08761f8fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2edb6438cb83c144f0ce480a47975043bbee2d4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2edb6438cb83c144f0ce480a47975043bbee2d4b", "html_url": "https://github.com/rust-lang/rust/commit/2edb6438cb83c144f0ce480a47975043bbee2d4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2edb6438cb83c144f0ce480a47975043bbee2d4b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc04cd4bb169141c12b1f44ea75f265826dfbda9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc04cd4bb169141c12b1f44ea75f265826dfbda9", "html_url": "https://github.com/rust-lang/rust/commit/cc04cd4bb169141c12b1f44ea75f265826dfbda9"}, {"sha": "8c58fe17393d01a3b1661cc43ec5ffcf005a0c1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c58fe17393d01a3b1661cc43ec5ffcf005a0c1d", "html_url": "https://github.com/rust-lang/rust/commit/8c58fe17393d01a3b1661cc43ec5ffcf005a0c1d"}], "stats": {"total": 636, "additions": 341, "deletions": 295}, "files": [{"sha": "aeb08464ff566554d9a0b6cf21615c1c59a8063c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -25,22 +25,23 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(associated_consts)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(fs_canonicalize)]\n #![feature(hash)]\n+#![feature(into_cow)]\n #![feature(libc)]\n+#![feature(path_ext)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(path_ext)]\n #![feature(str_char)]\n-#![feature(into_cow)]\n-#![feature(fs_canonicalize)]\n-#![feature(slice_patterns)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]"}, {"sha": "5b0eea6bcc51678466a24364db67707f4ef8b08b", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -46,33 +46,35 @@ bitflags! {\n     #[derive(RustcEncodable, RustcDecodable)]\n     flags ConstQualif: u8 {\n         // Const rvalue which can be placed behind a reference.\n-        const PURE_CONST          = 0b000000,\n+        const PURE_CONST         = 0,\n         // Inner mutability (can not be placed behind a reference) or behind\n         // &mut in a non-global expression. Can be copied from static memory.\n-        const MUTABLE_MEM         = 0b000001,\n+        const MUTABLE_MEM        = 1 << 0,\n         // Constant value with a type that implements Drop. Can be copied\n         // from static memory, similar to MUTABLE_MEM.\n-        const NEEDS_DROP          = 0b000010,\n+        const NEEDS_DROP         = 1 << 1,\n         // Even if the value can be placed in static memory, copying it from\n         // there is more expensive than in-place instantiation, and/or it may\n         // be too large. This applies to [T; N] and everything containing it.\n         // N.B.: references need to clear this flag to not end up on the stack.\n-        const PREFER_IN_PLACE     = 0b000100,\n+        const PREFER_IN_PLACE    = 1 << 2,\n         // May use more than 0 bytes of memory, doesn't impact the constness\n         // directly, but is not allowed to be borrowed mutably in a constant.\n-        const NON_ZERO_SIZED      = 0b001000,\n+        const NON_ZERO_SIZED     = 1 << 3,\n         // Actually borrowed, has to always be in static memory. Does not\n         // propagate, and requires the expression to behave like a 'static\n         // lvalue. The set of expressions with this flag is the minimum\n         // that have to be promoted.\n-        const HAS_STATIC_BORROWS  = 0b010000,\n+        const HAS_STATIC_BORROWS = 1 << 4,\n         // Invalid const for miscellaneous reasons (e.g. not implemented).\n-        const NOT_CONST           = 0b100000,\n+        const NOT_CONST          = 1 << 5,\n \n         // Borrowing the expression won't produce &'static T if any of these\n         // bits are set, though the value could be copied from static memory\n         // if `NOT_CONST` isn't set.\n-        const NON_STATIC_BORROWS = MUTABLE_MEM.bits | NEEDS_DROP.bits | NOT_CONST.bits\n+        const NON_STATIC_BORROWS = ConstQualif::MUTABLE_MEM.bits |\n+                                   ConstQualif::NEEDS_DROP.bits |\n+                                   ConstQualif::NOT_CONST.bits\n     }\n }\n \n@@ -102,7 +104,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     {\n         let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n-        self.qualif = PURE_CONST;\n+        self.qualif = ConstQualif::PURE_CONST;\n         let r = f(self);\n         self.mode = old_mode;\n         self.qualif = old_qualif;\n@@ -126,7 +128,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             Entry::Occupied(entry) => return *entry.get(),\n             Entry::Vacant(entry) => {\n                 // Prevent infinite recursion on re-entry.\n-                entry.insert(PURE_CONST);\n+                entry.insert(ConstQualif::PURE_CONST);\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -271,7 +273,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         let mut outer = self.qualif;\n-        self.qualif = PURE_CONST;\n+        self.qualif = ConstQualif::PURE_CONST;\n \n         let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n         check_expr(self, ex, node_ty);\n@@ -287,7 +289,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 self.visit_expr(&**callee);\n                 // The callee's size doesn't count in the call.\n                 let added = self.qualif - inner;\n-                self.qualif = inner | (added - NON_ZERO_SIZED);\n+                self.qualif = inner | (added - ConstQualif::NON_ZERO_SIZED);\n             }\n             ast::ExprRepeat(ref element, _) => {\n                 self.visit_expr(&**element);\n@@ -298,7 +300,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 };\n                 // [element; 0] is always zero-sized.\n                 if count == 0 {\n-                    self.qualif = self.qualif - (NON_ZERO_SIZED | PREFER_IN_PLACE);\n+                    self.qualif.remove(ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n                 }\n             }\n             ast::ExprMatch(ref discr, ref arms, _) => {\n@@ -325,7 +327,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 let div_or_rem = op.node == ast::BiDiv || op.node == ast::BiRem;\n                 match node_ty.sty {\n                     ty::ty_uint(_) | ty::ty_int(_) if div_or_rem => {\n-                        if !self.qualif.intersects(NOT_CONST) {\n+                        if !self.qualif.intersects(ConstQualif::NOT_CONST) {\n                             match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n                                 Ok(_) => {}\n                                 Err(msg) => {\n@@ -348,11 +350,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 // Constants cannot be borrowed if they contain interior mutability as\n                 // it means that our \"silent insertion of statics\" could change\n                 // initializer values (very bad).\n-                // If the type doesn't have interior mutability, then `MUTABLE_MEM` has\n+                // If the type doesn't have interior mutability, then `ConstQualif::MUTABLE_MEM` has\n                 // propagated from another error, so erroring again would be just noise.\n                 let tc = ty::type_contents(self.tcx, node_ty);\n-                if self.qualif.intersects(MUTABLE_MEM) && tc.interior_unsafe() {\n-                    outer = outer | NOT_CONST;\n+                if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n+                    outer = outer | ConstQualif::NOT_CONST;\n                     if self.mode != Mode::Var {\n                         self.tcx.sess.span_err(ex.span,\n                             \"cannot borrow a constant which contains \\\n@@ -361,32 +363,32 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 }\n                 // If the reference has to be 'static, avoid in-place initialization\n                 // as that will end up pointing to the stack instead.\n-                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n-                    self.qualif = self.qualif - PREFER_IN_PLACE;\n-                    self.add_qualif(HAS_STATIC_BORROWS);\n+                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n+                    self.qualif = self.qualif - ConstQualif::PREFER_IN_PLACE;\n+                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n                 }\n             }\n             Some(ast::MutMutable) => {\n                 // `&mut expr` means expr could be mutated, unless it's zero-sized.\n-                if self.qualif.intersects(NON_ZERO_SIZED) {\n+                if self.qualif.intersects(ConstQualif::NON_ZERO_SIZED) {\n                     if self.mode == Mode::Var {\n-                        outer = outer | NOT_CONST;\n-                        self.add_qualif(MUTABLE_MEM);\n+                        outer = outer | ConstQualif::NOT_CONST;\n+                        self.add_qualif(ConstQualif::MUTABLE_MEM);\n                     } else {\n                         span_err!(self.tcx.sess, ex.span, E0017,\n                             \"references in {}s may only refer \\\n                              to immutable values\", self.msg())\n                     }\n                 }\n-                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n-                    self.add_qualif(HAS_STATIC_BORROWS);\n+                if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n+                    self.add_qualif(ConstQualif::HAS_STATIC_BORROWS);\n                 }\n             }\n             None => {}\n         }\n         self.tcx.const_qualif_map.borrow_mut().insert(ex.id, self.qualif);\n         // Don't propagate certain flags.\n-        self.qualif = outer | (self.qualif - HAS_STATIC_BORROWS);\n+        self.qualif = outer | (self.qualif - ConstQualif::HAS_STATIC_BORROWS);\n     }\n }\n \n@@ -401,7 +403,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n     match node_ty.sty {\n         ty::ty_struct(did, _) |\n         ty::ty_enum(did, _) if ty::has_dtor(v.tcx, did) => {\n-            v.add_qualif(NEEDS_DROP);\n+            v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n                                     &format!(\"{}s are not allowed to have destructors\",\n@@ -416,15 +418,15 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprUnary(..) |\n         ast::ExprBinary(..) |\n         ast::ExprIndex(..) if v.tcx.method_map.borrow().contains_key(&method_call) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0011,\n                             \"user-defined operators are not allowed in {}s\", v.msg());\n             }\n         }\n         ast::ExprBox(..) |\n         ast::ExprUnary(ast::UnUniq, _) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0010,\n                           \"allocations are not allowed in {}s\", v.msg());\n@@ -434,7 +436,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             match ty::node_id_to_type(v.tcx, ptr.id).sty {\n                 ty::ty_ptr(_) => {\n                     // This shouldn't be allowed in constants at all.\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                 }\n                 _ => {}\n             }\n@@ -447,15 +449,15 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 ty::type_is_unsafe_ptr(toty) ||\n                 (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n             if !is_legal_cast {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, e.span, E0012,\n                               \"can not cast to `{}` in {}s\",\n                               ppaux::ty_to_string(v.tcx, toty), v.msg());\n                 }\n             }\n             if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, e.span, E0018,\n                               \"can not cast a pointer to an integer in {}s\", v.msg());\n@@ -467,17 +469,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             match def {\n                 Some(def::DefVariant(_, _, _)) => {\n                     // Count the discriminator or function pointer.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 Some(def::DefStruct(_)) => {\n                     if let ty::ty_bare_fn(..) = node_ty.sty {\n                         // Count the function pointer.\n-                        v.add_qualif(NON_ZERO_SIZED);\n+                        v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     }\n                 }\n                 Some(def::DefFn(..)) | Some(def::DefMethod(..)) => {\n                     // Count the function pointer.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 Some(def::DefStatic(..)) => {\n                     match v.mode {\n@@ -487,7 +489,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                                 \"constants cannot refer to other statics, \\\n                                  insert an intermediate constant instead\");\n                         }\n-                        Mode::Var => v.add_qualif(NOT_CONST)\n+                        Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n                 }\n                 Some(def::DefConst(did)) |\n@@ -503,7 +505,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     }\n                 }\n                 def => {\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n                         debug!(\"(checking const) found bad def: {:?}\", def);\n                         span_err!(v.tcx.sess, e.span, E0014,\n@@ -530,10 +532,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(def::DefStruct(..)) => {}\n                 Some(def::DefVariant(..)) => {\n                     // Count the discriminator.\n-                    v.add_qualif(NON_ZERO_SIZED);\n+                    v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n                 _ => {\n-                    v.add_qualif(NOT_CONST);\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n                         span_err!(v.tcx.sess, e.span, E0015,\n                                   \"function calls in {}s are limited to \\\n@@ -545,7 +547,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n             let mut block_span_err = |span| {\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, span, E0016,\n                               \"blocks in {}s are limited to items and \\\n@@ -574,17 +576,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprStruct(..) => {\n             let did = v.tcx.def_map.borrow().get(&e.id).map(|def| def.def_id());\n             if did == v.tcx.lang_items.unsafe_cell_type() {\n-                v.add_qualif(MUTABLE_MEM);\n+                v.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n         }\n \n         ast::ExprLit(_) |\n         ast::ExprAddrOf(..) => {\n-            v.add_qualif(NON_ZERO_SIZED);\n+            v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n         }\n \n         ast::ExprRepeat(..) => {\n-            v.add_qualif(PREFER_IN_PLACE);\n+            v.add_qualif(ConstQualif::PREFER_IN_PLACE);\n         }\n \n         ast::ExprClosure(..) => {\n@@ -593,7 +595,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n                 assert!(v.mode == Mode::Var,\n                         \"global closures can't capture anything\");\n-                v.add_qualif(NOT_CONST);\n+                v.add_qualif(ConstQualif::NOT_CONST);\n             }\n         }\n \n@@ -631,7 +633,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ast::ExprAssignOp(..) |\n         ast::ExprInlineAsm(_) |\n         ast::ExprMac(_) => {\n-            v.add_qualif(NOT_CONST);\n+            v.add_qualif(ConstQualif::NOT_CONST);\n             if v.mode != Mode::Var {\n                 span_err!(v.tcx.sess, e.span, E0019,\n                           \"{} contains unimplemented expression type\", v.msg());\n@@ -644,7 +646,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut CheckCrateVisitor {\n         tcx: tcx,\n         mode: Mode::Var,\n-        qualif: NOT_CONST,\n+        qualif: ConstQualif::NOT_CONST,\n         rvalue_borrows: NodeMap()\n     }, tcx.map.krate());\n "}, {"sha": "c4ab89e3b4da07ef0de3663309127aeda946a7b9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -838,20 +838,20 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n         let qualif = self.tcx().const_qualif_map.borrow().get(&id).cloned()\n-                               .unwrap_or(check_const::NOT_CONST);\n+                               .unwrap_or(check_const::ConstQualif::NOT_CONST);\n \n         // Only promote `[T; 0]` before an RFC for rvalue promotions\n         // is accepted.\n         let qualif = match expr_ty.sty {\n             ty::ty_vec(_, Some(0)) => qualif,\n-            _ => check_const::NOT_CONST\n+            _ => check_const::ConstQualif::NOT_CONST\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n-        let re = match qualif & check_const::NON_STATIC_BORROWS {\n-            check_const::PURE_CONST => ty::ReStatic,\n+        let re = match qualif & check_const::ConstQualif::NON_STATIC_BORROWS {\n+            check_const::ConstQualif::PURE_CONST => ty::ReStatic,\n             _ => self.temporary_scope(id),\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);"}, {"sha": "33ba21bc7b15445c16a860328e2ca10e8f2f8b01", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -848,16 +848,18 @@ impl<'tcx> ctxt<'tcx> {\n // recursing over the type itself.\n bitflags! {\n     flags TypeFlags: u32 {\n-        const NO_TYPE_FLAGS       = 0b0,\n-        const HAS_PARAMS          = 0b1,\n-        const HAS_SELF            = 0b10,\n-        const HAS_TY_INFER        = 0b100,\n-        const HAS_RE_INFER        = 0b1000,\n-        const HAS_RE_LATE_BOUND   = 0b10000,\n-        const HAS_REGIONS         = 0b100000,\n-        const HAS_TY_ERR          = 0b1000000,\n-        const HAS_PROJECTION      = 0b10000000,\n-        const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n+        const NO_TYPE_FLAGS     = 0,\n+        const HAS_PARAMS        = 1 << 0,\n+        const HAS_SELF          = 1 << 1,\n+        const HAS_TY_INFER      = 1 << 2,\n+        const HAS_RE_INFER      = 1 << 3,\n+        const HAS_RE_LATE_BOUND = 1 << 4,\n+        const HAS_REGIONS       = 1 << 5,\n+        const HAS_TY_ERR        = 1 << 6,\n+        const HAS_PROJECTION    = 1 << 7,\n+        const NEEDS_SUBST       = TypeFlags::HAS_PARAMS.bits |\n+                                  TypeFlags::HAS_SELF.bits |\n+                                  TypeFlags::HAS_REGIONS.bits,\n     }\n }\n \n@@ -890,8 +892,8 @@ macro_rules! sty_debug_print {\n                         ty::ty_err => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let region = t.flags.intersects(ty::HAS_RE_INFER);\n-                    let ty = t.flags.intersects(ty::HAS_TY_INFER);\n+                    let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n@@ -993,23 +995,23 @@ impl<'tcx> Borrow<sty<'tcx>> for InternedTy<'tcx> {\n }\n \n pub fn type_has_params(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_PARAMS)\n+    ty.flags.intersects(TypeFlags::HAS_PARAMS)\n }\n pub fn type_has_self(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_SELF)\n+    ty.flags.intersects(TypeFlags::HAS_SELF)\n }\n pub fn type_has_ty_infer(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_INFER)\n+    ty.flags.intersects(TypeFlags::HAS_TY_INFER)\n }\n pub fn type_needs_infer(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_INFER | HAS_RE_INFER)\n+    ty.flags.intersects(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n }\n pub fn type_has_projection(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_PROJECTION)\n+    ty.flags.intersects(TypeFlags::HAS_PROJECTION)\n }\n \n pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_RE_LATE_BOUND)\n+    ty.flags.intersects(TypeFlags::HAS_RE_LATE_BOUND)\n }\n \n /// An \"escaping region\" is a bound region whose binder is not part of `t`.\n@@ -2810,7 +2812,7 @@ struct FlagComputation {\n \n impl FlagComputation {\n     fn new() -> FlagComputation {\n-        FlagComputation { flags: NO_TYPE_FLAGS, depth: 0 }\n+        FlagComputation { flags: TypeFlags::NO_TYPE_FLAGS, depth: 0 }\n     }\n \n     fn for_sty(st: &sty) -> FlagComputation {\n@@ -2855,20 +2857,20 @@ impl FlagComputation {\n \n             // You might think that we could just return ty_err for\n             // any type containing ty_err as a component, and get\n-            // rid of the HAS_TY_ERR flag -- likewise for ty_bot (with\n+            // rid of the TypeFlags::HAS_TY_ERR flag -- likewise for ty_bot (with\n             // the exception of function types that return bot).\n             // But doing so caused sporadic memory corruption, and\n             // neither I (tjc) nor nmatsakis could figure out why,\n             // so we're doing it this way.\n             &ty_err => {\n-                self.add_flags(HAS_TY_ERR)\n+                self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n             &ty_param(ref p) => {\n                 if p.space == subst::SelfSpace {\n-                    self.add_flags(HAS_SELF);\n+                    self.add_flags(TypeFlags::HAS_SELF);\n                 } else {\n-                    self.add_flags(HAS_PARAMS);\n+                    self.add_flags(TypeFlags::HAS_PARAMS);\n                 }\n             }\n \n@@ -2877,15 +2879,15 @@ impl FlagComputation {\n             }\n \n             &ty_infer(_) => {\n-                self.add_flags(HAS_TY_INFER)\n+                self.add_flags(TypeFlags::HAS_TY_INFER)\n             }\n \n             &ty_enum(_, substs) | &ty_struct(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n             &ty_projection(ref data) => {\n-                self.add_flags(HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n \n@@ -2949,11 +2951,11 @@ impl FlagComputation {\n     }\n \n     fn add_region(&mut self, r: Region) {\n-        self.add_flags(HAS_REGIONS);\n+        self.add_flags(TypeFlags::HAS_REGIONS);\n         match r {\n-            ty::ReInfer(_) => { self.add_flags(HAS_RE_INFER); }\n+            ty::ReInfer(_) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n             ty::ReLateBound(debruijn, _) => {\n-                self.add_flags(HAS_RE_LATE_BOUND);\n+                self.add_flags(TypeFlags::HAS_RE_LATE_BOUND);\n                 self.add_depth(debruijn.depth);\n             }\n             _ => { }\n@@ -3307,11 +3309,11 @@ pub fn type_is_nil(ty: Ty) -> bool {\n }\n \n pub fn type_is_error(ty: Ty) -> bool {\n-    ty.flags.intersects(HAS_TY_ERR)\n+    ty.flags.intersects(TypeFlags::HAS_TY_ERR)\n }\n \n pub fn type_needs_subst(ty: Ty) -> bool {\n-    ty.flags.intersects(NEEDS_SUBST)\n+    ty.flags.intersects(TypeFlags::NEEDS_SUBST)\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {"}, {"sha": "6d23cad26cb37e76d07362fbe3f31b5e1893b1af", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -12,6 +12,7 @@\n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"rustc_bitflags\"]\n+#![feature(associated_consts)]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -34,26 +35,27 @@\n ///\n /// ```{.rust}\n /// # #![feature(rustc_private)]\n+/// # #![feature(associated_consts)]\n /// #[macro_use] extern crate rustc_bitflags;\n ///\n /// bitflags! {\n ///     flags Flags: u32 {\n ///         const FLAG_A       = 0b00000001,\n ///         const FLAG_B       = 0b00000010,\n ///         const FLAG_C       = 0b00000100,\n-///         const FLAG_ABC     = FLAG_A.bits\n-///                            | FLAG_B.bits\n-///                            | FLAG_C.bits,\n+///         const FLAG_ABC     = Flags::FLAG_A.bits\n+///                            | Flags::FLAG_B.bits\n+///                            | Flags::FLAG_C.bits,\n ///     }\n /// }\n ///\n /// fn main() {\n-///     let e1 = FLAG_A | FLAG_C;\n-///     let e2 = FLAG_B | FLAG_C;\n-///     assert!((e1 | e2) == FLAG_ABC);   // union\n-///     assert!((e1 & e2) == FLAG_C);     // intersection\n-///     assert!((e1 - e2) == FLAG_A);     // set difference\n-///     assert!(!e2 == FLAG_A);           // set complement\n+///     let e1 = Flags::FLAG_A | Flags::FLAG_C;\n+///     let e2 = Flags::FLAG_B | Flags::FLAG_C;\n+///     assert!((e1 | e2) == Flags::FLAG_ABC); // union\n+///     assert!((e1 & e2) == Flags::FLAG_C);   // intersection\n+///     assert!((e1 - e2) == Flags::FLAG_A);   // set difference\n+///     assert!(!e2 == Flags::FLAG_A);         // set complement\n /// }\n /// ```\n ///\n@@ -86,7 +88,7 @@\n /// }\n ///\n /// fn main() {\n-///     let mut flags = FLAG_A | FLAG_B;\n+///     let mut flags = Flags::FLAG_A | Flags::FLAG_B;\n ///     flags.clear();\n ///     assert!(flags.is_empty());\n ///     assert_eq!(format!(\"{:?}\", flags), \"hi!\");\n@@ -144,9 +146,9 @@ macro_rules! bitflags {\n             bits: $T,\n         }\n \n-        $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n-\n         impl $BitFlags {\n+            $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+\n             /// Returns an empty set of flags.\n             #[inline]\n             pub fn empty() -> $BitFlags {\n@@ -314,9 +316,9 @@ mod tests {\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n-            const FlagABC     = FlagA.bits\n-                               | FlagB.bits\n-                               | FlagC.bits,\n+            const FlagABC     = Flags::FlagA.bits\n+                               | Flags::FlagB.bits\n+                               | Flags::FlagC.bits,\n         }\n     }\n \n@@ -329,52 +331,52 @@ mod tests {\n     #[test]\n     fn test_bits(){\n         assert_eq!(Flags::empty().bits(), 0b00000000);\n-        assert_eq!(FlagA.bits(), 0b00000001);\n-        assert_eq!(FlagABC.bits(), 0b00000111);\n+        assert_eq!(Flags::FlagA.bits(), 0b00000001);\n+        assert_eq!(Flags::FlagABC.bits(), 0b00000111);\n \n         assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n-        assert_eq!(AnotherFlag.bits(), !0);\n+        assert_eq!(AnotherSetOfFlags::AnotherFlag.bits(), !0);\n     }\n \n     #[test]\n     fn test_from_bits() {\n         assert!(Flags::from_bits(0) == Some(Flags::empty()));\n-        assert!(Flags::from_bits(0b1) == Some(FlagA));\n-        assert!(Flags::from_bits(0b10) == Some(FlagB));\n-        assert!(Flags::from_bits(0b11) == Some(FlagA | FlagB));\n+        assert!(Flags::from_bits(0b1) == Some(Flags::FlagA));\n+        assert!(Flags::from_bits(0b10) == Some(Flags::FlagB));\n+        assert!(Flags::from_bits(0b11) == Some(Flags::FlagA | Flags::FlagB));\n         assert!(Flags::from_bits(0b1000) == None);\n \n-        assert!(AnotherSetOfFlags::from_bits(!0) == Some(AnotherFlag));\n+        assert!(AnotherSetOfFlags::from_bits(!0) == Some(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_from_bits_truncate() {\n         assert!(Flags::from_bits_truncate(0) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0b1) == FlagA);\n-        assert!(Flags::from_bits_truncate(0b10) == FlagB);\n-        assert!(Flags::from_bits_truncate(0b11) == (FlagA | FlagB));\n+        assert!(Flags::from_bits_truncate(0b1) == Flags::FlagA);\n+        assert!(Flags::from_bits_truncate(0b10) == Flags::FlagB);\n+        assert!(Flags::from_bits_truncate(0b11) == (Flags::FlagA | Flags::FlagB));\n         assert!(Flags::from_bits_truncate(0b1000) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0b1001) == FlagA);\n+        assert!(Flags::from_bits_truncate(0b1001) == Flags::FlagA);\n \n         assert!(AnotherSetOfFlags::from_bits_truncate(0) == AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n     fn test_is_empty(){\n         assert!(Flags::empty().is_empty());\n-        assert!(!FlagA.is_empty());\n-        assert!(!FlagABC.is_empty());\n+        assert!(!Flags::FlagA.is_empty());\n+        assert!(!Flags::FlagABC.is_empty());\n \n-        assert!(!AnotherFlag.is_empty());\n+        assert!(!AnotherSetOfFlags::AnotherFlag.is_empty());\n     }\n \n     #[test]\n     fn test_is_all() {\n         assert!(Flags::all().is_all());\n-        assert!(!FlagA.is_all());\n-        assert!(FlagABC.is_all());\n+        assert!(!Flags::FlagA.is_all());\n+        assert!(Flags::FlagABC.is_all());\n \n-        assert!(AnotherFlag.is_all());\n+        assert!(AnotherSetOfFlags::AnotherFlag.is_all());\n     }\n \n     #[test]\n@@ -383,77 +385,77 @@ mod tests {\n         let e2 = Flags::empty();\n         assert!(!e1.intersects(e2));\n \n-        assert!(AnotherFlag.intersects(AnotherFlag));\n+        assert!(AnotherSetOfFlags::AnotherFlag.intersects(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_empty_does_not_intersect_with_full() {\n         let e1 = Flags::empty();\n-        let e2 = FlagABC;\n+        let e2 = Flags::FlagABC;\n         assert!(!e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_disjoint_intersects() {\n-        let e1 = FlagA;\n-        let e2 = FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagB;\n         assert!(!e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_overlapping_intersects() {\n-        let e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         assert!(e1.intersects(e2));\n     }\n \n     #[test]\n     fn test_contains() {\n-        let e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         assert!(!e1.contains(e2));\n         assert!(e2.contains(e1));\n-        assert!(FlagABC.contains(e2));\n+        assert!(Flags::FlagABC.contains(e2));\n \n-        assert!(AnotherFlag.contains(AnotherFlag));\n+        assert!(AnotherSetOfFlags::AnotherFlag.contains(AnotherSetOfFlags::AnotherFlag));\n     }\n \n     #[test]\n     fn test_insert(){\n-        let mut e1 = FlagA;\n-        let e2 = FlagA | FlagB;\n+        let mut e1 = Flags::FlagA;\n+        let e2 = Flags::FlagA | Flags::FlagB;\n         e1.insert(e2);\n         assert!(e1 == e2);\n \n         let mut e3 = AnotherSetOfFlags::empty();\n-        e3.insert(AnotherFlag);\n-        assert!(e3 == AnotherFlag);\n+        e3.insert(AnotherSetOfFlags::AnotherFlag);\n+        assert!(e3 == AnotherSetOfFlags::AnotherFlag);\n     }\n \n     #[test]\n     fn test_remove(){\n-        let mut e1 = FlagA | FlagB;\n-        let e2 = FlagA | FlagC;\n+        let mut e1 = Flags::FlagA | Flags::FlagB;\n+        let e2 = Flags::FlagA | Flags::FlagC;\n         e1.remove(e2);\n-        assert!(e1 == FlagB);\n+        assert!(e1 == Flags::FlagB);\n \n-        let mut e3 = AnotherFlag;\n-        e3.remove(AnotherFlag);\n+        let mut e3 = AnotherSetOfFlags::AnotherFlag;\n+        e3.remove(AnotherSetOfFlags::AnotherFlag);\n         assert!(e3 == AnotherSetOfFlags::empty());\n     }\n \n     #[test]\n     fn test_operators() {\n-        let e1 = FlagA | FlagC;\n-        let e2 = FlagB | FlagC;\n-        assert!((e1 | e2) == FlagABC);     // union\n-        assert!((e1 & e2) == FlagC);       // intersection\n-        assert!((e1 - e2) == FlagA);       // set difference\n-        assert!(!e2 == FlagA);             // set complement\n-        assert!(e1 ^ e2 == FlagA | FlagB); // toggle\n+        let e1 = Flags::FlagA | Flags::FlagC;\n+        let e2 = Flags::FlagB | Flags::FlagC;\n+        assert!((e1 | e2) == Flags::FlagABC);     // union\n+        assert!((e1 & e2) == Flags::FlagC);       // intersection\n+        assert!((e1 - e2) == Flags::FlagA);       // set difference\n+        assert!(!e2 == Flags::FlagA);             // set complement\n+        assert!(e1 ^ e2 == Flags::FlagA | Flags::FlagB); // toggle\n         let mut e3 = e1;\n         e3.toggle(e2);\n-        assert!(e3 == FlagA | FlagB);\n+        assert!(e3 == Flags::FlagA | Flags::FlagB);\n \n         let mut m4 = AnotherSetOfFlags::empty();\n         m4.toggle(AnotherSetOfFlags::empty());\n@@ -466,11 +468,11 @@ mod tests {\n         let mut b = Flags::empty();\n \n         assert!(!(a < b) && !(b < a));\n-        b = FlagB;\n+        b = Flags::FlagB;\n         assert!(a < b);\n-        a = FlagC;\n+        a = Flags::FlagC;\n         assert!(!(a < b) && b < a);\n-        b = FlagC | FlagB;\n+        b = Flags::FlagC | Flags::FlagB;\n         assert!(a < b);\n     }\n \n@@ -480,10 +482,10 @@ mod tests {\n         let mut b = Flags::empty();\n \n         assert!(a <= b && a >= b);\n-        a = FlagA;\n+        a = Flags::FlagA;\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        b = FlagB;\n+        b = Flags::FlagB;\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -494,7 +496,7 @@ mod tests {\n       let mut y = Flags::empty();\n       assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n       x = Flags::all();\n-      y = FlagABC;\n+      y = Flags::FlagABC;\n       assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n     }\n }"}, {"sha": "db88072150a603f2ef49f5847f51065e7abbd4dc", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -25,6 +25,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(associated_consts)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(libc)]\n@@ -124,32 +125,32 @@ pub enum DiagnosticSeverity {\n \n bitflags! {\n     flags Attribute : u32 {\n-        const ZExtAttribute = 1 << 0,\n-        const SExtAttribute = 1 << 1,\n-        const NoReturnAttribute = 1 << 2,\n-        const InRegAttribute = 1 << 3,\n-        const StructRetAttribute = 1 << 4,\n-        const NoUnwindAttribute = 1 << 5,\n-        const NoAliasAttribute = 1 << 6,\n-        const ByValAttribute = 1 << 7,\n-        const NestAttribute = 1 << 8,\n-        const ReadNoneAttribute = 1 << 9,\n-        const ReadOnlyAttribute = 1 << 10,\n-        const NoInlineAttribute = 1 << 11,\n-        const AlwaysInlineAttribute = 1 << 12,\n+        const ZExtAttribute            = 1 << 0,\n+        const SExtAttribute            = 1 << 1,\n+        const NoReturnAttribute        = 1 << 2,\n+        const InRegAttribute           = 1 << 3,\n+        const StructRetAttribute       = 1 << 4,\n+        const NoUnwindAttribute        = 1 << 5,\n+        const NoAliasAttribute         = 1 << 6,\n+        const ByValAttribute           = 1 << 7,\n+        const NestAttribute            = 1 << 8,\n+        const ReadNoneAttribute        = 1 << 9,\n+        const ReadOnlyAttribute        = 1 << 10,\n+        const NoInlineAttribute        = 1 << 11,\n+        const AlwaysInlineAttribute    = 1 << 12,\n         const OptimizeForSizeAttribute = 1 << 13,\n-        const StackProtectAttribute = 1 << 14,\n+        const StackProtectAttribute    = 1 << 14,\n         const StackProtectReqAttribute = 1 << 15,\n-        const AlignmentAttribute = 31 << 16,\n-        const NoCaptureAttribute = 1 << 21,\n-        const NoRedZoneAttribute = 1 << 22,\n+        const AlignmentAttribute       = 1 << 16,\n+        const NoCaptureAttribute       = 1 << 21,\n+        const NoRedZoneAttribute       = 1 << 22,\n         const NoImplicitFloatAttribute = 1 << 23,\n-        const NakedAttribute = 1 << 24,\n-        const InlineHintAttribute = 1 << 25,\n-        const StackAttribute = 7 << 26,\n-        const ReturnsTwiceAttribute = 1 << 29,\n-        const UWTableAttribute = 1 << 30,\n-        const NonLazyBindAttribute = 1 << 31,\n+        const NakedAttribute           = 1 << 24,\n+        const InlineHintAttribute      = 1 << 25,\n+        const StackAttribute           = 7 << 26,\n+        const ReturnsTwiceAttribute    = 1 << 29,\n+        const UWTableAttribute         = 1 << 30,\n+        const NonLazyBindAttribute     = 1 << 31,\n     }\n }\n "}, {"sha": "4ea18968d43ac218df9fbc3dda33aee3c716ad1e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -13,7 +13,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use {DefModifiers, PUBLIC, IMPORTABLE};\n+use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n use resolve_imports::ImportResolution;\n@@ -262,7 +262,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let name = item.ident.name;\n         let sp = item.span;\n         let is_public = item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n \n         match item.node {\n             ItemUse(ref view_path) => {\n@@ -533,20 +537,20 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         ast::ConstTraitItem(..) => {\n                             let def = DefAssociatedConst(local_def(trait_item.id),\n                                                          FromTrait(local_def(item.id)));\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         ast::MethodTraitItem(..) => {\n                             let def = DefMethod(local_def(trait_item.id),\n                                                 FromTrait(local_def(item.id)));\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_value(def, trait_item.span, PUBLIC);\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         ast::TypeTraitItem(..) => {\n                             let def = DefAssociatedTy(local_def(item.id),\n                                                       local_def(trait_item.id));\n-                            // NB: not IMPORTABLE\n-                            name_bindings.define_type(def, trait_item.span, PUBLIC);\n+                            // NB: not DefModifiers::IMPORTABLE\n+                            name_bindings.define_type(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                     }\n \n@@ -584,10 +588,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         // used\n         child.define_value(DefVariant(item_id,\n                                       local_def(variant.node.id), is_exported),\n-                           variant.span, PUBLIC | IMPORTABLE);\n+                           variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n         child.define_type(DefVariant(item_id,\n                                      local_def(variant.node.id), is_exported),\n-                          variant.span, PUBLIC | IMPORTABLE);\n+                          variant.span, DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -596,7 +600,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             parent: &Rc<Module>) {\n         let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let name_bindings =\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n@@ -644,7 +652,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 external crate) building external def {}, priv {:?}\",\n                final_ident, vis);\n         let is_public = vis == ast::Public;\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let is_exported = is_public && match new_parent.def_id.get() {\n             None => true,\n             Some(did) => self.external_exports.contains(&did)\n@@ -695,7 +707,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                       final_ident);\n               // variants are always treated as importable to allow them to be\n               // glob used\n-              let modifiers = PUBLIC | IMPORTABLE;\n+              let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n               if is_struct {\n                   child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n                   // Not adding fields for variants as they are not accessed with a self receiver\n@@ -715,11 +727,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     crate) building value (fn/static) {}\", final_ident);\n             // impl methods have already been defined with the correct importability modifier\n             let mut modifiers = match *child_name_bindings.value_def.borrow() {\n-                Some(ref def) => (modifiers & !IMPORTABLE) | (def.modifiers & IMPORTABLE),\n+                Some(ref def) => (modifiers & !DefModifiers::IMPORTABLE) |\n+                             (def.modifiers &  DefModifiers::IMPORTABLE),\n                 None => modifiers\n             };\n             if new_parent.kind.get() != NormalModuleKind {\n-                modifiers = modifiers & !IMPORTABLE;\n+                modifiers = modifiers & !DefModifiers::IMPORTABLE;\n             }\n             child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n           }"}, {"sha": "d8495fb989bfe1f292f06ec11f078b8257a546b6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -20,6 +20,7 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(alloc)]\n+#![feature(associated_consts)]\n #![feature(collections)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -477,8 +478,8 @@ impl fmt::Debug for Module {\n bitflags! {\n     #[derive(Debug)]\n     flags DefModifiers: u8 {\n-        const PUBLIC            = 0b0000_0001,\n-        const IMPORTABLE        = 0b0000_0010,\n+        const PUBLIC     = 1 << 0,\n+        const IMPORTABLE = 1 << 1,\n     }\n }\n \n@@ -524,7 +525,11 @@ impl NameBindings {\n                      is_public: bool,\n                      sp: Span) {\n         // Merges the module with the existing type def or creates a new one.\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let module_ = Rc::new(Module::new(parent_link,\n                                           def_id,\n                                           kind,\n@@ -559,7 +564,11 @@ impl NameBindings {\n                        external: bool,\n                        is_public: bool,\n                        _sp: Span) {\n-        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n+        let modifiers = if is_public {\n+            DefModifiers::PUBLIC\n+        } else {\n+            DefModifiers::empty()\n+        } | DefModifiers::IMPORTABLE;\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n             None => {\n@@ -659,7 +668,7 @@ impl NameBindings {\n     }\n \n     fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n-        self.defined_in_namespace_with(namespace, PUBLIC)\n+        self.defined_in_namespace_with(namespace, DefModifiers::PUBLIC)\n     }\n \n     fn defined_in_namespace_with(&self, namespace: Namespace, modifiers: DefModifiers) -> bool {\n@@ -730,11 +739,11 @@ impl NameBindings {\n         match namespace {\n             TypeNS  => {\n                 let type_def = self.type_def.borrow();\n-                type_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+                type_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n             }\n             ValueNS => {\n                 let value_def = self.value_def.borrow();\n-                value_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+                value_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n             }\n         }\n     }\n@@ -921,7 +930,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn create_name_bindings_from_module(module: Rc<Module>) -> NameBindings {\n         NameBindings {\n             type_def: RefCell::new(Some(TypeNsDef {\n-                modifiers: IMPORTABLE,\n+                modifiers: DefModifiers::IMPORTABLE,\n                 module_def: Some(module),\n                 type_def: None,\n                 type_span: None"}, {"sha": "350f69d30c4e452d8c0779e6798162aa7e257ae9", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -10,7 +10,7 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {PUBLIC, IMPORTABLE};\n+use DefModifiers;\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use NameBindings;\n@@ -848,7 +848,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // Merge the child item into the import resolution.\n         {\n             let mut merge_child_item = |namespace| {\n-                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n+                let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n+\n+                if name_bindings.defined_in_namespace_with(namespace, modifier) {\n                     let namespace_name = match namespace {\n                         TypeNS => \"type\",\n                         ValueNS => \"value\",\n@@ -914,7 +916,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                        import_span: Span,\n                                        name: Name,\n                                        namespace: Namespace) {\n-        if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n+        if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);"}, {"sha": "b44ccec0127bd7f864b387e6d24ae216667a933b", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -39,13 +39,13 @@ pub fn split_stack(val: ValueRef, set: bool) {\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n-        Hint   => llvm::SetFunctionAttribute(val, llvm::InlineHintAttribute),\n-        Always => llvm::SetFunctionAttribute(val, llvm::AlwaysInlineAttribute),\n-        Never  => llvm::SetFunctionAttribute(val, llvm::NoInlineAttribute),\n+        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHintAttribute),\n+        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInlineAttribute),\n+        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInlineAttribute),\n         None   => {\n-            let attr = llvm::InlineHintAttribute |\n-                       llvm::AlwaysInlineAttribute |\n-                       llvm::NoInlineAttribute;\n+            let attr = llvm::Attribute::InlineHintAttribute |\n+                       llvm::Attribute::AlwaysInlineAttribute |\n+                       llvm::Attribute::NoInlineAttribute;\n             unsafe {\n                 llvm::LLVMRemoveFunctionAttr(val, attr.bits() as c_ulonglong)\n             }\n@@ -57,10 +57,13 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n #[inline]\n pub fn emit_uwtable(val: ValueRef, emit: bool) {\n     if emit {\n-        llvm::SetFunctionAttribute(val, llvm::UWTableAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTableAttribute);\n     } else {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::UWTableAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::UWTableAttribute.bits() as c_ulonglong,\n+            );\n         }\n     }\n }\n@@ -71,10 +74,13 @@ pub fn emit_uwtable(val: ValueRef, emit: bool) {\n pub fn unwind(val: ValueRef, can_unwind: bool) {\n     if can_unwind {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::NoUnwindAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::NoUnwindAttribute.bits() as c_ulonglong,\n+            );\n         }\n     } else {\n-        llvm::SetFunctionAttribute(val, llvm::NoUnwindAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwindAttribute);\n     }\n }\n \n@@ -83,10 +89,13 @@ pub fn unwind(val: ValueRef, can_unwind: bool) {\n #[allow(dead_code)] // possibly useful function\n pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n     if optimize {\n-        llvm::SetFunctionAttribute(val, llvm::OptimizeForSizeAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSizeAttribute);\n     } else {\n         unsafe {\n-            llvm::LLVMRemoveFunctionAttr(val, llvm::OptimizeForSizeAttribute.bits() as c_ulonglong);\n+            llvm::LLVMRemoveFunctionAttr(\n+                val,\n+                llvm::Attribute::OptimizeForSizeAttribute.bits() as c_ulonglong,\n+            );\n         }\n     }\n }\n@@ -107,7 +116,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n                                                llvm::ColdAttribute as u64)\n             }\n         } else if attr.check_name(\"allocator\") {\n-            llvm::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+            llvm::Attribute::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n         }\n     }\n }\n@@ -176,9 +185,9 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // The outptr can be noalias and nocapture because it's entirely\n             // invisible to the program. We also know it's nonnull as well\n             // as how many bytes we can dereference\n-            attrs.arg(1, llvm::StructRetAttribute)\n-                 .arg(1, llvm::NoAliasAttribute)\n-                 .arg(1, llvm::NoCaptureAttribute)\n+            attrs.arg(1, llvm::Attribute::StructRetAttribute)\n+                 .arg(1, llvm::Attribute::NoAliasAttribute)\n+                 .arg(1, llvm::Attribute::NoCaptureAttribute)\n                  .arg(1, llvm::DereferenceableAttribute(llret_sz));\n \n             // Add one more since there's an outptr\n@@ -190,7 +199,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n-                    attrs.ret(llvm::NoAliasAttribute);\n+                    attrs.ret(llvm::Attribute::NoAliasAttribute);\n                 }\n                 _ => {}\n             }\n@@ -207,7 +216,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             }\n \n             if let ty::ty_bool = ret_ty.sty {\n-                attrs.ret(llvm::ZExtAttribute);\n+                attrs.ret(llvm::Attribute::ZExtAttribute);\n             }\n         }\n     }\n@@ -221,20 +230,20 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n-                     .arg(idx, llvm::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n+                     .arg(idx, llvm::Attribute::NoCaptureAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n             }\n \n             ty::ty_bool => {\n-                attrs.arg(idx, llvm::ZExtAttribute);\n+                attrs.arg(idx, llvm::Attribute::ZExtAttribute);\n             }\n \n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(inner) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n \n-                attrs.arg(idx, llvm::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n \n@@ -247,23 +256,23 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                                   !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n \n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n \n                 if mt.mutbl == ast::MutImmutable {\n-                    attrs.arg(idx, llvm::ReadOnlyAttribute);\n+                    attrs.arg(idx, llvm::Attribute::ReadOnlyAttribute);\n                 }\n \n                 if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::NoCaptureAttribute);\n+                    attrs.arg(idx, llvm::Attribute::NoCaptureAttribute);\n                 }\n             }\n \n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n             ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoCaptureAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n "}, {"sha": "2eef678673987dc8ee28cbfdfa57fe469e776f9b", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -164,7 +163,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n@@ -186,12 +185,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {"}, {"sha": "689b3b3ad37eef5695cc2f02a75c04b40b1327ba", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_upper_case_globals)]\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -132,7 +131,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let size = ty_size(ty, align_fn);\n@@ -146,12 +145,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let align = align_fn(ty);"}, {"sha": "2e899f72979d7e491233dbff117ea88e163e624a", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -13,8 +13,7 @@\n use libc::c_uint;\n use std::cmp;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector, Attribute};\n use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -89,10 +88,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n     }\n }\n \n@@ -106,7 +105,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "eae2378a2c518e0fd970a7495ea975bec4d1d4c2", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -10,8 +10,7 @@\n \n use libc::c_uint;\n use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n-use llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array, Attribute};\n use trans::cabi::{FnType, ArgType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -85,10 +84,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n     }\n }\n \n@@ -102,7 +101,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "d9c265d94a793e8f92c534e6d334ee2035e8f4e9", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -52,11 +52,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 ret_ty = ArgType::direct(rty, Some(t), None, None);\n             }\n             RetPointer => {\n-                ret_ty = ArgType::indirect(rty, Some(StructRetAttribute));\n+                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRetAttribute));\n             }\n         }\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -67,11 +67,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 if size == 0 {\n                     ArgType::ignore(t)\n                 } else {\n-                    ArgType::indirect(t, Some(ByValAttribute))\n+                    ArgType::indirect(t, Some(Attribute::ByValAttribute))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "d954a861a7267390256e87685d1abef932e22074", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -16,7 +16,6 @@ use self::RegClass::*;\n \n use llvm::{Integer, Pointer, Float, Double};\n use llvm::{Struct, Array, Attribute, Vector};\n-use llvm::{StructRetAttribute, ByValAttribute, ZExtAttribute};\n use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n@@ -407,19 +406,19 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                                 None)\n             }\n         } else {\n-            let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n             ArgType::direct(ty, None, None, attr)\n         }\n     }\n \n     let mut arg_tys = Vec::new();\n     for t in atys {\n-        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), ByValAttribute);\n+        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), Attribute::ByValAttribute);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), StructRetAttribute)\n+        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), Attribute::StructRetAttribute)\n     } else {\n         ArgType::direct(Type::void(ccx), None, None, None)\n     };"}, {"sha": "7808b9d27feead1a39005e8bc6e3a2b120719768", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -31,10 +31,10 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n             4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n             8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-            _ => ArgType::indirect(rty, Some(StructRetAttribute))\n+            _ => ArgType::indirect(rty, Some(Attribute::StructRetAttribute))\n         };\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -46,11 +46,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                     2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n                     4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n                     8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-                    _ => ArgType::indirect(t, Some(ByValAttribute))\n+                    _ => ArgType::indirect(t, Some(Attribute::ByValAttribute))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "3aaf4addd89626fc8d99540832099e0198fef317", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -186,7 +186,7 @@ fn get_const_val(ccx: &CrateContext,\n                  ref_expr: &ast::Expr) -> ValueRef {\n     let expr = get_const_expr(ccx, def_id, ref_expr);\n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-    get_const_expr_as_global(ccx, expr, check_const::PURE_CONST, empty_substs)\n+    get_const_expr_as_global(ccx, expr, check_const::ConstQualif::PURE_CONST, empty_substs)\n }\n \n pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -215,7 +215,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Some(&val) => return val,\n         None => {}\n     }\n-    let val = if qualif.intersects(check_const::NON_STATIC_BORROWS) {\n+    let val = if qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS) {\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n         let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,"}, {"sha": "35946491ba17693f99d66b4d1aca6d87b6c78c10", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -71,12 +71,12 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     llvm::SetUnnamedAddr(llfn, true);\n \n     if output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoReturnAttribute);\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturnAttribute);\n     }\n \n     if ccx.tcx().sess.opts.cg.no_redzone\n         .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::NoRedZoneAttribute)\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZoneAttribute)\n     }\n \n     if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {"}, {"sha": "f5ee44d69cc6353b1cf8e66d29eb89d59f289dc3", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -126,8 +126,11 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n-        if !qualif.intersects(check_const::PREFER_IN_PLACE) {\n+    if !qualif.intersects(\n+        check_const::ConstQualif::NOT_CONST |\n+        check_const::ConstQualif::NEEDS_DROP\n+    ) {\n+        if !qualif.intersects(check_const::ConstQualif::PREFER_IN_PLACE) {\n             if let SaveIn(lldest) = dest {\n                 let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n                                                             bcx.fcx.param_substs);\n@@ -209,12 +212,15 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n     let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n-    let adjusted_global = !qualif.intersects(check_const::NON_STATIC_BORROWS);\n-    let global = if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n+    let adjusted_global = !qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS);\n+    let global = if !qualif.intersects(\n+        check_const::ConstQualif::NOT_CONST |\n+        check_const::ConstQualif::NEEDS_DROP\n+    ) {\n         let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n                                                       bcx.fcx.param_substs);\n \n-        if qualif.intersects(check_const::HAS_STATIC_BORROWS) {\n+        if qualif.intersects(check_const::ConstQualif::HAS_STATIC_BORROWS) {\n             // Is borrowed as 'static, must return lvalue.\n \n             // Cast pointer to global, because constants have different types."}, {"sha": "d760b2c52ca1b0217d14137f00ace8b5488fc193", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -349,8 +349,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We also know it's nonnull as well\n         // as how many bytes we can dereference\n-        attrs.arg(1, llvm::NoAliasAttribute)\n-             .arg(1, llvm::NoCaptureAttribute)\n+        attrs.arg(1, llvm::Attribute::NoAliasAttribute)\n+             .arg(1, llvm::Attribute::NoCaptureAttribute)\n              .arg(1, llvm::DereferenceableAttribute(llret_sz));\n     };\n "}, {"sha": "6a84c6ace47b4d397875b8deab57a042e1196950", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -107,26 +107,27 @@\n #![doc(test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n #![feature(alloc)]\n+#![feature(allow_internal_unstable)]\n+#![feature(associated_consts)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(debug_builders)]\n+#![feature(into_cow)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n+#![feature(macro_reexport)]\n #![feature(optin_builtin_traits)]\n #![feature(rand)]\n+#![feature(slice_patterns)]\n #![feature(staged_api)]\n+#![feature(std_misc)]\n+#![feature(str_char)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n-#![feature(unsafe_no_drop_flag, filling_drop)]\n-#![feature(macro_reexport)]\n #![feature(unique)]\n-#![feature(allow_internal_unstable)]\n-#![feature(str_char)]\n-#![feature(into_cow)]\n-#![feature(std_misc)]\n-#![feature(slice_patterns)]\n-#![feature(debug_builders)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(zero_one)]\n #![cfg_attr(test, feature(float_from_str_radix))]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n@@ -307,13 +308,12 @@ mod std {\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n-    pub use option; // used for bitflags!{}\n+    pub use option; // used for thread_local!{}\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]\n     pub use cell; // used for tls!\n     pub use thread; // used for thread_local!\n     pub use marker;  // used for tls!\n-    pub use ops; // used for bitflags!\n \n     // The test runner calls ::std::env::args() but really wants realstd\n     #[cfg(test)] pub use realstd::env as env;"}, {"sha": "c22fba658373a7d64abce8d017c2d5cb90806bab", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -25,13 +25,14 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![feature(associated_consts)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(libc)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(unicode)]\n #![feature(str_char)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "5f76c21492707c30c985fb28bb6160702f4726f4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2edb6438cb83c144f0ce480a47975043bbee2d4b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2edb6438cb83c144f0ce480a47975043bbee2d4b", "patch": "@@ -88,9 +88,9 @@ use std::slice;\n \n bitflags! {\n     flags Restrictions: u8 {\n-        const UNRESTRICTED                  = 0b0000,\n-        const RESTRICTION_STMT_EXPR         = 0b0001,\n-        const RESTRICTION_NO_STRUCT_LITERAL = 0b0010,\n+        const UNRESTRICTED                  = 0,\n+        const RESTRICTION_STMT_EXPR         = 1 << 0,\n+        const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n     }\n }\n \n@@ -339,7 +339,7 @@ impl<'a> Parser<'a> {\n             buffer_start: 0,\n             buffer_end: 0,\n             tokens_consumed: 0,\n-            restrictions: UNRESTRICTED,\n+            restrictions: Restrictions::UNRESTRICTED,\n             quote_depth: 0,\n             obsolete_set: HashSet::new(),\n             mod_path_stack: Vec::new(),\n@@ -2198,7 +2198,10 @@ impl<'a> Parser<'a> {\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n-                        if !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL) {\n+                        let prohibited = self.restrictions.contains(\n+                            Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+                        );\n+                        if !prohibited {\n                             // It's a struct literal.\n                             try!(self.bump());\n                             let mut fields = Vec::new();\n@@ -2759,7 +2762,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_assign_expr_with(&mut self, lhs: P<Expr>) -> PResult<P<Expr>> {\n-        let restrictions = self.restrictions & RESTRICTION_NO_STRUCT_LITERAL;\n+        let restrictions = self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL;\n         let op_span = self.span;\n         match self.token {\n           token::Eq => {\n@@ -2814,7 +2817,7 @@ impl<'a> Parser<'a> {\n         if self.token.can_begin_expr() {\n             // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n             if self.token == token::OpenDelim(token::Brace) {\n-                return !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL);\n+                return !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL);\n             }\n             true\n         } else {\n@@ -2828,7 +2831,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_let_expr();\n         }\n         let lo = self.last_span.lo;\n-        let cond = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let thn = try!(self.parse_block());\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n@@ -2846,7 +2849,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat_nopanic());\n         try!(self.expect(&token::Eq));\n-        let expr = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let thn = try!(self.parse_block());\n         let (hi, els) = if try!(self.eat_keyword(keywords::Else) ){\n             let expr = try!(self.parse_else_expr());\n@@ -2905,7 +2908,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let pat = try!(self.parse_pat_nopanic());\n         try!(self.expect_keyword(keywords::In));\n-        let expr = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let loop_block = try!(self.parse_block());\n         let hi = self.last_span.hi;\n \n@@ -2918,7 +2921,7 @@ impl<'a> Parser<'a> {\n             return self.parse_while_let_expr(opt_ident);\n         }\n         let lo = self.last_span.lo;\n-        let cond = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let body = try!(self.parse_block());\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(lo, hi, ExprWhile(cond, body, opt_ident)));\n@@ -2930,7 +2933,7 @@ impl<'a> Parser<'a> {\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat_nopanic());\n         try!(self.expect(&token::Eq));\n-        let expr = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         let body = try!(self.parse_block());\n         let hi = body.span.hi;\n         return Ok(self.mk_expr(lo, hi, ExprWhileLet(pat, expr, body, opt_ident)));\n@@ -2945,7 +2948,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_match_expr(&mut self) -> PResult<P<Expr>> {\n         let lo = self.last_span.lo;\n-        let discriminant = try!(self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL));\n+        let discriminant = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n         try!(self.commit_expr_expecting(&*discriminant, token::OpenDelim(token::Brace)));\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n@@ -2966,7 +2969,7 @@ impl<'a> Parser<'a> {\n             guard = Some(try!(self.parse_expr_nopanic()));\n         }\n         try!(self.expect(&token::FatArrow));\n-        let expr = try!(self.parse_expr_res(RESTRICTION_STMT_EXPR));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n@@ -2988,7 +2991,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr_nopanic(&mut self) -> PResult<P<Expr>> {\n-        return self.parse_expr_res(UNRESTRICTED);\n+        return self.parse_expr_res(Restrictions::UNRESTRICTED);\n     }\n \n     /// Parse an expression, subject to the given restrictions\n@@ -3564,7 +3567,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     // Remainder are line-expr stmts.\n-                    let e = try!(self.parse_expr_res(RESTRICTION_STMT_EXPR));\n+                    let e = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n                     spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID))\n                 }\n             }\n@@ -3573,7 +3576,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restrictions.contains(RESTRICTION_STMT_EXPR) &&\n+        self.restrictions.contains(Restrictions::RESTRICTION_STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}]}