{"sha": "43874a2ee749c2dd9f052172341f2f87fa36cd79", "node_id": "C_kwDOAAsO6NoAKDQzODc0YTJlZTc0OWMyZGQ5ZjA1MjE3MjM0MWYyZjg3ZmEzNmNkNzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-04T23:14:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-04T23:14:09Z"}, "message": "Auto merge of #97742 - matthiaskrgr:rollup-fr3j0t8, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #97609 (Iterate over `maybe_unused_trait_imports` when checking dead trait imports)\n - #97688 (test const_copy to make sure bytewise pointer copies are working)\n - #97707 (Improve soundness of rustc_data_structures)\n - #97731 (Add regresion test for #87142)\n - #97735 (Don't generate \"Impls on Foreign Types\" for std)\n - #97737 (Fix pretty printing named bound regions under -Zverbose)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d4d0186c548df3f4fe7e6330e25bcf5b95d434e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4d0186c548df3f4fe7e6330e25bcf5b95d434e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43874a2ee749c2dd9f052172341f2f87fa36cd79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43874a2ee749c2dd9f052172341f2f87fa36cd79", "html_url": "https://github.com/rust-lang/rust/commit/43874a2ee749c2dd9f052172341f2f87fa36cd79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43874a2ee749c2dd9f052172341f2f87fa36cd79/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e725bad73747a4c93a3ac53106e4b4006edc665", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e725bad73747a4c93a3ac53106e4b4006edc665", "html_url": "https://github.com/rust-lang/rust/commit/4e725bad73747a4c93a3ac53106e4b4006edc665"}, {"sha": "1794309e0aa451e63d74511d4af595a5bcd0f685", "url": "https://api.github.com/repos/rust-lang/rust/commits/1794309e0aa451e63d74511d4af595a5bcd0f685", "html_url": "https://github.com/rust-lang/rust/commit/1794309e0aa451e63d74511d4af595a5bcd0f685"}], "stats": {"total": 239, "additions": 162, "deletions": 77}, "files": [{"sha": "2be2f0532c99ca321ff590931fadb700ce0bc5ef", "filename": "compiler/rustc_data_structures/src/base_n/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n%2Ftests.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -15,7 +15,9 @@ fn test_encode() {\n         test(u64::MAX as u128, base);\n         test(u128::MAX, base);\n \n-        for i in 0..1_000 {\n+        const N: u128 = if cfg!(miri) { 10 } else { 1000 };\n+\n+        for i in 0..N {\n             test(i * 983, base);\n         }\n     }"}, {"sha": "9940fee60d7d8209a56a988a0bb52278d434302b", "filename": "compiler/rustc_data_structures/src/graph/scc/tests.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -156,7 +156,10 @@ fn test_deep_linear() {\n     v\n     \u2026\n      */\n+    #[cfg(not(miri))]\n     const NR_NODES: usize = 1 << 14;\n+    #[cfg(miri)]\n+    const NR_NODES: usize = 1 << 3;\n     let mut nodes = vec![];\n     for i in 1..NR_NODES {\n         nodes.push((i - 1, i));"}, {"sha": "320c03d5139f4ba0985dbaae066f61c3b92c0fe8", "filename": "compiler/rustc_data_structures/src/owning_ref/tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -1,3 +1,5 @@\n+// FIXME: owning_ref is not sound under stacked borrows. Preferably, get rid of it.\n+#[cfg(not(miri))]\n mod owning_ref {\n     use super::super::OwningRef;\n     use super::super::{BoxRef, Erased, ErasedBoxRef, RcRef};\n@@ -361,6 +363,8 @@ mod owning_handle {\n     }\n }\n \n+// FIXME: owning_ref is not sound under stacked borrows. Preferably, get rid of it.\n+#[cfg(not(miri))]\n mod owning_ref_mut {\n     use super::super::BoxRef;\n     use super::super::{BoxRefMut, Erased, ErasedBoxRefMut, OwningRefMut};"}, {"sha": "90793a97ed0d894d5422403ea241a1d8db7072c7", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -255,8 +255,9 @@ impl SipHasher128 {\n         // elements from spill (at most LEN - 1 bytes could have overflowed\n         // into the spill). The memcpy call is optimized away because the size\n         // is known. And the whole copy is optimized away for LEN == 1.\n+        let dst = self.buf.as_mut_ptr() as *mut u8;\n         let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;\n-        ptr::copy_nonoverlapping(src, self.buf.as_mut_ptr() as *mut u8, LEN - 1);\n+        ptr::copy_nonoverlapping(src, dst, LEN - 1);\n \n         // This function should only be called when the write fills the buffer.\n         // Therefore, when LEN == 1, the new `self.nbuf` must be zero."}, {"sha": "24531e461896be80703ba4101f824f975bfa5281", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -1728,8 +1728,8 @@ rustc_queries! {\n     query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n         desc { |tcx| \"collecting upvars mentioned in `{}`\", tcx.def_path_str(def_id) }\n     }\n-    query maybe_unused_trait_import(def_id: LocalDefId) -> bool {\n-        desc { |tcx| \"maybe_unused_trait_import for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n+    query maybe_unused_trait_imports(_: ()) -> &'tcx FxIndexSet<LocalDefId> {\n+        desc { \"fetching potentially unused trait imports\" }\n     }\n     query maybe_unused_extern_crates(_: ()) -> &'tcx [(LocalDefId, Span)] {\n         desc { \"looking up all possibly unused extern crates\" }"}, {"sha": "ac71146303ac2940007b4765dcb3683ba6f0f5f6", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -2893,8 +2893,8 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name\n     };\n-    providers.maybe_unused_trait_import =\n-        |tcx, id| tcx.resolutions(()).maybe_unused_trait_imports.contains(&id);\n+    providers.maybe_unused_trait_imports =\n+        |tcx, ()| &tcx.resolutions(()).maybe_unused_trait_imports;\n     providers.maybe_unused_extern_crates =\n         |tcx, ()| &tcx.resolutions(()).maybe_unused_extern_crates[..];\n     providers.names_imported_by_glob_use = |tcx, id| {"}, {"sha": "3a2d3408b9d9365325e793afd223604ccc90ee2c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -28,7 +28,7 @@ pub use generics::*;\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n@@ -138,7 +138,7 @@ pub struct ResolverOutputs {\n     pub has_pub_restricted: bool,\n     pub access_levels: AccessLevels,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n-    pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n+    pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n     pub reexport_map: FxHashMap<LocalDefId, Vec<ModChild>>,\n     pub glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,"}, {"sha": "08879afa64a0ebaa601d0e5e24e2a9a1fbd27a51", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -2190,34 +2190,40 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         // this is not *quite* right and changes the ordering of some output\n         // anyways.\n         let (new_value, map) = if self.tcx().sess.verbose() {\n-            // anon index + 1 (BrEnv takes 0) -> name\n-            let mut region_map: FxHashMap<_, _> = Default::default();\n-            let bound_vars = value.bound_vars();\n-            for var in bound_vars {\n-                let ty::BoundVariableKind::Region(var) = var else { continue };\n-                match var {\n-                    ty::BrAnon(_) | ty::BrEnv => {\n-                        start_or_continue(&mut self, \"for<\", \", \");\n-                        let name = next_name(&self);\n-                        do_continue(&mut self, name);\n-                        region_map.insert(var, ty::BrNamed(CRATE_DEF_ID.to_def_id(), name));\n-                    }\n-                    ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n-                        start_or_continue(&mut self, \"for<\", \", \");\n-                        let name = next_name(&self);\n-                        do_continue(&mut self, name);\n-                        region_map.insert(var, ty::BrNamed(def_id, name));\n-                    }\n-                    ty::BrNamed(_, name) => {\n-                        start_or_continue(&mut self, \"for<\", \", \");\n-                        do_continue(&mut self, name);\n+            let regions: Vec<_> = value\n+                .bound_vars()\n+                .into_iter()\n+                .map(|var| {\n+                    let ty::BoundVariableKind::Region(var) = var else {\n+                    // This doesn't really matter because it doesn't get used,\n+                    // it's just an empty value\n+                    return ty::BrAnon(0);\n+                };\n+                    match var {\n+                        ty::BrAnon(_) | ty::BrEnv => {\n+                            start_or_continue(&mut self, \"for<\", \", \");\n+                            let name = next_name(&self);\n+                            do_continue(&mut self, name);\n+                            ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n+                        }\n+                        ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n+                            start_or_continue(&mut self, \"for<\", \", \");\n+                            let name = next_name(&self);\n+                            do_continue(&mut self, name);\n+                            ty::BrNamed(def_id, name)\n+                        }\n+                        ty::BrNamed(def_id, name) => {\n+                            start_or_continue(&mut self, \"for<\", \", \");\n+                            do_continue(&mut self, name);\n+                            ty::BrNamed(def_id, name)\n+                        }\n                     }\n-                }\n-            }\n+                })\n+                .collect();\n             start_or_continue(&mut self, \"\", \"> \");\n \n             self.tcx.replace_late_bound_regions(value.clone(), |br| {\n-                let kind = region_map[&br.kind];\n+                let kind = regions[br.var.as_usize()];\n                 self.tcx.mk_region(ty::ReLateBound(\n                     ty::INNERMOST,\n                     ty::BoundRegion { var: br.var, kind },"}, {"sha": "59794c4d3f0d83adc9814608ef1017efa5bdd185", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -37,7 +37,7 @@ use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, T\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;"}, {"sha": "49c15d2c9ef1f7be31c42a28a41d95c70b921db1", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -28,7 +28,7 @@ use rustc_ast::node_id::NodeMap;\n use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_ast_lowering::{LifetimeRes, ResolverAstLowering};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n@@ -941,7 +941,7 @@ pub struct Resolver<'a> {\n     visibilities: FxHashMap<LocalDefId, ty::Visibility>,\n     has_pub_restricted: bool,\n     used_imports: FxHashSet<NodeId>,\n-    maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n+    maybe_unused_trait_imports: FxIndexSet<LocalDefId>,\n     maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n \n     /// Privacy errors are delayed until the end in order to deduplicate them."}, {"sha": "f28184c74d35548518765421a2f957972b580137", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -16,48 +16,32 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n         used_trait_imports.extend(imports.iter());\n     }\n \n-    for id in tcx.hir().items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::Use) {\n-            if tcx.visibility(id.def_id).is_public() {\n-                continue;\n-            }\n-            let item = tcx.hir().item(id);\n-            if item.span.is_dummy() {\n-                continue;\n-            }\n-            if let hir::ItemKind::Use(path, _) = item.kind {\n-                check_import(tcx, &mut used_trait_imports, item.item_id(), path.span);\n-            }\n+    for &id in tcx.maybe_unused_trait_imports(()) {\n+        debug_assert_eq!(tcx.def_kind(id), DefKind::Use);\n+        if tcx.visibility(id).is_public() {\n+            continue;\n+        }\n+        if used_trait_imports.contains(&id) {\n+            continue;\n         }\n+        let item = tcx.hir().expect_item(id);\n+        if item.span.is_dummy() {\n+            continue;\n+        }\n+        let hir::ItemKind::Use(path, _) = item.kind else { unreachable!() };\n+        tcx.struct_span_lint_hir(lint::builtin::UNUSED_IMPORTS, item.hir_id(), path.span, |lint| {\n+            let msg = if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(path.span) {\n+                format!(\"unused import: `{}`\", snippet)\n+            } else {\n+                \"unused import\".to_owned()\n+            };\n+            lint.build(&msg).emit();\n+        });\n     }\n \n     unused_crates_lint(tcx);\n }\n \n-fn check_import<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    used_trait_imports: &mut FxHashSet<LocalDefId>,\n-    item_id: hir::ItemId,\n-    span: Span,\n-) {\n-    if !tcx.maybe_unused_trait_import(item_id.def_id) {\n-        return;\n-    }\n-\n-    if used_trait_imports.contains(&item_id.def_id) {\n-        return;\n-    }\n-\n-    tcx.struct_span_lint_hir(lint::builtin::UNUSED_IMPORTS, item_id.hir_id(), span, |lint| {\n-        let msg = if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n-            format!(\"unused import: `{}`\", snippet)\n-        } else {\n-            \"unused import\".to_owned()\n-        };\n-        lint.build(&msg).emit();\n-    });\n-}\n-\n fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n "}, {"sha": "9505ec31609f5a7ffcf6a07a157c71e129e3a58d", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -84,6 +84,7 @@\n #![feature(const_option)]\n #![feature(const_option_ext)]\n #![feature(const_result)]\n+#![feature(const_intrinsic_copy)]\n #![feature(integer_atomics)]\n #![feature(int_roundings)]\n #![feature(slice_group_by)]"}, {"sha": "40b2b49bdbd7d96c6dcbc6a144acf7d77abe1945", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -1,4 +1,5 @@\n use core::cell::RefCell;\n+use core::mem::{self, MaybeUninit};\n use core::num::NonZeroUsize;\n use core::ptr;\n use core::ptr::*;\n@@ -781,3 +782,42 @@ fn nonnull_tagged_pointer_with_provenance() {\n         }\n     }\n }\n+\n+#[test]\n+fn test_const_copy() {\n+    const {\n+        let ptr1 = &1;\n+        let mut ptr2 = &666;\n+\n+        // Copy ptr1 to ptr2, bytewise.\n+        unsafe {\n+            ptr::copy(\n+                &ptr1 as *const _ as *const MaybeUninit<u8>,\n+                &mut ptr2 as *mut _ as *mut MaybeUninit<u8>,\n+                mem::size_of::<&i32>(),\n+            );\n+        }\n+\n+        // Make sure they still work.\n+        assert!(*ptr1 == 1);\n+        assert!(*ptr2 == 1);\n+    };\n+\n+    const {\n+        let ptr1 = &1;\n+        let mut ptr2 = &666;\n+\n+        // Copy ptr1 to ptr2, bytewise.\n+        unsafe {\n+            ptr::copy_nonoverlapping(\n+                &ptr1 as *const _ as *const MaybeUninit<u8>,\n+                &mut ptr2 as *mut _ as *mut MaybeUninit<u8>,\n+                mem::size_of::<&i32>(),\n+            );\n+        }\n+\n+        // Make sure they still work.\n+        assert!(*ptr1 == 1);\n+        assert!(*ptr2 == 1);\n+    };\n+}"}, {"sha": "b236bd7be4f0c0eb9db8ccde0bf628071d3ca83a", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def_id::DefId;\n pub(crate) use renderer::{run_format, FormatRenderer};\n \n use crate::clean::{self, ItemId};\n-use cache::Cache;\n+use crate::html::render::Context;\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n@@ -65,7 +65,8 @@ impl Impl {\n     // Returns true if this is an implementation on a \"local\" type, meaning:\n     // the type is in the current crate, or the type and the trait are both\n     // re-exported by the current crate.\n-    pub(crate) fn is_on_local_type(&self, cache: &Cache) -> bool {\n+    pub(crate) fn is_on_local_type(&self, cx: &Context<'_>) -> bool {\n+        let cache = cx.cache();\n         let for_type = &self.inner_impl().for_;\n         if let Some(for_type_did) = for_type.def_id(cache) {\n             // The \"for\" type is local if it's in the paths for the current crate.\n@@ -80,6 +81,18 @@ impl Impl {\n                 if for_type_did.krate == trait_did.krate {\n                     return true;\n                 }\n+                // Hack: many traits and types in std are re-exported from\n+                // core or alloc. In general, rustdoc is capable of recognizing\n+                // these implementations as being on local types. However, in at\n+                // least one case (https://github.com/rust-lang/rust/issues/97610),\n+                // rustdoc gets confused and labels an implementation as being on\n+                // a foreign type. To make sure that confusion doesn't pass on to\n+                // the reader, consider all implementations in std, core, and alloc\n+                // to be on local types.\n+                let crate_name = cx.tcx().crate_name(trait_did.krate);\n+                if matches!(crate_name.as_str(), \"std\" | \"core\" | \"alloc\") {\n+                    return true;\n+                }\n             }\n             return false;\n         };"}, {"sha": "23ce634cf286ba839680ef3291abbba78ae2e74e", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -2281,11 +2281,10 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::Method),\n     );\n \n-    let cache = cx.cache();\n-    if let Some(implementors) = cache.implementors.get(&it.item_id.expect_def_id()) {\n+    if let Some(implementors) = cx.cache().implementors.get(&it.item_id.expect_def_id()) {\n         let mut res = implementors\n             .iter()\n-            .filter(|i| !i.is_on_local_type(cache))\n+            .filter(|i| !i.is_on_local_type(cx))\n             .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n             .collect::<Vec<_>>();\n "}, {"sha": "d115185562ce44344ad2cb87265f4b82618480a8", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -823,7 +823,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         }\n \n         let (local, foreign) =\n-            implementors.iter().partition::<Vec<_>, _>(|i| i.is_on_local_type(cache));\n+            implementors.iter().partition::<Vec<_>, _>(|i| i.is_on_local_type(cx));\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             local.iter().partition(|i| i.inner_impl().kind.is_auto());"}, {"sha": "fc10d04d46cfb856e10a40301517a41b8e1482b4", "filename": "src/test/ui/generator/issue-87142.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43874a2ee749c2dd9f052172341f2f87fa36cd79/src%2Ftest%2Fui%2Fgenerator%2Fissue-87142.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43874a2ee749c2dd9f052172341f2f87fa36cd79/src%2Ftest%2Fui%2Fgenerator%2Fissue-87142.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-87142.rs?ref=43874a2ee749c2dd9f052172341f2f87fa36cd79", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: -Cdebuginfo=2\n+// build-pass\n+\n+// Regression test for #87142\n+// This test needs the above flags and the \"lib\" crate type.\n+\n+#![feature(type_alias_impl_trait, generator_trait, generators)]\n+#![crate_type = \"lib\"]\n+\n+use std::ops::Generator;\n+\n+pub trait GeneratorProviderAlt: Sized {\n+    type Gen: Generator<(), Return = (), Yield = ()>;\n+\n+    fn start(ctx: Context<Self>) -> Self::Gen;\n+}\n+\n+pub struct Context<G: 'static + GeneratorProviderAlt> {\n+    pub link: Box<G::Gen>,\n+}\n+\n+impl GeneratorProviderAlt for () {\n+    type Gen = impl Generator<(), Return = (), Yield = ()>;\n+    fn start(ctx: Context<Self>) -> Self::Gen {\n+        move || {\n+            match ctx {\n+                _ => (),\n+            }\n+            yield ();\n+        }\n+    }\n+}"}]}