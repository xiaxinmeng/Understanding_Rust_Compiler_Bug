{"sha": "881c29192d39f657bf518baf399c47a5bfdc922f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MWMyOTE5MmQzOWY2NTdiZjUxOGJhZjM5OWM0N2E1YmZkYzkyMmY=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-17T19:13:54Z"}, "committer": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-25T18:55:05Z"}, "message": "initial newline translation working\ntodo:\ncleanup, simplify\nhandle columns", "tree": {"sha": "bdcdfce03ec705d8f05e43da5c7576c42ae74e5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdcdfce03ec705d8f05e43da5c7576c42ae74e5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/881c29192d39f657bf518baf399c47a5bfdc922f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/881c29192d39f657bf518baf399c47a5bfdc922f", "html_url": "https://github.com/rust-lang/rust/commit/881c29192d39f657bf518baf399c47a5bfdc922f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/881c29192d39f657bf518baf399c47a5bfdc922f/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9519791590170fd77aa45cc9a802539eaf16efc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9519791590170fd77aa45cc9a802539eaf16efc", "html_url": "https://github.com/rust-lang/rust/commit/d9519791590170fd77aa45cc9a802539eaf16efc"}], "stats": {"total": 276, "additions": 262, "deletions": 14}, "files": [{"sha": "7eddfd502528e8cba3cac7538cad160d9bf3d087", "filename": "crates/ra_editor/src/line_index.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/881c29192d39f657bf518baf399c47a5bfdc922f/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881c29192d39f657bf518baf399c47a5bfdc922f/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index.rs?ref=881c29192d39f657bf518baf399c47a5bfdc922f", "patch": "@@ -1,4 +1,4 @@\n-use crate::TextUnit;\n+use crate::{TextUnit, TextRange};\n use rustc_hash::FxHashMap;\n use superslice::Ext;\n \n@@ -120,6 +120,10 @@ impl LineIndex {\n \n         col\n     }\n+\n+    pub fn newlines(&self) -> &[TextUnit] {\n+        &self.newlines[1..]\n+    }\n }\n \n #[test]"}, {"sha": "6d0ebbcd965952a461c9b63105da46e301297330", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 257, "deletions": 13, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/881c29192d39f657bf518baf399c47a5bfdc922f/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881c29192d39f657bf518baf399c47a5bfdc922f/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=881c29192d39f657bf518baf399c47a5bfdc922f", "patch": "@@ -296,6 +296,202 @@ fn translate_offset_with_edit(\n     }\n }\n \n+#[derive(Debug)]\n+struct OffsetNewlineIter<'a> {\n+    text: &'a str,\n+    offset: TextUnit,\n+}\n+\n+impl<'a> Iterator for OffsetNewlineIter<'a> {\n+    type Item = TextUnit;\n+    fn next(&mut self) -> Option<TextUnit> {\n+        let next_idx = self\n+            .text\n+            .char_indices()\n+            .filter_map(|(i, c)| if c == '\\n' { Some(i + 1) } else { None })\n+            .next()?;\n+        let next = self.offset + TextUnit::from_usize(next_idx);\n+        self.text = &self.text[next_idx..];\n+        self.offset = next;\n+        Some(next)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+enum TranslatedPos {\n+    Before,\n+    After,\n+}\n+\n+/// None means it was deleted\n+type TranslatedOffset = Option<(TranslatedPos, TextUnit)>;\n+\n+fn translate_offset(offset: TextUnit, edit: &TranslatedAtomEdit) -> TranslatedOffset {\n+    if offset <= edit.delete.start() {\n+        Some((TranslatedPos::Before, offset))\n+    } else if offset <= edit.delete.end() {\n+        None\n+    } else {\n+        let diff = edit.insert.len() as i64 - edit.delete.len().to_usize() as i64;\n+        let after = TextUnit::from((offset.to_usize() as i64 + diff) as u32);\n+        Some((TranslatedPos::After, after))\n+    }\n+}\n+\n+trait TranslatedNewlineIterator {\n+    fn translate(&self, offset: TextUnit) -> TextUnit;\n+    fn translate_range(&self, range: TextRange) -> TextRange {\n+        TextRange::from_to(self.translate(range.start()), self.translate(range.end()))\n+    }\n+    fn next_translated(&mut self) -> Option<TextUnit>;\n+    fn boxed<'a>(self) -> Box<TranslatedNewlineIterator + 'a>\n+    where\n+        Self: 'a + Sized,\n+    {\n+        Box::new(self)\n+    }\n+}\n+\n+struct TranslatedAtomEdit<'a> {\n+    delete: TextRange,\n+    insert: &'a str,\n+}\n+\n+struct TranslatedNewlines<'a, T: TranslatedNewlineIterator> {\n+    inner: T,\n+    next_inner: Option<TranslatedOffset>,\n+    edit: TranslatedAtomEdit<'a>,\n+    insert: OffsetNewlineIter<'a>,\n+}\n+\n+impl<'a, T: TranslatedNewlineIterator> TranslatedNewlines<'a, T> {\n+    fn from(inner: T, edit: &'a AtomTextEdit) -> Self {\n+        let delete = inner.translate_range(edit.delete);\n+        let mut res = TranslatedNewlines {\n+            inner,\n+            next_inner: None,\n+            edit: TranslatedAtomEdit {\n+                delete,\n+                insert: &edit.insert,\n+            },\n+            insert: OffsetNewlineIter {\n+                offset: delete.start(),\n+                text: &edit.insert,\n+            },\n+        };\n+        // prepare next_inner\n+        res.advance_inner();\n+        res\n+    }\n+\n+    fn advance_inner(&mut self) {\n+        self.next_inner = self\n+            .inner\n+            .next_translated()\n+            .map(|x| translate_offset(x, &self.edit));\n+    }\n+}\n+\n+impl<'a, T: TranslatedNewlineIterator> TranslatedNewlineIterator for TranslatedNewlines<'a, T> {\n+    fn translate(&self, offset: TextUnit) -> TextUnit {\n+        let offset = self.inner.translate(offset);\n+        let (_, offset) =\n+            translate_offset(offset, &self.edit).expect(\"translate_unit returned None\");\n+        offset\n+    }\n+\n+    fn next_translated(&mut self) -> Option<TextUnit> {\n+        match self.next_inner {\n+            None => self.insert.next(),\n+            Some(next) => match next {\n+                None => self.insert.next().or_else(|| {\n+                    self.advance_inner();\n+                    self.next_translated()\n+                }),\n+                Some((TranslatedPos::Before, next)) => {\n+                    self.advance_inner();\n+                    Some(next)\n+                }\n+                Some((TranslatedPos::After, next)) => self.insert.next().or_else(|| {\n+                    self.advance_inner();\n+                    Some(next)\n+                }),\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for Box<dyn TranslatedNewlineIterator + 'a> {\n+    type Item = TextUnit;\n+    fn next(&mut self) -> Option<TextUnit> {\n+        self.next_translated()\n+    }\n+}\n+\n+impl<T: TranslatedNewlineIterator + ?Sized> TranslatedNewlineIterator for Box<T> {\n+    fn translate(&self, offset: TextUnit) -> TextUnit {\n+        self.as_ref().translate(offset)\n+    }\n+    fn next_translated(&mut self) -> Option<TextUnit> {\n+        self.as_mut().next_translated()\n+    }\n+}\n+\n+struct IteratorWrapper<T: Iterator<Item = TextUnit>>(T);\n+\n+impl<T: Iterator<Item = TextUnit>> TranslatedNewlineIterator for IteratorWrapper<T> {\n+    fn translate(&self, offset: TextUnit) -> TextUnit {\n+        offset\n+    }\n+    fn next_translated(&mut self) -> Option<TextUnit> {\n+        self.0.next()\n+    }\n+}\n+\n+impl<T: Iterator<Item = TextUnit>> Iterator for IteratorWrapper<T> {\n+    type Item = TextUnit;\n+    fn next(&mut self) -> Option<TextUnit> {\n+        self.0.next()\n+    }\n+}\n+\n+fn translate_newlines<'a>(\n+    mut newlines: Box<TranslatedNewlineIterator + 'a>,\n+    edits: &'a [AtomTextEdit],\n+) -> Box<TranslatedNewlineIterator + 'a> {\n+    for edit in edits {\n+        newlines = TranslatedNewlines::from(newlines, edit).boxed();\n+    }\n+    newlines\n+}\n+\n+#[allow(dead_code)]\n+fn translate_offset_with_edit_fast(\n+    pre_edit_index: &LineIndex,\n+    offset: TextUnit,\n+    edits: &[AtomTextEdit],\n+) -> LineCol {\n+    // println!(\"{:?}\", pre_edit_index.newlines());\n+    let mut newlines: Box<TranslatedNewlineIterator> = Box::new(IteratorWrapper(\n+        pre_edit_index.newlines().iter().map(|x| *x),\n+    ));\n+\n+    newlines = translate_newlines(newlines, edits);\n+\n+    let mut line = 0;\n+    for n in newlines {\n+        if n > offset {\n+            break;\n+        }\n+        line += 1;\n+    }\n+\n+    LineCol {\n+        line: line,\n+        col_utf16: 0,\n+    }\n+}\n+\n impl TryConvWith for SourceFileEdit {\n     type Ctx = ServerWorld;\n     type Output = TextDocumentEdit;\n@@ -414,36 +610,84 @@ mod test {\n             .boxed()\n     }\n \n-    fn translate_offset_with_edit_naive(\n-        pre_edit_text: String,\n-        offset: TextUnit,\n-        edits: &[AtomTextEdit],\n-    ) -> LineCol {\n+    fn edit_text(pre_edit_text: &str, mut edits: Vec<AtomTextEdit>) -> String {\n         // apply edits ordered from last to first\n         // since they should not overlap we can just use start()\n-        let mut edits: Vec<AtomTextEdit> = edits.to_vec();\n         edits.sort_by_key(|x| -(x.delete.start().to_usize() as isize));\n \n-        let mut text = pre_edit_text;\n+        let mut text = pre_edit_text.to_owned();\n \n         for edit in &edits {\n             let range = edit.delete.start().to_usize()..edit.delete.end().to_usize();\n             text.replace_range(range, &edit.insert);\n         }\n \n-        let line_index = LineIndex::new(&text);\n+        text\n+    }\n \n+    fn translate_after_edit(\n+        pre_edit_text: &str,\n+        offset: TextUnit,\n+        edits: Vec<AtomTextEdit>,\n+    ) -> LineCol {\n+        let text = edit_text(pre_edit_text, edits);\n+        let line_index = LineIndex::new(&text);\n         line_index.line_col(offset)\n     }\n \n     proptest! {\n         #[test]\n         fn test_translate_offset_with_edit(x in arb_text_with_offset_and_edits()) {\n-            if x.edits.len() <= 1 {\n-                let expected = translate_offset_with_edit_naive(x.text.clone(), x.offset, &x.edits);\n-                let actual = translate_offset_with_edit(&LineIndex::new(&x.text), x.offset, &x.edits);\n-                assert_eq!(actual, expected);\n-            }\n+            let line_index = LineIndex::new(&x.text);\n+            let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+            let actual = translate_offset_with_edit_fast(&line_index, x.offset, &x.edits);\n+            assert_eq!(actual.line, expected.line);\n         }\n     }\n+\n+    #[test]\n+    fn test_translate_offset_with_edit_1() {\n+        let x = ArbTextWithOffsetAndEdits {\n+            text: \"jbnan\".to_owned(),\n+            offset: 3.into(),\n+            edits: vec![\n+                AtomTextEdit::delete(TextRange::from_to(1.into(), 3.into())),\n+                AtomTextEdit::insert(4.into(), \"\\n\".into()),\n+            ],\n+        };\n+        let line_index = LineIndex::new(&x.text);\n+        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+        let actual = translate_offset_with_edit_fast(&line_index, x.offset, &x.edits);\n+        // assert_eq!(actual, expected);\n+        assert_eq!(actual.line, expected.line);\n+    }\n+\n+    #[test]\n+    fn test_translate_offset_with_edit_2() {\n+        let x = ArbTextWithOffsetAndEdits {\n+            text: \"aa\\n\".to_owned(),\n+            offset: 1.into(),\n+            edits: vec![AtomTextEdit::delete(TextRange::from_to(0.into(), 2.into()))],\n+        };\n+        let line_index = LineIndex::new(&x.text);\n+        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+        let actual = translate_offset_with_edit_fast(&line_index, x.offset, &x.edits);\n+        // assert_eq!(actual, expected);\n+        assert_eq!(actual.line, expected.line);\n+    }\n+\n+    #[test]\n+    fn test_translate_offset_with_edit_3() {\n+        let x = ArbTextWithOffsetAndEdits {\n+            text: \"\".to_owned(),\n+            offset: 0.into(),\n+            edits: vec![AtomTextEdit::insert(0.into(), \"\\n\".into())],\n+        };\n+        let line_index = LineIndex::new(&x.text);\n+        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+        let actual = translate_offset_with_edit_fast(&line_index, x.offset, &x.edits);\n+        // assert_eq!(actual, expected);\n+        assert_eq!(actual.line, expected.line);\n+    }\n+\n }"}]}