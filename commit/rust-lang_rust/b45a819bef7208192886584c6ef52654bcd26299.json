{"sha": "b45a819bef7208192886584c6ef52654bcd26299", "node_id": "C_kwDOAAsO6NoAKGI0NWE4MTliZWY3MjA4MTkyODg2NTg0YzZlZjUyNjU0YmNkMjYyOTk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-13T07:11:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-13T07:11:19Z"}, "message": "Rollup merge of #92006 - oli-obk:welcome_opaque_types_into_the_fold, r=nikomatsakis\n\nWelcome opaque types into the fold\n\nr? ```@nikomatsakis``` because idk who else to bug on the type_op changes\n\nThe commits have explanations in them. The TLDR is that\n\n* 5c4600227329a273c0c6c844e4a10ce650ead601 stops the \"recurse and replace\" scheme that replaces opaque types with their canonical inference var by just doing that ahead of time\n* bdeeb07bf6400622074f04ca2523dac1512ab662 does not affect anything on master afaict, but since opaque types generate obligations when instantiated, and lazy TAIT instantiates opaque types *everywhere*, we need to properly handle obligations here instead of just hoping no problematic obligations ever come up.", "tree": {"sha": "ce8b66533b0743e8e3c28ec7826f51885bf90148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce8b66533b0743e8e3c28ec7826f51885bf90148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b45a819bef7208192886584c6ef52654bcd26299", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh39CXCRBK7hj4Ov3rIwAAXoIIAGu8Ji6nopuX14qeADfwDNlg\nxg+X2FkyEOHSPY1mdeJfR8wGHqlF/RTcpZTW8PPxv8le4Jd5nIqCkNw64QNjCWUr\nJ8vFOovo7IPHVWEAUHP4Mj6MIWd6v9vR4kKzYIqs6xlqiVmFYqv8bJ90EA50rwAa\nUK/QCKTkltFuDYyKsxpjWuC/6PiC4K+/3x4Tt5L+hh7dOqGhmxEqrP/dNrH7XGHX\nhVjWixzIRzKbLEZGxWLchlObNLWvWfZIfApzkjCD5Jo++lDhUAJJ2n1D6sNiZU0z\nyMQn9W4gI55qbYponJhAoTW3jaEFViqH9LU2MSfkLQR2jkGf3tedrmswZAvat/c=\n=hney\n-----END PGP SIGNATURE-----\n", "payload": "tree ce8b66533b0743e8e3c28ec7826f51885bf90148\nparent e045c79c2d8697ef7ab2e25c3165cb5896f163ba\nparent bdeeb07bf6400622074f04ca2523dac1512ab662\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642057879 +0100\ncommitter GitHub <noreply@github.com> 1642057879 +0100\n\nRollup merge of #92006 - oli-obk:welcome_opaque_types_into_the_fold, r=nikomatsakis\n\nWelcome opaque types into the fold\n\nr? ```@nikomatsakis``` because idk who else to bug on the type_op changes\n\nThe commits have explanations in them. The TLDR is that\n\n* 5c4600227329a273c0c6c844e4a10ce650ead601 stops the \"recurse and replace\" scheme that replaces opaque types with their canonical inference var by just doing that ahead of time\n* bdeeb07bf6400622074f04ca2523dac1512ab662 does not affect anything on master afaict, but since opaque types generate obligations when instantiated, and lazy TAIT instantiates opaque types *everywhere*, we need to properly handle obligations here instead of just hoping no problematic obligations ever come up.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b45a819bef7208192886584c6ef52654bcd26299", "html_url": "https://github.com/rust-lang/rust/commit/b45a819bef7208192886584c6ef52654bcd26299", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b45a819bef7208192886584c6ef52654bcd26299/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e045c79c2d8697ef7ab2e25c3165cb5896f163ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/e045c79c2d8697ef7ab2e25c3165cb5896f163ba", "html_url": "https://github.com/rust-lang/rust/commit/e045c79c2d8697ef7ab2e25c3165cb5896f163ba"}, {"sha": "bdeeb07bf6400622074f04ca2523dac1512ab662", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdeeb07bf6400622074f04ca2523dac1512ab662", "html_url": "https://github.com/rust-lang/rust/commit/bdeeb07bf6400622074f04ca2523dac1512ab662"}], "stats": {"total": 141, "additions": 61, "deletions": 80}, "files": [{"sha": "d5e65705b2885a9f2226ec032ae21bab8fd98dbf", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b45a819bef7208192886584c6ef52654bcd26299/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b45a819bef7208192886584c6ef52654bcd26299/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=b45a819bef7208192886584c6ef52654bcd26299", "patch": "@@ -551,6 +551,22 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             let predicate = predicate.subst(tcx, substs);\n             debug!(?predicate);\n \n+            let predicate = predicate.fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| match *ty.kind() {\n+                    // Replace all other mentions of the same opaque type with the hidden type,\n+                    // as the bounds must hold on the hidden type after all.\n+                    ty::Opaque(def_id2, substs2) if def_id == def_id2 && substs == substs2 => {\n+                        ty_var\n+                    }\n+                    // Instantiate nested instances of `impl Trait`.\n+                    ty::Opaque(..) => self.instantiate_opaque_types_in_map(ty),\n+                    _ => ty,\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            });\n+\n             // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n             let predicate = predicate.fold_with(&mut BottomUpFolder {\n                 tcx,\n@@ -575,10 +591,6 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     return tcx.ty_error();\n                 }\n             }\n-            // Change the predicate to refer to the type variable,\n-            // which will be the concrete type instead of the opaque type.\n-            // This also instantiates nested instances of `impl Trait`.\n-            let predicate = self.instantiate_opaque_types_in_map(predicate);\n \n             let cause =\n                 traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);"}, {"sha": "d662f61e2cf4dbbc1532fef09b656d71d7b546d1", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b45a819bef7208192886584c6ef52654bcd26299/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b45a819bef7208192886584c6ef52654bcd26299/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=b45a819bef7208192886584c6ef52654bcd26299", "patch": "@@ -4,7 +4,9 @@ use crate::infer::canonical::{\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n-use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::infer::canonical::{Canonical, Certainty};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::PredicateObligations;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use std::fmt;\n@@ -17,7 +19,6 @@ pub mod implied_outlives_bounds;\n pub mod normalize;\n pub mod outlives;\n pub mod prove_predicate;\n-use self::prove_predicate::ProvePredicate;\n pub mod subtype;\n \n pub use rustc_middle::traits::query::type_op::*;\n@@ -80,9 +81,14 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'tcx>,\n         output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n-    ) -> Fallible<(Self::QueryResponse, Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>)> {\n+    ) -> Fallible<(\n+        Self::QueryResponse,\n+        Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>,\n+        PredicateObligations<'tcx>,\n+        Certainty,\n+    )> {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n-            return Ok((result, None));\n+            return Ok((result, None, vec![], Certainty::Proven));\n         }\n \n         // FIXME(#33684) -- We need to use\n@@ -104,20 +110,7 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n                 output_query_region_constraints,\n             )?;\n \n-        // Typically, instantiating NLL query results does not\n-        // create obligations. However, in some cases there\n-        // are unresolved type variables, and unify them *can*\n-        // create obligations. In that case, we have to go\n-        // fulfill them. We do this via a (recursive) query.\n-        for obligation in obligations {\n-            let ((), _) = ProvePredicate::fully_perform_into(\n-                obligation.param_env.and(ProvePredicate::new(obligation.predicate)),\n-                infcx,\n-                output_query_region_constraints,\n-            )?;\n-        }\n-\n-        Ok((value, Some(canonical_self)))\n+        Ok((value, Some(canonical_self), obligations, canonical_result.value.certainty))\n     }\n }\n \n@@ -129,9 +122,39 @@ where\n \n     fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let mut region_constraints = QueryRegionConstraints::default();\n-        let (output, canonicalized_query) =\n+        let (output, canonicalized_query, mut obligations, _) =\n             Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n \n+        // Typically, instantiating NLL query results does not\n+        // create obligations. However, in some cases there\n+        // are unresolved type variables, and unify them *can*\n+        // create obligations. In that case, we have to go\n+        // fulfill them. We do this via a (recursive) query.\n+        while !obligations.is_empty() {\n+            trace!(\"{:#?}\", obligations);\n+            let mut progress = false;\n+            for obligation in std::mem::take(&mut obligations) {\n+                let obligation = infcx.resolve_vars_if_possible(obligation);\n+                match ProvePredicate::fully_perform_into(\n+                    obligation.param_env.and(ProvePredicate::new(obligation.predicate)),\n+                    infcx,\n+                    &mut region_constraints,\n+                ) {\n+                    Ok(((), _, new, certainty)) => {\n+                        obligations.extend(new);\n+                        progress = true;\n+                        if let Certainty::Ambiguous = certainty {\n+                            obligations.push(obligation);\n+                        }\n+                    }\n+                    Err(_) => obligations.push(obligation),\n+                }\n+            }\n+            if !progress {\n+                return Err(NoSolution);\n+            }\n+        }\n+\n         // Promote the final query-region-constraints into a\n         // (optional) ref-counted vector:\n         let region_constraints ="}, {"sha": "cee8186dd8f8c432c3a2ccf10f49ae3822e120f5", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b45a819bef7208192886584c6ef52654bcd26299/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b45a819bef7208192886584c6ef52654bcd26299/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=b45a819bef7208192886584c6ef52654bcd26299", "patch": "@@ -15,9 +15,5 @@ impl<W> Trait<W> for () {}\n \n fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n     //~^ ERROR non-defining opaque type use in defining scope\n-    //~| ERROR non-defining opaque type use in defining scope\n-    //~| ERROR non-defining opaque type use in defining scope\n-    //~| ERROR `T` is part of concrete type but not used in parameter list\n-    //~| ERROR `T` is part of concrete type but not used in parameter list\n     ()\n }"}, {"sha": "03e696fe8980376392a3df6e8219d9ae3dbd03fc", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 3, "deletions": 53, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b45a819bef7208192886584c6ef52654bcd26299/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b45a819bef7208192886584c6ef52654bcd26299/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=b45a819bef7208192886584c6ef52654bcd26299", "patch": "@@ -1,70 +1,20 @@\n-error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/bound_reduction2.rs:16:60\n-   |\n-LL |   fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   |  ____________________________________________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     ()\n-LL | | }\n-   | |_^\n-\n-error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/bound_reduction2.rs:16:60\n-   |\n-LL |   fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   |  ____________________________________________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     ()\n-LL | | }\n-   | |_^\n-\n error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:1\n+  --> $DIR/bound_reduction2.rs:16:46\n    |\n LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                              ^^^^^^^^^^^^^\n    |\n note: used non-generic type `<T as TraitWithAssoc>::Assoc` for generic parameter\n   --> $DIR/bound_reduction2.rs:9:10\n    |\n LL | type Foo<V> = impl Trait<V>;\n    |          ^\n \n-error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:1\n-   |\n-LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: used non-generic type `_` for generic parameter\n-  --> $DIR/bound_reduction2.rs:9:10\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   |          ^\n-\n-error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:1\n-   |\n-LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: used non-generic type `_` for generic parameter\n-  --> $DIR/bound_reduction2.rs:9:10\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   |          ^\n-\n error: could not find defining uses\n   --> $DIR/bound_reduction2.rs:9:15\n    |\n LL | type Foo<V> = impl Trait<V>;\n    |               ^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 2 previous errors\n "}]}