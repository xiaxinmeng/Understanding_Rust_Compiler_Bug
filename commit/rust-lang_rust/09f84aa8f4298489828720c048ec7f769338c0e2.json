{"sha": "09f84aa8f4298489828720c048ec7f769338c0e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5Zjg0YWE4ZjQyOTg0ODk4Mjg3MjBjMDQ4ZWM3Zjc2OTMzOGMwZTI=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-25T05:18:21Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@palantir.com", "date": "2013-11-26T21:54:00Z"}, "message": "Add SmallVector to libsyntax", "tree": {"sha": "23f06fc196d9a0fcd96cf82197d2e0582fc608b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f06fc196d9a0fcd96cf82197d2e0582fc608b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f84aa8f4298489828720c048ec7f769338c0e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f84aa8f4298489828720c048ec7f769338c0e2", "html_url": "https://github.com/rust-lang/rust/commit/09f84aa8f4298489828720c048ec7f769338c0e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f84aa8f4298489828720c048ec7f769338c0e2/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9a1869a5f4164d5311963b1b25b05f003d43699", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9a1869a5f4164d5311963b1b25b05f003d43699", "html_url": "https://github.com/rust-lang/rust/commit/e9a1869a5f4164d5311963b1b25b05f003d43699"}], "stats": {"total": 214, "additions": 214, "deletions": 0}, "files": [{"sha": "5b12e8b8eb1feb9eb434144295d1d827680aff4c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09f84aa8f4298489828720c048ec7f769338c0e2/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f84aa8f4298489828720c048ec7f769338c0e2/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=09f84aa8f4298489828720c048ec7f769338c0e2", "patch": "@@ -31,6 +31,7 @@ pub mod util {\n     pub mod interner;\n     #[cfg(test)]\n     pub mod parser_testing;\n+    pub mod small_vector;\n }\n \n pub mod syntax {"}, {"sha": "c6b223f7c15806d6f2af194e73b9667acf1562ff", "filename": "src/libsyntax/util/small_vector.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/09f84aa8f4298489828720c048ec7f769338c0e2/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f84aa8f4298489828720c048ec7f769338c0e2/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=09f84aa8f4298489828720c048ec7f769338c0e2", "patch": "@@ -0,0 +1,213 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use std::vec::MoveIterator;\n+use std::util;\n+\n+/// A vector type optimized for cases where the size is almost always 0 or 1\n+pub enum SmallVector<T> {\n+    priv Zero,\n+    priv One(T),\n+    priv Many(~[T]),\n+}\n+\n+impl<T> Container for SmallVector<T> {\n+    fn len(&self) -> uint {\n+        match *self {\n+            Zero => 0,\n+            One(*) => 1,\n+            Many(ref vals) => vals.len()\n+        }\n+    }\n+}\n+\n+impl<T> FromIterator<T> for SmallVector<T> {\n+    fn from_iterator<I: Iterator<T>>(iter: &mut I) -> SmallVector<T> {\n+        let mut v = Zero;\n+        for val in *iter {\n+            v.push(val);\n+        }\n+        v\n+    }\n+}\n+\n+impl<T> SmallVector<T> {\n+    pub fn zero() -> SmallVector<T> {\n+        Zero\n+    }\n+\n+    pub fn one(v: T) -> SmallVector<T> {\n+        One(v)\n+    }\n+\n+    pub fn many(vs: ~[T]) -> SmallVector<T> {\n+        Many(vs)\n+    }\n+\n+    pub fn push(&mut self, v: T) {\n+        match *self {\n+            Zero => *self = One(v),\n+            One(*) => {\n+                let mut tmp = Many(~[]);\n+                util::swap(self, &mut tmp);\n+                match *self {\n+                    Many(ref mut vs) => {\n+                        match tmp {\n+                            One(v1) => {\n+                                vs.push(v1);\n+                                vs.push(v);\n+                            }\n+                            _ => unreachable!()\n+                        }\n+                    }\n+                    _ => unreachable!()\n+                }\n+            }\n+            Many(ref mut vs) => vs.push(v)\n+        }\n+    }\n+\n+    pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n+        match *self {\n+            One(ref v) if idx == 0 => v,\n+            Many(ref vs) => &vs[idx],\n+            _ => fail!(\"Out of bounds access\")\n+        }\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> SmallVectorIterator<'a, T> {\n+        SmallVectorIterator {\n+            vec: self,\n+            idx: 0\n+        }\n+    }\n+\n+    pub fn move_iter(self) -> SmallVectorMoveIterator<T> {\n+        match self {\n+            Zero => ZeroIterator,\n+            One(v) => OneIterator(v),\n+            Many(vs) => ManyIterator(vs.move_iter())\n+        }\n+    }\n+}\n+\n+pub struct SmallVectorIterator<'vec, T> {\n+    priv vec: &'vec SmallVector<T>,\n+    priv idx: uint\n+}\n+\n+impl<'vec, T> Iterator<&'vec T> for SmallVectorIterator<'vec, T> {\n+    fn next(&mut self) -> Option<&'vec T> {\n+        if self.idx == self.vec.len() {\n+            return None;\n+        }\n+\n+        self.idx += 1;\n+        Some(self.vec.get(self.idx - 1))\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let rem = self.vec.len() - self.idx;\n+        (rem, Some(rem))\n+    }\n+}\n+\n+pub enum SmallVectorMoveIterator<T> {\n+    priv ZeroIterator,\n+    priv OneIterator(T),\n+    priv ManyIterator(MoveIterator<T>),\n+}\n+\n+impl<T> Iterator<T> for SmallVectorMoveIterator<T> {\n+    fn next(&mut self) -> Option<T> {\n+        match *self {\n+            ZeroIterator => None,\n+            OneIterator(*) => {\n+                let mut replacement = ZeroIterator;\n+                util::swap(self, &mut replacement);\n+                match replacement {\n+                    OneIterator(v) => Some(v),\n+                    _ => unreachable!()\n+                }\n+            }\n+            ManyIterator(ref mut inner) => inner.next()\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        match *self {\n+            ZeroIterator => (0, Some(0)),\n+            OneIterator(*) => (1, Some(1)),\n+            ManyIterator(ref inner) => inner.size_hint()\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_len() {\n+        let v: SmallVector<int> = SmallVector::zero();\n+        assert_eq!(0, v.len());\n+\n+        assert_eq!(1, SmallVector::one(1).len());\n+        assert_eq!(5, SmallVector::many(~[1, 2, 3, 4, 5]).len());\n+    }\n+\n+    #[test]\n+    fn test_push_get() {\n+        let mut v = SmallVector::zero();\n+        v.push(1);\n+        assert_eq!(1, v.len());\n+        assert_eq!(&1, v.get(0));\n+        v.push(2);\n+        assert_eq!(2, v.len());\n+        assert_eq!(&2, v.get(1));\n+        v.push(3);\n+        assert_eq!(3, v.len());\n+        assert_eq!(&3, v.get(2));\n+    }\n+\n+    #[test]\n+    fn test_from_iterator() {\n+        let v: SmallVector<int> = (~[1, 2, 3]).move_iter().collect();\n+        assert_eq!(3, v.len());\n+        assert_eq!(&1, v.get(0));\n+        assert_eq!(&2, v.get(1));\n+        assert_eq!(&3, v.get(2));\n+    }\n+\n+    #[test]\n+    fn test_iter() {\n+        let v = SmallVector::zero();\n+        let v: ~[&int] = v.iter().collect();\n+        assert_eq!(~[], v);\n+\n+        let v = SmallVector::one(1);\n+        assert_eq!(~[&1], v.iter().collect());\n+\n+        let v = SmallVector::many(~[1, 2, 3]);\n+        assert_eq!(~[&1, &2, &3], v.iter().collect());\n+    }\n+\n+    #[test]\n+    fn test_move_iter() {\n+        let v = SmallVector::zero();\n+        let v: ~[int] = v.move_iter().collect();\n+        assert_eq!(~[], v);\n+\n+        let v = SmallVector::one(1);\n+        assert_eq!(~[1], v.move_iter().collect());\n+\n+        let v = SmallVector::many(~[1, 2, 3]);\n+        assert_eq!(~[1, 2, 3], v.move_iter().collect());\n+    }\n+}"}]}