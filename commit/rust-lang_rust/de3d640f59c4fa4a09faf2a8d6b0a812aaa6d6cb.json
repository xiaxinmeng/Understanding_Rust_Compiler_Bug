{"sha": "de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlM2Q2NDBmNTljNGZhNGEwOWZhZjJhOGQ2YjBhODEyYWFhNmQ2Y2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-01T14:58:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-01T14:58:24Z"}, "message": "Auto merge of #54667 - RalfJung:maybe-uninit, r=pnkfelix\n\nPanic when using mem::uninitialized or mem::zeroed on an uninhabited type\n\nAll code by @japaric. This re-submits one half of https://github.com/rust-lang/rust/pull/53508. This is likely not the one that introduced the perf regression, but just to be sure I'll do a perf run anyway.", "tree": {"sha": "a972fbca76a07b42c194d259fb11105fe8d78726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a972fbca76a07b42c194d259fb11105fe8d78726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "html_url": "https://github.com/rust-lang/rust/commit/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6188c58a55a27efac25f6e50a8e5f18c2650b60f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6188c58a55a27efac25f6e50a8e5f18c2650b60f", "html_url": "https://github.com/rust-lang/rust/commit/6188c58a55a27efac25f6e50a8e5f18c2650b60f"}, {"sha": "dd65d732ed702302ac0943179cb2feec835975ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd65d732ed702302ac0943179cb2feec835975ee", "html_url": "https://github.com/rust-lang/rust/commit/dd65d732ed702302ac0943179cb2feec835975ee"}], "stats": {"total": 195, "additions": 181, "deletions": 14}, "files": [{"sha": "8bfe46568eb198791f12a879d4821a3a69b23326", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n             }\n \n-            if sized && fields.iter().any(|f| f.abi == Abi::Uninhabited) {\n+            if sized && fields.iter().any(|f| f.abi.is_uninhabited()) {\n                 abi = Abi::Uninhabited;\n             }\n \n@@ -724,7 +724,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 // See issue #49298 for more details on the need to leave space\n                 // for non-ZST uninhabited data (mostly partial initialization).\n                 let absent = |fields: &[TyLayout<'_>]| {\n-                    let uninhabited = fields.iter().any(|f| f.abi == Abi::Uninhabited);\n+                    let uninhabited = fields.iter().any(|f| f.abi.is_uninhabited());\n                     let is_zst = fields.iter().all(|f| f.is_zst());\n                     uninhabited && is_zst\n                 };\n@@ -872,7 +872,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 _ => Abi::Aggregate { sized: true },\n                             };\n \n-                            if st.iter().all(|v| v.abi == Abi::Uninhabited) {\n+                            if st.iter().all(|v| v.abi.is_uninhabited()) {\n                                 abi = Abi::Uninhabited;\n                             }\n \n@@ -900,7 +900,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let discr_type = def.repr.discr_type();\n                 let bits = Integer::from_attr(tcx, discr_type).size().bits();\n                 for (i, discr) in def.discriminants(tcx).enumerate() {\n-                    if variants[i].iter().any(|f| f.abi == Abi::Uninhabited) {\n+                    if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n                         continue;\n                     }\n                     let mut x = discr.val as i128;\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n                 }\n \n-                if layout_variants.iter().all(|v| v.abi == Abi::Uninhabited) {\n+                if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n                     abi = Abi::Uninhabited;\n                 }\n "}, {"sha": "7b0c413e857617b7ffbd5fd975285875ddf33579", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -279,7 +279,7 @@ pub fn create_function_debug_context(\n         }\n         None => {}\n     };\n-    if cx.layout_of(sig.output()).abi == ty::layout::Abi::Uninhabited {\n+    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n         flags = flags | DIFlags::FlagNoReturn;\n     }\n "}, {"sha": "7141c9ece89d7180ea0c7f85f22e1fb29afbf8e1", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -23,7 +23,7 @@\n use llvm;\n use llvm::AttributePlace::Function;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutOf};\n+use rustc::ty::layout::LayoutOf;\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_target::spec::PanicStrategy;\n@@ -137,7 +137,7 @@ pub fn declare_fn(\n     let fty = FnType::new(cx, sig, &[]);\n     let llfn = declare_raw_fn(cx, name, fty.llvm_cconv(), fty.llvm_type(cx));\n \n-    if cx.layout_of(sig.output()).abi == layout::Abi::Uninhabited {\n+    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n         llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "709fceb492509e9c88cddac93057e6d66d32c55c", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -482,6 +482,54 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     _ => FnType::new(bx.cx, sig, &extra_args)\n                 };\n \n+                // emit a panic instead of instantiating an uninhabited type\n+                if (intrinsic == Some(\"init\") || intrinsic == Some(\"uninit\")) &&\n+                    fn_ty.ret.layout.abi.is_uninhabited()\n+                {\n+                    let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n+                    let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n+                    let filename = C_str_slice(bx.cx, filename);\n+                    let line = C_u32(bx.cx, loc.line as u32);\n+                    let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n+                    let align = tcx.data_layout.aggregate_align\n+                        .max(tcx.data_layout.i32_align)\n+                        .max(tcx.data_layout.pointer_align);\n+\n+                    let str = format!(\n+                        \"Attempted to instantiate uninhabited type {} using mem::{}\",\n+                        sig.output(),\n+                        if intrinsic == Some(\"init\") { \"zeroed\" } else { \"uninitialized\" }\n+                    );\n+                    let msg_str = Symbol::intern(&str).as_str();\n+                    let msg_str = C_str_slice(bx.cx, msg_str);\n+                    let msg_file_line_col = C_struct(bx.cx,\n+                                                    &[msg_str, filename, line, col],\n+                                                    false);\n+                    let msg_file_line_col = consts::addr_of(bx.cx,\n+                                                            msg_file_line_col,\n+                                                            align,\n+                                                            Some(\"panic_loc\"));\n+\n+                    // Obtain the panic entry point.\n+                    let def_id =\n+                        common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n+                    let instance = ty::Instance::mono(bx.tcx(), def_id);\n+                    let fn_ty = FnType::of_instance(bx.cx, &instance);\n+                    let llfn = callee::get_fn(bx.cx, instance);\n+\n+                    // Codegen the actual panic invoke/call.\n+                    do_call(\n+                        self,\n+                        bx,\n+                        fn_ty,\n+                        llfn,\n+                        &[msg_file_line_col],\n+                        destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n+                        cleanup,\n+                    );\n+                    return;\n+                }\n+\n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n                 let mut llargs = Vec::with_capacity(arg_count);"}, {"sha": "e7b6f5908a4d16a2c4fa9780d53bd5abbcd9d5ff", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -275,7 +275,7 @@ impl PlaceRef<'ll, 'tcx> {\n     /// Obtain the actual discriminant of a value.\n     pub fn codegen_get_discr(self, bx: &Builder<'a, 'll, 'tcx>, cast_to: Ty<'tcx>) -> &'ll Value {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n-        if self.layout.abi == layout::Abi::Uninhabited {\n+        if self.layout.abi.is_uninhabited() {\n             return C_undef(cast_to);\n         }\n         match self.layout.variants {\n@@ -338,7 +338,7 @@ impl PlaceRef<'ll, 'tcx> {\n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize) {\n-        if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n+        if self.layout.for_variant(bx.cx, variant_index).abi.is_uninhabited() {\n             return;\n         }\n         match self.layout.variants {"}, {"sha": "fa22bdff94dddbeb29fda3c9a0295e6c2100ea8b", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -290,7 +290,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     mir::CastKind::Misc => {\n                         assert!(cast.is_llvm_immediate());\n                         let ll_t_out = cast.immediate_llvm_type(bx.cx);\n-                        if operand.layout.abi == layout::Abi::Uninhabited {\n+                        if operand.layout.abi.is_uninhabited() {\n                             return (bx, OperandRef {\n                                 val: OperandValue::Immediate(C_undef(ll_t_out)),\n                                 layout: cast,"}, {"sha": "a11150c47836e11bc11c591c326cfe132eb48c1f", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         rval: OpTy<'tcx>,\n     ) -> EvalResult<'tcx, (u128, usize)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n-        if rval.layout.abi == layout::Abi::Uninhabited {\n+        if rval.layout.abi.is_uninhabited() {\n             return err!(Unreachable);\n         }\n "}, {"sha": "96eb69163220e7b33c57287bd9ac35596ab6b589", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -802,6 +802,14 @@ impl Abi {\n             _ => false,\n         }\n     }\n+\n+    /// Returns true if this is an uninhabited type\n+    pub fn is_uninhabited(&self) -> bool {\n+        match *self {\n+            Abi::Uninhabited => true,\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]"}, {"sha": "168e1a3eba0c56f9a22c0d9581fe50d95e89759f", "filename": "src/test/codegen/box-maybe-uninit.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -O\n+#![crate_type=\"lib\"]\n+#![feature(maybe_uninit)]\n+\n+use std::mem::MaybeUninit;\n+\n+// Boxing a `MaybeUninit` value should not copy junk from the stack\n+#[no_mangle]\n+pub fn box_uninitialized() -> Box<MaybeUninit<usize>> {\n+    // CHECK-LABEL: @box_uninitialized\n+    // CHECK-NOT: store\n+    Box::new(MaybeUninit::uninitialized())\n+}"}, {"sha": "ab9c7e2dd2758a5d4dec1827be9c915f7fef0848", "filename": "src/test/debuginfo/nil-enum.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// NOTE Instantiating an empty enum is UB. This test may break in the future.\n+\n // LLDB can't handle zero-sized values\n // ignore-lldb\n \n@@ -25,8 +27,11 @@\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n+#![feature(maybe_uninit)]\n #![omit_gdb_pretty_printer_section]\n \n+use std::mem::MaybeUninit;\n+\n enum ANilEnum {}\n enum AnotherNilEnum {}\n \n@@ -35,8 +40,8 @@ enum AnotherNilEnum {}\n // The error from gdbr is expected since nil enums are not supposed to exist.\n fn main() {\n     unsafe {\n-        let first: ANilEnum = ::std::mem::zeroed();\n-        let second: AnotherNilEnum = ::std::mem::zeroed();\n+        let first: ANilEnum = MaybeUninit::uninitialized().into_inner();\n+        let second: AnotherNilEnum = MaybeUninit::uninitialized().into_inner();\n \n         zzz(); // #break\n     }"}, {"sha": "2972f6efa32e05f3eab76c0229b61767a978ad44", "filename": "src/test/run-pass/panic-uninitialized-zeroed.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs?ref=de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-wasm32-bare always compiled as panic=abort right now and this requires unwinding\n+// This test checks that instantiating an uninhabited type via `mem::{uninitialized,zeroed}` results\n+// in a runtime panic.\n+\n+#![feature(never_type)]\n+\n+use std::{mem, panic};\n+\n+#[allow(dead_code)]\n+struct Foo {\n+    x: u8,\n+    y: !,\n+}\n+\n+enum Bar {}\n+\n+fn main() {\n+    unsafe {\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::uninitialized::<!>()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type ! using mem::uninitialized\"\n+            })),\n+            Some(true)\n+        );\n+\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::zeroed::<!>()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type ! using mem::zeroed\"\n+            })),\n+            Some(true)\n+        );\n+\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::uninitialized::<Foo>()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type Foo using mem::uninitialized\"\n+            })),\n+            Some(true)\n+        );\n+\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::zeroed::<Foo>()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type Foo using mem::zeroed\"\n+            })),\n+            Some(true)\n+        );\n+\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::uninitialized::<Bar>()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type Bar using mem::uninitialized\"\n+            })),\n+            Some(true)\n+        );\n+\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::zeroed::<Bar>()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type Bar using mem::zeroed\"\n+            })),\n+            Some(true)\n+        );\n+    }\n+}"}]}