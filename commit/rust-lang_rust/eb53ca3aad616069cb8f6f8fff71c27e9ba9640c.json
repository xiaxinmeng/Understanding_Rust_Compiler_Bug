{"sha": "eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNTNjYTNhYWQ2MTYwNjljYjhmNmY4ZmZmNzFjMjdlOWJhOTY0MGM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-10-24T00:22:06Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-11-22T21:42:36Z"}, "message": "Show multiline spans in full if short enough\n\nWhen dealing with multiline spans that span few lines, show the complete\nspan instead of restricting to the first character of the first line.\n\nFor example, instead of:\n\n```\n% ./rustc foo.rs\nerror[E0277]: the trait bound `{integer}: std::ops::Add<()>` is not satisfied\n  --> foo.rs:13:9\n   |\n13 |    foo(1 + bar(x,\n   |        ^ trait `{integer}: std::ops::Add<()>` not satisfied\n   |\n```\n\nshow\n\n```\n% ./rustc foo.rs\nerror[E0277]: the trait bound `{integer}: std::ops::Add<()>` is not satisfied\n  --> foo.rs:13:9\n   |\n13 |      foo(1 + bar(x,\n   |  ________^ starting here...\n14 | |            y),\n   | |_____________^ ...ending here: trait `{integer}: std::ops::Add<()>` not satisfied\n   |\n```", "tree": {"sha": "8b305f44c0527577d57be9cc693465dd3b74f7e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b305f44c0527577d57be9cc693465dd3b74f7e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "html_url": "https://github.com/rust-lang/rust/commit/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83", "html_url": "https://github.com/rust-lang/rust/commit/fb122199aac1fd4f9a3c133e25791a9fcb2a6b83"}], "stats": {"total": 1225, "additions": 1081, "deletions": 144}, "files": [{"sha": "808a1683b8436a7864eba26ac0c9c3463115586a", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 379, "deletions": 105, "changes": 484, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n \n use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapper};\n use RenderSpan::*;\n-use snippet::{StyledString, Style, Annotation, Line};\n+use snippet::{Annotation, AnnotationType, Line, StyledString, Style};\n use styled_buffer::StyledBuffer;\n \n use std::io::prelude::*;\n@@ -65,6 +65,7 @@ pub struct EmitterWriter {\n struct FileWithAnnotatedLines {\n     file: Rc<FileMap>,\n     lines: Vec<Line>,\n+    multiline_depth: usize,\n }\n \n \n@@ -137,10 +138,12 @@ impl EmitterWriter {\n                                 line_index: line_index,\n                                 annotations: vec![ann],\n                             }],\n+                multiline_depth: 0,\n             });\n         }\n \n         let mut output = vec![];\n+        let mut multiline_annotations = vec![];\n \n         if let Some(ref cm) = self.cm {\n             for span_label in msp.span_labels() {\n@@ -151,8 +154,9 @@ impl EmitterWriter {\n                 let mut hi = cm.lookup_char_pos(span_label.span.hi);\n                 let mut is_minimized = false;\n \n-                // If the span is multi-line, simplify down to the span of one character\n-                if lo.line != hi.line {\n+                // If the span is long multi-line, simplify down to the span of one character\n+                let max_multiline_span_length = 8;\n+                if lo.line != hi.line && (hi.line - lo.line) > max_multiline_span_length {\n                     hi.line = lo.line;\n                     hi.col = CharPos(lo.col.0 + 1);\n                     is_minimized = true;\n@@ -163,52 +167,134 @@ impl EmitterWriter {\n                 // 6..7. This is degenerate input, but it's best to degrade\n                 // gracefully -- and the parser likes to supply a span like\n                 // that for EOF, in particular.\n-                if lo.col == hi.col {\n+                if lo.col == hi.col && lo.line == hi.line {\n                     hi.col = CharPos(lo.col.0 + 1);\n                 }\n \n-                add_annotation_to_file(&mut output,\n-                                       lo.file,\n-                                       lo.line,\n-                                       Annotation {\n-                                           start_col: lo.col.0,\n-                                           end_col: hi.col.0,\n-                                           is_primary: span_label.is_primary,\n-                                           is_minimized: is_minimized,\n-                                           label: span_label.label.clone(),\n-                                       });\n+                let mut ann = Annotation {\n+                    start_col: lo.col.0,\n+                    end_col: hi.col.0,\n+                    is_primary: span_label.is_primary,\n+                    label: span_label.label.clone(),\n+                    annotation_type: AnnotationType::Singleline,\n+                };\n+                if is_minimized {\n+                    ann.annotation_type = AnnotationType::Minimized;\n+                } else if lo.line != hi.line {\n+                    ann.annotation_type = AnnotationType::Multiline {\n+                        depth: 1,\n+                        line_start: lo.line,\n+                        line_end: hi.line,\n+                    };\n+                    multiline_annotations.push((lo.file.clone(), ann.clone()));\n+                };\n+\n+                if !ann.is_multiline() {\n+                    add_annotation_to_file(&mut output,\n+                                           lo.file,\n+                                           lo.line,\n+                                           ann);\n+                }\n+            }\n+        }\n+\n+        // Find overlapping multiline annotations, put them at different depths\n+        multiline_annotations.sort_by(|a, b| {\n+            if let AnnotationType::Multiline {\n+                line_start: a_start,\n+                line_end: a_end,\n+                ..\n+            } = a.1.annotation_type {\n+                if let AnnotationType::Multiline {\n+                    line_start: b_start,\n+                    line_end: b_end,\n+                    ..\n+                } = b.1.annotation_type {\n+                    (a_start, a_end).cmp(&(b_start, b_end))\n+                } else {\n+                    panic!(\"tried to sort multiline annotations, but found `{:?}`\", b)\n+                }\n+            } else {\n+                panic!(\"tried to sort multiline annotations, but found `{:?}`\", a)\n+            }\n+        });\n+        for item in multiline_annotations.clone() {\n+            let ann = item.1;\n+            if let AnnotationType::Multiline {line_start, line_end, ..} = ann.annotation_type {\n+                for item in multiline_annotations.iter_mut() {\n+                    let ref mut a = item.1;\n+                    if let AnnotationType::Multiline {\n+                        line_start: start,\n+                        line_end: end,\n+                        ..\n+                    } = a.annotation_type {\n+                        // Move all other multiline annotations overlapping with this one\n+                        // one level to the right.\n+                        if &ann != a && num_overlap(line_start, line_end, start, end, true) {\n+                            a.annotation_type.increase_depth();\n+                        } else {\n+                            break;\n+                        }\n+                    } else {\n+                        panic!(\"tried to find depth for multiline annotation, but found `{:?}`\",\n+                               ann)\n+                    };\n+                }\n+            } else {\n+                panic!(\"tried to find depth for multiline annotation, but found `{:?}`\", ann)\n+            };\n+        }\n+\n+        let mut max_depth = 0;  // max overlapping multiline spans\n+        for (file, ann) in multiline_annotations {\n+            if let AnnotationType::Multiline {line_start, line_end, depth} = ann.annotation_type {\n+                if depth > max_depth {\n+                    max_depth = depth;\n+                }\n+                add_annotation_to_file(&mut output, file.clone(), line_start, ann.as_start());\n+                for line in line_start + 1..line_end {\n+                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+                }\n+                add_annotation_to_file(&mut output, file, line_end, ann.as_end());\n+            } else {\n+                panic!(\"non-multiline annotation `{:?}` in `multiline_annotations`!\", ann);\n             }\n         }\n+        for file_vec in output.iter_mut() {\n+            file_vec.multiline_depth = max_depth;\n+        }\n         output\n     }\n \n     fn render_source_line(&self,\n                           buffer: &mut StyledBuffer,\n                           file: Rc<FileMap>,\n                           line: &Line,\n-                          width_offset: usize) {\n+                          width_offset: usize,\n+                          multiline_depth: usize) {\n         let source_string = file.get_line(line.line_index - 1)\n             .unwrap_or(\"\");\n \n         let line_offset = buffer.num_lines();\n+        let code_offset = if multiline_depth == 0 {\n+            width_offset\n+        } else {\n+            width_offset + multiline_depth + 1\n+        };\n \n         // First create the source line we will highlight.\n-        buffer.puts(line_offset, width_offset, &source_string, Style::Quotation);\n+        buffer.puts(line_offset, code_offset, &source_string, Style::Quotation);\n         buffer.puts(line_offset,\n                     0,\n                     &(line.line_index.to_string()),\n                     Style::LineNumber);\n \n         draw_col_separator(buffer, line_offset, width_offset - 2);\n \n-        if line.annotations.is_empty() {\n-            return;\n-        }\n-\n         // We want to display like this:\n         //\n         //      vec.push(vec.pop().unwrap());\n-        //      ---      ^^^               _ previous borrow ends here\n+        //      ---      ^^^               - previous borrow ends here\n         //      |        |\n         //      |        error occurs here\n         //      previous borrow of `vec` occurs here\n@@ -227,42 +313,22 @@ impl EmitterWriter {\n         // Sort the annotations by (start, end col)\n         let mut annotations = line.annotations.clone();\n         annotations.sort();\n+        annotations.reverse();\n \n-        // Next, create the highlight line.\n-        for annotation in &annotations {\n-            for p in annotation.start_col..annotation.end_col {\n-                if annotation.is_primary {\n-                    buffer.putc(line_offset + 1,\n-                                width_offset + p,\n-                                '^',\n-                                Style::UnderlinePrimary);\n-                    if !annotation.is_minimized {\n-                        buffer.set_style(line_offset, width_offset + p, Style::UnderlinePrimary);\n-                    }\n-                } else {\n-                    buffer.putc(line_offset + 1,\n-                                width_offset + p,\n-                                '-',\n-                                Style::UnderlineSecondary);\n-                    if !annotation.is_minimized {\n-                        buffer.set_style(line_offset, width_offset + p, Style::UnderlineSecondary);\n-                    }\n-                }\n-            }\n-        }\n-        draw_col_separator(buffer, line_offset + 1, width_offset - 2);\n-\n-        // Now we are going to write labels in. To start, we'll exclude\n-        // the annotations with no labels.\n-        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) = annotations.into_iter()\n-            .partition(|a| a.label.is_some());\n-\n-        // If there are no annotations that need text, we're done.\n-        if labeled_annotations.is_empty() {\n-            return;\n-        }\n-        // Now add the text labels. We try, when possible, to stick the rightmost\n-        // annotation at the end of the highlight line:\n+        // First, figure out where each label will be positioned.\n+        //\n+        // In the case where you have the following annotations:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      --------                    - previous borrow ends here [C]\n+        //      ||\n+        //      |this makes no sense [B]\n+        //      previous borrow of `vec` occurs here [A]\n+        //\n+        // `annotations_position` will hold [(2, A), (1, B), (0, C)].\n+        //\n+        // We try, when possible, to stick the rightmost annotation at the end\n+        // of the highlight line:\n         //\n         //      vec.push(vec.pop().unwrap());\n         //      ---      ---               - previous borrow ends here\n@@ -296,66 +362,251 @@ impl EmitterWriter {\n         // the rightmost span overlaps with any other span, we should\n         // use the \"hang below\" version, so we can at least make it\n         // clear where the span *starts*.\n-        let mut labeled_annotations = &labeled_annotations[..];\n-        match labeled_annotations.split_last().unwrap() {\n-            (last, previous) => {\n-                if previous.iter()\n-                    .chain(&unlabeled_annotations)\n-                    .all(|a| !overlaps(a, last)) {\n-                    // append the label afterwards; we keep it in a separate\n-                    // string\n-                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n-                    if last.is_primary {\n-                        buffer.append(line_offset + 1, &highlight_label, Style::LabelPrimary);\n-                    } else {\n-                        buffer.append(line_offset + 1, &highlight_label, Style::LabelSecondary);\n-                    }\n-                    labeled_annotations = previous;\n+        let mut annotations_position = vec![];\n+        let mut line_len = 0;\n+        let mut p = 0;\n+        let mut ann_iter = annotations.iter().peekable();\n+        while let Some(annotation) = ann_iter.next() {\n+            let is_line = if let AnnotationType::MultilineLine(_) = annotation.annotation_type {\n+                true\n+            } else {\n+                false\n+            };\n+            let peek = ann_iter.peek();\n+            if let Some(next) = peek {\n+                let next_is_line = if let AnnotationType::MultilineLine(_) = next.annotation_type {\n+                    true\n+                } else {\n+                    false\n+                };\n+\n+                if overlaps(next, annotation) && !is_line && !next_is_line {\n+                    p += 1;\n                 }\n             }\n+            annotations_position.push((p, annotation));\n+            if let Some(next) = peek {\n+                let next_is_line = if let AnnotationType::MultilineLine(_) = next.annotation_type {\n+                    true\n+                } else {\n+                    false\n+                };\n+                let l = if let Some(ref label) = next.label {\n+                    label.len() + 2\n+                } else {\n+                    0\n+                };\n+                if (overlaps(next, annotation) || next.end_col + l > annotation.start_col)\n+                    && !is_line && !next_is_line\n+                {\n+                    p += 1;\n+                }\n+            }\n+            if line_len < p {\n+                line_len = p;\n+            }\n+        }\n+        if line_len != 0 {\n+            line_len += 1;\n         }\n \n-        // If that's the last annotation, we're done\n-        if labeled_annotations.is_empty() {\n+        // If there are no annotations or the only annotations on this line are\n+        // MultilineLine, then there's only code being shown, stop processing.\n+        if line.annotations.is_empty() || line.annotations.iter()\n+            .filter(|a| {\n+                // Set the multiline annotation vertical lines to the left of\n+                // the code in this line.\n+                if let AnnotationType::MultilineLine(depth) = a.annotation_type {\n+                    buffer.putc(line_offset,\n+                                width_offset + depth - 1,\n+                                '|',\n+                                if a.is_primary {\n+                                    Style::UnderlinePrimary\n+                                } else {\n+                                    Style::UnderlineSecondary\n+                                });\n+                    false\n+                } else {\n+                    true\n+                }\n+            }).collect::<Vec<_>>().len() == 0\n+        {\n             return;\n         }\n \n-        for (index, annotation) in labeled_annotations.iter().enumerate() {\n-            // Leave:\n-            // - 1 extra line\n-            // - One line for each thing that comes after\n-            let comes_after = labeled_annotations.len() - index - 1;\n-            let blank_lines = 3 + comes_after;\n+        for pos in 0..line_len + 1 {\n+            draw_col_separator(buffer, line_offset + pos + 1, width_offset - 2);\n+            buffer.putc(line_offset + pos + 1,\n+                        width_offset - 2,\n+                        '|',\n+                        Style::LineNumber);\n+        }\n+\n+        // Write the horizontal lines for multiline annotations\n+        // (only the first and last lines need this).\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  __________\n+        //   |\n+        //   |\n+        // 3 |\n+        // 4 |   }\n+        //   |  _\n+        for &(pos, annotation) in &annotations_position {\n+            let style = if annotation.is_primary {\n+                Style::UnderlinePrimary\n+            } else {\n+                Style::UnderlineSecondary\n+            };\n+            let pos = pos + 1;\n+            match annotation.annotation_type {\n+                AnnotationType::MultilineStart(depth) |\n+                AnnotationType::MultilineEnd(depth) => {\n+                    draw_range(buffer,\n+                               '_',\n+                               line_offset + pos,\n+                               width_offset + depth,\n+                               code_offset + annotation.start_col,\n+                               style);\n+                }\n+                _ => (),\n+            }\n+        }\n \n-            // For each blank line, draw a `|` at our column. The\n-            // text ought to be long enough for this.\n-            for index in 2..blank_lines {\n-                if annotation.is_primary {\n-                    buffer.putc(line_offset + index,\n-                                width_offset + annotation.start_col,\n+        // Write the vertical lines for multiline spans and for labels that are\n+        // on a different line as the underline.\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  __________\n+        //   | |    |\n+        //   | |\n+        // 3 | |\n+        // 4 | | }\n+        //   | |_\n+        for &(pos, annotation) in &annotations_position {\n+            let style = if annotation.is_primary {\n+                Style::UnderlinePrimary\n+            } else {\n+                Style::UnderlineSecondary\n+            };\n+            let pos = pos + 1;\n+            if pos > 1 {\n+                for p in line_offset + 1..line_offset + pos + 1 {\n+                    buffer.putc(p,\n+                                code_offset + annotation.start_col,\n                                 '|',\n-                                Style::UnderlinePrimary);\n+                                style);\n+                }\n+            }\n+            match annotation.annotation_type {\n+                AnnotationType::MultilineStart(depth) => {\n+                    for p in line_offset + pos + 1..line_offset + line_len + 2 {\n+                        buffer.putc(p,\n+                                    width_offset + depth - 1,\n+                                    '|',\n+                                    style);\n+                    }\n+                }\n+                AnnotationType::MultilineEnd(depth) => {\n+                    for p in line_offset..line_offset + pos + 1 {\n+                        buffer.putc(p,\n+                                    width_offset + depth - 1,\n+                                    '|',\n+                                    style);\n+                    }\n+                }\n+                AnnotationType::MultilineLine(depth) => {\n+                    // the first line will have already be filled when we checked\n+                    // wether there were any annotations for this line.\n+                    for p in line_offset + 1..line_offset + line_len + 2 {\n+                        buffer.putc(p,\n+                                    width_offset + depth - 1,\n+                                    '|',\n+                                    style);\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        // Write the labels on the annotations that actually have a label.\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  __________ starting here...\n+        //   | |    |\n+        //   | |    something about `foo`\n+        // 3 | |\n+        // 4 | | }\n+        //   | |_  ...ending here: test\n+        for &(pos, annotation) in &annotations_position {\n+            let style = if annotation.is_primary {\n+                Style::LabelPrimary\n+            } else {\n+                Style::LabelSecondary\n+            };\n+            let (pos, col) = if pos == 0 {\n+                (pos + 1, annotation.end_col + 1)\n+            } else {\n+                (pos + 2, annotation.start_col)\n+            };\n+            if let Some(ref label) = annotation.label {\n+                buffer.puts(line_offset + pos,\n+                            code_offset + col,\n+                            &label,\n+                            style);\n+            }\n+        }\n+\n+        // Sort from biggest span to smallest span so that smaller spans are\n+        // represented in the output:\n+        //\n+        // x | fn foo()\n+        //   | ^^^---^^\n+        //   | |  |\n+        //   | |  something about `foo`\n+        //   | something about `fn foo()`\n+        annotations_position.sort_by(|a, b| {\n+            fn len(a: Annotation) -> usize {\n+                // Account for usize underflows\n+                if a.end_col > a.start_col {\n+                    a.end_col - a.start_col\n                 } else {\n-                    buffer.putc(line_offset + index,\n-                                width_offset + annotation.start_col,\n-                                '|',\n-                                Style::UnderlineSecondary);\n+                    a.start_col - a.end_col\n                 }\n-                draw_col_separator(buffer, line_offset + index, width_offset - 2);\n             }\n+            // Decreasing order\n+            len(a.1).cmp(&len(b.1)).reverse()\n+        });\n \n-            if annotation.is_primary {\n-                buffer.puts(line_offset + blank_lines,\n-                            width_offset + annotation.start_col,\n-                            annotation.label.as_ref().unwrap(),\n-                            Style::LabelPrimary);\n+        // Write the underlines.\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  ____-_____^ starting here...\n+        //   | |    |\n+        //   | |    something about `foo`\n+        // 3 | |\n+        // 4 | | }\n+        //   | |_^  ...ending here: test\n+        for &(_, annotation) in &annotations_position {\n+            let (underline, style) = if annotation.is_primary {\n+                ('^', Style::UnderlinePrimary)\n             } else {\n-                buffer.puts(line_offset + blank_lines,\n-                            width_offset + annotation.start_col,\n-                            annotation.label.as_ref().unwrap(),\n-                            Style::LabelSecondary);\n+                ('-', Style::UnderlineSecondary)\n+            };\n+            for p in annotation.start_col..annotation.end_col {\n+                buffer.putc(line_offset + 1,\n+                            code_offset + p,\n+                            underline,\n+                            style);\n             }\n-            draw_col_separator(buffer, line_offset + blank_lines, width_offset - 2);\n         }\n     }\n \n@@ -577,7 +828,8 @@ impl EmitterWriter {\n                 self.render_source_line(&mut buffer,\n                                         annotated_file.file.clone(),\n                                         &annotated_file.lines[line_idx],\n-                                        3 + max_line_num_len);\n+                                        3 + max_line_num_len,\n+                                        annotated_file.multiline_depth);\n \n                 // check to see if we need to print out or elide lines that come between\n                 // this annotated line and the next one\n@@ -729,16 +981,38 @@ fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n }\n \n fn draw_col_separator_no_space(buffer: &mut StyledBuffer, line: usize, col: usize) {\n-    buffer.puts(line, col, \"|\", Style::LineNumber);\n+    draw_col_separator_no_space_with_style(buffer, line, col, Style::LineNumber);\n+}\n+\n+fn draw_col_separator_no_space_with_style(buffer: &mut StyledBuffer,\n+                                          line: usize,\n+                                          col: usize,\n+                                          style: Style) {\n+    buffer.putc(line, col, '|', style);\n+}\n+\n+fn draw_range(buffer: &mut StyledBuffer, symbol: char, line: usize,\n+              col_from: usize, col_to: usize, style: Style) {\n+    for col in col_from..col_to {\n+        buffer.putc(line, col, symbol, style);\n+    }\n }\n \n fn draw_note_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n     buffer.puts(line, col, \"= \", Style::LineNumber);\n }\n \n+fn num_overlap(a_start: usize, a_end: usize, b_start: usize, b_end:usize, inclusive: bool) -> bool {\n+    let extra = if inclusive {\n+        1\n+    } else {\n+        0\n+    };\n+    (b_start..b_end + extra).contains(a_start) ||\n+    (a_start..a_end + extra).contains(b_start)\n+}\n fn overlaps(a1: &Annotation, a2: &Annotation) -> bool {\n-    (a2.start_col..a2.end_col).contains(a1.start_col) ||\n-    (a1.start_col..a1.end_col).contains(a2.start_col)\n+    num_overlap(a1.start_col, a1.end_col, a2.start_col, a2.end_col, false)\n }\n \n fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,"}, {"sha": "3bf428af994a2c71b31b819f329bb07bd17284e8", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 100, "deletions": 3, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -41,6 +41,57 @@ pub struct Line {\n     pub annotations: Vec<Annotation>,\n }\n \n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub enum AnnotationType {\n+    /// Annotation under a single line of code\n+    Singleline,\n+\n+    /// Annotation under the first character of a multiline span\n+    Minimized,\n+\n+    /// Annotation enclosing the first and last character of a multiline span\n+    Multiline {\n+        depth: usize,\n+        line_start: usize,\n+        line_end: usize,\n+    },\n+\n+    // The Multiline type above is replaced with the following three in order\n+    // to reuse the current label drawing code.\n+    //\n+    // Each of these corresponds to one part of the following diagram:\n+    //\n+    //     x |   foo(1 + bar(x,\n+    //       |  _________^ starting here...           < MultilineStart\n+    //     x | |             y),                      < MultilineLine\n+    //       | |______________^ ...ending here: label < MultilineEnd\n+    //     x |       z);\n+    /// Annotation marking the first character of a fully shown multiline span\n+    MultilineStart(usize),\n+    /// Annotation marking the last character of a fully shown multiline span\n+    MultilineEnd(usize),\n+    /// Line at the left enclosing the lines of a fully shown multiline span\n+    MultilineLine(usize),\n+}\n+\n+impl AnnotationType {\n+    pub fn depth(&self) -> usize {\n+        match self {\n+            &AnnotationType::Multiline {depth, ..} |\n+                &AnnotationType::MultilineStart(depth) |\n+                &AnnotationType::MultilineLine(depth) |\n+                &AnnotationType::MultilineEnd(depth) => depth,\n+            _ => 0,\n+        }\n+    }\n+\n+    pub fn increase_depth(&mut self) {\n+        if let AnnotationType::Multiline {ref mut depth, ..} = *self {\n+            *depth += 1;\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub struct Annotation {\n     /// Start column, 0-based indexing -- counting *characters*, not\n@@ -55,11 +106,57 @@ pub struct Annotation {\n     /// Is this annotation derived from primary span\n     pub is_primary: bool,\n \n-    /// Is this a large span minimized down to a smaller span\n-    pub is_minimized: bool,\n-\n     /// Optional label to display adjacent to the annotation.\n     pub label: Option<String>,\n+\n+    /// Is this a single line, multiline or multiline span minimized down to a\n+    /// smaller span.\n+    pub annotation_type: AnnotationType,\n+}\n+\n+impl Annotation {\n+    pub fn is_minimized(&self) -> bool {\n+        match self.annotation_type {\n+            AnnotationType::Minimized => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_multiline(&self) -> bool {\n+        match self.annotation_type {\n+            AnnotationType::Multiline {..} |\n+                AnnotationType::MultilineStart(_) |\n+                AnnotationType::MultilineLine(_) |\n+                AnnotationType::MultilineEnd(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn as_start(&self) -> Annotation {\n+        let mut a = self.clone();\n+        a.annotation_type = AnnotationType::MultilineStart(self.annotation_type.depth());\n+        a.end_col = a.start_col + 1;\n+        a.label = Some(\"starting here...\".to_owned());\n+        a\n+    }\n+\n+    pub fn as_end(&self) -> Annotation {\n+        let mut a = self.clone();\n+        a.annotation_type = AnnotationType::MultilineEnd(self.annotation_type.depth());\n+        a.start_col = a.end_col - 1;\n+        a.label = match a.label {\n+            Some(l) => Some(format!(\"...ending here: {}\", l)),\n+            None => Some(\"..ending here\".to_owned()),\n+        };\n+        a\n+    }\n+\n+    pub fn as_line(&self) -> Annotation {\n+        let mut a = self.clone();\n+        a.annotation_type = AnnotationType::MultilineLine(self.annotation_type.depth());\n+        a.label = None;\n+        a\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "0545cccabf720cc26b79b9163da1015a974251e6", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -144,4 +144,7 @@ pub mod ext {\n     }\n }\n \n+#[cfg(test)]\n+mod test_snippet;\n+\n // __build_diagnostic_array! { libsyntax, DIAGNOSTICS }"}, {"sha": "4ce51076adcf458d20d5ed36190903d75c71679f", "filename": "src/libsyntax/test_snippet.rs", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -0,0 +1,446 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use codemap::CodeMap;\n+use errors::Handler;\n+use errors::emitter::EmitterWriter;\n+use std::io;\n+use std::io::prelude::*;\n+use std::rc::Rc;\n+use std::str;\n+use std::sync::{Arc, Mutex};\n+use syntax_pos::{BytePos, NO_EXPANSION, Span, MultiSpan};\n+\n+/// Identify a position in the text by the Nth occurrence of a string.\n+struct Position {\n+    string: &'static str,\n+    count: usize,\n+}\n+\n+struct SpanLabel {\n+    start: Position,\n+    end: Position,\n+    label: &'static str,\n+}\n+\n+struct Shared<T: Write> {\n+    data: Arc<Mutex<T>>,\n+}\n+\n+impl<T: Write> Write for Shared<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.data.lock().unwrap().write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.data.lock().unwrap().flush()\n+    }\n+}\n+\n+fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &str) {\n+    let output = Arc::new(Mutex::new(Vec::new()));\n+\n+    let code_map = Rc::new(CodeMap::new());\n+    code_map.new_filemap_and_lines(\"test.rs\", None, &file_text);\n+\n+    let primary_span = make_span(&file_text, &span_labels[0].start, &span_labels[0].end);\n+    let mut msp = MultiSpan::from_span(primary_span);\n+    for span_label in span_labels {\n+        let span = make_span(&file_text, &span_label.start, &span_label.end);\n+        msp.push_span_label(span, span_label.label.to_string());\n+        println!(\"span: {:?} label: {:?}\", span, span_label.label);\n+        println!(\"text: {:?}\", code_map.span_to_snippet(span));\n+    }\n+\n+    let emitter = EmitterWriter::new(Box::new(Shared { data: output.clone() }),\n+                                     Some(code_map.clone()));\n+    let handler = Handler::with_emitter(true, false, Box::new(emitter));\n+    handler.span_err(msp, \"foo\");\n+\n+    assert!(expected_output.chars().next() == Some('\\n'),\n+            \"expected output should begin with newline\");\n+    let expected_output = &expected_output[1..];\n+\n+    let bytes = output.lock().unwrap();\n+    let actual_output = str::from_utf8(&bytes).unwrap();\n+    println!(\"expected output:\\n------\\n{}------\", expected_output);\n+    println!(\"actual output:\\n------\\n{}------\", actual_output);\n+\n+    assert!(expected_output == actual_output)\n+}\n+\n+fn make_span(file_text: &str, start: &Position, end: &Position) -> Span {\n+    let start = make_pos(file_text, start);\n+    let end = make_pos(file_text, end) + end.string.len(); // just after matching thing ends\n+    assert!(start <= end);\n+    Span {\n+        lo: BytePos(start as u32),\n+        hi: BytePos(end as u32),\n+        expn_id: NO_EXPANSION,\n+    }\n+}\n+\n+fn make_pos(file_text: &str, pos: &Position) -> usize {\n+    let mut remainder = file_text;\n+    let mut offset = 0;\n+    for _ in 0..pos.count {\n+        if let Some(n) = remainder.find(&pos.string) {\n+            offset += n;\n+            remainder = &remainder[n + 1..];\n+        } else {\n+            panic!(\"failed to find {} instances of {:?} in {:?}\",\n+                   pos.count,\n+                   pos.string,\n+                   file_text);\n+        }\n+    }\n+    offset\n+}\n+\n+#[test]\n+fn ends_on_col0() {\n+    test_harness(r#\"\n+fn foo() {\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+           start: Position {\n+               string: \"{\",\n+               count: 1,\n+           },\n+           end: Position {\n+               string: \"}\",\n+               count: 1,\n+           },\n+           label: \"test\",\n+       },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:2:10\n+  |\n+2 |   fn foo() {\n+  |  __________^ starting here...\n+3 | | }\n+  | |_^ ...ending here: test\n+\n+\"#);\n+}\n+\n+#[test]\n+fn ends_on_col2() {\n+    test_harness(r#\"\n+fn foo() {\n+\n+\n+  }\n+\"#,\n+     vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"{\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"}\",\n+                count: 1,\n+            },\n+            label: \"test\",\n+        },\n+     ],\n+     r#\"\n+error: foo\n+ --> test.rs:2:10\n+  |\n+2 |   fn foo() {\n+  |  __________^ starting here...\n+3 | |\n+4 | |\n+5 | |   }\n+  | |___^ ...ending here: test\n+\n+\"#);\n+}\n+#[test]\n+fn non_nested() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0\n+  X1 Y1\n+  X2 Y2\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"X0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X2\",\n+                count: 1,\n+            },\n+            label: \"`X` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Y2\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter too\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |      X0 Y0\n+  |  ____^__- starting here...\n+  | | ___|\n+  | ||   starting here...\n+4 | ||   X1 Y1\n+5 | ||   X2 Y2\n+  | ||____^__- ...ending here: `Y` is a good letter too\n+  |  |____|\n+  |       ...ending here: `X` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn nested() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0\n+  Y1 X1\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"X0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X1\",\n+                count: 1,\n+            },\n+            label: \"`X` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Y1\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter too\",\n+        },\n+    ],\n+r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |      X0 Y0\n+  |  ____^__- starting here...\n+  | | ___|\n+  | ||   starting here...\n+4 | ||   Y1 X1\n+  | ||____-__^ ...ending here: `X` is a good letter\n+  | |_____|\n+  |       ...ending here: `Y` is a good letter too\n+\n+\"#);\n+}\n+\n+#[test]\n+fn different_overlap() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0 Z0\n+  X1 Y1 Z1\n+  X2 Y2 Z2\n+  X3 Y3 Z3\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X2\",\n+                count: 1,\n+            },\n+            label: \"`X` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Z1\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X3\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter too\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:6\n+  |\n+3 |      X0 Y0 Z0\n+  |   ______^ starting here...\n+4 |  |   X1 Y1 Z1\n+  |  |_________- starting here...\n+5 | ||   X2 Y2 Z2\n+  | ||____^ ...ending here: `X` is a good letter\n+6 | |    X3 Y3 Z3\n+  | |_____- ...ending here: `Y` is a good letter too\n+\n+\"#);\n+}\n+\n+#[test]\n+fn triple_overlap() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0 Z0\n+  X1 Y1 Z1\n+  X2 Y2 Z2\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"X0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X2\",\n+                count: 1,\n+            },\n+            label: \"`X` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Y2\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter too\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Z0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Z2\",\n+                count: 1,\n+            },\n+            label: \"`Z` label\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:3\n+  |\n+3 |       X0 Y0 Z0\n+  |  _____^__-__- starting here...\n+  | | ____|__|\n+  | || ___|  starting here...\n+  | |||   starting here...\n+4 | |||   X1 Y1 Z1\n+5 | |||   X2 Y2 Z2\n+  | |||____^__-__- ...ending here: `Z` label\n+  |  ||____|__|\n+  |   |____|  ...ending here: `Y` is a good letter too\n+  |        ...ending here: `X` is a good letter\n+\n+\"#);\n+}\n+\n+#[test]\n+fn minimum_depth() {\n+    test_harness(r#\"\n+fn foo() {\n+  X0 Y0 Z0\n+  X1 Y1 Z1\n+  X2 Y2 Z2\n+  X3 Y3 Z3\n+}\n+\"#,\n+    vec![\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y0\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"X1\",\n+                count: 1,\n+            },\n+            label: \"`X` is a good letter\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"Y1\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Z2\",\n+                count: 1,\n+            },\n+            label: \"`Y` is a good letter too\",\n+        },\n+        SpanLabel {\n+            start: Position {\n+                string: \"X2\",\n+                count: 1,\n+            },\n+            end: Position {\n+                string: \"Y3\",\n+                count: 1,\n+            },\n+            label: \"`Z`\",\n+        },\n+    ],\n+    r#\"\n+error: foo\n+ --> test.rs:3:6\n+  |\n+3 |      X0 Y0 Z0\n+  |   ______^ starting here...\n+4 |  |   X1 Y1 Z1\n+  |  |____^_- starting here...\n+  | ||____|\n+  | |     ...ending here: `X` is a good letter\n+5 | |    X2 Y2 Z2\n+  | |____-______- ...ending here: `Y` is a good letter too\n+  |  ____|\n+  | |    starting here...\n+6 | |    X3 Y3 Z3\n+  | |________- ...ending here: `Z`\n+\n+\"#);\n+}"}, {"sha": "12b0ecabcc72053403e002fe6a506efe2185cf5d", "filename": "src/test/ui/compare-method/region-extra-2.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra-2.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -1,11 +1,15 @@\n error[E0276]: impl has stricter requirements than trait\n   --> $DIR/region-extra-2.rs:19:5\n    |\n-15 |     fn renew<'b: 'a>(self) -> &'b mut [T];\n-   |     -------------------------------------- definition of `renew` from trait\n+15 |       fn renew<'b: 'a>(self) -> &'b mut [T];\n+   |       -------------------------------------- definition of `renew` from trait\n ...\n-19 |     fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n-   |     ^ impl has extra requirement `'a: 'b`\n+19 |       fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n+   |  _____^ starting here...\n+20 | |         //~^ ERROR E0276\n+21 | |         &mut self[..]\n+22 | |     }\n+   | |_____^ ...ending here: impl has extra requirement `'a: 'b`\n \n error: aborting due to previous error\n "}, {"sha": "77b056f69789249f722f0ac6c7e6f36f60d0e692", "filename": "src/test/ui/compare-method/traits-misc-mismatch-2.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Ftraits-misc-mismatch-2.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -1,11 +1,15 @@\n error[E0276]: impl has stricter requirements than trait\n   --> $DIR/traits-misc-mismatch-2.rs:23:5\n    |\n-19 |     fn zip<B, U: Iterator<U>>(self, other: U) -> ZipIterator<Self, U>;\n-   |     ------------------------------------------------------------------ definition of `zip` from trait\n+19 |       fn zip<B, U: Iterator<U>>(self, other: U) -> ZipIterator<Self, U>;\n+   |       ------------------------------------------------------------------ definition of `zip` from trait\n ...\n-23 |     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n-   |     ^ impl has extra requirement `U: Iterator<B>`\n+23 |       fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n+   |  _____^ starting here...\n+24 | |     //~^ ERROR E0276\n+25 | |         ZipIterator{a: self, b: other}\n+26 | |     }\n+   | |_____^ ...ending here: impl has extra requirement `U: Iterator<B>`\n \n error: aborting due to previous error\n "}, {"sha": "b3e72f28d88c8af6c3f42003207f1eb916ac83a4", "filename": "src/test/ui/dropck/dropck-eyepatch-implies-unsafe-impl.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -1,14 +1,26 @@\n error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n   --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:32:1\n    |\n-32 | impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n-   | ^\n+32 |   impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+   |  _^ starting here...\n+33 | |     //~^ ERROR requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+34 | |\n+35 | |     // (unsafe to access self.1  due to #[may_dangle] on A)\n+36 | |     fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+37 | | }\n+   | |_^ ..ending here\n \n error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n   --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:38:1\n    |\n-38 | impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n-   | ^\n+38 |   impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+   |  _^ starting here...\n+39 | |     //~^ ERROR requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n+40 | |\n+41 | |     // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+42 | |     fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+43 | | }\n+   | |_^ ..ending here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1d1bc58805aaeaa3ad4d5b4056d6bea85be09e1b", "filename": "src/test/ui/lifetimes/consider-using-explicit-lifetime.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -15,8 +15,11 @@ error[E0495]: cannot infer an appropriate lifetime due to conflicting requiremen\n help: consider using an explicit lifetime parameter as shown: fn from_str(path: &'a str) -> Result<Self, ()>\n   --> $DIR/consider-using-explicit-lifetime.rs:25:5\n    |\n-25 |     fn from_str(path: &str) -> Result<Self, ()> {\n-   |     ^\n+25 |       fn from_str(path: &str) -> Result<Self, ()> {\n+   |  _____^ starting here...\n+26 | |         Ok(Foo { field: path })\n+27 | |     }\n+   | |_____^ ..ending here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c87b635521eab94ed9514031084259036c792920", "filename": "src/test/ui/mismatched_types/main.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -1,8 +1,10 @@\n error[E0308]: mismatched types\n   --> $DIR/main.rs:12:18\n    |\n-12 |     let x: u32 = (\n-   |                  ^ expected u32, found ()\n+12 |       let x: u32 = (\n+   |  __________________^ starting here...\n+13 | |     );\n+   | |_____^ ...ending here: expected u32, found ()\n    |\n    = note: expected type `u32`\n    = note:    found type `()`"}, {"sha": "3313543454469073e8d16e034372d50ffde3cbac", "filename": "src/test/ui/missing-items/m2.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fmissing-items%2Fm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fmissing-items%2Fm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing-items%2Fm2.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -3,8 +3,10 @@ error: main function not found\n error[E0046]: not all trait items implemented, missing: `CONSTANT`, `Type`, `method`\n   --> $DIR/m2.rs:20:1\n    |\n-20 | impl m1::X for X {\n-   | ^ missing `CONSTANT`, `Type`, `method` in implementation\n+20 |   impl m1::X for X {\n+   |  _^ starting here...\n+21 | | }\n+   | |_^ ...ending here: missing `CONSTANT`, `Type`, `method` in implementation\n    |\n    = note: `CONSTANT` from trait: `const CONSTANT: u32;`\n    = note: `Type` from trait: `type Type;`"}, {"sha": "5c352436c3ea0e14ffa1de6602112ade00929081", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -10,11 +10,19 @@ error[E0323]: item `bar` is an associated const, which doesn't match its trait `\n error[E0046]: not all trait items implemented, missing: `bar`\n   --> $DIR/impl-wrong-item-for-trait.rs:22:1\n    |\n-16 |     fn bar(&self);\n-   |     -------------- `bar` from trait\n+16 |       fn bar(&self);\n+   |       -------------- `bar` from trait\n ...\n-22 | impl Foo for FooConstForMethod {\n-   | ^ missing `bar` in implementation\n+22 |   impl Foo for FooConstForMethod {\n+   |  _^ starting here...\n+23 | |     //~^ ERROR E0046\n+24 | |     //~| NOTE missing `bar` in implementation\n+25 | |     const bar: u64 = 1;\n+26 | |     //~^ ERROR E0323\n+27 | |     //~| NOTE does not match trait\n+28 | |     const MY_CONST: u32 = 1;\n+29 | | }\n+   | |_^ ...ending here: missing `bar` in implementation\n \n error[E0324]: item `MY_CONST` is an associated method, which doesn't match its trait `<FooMethodForConst as Foo>`\n   --> $DIR/impl-wrong-item-for-trait.rs:37:5\n@@ -28,11 +36,19 @@ error[E0324]: item `MY_CONST` is an associated method, which doesn't match its t\n error[E0046]: not all trait items implemented, missing: `MY_CONST`\n   --> $DIR/impl-wrong-item-for-trait.rs:33:1\n    |\n-17 |     const MY_CONST: u32;\n-   |     -------------------- `MY_CONST` from trait\n+17 |       const MY_CONST: u32;\n+   |       -------------------- `MY_CONST` from trait\n ...\n-33 | impl Foo for FooMethodForConst {\n-   | ^ missing `MY_CONST` in implementation\n+33 |   impl Foo for FooMethodForConst {\n+   |  _^ starting here...\n+34 | |     //~^ ERROR E0046\n+35 | |     //~| NOTE missing `MY_CONST` in implementation\n+36 | |     fn bar(&self) {}\n+37 | |     fn MY_CONST() {}\n+38 | |     //~^ ERROR E0324\n+39 | |     //~| NOTE does not match trait\n+40 | | }\n+   | |_^ ...ending here: missing `MY_CONST` in implementation\n \n error[E0325]: item `bar` is an associated type, which doesn't match its trait `<FooTypeForMethod as Foo>`\n   --> $DIR/impl-wrong-item-for-trait.rs:47:5\n@@ -46,17 +62,27 @@ error[E0325]: item `bar` is an associated type, which doesn't match its trait `<\n error[E0046]: not all trait items implemented, missing: `bar`\n   --> $DIR/impl-wrong-item-for-trait.rs:44:1\n    |\n-16 |     fn bar(&self);\n-   |     -------------- `bar` from trait\n+16 |       fn bar(&self);\n+   |       -------------- `bar` from trait\n ...\n-44 | impl Foo for FooTypeForMethod {\n-   | ^ missing `bar` in implementation\n+44 |   impl Foo for FooTypeForMethod {\n+   |  _^ starting here...\n+45 | |     //~^ ERROR E0046\n+46 | |     //~| NOTE missing `bar` in implementation\n+47 | |     type bar = u64;\n+48 | |     //~^ ERROR E0325\n+49 | |     //~| NOTE does not match trait\n+50 | |     const MY_CONST: u32 = 1;\n+51 | | }\n+   | |_^ ...ending here: missing `bar` in implementation\n \n error[E0046]: not all trait items implemented, missing: `fmt`\n   --> $DIR/impl-wrong-item-for-trait.rs:53:1\n    |\n-53 | impl Debug for FooTypeForMethod {\n-   | ^ missing `fmt` in implementation\n+53 |   impl Debug for FooTypeForMethod {\n+   |  _^ starting here...\n+54 | | }\n+   | |_^ ...ending here: missing `fmt` in implementation\n    |\n    = note: `fmt` from trait: `fn(&Self, &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error>`\n "}, {"sha": "6c1c246753011d907a3df7d00185e8f2498c4237", "filename": "src/test/ui/span/issue-23827.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -1,8 +1,16 @@\n error[E0046]: not all trait items implemented, missing: `Output`\n   --> $DIR/issue-23827.rs:36:1\n    |\n-36 | impl<C: Component> FnOnce<(C,)> for Prototype {\n-   | ^ missing `Output` in implementation\n+36 |   impl<C: Component> FnOnce<(C,)> for Prototype {\n+   |  _^ starting here...\n+37 | |     //~^ ERROR E0046\n+38 | |     //~| NOTE missing `Output` in implementation\n+39 | |     //~| NOTE `Output` from trait: `type Output;`\n+40 | |     extern \"rust-call\" fn call_once(self, (comp,): (C,)) -> Prototype {\n+41 | |         Fn::call(&self, (comp,))\n+42 | |     }\n+43 | | }\n+   | |_^ ...ending here: missing `Output` in implementation\n    |\n    = note: `Output` from trait: `type Output;`\n "}, {"sha": "963f4bd9bbcd8ac432569b16b33e304de5e535ea", "filename": "src/test/ui/span/issue-24356.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -1,8 +1,14 @@\n error[E0046]: not all trait items implemented, missing: `Target`\n   --> $DIR/issue-24356.rs:30:9\n    |\n-30 |         impl Deref for Thing {\n-   |         ^ missing `Target` in implementation\n+30 |           impl Deref for Thing {\n+   |  _________^ starting here...\n+31 | |             //~^ ERROR E0046\n+32 | |             //~| NOTE missing `Target` in implementation\n+33 | |             //~| NOTE `Target` from trait: `type Target;`\n+34 | |             fn deref(&self) -> i8 { self.0 }\n+35 | |         }\n+   | |_________^ ...ending here: missing `Target` in implementation\n    |\n    = note: `Target` from trait: `type Target;`\n "}, {"sha": "16414766f398e9e2b71ea99fe7f3a1311b58f481", "filename": "src/test/ui/span/multiline-span-simple.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.rs?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(a: u32, b: u32) {\n+    a + b;\n+}\n+\n+fn bar(a: u32, b: u32) {\n+    a + b;\n+}\n+\n+fn main() {\n+    let x = 1;\n+    let y = 2;\n+    let z = 3;\n+    foo(1 +\n+\n+        bar(x,\n+\n+            y),\n+\n+        z)\n+}"}, {"sha": "26acef64c896fce8109df305885fe79201d2f5ca", "filename": "src/test/ui/span/multiline-span-simple.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb53ca3aad616069cb8f6f8fff71c27e9ba9640c/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr?ref=eb53ca3aad616069cb8f6f8fff71c27e9ba9640c", "patch": "@@ -0,0 +1,20 @@\n+error[E0277]: the trait bound `{integer}: std::ops::Add<()>` is not satisfied\n+  --> $DIR/multiline-span-simple.rs:23:9\n+   |\n+23 |       foo(1 +\n+   |  _________^ starting here...\n+24 | |\n+25 | |         bar(x,\n+26 | |\n+27 | |             y),\n+   | |______________^ ...ending here: the trait `std::ops::Add<()>` is not implemented for `{integer}`\n+   |\n+   = help: the following implementations were found:\n+   = help:   <u32 as std::ops::Add>\n+   = help:   <&'a u32 as std::ops::Add<u32>>\n+   = help:   <u32 as std::ops::Add<&'a u32>>\n+   = help:   <&'b u32 as std::ops::Add<&'a u32>>\n+   = help: and 90 others\n+\n+error: aborting due to previous error\n+"}]}