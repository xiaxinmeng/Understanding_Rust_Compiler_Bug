{"sha": "1f7080246562a7dd3c3dee006d1fc7754029c8bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNzA4MDI0NjU2MmE3ZGQzYzNkZWUwMDZkMWZjNzc1NDAyOWM4YmM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-26T09:09:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-26T09:09:13Z"}, "message": "Merge pull request #1189 from bjorn3/stdsimd_fixes\n\nImprove stdsimd support", "tree": {"sha": "7035b0cbcbf7bc59ee72b128c9b71032325ffe54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7035b0cbcbf7bc59ee72b128c9b71032325ffe54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f7080246562a7dd3c3dee006d1fc7754029c8bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg/nu5CRBK7hj4Ov3rIwAAU1gIAF8eM9a5Y9LrMLX6ee7A4MUs\nx2YTlmzZ1xy6soZyXhsyiV3uYGk1UNm+Fw8Ms7wTvKkDm/pNenZcXtGLKdDyQEr/\nxQ2B6DA3JGgktdrfrqhkAuk2bFklhMwJITveO7l3nu0hiAC9+Z0vuIjtTIgS4sSJ\nd+8h7uyI7fo9YYztgZUmTIlCgxSczvyu/d7YkFg82xtGbdloXAMYP8rFP1B4Pkv6\nCQCyhFoHC29anRmyc5+Ix1OBKucdBqh8qQYaTSfSKuUaa8EBJMN7Yxmq0iNJ4syh\nucV8wHfgzE440xld0Rwmgi4R+IdKuofxIF9jEv2JmuiQl3G8y2ctudGf5beX0KE=\n=m2Tp\n-----END PGP SIGNATURE-----\n", "payload": "tree 7035b0cbcbf7bc59ee72b128c9b71032325ffe54\nparent 356360836e128e1d1eb11caf6ff5186efb211960\nparent 581e38b97c8431be06e74a5c8c22c8e1e78cf368\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1627290553 +0200\ncommitter GitHub <noreply@github.com> 1627290553 +0200\n\nMerge pull request #1189 from bjorn3/stdsimd_fixes\n\nImprove stdsimd support"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7080246562a7dd3c3dee006d1fc7754029c8bc", "html_url": "https://github.com/rust-lang/rust/commit/1f7080246562a7dd3c3dee006d1fc7754029c8bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f7080246562a7dd3c3dee006d1fc7754029c8bc/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "356360836e128e1d1eb11caf6ff5186efb211960", "url": "https://api.github.com/repos/rust-lang/rust/commits/356360836e128e1d1eb11caf6ff5186efb211960", "html_url": "https://github.com/rust-lang/rust/commit/356360836e128e1d1eb11caf6ff5186efb211960"}, {"sha": "581e38b97c8431be06e74a5c8c22c8e1e78cf368", "url": "https://api.github.com/repos/rust-lang/rust/commits/581e38b97c8431be06e74a5c8c22c8e1e78cf368", "html_url": "https://github.com/rust-lang/rust/commit/581e38b97c8431be06e74a5c8c22c8e1e78cf368"}], "stats": {"total": 494, "additions": 453, "deletions": 41}, "files": [{"sha": "4b2051b605abdd726c99682639f95f5c8a7deeb3", "filename": "build_system/prepare.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f7080246562a7dd3c3dee006d1fc7754029c8bc/build_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7080246562a7dd3c3dee006d1fc7754029c8bc/build_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fprepare.rs?ref=1f7080246562a7dd3c3dee006d1fc7754029c8bc", "patch": "@@ -27,6 +27,13 @@ pub(crate) fn prepare() {\n         \"341f207c1071f7290e3f228c710817c280c8dca1\",\n     );\n \n+    clone_repo(\n+        \"stdsimd\",\n+        \"https://github.com/rust-lang/stdsimd\",\n+        \"be96995d8ddec03fac9a0caf4d4c51c7fbc33507\",\n+    );\n+    apply_patches(\"stdsimd\", Path::new(\"stdsimd\"));\n+\n     clone_repo(\n         \"simple-raytracer\",\n         \"https://github.com/ebobby/simple-raytracer\",\n@@ -60,11 +67,7 @@ fn prepare_sysroot() {\n     copy_dir_recursively(&sysroot_src_orig.join(\"library\"), &sysroot_src.join(\"library\"));\n \n     let rustc_version = get_rustc_version();\n-    fs::write(\n-        Path::new(\"build_sysroot\").join(\"rustc_version\"),\n-        &rustc_version,\n-    )\n-    .unwrap();\n+    fs::write(Path::new(\"build_sysroot\").join(\"rustc_version\"), &rustc_version).unwrap();\n \n     eprintln!(\"[GIT] init\");\n     let mut git_init_cmd = Command::new(\"git\");"}, {"sha": "b24f67f3edc3067df057f13b3d630a301d87b0c4", "filename": "patches/0001-stdsimd-Disable-unsupported-tests.patch", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/1f7080246562a7dd3c3dee006d1fc7754029c8bc/patches%2F0001-stdsimd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/1f7080246562a7dd3c3dee006d1fc7754029c8bc/patches%2F0001-stdsimd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-stdsimd-Disable-unsupported-tests.patch?ref=1f7080246562a7dd3c3dee006d1fc7754029c8bc", "patch": "@@ -0,0 +1,181 @@\n+From 6bfce5dc2cbf834c74dbccb7538adc08c6eb57e7 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sun, 25 Jul 2021 18:39:31 +0200\n+Subject: [PATCH] Disable unsupported tests\n+\n+---\n+ crates/core_simd/src/array.rs        |  2 ++\n+ crates/core_simd/src/lib.rs          |  2 +-\n+ crates/core_simd/src/math.rs         |  4 ++++\n+ crates/core_simd/tests/masks.rs      | 12 ------------\n+ crates/core_simd/tests/ops_macros.rs |  6 ++++++\n+ crates/core_simd/tests/round.rs      |  2 ++\n+ 6 files changed, 15 insertions(+), 13 deletions(-)\n+\n+diff --git a/crates/core_simd/src/array.rs b/crates/core_simd/src/array.rs\n+index 25c5309..2b3d819 100644\n+--- a/crates/core_simd/src/array.rs\n++++ b/crates/core_simd/src/array.rs\n+@@ -22,6 +22,7 @@ where\n+     #[must_use]\n+     fn splat(val: Self::Scalar) -> Self;\n+ \n++    /*\n+     /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+     /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n+     /// ```\n+@@ -150,6 +151,7 @@ where\n+             // Cleared \u2622\ufe0f *mut T Zone\n+         }\n+     }\n++    */\n+ }\n+ \n+ macro_rules! impl_simdarray_for {\n+diff --git a/crates/core_simd/src/lib.rs b/crates/core_simd/src/lib.rs\n+index a64904d..299eb11 100644\n+--- a/crates/core_simd/src/lib.rs\n++++ b/crates/core_simd/src/lib.rs\n+@@ -1,7 +1,7 @@\n+ #![no_std]\n+ #![allow(incomplete_features)]\n+ #![feature(\n+-    const_generics, \n++    const_generics,\n+     platform_intrinsics,\n+     repr_simd,\n+     simd_ffi,\n+diff --git a/crates/core_simd/src/math.rs b/crates/core_simd/src/math.rs\n+index 7290a28..e394730 100644\n+--- a/crates/core_simd/src/math.rs\n++++ b/crates/core_simd/src/math.rs\n+@@ -2,6 +2,7 @@ macro_rules! impl_uint_arith {\n+     ($(($name:ident, $n:ident)),+) => {\n+         $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n+ \n++            /*\n+             /// Lanewise saturating add.\n+             ///\n+             /// # Examples\n+@@ -38,6 +39,7 @@ macro_rules! impl_uint_arith {\n+             pub fn saturating_sub(self, second: Self) -> Self {\n+                 unsafe { crate::intrinsics::simd_saturating_sub(self, second) }\n+             }\n++            */\n+         })+\n+     }\n+ }\n+@@ -46,6 +48,7 @@ macro_rules! impl_int_arith {\n+     ($(($name:ident, $n:ident)),+) => {\n+         $( impl<const LANES: usize> $name<LANES> where Self: crate::LanesAtMost32 {\n+ \n++            /*\n+             /// Lanewise saturating add.\n+             ///\n+             /// # Examples\n+@@ -141,6 +144,7 @@ macro_rules! impl_int_arith {\n+             pub fn saturating_neg(self) -> Self {\n+                 Self::splat(0).saturating_sub(self)\n+             }\n++            */\n+         })+\n+     }\n+ }\n+diff --git a/crates/core_simd/tests/masks.rs b/crates/core_simd/tests/masks.rs\n+index 61d8e44..2bccae2 100644\n+--- a/crates/core_simd/tests/masks.rs\n++++ b/crates/core_simd/tests/masks.rs\n+@@ -67,18 +67,6 @@ macro_rules! test_mask_api {\n+                 assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n+                 assert_eq!(core_simd::$name::<8>::from_int(int), mask);\n+             }\n+-\n+-            #[test]\n+-            fn roundtrip_bitmask_conversion() {\n+-                let values = [\n+-                    true, false, false, true, false, false, true, false,\n+-                    true, true, false, false, false, false, false, true,\n+-                ];\n+-                let mask = core_simd::$name::<16>::from_array(values);\n+-                let bitmask = mask.to_bitmask();\n+-                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+-                assert_eq!(core_simd::$name::<16>::from_bitmask(bitmask), mask);\n+-            }\n+         }\n+     }\n+ }\n+diff --git a/crates/core_simd/tests/ops_macros.rs b/crates/core_simd/tests/ops_macros.rs\n+index cb39e73..fc0ebe1 100644\n+--- a/crates/core_simd/tests/ops_macros.rs\n++++ b/crates/core_simd/tests/ops_macros.rs\n+@@ -435,6 +435,7 @@ macro_rules! impl_float_tests {\n+                     )\n+                 }\n+ \n++                /*\n+                 fn mul_add<const LANES: usize>() {\n+                     test_helpers::test_ternary_elementwise(\n+                         &Vector::<LANES>::mul_add,\n+@@ -442,6 +443,7 @@ macro_rules! impl_float_tests {\n+                         &|_, _, _| true,\n+                     )\n+                 }\n++                */\n+ \n+                 fn sqrt<const LANES: usize>() {\n+                     test_helpers::test_unary_elementwise(\n+@@ -491,6 +493,7 @@ macro_rules! impl_float_tests {\n+                     )\n+                 }\n+ \n++                /*\n+                 fn min<const LANES: usize>() {\n+                     // Regular conditions (both values aren't zero)\n+                     test_helpers::test_binary_elementwise(\n+@@ -536,6 +539,7 @@ macro_rules! impl_float_tests {\n+                     assert!(p_zero.max(n_zero).to_array().iter().all(|x| *x == 0.));\n+                     assert!(n_zero.max(p_zero).to_array().iter().all(|x| *x == 0.));\n+                 }\n++                */\n+ \n+                 fn clamp<const LANES: usize>() {\n+                     test_helpers::test_3(&|value: [Scalar; LANES], mut min: [Scalar; LANES], mut max: [Scalar; LANES]| {\n+@@ -581,6 +585,7 @@ macro_rules! impl_float_tests {\n+                     });\n+                 }\n+ \n++                /*\n+                 fn horizontal_max<const LANES: usize>() {\n+                     test_helpers::test_1(&|x| {\n+                         let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n+@@ -604,6 +609,7 @@ macro_rules! impl_float_tests {\n+                         Ok(())\n+                     });\n+                 }\n++                */\n+             }\n+         }\n+     }\n+diff --git a/crates/core_simd/tests/round.rs b/crates/core_simd/tests/round.rs\n+index 37044a7..4cdc6b7 100644\n+--- a/crates/core_simd/tests/round.rs\n++++ b/crates/core_simd/tests/round.rs\n+@@ -25,6 +25,7 @@ macro_rules! float_rounding_test {\n+                     )\n+                 }\n+ \n++                /*\n+                 fn round<const LANES: usize>() {\n+                     test_helpers::test_unary_elementwise(\n+                         &Vector::<LANES>::round,\n+@@ -32,6 +33,7 @@ macro_rules! float_rounding_test {\n+                         &|_| true,\n+                     )\n+                 }\n++                */\n+ \n+                 fn trunc<const LANES: usize>() {\n+                     test_helpers::test_unary_elementwise(\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "1b8858eb4ab7c830e22a80525edfe749e0b59046", "filename": "scripts/tests.sh", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f7080246562a7dd3c3dee006d1fc7754029c8bc/scripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1f7080246562a7dd3c3dee006d1fc7754029c8bc/scripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftests.sh?ref=1f7080246562a7dd3c3dee006d1fc7754029c8bc", "patch": "@@ -136,6 +136,14 @@ function extended_sysroot_tests() {\n         ../build/cargo build --tests --target $TARGET_TRIPLE\n     fi\n     popd\n+\n+    pushd stdsimd\n+    echo \"[TEST] rust-lang/stdsimd\"\n+    ../build/cargo build --all-targets --target $TARGET_TRIPLE\n+    if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+        ../build/cargo test -q\n+    fi\n+    popd\n }\n \n case \"$1\" in"}, {"sha": "17c79645eb24c0651b567fa0f64bd2696e0b8eb6", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1f7080246562a7dd3c3dee006d1fc7754029c8bc/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7080246562a7dd3c3dee006d1fc7754029c8bc/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=1f7080246562a7dd3c3dee006d1fc7754029c8bc", "patch": "@@ -175,12 +175,11 @@ fn simd_for_each_lane<'tcx>(\n     assert_eq!(lane_count, ret_lane_count);\n \n     for lane_idx in 0..lane_count {\n-        let lane_idx = mir::Field::new(lane_idx.try_into().unwrap());\n-        let lane = val.value_field(fx, lane_idx).load_scalar(fx);\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n \n         let res_lane = f(fx, lane_layout, ret_lane_layout, lane);\n \n-        ret.place_field(fx, lane_idx).write_cvalue(fx, res_lane);\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n     }\n }\n \n@@ -206,37 +205,38 @@ fn simd_pair_for_each_lane<'tcx>(\n     let ret_lane_layout = fx.layout_of(ret_lane_ty);\n     assert_eq!(lane_count, ret_lane_count);\n \n-    for lane in 0..lane_count {\n-        let lane = mir::Field::new(lane.try_into().unwrap());\n-        let x_lane = x.value_field(fx, lane).load_scalar(fx);\n-        let y_lane = y.value_field(fx, lane).load_scalar(fx);\n+    for lane_idx in 0..lane_count {\n+        let x_lane = x.value_lane(fx, lane_idx).load_scalar(fx);\n+        let y_lane = y.value_lane(fx, lane_idx).load_scalar(fx);\n \n         let res_lane = f(fx, lane_layout, ret_lane_layout, x_lane, y_lane);\n \n-        ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n     }\n }\n \n fn simd_reduce<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n+    acc: Option<Value>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n-    let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n-    for lane_idx in 1..lane_count {\n-        let lane =\n-            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n+    let (mut res_val, start_lane) =\n+        if let Some(acc) = acc { (acc, 0) } else { (val.value_lane(fx, 0).load_scalar(fx), 1) };\n+    for lane_idx in start_lane..lane_count {\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n     let res = CValue::by_val(res_val, lane_layout);\n     ret.write_cvalue(fx, res);\n }\n \n+// FIXME move all uses to `simd_reduce`\n fn simd_reduce_bool<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n@@ -246,14 +246,18 @@ fn simd_reduce_bool<'tcx>(\n     let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n-    let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n+    let res_val = val.value_lane(fx, 0).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n-        let lane =\n-            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n+        let lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n     }\n+    let res_val = if fx.bcx.func.dfg.value_type(res_val) != types::I8 {\n+        fx.bcx.ins().ireduce(types::I8, res_val)\n+    } else {\n+        res_val\n+    };\n     let res = CValue::by_val(res_val, ret.layout());\n     ret.write_cvalue(fx, res);\n }\n@@ -288,7 +292,11 @@ macro simd_cmp {\n         if let Some(vector_ty) = vector_ty {\n             let x = $x.load_scalar($fx);\n             let y = $y.load_scalar($fx);\n-            let val = $fx.bcx.ins().icmp(IntCC::$cc, x, y);\n+            let val = if vector_ty.lane_type().is_float() {\n+                $fx.bcx.ins().fcmp(FloatCC::$cc_f, x, y)\n+            } else {\n+                $fx.bcx.ins().icmp(IntCC::$cc, x, y)\n+            };\n \n             // HACK This depends on the fact that icmp for vectors represents bools as 0 and !0, not 0 and 1.\n             let val = $fx.bcx.ins().raw_bitcast(vector_ty, val);"}, {"sha": "37906ab472d2ebd71f2d7b85f18d1b3a797ec683", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 168, "deletions": 20, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/1f7080246562a7dd3c3dee006d1fc7754029c8bc/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7080246562a7dd3c3dee006d1fc7754029c8bc/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=1f7080246562a7dd3c3dee006d1fc7754029c8bc", "patch": "@@ -108,11 +108,11 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n             for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n                 let in_lane = if u64::from(in_idx) < lane_count {\n-                    x.value_field(fx, mir::Field::new(in_idx.into()))\n+                    x.value_lane(fx, in_idx.into())\n                 } else {\n-                    y.value_field(fx, mir::Field::new(usize::from(in_idx) - usize::try_from(lane_count).unwrap()))\n+                    y.value_lane(fx, u64::from(in_idx) - lane_count)\n                 };\n-                let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n+                let out_lane = ret.place_lane(fx, u64::try_from(out_idx).unwrap());\n                 out_lane.write_cvalue(fx, in_lane);\n             }\n         };\n@@ -163,10 +163,38 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));\n             }\n \n-            let ret_lane = v.value_field(fx, mir::Field::new(idx.try_into().unwrap()));\n+            let ret_lane = v.value_lane(fx, idx.try_into().unwrap());\n             ret.write_cvalue(fx, ret_lane);\n         };\n \n+        simd_neg, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = match lane_layout.ty.kind() {\n+                    ty::Int(_) => fx.bcx.ins().ineg(lane),\n+                    ty::Float(_) => fx.bcx.ins().fneg(lane),\n+                    _ => unreachable!(),\n+                };\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n+        simd_fabs, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().fabs(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n+        simd_fsqrt, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().sqrt(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n         simd_add, (c x, c y) {\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, iadd|fadd(x, y) -> ret);\n@@ -183,6 +211,29 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_flt_binop!(fx, udiv|sdiv|fdiv(x, y) -> ret);\n         };\n+        simd_rem, (c x, c y) {\n+            validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n+            simd_pair_for_each_lane(fx, x, y, ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.kind() {\n+                    ty::Uint(_) => fx.bcx.ins().urem(x_lane, y_lane),\n+                    ty::Int(_) => fx.bcx.ins().srem(x_lane, y_lane),\n+                    ty::Float(FloatTy::F32) => fx.lib_call(\n+                        \"fmodf\",\n+                        vec![AbiParam::new(types::F32), AbiParam::new(types::F32)],\n+                        vec![AbiParam::new(types::F32)],\n+                        &[x_lane, y_lane],\n+                    )[0],\n+                    ty::Float(FloatTy::F64) => fx.lib_call(\n+                        \"fmod\",\n+                        vec![AbiParam::new(types::F64), AbiParam::new(types::F64)],\n+                        vec![AbiParam::new(types::F64)],\n+                        &[x_lane, y_lane],\n+                    )[0],\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            });\n+        };\n         simd_shl, (c x, c y) {\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n             simd_int_binop!(fx, ishl(x, y) -> ret);\n@@ -216,15 +267,14 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             let ret_lane_layout = fx.layout_of(ret_lane_ty);\n \n             for lane in 0..lane_count {\n-                let lane = mir::Field::new(lane.try_into().unwrap());\n-                let a_lane = a.value_field(fx, lane).load_scalar(fx);\n-                let b_lane = b.value_field(fx, lane).load_scalar(fx);\n-                let c_lane = c.value_field(fx, lane).load_scalar(fx);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+                let c_lane = c.value_lane(fx, lane).load_scalar(fx);\n \n                 let mul_lane = fx.bcx.ins().fmul(a_lane, b_lane);\n                 let res_lane = CValue::by_val(fx.bcx.ins().fadd(mul_lane, c_lane), ret_lane_layout);\n \n-                ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+                ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n             }\n         };\n \n@@ -237,9 +287,52 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             simd_flt_binop!(fx, fmax(x, y) -> ret);\n         };\n \n-        simd_reduce_add_ordered | simd_reduce_add_unordered, (c v) {\n+        simd_round, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, lane_layout, ret_lane_layout, lane| {\n+                let res_lane = match lane_layout.ty.kind() {\n+                    ty::Float(FloatTy::F32) => fx.lib_call(\n+                        \"roundf\",\n+                        vec![AbiParam::new(types::F32)],\n+                        vec![AbiParam::new(types::F32)],\n+                        &[lane],\n+                    )[0],\n+                    ty::Float(FloatTy::F64) => fx.lib_call(\n+                        \"round\",\n+                        vec![AbiParam::new(types::F64)],\n+                        vec![AbiParam::new(types::F64)],\n+                        &[lane],\n+                    )[0],\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                CValue::by_val(res_lane, ret_lane_layout)\n+            });\n+        };\n+        simd_ceil, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().ceil(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+        simd_floor, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().floor(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+        simd_trunc, (c a) {\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            simd_for_each_lane(fx, a, ret, |fx, _lane_layout, ret_lane_layout, lane| {\n+                let ret_lane = fx.bcx.ins().trunc(lane);\n+                CValue::by_val(ret_lane, ret_lane_layout)\n+            });\n+        };\n+\n+        simd_reduce_add_ordered | simd_reduce_add_unordered, (c v, v acc) {\n             validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, ret, |fx, lane_layout, a, b| {\n+            simd_reduce(fx, v, Some(acc), ret, |fx, lane_layout, a, b| {\n                 if lane_layout.ty.is_floating_point() {\n                     fx.bcx.ins().fadd(a, b)\n                 } else {\n@@ -248,9 +341,9 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             });\n         };\n \n-        simd_reduce_mul_ordered | simd_reduce_mul_unordered, (c v) {\n+        simd_reduce_mul_ordered | simd_reduce_mul_unordered, (c v, v acc) {\n             validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n-            simd_reduce(fx, v, ret, |fx, lane_layout, a, b| {\n+            simd_reduce(fx, v, Some(acc), ret, |fx, lane_layout, a, b| {\n                 if lane_layout.ty.is_floating_point() {\n                     fx.bcx.ins().fmul(a, b)\n                 } else {\n@@ -269,13 +362,68 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             simd_reduce_bool(fx, v, ret, |fx, a, b| fx.bcx.ins().bor(a, b));\n         };\n \n-        // simd_fabs\n-        // simd_saturating_add\n+        simd_reduce_and, (c v) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().band(a, b));\n+        };\n+\n+        simd_reduce_or, (c v) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().bor(a, b));\n+        };\n+\n+        simd_reduce_xor, (c v) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, _layout, a, b| fx.bcx.ins().bxor(a, b));\n+        };\n+\n+        simd_reduce_min, (c v) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, layout, a, b| {\n+                let lt = fx.bcx.ins().icmp(if layout.ty.is_signed() {\n+                    IntCC::SignedLessThan\n+                } else {\n+                    IntCC::UnsignedLessThan\n+                }, a, b);\n+                fx.bcx.ins().select(lt, a, b)\n+            });\n+        };\n+\n+        simd_reduce_max, (c v) {\n+            validate_simd_type!(fx, intrinsic, span, v.layout().ty);\n+            simd_reduce(fx, v, None, ret, |fx, layout, a, b| {\n+                let gt = fx.bcx.ins().icmp(if layout.ty.is_signed() {\n+                    IntCC::SignedGreaterThan\n+                } else {\n+                    IntCC::UnsignedGreaterThan\n+                }, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        };\n+\n+        simd_select, (c m, c a, c b) {\n+            validate_simd_type!(fx, intrinsic, span, m.layout().ty);\n+            validate_simd_type!(fx, intrinsic, span, a.layout().ty);\n+            assert_eq!(a.layout(), b.layout());\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_layout = fx.layout_of(lane_ty);\n+\n+            for lane in 0..lane_count {\n+                let m_lane = m.value_lane(fx, lane).load_scalar(fx);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+\n+                let m_lane = fx.bcx.ins().icmp_imm(IntCC::Equal, m_lane, 0);\n+                let res_lane = CValue::by_val(fx.bcx.ins().select(m_lane, b_lane, a_lane), lane_layout);\n+\n+                ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n+            }\n+        };\n+\n+        // simd_saturating_*\n         // simd_bitmask\n-        // simd_select\n-        // simd_rem\n-        // simd_neg\n-        // simd_trunc\n-        // simd_floor\n+        // simd_scatter\n+        // simd_gather\n     }\n }"}, {"sha": "b1e00360d566ab5c5868bf23d8ec4267288d8591", "filename": "src/value_and_place.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1f7080246562a7dd3c3dee006d1fc7754029c8bc/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7080246562a7dd3c3dee006d1fc7754029c8bc/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=1f7080246562a7dd3c3dee006d1fc7754029c8bc", "patch": "@@ -206,6 +206,38 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n+    /// Like [`CValue::value_field`] except handling ADTs containing a single array field in a way\n+    /// such that you can access individual lanes.\n+    pub(crate) fn value_lane(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        lane_idx: u64,\n+    ) -> CValue<'tcx> {\n+        let layout = self.1;\n+        assert!(layout.ty.is_simd());\n+        let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+        let lane_layout = fx.layout_of(lane_ty);\n+        assert!(lane_idx < lane_count);\n+        match self.0 {\n+            CValueInner::ByVal(val) => match layout.abi {\n+                Abi::Vector { element: _, count: _ } => {\n+                    assert!(lane_count <= u8::MAX.into(), \"SIMD type with more than 255 lanes???\");\n+                    let lane_idx = u8::try_from(lane_idx).unwrap();\n+                    let lane = fx.bcx.ins().extractlane(val, lane_idx);\n+                    CValue::by_val(lane, lane_layout)\n+                }\n+                _ => unreachable!(\"value_lane for ByVal with abi {:?}\", layout.abi),\n+            },\n+            CValueInner::ByValPair(_, _) => unreachable!(),\n+            CValueInner::ByRef(ptr, None) => {\n+                let field_offset = lane_layout.size * lane_idx;\n+                let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n+                CValue::by_ref(field_ptr, lane_layout)\n+            }\n+            CValueInner::ByRef(_, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n     pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n@@ -610,6 +642,38 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    /// Like [`CPlace::place_field`] except handling ADTs containing a single array field in a way\n+    /// such that you can access individual lanes.\n+    pub(crate) fn place_lane(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        lane_idx: u64,\n+    ) -> CPlace<'tcx> {\n+        let layout = self.layout();\n+        assert!(layout.ty.is_simd());\n+        let (lane_count, lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+        let lane_layout = fx.layout_of(lane_ty);\n+        assert!(lane_idx < lane_count);\n+\n+        match self.inner {\n+            CPlaceInner::Var(local, var) => {\n+                assert!(matches!(layout.abi, Abi::Vector { .. }));\n+                CPlace {\n+                    inner: CPlaceInner::VarLane(local, var, lane_idx.try_into().unwrap()),\n+                    layout: lane_layout,\n+                }\n+            }\n+            CPlaceInner::VarPair(_, _, _) => unreachable!(),\n+            CPlaceInner::VarLane(_, _, _) => unreachable!(),\n+            CPlaceInner::Addr(ptr, None) => {\n+                let field_offset = lane_layout.size * lane_idx;\n+                let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n+                CPlace::for_ptr(field_ptr, lane_layout)\n+            }\n+            CPlaceInner::Addr(_, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n     pub(crate) fn place_index(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}]}