{"sha": "94bf2c15eb3d072e92855a605783a29920df9e46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YmYyYzE1ZWIzZDA3MmU5Mjg1NWE2MDU3ODNhMjk5MjBkZjllNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-24T07:26:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-24T07:26:19Z"}, "message": "Auto merge of #57087 - Centril:rollup, r=Centril\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #56188 (enum type instead of variant suggestion unification )\n - #56342 (Improve docs for collecting into `Option`s)\n - #56916 (Fix mutable references in `static mut`)\n - #56917 (Simplify MIR generation for logical operations)\n - #56939 (Pin stabilization)\n - #56953 (Mark tuple structs as live if their constructors are used)\n - #56964 (Remove `TokenStream::JointTree`.)\n - #56966 (Correct strings for raw pointer deref and array access suggestions)\n - #57020 (Point to cause of `fn` expected return type)\n - #57032 (fix deprecation warnings in liballoc benches)\n - #57053 (Fix alignment for array indexing)\n - #57062 (Fix a comment)\n - #57067 (Stabilize min_const_unsafe_fn in 1.33)\n - #57078 (Ignore two tests on s390x)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c54866741b6c39b4ddce1f30ae136075ec936bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c54866741b6c39b4ddce1f30ae136075ec936bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94bf2c15eb3d072e92855a605783a29920df9e46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94bf2c15eb3d072e92855a605783a29920df9e46", "html_url": "https://github.com/rust-lang/rust/commit/94bf2c15eb3d072e92855a605783a29920df9e46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94bf2c15eb3d072e92855a605783a29920df9e46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e16928082aa2d66a4498132572b69156b94b25f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e16928082aa2d66a4498132572b69156b94b25f1", "html_url": "https://github.com/rust-lang/rust/commit/e16928082aa2d66a4498132572b69156b94b25f1"}, {"sha": "dff3e41914905eae0326c00de0dd9befc9d9ae83", "url": "https://api.github.com/repos/rust-lang/rust/commits/dff3e41914905eae0326c00de0dd9befc9d9ae83", "html_url": "https://github.com/rust-lang/rust/commit/dff3e41914905eae0326c00de0dd9befc9d9ae83"}], "stats": {"total": 1210, "additions": 721, "deletions": 489}, "files": [{"sha": "5e6bde1db7cd5ba7e96843c50d2a9d2d37486519", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -18,6 +18,7 @@ dependencies = [\n  \"compiler_builtins 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_xorshift 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "861c7cecb887943aa3b740f50dbc8511eb314b0e", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -15,6 +15,7 @@ compiler_builtins = { version = \"0.1.0\", features = ['rustc-dep-of-std'] }\n \n [dev-dependencies]\n rand = \"0.6\"\n+rand_xorshift = \"0.1\"\n \n [[test]]\n name = \"collectionstests\""}, {"sha": "6e2b5e06b7a918a09213adf5a1619842bab5c0f6", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -12,7 +12,7 @@\n use std::iter::Iterator;\n use std::vec::Vec;\n use std::collections::BTreeMap;\n-use rand::{Rng, thread_rng};\n+use rand::{Rng, seq::SliceRandom, thread_rng};\n use test::{Bencher, black_box};\n \n macro_rules! map_insert_rand_bench {\n@@ -78,7 +78,7 @@ macro_rules! map_find_rand_bench {\n                 map.insert(k, k);\n             }\n \n-            rng.shuffle(&mut keys);\n+            keys.shuffle(&mut rng);\n \n             // measure\n             let mut i = 0;"}, {"sha": "9502a7dc3c075c8a0cddfe5183164d1a62436fdc", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -13,6 +13,7 @@\n #![feature(test)]\n \n extern crate rand;\n+extern crate rand_xorshift;\n extern crate test;\n \n mod btree;"}, {"sha": "fc58899406332999872682362a7090551d9da527", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -12,8 +12,9 @@ use rand::{thread_rng};\n use std::mem;\n use std::ptr;\n \n-use rand::{Rng, SeedableRng, XorShiftRng};\n+use rand::{Rng, SeedableRng};\n use rand::distributions::{Standard, Alphanumeric};\n+use rand_xorshift::XorShiftRng;\n use test::{Bencher, black_box};\n \n #[bench]"}, {"sha": "c5e1576d24e26df1b222954da4ffa8a4b5abb9b6", "filename": "src/liballoc/benches/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -274,11 +274,11 @@ make_test!(split_a_str, s, s.split(\"a\").count());\n make_test!(trim_ascii_char, s, {\n     s.trim_matches(|c: char| c.is_ascii())\n });\n-make_test!(trim_left_ascii_char, s, {\n-    s.trim_left_matches(|c: char| c.is_ascii())\n+make_test!(trim_start_ascii_char, s, {\n+    s.trim_start_matches(|c: char| c.is_ascii())\n });\n-make_test!(trim_right_ascii_char, s, {\n-    s.trim_right_matches(|c: char| c.is_ascii())\n+make_test!(trim_end_ascii_char, s, {\n+    s.trim_end_matches(|c: char| c.is_ascii())\n });\n \n make_test!(find_underscore_char, s, s.find('_'));"}, {"sha": "7438f3e6c9df539ed6fe4aa2349e984a3794bdb1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -111,9 +111,11 @@ impl<T> Box<T> {\n         box x\n     }\n \n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n+    /// `x` will be pinned in memory and unable to be moved.\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn pinned(x: T) -> Pin<Box<T>> {\n+    pub fn pin(x: T) -> Pin<Box<T>> {\n         (box x).into()\n     }\n }\n@@ -446,7 +448,7 @@ impl<T> From<T> for Box<T> {\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T> From<Box<T>> for Pin<Box<T>> {\n     fn from(boxed: Box<T>) -> Self {\n         // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n@@ -813,7 +815,7 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n  *  implementation of `Unpin` (where `T: Unpin`) would be valid/safe, and\n  *  could have a method to project a Pin<T> from it.\n  */\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Box<T> { }\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]"}, {"sha": "8a66cafc001b72d13be235ff5900f42462a01093", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -102,7 +102,6 @@\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]\n-#![feature(pin)]\n #![feature(ptr_internals)]\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]"}, {"sha": "af316b0b61bd1d8635fbe41dd1ff9a1d2195caa3", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -325,8 +325,10 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn pinned(value: T) -> Pin<Rc<T>> {\n+    /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n+    /// `value` will be pinned in memory and unable to be moved.\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    pub fn pin(value: T) -> Pin<Rc<T>> {\n         unsafe { Pin::new_unchecked(Rc::new(value)) }\n     }\n \n@@ -1934,5 +1936,5 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> { }"}, {"sha": "7b8afb1943c1f3b1ec593141c43d5c796a4ec538", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -303,8 +303,10 @@ impl<T> Arc<T> {\n         Arc { ptr: Box::into_raw_non_null(x), phantom: PhantomData }\n     }\n \n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn pinned(data: T) -> Pin<Arc<T>> {\n+    /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n+    /// `data` will be pinned in memory and unable to be moved.\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    pub fn pin(data: T) -> Pin<Arc<T>> {\n         unsafe { Pin::new_unchecked(Arc::new(data)) }\n     }\n \n@@ -2050,5 +2052,5 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> { }"}, {"sha": "da3aa8449bafb4f8b3414cc7732c87c5c561afcf", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -120,7 +120,7 @@ impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n \n impl<P> Future for Pin<P>\n where\n-    P: ops::DerefMut,\n+    P: Unpin + ops::DerefMut,\n     P::Target: Future,\n {\n     type Output = <<P as ops::Deref>::Target as Future>::Output;"}, {"sha": "74055a4f8a9b0b65c7a910b4d3588dcaa6e98c44", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -621,7 +621,6 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// So this, for example, can only be done on types implementing `Unpin`:\n ///\n /// ```rust\n-/// #![feature(pin)]\n /// use std::mem::replace;\n /// use std::pin::Pin;\n ///\n@@ -637,23 +636,23 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// [`replace`]: ../../std/mem/fn.replace.html\n /// [`Pin`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n pub auto trait Unpin {}\n \n /// A marker type which does not implement `Unpin`.\n ///\n /// If a type contains a `PhantomPinned`, it will not implement `Unpin` by default.\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n pub struct PhantomPinned;\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl !Unpin for PhantomPinned {}\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<'a, T: ?Sized + 'a> Unpin for &'a T {}\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<'a, T: ?Sized + 'a> Unpin for &'a mut T {}\n \n /// Implementations of `Copy` for primitive types."}, {"sha": "2b01da0de5203da0124144100fe4a9ed740ba06a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -273,7 +273,7 @@ impl<T> Option<T> {\n \n     /// Converts from `Pin<&Option<T>>` to `Option<Pin<&T>>`\n     #[inline]\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_ref<'a>(self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>> {\n         unsafe {\n             Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n@@ -282,10 +282,10 @@ impl<T> Option<T> {\n \n     /// Converts from `Pin<&mut Option<T>>` to `Option<Pin<&mut T>>`\n     #[inline]\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_mut<'a>(self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>> {\n         unsafe {\n-            Pin::get_mut_unchecked(self).as_mut().map(|x| Pin::new_unchecked(x))\n+            Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x))\n         }\n     }\n \n@@ -1253,20 +1253,42 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// returned. Should no [`None`][Option::None] occur, a container with the\n     /// values of each [`Option`] is returned.\n     ///\n-    /// Here is an example which increments every integer in a vector,\n-    /// checking for overflow:\n+    /// # Examples\n+    ///\n+    /// Here is an example which increments every integer in a vector.\n+    /// `We use the checked variant of `add` that returns `None` when the\n+    /// calculation would result in an overflow.\n     ///\n     /// ```\n-    /// use std::u16;\n+    /// let items = vec![0_u16, 1, 2];\n+    ///\n+    /// let res: Option<Vec<u16>> = items\n+    ///     .iter()\n+    ///     .map(|x| x.checked_add(1))\n+    ///     .collect();\n     ///\n-    /// let v = vec![1, 2];\n-    /// let res: Option<Vec<u16>> = v.iter().map(|&x: &u16|\n-    ///     if x == u16::MAX { None }\n-    ///     else { Some(x + 1) }\n-    /// ).collect();\n-    /// assert!(res == Some(vec![2, 3]));\n+    /// assert_eq!(res, Some(vec![1, 2, 3]));\n     /// ```\n     ///\n+    /// As you can see, this will return the expected, valid items.\n+    ///\n+    /// Here is another example that tries to subtract one from another list\n+    /// of integers, this time checking for underflow:\n+    ///\n+    /// ```\n+    /// let items = vec![2_u16, 1, 0];\n+    ///\n+    /// let res: Option<Vec<u16>> = items\n+    ///     .iter()\n+    ///     .map(|x| x.checked_sub(1))\n+    ///     .collect();\n+    ///\n+    /// assert_eq!(res, None);\n+    /// ```\n+    ///\n+    /// Since the last element is zero, it would underflow. Thus, the resulting\n+    /// value is `None`.\n+    ///\n     /// [`Iterator`]: ../iter/trait.Iterator.html\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {"}, {"sha": "d8508631bf9c36a487f004014f4387aa033e138b", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 37, "deletions": 44, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -36,15 +36,13 @@\n //! are always freely movable, even if the data they point to isn't.\n //!\n //! [`Pin`]: struct.Pin.html\n-//! [`Unpin`]: trait.Unpin.html\n+//! [`Unpin`]: ../../std/marker/trait.Unpin.html\n //! [`swap`]: ../../std/mem/fn.swap.html\n //! [`Box`]: ../../std/boxed/struct.Box.html\n //!\n //! # Examples\n //!\n //! ```rust\n-//! #![feature(pin)]\n-//!\n //! use std::pin::Pin;\n //! use std::marker::PhantomPinned;\n //! use std::ptr::NonNull;\n@@ -72,13 +70,13 @@\n //!             slice: NonNull::dangling(),\n //!             _pin: PhantomPinned,\n //!         };\n-//!         let mut boxed = Box::pinned(res);\n+//!         let mut boxed = Box::pin(res);\n //!\n //!         let slice = NonNull::from(&boxed.data);\n //!         // we know this is safe because modifying a field doesn't move the whole struct\n //!         unsafe {\n //!             let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);\n-//!             Pin::get_mut_unchecked(mut_ref).slice = slice;\n+//!             Pin::get_unchecked_mut(mut_ref).slice = slice;\n //!         }\n //!         boxed\n //!     }\n@@ -97,15 +95,12 @@\n //! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n //! ```\n \n-#![unstable(feature = \"pin\", issue = \"49150\")]\n+#![stable(feature = \"pin\", since = \"1.33.0\")]\n \n use fmt;\n-use marker::Sized;\n+use marker::{Sized, Unpin};\n use ops::{Deref, DerefMut, Receiver, CoerceUnsized, DispatchFromDyn};\n \n-#[doc(inline)]\n-pub use marker::Unpin;\n-\n /// A pinned pointer.\n ///\n /// This is a wrapper around a kind of pointer which makes that pointer \"pin\" its\n@@ -119,8 +114,9 @@ pub use marker::Unpin;\n //\n // Note: the derives below are allowed because they all only use `&P`, so they\n // cannot move the value behind `pointer`.\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n #[fundamental]\n+#[repr(transparent)]\n #[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]\n pub struct Pin<P> {\n     pointer: P,\n@@ -132,7 +128,7 @@ where\n {\n     /// Construct a new `Pin` around a pointer to some data of a type that\n     /// implements `Unpin`.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn new(pointer: P) -> Pin<P> {\n         // Safety: the value pointed to is `Unpin`, and so has no requirements\n@@ -154,14 +150,14 @@ impl<P: Deref> Pin<P> {\n     ///\n     /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n     /// instead.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n         Pin { pointer }\n     }\n \n     /// Get a pinned shared reference from this pinned pointer.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n         unsafe { Pin::new_unchecked(&*self.pointer) }\n@@ -170,14 +166,14 @@ impl<P: Deref> Pin<P> {\n \n impl<P: DerefMut> Pin<P> {\n     /// Get a pinned mutable reference from this pinned pointer.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n         unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n \n     /// Assign a new value to the memory behind the pinned reference.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn set(mut self: Pin<P>, value: P::Target)\n     where\n@@ -199,11 +195,11 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     /// will not move so long as the argument value does not move (for example,\n     /// because it is one of the fields of that value), and also that you do\n     /// not move out of the argument you receive to the interior function.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn map_unchecked<U, F>(this: Pin<&'a T>, func: F) -> Pin<&'a U> where\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    pub unsafe fn map_unchecked<U, F>(self: Pin<&'a T>, func: F) -> Pin<&'a U> where\n         F: FnOnce(&T) -> &U,\n     {\n-        let pointer = &*this.pointer;\n+        let pointer = &*self.pointer;\n         let new_pointer = func(pointer);\n         Pin::new_unchecked(new_pointer)\n     }\n@@ -215,19 +211,19 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n     /// the `Pin` itself. This method allows turning the `Pin` into a reference\n     /// with the same lifetime as the original `Pin`.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_ref(this: Pin<&'a T>) -> &'a T {\n-        this.pointer\n+    pub fn get_ref(self: Pin<&'a T>) -> &'a T {\n+        self.pointer\n     }\n }\n \n impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// Convert this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn into_ref(this: Pin<&'a mut T>) -> Pin<&'a T> {\n-        Pin { pointer: this.pointer }\n+    pub fn into_ref(self: Pin<&'a mut T>) -> Pin<&'a T> {\n+        Pin { pointer: self.pointer }\n     }\n \n     /// Get a mutable reference to the data inside of this `Pin`.\n@@ -239,12 +235,12 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n     /// the `Pin` itself. This method allows turning the `Pin` into a reference\n     /// with the same lifetime as the original `Pin`.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_mut(this: Pin<&'a mut T>) -> &'a mut T\n+    pub fn get_mut(self: Pin<&'a mut T>) -> &'a mut T\n         where T: Unpin,\n     {\n-        this.pointer\n+        self.pointer\n     }\n \n     /// Get a mutable reference to the data inside of this `Pin`.\n@@ -257,10 +253,10 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// If the underlying data is `Unpin`, `Pin::get_mut` should be used\n     /// instead.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub unsafe fn get_mut_unchecked(this: Pin<&'a mut T>) -> &'a mut T {\n-        this.pointer\n+    pub unsafe fn get_unchecked_mut(self: Pin<&'a mut T>) -> &'a mut T {\n+        self.pointer\n     }\n \n     /// Construct a new pin by mapping the interior value.\n@@ -274,25 +270,25 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// will not move so long as the argument value does not move (for example,\n     /// because it is one of the fields of that value), and also that you do\n     /// not move out of the argument you receive to the interior function.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn map_unchecked_mut<U, F>(this: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    pub unsafe fn map_unchecked_mut<U, F>(self: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n         F: FnOnce(&mut T) -> &mut U,\n     {\n-        let pointer = Pin::get_mut_unchecked(this);\n+        let pointer = Pin::get_unchecked_mut(self);\n         let new_pointer = func(pointer);\n         Pin::new_unchecked(new_pointer)\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P: Deref> Deref for Pin<P> {\n     type Target = P::Target;\n     fn deref(&self) -> &P::Target {\n         Pin::get_ref(Pin::as_ref(self))\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P: DerefMut> DerefMut for Pin<P>\n where\n     P::Target: Unpin\n@@ -305,21 +301,21 @@ where\n #[unstable(feature = \"receiver_trait\", issue = \"0\")]\n impl<P: Receiver> Receiver for Pin<P> {}\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P: fmt::Debug> fmt::Debug for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&self.pointer, f)\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P: fmt::Display> fmt::Display for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.pointer, f)\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P: fmt::Pointer> fmt::Pointer for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&self.pointer, f)\n@@ -331,17 +327,14 @@ impl<P: fmt::Pointer> fmt::Pointer for Pin<P> {\n // `Deref<Target=Unpin>` is unsound. Any such impl would probably be unsound\n // for other reasons, though, so we just need to take care not to allow such\n // impls to land in std.\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P, U> CoerceUnsized<Pin<U>> for Pin<P>\n where\n     P: CoerceUnsized<U>,\n {}\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<'a, P, U> DispatchFromDyn<Pin<U>> for Pin<P>\n where\n     P: DispatchFromDyn<U>,\n {}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<P> Unpin for Pin<P> {}"}, {"sha": "a1e6034b20821740a05503152bb9665517bed6b0", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -19,7 +19,7 @@\n // Re-exported core operators\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use marker::{Copy, Send, Sized, Sync};\n+pub use marker::{Copy, Send, Sized, Sync, Unpin};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use ops::{Drop, Fn, FnMut, FnOnce};"}, {"sha": "0fd5963c99d4a800081360479b6de555dae911bd", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1979,6 +1979,15 @@ pub enum FunctionRetTy {\n     Return(P<Ty>),\n }\n \n+impl fmt::Display for FunctionRetTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Return(ref ty) => print::to_string(print::NO_ANN, |s| s.print_type(ty)).fmt(f),\n+            DefaultReturn(_) => \"()\".fmt(f),\n+        }\n+    }\n+}\n+\n impl FunctionRetTy {\n     pub fn span(&self) -> Span {\n         match *self {\n@@ -2119,7 +2128,7 @@ impl StructField {\n /// Id of the whole enum lives in `Item`.\n ///\n /// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n-/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n+/// used for `Struct`-structs (but still present). Structures don't have an analogue of \"Id of\n /// the variant itself\" from enum variants.\n /// Id of the whole struct lives in `Item`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "6852e2c69618b302c5ae21d9a1cf79528b1f127d", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -47,7 +47,6 @@ impl_stable_hash_for!(enum mir::BorrowKind {\n impl_stable_hash_for!(enum mir::UnsafetyViolationKind {\n     General,\n     GeneralAndConstFn,\n-    GatedConstFnCall,\n     ExternStatic(lint_node_id),\n     BorrowPacked(lint_node_id),\n });"}, {"sha": "d2175c28309b1093c34a72f7c247bfebf81ced91", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -25,6 +25,8 @@ use middle::privacy;\n use ty::{self, TyCtxt};\n use util::nodemap::FxHashSet;\n \n+use rustc_data_structures::fx::FxHashMap;\n+\n use syntax::{ast, source_map};\n use syntax::attr;\n use syntax_pos;\n@@ -55,12 +57,15 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     in_pat: bool,\n     inherited_pub_visibility: bool,\n     ignore_variant_stack: Vec<DefId>,\n+    // maps from tuple struct constructors to tuple struct items\n+    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            if should_explore(self.tcx, node_id) {\n+            if should_explore(self.tcx, node_id) ||\n+               self.struct_constructors.contains_key(&node_id) {\n                 self.worklist.push(node_id);\n             }\n             self.live_symbols.insert(node_id);\n@@ -137,19 +142,23 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref node) = self.tcx.hir().find(id) {\n+            // in the case of tuple struct constructors we want to check the item, not the generated\n+            // tuple struct constructor function\n+            let id = self.struct_constructors.get(&id).cloned().unwrap_or(id);\n+\n+            if let Some(node) = self.tcx.hir().find(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n         }\n     }\n \n-    fn visit_node(&mut self, node: &Node<'tcx>) {\n+    fn visit_node(&mut self, node: Node<'tcx>) {\n         let had_repr_c = self.repr_has_repr_c;\n         self.repr_has_repr_c = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n         self.inherited_pub_visibility = false;\n-        match *node {\n+        match node {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n@@ -337,6 +346,8 @@ struct LifeSeeder<'k, 'tcx: 'k> {\n     worklist: Vec<ast::NodeId>,\n     krate: &'k hir::Crate,\n     tcx: TyCtxt<'k, 'tcx, 'tcx>,\n+    // see `MarkSymbolVisitor::struct_constructors`\n+    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n }\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n@@ -379,6 +390,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     }\n                 }\n             }\n+            hir::ItemKind::Struct(ref variant_data, _) => {\n+                self.struct_constructors.insert(variant_data.id(), item.id);\n+            }\n             _ => ()\n         }\n     }\n@@ -392,11 +406,11 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     }\n }\n \n-fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      access_levels: &privacy::AccessLevels,\n-                                      krate: &hir::Crate)\n-                                      -> Vec<ast::NodeId>\n-{\n+fn create_and_seed_worklist<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    access_levels: &privacy::AccessLevels,\n+    krate: &hir::Crate,\n+) -> (Vec<ast::NodeId>, FxHashMap<ast::NodeId, ast::NodeId>) {\n     let worklist = access_levels.map.iter().filter_map(|(&id, level)| {\n         if level >= &privacy::AccessLevel::Reachable {\n             Some(id)\n@@ -413,17 +427,18 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         worklist,\n         krate,\n         tcx,\n+        struct_constructors: Default::default(),\n     };\n     krate.visit_all_item_likes(&mut life_seeder);\n \n-    return life_seeder.worklist;\n+    (life_seeder.worklist, life_seeder.struct_constructors)\n }\n \n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n                        -> FxHashSet<ast::NodeId> {\n-    let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n+    let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n         tcx,\n@@ -433,20 +448,12 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         in_pat: false,\n         inherited_pub_visibility: false,\n         ignore_variant_stack: vec![],\n+        struct_constructors,\n     };\n     symbol_visitor.mark_live_symbols();\n     symbol_visitor.live_symbols\n }\n \n-fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n-    match item.node {\n-        hir::ItemKind::Struct(ref struct_def, _) if !struct_def.is_struct() => {\n-            Some(struct_def.id())\n-        }\n-        _ => None\n-    }\n-}\n-\n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     live_symbols: FxHashSet<ast::NodeId>,\n@@ -464,46 +471,35 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             | hir::ItemKind::Union(..) => true,\n             _ => false\n         };\n-        let ctor_id = get_struct_ctor_id(item);\n-        should_warn && !self.symbol_is_live(item.id, ctor_id)\n+        should_warn && !self.symbol_is_live(item.id)\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n         let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n         !field.is_positional()\n-            && !self.symbol_is_live(field.id, None)\n+            && !self.symbol_is_live(field.id)\n             && !field_type.is_phantom_data()\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n-        !self.symbol_is_live(variant.data.id(), None)\n+        !self.symbol_is_live(variant.data.id())\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n                                                  variant.data.id(),\n                                                  &variant.attrs)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n-        !self.symbol_is_live(fi.id, None)\n+        !self.symbol_is_live(fi.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx, fi.id, &fi.attrs)\n     }\n \n     // id := node id of an item's definition.\n-    // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n-    //            `None` otherwise.\n-    // If the item is a struct_ctor, then either its `id` or\n-    // `ctor_id` (unwrapped) is in the live_symbols set. More specifically,\n-    // DefMap maps the ExprKind::Path of a struct_ctor to the node referred by\n-    // `ctor_id`. On the other hand, in a statement like\n-    // `type <ident> <generics> = <ty>;` where <ty> refers to a struct_ctor,\n-    // DefMap maps <ty> to `id` instead.\n-    fn symbol_is_live(&mut self,\n-                      id: ast::NodeId,\n-                      ctor_id: Option<ast::NodeId>)\n-                      -> bool {\n-        if self.live_symbols.contains(&id)\n-           || ctor_id.map_or(false, |ctor| self.live_symbols.contains(&ctor))\n-        {\n+    fn symbol_is_live(\n+        &mut self,\n+        id: ast::NodeId,\n+    ) -> bool {\n+        if self.live_symbols.contains(&id) {\n             return true;\n         }\n         // If it's a type whose items are live, then it's live, too.\n@@ -611,7 +607,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id, None) {\n+                if !self.symbol_is_live(impl_item.id) {\n                     self.warn_dead_code(impl_item.id,\n                                         impl_item.span,\n                                         impl_item.ident.name,\n@@ -621,7 +617,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id, None) {\n+                if !self.symbol_is_live(impl_item.id) {\n                     let span = self.tcx.sess.source_map().def_span(impl_item.span);\n                     self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n                 }"}, {"sha": "120350a573b6e502245daeb0de379e52da60edfe", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -2792,9 +2792,6 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// Right now function calls to `const unsafe fn` are only permitted behind a feature gate\n-    /// Also, even `const unsafe fn` need an `unsafe` block to do the allowed operations.\n-    GatedConstFnCall,\n     /// Permitted in const fn and regular fns\n     GeneralAndConstFn,\n     ExternStatic(ast::NodeId),"}, {"sha": "5fad4a24b262e342f5d6bb8d56baf4796aec01a9", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -335,11 +335,20 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         llindex: V\n     ) -> Self {\n+        // Statically compute the offset if we can, otherwise just use the element size,\n+        // as this will yield the lowest alignment.\n+        let layout = self.layout.field(bx, 0);\n+        let offset = if bx.is_const_integral(llindex) {\n+            layout.size.checked_mul(bx.const_to_uint(llindex), bx).unwrap_or(layout.size)\n+        } else {\n+            layout.size\n+        };\n+\n         PlaceRef {\n             llval: bx.inbounds_gep(self.llval, &[bx.cx().const_usize(0), llindex]),\n             llextra: None,\n-            layout: self.layout.field(bx.cx(), 0),\n-            align: self.align\n+            layout,\n+            align: self.align.restrict_for_offset(offset),\n         }\n     }\n "}, {"sha": "052342dd7597bf18bb6c0f0dd2efd227ff7c7268", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -131,8 +131,9 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let keep_going = header_bx.icmp(IntPredicate::IntNE, current, end);\n                 header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n \n+                let align = dest.align.restrict_for_offset(dest.layout.field(bx.cx(), 0).size);\n                 cg_elem.val.store(&mut body_bx,\n-                    PlaceRef::new_sized(current, cg_elem.layout, dest.align));\n+                    PlaceRef::new_sized(current, cg_elem.layout, align));\n \n                 let next = body_bx.inbounds_gep(current, &[bx.cx().const_usize(1)]);\n                 body_bx.br(header_bx.llbb());"}, {"sha": "64defaf78a48779c70d4b841c567fb6640bab209", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -126,66 +126,59 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::LogicalOp { op, lhs, rhs } => {\n                 // And:\n                 //\n-                // [block: If(lhs)] -true-> [else_block: If(rhs)] -true-> [true_block]\n-                //        |                          | (false)\n-                //        +----------false-----------+------------------> [false_block]\n+                // [block: If(lhs)] -true-> [else_block: dest = (rhs)]\n+                //        | (false)\n+                //  [shortcurcuit_block: dest = false]\n                 //\n                 // Or:\n                 //\n-                // [block: If(lhs)] -false-> [else_block: If(rhs)] -true-> [true_block]\n-                //        | (true)                   | (false)\n-                //  [true_block]               [false_block]\n+                // [block: If(lhs)] -false-> [else_block: dest = (rhs)]\n+                //        | (true)\n+                //  [shortcurcuit_block: dest = true]\n \n-                let (true_block, false_block, mut else_block, join_block) = (\n-                    this.cfg.start_new_block(),\n+                let (shortcircuit_block, mut else_block, join_block) = (\n                     this.cfg.start_new_block(),\n                     this.cfg.start_new_block(),\n                     this.cfg.start_new_block(),\n                 );\n \n                 let lhs = unpack!(block = this.as_local_operand(block, lhs));\n                 let blocks = match op {\n-                    LogicalOp::And => (else_block, false_block),\n-                    LogicalOp::Or => (true_block, else_block),\n+                    LogicalOp::And => (else_block, shortcircuit_block),\n+                    LogicalOp::Or => (shortcircuit_block, else_block),\n                 };\n                 let term = TerminatorKind::if_(this.hir.tcx(), lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n-                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n-                let term = TerminatorKind::if_(this.hir.tcx(), rhs, true_block, false_block);\n-                this.cfg.terminate(else_block, source_info, term);\n-\n                 this.cfg.push_assign_constant(\n-                    true_block,\n+                    shortcircuit_block,\n                     source_info,\n                     destination,\n                     Constant {\n                         span: expr_span,\n                         ty: this.hir.bool_ty(),\n                         user_ty: None,\n-                        literal: this.hir.true_literal(),\n+                        literal: match op {\n+                            LogicalOp::And => this.hir.false_literal(),\n+                            LogicalOp::Or => this.hir.true_literal(),\n+                        },\n                     },\n                 );\n-\n-                this.cfg.push_assign_constant(\n-                    false_block,\n+                this.cfg.terminate(\n+                    shortcircuit_block,\n                     source_info,\n-                    destination,\n-                    Constant {\n-                        span: expr_span,\n-                        ty: this.hir.bool_ty(),\n-                        user_ty: None,\n-                        literal: this.hir.false_literal(),\n-                    },\n+                    TerminatorKind::Goto { target: join_block },\n                 );\n \n-                this.cfg.terminate(\n-                    true_block,\n+                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n+                this.cfg.push_assign(\n+                    else_block,\n                     source_info,\n-                    TerminatorKind::Goto { target: join_block },\n+                    destination,\n+                    Rvalue::Use(rhs),\n                 );\n                 this.cfg.terminate(\n-                    false_block,\n+                    else_block,\n                     source_info,\n                     TerminatorKind::Goto { target: join_block },\n                 );"}, {"sha": "8ab9cb42b8243e9b3c38e4b79d16ea7a8c9482ca", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -139,7 +139,7 @@\n //!\n //! #### Boxes\n //! Since `Box` expression have special compiler support, no explicit calls to\n-//! `exchange_malloc()` and `exchange_free()` may show up in MIR, even if the\n+//! `exchange_malloc()` and `box_free()` may show up in MIR, even if the\n //! compiler will generate them. We have to observe `Rvalue::Box` expressions\n //! and Box-typed drop-statements for that purpose.\n //!"}, {"sha": "89d9c03f74e3e9baf40ca5ed5dfc86487f2f62c2", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -23,7 +23,6 @@ use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n use syntax::ast;\n use syntax::symbol::Symbol;\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n \n use std::ops::Bound;\n \n@@ -97,7 +96,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 if let hir::Unsafety::Unsafe = sig.unsafety() {\n                     self.require_unsafe(\"call to unsafe function\",\n                         \"consult the function's documentation for information on how to avoid \\\n-                         undefined behavior\", UnsafetyViolationKind::GatedConstFnCall)\n+                         undefined behavior\", UnsafetyViolationKind::GeneralAndConstFn)\n                 }\n             }\n         }\n@@ -325,11 +324,6 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                             // compat lint\n                             violation.kind = UnsafetyViolationKind::General;\n                         },\n-                        UnsafetyViolationKind::GatedConstFnCall => {\n-                            // safe code can't call unsafe const fns, this `UnsafetyViolationKind`\n-                            // is only relevant for `Safety::ExplicitUnsafe` in `unsafe const fn`s\n-                            violation.kind = UnsafetyViolationKind::General;\n-                        }\n                     }\n                     if !self.violations.contains(&violation) {\n                         self.violations.push(violation)\n@@ -346,19 +340,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 }\n                 // only some unsafety is allowed in const fn\n                 if self.min_const_fn {\n-                    let min_const_unsafe_fn = self.tcx.features().min_const_unsafe_fn;\n                     for violation in violations {\n                         match violation.kind {\n-                            UnsafetyViolationKind::GatedConstFnCall if min_const_unsafe_fn => {\n-                                // these function calls to unsafe functions are allowed\n-                                // if `#![feature(min_const_unsafe_fn)]` is active\n-                            },\n-                            UnsafetyViolationKind::GatedConstFnCall => {\n-                                // without the feature gate, we report errors\n-                                if !self.violations.contains(&violation) {\n-                                    self.violations.push(violation.clone())\n-                                }\n-                            }\n                             // these unsafe things are stable in const fn\n                             UnsafetyViolationKind::GeneralAndConstFn => {},\n                             // these things are forbidden in const fns\n@@ -620,16 +603,6 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n                     .note(&details.as_str()[..])\n                     .emit();\n             }\n-            UnsafetyViolationKind::GatedConstFnCall => {\n-                emit_feature_err(\n-                    &tcx.sess.parse_sess,\n-                    \"min_const_unsafe_fn\",\n-                    source_info.span,\n-                    GateIssue::Language,\n-                    \"calls to `const unsafe fn` in const fns are unstable\",\n-                );\n-\n-            }\n             UnsafetyViolationKind::ExternStatic(lint_node_id) => {\n                 tcx.lint_node_note(SAFE_EXTERN_STATICS,\n                               lint_node_id,"}, {"sha": "646a671d4a2ce50494cc15dc61324fbab8a50356", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -518,7 +518,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n                 // Only allow statics (not consts) to refer to other statics.\n                 if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                    if context.is_mutating_use() {\n+                    if self.mode == Mode::Static && context.is_mutating_use() {\n                         // this is not strictly necessary as miri will also bail out\n                         // For interior mutability we can't really catch this statically as that\n                         // goes through raw pointers and intermediate temporaries, so miri has"}, {"sha": "e543677ef06218ea378d6a6b6d71b384f80b12eb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -3213,23 +3213,43 @@ impl<'a> Resolver<'a> {\n                 let enum_candidates =\n                     this.lookup_import_candidates(ident, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n-                    .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n+                    .map(|suggestion| {\n+                        import_candidate_to_enum_paths(&suggestion)\n+                    }).collect::<Vec<_>>();\n                 enum_candidates.sort();\n-                for (sp, variant_path, enum_path) in enum_candidates {\n-                    if sp.is_dummy() {\n-                        let msg = format!(\"there is an enum variant `{}`, \\\n-                                           try using `{}`?\",\n-                                          variant_path,\n-                                          enum_path);\n-                        err.help(&msg);\n+\n+                if !enum_candidates.is_empty() {\n+                    // contextualize for E0412 \"cannot find type\", but don't belabor the point\n+                    // (that it's a variant) for E0573 \"expected type, found variant\"\n+                    let preamble = if def.is_none() {\n+                        let others = match enum_candidates.len() {\n+                            1 => String::new(),\n+                            2 => \" and 1 other\".to_owned(),\n+                            n => format!(\" and {} others\", n)\n+                        };\n+                        format!(\"there is an enum variant `{}`{}; \",\n+                                enum_candidates[0].0, others)\n                     } else {\n-                        err.span_suggestion_with_applicability(\n-                            span,\n-                            \"you can try using the variant's enum\",\n-                            enum_path,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                        String::new()\n+                    };\n+                    let msg = format!(\"{}try using the variant's enum\", preamble);\n+\n+                    err.span_suggestions_with_applicability(\n+                        span,\n+                        &msg,\n+                        enum_candidates.into_iter()\n+                            .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n+                            // variants re\u00ebxported in prelude doesn't mean `prelude::v1` is the\n+                            // type name! FIXME: is there a more principled way to do this that\n+                            // would work for other re\u00ebxports?\n+                            .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n+                            // also say `Option` rather than `std::prelude::v1::Option`\n+                            .map(|enum_ty_path| {\n+                                // FIXME #56861: DRYer prelude filtering\n+                                enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n+                            }),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n@@ -5128,8 +5148,8 @@ fn path_names_to_string(path: &Path) -> String {\n                         .collect::<Vec<_>>())\n }\n \n-/// Get the path for an enum and the variant from an `ImportSuggestion` for an enum variant.\n-fn import_candidate_to_paths(suggestion: &ImportSuggestion) -> (Span, String, String) {\n+/// Get the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n+fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n     let variant_path = &suggestion.path;\n     let variant_path_string = path_names_to_string(variant_path);\n \n@@ -5140,7 +5160,7 @@ fn import_candidate_to_paths(suggestion: &ImportSuggestion) -> (Span, String, St\n     };\n     let enum_path_string = path_names_to_string(&enum_path);\n \n-    (suggestion.path.span, variant_path_string, enum_path_string)\n+    (variant_path_string, enum_path_string)\n }\n \n "}, {"sha": "8b2be84942388bb55c48bb554531d66f3adcefb6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1169,7 +1169,6 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n             // `expression_ty` will be unit).\n             //\n             // Another example is `break` with no argument expression.\n-            assert!(expression_ty.is_unit());\n             assert!(expression_ty.is_unit(), \"if let hack without unit type\");\n             fcx.at(cause, fcx.param_env)\n                .eq_exp(label_expression_as_expected, expression_ty, self.merged_ty())\n@@ -1210,13 +1209,14 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     (self.final_ty.unwrap_or(self.expected_ty), expression_ty)\n                 };\n \n+                let reason_label = \"expected because of this statement\";\n                 let mut db;\n                 match cause.code {\n                     ObligationCauseCode::ReturnNoExpression => {\n                         db = struct_span_err!(\n                             fcx.tcx.sess, cause.span, E0069,\n                             \"`return;` in a function whose return type is not `()`\");\n-                        db.span_label(cause.span, \"return type is not ()\");\n+                        db.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);\n@@ -1234,9 +1234,19 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                             cause.span,\n                             blk_id,\n                         );\n+                        if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n+                            if !sp.overlaps(cause.span) {\n+                                db.span_label(*sp, reason_label);\n+                            }\n+                        }\n                     }\n                     _ => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);\n+                        if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n+                            if !sp.overlaps(cause.span) {\n+                                db.span_label(*sp, reason_label);\n+                            }\n+                        }\n                     }\n                 }\n "}, {"sha": "996b57f558cc517add601e483a2f27ee677fe851", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -123,6 +123,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n                         if self.can_coerce(expr_ty, sole_field_ty) {\n                             let variant_path = self.tcx.item_path_str(variant.did);\n+                            // FIXME #56861: DRYer prelude filtering\n                             Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n                         } else {\n                             None"}, {"sha": "0665452e30a575ac17cd76b1e03134801e0da669", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -538,6 +538,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     err_count_on_creation: usize,\n \n     ret_coercion: Option<RefCell<DynamicCoerceMany<'gcx, 'tcx>>>,\n+    ret_coercion_span: RefCell<Option<Span>>,\n \n     yield_ty: Option<Ty<'tcx>>,\n \n@@ -1987,6 +1988,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n+            ret_coercion_span: RefCell::new(None),\n             yield_ty: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n                                                      ast::CRATE_NODE_ID)),\n@@ -3440,7 +3442,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             len.assert_usize(self.tcx),\n                             field.as_str().parse::<u64>()\n                         ) {\n-                            let base = self.tcx.hir().node_to_pretty_string(base.id);\n+                            let base = self.tcx.sess.source_map()\n+                                .span_to_snippet(base.span)\n+                                .unwrap_or_else(|_| self.tcx.hir().node_to_pretty_string(base.id));\n                             let help = \"instead of using tuple indexing, use array indexing\";\n                             let suggestion = format!(\"{}[{}]\", base, field);\n                             let applicability = if len < user_index {\n@@ -3454,11 +3458,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     ty::RawPtr(..) => {\n-                        let base = self.tcx.hir().node_to_pretty_string(base.id);\n-                        let msg = format!(\"`{}` is a native pointer; try dereferencing it\", base);\n+                        let base = self.tcx.sess.source_map()\n+                            .span_to_snippet(base.span)\n+                            .unwrap_or_else(|_| self.tcx.hir().node_to_pretty_string(base.id));\n+                        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n                         let suggestion = format!(\"(*{}).{}\", base, field);\n                         err.span_suggestion_with_applicability(\n-                            field.span,\n+                            expr.span,\n                             &msg,\n                             suggestion,\n                             Applicability::MaybeIncorrect,\n@@ -4168,11 +4174,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     struct_span_err!(self.tcx.sess, expr.span, E0572,\n                                      \"return statement outside of function body\").emit();\n                 } else if let Some(ref e) = *expr_opt {\n+                    *self.ret_coercion_span.borrow_mut() = Some(e.span);\n                     self.check_return_expr(e);\n                 } else {\n                     let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n+                    *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n                     let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-                    coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                    if let Some((fn_decl, _)) = self.get_fn_decl(expr.id) {\n+                        coercion.coerce_forced_unit(\n+                            self,\n+                            &cause,\n+                            &mut |db| {\n+                                db.span_label(\n+                                    fn_decl.output.span(),\n+                                    format!(\n+                                        \"expected `{}` because of this return type\",\n+                                        fn_decl.output,\n+                                    ),\n+                                );\n+                            },\n+                            true,\n+                        );\n+                    } else {\n+                        coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                    }\n                 }\n                 tcx.types.never\n             }"}, {"sha": "3379be79186efce95209a34a86b0c83497f90ed8", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -43,7 +43,7 @@ impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n     fn poll(self: Pin<&mut Self>, lw: &LocalWaker) -> Poll<Self::Output> {\n-        set_task_waker(lw, || match unsafe { Pin::get_mut_unchecked(self).0.resume() } {\n+        set_task_waker(lw, || match unsafe { Pin::get_unchecked_mut(self).0.resume() } {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         })"}, {"sha": "5bede9eafc14d8e8236f6cb537f41a95f52bc4f7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -273,7 +273,6 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n-#![cfg_attr(not(stage0), feature(min_const_unsafe_fn))]\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n #![feature(nll)]\n@@ -282,7 +281,6 @@\n #![feature(optin_builtin_traits)]\n #![feature(panic_internals)]\n #![feature(panic_unwind)]\n-#![feature(pin)]\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]\n@@ -434,7 +432,7 @@ pub use alloc_crate::borrow;\n pub use alloc_crate::fmt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::format;\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[stable(feature = \"pin\", since = \"1.33.0\")]\n pub use core::pin;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::slice;"}, {"sha": "2238e429a58e01a1c077667cf496538cfd6c341c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -486,9 +486,6 @@ declare_features! (\n \n     // `extern crate self as foo;` puts local crate root into extern prelude under name `foo`.\n     (active, extern_crate_self, \"1.31.0\", Some(56409), None),\n-\n-    // Allows calling `const unsafe fn` inside `unsafe` blocks in `const fn` functions.\n-    (active, min_const_unsafe_fn, \"1.31.0\", Some(55607), None),\n );\n \n declare_features! (\n@@ -694,6 +691,8 @@ declare_features! (\n     (accepted, underscore_imports, \"1.33.0\", Some(48216), None),\n     // Allows `#[repr(packed(N))]` attribute on structs.\n     (accepted, repr_packed, \"1.33.0\", Some(33158), None),\n+    // Allows calling `const unsafe fn` inside `unsafe` blocks in `const fn` functions.\n+    (accepted, min_const_unsafe_fn, \"1.33.0\", Some(55607), None),\n );\n \n // If you change this, please modify `src/doc/unstable-book` as well. You must"}, {"sha": "265ff5f57e4c054bdab89cd0a65fd8f4c97f1b0a", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -11,7 +11,7 @@\n use print::pprust::token_to_string;\n use parse::lexer::StringReader;\n use parse::{token, PResult};\n-use tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree};\n \n impl<'a> StringReader<'a> {\n     // Parse a stream of tokens into a list of `TokenTree`s, up to an `Eof`.\n@@ -186,8 +186,7 @@ impl<'a> StringReader<'a> {\n                 let raw = self.span_src_raw;\n                 self.real_token();\n                 let is_joint = raw.hi() == self.span_src_raw.lo() && token::is_op(&self.token);\n-\n-                Ok(if is_joint { tt.joint() } else { tt.into() })\n+                Ok(TokenStream::Tree(tt, if is_joint { Joint } else { NonJoint }))\n             }\n         }\n     }"}, {"sha": "b04495d751a85ce803b2c5c7a7cd7a68aa7ba459", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -123,7 +123,7 @@ impl TokenTree {\n     }\n \n     pub fn joint(self) -> TokenStream {\n-        TokenStream::JointTree(self)\n+        TokenStream::Tree(self, Joint)\n     }\n \n     /// Returns the opening delimiter as a token tree.\n@@ -156,15 +156,22 @@ impl TokenTree {\n #[derive(Clone, Debug)]\n pub enum TokenStream {\n     Empty,\n-    Tree(TokenTree),\n-    JointTree(TokenTree),\n+    Tree(TokenTree, IsJoint),\n     Stream(Lrc<Vec<TokenStream>>),\n }\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 32);\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub enum IsJoint {\n+    Joint,\n+    NonJoint\n+}\n+\n+use self::IsJoint::*;\n+\n impl TokenStream {\n     /// Given a `TokenStream` with a `Stream` of only two arguments, return a new `TokenStream`\n     /// separating the two arguments with a comma for diagnostic suggestions.\n@@ -176,16 +183,16 @@ impl TokenStream {\n             while let Some((pos, ts)) = iter.next() {\n                 if let Some((_, next)) = iter.peek() {\n                     let sp = match (&ts, &next) {\n-                        (TokenStream::Tree(TokenTree::Token(_, token::Token::Comma)), _) |\n-                        (_, TokenStream::Tree(TokenTree::Token(_, token::Token::Comma))) => {\n-                            continue;\n-                        }\n-                        (TokenStream::Tree(TokenTree::Token(sp, _)), _) => *sp,\n-                        (TokenStream::Tree(TokenTree::Delimited(sp, ..)), _) => sp.entire(),\n+                        (TokenStream::Tree(TokenTree::Token(_, token::Token::Comma), NonJoint), _) |\n+                        (_, TokenStream::Tree(TokenTree::Token(_, token::Token::Comma), NonJoint))\n+                          => continue,\n+                        (TokenStream::Tree(TokenTree::Token(sp, _), NonJoint), _) => *sp,\n+                        (TokenStream::Tree(TokenTree::Delimited(sp, ..), NonJoint), _) =>\n+                            sp.entire(),\n                         _ => continue,\n                     };\n                     let sp = sp.shrink_to_hi();\n-                    let comma = TokenStream::Tree(TokenTree::Token(sp, token::Comma));\n+                    let comma = TokenStream::Tree(TokenTree::Token(sp, token::Comma), NonJoint);\n                     suggestion = Some((pos, comma, sp));\n                 }\n             }\n@@ -204,7 +211,7 @@ impl TokenStream {\n \n impl From<TokenTree> for TokenStream {\n     fn from(tt: TokenTree) -> TokenStream {\n-        TokenStream::Tree(tt)\n+        TokenStream::Tree(tt, NonJoint)\n     }\n }\n \n@@ -232,7 +239,7 @@ impl Extend<TokenStream> for TokenStream {\n                 vec.reserve(iter.size_hint().0);\n                 vec\n             }\n-            TokenStream::Tree(_) | TokenStream::JointTree(_) => {\n+            TokenStream::Tree(..) => {\n                 let mut vec = Vec::new();\n                 vec.reserve(1 + iter.size_hint().0);\n                 vec.push(this);\n@@ -369,8 +376,7 @@ impl TokenStream {\n     /// Returns true if the token tree is a joint operation w.r.t. `proc_macro::TokenNode`.\n     pub fn as_tree(self) -> (TokenTree, bool /* joint? */) {\n         match self {\n-            TokenStream::Tree(tree) => (tree, false),\n-            TokenStream::JointTree(tree) => (tree, true),\n+            TokenStream::Tree(tree, is_joint) => (tree, is_joint == Joint),\n             _ => unreachable!(),\n         }\n     }\n@@ -381,8 +387,7 @@ impl TokenStream {\n         let mut i = 0;\n         while let Some(stream) = trees.next_as_stream() {\n             result.push(match stream {\n-                TokenStream::Tree(tree) => f(i, tree).into(),\n-                TokenStream::JointTree(tree) => f(i, tree).joint(),\n+                TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(i, tree), is_joint),\n                 _ => unreachable!()\n             });\n             i += 1;\n@@ -395,27 +400,25 @@ impl TokenStream {\n         let mut result = Vec::new();\n         while let Some(stream) = trees.next_as_stream() {\n             result.push(match stream {\n-                TokenStream::Tree(tree) => f(tree).into(),\n-                TokenStream::JointTree(tree) => f(tree).joint(),\n+                TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(tree), is_joint),\n                 _ => unreachable!()\n             });\n         }\n         TokenStream::new(result)\n     }\n \n-    fn first_tree_and_joint(&self) -> Option<(TokenTree, bool)> {\n+    fn first_tree_and_joint(&self) -> Option<(TokenTree, IsJoint)> {\n         match self {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree) => Some((tree.clone(), false)),\n-            TokenStream::JointTree(ref tree) => Some((tree.clone(), true)),\n+            TokenStream::Tree(ref tree, is_joint) => Some((tree.clone(), *is_joint)),\n             TokenStream::Stream(ref stream) => stream.first().unwrap().first_tree_and_joint(),\n         }\n     }\n \n     fn last_tree_if_joint(&self) -> Option<TokenTree> {\n         match self {\n-            TokenStream::Empty | TokenStream::Tree(..) => None,\n-            TokenStream::JointTree(ref tree) => Some(tree.clone()),\n+            TokenStream::Empty | TokenStream::Tree(_, NonJoint) => None,\n+            TokenStream::Tree(ref tree, Joint) => Some(tree.clone()),\n             TokenStream::Stream(ref stream) => stream.last().unwrap().last_tree_if_joint(),\n         }\n     }\n@@ -439,11 +442,7 @@ impl TokenStreamBuilder {\n                     self.push_all_but_last_tree(&last_stream);\n                     let glued_span = last_span.to(span);\n                     let glued_tt = TokenTree::Token(glued_span, glued_tok);\n-                    let glued_tokenstream = if is_joint {\n-                        glued_tt.joint()\n-                    } else {\n-                        glued_tt.into()\n-                    };\n+                    let glued_tokenstream = TokenStream::Tree(glued_tt, is_joint);\n                     self.0.push(glued_tokenstream);\n                     self.push_all_but_first_tree(&stream);\n                     return\n@@ -493,8 +492,7 @@ pub struct Cursor(CursorKind);\n #[derive(Clone)]\n enum CursorKind {\n     Empty,\n-    Tree(TokenTree, bool /* consumed? */),\n-    JointTree(TokenTree, bool /* consumed? */),\n+    Tree(TokenTree, IsJoint, bool /* consumed? */),\n     Stream(StreamCursor),\n }\n \n@@ -516,9 +514,9 @@ impl StreamCursor {\n                 self.index += 1;\n                 let next = self.stream[self.index - 1].clone();\n                 match next {\n-                    TokenStream::Tree(..) | TokenStream::JointTree(..) => return Some(next),\n-                    TokenStream::Stream(stream) => self.insert(stream),\n                     TokenStream::Empty => {}\n+                    TokenStream::Tree(..) => return Some(next),\n+                    TokenStream::Stream(stream) => self.insert(stream),\n                 }\n             } else if let Some((stream, index)) = self.stack.pop() {\n                 self.stream = stream;\n@@ -540,7 +538,7 @@ impl Iterator for Cursor {\n \n     fn next(&mut self) -> Option<TokenTree> {\n         self.next_as_stream().map(|stream| match stream {\n-            TokenStream::Tree(tree) | TokenStream::JointTree(tree) => tree,\n+            TokenStream::Tree(tree, _) => tree,\n             _ => unreachable!()\n         })\n     }\n@@ -550,18 +548,15 @@ impl Cursor {\n     fn new(stream: TokenStream) -> Self {\n         Cursor(match stream {\n             TokenStream::Empty => CursorKind::Empty,\n-            TokenStream::Tree(tree) => CursorKind::Tree(tree, false),\n-            TokenStream::JointTree(tree) => CursorKind::JointTree(tree, false),\n+            TokenStream::Tree(tree, is_joint) => CursorKind::Tree(tree, is_joint, false),\n             TokenStream::Stream(stream) => CursorKind::Stream(StreamCursor::new(stream)),\n         })\n     }\n \n     pub fn next_as_stream(&mut self) -> Option<TokenStream> {\n         let (stream, consumed) = match self.0 {\n-            CursorKind::Tree(ref tree, ref mut consumed @ false) =>\n-                (tree.clone().into(), consumed),\n-            CursorKind::JointTree(ref tree, ref mut consumed @ false) =>\n-                (tree.clone().joint(), consumed),\n+            CursorKind::Tree(ref tree, ref is_joint, ref mut consumed @ false) =>\n+                (TokenStream::Tree(tree.clone(), *is_joint), consumed),\n             CursorKind::Stream(ref mut cursor) => return cursor.next_as_stream(),\n             _ => return None,\n         };\n@@ -574,7 +569,7 @@ impl Cursor {\n         match self.0 {\n             _ if stream.is_empty() => return,\n             CursorKind::Empty => *self = stream.trees(),\n-            CursorKind::Tree(_, consumed) | CursorKind::JointTree(_, consumed) => {\n+            CursorKind::Tree(_, _, consumed) => {\n                 *self = TokenStream::new(vec![self.original_stream(), stream]).trees();\n                 if consumed {\n                     self.next();\n@@ -589,8 +584,8 @@ impl Cursor {\n     pub fn original_stream(&self) -> TokenStream {\n         match self.0 {\n             CursorKind::Empty => TokenStream::empty(),\n-            CursorKind::Tree(ref tree, _) => tree.clone().into(),\n-            CursorKind::JointTree(ref tree, _) => tree.clone().joint(),\n+            CursorKind::Tree(ref tree, ref is_joint, _) =>\n+                TokenStream::Tree(tree.clone(), *is_joint),\n             CursorKind::Stream(ref cursor) => TokenStream::Stream(\n                 cursor.stack.get(0).cloned().map(|(stream, _)| stream)\n                     .unwrap_or_else(|| cursor.stream.clone())\n@@ -602,9 +597,8 @@ impl Cursor {\n         fn look_ahead(streams: &[TokenStream], mut n: usize) -> Result<TokenTree, usize> {\n             for stream in streams {\n                 n = match stream {\n-                    TokenStream::Tree(ref tree) | TokenStream::JointTree(ref tree)\n-                        if n == 0 => return Ok(tree.clone()),\n-                    TokenStream::Tree(..) | TokenStream::JointTree(..) => n - 1,\n+                    TokenStream::Tree(ref tree, _) if n == 0 => return Ok(tree.clone()),\n+                    TokenStream::Tree(..) => n - 1,\n                     TokenStream::Stream(ref stream) => match look_ahead(stream, n) {\n                         Ok(tree) => return Ok(tree),\n                         Err(n) => n,\n@@ -617,10 +611,8 @@ impl Cursor {\n \n         match self.0 {\n             CursorKind::Empty |\n-            CursorKind::Tree(_, true) |\n-            CursorKind::JointTree(_, true) => Err(n),\n-            CursorKind::Tree(ref tree, false) |\n-            CursorKind::JointTree(ref tree, false) => look_ahead(&[tree.clone().into()], n),\n+            CursorKind::Tree(_, _, true) => Err(n),\n+            CursorKind::Tree(ref tree, _, false) => look_ahead(&[tree.clone().into()], n),\n             CursorKind::Stream(ref cursor) => {\n                 look_ahead(&cursor.stream[cursor.index ..], n).or_else(|mut n| {\n                     for &(ref stream, index) in cursor.stack.iter().rev() {\n@@ -653,8 +645,7 @@ impl From<TokenStream> for ThinTokenStream {\n     fn from(stream: TokenStream) -> ThinTokenStream {\n         ThinTokenStream(match stream {\n             TokenStream::Empty => None,\n-            TokenStream::Tree(tree) => Some(Lrc::new(vec![tree.into()])),\n-            TokenStream::JointTree(tree) => Some(Lrc::new(vec![tree.joint()])),\n+            TokenStream::Tree(..) => Some(Lrc::new(vec![stream])),\n             TokenStream::Stream(stream) => Some(stream),\n         })\n     }"}, {"sha": "507ceb53432d6fb62c510e161a209065abc33139", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -21,7 +21,7 @@ use syntax::ast;\n use syntax::ext::base::ExtCtxt;\n use syntax::parse::lexer::comments;\n use syntax::parse::{self, token, ParseSess};\n-use syntax::tokenstream::{self, DelimSpan, TokenStream};\n+use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream};\n use syntax_pos::hygiene::{SyntaxContext, Transparency};\n use syntax_pos::symbol::{keywords, Symbol};\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n@@ -278,11 +278,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n         };\n \n         let tree = tokenstream::TokenTree::Token(span, token);\n-        if joint {\n-            tree.joint()\n-        } else {\n-            tree.into()\n-        }\n+        TokenStream::Tree(tree, if joint { Joint } else { NonJoint })\n     }\n }\n "}, {"sha": "ae2259d5258989121787ad1010109a09138ae1f3", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -334,6 +334,13 @@ impl Span {\n         span.lo <= other.lo && other.hi <= span.hi\n     }\n \n+    /// Return `true` if `self` touches `other`.\n+    pub fn overlaps(self, other: Span) -> bool {\n+        let span = self.data();\n+        let other = other.data();\n+        span.lo < other.hi && other.lo < span.hi\n+    }\n+\n     /// Return true if the spans are equal with regards to the source text.\n     ///\n     /// Use this instead of `==` when either span could be generated code,"}, {"sha": "0544ff86aacfa2bb9cd17ab0b5c5c49f442b899c", "filename": "src/test/codegen/issue-56927.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fcodegen%2Fissue-56927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fcodegen%2Fissue-56927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-56927.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,44 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type=\"rlib\"]\n+use std::usize;\n+\n+#[repr(align(16))]\n+pub struct S {\n+    arr: [u32; 4],\n+}\n+\n+// CHECK-LABEL: @test1\n+// CHECK: store i32 0, i32* %{{.+}}, align 16\n+// CHECK: store i32 1, i32* %{{.+}}, align 4\n+// CHECK: store i32 2, i32* %{{.+}}, align 8\n+// CHECK: store i32 3, i32* %{{.+}}, align 4\n+#[no_mangle]\n+pub fn test1(s: &mut S) {\n+    s.arr[0] = 0;\n+    s.arr[1] = 1;\n+    s.arr[2] = 2;\n+    s.arr[3] = 3;\n+}\n+\n+// CHECK-LABEL: @test2\n+// CHECK: store i32 4, i32* %{{.+}}, align 4\n+#[allow(const_err)]\n+#[no_mangle]\n+pub fn test2(s: &mut S) {\n+    s.arr[usize::MAX / 4 + 1] = 4;\n+}\n+\n+// CHECK-LABEL: @test3\n+// CHECK: store i32 5, i32* %{{.+}}, align 4\n+#[no_mangle]\n+pub fn test3(s: &mut S, i: usize) {\n+    s.arr[i] = 5;\n+}\n+\n+// CHECK-LABEL: @test4\n+// CHECK: store i32 6, i32* %{{.+}}, align 4\n+#[no_mangle]\n+pub fn test4(s: &mut S) {\n+    s.arr = [6; 4];\n+}"}, {"sha": "3b4e89f12e0ad923fe345f5385ef720cb82bae21", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -83,6 +83,42 @@ pub fn call_pkd2(f: fn() -> Array) -> BigPacked2 {\n     BigPacked2 { dealign: 0, data: f() }\n }\n \n+// CHECK-LABEL: @write_packed_array1\n+// CHECK: store i32 0, i32* %{{.+}}, align 1\n+// CHECK: store i32 1, i32* %{{.+}}, align 1\n+// CHECK: store i32 2, i32* %{{.+}}, align 1\n+#[no_mangle]\n+pub fn write_packed_array1(p: &mut BigPacked1) {\n+    p.data.0[0] = 0;\n+    p.data.0[1] = 1;\n+    p.data.0[2] = 2;\n+}\n+\n+// CHECK-LABEL: @write_packed_array2\n+// CHECK: store i32 0, i32* %{{.+}}, align 2\n+// CHECK: store i32 1, i32* %{{.+}}, align 2\n+// CHECK: store i32 2, i32* %{{.+}}, align 2\n+#[no_mangle]\n+pub fn write_packed_array2(p: &mut BigPacked2) {\n+    p.data.0[0] = 0;\n+    p.data.0[1] = 1;\n+    p.data.0[2] = 2;\n+}\n+\n+// CHECK-LABEL: @repeat_packed_array1\n+// CHECK: store i32 42, i32* %{{.+}}, align 1\n+#[no_mangle]\n+pub fn repeat_packed_array1(p: &mut BigPacked1) {\n+    p.data.0 = [42; 8];\n+}\n+\n+// CHECK-LABEL: @repeat_packed_array2\n+// CHECK: store i32 42, i32* %{{.+}}, align 2\n+#[no_mangle]\n+pub fn repeat_packed_array2(p: &mut BigPacked2) {\n+    p.data.0 = [42; 8];\n+}\n+\n #[repr(packed)]\n #[derive(Copy, Clone)]\n pub struct Packed1Pair(u8, u32);"}, {"sha": "0fd3d5424383fc9c4b11a7ca2a56aec3017505b9", "filename": "src/test/codegen/x86_mmx.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fx86_mmx.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -18,6 +18,7 @@\n // ignore-powerpc64le\n // ignore-sparc\n // ignore-sparc64\n+// ignore-s390x\n // compile-flags: -O\n \n #![feature(repr_simd)]"}, {"sha": "7e446fdaeaf41740b32530035826090189f4d1de", "filename": "src/test/compile-fail/must_use-in-stdlib-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmust_use-in-stdlib-traits.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,5 +1,5 @@\n #![deny(unused_must_use)]\n-#![feature(futures_api, pin, arbitrary_self_types)]\n+#![feature(arbitrary_self_types, futures_api)]\n \n use std::iter::Iterator;\n use std::future::Future;"}, {"sha": "3cd622a33b173afdbed2fb60bd59e4c7eb9aa46c", "filename": "src/test/run-pass-fulldeps/newtype_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_attrs, rustc_private, step_trait, min_const_unsafe_fn)]\n+#![feature(rustc_attrs, rustc_private, step_trait)]\n \n #[macro_use] extern crate rustc_data_structures;\n extern crate rustc_serialize;"}, {"sha": "e5ee2233b766d2c78bae653a86713321ddb1d21e", "filename": "src/test/run-pass/arbitrary_self_types_stdlib_pointers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-pass%2Farbitrary_self_types_stdlib_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-pass%2Farbitrary_self_types_stdlib_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_stdlib_pointers.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(pin)]\n+#![feature(arbitrary_self_types)]\n #![feature(rustc_attrs)]\n \n use std::{"}, {"sha": "d9eb801a2066841bdf1d6d01fab22be015394c6b", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -10,7 +10,7 @@\n \n // edition:2018\n \n-#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+#![feature(arbitrary_self_types, async_await, await_macro, futures_api)]\n \n use std::pin::Pin;\n use std::future::Future;\n@@ -138,7 +138,7 @@ where\n     F: FnOnce(u8) -> Fut,\n     Fut: Future<Output = u8>,\n {\n-    let mut fut = Box::pinned(f(9));\n+    let mut fut = Box::pin(f(9));\n     let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n     let waker = local_waker_from_nonlocal(counter.clone());\n     assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));"}, {"sha": "ac67488924993c8137132cdad7d24da4687e7330", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(arbitrary_self_types, futures_api, pin)]\n+#![feature(arbitrary_self_types, futures_api)]\n #![allow(unused)]\n \n use std::future::Future;"}, {"sha": "f38fab91de7c4b1a501b2fd122482689ccec36bb", "filename": "src/test/rustdoc/const-display.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frustdoc%2Fconst-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frustdoc%2Fconst-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-display.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -15,7 +15,6 @@\n             issue = \"0\")]\n \n #![feature(rustc_const_unstable, const_fn, foo, foo2)]\n-#![feature(min_const_unsafe_fn)]\n #![feature(staged_api)]\n \n // @has 'foo/fn.foo.html' '//pre' 'pub unsafe fn foo() -> u32'"}, {"sha": "da875fe7a6b77ce7618ab6a9721ad94ebbbbd1ff", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -8,27 +8,62 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-min_const_unsafe_fn\n+//------------------------------------------------------------------------------\n+// OK\n+//------------------------------------------------------------------------------\n \n-// ok\n const unsafe fn ret_i32_no_unsafe() -> i32 { 42 }\n const unsafe fn ret_null_ptr_no_unsafe<T>() -> *const T { 0 as *const T }\n const unsafe fn ret_null_mut_ptr_no_unsafe<T>() -> *mut T { 0 as *mut T }\n const fn no_unsafe() { unsafe {} }\n \n-// not ok\n const fn call_unsafe_const_fn() -> i32 {\n-    unsafe { ret_i32_no_unsafe() } //~ ERROR calls to `const unsafe fn` in const fns are unstable\n+    unsafe { ret_i32_no_unsafe() }\n }\n const fn call_unsafe_generic_const_fn() -> *const String {\n     unsafe { ret_null_ptr_no_unsafe::<String>() }\n-    //~^ ERROR calls to `const unsafe fn` in const fns are unstable\n }\n-const fn call_unsafe_generic_cell_const_fn() -> *const Vec<std::cell::Cell<u32>> {\n+const fn call_unsafe_generic_cell_const_fn()\n+    -> *const Vec<std::cell::Cell<u32>>\n+{\n     unsafe { ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>() }\n-    //~^ ERROR calls to `const unsafe fn` in const fns\n }\n-const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x }\n+\n+const unsafe fn call_unsafe_const_unsafe_fn() -> i32 {\n+    unsafe { ret_i32_no_unsafe() }\n+}\n+const unsafe fn call_unsafe_generic_const_unsafe_fn() -> *const String {\n+    unsafe { ret_null_ptr_no_unsafe::<String>() }\n+}\n+const unsafe fn call_unsafe_generic_cell_const_unsafe_fn()\n+    -> *const Vec<std::cell::Cell<u32>>\n+{\n+    unsafe { ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>() }\n+}\n+\n+const unsafe fn call_unsafe_const_unsafe_fn_immediate() -> i32 {\n+    ret_i32_no_unsafe()\n+}\n+const unsafe fn call_unsafe_generic_const_unsafe_fn_immediate() -> *const String {\n+    ret_null_ptr_no_unsafe::<String>()\n+}\n+const unsafe fn call_unsafe_generic_cell_const_unsafe_fn_immediate()\n+    -> *const Vec<std::cell::Cell<u32>>\n+{\n+    ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>()\n+}\n+\n+//------------------------------------------------------------------------------\n+// NOT OK\n+//------------------------------------------------------------------------------\n+\n+const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n+//~^ dereferencing raw pointers in constant functions\n+\n+const unsafe fn bad_const_unsafe_deref_raw(x: *mut usize) -> usize { *x }\n+//~^ dereferencing raw pointers in constant functions\n+\n+const unsafe fn bad_const_unsafe_deref_raw_ref(x: *mut usize) -> &'static usize { &*x }\n //~^ dereferencing raw pointers in constant functions\n \n fn main() {}"}, {"sha": "68b782bf0e7eaed960d7290072b082a137e2082a", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.stderr", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,43 +1,44 @@\n error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n-  --> $DIR/min_const_fn_unsafe.rs:31:59\n+  --> $DIR/min_const_fn_unsafe.rs:60:77\n    |\n-LL | const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x }\n-   |                                                           ^^\n+LL | const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n+   |                                                                             ^^^\n    |\n    = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n-error[E0658]: unions in const fn are unstable (see issue #51909)\n-  --> $DIR/min_const_fn_unsafe.rs:38:5\n+error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n+  --> $DIR/min_const_fn_unsafe.rs:63:70\n    |\n-LL |     Foo { x: () }.y\n-   |     ^^^^^^^^^^^^^^^\n+LL | const unsafe fn bad_const_unsafe_deref_raw(x: *mut usize) -> usize { *x }\n+   |                                                                      ^^\n    |\n-   = help: add #![feature(const_fn_union)] to the crate attributes to enable\n+   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n-error[E0658]: calls to `const unsafe fn` in const fns are unstable (see issue #55607)\n-  --> $DIR/min_const_fn_unsafe.rs:21:14\n+error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n+  --> $DIR/min_const_fn_unsafe.rs:66:83\n    |\n-LL |     unsafe { ret_i32_no_unsafe() } //~ ERROR calls to `const unsafe fn` in const fns are unstable\n-   |              ^^^^^^^^^^^^^^^^^^^\n+LL | const unsafe fn bad_const_unsafe_deref_raw_ref(x: *mut usize) -> &'static usize { &*x }\n+   |                                                                                   ^^^\n    |\n-   = help: add #![feature(min_const_unsafe_fn)] to the crate attributes to enable\n+   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n-error[E0658]: calls to `const unsafe fn` in const fns are unstable (see issue #55607)\n-  --> $DIR/min_const_fn_unsafe.rs:24:14\n+error[E0658]: unions in const fn are unstable (see issue #51909)\n+  --> $DIR/min_const_fn_unsafe.rs:73:5\n    |\n-LL |     unsafe { ret_null_ptr_no_unsafe::<String>() }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     Foo { x: () }.y\n+   |     ^^^^^^^^^^^^^^^\n    |\n-   = help: add #![feature(min_const_unsafe_fn)] to the crate attributes to enable\n+   = help: add #![feature(const_fn_union)] to the crate attributes to enable\n \n-error[E0658]: calls to `const unsafe fn` in const fns are unstable (see issue #55607)\n-  --> $DIR/min_const_fn_unsafe.rs:28:14\n+error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n+  --> $DIR/min_const_fn_unsafe.rs:60:77\n    |\n-LL |     unsafe { ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>() }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | const fn bad_const_fn_deref_raw(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n+   |                                                                             ^^^ dereference of raw pointer\n    |\n-   = help: add #![feature(min_const_unsafe_fn)] to the crate attributes to enable\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0658`.\n+Some errors occurred: E0133, E0658.\n+For more information about an error, try `rustc --explain E0133`."}, {"sha": "67a48206126421f973e497d0c1ad2eae03dda04b", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_feature_gate.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e16928082aa2d66a4498132572b69156b94b25f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e16928082aa2d66a4498132572b69156b94b25f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs?ref=e16928082aa2d66a4498132572b69156b94b25f1", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(min_const_unsafe_fn)]\n-\n-// ok\n-const unsafe fn foo4() -> i32 { 42 }\n-const unsafe fn foo5<T>() -> *const T { 0 as *const T }\n-const unsafe fn foo6<T>() -> *mut T { 0 as *mut T }\n-const fn no_unsafe() { unsafe {} }\n-\n-const fn foo8() -> i32 {\n-    unsafe { foo4() }\n-}\n-const fn foo9() -> *const String {\n-    unsafe { foo5::<String>() }\n-}\n-const fn foo10() -> *const Vec<std::cell::Cell<u32>> {\n-    unsafe { foo6::<Vec<std::cell::Cell<u32>>>() }\n-}\n-const unsafe fn foo8_3() -> i32 {\n-    unsafe { foo4() }\n-}\n-const unsafe fn foo9_3() -> *const String {\n-    unsafe { foo5::<String>() }\n-}\n-const unsafe fn foo10_3() -> *const Vec<std::cell::Cell<u32>> {\n-    unsafe { foo6::<Vec<std::cell::Cell<u32>>>() }\n-}\n-const unsafe fn foo8_2() -> i32 {\n-    foo4()\n-}\n-const unsafe fn foo9_2() -> *const String {\n-    foo5::<String>()\n-}\n-const unsafe fn foo10_2() -> *const Vec<std::cell::Cell<u32>> {\n-    foo6::<Vec<std::cell::Cell<u32>>>()\n-}\n-const unsafe fn foo30_3(x: *mut usize) -> usize { *x }\n-//~^ dereferencing raw pointers in constant functions\n-\n-const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x }\n-//~^ dereferencing raw pointers in constant functions\n-\n-const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n-//~^ dereferencing raw pointers in constant functions\n-\n-fn main() {}\n-\n-const unsafe fn no_union() {\n-    union Foo { x: (), y: () }\n-    Foo { x: () }.y\n-    //~^ unions in const fn\n-}"}, {"sha": "63bf9a53e509cc7a908b2813d23c5d92b00bbdd8", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_feature_gate.stderr", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e16928082aa2d66a4498132572b69156b94b25f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e16928082aa2d66a4498132572b69156b94b25f1/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr?ref=e16928082aa2d66a4498132572b69156b94b25f1", "patch": "@@ -1,44 +0,0 @@\n-error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:46:51\n-   |\n-LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x }\n-   |                                                   ^^\n-   |\n-   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n-\n-error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:49:60\n-   |\n-LL | const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x }\n-   |                                                            ^^^\n-   |\n-   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n-\n-error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:52:62\n-   |\n-LL | const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n-   |                                                              ^^^\n-   |\n-   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n-\n-error[E0658]: unions in const fn are unstable (see issue #51909)\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:59:5\n-   |\n-LL |     Foo { x: () }.y\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(const_fn_union)] to the crate attributes to enable\n-\n-error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:52:62\n-   |\n-LL | const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n-   |                                                              ^^^ dereference of raw pointer\n-   |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-\n-error: aborting due to 5 previous errors\n-\n-Some errors occurred: E0133, E0658.\n-For more information about an error, try `rustc --explain E0133`."}, {"sha": "33fcea9818959f3c5ffecc5dd5c5c1004ce535e3", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -14,7 +14,6 @@\n             issue = \"0\")]\n \n #![feature(rustc_const_unstable, const_fn, foo, foo2)]\n-#![feature(min_const_unsafe_fn)]\n #![feature(staged_api)]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "2a0ef0e6b96515a5a482497ccdf9e3145a508b87", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,23 +1,23 @@\n error: can only call other `min_const_fn` within a `min_const_fn`\n-  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:26:41\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:25:41\n    |\n LL | const unsafe fn bar() -> u32 { unsafe { foo() } } //~ ERROR can only call other `min_const_fn`\n    |                                         ^^^^^\n \n error: can only call other `min_const_fn` within a `min_const_fn`\n-  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:33:42\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:32:42\n    |\n LL | const unsafe fn bar2() -> u32 { unsafe { foo2() } } //~ ERROR can only call other `min_const_fn`\n    |                                          ^^^^^^\n \n error: only int, `bool` and `char` operations are stable in const fn\n-  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:37:33\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:36:33\n    |\n LL | const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` op\n    |                                 ^^^^^^^^^^^^^\n \n error: can only call other `min_const_fn` within a `min_const_fn`\n-  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:45:48\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:44:48\n    |\n LL | const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } } //~ ERROR can only call other\n    |                                                ^^^^^^^^^^^^"}, {"sha": "68205edd63bc9f2bfc1b72c25c03de276c0f817b", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -14,7 +14,6 @@\n             issue = \"0\")]\n \n #![feature(rustc_const_unstable, const_fn, foo, foo2)]\n-#![feature(min_const_unsafe_fn)]\n #![feature(staged_api)]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "6153301518563c7a8533613679a7918b6ea0c1e8", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,17 +1,17 @@\n error: can only call other `min_const_fn` within a `min_const_fn`\n-  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:26:32\n+  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:25:32\n    |\n LL | const unsafe fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n    |                                ^^^^^\n \n error: can only call other `min_const_fn` within a `min_const_fn`\n-  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:33:33\n+  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:32:33\n    |\n LL | const unsafe fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n    |                                 ^^^^^^\n \n error: can only call other `min_const_fn` within a `min_const_fn`\n-  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:41:39\n+  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:40:39\n    |\n LL | const unsafe fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `min_const_fn`\n    |                                       ^^^^^^^^^^^^"}, {"sha": "27e1a111163b15999cc7c9f34718bc6f40d4cf2b", "filename": "src/test/ui/consts/static_mut_containing_mut_ref.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,7 @@\n+// compile-pass\n+\n+static mut STDERR_BUFFER_SPACE: [u8; 42] = [0u8; 42];\n+\n+pub static mut STDERR_BUFFER: *mut [u8] = unsafe { &mut STDERR_BUFFER_SPACE };\n+\n+fn main() {}"}, {"sha": "4180b1e295ab049d4eaceb20aca335d07d5e479c", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_let)]\n+\n+static mut STDERR_BUFFER_SPACE: u8 = 0;\n+\n+pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n+//~^ ERROR references in statics may only refer to immutable values\n+//~| ERROR static contains unimplemented expression type\n+\n+fn main() {}"}, {"sha": "f0ae1545056b7ad3ac98d209eb0d3fa7d5e81db5", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,16 @@\n+error[E0017]: references in statics may only refer to immutable values\n+  --> $DIR/static_mut_containing_mut_ref2.rs:5:46\n+   |\n+LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values\n+\n+error[E0019]: static contains unimplemented expression type\n+  --> $DIR/static_mut_containing_mut_ref2.rs:5:45\n+   |\n+LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0017, E0019.\n+For more information about an error, try `rustc --explain E0017`."}, {"sha": "0bc7faa9afdec7b2d170a33883be90041fcfe459", "filename": "src/test/ui/consts/static_mut_containing_mut_ref3.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,8 @@\n+#![feature(const_let)]\n+\n+static mut FOO: (u8, u8) = (42, 43);\n+\n+static mut BAR: () = unsafe { FOO.0 = 99; };\n+//~^ ERROR could not evaluate static initializer\n+\n+fn main() {}"}, {"sha": "cae53c6fee9dd9d6297adb4c4a1276e550777a57", "filename": "src/test/ui/consts/static_mut_containing_mut_ref3.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref3.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/static_mut_containing_mut_ref3.rs:5:31\n+   |\n+LL | static mut BAR: () = unsafe { FOO.0 = 99; };\n+   |                               ^^^^^^^^^^ tried to modify a static's initial value from another static's initializer\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "496ce4fb378aec933ca76baac9209e2391e38b3a", "filename": "src/test/ui/dead-code-tuple-struct-field.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,12 @@\n+// compile-pass\n+\n+#![deny(dead_code)]\n+\n+const LEN: usize = 4;\n+\n+#[derive(Debug)]\n+struct Wrapper([u8; LEN]);\n+\n+fn main() {\n+    println!(\"{:?}\", Wrapper([0, 1, 2, 3]));\n+}"}, {"sha": "264cfa449942c59d57010ef99562e657b2d08906", "filename": "src/test/ui/did_you_mean/issue-56028-there-is-an-enum-variant.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,15 @@\n+enum PutDown { Set }\n+enum AffixHeart { Set }\n+enum CauseToBe { Set }\n+enum Determine { Set }\n+enum TableDishesAction { Set }\n+enum Solidify { Set }\n+enum UnorderedCollection { Set }\n+\n+fn setup() -> Set { Set }\n+//~^ ERROR cannot find type `Set` in this scope\n+//~| ERROR cannot find value `Set` in this scope\n+\n+fn main() {\n+    setup();\n+}"}, {"sha": "6107ca32a5d75aec623a738daf538f021a82f1d8", "filename": "src/test/ui/did_you_mean/issue-56028-there-is-an-enum-variant.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-56028-there-is-an-enum-variant.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,38 @@\n+error[E0412]: cannot find type `Set` in this scope\n+  --> $DIR/issue-56028-there-is-an-enum-variant.rs:9:15\n+   |\n+LL | fn setup() -> Set { Set }\n+   |               ^^^ not found in this scope\n+help: there is an enum variant `AffixHeart::Set` and 7 others; try using the variant's enum\n+   |\n+LL | fn setup() -> AffixHeart { Set }\n+   |               ^^^^^^^^^^\n+LL | fn setup() -> CauseToBe { Set }\n+   |               ^^^^^^^^^\n+LL | fn setup() -> Determine { Set }\n+   |               ^^^^^^^^^\n+LL | fn setup() -> PutDown { Set }\n+   |               ^^^^^^^\n+and 3 other candidates\n+\n+error[E0425]: cannot find value `Set` in this scope\n+  --> $DIR/issue-56028-there-is-an-enum-variant.rs:9:21\n+   |\n+LL | fn setup() -> Set { Set }\n+   |                     ^^^ not found in this scope\n+help: possible candidates are found in other modules, you can import them into scope\n+   |\n+LL | use AffixHeart::Set;\n+   |\n+LL | use CauseToBe::Set;\n+   |\n+LL | use Determine::Set;\n+   |\n+LL | use PutDown::Set;\n+   |\n+and 3 other candidates\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0412, E0425.\n+For more information about an error, try `rustc --explain E0412`."}, {"sha": "eb869f5539f366f777f8f9f95d4a6157199aa180", "filename": "src/test/ui/enum/enum-variant-type-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fenum%2Fenum-variant-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fenum%2Fenum-variant-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-variant-type-2.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -5,7 +5,7 @@ LL | fn foo(x: Foo::Bar) {} //~ ERROR expected type, found variant `Foo::Bar`\n    |           ^^^^^^^^\n    |           |\n    |           not a type\n-   |           help: you can try using the variant's enum: `Foo`\n+   |           help: try using the variant's enum: `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "12b778f42e22ca7cba305e89defe55f4bdeeaee8", "filename": "src/test/ui/error-codes/E0069.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Ferror-codes%2FE0069.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Ferror-codes%2FE0069.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0069.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,8 +1,10 @@\n error[E0069]: `return;` in a function whose return type is not `()`\n   --> $DIR/E0069.rs:12:5\n    |\n+LL | fn foo() -> u8 {\n+   |             -- expected `u8` because of this return type\n LL |     return;\n-   |     ^^^^^^ return type is not ()\n+   |     ^^^^^^ return type is not `()`\n \n error: aborting due to previous error\n "}, {"sha": "f1d2071bbdb9ea2ead06a23d90683a9ff48739bf", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/equality.rs:25:5\n    |\n+LL |         return 1_i32;\n+   |                ----- expected because of this statement\n+LL |     }\n LL |     0_u32\n    |     ^^^^^ expected i32, found u32\n    |"}, {"sha": "eb5b568b347387d2d7903038d98d02fb2a751bb7", "filename": "src/test/ui/issues/issue-11004.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-11004.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-11004.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11004.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -2,13 +2,17 @@ error[E0609]: no field `x` on type `*mut A`\n   --> $DIR/issue-11004.rs:17:21\n    |\n LL |     let x : i32 = n.x; //~ no field `x` on type `*mut A`\n-   |                     ^ help: `n` is a native pointer; try dereferencing it: `(*n).x`\n+   |                   --^\n+   |                   |\n+   |                   help: `n` is a raw pointer; try dereferencing it: `(*n).x`\n \n error[E0609]: no field `y` on type `*mut A`\n   --> $DIR/issue-11004.rs:18:21\n    |\n LL |     let y : f64 = n.y; //~ no field `y` on type `*mut A`\n-   |                     ^ help: `n` is a native pointer; try dereferencing it: `(*n).y`\n+   |                   --^\n+   |                   |\n+   |                   help: `n` is a raw pointer; try dereferencing it: `(*n).y`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a8ab5e8eb7745b4ba5320b94e37efd0c0a756ba7", "filename": "src/test/ui/issues/issue-17546.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -5,7 +5,7 @@ LL |     fn new() -> NoResult<MyEnum, String> {\n    |                 --------^^^^^^^^^^^^^^^^\n    |                 |\n    |                 did you mean `Result`?\n-   |                 help: you can try using the variant's enum: `foo::MyEnum`\n+   |                 help: try using the variant's enum: `foo::MyEnum`\n \n error[E0573]: expected type, found variant `Result`\n   --> $DIR/issue-17546.rs:32:17\n@@ -48,7 +48,7 @@ LL | fn newer() -> NoResult<foo::MyEnum, String> {\n    |               --------^^^^^^^^^^^^^^^^^^^^^\n    |               |\n    |               did you mean `Result`?\n-   |               help: you can try using the variant's enum: `foo::MyEnum`\n+   |               help: try using the variant's enum: `foo::MyEnum`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "35ef227acfce6547ef1375852a1295972bcf1262", "filename": "src/test/ui/issues/issue-30535.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-30535.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-30535.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30535.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -2,9 +2,10 @@ error[E0573]: expected type, found variant `foo::Foo::FooV`\n   --> $DIR/issue-30535.rs:16:8\n    |\n LL |     _: foo::Foo::FooV //~ ERROR expected type, found variant `foo::Foo::FooV`\n-   |        ^^^^^^^^^^^^^^ not a type\n-   |\n-   = help: there is an enum variant `foo::Foo::FooV`, try using `foo::Foo`?\n+   |        ^^^^^^^^^^^^^^\n+   |        |\n+   |        not a type\n+   |        help: try using the variant's enum: `foo::Foo`\n \n error: aborting due to previous error\n "}, {"sha": "ead07a5f0c8fec1d64b66904f377aa07f2e577b8", "filename": "src/test/ui/issues/issue-35075.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-35075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-35075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35075.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -2,19 +2,21 @@ error[E0412]: cannot find type `Foo` in this scope\n   --> $DIR/issue-35075.rs:12:12\n    |\n LL |     inner: Foo<T> //~ ERROR cannot find type `Foo` in this scope\n-   |            ^^^---\n-   |            |\n-   |            not found in this scope\n-   |            help: you can try using the variant's enum: `Baz`\n+   |            ^^^ not found in this scope\n+help: there is an enum variant `Baz::Foo`; try using the variant's enum\n+   |\n+LL |     inner: Baz //~ ERROR cannot find type `Foo` in this scope\n+   |            ^^^\n \n error[E0412]: cannot find type `Foo` in this scope\n   --> $DIR/issue-35075.rs:16:9\n    |\n LL |     Foo(Foo<T>) //~ ERROR cannot find type `Foo` in this scope\n-   |         ^^^---\n-   |         |\n-   |         not found in this scope\n-   |         help: you can try using the variant's enum: `Baz`\n+   |         ^^^ not found in this scope\n+help: there is an enum variant `Baz::Foo`; try using the variant's enum\n+   |\n+LL |     Foo(Baz) //~ ERROR cannot find type `Foo` in this scope\n+   |         ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "652e1695a85a6fb4569566d16a286b709f28d7f4", "filename": "src/test/ui/issues/issue-35675.stderr", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-35675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fissues%2Fissue-35675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35675.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -2,10 +2,11 @@ error[E0412]: cannot find type `Apple` in this scope\n   --> $DIR/issue-35675.rs:17:29\n    |\n LL | fn should_return_fruit() -> Apple {\n+   |                             ^^^^^ not found in this scope\n+help: there is an enum variant `Fruit::Apple`; try using the variant's enum\n+   |\n+LL | fn should_return_fruit() -> Fruit {\n    |                             ^^^^^\n-   |                             |\n-   |                             not found in this scope\n-   |                             help: you can try using the variant's enum: `Fruit`\n \n error[E0425]: cannot find function `Apple` in this scope\n   --> $DIR/issue-35675.rs:19:5\n@@ -24,7 +25,7 @@ LL | fn should_return_fruit_too() -> Fruit::Apple {\n    |                                 ^^^^^^^^^^^^\n    |                                 |\n    |                                 not a type\n-   |                                 help: you can try using the variant's enum: `Fruit`\n+   |                                 help: try using the variant's enum: `Fruit`\n \n error[E0425]: cannot find function `Apple` in this scope\n   --> $DIR/issue-35675.rs:25:5\n@@ -40,28 +41,29 @@ error[E0573]: expected type, found variant `Ok`\n   --> $DIR/issue-35675.rs:29:13\n    |\n LL | fn foo() -> Ok {\n-   |             ^^ not a type\n-   |\n-   = help: there is an enum variant `std::prelude::v1::Ok`, try using `std::prelude::v1`?\n-   = help: there is an enum variant `std::result::Result::Ok`, try using `std::result::Result`?\n+   |             ^^\n+   |             |\n+   |             not a type\n+   |             help: try using the variant's enum: `std::result::Result`\n \n error[E0412]: cannot find type `Variant3` in this scope\n   --> $DIR/issue-35675.rs:34:13\n    |\n LL | fn bar() -> Variant3 {\n-   |             ^^^^^^^^\n-   |             |\n-   |             not found in this scope\n-   |             help: you can try using the variant's enum: `x::Enum`\n+   |             ^^^^^^^^ not found in this scope\n+help: there is an enum variant `x::Enum::Variant3`; try using the variant's enum\n+   |\n+LL | fn bar() -> x::Enum {\n+   |             ^^^^^^^\n \n error[E0573]: expected type, found variant `Some`\n   --> $DIR/issue-35675.rs:38:13\n    |\n LL | fn qux() -> Some {\n-   |             ^^^^ not a type\n-   |\n-   = help: there is an enum variant `std::prelude::v1::Option::Some`, try using `std::prelude::v1::Option`?\n-   = help: there is an enum variant `std::prelude::v1::Some`, try using `std::prelude::v1`?\n+   |             ^^^^\n+   |             |\n+   |             not a type\n+   |             help: try using the variant's enum: `Option`\n \n error: aborting due to 7 previous errors\n "}, {"sha": "0b4ccdd5a56d4939ce553c2bc25bd6f717558479", "filename": "src/test/ui/parenthesised-deref-suggestion.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fparenthesised-deref-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fparenthesised-deref-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparenthesised-deref-suggestion.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,11 @@\n+struct Session {\n+    opts: u8,\n+}\n+\n+fn main() {\n+    let sess: &Session = &Session { opts: 0 };\n+    (sess as *const Session).opts; //~ ERROR no field `opts` on type `*const Session`\n+\n+    let x = [0u32];\n+    (x as [u32; 1]).0; //~ ERROR no field `0` on type `[u32; 1]`\n+}"}, {"sha": "71a2bf67f06ae8c362efe0408e0656470a269c94", "filename": "src/test/ui/parenthesised-deref-suggestion.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fparenthesised-deref-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fparenthesised-deref-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparenthesised-deref-suggestion.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -0,0 +1,21 @@\n+error[E0609]: no field `opts` on type `*const Session`\n+  --> $DIR/parenthesised-deref-suggestion.rs:7:30\n+   |\n+LL |     (sess as *const Session).opts; //~ ERROR no field `opts` on type `*const Session`\n+   |                              ^^^^\n+help: `(sess as *const Session)` is a raw pointer; try dereferencing it\n+   |\n+LL |     (*(sess as *const Session)).opts; //~ ERROR no field `opts` on type `*const Session`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0609]: no field `0` on type `[u32; 1]`\n+  --> $DIR/parenthesised-deref-suggestion.rs:10:21\n+   |\n+LL |     (x as [u32; 1]).0; //~ ERROR no field `0` on type `[u32; 1]`\n+   |     ----------------^\n+   |     |\n+   |     help: instead of using tuple indexing, use array indexing: `(x as [u32; 1])[0]`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "e0fdc8c67edf7fedcb13ffcb486e69e5335bfd7f", "filename": "src/test/ui/ret-non-nil.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fret-non-nil.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fret-non-nil.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fret-non-nil.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -2,7 +2,9 @@ error[E0069]: `return;` in a function whose return type is not `()`\n   --> $DIR/ret-non-nil.rs:15:19\n    |\n LL | fn g() -> isize { return; }\n-   |                   ^^^^^^ return type is not ()\n+   |           -----   ^^^^^^ return type is not `()`\n+   |           |\n+   |           expected `isize` because of this return type\n \n error: aborting due to previous error\n "}, {"sha": "5a9f0877cc6b6957dfcc4be8c7ba39427e92d093", "filename": "src/test/ui/return/return-unit-from-diverging.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Freturn%2Freturn-unit-from-diverging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Freturn%2Freturn-unit-from-diverging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Freturn-unit-from-diverging.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,8 +1,10 @@\n error[E0069]: `return;` in a function whose return type is not `()`\n   --> $DIR/return-unit-from-diverging.rs:15:5\n    |\n+LL | fn fail() -> ! {\n+   |              - expected `!` because of this return type\n LL |     return; //~ ERROR in a function whose return type is not\n-   |     ^^^^^^ return type is not ()\n+   |     ^^^^^^ return type is not `()`\n \n error: aborting due to previous error\n "}, {"sha": "9f3a7b5e924622a42ffd17ca709d46b4f363a9ff", "filename": "src/test/ui/target-feature-gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Ftarget-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -19,6 +19,7 @@\n // ignore-powerpc64le\n // ignore-sparc\n // ignore-sparc64\n+// ignore-s390x\n // gate-test-sse4a_target_feature\n // gate-test-powerpc_target_feature\n // gate-test-avx512_target_feature"}, {"sha": "73da67a9b8fc91df9321e45abdc4c34ec576f932", "filename": "src/test/ui/target-feature-gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-gate.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: the target feature `avx512bw` is currently unstable (see issue #44839)\n-  --> $DIR/target-feature-gate.rs:36:18\n+  --> $DIR/target-feature-gate.rs:37:18\n    |\n LL | #[target_feature(enable = \"avx512bw\")]\n    |                  ^^^^^^^^^^^^^^^^^^^"}, {"sha": "7525f6705156723a318b45efa69ea2a77ea32338", "filename": "src/test/ui/unsafe/unsafe-fn-autoderef.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-autoderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-autoderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-fn-autoderef.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -2,7 +2,9 @@ error[E0609]: no field `f` on type `*const Rec`\n   --> $DIR/unsafe-fn-autoderef.rs:29:14\n    |\n LL |     return p.f; //~ ERROR no field `f` on type `*const Rec`\n-   |              ^ help: `p` is a native pointer; try dereferencing it: `(*p).f`\n+   |            --^\n+   |            |\n+   |            help: `p` is a raw pointer; try dereferencing it: `(*p).f`\n \n error: aborting due to previous error\n "}, {"sha": "c72729923ef6d6d027ead1bc5dfe83e907e8cdb7", "filename": "src/test/ui/variants/variant-used-as-type.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fvariants%2Fvariant-used-as-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fvariants%2Fvariant-used-as-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariants%2Fvariant-used-as-type.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -3,28 +3,24 @@ error[E0573]: expected type, found variant `Ty::A`\n    |\n LL |     B(Ty::A),\n    |       ^^^^^ not a type\n-help: you can try using the variant's enum\n-   |\n-LL |     B(Ty),\n-   |       ^^\n-help: you can try using the variant's enum\n+help: try using the variant's enum\n    |\n LL |     B(E),\n    |       ^\n+LL |     B(Ty),\n+   |       ^^\n \n error[E0573]: expected type, found variant `E::A`\n   --> $DIR/variant-used-as-type.rs:27:6\n    |\n LL | impl E::A {}\n    |      ^^^^ not a type\n-help: you can try using the variant's enum\n-   |\n-LL | impl Ty {}\n-   |      ^^\n-help: you can try using the variant's enum\n+help: try using the variant's enum\n    |\n LL | impl E {}\n    |      ^\n+LL | impl Ty {}\n+   |      ^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "983b5d48e60fc0a9a988dfb9b0d59f294857de38", "filename": "src/test/ui/write-to-static-mut-in-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -12,10 +12,10 @@\n \n pub static mut A: u32 = 0;\n pub static mut B: () = unsafe { A = 1; };\n-//~^ ERROR cannot mutate statics in the initializer of another static\n+//~^ ERROR could not evaluate static initializer\n \n pub static mut C: u32 = unsafe { C = 1; 0 };\n-//~^ ERROR cannot mutate statics in the initializer of another static\n+//~^ ERROR cycle detected\n \n pub static D: u32 = D;\n "}, {"sha": "335f849fb2472604ee970ed46e4fa490af1d6024", "filename": "src/test/ui/write-to-static-mut-in-static.stderr", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrite-to-static-mut-in-static.stderr?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,14 +1,28 @@\n-error: cannot mutate statics in the initializer of another static\n+error[E0080]: could not evaluate static initializer\n   --> $DIR/write-to-static-mut-in-static.rs:14:33\n    |\n LL | pub static mut B: () = unsafe { A = 1; };\n-   |                                 ^^^^^\n+   |                                 ^^^^^ tried to modify a static's initial value from another static's initializer\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0391]: cycle detected when const-evaluating `C`\n   --> $DIR/write-to-static-mut-in-static.rs:17:34\n    |\n LL | pub static mut C: u32 = unsafe { C = 1; 0 };\n    |                                  ^^^^^\n+   |\n+note: ...which requires const-evaluating `C`...\n+  --> $DIR/write-to-static-mut-in-static.rs:17:1\n+   |\n+LL | pub static mut C: u32 = unsafe { C = 1; 0 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires const-evaluating `C`, completing the cycle\n+note: cycle used when const-evaluating + checking `C`\n+  --> $DIR/write-to-static-mut-in-static.rs:17:1\n+   |\n+LL | pub static mut C: u32 = unsafe { C = 1; 0 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n+Some errors occurred: E0080, E0391.\n+For more information about an error, try `rustc --explain E0080`."}]}