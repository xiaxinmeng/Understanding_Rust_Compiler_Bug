{"sha": "5b533fccf39501bd5ca8a436da6f2d8b5999664d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNTMzZmNjZjM5NTAxYmQ1Y2E4YTQzNmRhNmYyZDhiNTk5OTY2NGQ=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T07:10:05Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-26T05:04:58Z"}, "message": "Move traits implementation of str to new mod\n\nAlso move FromStr trait", "tree": {"sha": "c6764743a7bb9bf8038f6d0b564a1528260e74af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6764743a7bb9bf8038f6d0b564a1528260e74af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b533fccf39501bd5ca8a436da6f2d8b5999664d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b533fccf39501bd5ca8a436da6f2d8b5999664d", "html_url": "https://github.com/rust-lang/rust/commit/5b533fccf39501bd5ca8a436da6f2d8b5999664d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b533fccf39501bd5ca8a436da6f2d8b5999664d/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d", "html_url": "https://github.com/rust-lang/rust/commit/d31ca4fc8ede3b4a28abea7df57e01591ee8bb7d"}], "stats": {"total": 1201, "additions": 599, "deletions": 602}, "files": [{"sha": "147d341c8b0b2460bd8bf522ca6adbacb46be828", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 2, "deletions": 602, "changes": 604, "blob_url": "https://github.com/rust-lang/rust/blob/5b533fccf39501bd5ca8a436da6f2d8b5999664d/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b533fccf39501bd5ca8a436da6f2d8b5999664d/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=5b533fccf39501bd5ca8a436da6f2d8b5999664d", "patch": "@@ -9,6 +9,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n mod error;\n+mod traits;\n \n use self::pattern::Pattern;\n use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n@@ -32,116 +33,8 @@ pub mod lossy;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use error::{ParseBoolError, Utf8Error};\n \n-/// Parse a value from a string\n-///\n-/// `FromStr`'s [`from_str`] method is often used implicitly, through\n-/// [`str`]'s [`parse`] method. See [`parse`]'s documentation for examples.\n-///\n-/// [`from_str`]: FromStr::from_str\n-/// [`parse`]: str::parse\n-///\n-/// `FromStr` does not have a lifetime parameter, and so you can only parse types\n-/// that do not contain a lifetime parameter themselves. In other words, you can\n-/// parse an `i32` with `FromStr`, but not a `&i32`. You can parse a struct that\n-/// contains an `i32`, but not one that contains an `&i32`.\n-///\n-/// # Examples\n-///\n-/// Basic implementation of `FromStr` on an example `Point` type:\n-///\n-/// ```\n-/// use std::str::FromStr;\n-/// use std::num::ParseIntError;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// struct Point {\n-///     x: i32,\n-///     y: i32\n-/// }\n-///\n-/// impl FromStr for Point {\n-///     type Err = ParseIntError;\n-///\n-///     fn from_str(s: &str) -> Result<Self, Self::Err> {\n-///         let coords: Vec<&str> = s.trim_matches(|p| p == '(' || p == ')' )\n-///                                  .split(',')\n-///                                  .collect();\n-///\n-///         let x_fromstr = coords[0].parse::<i32>()?;\n-///         let y_fromstr = coords[1].parse::<i32>()?;\n-///\n-///         Ok(Point { x: x_fromstr, y: y_fromstr })\n-///     }\n-/// }\n-///\n-/// let p = Point::from_str(\"(1,2)\");\n-/// assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )\n-/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait FromStr: Sized {\n-    /// The associated error which can be returned from parsing.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Err;\n-\n-    /// Parses a string `s` to return a value of this type.\n-    ///\n-    /// If parsing succeeds, return the value inside [`Ok`], otherwise\n-    /// when the string is ill-formatted return an error specific to the\n-    /// inside [`Err`]. The error type is specific to implementation of the trait.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage with [`i32`][ithirtytwo], a type that implements `FromStr`:\n-    ///\n-    /// [ithirtytwo]: ../../std/primitive.i32.html\n-    ///\n-    /// ```\n-    /// use std::str::FromStr;\n-    ///\n-    /// let s = \"5\";\n-    /// let x = i32::from_str(s).unwrap();\n-    ///\n-    /// assert_eq!(5, x);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_str(s: &str) -> Result<Self, Self::Err>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromStr for bool {\n-    type Err = ParseBoolError;\n-\n-    /// Parse a `bool` from a string.\n-    ///\n-    /// Yields a `Result<bool, ParseBoolError>`, because `s` may or may not\n-    /// actually be parseable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::str::FromStr;\n-    ///\n-    /// assert_eq!(FromStr::from_str(\"true\"), Ok(true));\n-    /// assert_eq!(FromStr::from_str(\"false\"), Ok(false));\n-    /// assert!(<bool as FromStr>::from_str(\"not even a boolean\").is_err());\n-    /// ```\n-    ///\n-    /// Note, in many cases, the `.parse()` method on `str` is more proper.\n-    ///\n-    /// ```\n-    /// assert_eq!(\"true\".parse(), Ok(true));\n-    /// assert_eq!(\"false\".parse(), Ok(false));\n-    /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n-    /// ```\n-    #[inline]\n-    fn from_str(s: &str) -> Result<bool, ParseBoolError> {\n-        match s {\n-            \"true\" => Ok(true),\n-            \"false\" => Ok(false),\n-            _ => Err(ParseBoolError { _priv: () }),\n-        }\n-    }\n-}\n+pub use traits::FromStr;\n \n /*\n Section: Creating a string\n@@ -1586,499 +1479,6 @@ const CONT_MASK: u8 = 0b0011_1111;\n /// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte.\n const TAG_CONT_U8: u8 = 0b1000_0000;\n \n-/*\n-Section: Trait implementations\n-*/\n-\n-mod traits {\n-    use crate::cmp::Ordering;\n-    use crate::ops;\n-    use crate::ptr;\n-    use crate::slice::SliceIndex;\n-\n-    /// Implements ordering of strings.\n-    ///\n-    /// Strings are ordered  lexicographically by their byte values. This orders Unicode code\n-    /// points based on their positions in the code charts. This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale. Sorting strings according to\n-    /// culturally-accepted standards requires locale-specific data that is outside the scope of\n-    /// the `str` type.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Ord for str {\n-        #[inline]\n-        fn cmp(&self, other: &str) -> Ordering {\n-            self.as_bytes().cmp(other.as_bytes())\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl PartialEq for str {\n-        #[inline]\n-        fn eq(&self, other: &str) -> bool {\n-            self.as_bytes() == other.as_bytes()\n-        }\n-        #[inline]\n-        fn ne(&self, other: &str) -> bool {\n-            !(*self).eq(other)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Eq for str {}\n-\n-    /// Implements comparison operations on strings.\n-    ///\n-    /// Strings are compared lexicographically by their byte values. This compares Unicode code\n-    /// points based on their positions in the code charts. This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale. Comparing strings according to\n-    /// culturally-accepted standards requires locale-specific data that is outside the scope of\n-    /// the `str` type.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl PartialOrd for str {\n-        #[inline]\n-        fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n-            Some(self.cmp(other))\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<I> ops::Index<I> for str\n-    where\n-        I: SliceIndex<str>,\n-    {\n-        type Output = I::Output;\n-\n-        #[inline]\n-        fn index(&self, index: I) -> &I::Output {\n-            index.index(self)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<I> ops::IndexMut<I> for str\n-    where\n-        I: SliceIndex<str>,\n-    {\n-        #[inline]\n-        fn index_mut(&mut self, index: I) -> &mut I::Output {\n-            index.index_mut(self)\n-        }\n-    }\n-\n-    #[inline(never)]\n-    #[cold]\n-    #[track_caller]\n-    fn str_index_overflow_fail() -> ! {\n-        panic!(\"attempted to index str up to maximum usize\");\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[..]` or `&mut self[..]`.\n-    ///\n-    /// Returns a slice of the whole string, i.e., returns `&self` or `&mut\n-    /// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n-    /// other indexing operations, this can never panic.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Prior to 1.20.0, these indexing operations were still supported by\n-    /// direct implementation of `Index` and `IndexMut`.\n-    ///\n-    /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeFull {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            Some(slice)\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            Some(slice)\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            slice\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            slice\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            slice\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            slice\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[begin .. end]` or `&mut\n-    /// self[begin .. end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`, `end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Prior to 1.20.0, these indexing operations were still supported by\n-    /// direct implementation of `Index` and `IndexMut`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` or `end` does not point to the starting byte offset of\n-    /// a character (as defined by `is_char_boundary`), if `begin > end`, or if\n-    /// `end > len`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(&s[0 .. 1], \"L\");\n-    ///\n-    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // &s[2 ..3];\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // &s[1 .. 8];\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // &s[3 .. 100];\n-    /// ```\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe impl SliceIndex<str> for ops::Range<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.start <= self.end\n-                && slice.is_char_boundary(self.start)\n-                && slice.is_char_boundary(self.end)\n-            {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                // We also checked char boundaries, so this is valid UTF-8.\n-                Some(unsafe { &*self.get_unchecked(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.start <= self.end\n-                && slice.is_char_boundary(self.start)\n-                && slice.is_char_boundary(self.end)\n-            {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                // We know the pointer is unique because we got it from `slice`.\n-                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            let slice = slice as *const [u8];\n-            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n-            // which satisfies all the conditions for `add`.\n-            let ptr = unsafe { slice.as_ptr().add(self.start) };\n-            let len = self.end - self.start;\n-            ptr::slice_from_raw_parts(ptr, len) as *const str\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            let slice = slice as *mut [u8];\n-            // SAFETY: see comments for `get_unchecked`.\n-            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n-            let len = self.end - self.start;\n-            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            let (start, end) = (self.start, self.end);\n-            match self.get(slice) {\n-                Some(s) => s,\n-                None => super::slice_error_fail(slice, start, end),\n-            }\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n-            // cannot reuse `get` as above, because of NLL trouble\n-            if self.start <= self.end\n-                && slice.is_char_boundary(self.start)\n-                && slice.is_char_boundary(self.end)\n-            {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                unsafe { &mut *self.get_unchecked_mut(slice) }\n-            } else {\n-                super::slice_error_fail(slice, self.start, self.end)\n-            }\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[.. end]` or `&mut\n-    /// self[.. end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range [`0`, `end`).\n-    /// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Prior to 1.20.0, these indexing operations were still supported by\n-    /// direct implementation of `Index` and `IndexMut`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `end` does not point to the starting byte offset of a\n-    /// character (as defined by `is_char_boundary`), or if `end > len`.\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                Some(unsafe { &*self.get_unchecked(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            let slice = slice as *const [u8];\n-            let ptr = slice.as_ptr();\n-            ptr::slice_from_raw_parts(ptr, self.end) as *const str\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            let slice = slice as *mut [u8];\n-            let ptr = slice.as_mut_ptr();\n-            ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            let end = self.end;\n-            match self.get(slice) {\n-                Some(s) => s,\n-                None => super::slice_error_fail(slice, 0, end),\n-            }\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                unsafe { &mut *self.get_unchecked_mut(slice) }\n-            } else {\n-                super::slice_error_fail(slice, 0, self.end)\n-            }\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[begin ..]` or `&mut\n-    /// self[begin ..]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range [`begin`,\n-    /// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n-    /// len]`.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Prior to 1.20.0, these indexing operations were still supported by\n-    /// direct implementation of `Index` and `IndexMut`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` does not point to the starting byte offset of\n-    /// a character (as defined by `is_char_boundary`), or if `begin > len`.\n-    #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                Some(unsafe { &*self.get_unchecked(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n-            } else {\n-                None\n-            }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            let slice = slice as *const [u8];\n-            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n-            // which satisfies all the conditions for `add`.\n-            let ptr = unsafe { slice.as_ptr().add(self.start) };\n-            let len = slice.len() - self.start;\n-            ptr::slice_from_raw_parts(ptr, len) as *const str\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            let slice = slice as *mut [u8];\n-            // SAFETY: identical to `get_unchecked`.\n-            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n-            let len = slice.len() - self.start;\n-            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            let (start, end) = (self.start, slice.len());\n-            match self.get(slice) {\n-                Some(s) => s,\n-                None => super::slice_error_fail(slice, start, end),\n-            }\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary,\n-                // and we are passing in a safe reference, so the return value will also be one.\n-                unsafe { &mut *self.get_unchecked_mut(slice) }\n-            } else {\n-                super::slice_error_fail(slice, self.start, slice.len())\n-            }\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[begin ..= end]` or `&mut\n-    /// self[begin ..= end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`, `end`]. Equivalent to `&self [begin .. end + 1]` or `&mut\n-    /// self[begin .. end + 1]`, except if `end` has the maximum value for\n-    /// `usize`.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` does not point to the starting byte offset of\n-    /// a character (as defined by `is_char_boundary`), if `end` does not point\n-    /// to the ending byte offset of a character (`end + 1` is either a starting\n-    /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if *self.end() == usize::MAX {\n-                None\n-            } else {\n-                (*self.start()..self.end() + 1).get(slice)\n-            }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if *self.end() == usize::MAX {\n-                None\n-            } else {\n-                (*self.start()..self.end() + 1).get_mut(slice)\n-            }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-            unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-            unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            if *self.end() == usize::MAX {\n-                str_index_overflow_fail();\n-            }\n-            (*self.start()..self.end() + 1).index(slice)\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if *self.end() == usize::MAX {\n-                str_index_overflow_fail();\n-            }\n-            (*self.start()..self.end() + 1).index_mut(slice)\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[..= end]` or `&mut\n-    /// self[..= end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range [0, `end`].\n-    /// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n-    /// value for `usize`.\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `end` does not point to the ending byte offset of a character\n-    /// (`end + 1` is either a starting byte offset as defined by\n-    /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n-        type Output = str;\n-        #[inline]\n-        fn get(self, slice: &str) -> Option<&Self::Output> {\n-            if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n-        }\n-        #[inline]\n-        fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-            if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-            unsafe { (..self.end + 1).get_unchecked(slice) }\n-        }\n-        #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-            unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n-        }\n-        #[inline]\n-        fn index(self, slice: &str) -> &Self::Output {\n-            if self.end == usize::MAX {\n-                str_index_overflow_fail();\n-            }\n-            (..self.end + 1).index(slice)\n-        }\n-        #[inline]\n-        fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            if self.end == usize::MAX {\n-                str_index_overflow_fail();\n-            }\n-            (..self.end + 1).index_mut(slice)\n-        }\n-    }\n-}\n-\n // truncate `&str` to length at most equal to `max`\n // return `true` if it were truncated, and the new str.\n fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {"}, {"sha": "4f8aa246e52322fbfd6992bb57c21a7e33f7af0a", "filename": "library/core/src/str/traits.rs", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/rust-lang/rust/blob/5b533fccf39501bd5ca8a436da6f2d8b5999664d/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b533fccf39501bd5ca8a436da6f2d8b5999664d/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=5b533fccf39501bd5ca8a436da6f2d8b5999664d", "patch": "@@ -0,0 +1,597 @@\n+//! Trait implementations for `str`.\n+\n+use crate::cmp::Ordering;\n+use crate::ops;\n+use crate::ptr;\n+use crate::slice::SliceIndex;\n+\n+use super::ParseBoolError;\n+\n+/// Implements ordering of strings.\n+///\n+/// Strings are ordered  lexicographically by their byte values. This orders Unicode code\n+/// points based on their positions in the code charts. This is not necessarily the same as\n+/// \"alphabetical\" order, which varies by language and locale. Sorting strings according to\n+/// culturally-accepted standards requires locale-specific data that is outside the scope of\n+/// the `str` type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Ord for str {\n+    #[inline]\n+    fn cmp(&self, other: &str) -> Ordering {\n+        self.as_bytes().cmp(other.as_bytes())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialEq for str {\n+    #[inline]\n+    fn eq(&self, other: &str) -> bool {\n+        self.as_bytes() == other.as_bytes()\n+    }\n+    #[inline]\n+    fn ne(&self, other: &str) -> bool {\n+        !(*self).eq(other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Eq for str {}\n+\n+/// Implements comparison operations on strings.\n+///\n+/// Strings are compared lexicographically by their byte values. This compares Unicode code\n+/// points based on their positions in the code charts. This is not necessarily the same as\n+/// \"alphabetical\" order, which varies by language and locale. Comparing strings according to\n+/// culturally-accepted standards requires locale-specific data that is outside the scope of\n+/// the `str` type.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialOrd for str {\n+    #[inline]\n+    fn partial_cmp(&self, other: &str) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ops::Index<I> for str\n+where\n+    I: SliceIndex<str>,\n+{\n+    type Output = I::Output;\n+\n+    #[inline]\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ops::IndexMut<I> for str\n+where\n+    I: SliceIndex<str>,\n+{\n+    #[inline]\n+    fn index_mut(&mut self, index: I) -> &mut I::Output {\n+        index.index_mut(self)\n+    }\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+fn str_index_overflow_fail() -> ! {\n+    panic!(\"attempted to index str up to maximum usize\");\n+}\n+\n+/// Implements substring slicing with syntax `&self[..]` or `&mut self[..]`.\n+///\n+/// Returns a slice of the whole string, i.e., returns `&self` or `&mut\n+/// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n+/// other indexing operations, this can never panic.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// Prior to 1.20.0, these indexing operations were still supported by\n+/// direct implementation of `Index` and `IndexMut`.\n+///\n+/// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n+#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeFull {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        Some(slice)\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        Some(slice)\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        slice\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        slice\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        slice\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        slice\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[begin .. end]` or `&mut\n+/// self[begin .. end]`.\n+///\n+/// Returns a slice of the given string from the byte range\n+/// [`begin`, `end`).\n+///\n+/// This operation is `O(1)`.\n+///\n+/// Prior to 1.20.0, these indexing operations were still supported by\n+/// direct implementation of `Index` and `IndexMut`.\n+///\n+/// # Panics\n+///\n+/// Panics if `begin` or `end` does not point to the starting byte offset of\n+/// a character (as defined by `is_char_boundary`), if `begin > end`, or if\n+/// `end > len`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+/// assert_eq!(&s[0 .. 1], \"L\");\n+///\n+/// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+///\n+/// // these will panic:\n+/// // byte 2 lies within `\u00f6`:\n+/// // &s[2 ..3];\n+///\n+/// // byte 8 lies within `\u8001`\n+/// // &s[1 .. 8];\n+///\n+/// // byte 100 is outside the string\n+/// // &s[3 .. 100];\n+/// ```\n+#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+unsafe impl SliceIndex<str> for ops::Range<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if self.start <= self.end\n+            && slice.is_char_boundary(self.start)\n+            && slice.is_char_boundary(self.end)\n+        {\n+            // SAFETY: just checked that `start` and `end` are on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            // We also checked char boundaries, so this is valid UTF-8.\n+            Some(unsafe { &*self.get_unchecked(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if self.start <= self.end\n+            && slice.is_char_boundary(self.start)\n+            && slice.is_char_boundary(self.end)\n+        {\n+            // SAFETY: just checked that `start` and `end` are on a char boundary.\n+            // We know the pointer is unique because we got it from `slice`.\n+            Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        let slice = slice as *const [u8];\n+        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+        // which satisfies all the conditions for `add`.\n+        let ptr = unsafe { slice.as_ptr().add(self.start) };\n+        let len = self.end - self.start;\n+        ptr::slice_from_raw_parts(ptr, len) as *const str\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        let slice = slice as *mut [u8];\n+        // SAFETY: see comments for `get_unchecked`.\n+        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n+        let len = self.end - self.start;\n+        ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        let (start, end) = (self.start, self.end);\n+        match self.get(slice) {\n+            Some(s) => s,\n+            None => super::slice_error_fail(slice, start, end),\n+        }\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        // cannot reuse `get` as above, because of NLL trouble\n+        if self.start <= self.end\n+            && slice.is_char_boundary(self.start)\n+            && slice.is_char_boundary(self.end)\n+        {\n+            // SAFETY: just checked that `start` and `end` are on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            unsafe { &mut *self.get_unchecked_mut(slice) }\n+        } else {\n+            super::slice_error_fail(slice, self.start, self.end)\n+        }\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[.. end]` or `&mut\n+/// self[.. end]`.\n+///\n+/// Returns a slice of the given string from the byte range [`0`, `end`).\n+/// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// Prior to 1.20.0, these indexing operations were still supported by\n+/// direct implementation of `Index` and `IndexMut`.\n+///\n+/// # Panics\n+///\n+/// Panics if `end` does not point to the starting byte offset of a\n+/// character (as defined by `is_char_boundary`), or if `end > len`.\n+#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if slice.is_char_boundary(self.end) {\n+            // SAFETY: just checked that `end` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            Some(unsafe { &*self.get_unchecked(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if slice.is_char_boundary(self.end) {\n+            // SAFETY: just checked that `end` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        let slice = slice as *const [u8];\n+        let ptr = slice.as_ptr();\n+        ptr::slice_from_raw_parts(ptr, self.end) as *const str\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        let slice = slice as *mut [u8];\n+        let ptr = slice.as_mut_ptr();\n+        ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        let end = self.end;\n+        match self.get(slice) {\n+            Some(s) => s,\n+            None => super::slice_error_fail(slice, 0, end),\n+        }\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        if slice.is_char_boundary(self.end) {\n+            // SAFETY: just checked that `end` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            unsafe { &mut *self.get_unchecked_mut(slice) }\n+        } else {\n+            super::slice_error_fail(slice, 0, self.end)\n+        }\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[begin ..]` or `&mut\n+/// self[begin ..]`.\n+///\n+/// Returns a slice of the given string from the byte range [`begin`,\n+/// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n+/// len]`.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// Prior to 1.20.0, these indexing operations were still supported by\n+/// direct implementation of `Index` and `IndexMut`.\n+///\n+/// # Panics\n+///\n+/// Panics if `begin` does not point to the starting byte offset of\n+/// a character (as defined by `is_char_boundary`), or if `begin > len`.\n+#[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if slice.is_char_boundary(self.start) {\n+            // SAFETY: just checked that `start` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            Some(unsafe { &*self.get_unchecked(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if slice.is_char_boundary(self.start) {\n+            // SAFETY: just checked that `start` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n+        } else {\n+            None\n+        }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        let slice = slice as *const [u8];\n+        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+        // which satisfies all the conditions for `add`.\n+        let ptr = unsafe { slice.as_ptr().add(self.start) };\n+        let len = slice.len() - self.start;\n+        ptr::slice_from_raw_parts(ptr, len) as *const str\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        let slice = slice as *mut [u8];\n+        // SAFETY: identical to `get_unchecked`.\n+        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n+        let len = slice.len() - self.start;\n+        ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        let (start, end) = (self.start, slice.len());\n+        match self.get(slice) {\n+            Some(s) => s,\n+            None => super::slice_error_fail(slice, start, end),\n+        }\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        if slice.is_char_boundary(self.start) {\n+            // SAFETY: just checked that `start` is on a char boundary,\n+            // and we are passing in a safe reference, so the return value will also be one.\n+            unsafe { &mut *self.get_unchecked_mut(slice) }\n+        } else {\n+            super::slice_error_fail(slice, self.start, slice.len())\n+        }\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[begin ..= end]` or `&mut\n+/// self[begin ..= end]`.\n+///\n+/// Returns a slice of the given string from the byte range\n+/// [`begin`, `end`]. Equivalent to `&self [begin .. end + 1]` or `&mut\n+/// self[begin .. end + 1]`, except if `end` has the maximum value for\n+/// `usize`.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// # Panics\n+///\n+/// Panics if `begin` does not point to the starting byte offset of\n+/// a character (as defined by `is_char_boundary`), if `end` does not point\n+/// to the ending byte offset of a character (`end + 1` is either a starting\n+/// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if *self.end() == usize::MAX {\n+            None\n+        } else {\n+            (*self.start()..self.end() + 1).get_mut(slice)\n+        }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        if *self.end() == usize::MAX {\n+            str_index_overflow_fail();\n+        }\n+        (*self.start()..self.end() + 1).index(slice)\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        if *self.end() == usize::MAX {\n+            str_index_overflow_fail();\n+        }\n+        (*self.start()..self.end() + 1).index_mut(slice)\n+    }\n+}\n+\n+/// Implements substring slicing with syntax `&self[..= end]` or `&mut\n+/// self[..= end]`.\n+///\n+/// Returns a slice of the given string from the byte range [0, `end`].\n+/// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n+/// value for `usize`.\n+///\n+/// This operation is `O(1)`.\n+///\n+/// # Panics\n+///\n+/// Panics if `end` does not point to the ending byte offset of a character\n+/// (`end + 1` is either a starting byte offset as defined by\n+/// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n+    type Output = str;\n+    #[inline]\n+    fn get(self, slice: &str) -> Option<&Self::Output> {\n+        if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n+    }\n+    #[inline]\n+    fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n+        if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { (..self.end + 1).get_unchecked(slice) }\n+    }\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n+    }\n+    #[inline]\n+    fn index(self, slice: &str) -> &Self::Output {\n+        if self.end == usize::MAX {\n+            str_index_overflow_fail();\n+        }\n+        (..self.end + 1).index(slice)\n+    }\n+    #[inline]\n+    fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n+        if self.end == usize::MAX {\n+            str_index_overflow_fail();\n+        }\n+        (..self.end + 1).index_mut(slice)\n+    }\n+}\n+\n+/// Parse a value from a string\n+///\n+/// `FromStr`'s [`from_str`] method is often used implicitly, through\n+/// [`str`]'s [`parse`] method. See [`parse`]'s documentation for examples.\n+///\n+/// [`from_str`]: FromStr::from_str\n+/// [`parse`]: str::parse\n+///\n+/// `FromStr` does not have a lifetime parameter, and so you can only parse types\n+/// that do not contain a lifetime parameter themselves. In other words, you can\n+/// parse an `i32` with `FromStr`, but not a `&i32`. You can parse a struct that\n+/// contains an `i32`, but not one that contains an `&i32`.\n+///\n+/// # Examples\n+///\n+/// Basic implementation of `FromStr` on an example `Point` type:\n+///\n+/// ```\n+/// use std::str::FromStr;\n+/// use std::num::ParseIntError;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32\n+/// }\n+///\n+/// impl FromStr for Point {\n+///     type Err = ParseIntError;\n+///\n+///     fn from_str(s: &str) -> Result<Self, Self::Err> {\n+///         let coords: Vec<&str> = s.trim_matches(|p| p == '(' || p == ')' )\n+///                                  .split(',')\n+///                                  .collect();\n+///\n+///         let x_fromstr = coords[0].parse::<i32>()?;\n+///         let y_fromstr = coords[1].parse::<i32>()?;\n+///\n+///         Ok(Point { x: x_fromstr, y: y_fromstr })\n+///     }\n+/// }\n+///\n+/// let p = Point::from_str(\"(1,2)\");\n+/// assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait FromStr: Sized {\n+    /// The associated error which can be returned from parsing.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Err;\n+\n+    /// Parses a string `s` to return a value of this type.\n+    ///\n+    /// If parsing succeeds, return the value inside [`Ok`], otherwise\n+    /// when the string is ill-formatted return an error specific to the\n+    /// inside [`Err`]. The error type is specific to implementation of the trait.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage with [`i32`][ithirtytwo], a type that implements `FromStr`:\n+    ///\n+    /// [ithirtytwo]: ../../std/primitive.i32.html\n+    ///\n+    /// ```\n+    /// use std::str::FromStr;\n+    ///\n+    /// let s = \"5\";\n+    /// let x = i32::from_str(s).unwrap();\n+    ///\n+    /// assert_eq!(5, x);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_str(s: &str) -> Result<Self, Self::Err>;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl FromStr for bool {\n+    type Err = ParseBoolError;\n+\n+    /// Parse a `bool` from a string.\n+    ///\n+    /// Yields a `Result<bool, ParseBoolError>`, because `s` may or may not\n+    /// actually be parseable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::str::FromStr;\n+    ///\n+    /// assert_eq!(FromStr::from_str(\"true\"), Ok(true));\n+    /// assert_eq!(FromStr::from_str(\"false\"), Ok(false));\n+    /// assert!(<bool as FromStr>::from_str(\"not even a boolean\").is_err());\n+    /// ```\n+    ///\n+    /// Note, in many cases, the `.parse()` method on `str` is more proper.\n+    ///\n+    /// ```\n+    /// assert_eq!(\"true\".parse(), Ok(true));\n+    /// assert_eq!(\"false\".parse(), Ok(false));\n+    /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n+    /// ```\n+    #[inline]\n+    fn from_str(s: &str) -> Result<bool, ParseBoolError> {\n+        match s {\n+            \"true\" => Ok(true),\n+            \"false\" => Ok(false),\n+            _ => Err(ParseBoolError { _priv: () }),\n+        }\n+    }\n+}"}]}