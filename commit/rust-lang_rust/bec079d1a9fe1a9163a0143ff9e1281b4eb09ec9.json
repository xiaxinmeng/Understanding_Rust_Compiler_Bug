{"sha": "bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "node_id": "C_kwDOAAsO6NoAKGJlYzA3OWQxYTlmZTFhOTE2M2EwMTQzZmY5ZTEyODFiNGViMDllYzk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-09T21:57:38Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-10T02:49:14Z"}, "message": "split compare_predicate_entailment and collect_trait_impl_trait_tys out", "tree": {"sha": "18b16c65a3d76830a70593ea307a82beb1f71e74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18b16c65a3d76830a70593ea307a82beb1f71e74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "html_url": "https://github.com/rust-lang/rust/commit/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "395e56f39849defec8d6941f76625d286a6e5ddc", "url": "https://api.github.com/repos/rust-lang/rust/commits/395e56f39849defec8d6941f76625d286a6e5ddc", "html_url": "https://github.com/rust-lang/rust/commit/395e56f39849defec8d6941f76625d286a6e5ddc"}], "stats": {"total": 170, "additions": 137, "deletions": 33}, "files": [{"sha": "95a36dd8a56a588849971012d7cf912a39b3bc72", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "patch": "@@ -1772,7 +1772,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // In some (most?) cases cause.body_id points to actual body, but in some cases\n         // it's an actual definition. According to the comments (e.g. in\n-        // librustc_typeck/check/compare_method.rs:compare_predicates_and_trait_impl_trait_tys) the latter\n+        // librustc_typeck/check/compare_method.rs:compare_predicate_entailment) the latter\n         // is relied upon by some other code. This might (or might not) need cleanup.\n         let body_owner_def_id =\n             self.tcx.hir().opt_local_def_id(cause.body_id).unwrap_or_else(|| {"}, {"sha": "6ca72351713c11a48a4476f96611c96689b34663", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "patch": "@@ -161,7 +161,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query compare_predicates_and_trait_impl_trait_tys(key: DefId)\n+    query collect_trait_impl_trait_tys(key: DefId)\n         -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>\n     {\n         desc { \"better description please\" }"}, {"sha": "23ad4d27d8ea6335af4f68f1c01eaab24c62eb47", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "patch": "@@ -655,7 +655,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         def_id: DefId,\n     ) -> ty::EarlyBinder<Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>> {\n-        ty::EarlyBinder(self.compare_predicates_and_trait_impl_trait_tys(def_id))\n+        ty::EarlyBinder(self.collect_trait_impl_trait_tys(def_id))\n     }\n \n     pub fn bound_fn_sig(self, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'tcx>> {"}, {"sha": "3e407d4ae6c277b6b273a1fdada54c94de7ef60c", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 127, "deletions": 18, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::util::ExplicitSelf;\n use rustc_middle::ty::{\n-    self, DefIdTree, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    self, AssocItem, DefIdTree, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n@@ -68,7 +68,10 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    tcx.ensure().compare_predicates_and_trait_impl_trait_tys(impl_m.def_id);\n+    if let Err(_) = compare_predicate_entailment(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)\n+    {\n+        return;\n+    }\n }\n \n /// This function is best explained by example. Consider a trait:\n@@ -137,15 +140,13 @@ pub(crate) fn compare_impl_method<'tcx>(\n ///\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n-pub(super) fn compare_predicates_and_trait_impl_trait_tys<'tcx>(\n+fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-) -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed> {\n-    let impl_m = tcx.opt_associated_item(def_id).unwrap();\n-    let impl_m_span = tcx.def_span(def_id);\n-    let trait_m = tcx.opt_associated_item(impl_m.trait_item_def_id.unwrap()).unwrap();\n-    let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n-\n+    impl_m: &AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) -> Result<(), ErrorGuaranteed> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     // This node-id should be used for the `body_id` field on each\n@@ -164,7 +165,6 @@ pub(super) fn compare_predicates_and_trait_impl_trait_tys<'tcx>(\n             kind: impl_m.kind,\n         },\n     );\n-    let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n \n     // Create mapping from impl to placeholder.\n     let impl_to_placeholder_substs = InternalSubsts::identity_for_item(tcx, impl_m.def_id);\n@@ -270,12 +270,6 @@ pub(super) fn compare_predicates_and_trait_impl_trait_tys<'tcx>(\n \n         let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n         let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n-        let mut collector =\n-            ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n-        // FIXME(RPITIT): This should only be needed on the output type, but\n-        // RPITIT placeholders shouldn't show up anywhere except for there,\n-        // so I think this is fine.\n-        let trait_sig = trait_sig.fold_with(&mut collector);\n \n         // Next, add all inputs and output as well-formed tys. Importantly,\n         // we have to do this before normalization, since the normalized ty may\n@@ -422,6 +416,121 @@ pub(super) fn compare_predicates_and_trait_impl_trait_tys<'tcx>(\n             &outlives_environment,\n         );\n \n+        Ok(())\n+    })\n+}\n+\n+pub fn collect_trait_impl_trait_tys<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed> {\n+    let impl_m = tcx.opt_associated_item(def_id).unwrap();\n+    let trait_m = tcx.opt_associated_item(impl_m.trait_item_def_id.unwrap()).unwrap();\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n+    let param_env = tcx.param_env(def_id);\n+\n+    let trait_to_impl_substs = impl_trait_ref.substs;\n+\n+    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n+    let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n+    let cause = ObligationCause::new(\n+        return_span,\n+        impl_m_hir_id,\n+        ObligationCauseCode::CompareImplItemObligation {\n+            impl_item_def_id: impl_m.def_id.expect_local(),\n+            trait_item_def_id: trait_m.def_id,\n+            kind: impl_m.kind,\n+        },\n+    );\n+\n+    // Create mapping from impl to placeholder.\n+    let impl_to_placeholder_substs = InternalSubsts::identity_for_item(tcx, impl_m.def_id);\n+\n+    // Create mapping from trait to placeholder.\n+    let trait_to_placeholder_substs =\n+        impl_to_placeholder_substs.rebase_onto(tcx, impl_m.container_id(tcx), trait_to_impl_substs);\n+\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let ocx = ObligationCtxt::new(infcx);\n+\n+        let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n+        let impl_return_ty = ocx.normalize(\n+            norm_cause.clone(),\n+            param_env,\n+            infcx\n+                .replace_bound_vars_with_fresh_vars(\n+                    return_span,\n+                    infer::HigherRankedType,\n+                    tcx.fn_sig(impl_m.def_id),\n+                )\n+                .output(),\n+        );\n+\n+        let mut collector =\n+            ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n+        let unnormalized_trait_return_ty = tcx\n+            .liberate_late_bound_regions(\n+                impl_m.def_id,\n+                tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n+            )\n+            .output()\n+            .fold_with(&mut collector);\n+        let trait_return_ty =\n+            ocx.normalize(norm_cause.clone(), param_env, unnormalized_trait_return_ty);\n+\n+        let wf_tys = FxHashSet::from_iter([unnormalized_trait_return_ty, trait_return_ty]);\n+\n+        match infcx.at(&cause, param_env).eq(trait_return_ty, impl_return_ty) {\n+            Ok(infer::InferOk { value: (), obligations }) => {\n+                ocx.register_obligations(obligations);\n+            }\n+            Err(terr) => {\n+                let mut diag = struct_span_err!(\n+                    tcx.sess,\n+                    cause.span(),\n+                    E0053,\n+                    \"method `{}` has an incompatible return type for trait\",\n+                    trait_m.name\n+                );\n+                let hir = tcx.hir();\n+                infcx.note_type_err(\n+                    &mut diag,\n+                    &cause,\n+                    hir.get_if_local(impl_m.def_id)\n+                        .and_then(|node| node.fn_decl())\n+                        .map(|decl| (decl.output.span(), \"return type in trait\".to_owned())),\n+                    Some(infer::ValuePairs::Terms(ExpectedFound {\n+                        expected: trait_return_ty.into(),\n+                        found: impl_return_ty.into(),\n+                    })),\n+                    terr,\n+                    false,\n+                    false,\n+                );\n+                return Err(diag.emit());\n+            }\n+        }\n+\n+        // Check that all obligations are satisfied by the implementation's\n+        // RPITs.\n+        let errors = ocx.select_all_or_error();\n+        if !errors.is_empty() {\n+            let reported = infcx.report_fulfillment_errors(&errors, None, false);\n+            return Err(reported);\n+        }\n+\n+        // Finally, resolve all regions. This catches wily misuses of\n+        // lifetime parameters.\n+        let outlives_environment = OutlivesEnvironment::with_bounds(\n+            param_env,\n+            Some(infcx),\n+            infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+        );\n+        infcx.check_region_obligations_and_report_errors(\n+            impl_m.def_id.expect_local(),\n+            &outlives_environment,\n+        );\n+\n         let mut collected_tys = FxHashMap::default();\n         for (def_id, (ty, substs)) in collector.types {\n             match infcx.fully_resolve(ty) {\n@@ -1307,7 +1416,7 @@ pub(crate) fn compare_ty_impl<'tcx>(\n     })();\n }\n \n-/// The equivalent of [compare_predicates_and_trait_impl_trait_tys], but for associated types\n+/// The equivalent of [compare_predicate_entailment], but for associated types\n /// instead of associated functions.\n fn compare_type_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "cfae63e4a06980303ad13f5b86a454de2907cf63", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "patch": "@@ -132,7 +132,7 @@ use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n use self::coercion::DynamicCoerceMany;\n-use self::compare_method::compare_predicates_and_trait_impl_trait_tys;\n+use self::compare_method::collect_trait_impl_trait_tys;\n use self::region::region_scope_tree;\n pub use self::Expectation::*;\n \n@@ -250,7 +250,7 @@ pub fn provide(providers: &mut Providers) {\n         used_trait_imports,\n         check_mod_item_types,\n         region_scope_tree,\n-        compare_predicates_and_trait_impl_trait_tys,\n+        collect_trait_impl_trait_tys,\n         ..*providers\n     };\n }"}, {"sha": "a6385147c3ae74c14872c89567f59da8501182ab", "filename": "src/test/ui/impl-trait/in-trait/deep-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs?ref=bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "patch": "@@ -9,7 +9,7 @@ trait Foo {\n \n impl Foo for () {\n     fn bar() -> i32 { 0 }\n-    //~^ ERROR method `bar` has an incompatible type for trait\n+    //~^ ERROR method `bar` has an incompatible return type for trait\n }\n \n fn main() {}"}, {"sha": "034ee5ea4e10cef387a944f094c9970bb5be211f", "filename": "src/test/ui/impl-trait/in-trait/deep-match.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.stderr?ref=bec079d1a9fe1a9163a0143ff9e1281b4eb09ec9", "patch": "@@ -1,19 +1,14 @@\n-error[E0053]: method `bar` has an incompatible type for trait\n+error[E0053]: method `bar` has an incompatible return type for trait\n   --> $DIR/deep-match.rs:11:17\n    |\n LL |     fn bar() -> i32 { 0 }\n    |                 ^^^\n    |                 |\n    |                 expected struct `Wrapper`, found `i32`\n-   |                 help: change the output type to match the trait: `Wrapper<_>`\n+   |                 return type in trait\n    |\n-note: type in trait\n-  --> $DIR/deep-match.rs:7:17\n-   |\n-LL |     fn bar() -> Wrapper<impl Sized>;\n-   |                 ^^^^^^^^^^^^^^^^^^^\n-   = note: expected fn pointer `fn() -> Wrapper<_>`\n-              found fn pointer `fn() -> i32`\n+   = note: expected struct `Wrapper<_>`\n+                found type `i32`\n \n error: aborting due to previous error\n "}]}