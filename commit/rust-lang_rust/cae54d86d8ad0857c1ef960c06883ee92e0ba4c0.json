{"sha": "cae54d86d8ad0857c1ef960c06883ee92e0ba4c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZTU0ZDg2ZDhhZDA4NTdjMWVmOTYwYzA2ODgzZWU5MmUwYmE0YzA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-02T15:44:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-02T15:44:43Z"}, "message": "Merge #9761\n\n9761: feat: Show coerced types on type hover r=Veykril a=Veykril\n\nThis applies to both the ranged hover request as well as the normal hover type fallback.\r\n![image](https://user-images.githubusercontent.com/3757771/127883884-2935b624-a3e5-4f35-861a-7d6d3266d187.png)\r\n![image](https://user-images.githubusercontent.com/3757771/127883951-4ff96b6b-7576-4886-887b-1198c1121841.png)\r\n\r\nWe unfortunately have to leave out syntax highlighting here as otherwise the `Type` and `Coerced` words in the hover will get colored.\r\n\r\nNote that this does not show all the coercions yet(and almost no pattern coercions) as not all coercion adjustments are implemented yet.\r\n\r\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/2677\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "1ab0dba7532c3e47d63c40ae1f8af9fa2c944095", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ab0dba7532c3e47d63c40ae1f8af9fa2c944095"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhCBLrCRBK7hj4Ov3rIwAACbkIAAAAb9Up/9llz4dZGJI4Tjo9\nm3Q4a53X5ow3KP+2NwrCtePkEw5j2lB2rwuDQDP6iEUFyGpqPMkdVam2KPgWF7mT\nyKwVKPNkqp679FMApLqkF9LMXQiHvQnmV2Iyfkv/FkDHJeQUxyAmzSIoVKBU3Z33\nYOvfKQXfwU8oYQyvM1ijUu/Fgro3muztwe7NwByYUF7c4u4nKjS+ToI53v+lCbDr\nsdnaIXnTZ+GUChlDYEyzyy5lNgRjUfH+LpC72B9g02LPQSdJlyA8SbXtEs/eaRki\n7Z1JELmVju+zEehqO3FwSnmXMEzjiA2TR5LKKl6CI8iEIyLIv78wA5Tta+UKS+A=\n=dnwh\n-----END PGP SIGNATURE-----\n", "payload": "tree 1ab0dba7532c3e47d63c40ae1f8af9fa2c944095\nparent 138849a479b2404a55c0fd256d36b87a36dd8e4a\nparent f2d2ce03c7a7d2d120495ae4e5164818964d21ec\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1627919083 +0000\ncommitter GitHub <noreply@github.com> 1627919083 +0000\n\nMerge #9761\n\n9761: feat: Show coerced types on type hover r=Veykril a=Veykril\n\nThis applies to both the ranged hover request as well as the normal hover type fallback.\r\n![image](https://user-images.githubusercontent.com/3757771/127883884-2935b624-a3e5-4f35-861a-7d6d3266d187.png)\r\n![image](https://user-images.githubusercontent.com/3757771/127883951-4ff96b6b-7576-4886-887b-1198c1121841.png)\r\n\r\nWe unfortunately have to leave out syntax highlighting here as otherwise the `Type` and `Coerced` words in the hover will get colored.\r\n\r\nNote that this does not show all the coercions yet(and almost no pattern coercions) as not all coercion adjustments are implemented yet.\r\n\r\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/2677\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0", "html_url": "https://github.com/rust-lang/rust/commit/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "138849a479b2404a55c0fd256d36b87a36dd8e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/138849a479b2404a55c0fd256d36b87a36dd8e4a", "html_url": "https://github.com/rust-lang/rust/commit/138849a479b2404a55c0fd256d36b87a36dd8e4a"}, {"sha": "f2d2ce03c7a7d2d120495ae4e5164818964d21ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2d2ce03c7a7d2d120495ae4e5164818964d21ec", "html_url": "https://github.com/rust-lang/rust/commit/f2d2ce03c7a7d2d120495ae4e5164818964d21ec"}], "stats": {"total": 236, "additions": 157, "deletions": 79}, "files": [{"sha": "e17bd9594cb2475fe969943b47a9ea700ab6bb9a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=cae54d86d8ad0857c1ef960c06883ee92e0ba4c0", "patch": "@@ -225,7 +225,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.type_of_pat(pat)\n     }\n \n-    pub fn type_of_pat_with_coercion(&self, expr: &ast::Pat) -> Option<Type> {\n+    pub fn type_of_pat_with_coercion(&self, expr: &ast::Pat) -> Option<(Type, bool)> {\n         self.imp.type_of_pat_with_coercion(expr)\n     }\n \n@@ -577,7 +577,7 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(pat.syntax()).type_of_pat(self.db, pat)\n     }\n \n-    fn type_of_pat_with_coercion(&self, pat: &ast::Pat) -> Option<Type> {\n+    fn type_of_pat_with_coercion(&self, pat: &ast::Pat) -> Option<(Type, bool)> {\n         self.analyze(pat.syntax()).type_of_pat_with_coercion(self.db, pat)\n     }\n "}, {"sha": "e18d27e722deca9c1c458bc8285a02f89f3819de", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=cae54d86d8ad0857c1ef960c06883ee92e0ba4c0", "patch": "@@ -147,15 +147,15 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         pat: &ast::Pat,\n-    ) -> Option<Type> {\n+    ) -> Option<(Type, bool)> {\n         let pat_id = self.pat_id(pat)?;\n         let infer = self.infer.as_ref()?;\n-        let ty = infer\n+        let (ty, coerced) = infer\n             .pat_adjustments\n             .get(&pat_id)\n-            .and_then(|adjusts| adjusts.last().map(|adjust| &adjust.target))\n-            .unwrap_or_else(|| &infer[pat_id]);\n-        Type::new_with_resolver(db, &self.resolver, ty.clone())\n+            .and_then(|adjusts| adjusts.last().map(|adjust| (&adjust.target, true)))\n+            .unwrap_or_else(|| (&infer[pat_id], false));\n+        Type::new_with_resolver(db, &self.resolver, ty.clone()).zip(Some(coerced))\n     }\n \n     pub(crate) fn type_of_self("}, {"sha": "82afae7674fc24085860543ab77a793b6d506229", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 150, "deletions": 72, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae54d86d8ad0857c1ef960c06883ee92e0ba4c0/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=cae54d86d8ad0857c1ef960c06883ee92e0ba4c0", "patch": "@@ -12,12 +12,8 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    algo::{self, find_node_at_range},\n-    ast,\n-    display::fn_as_proc_macro_label,\n-    match_ast, AstNode, AstToken, Direction,\n-    SyntaxKind::*,\n-    SyntaxToken, T,\n+    algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, AstToken, Direction,\n+    SyntaxKind::*, SyntaxToken, T,\n };\n \n use crate::{\n@@ -79,43 +75,35 @@ pub struct HoverResult {\n // image::https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif[]\n pub(crate) fn hover(\n     db: &RootDatabase,\n-    range: FileRange,\n+    FileRange { file_id, range }: FileRange,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     let sema = hir::Semantics::new(db);\n-    let file = sema.parse(range.file_id).syntax().clone();\n+    let file = sema.parse(file_id).syntax().clone();\n \n-    // This means we're hovering over a range.\n-    if !range.range.is_empty() {\n-        let expr = find_node_at_range::<ast::Expr>(&file, range.range)?;\n-        let ty = sema.type_of_expr(&expr)?;\n-\n-        if ty.is_unknown() {\n-            return None;\n-        }\n-\n-        let mut res = HoverResult::default();\n-\n-        res.markup = if config.markdown() {\n-            Markup::fenced_block(&ty.display(db))\n-        } else {\n-            ty.display(db).to_string().into()\n-        };\n-\n-        return Some(RangeInfo::new(range.range, res));\n-    }\n+    let offset = if range.is_empty() {\n+        range.start()\n+    } else {\n+        let expr = file.covering_element(range).ancestors().find_map(|it| {\n+            match_ast! {\n+                match it {\n+                    ast::Expr(expr) => Some(Either::Left(expr)),\n+                    ast::Pat(pat) => Some(Either::Right(pat)),\n+                    _ => None,\n+                }\n+            }\n+        })?;\n+        return hover_type_info(&sema, config, expr).map(|it| RangeInfo::new(range, it));\n+    };\n \n-    let position = FilePosition { file_id: range.file_id, offset: range.range.start() };\n-    let token = pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n+    let token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n         IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] => 3,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n     })?;\n     let token = sema.descend_into_macros(token);\n \n-    let mut res = HoverResult::default();\n-\n     let node = token.parent()?;\n     let mut range = None;\n     let definition = match_ast! {\n@@ -146,8 +134,8 @@ pub(crate) fn hover(\n                     let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n                     let (idl_range, link, ns) =\n                         extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n-                            let hir::InFile { file_id, value: mapped_range } = doc_mapping.map(range)?;\n-                            (file_id == position.file_id.into() && mapped_range.contains(position.offset)).then(||(mapped_range, link, ns))\n+                            let mapped = doc_mapping.map(range)?;\n+                            (mapped.file_id == file_id.into() && mapped.value.contains(offset)).then(||(mapped.value, link, ns))\n                         })?;\n                     range = Some(idl_range);\n                     Some(match resolve_doc_path_for_def(db,def, &link,ns)? {\n@@ -176,6 +164,7 @@ pub(crate) fn hover(\n             _ => None,\n         };\n         if let Some(markup) = hover_for_definition(db, definition, famous_defs.as_ref(), config) {\n+            let mut res = HoverResult::default();\n             res.markup = process_markup(sema.db, definition, &markup, config);\n             if let Some(action) = show_implementations_action(db, definition) {\n                 res.actions.push(action);\n@@ -185,7 +174,7 @@ pub(crate) fn hover(\n                 res.actions.push(action);\n             }\n \n-            if let Some(action) = runnable_action(&sema, definition, position.file_id) {\n+            if let Some(action) = runnable_action(&sema, definition, file_id) {\n                 res.actions.push(action);\n             }\n \n@@ -207,27 +196,59 @@ pub(crate) fn hover(\n         .take_while(|it| !ast::Item::can_cast(it.kind()))\n         .find(|n| ast::Expr::can_cast(n.kind()) || ast::Pat::can_cast(n.kind()))?;\n \n-    let ty = match_ast! {\n+    let expr_or_pat = match_ast! {\n         match node {\n-            ast::Expr(it) => sema.type_of_expr(&it)?,\n-            ast::Pat(it) => sema.type_of_pat(&it)?,\n+            ast::Expr(it) => Either::Left(it),\n+            ast::Pat(it) => Either::Right(it),\n             // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n             // (e.g expanding a builtin macro). So we give up here.\n             ast::MacroCall(_it) => return None,\n             _ => return None,\n         }\n     };\n \n-    res.markup = if config.markdown() {\n-        Markup::fenced_block(&ty.display(db))\n-    } else {\n-        ty.display(db).to_string().into()\n-    };\n-\n+    let res = hover_type_info(&sema, config, expr_or_pat)?;\n     let range = sema.original_range(&node).range;\n     Some(RangeInfo::new(range, res))\n }\n \n+fn hover_type_info(\n+    sema: &Semantics<RootDatabase>,\n+    config: &HoverConfig,\n+    expr_or_pat: Either<ast::Expr, ast::Pat>,\n+) -> Option<HoverResult> {\n+    let (ty, coerced) = match &expr_or_pat {\n+        Either::Left(expr) => sema.type_of_expr_with_coercion(expr)?,\n+        Either::Right(pat) => sema.type_of_pat_with_coercion(pat)?,\n+    };\n+\n+    let mut res = HoverResult::default();\n+    res.markup = if coerced {\n+        let uncoerced_ty = match &expr_or_pat {\n+            Either::Left(expr) => sema.type_of_expr(expr)?,\n+            Either::Right(pat) => sema.type_of_pat(pat)?,\n+        };\n+        let uncoerced = uncoerced_ty.display(sema.db).to_string();\n+        let coerced = ty.display(sema.db).to_string();\n+        format!(\n+            \"```text\\nType: {:>upad$}\\nCoerced to: {:>cpad$}\\n```\\n\",\n+            uncoerced = uncoerced,\n+            coerced = coerced,\n+            // 6 base padding for static text prefix of each line\n+            upad = 6 + coerced.len().max(uncoerced.len()),\n+            cpad = uncoerced.len(),\n+        )\n+        .into()\n+    } else {\n+        if config.markdown() {\n+            Markup::fenced_block(&ty.display(sema.db))\n+        } else {\n+            ty.display(sema.db).to_string().into()\n+        }\n+    };\n+    Some(res)\n+}\n+\n fn try_hover_for_lint(attr: &ast::Attr, token: &SyntaxToken) -> Option<RangeInfo<HoverResult>> {\n     let (path, tt) = attr.as_simple_call()?;\n     if !tt.syntax().text_range().contains(token.text_range().start()) {\n@@ -1192,7 +1213,7 @@ impl Thing {\n }\n \n fn main() { let foo_$0test = Thing::new(); }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo_test*\n \n@@ -1562,7 +1583,7 @@ fn foo() {\n             fn foo() {\n                 format!(\"hel$0lo {}\", 0);\n             }\n-            \"#,\n+\"#,\n         );\n     }\n \n@@ -1670,7 +1691,7 @@ extern crate st$0d;\n //!\n //! Printed?\n //! abc123\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *std*\n \n@@ -1695,7 +1716,7 @@ extern crate std as ab$0c;\n //!\n //! Printed?\n //! abc123\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *abc*\n \n@@ -2214,7 +2235,7 @@ mod tests$0 {\n struct S{ f1: u32 }\n \n fn main() { let s$0t = S{ f1:0 }; }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n@@ -2293,7 +2314,7 @@ struct Arg(u32);\n struct S<T>{ f1: T }\n \n fn main() { let s$0t = S{ f1: S{ f1: Arg(0) } }; }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n@@ -2482,7 +2503,7 @@ trait Bar {}\n fn foo() -> impl Foo + Bar {}\n \n fn main() { let s$0t = foo(); }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n@@ -2915,7 +2936,7 @@ struct B<T> {}\n struct S {}\n \n fn foo(a$0rg: &impl ImplTrait<B<dyn DynTrait<B<S>>>>) {}\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 [\n                     GoToType(\n@@ -3711,7 +3732,7 @@ mod string {\n     /// This is `alloc::String`.\n     pub struct String;\n }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *String*\n \n@@ -3830,7 +3851,7 @@ pub fn foo() {}\n //- /lib.rs crate:main.rs deps:foo\n #[fo$0o::bar()]\n struct Foo;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3846,7 +3867,7 @@ struct Foo;\n         check(\n             r#\"\n use self as foo$0;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3859,7 +3880,7 @@ use self as foo$0;\n             r#\"\n mod bar {}\n use bar::{self as foo$0};\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3877,7 +3898,7 @@ use bar::{self as foo$0};\n mod bar {\n     use super as foo$0;\n }\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3889,7 +3910,7 @@ mod bar {\n         check(\n             r#\"\n use crate as foo$0;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -3908,7 +3929,7 @@ use crate as foo$0;\n pub macro Copy {}\n #[derive(Copy$0)]\n struct Foo;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *Copy*\n \n@@ -3929,7 +3950,7 @@ mod foo {\n }\n #[derive(foo::Copy$0)]\n struct Foo;\n-            \"#,\n+\"#,\n             expect![[r#\"\n                 *Copy*\n \n@@ -3949,7 +3970,7 @@ struct Foo;\n         check_hover_range(\n             r#\"\n fn f() { let expr = $01 + 2 * 3$0 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             i32\n@@ -3959,7 +3980,7 @@ fn f() { let expr = $01 + 2 * 3$0 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = 1 $0+ 2 * $03 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             i32\n@@ -3969,7 +3990,7 @@ fn f() { let expr = 1 $0+ 2 * $03 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = 1 + $02 * 3$0 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             i32\n@@ -3982,7 +4003,7 @@ fn f() { let expr = 1 + $02 * 3$0 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = $0[1, 2, 3, 4]$0 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             [i32; 4]\n@@ -3992,7 +4013,7 @@ fn f() { let expr = $0[1, 2, 3, 4]$0 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = [1, 2, $03, 4]$0 }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             [i32; 4]\n@@ -4002,7 +4023,7 @@ fn f() { let expr = [1, 2, $03, 4]$0 }\n         check_hover_range(\n             r#\"\n fn f() { let expr = [1, 2, $03$0, 4] }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             i32\n@@ -4016,7 +4037,7 @@ fn f() { let expr = [1, 2, $03$0, 4] }\n             r#\"\n fn f<T>(a: &[T]) { }\n fn b() { $0f$0(&[1, 2, 3, 4, 5]); }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             fn f<i32>(&[i32])\n@@ -4027,7 +4048,7 @@ fn b() { $0f$0(&[1, 2, 3, 4, 5]); }\n             r#\"\n fn f<T>(a: &[T]) { }\n fn b() { f($0&[1, 2, 3, 4, 5]$0); }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             &[i32; 5]\n@@ -4041,20 +4062,20 @@ fn b() { f($0&[1, 2, 3, 4, 5]$0); }\n             r#\"\n fn f<T>(a: &[T]) { }\n fn b()$0 { f(&[1, 2, 3, 4, 5]); }$0\n-            \"#,\n+\"#,\n         );\n \n         check_hover_range_no_results(\n             r#\"\n fn f<T>$0(a: &[T]) { }\n fn b() { f(&[1, 2, 3,$0 4, 5]); }\n-            \"#,\n+\"#,\n         );\n \n         check_hover_range_no_results(\n             r#\"\n fn $0f() { let expr = [1, 2, 3, 4]$0 }\n-            \"#,\n+\"#,\n         );\n     }\n \n@@ -4064,7 +4085,7 @@ fn $0f() { let expr = [1, 2, 3, 4]$0 }\n             r#\"\n fn f<T>(a: &[T]) { }\n fn b() { $0f(&[1, 2, 3, 4, 5]); }$0\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             ()\n@@ -4074,11 +4095,68 @@ fn b() { $0f(&[1, 2, 3, 4, 5]); }$0\n         check_hover_range(\n             r#\"\n fn f() { let expr$0 = $0[1, 2, 3, 4] }\n-            \"#,\n+\"#,\n             expect![[r#\"\n             ```rust\n             ()\n             ```\"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_range_for_pat() {\n+        check_hover_range(\n+            r#\"\n+fn foo() {\n+    let $0x$0 = 0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```rust\n+                i32\n+                ```\"#]],\n+        );\n+\n+        check_hover_range(\n+            r#\"\n+fn foo() {\n+    let $0x$0 = \"\";\n+}\n+\"#,\n+            expect![[r#\"\n+                ```rust\n+                &str\n+                ```\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_range_shows_coercions_if_applicable_expr() {\n+        check_hover_range(\n+            r#\"\n+fn foo() {\n+    let x: &u32 = $0&&&&&0$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```text\n+                Type:       &&&&&u32\n+                Coerced to:     &u32\n+                ```\n+            \"#]],\n+        );\n+        check_hover_range(\n+            r#\"\n+fn foo() {\n+    let x: *const u32 = $0&0$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                ```text\n+                Type:             &u32\n+                Coerced to: *const u32\n+                ```\n+            \"#]],\n+        );\n+    }\n }"}]}