{"sha": "972e25410651e31a9458a4a47cc739ecd446f35a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MmUyNTQxMDY1MWUzMWE5NDU4YTRhNDdjYzczOWVjZDQ0NmYzNWE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-27T17:50:49Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:11:19Z"}, "message": "Implement const generics for `InferenceFudger`", "tree": {"sha": "58ac22ec93b733c0572d96f4159fa05416aea867", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58ac22ec93b733c0572d96f4159fa05416aea867"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/972e25410651e31a9458a4a47cc739ecd446f35a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/972e25410651e31a9458a4a47cc739ecd446f35a", "html_url": "https://github.com/rust-lang/rust/commit/972e25410651e31a9458a4a47cc739ecd446f35a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/972e25410651e31a9458a4a47cc739ecd446f35a/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2416936620f86a8c520a6128aaa461fc5b88c7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2416936620f86a8c520a6128aaa461fc5b88c7c", "html_url": "https://github.com/rust-lang/rust/commit/f2416936620f86a8c520a6128aaa461fc5b88c7c"}], "stats": {"total": 46, "additions": 33, "deletions": 13}, "files": [{"sha": "5f5a2d4a489e361fbfa10bb5c00f31a6614ca2a4", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/972e25410651e31a9458a4a47cc739ecd446f35a/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972e25410651e31a9458a4a47cc739ecd446f35a/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=972e25410651e31a9458a4a47cc739ecd446f35a", "patch": "@@ -1,13 +1,27 @@\n-use crate::ty::{self, Ty, TyCtxt, TyVid, IntVid, FloatVid, RegionVid};\n+use crate::ty::{self, Ty, TyCtxt, TyVid, IntVid, FloatVid, RegionVid, ConstVid};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::mir::interpret::ConstValue;\n \n use super::InferCtxt;\n-use super::RegionVariableOrigin;\n+use super::{RegionVariableOrigin, ConstVariableOrigin};\n use super::type_variable::TypeVariableOrigin;\n \n+use rustc_data_structures::unify as ut;\n+use ut::UnifyKey;\n+\n+use std::cell::RefMut;\n use std::ops::Range;\n \n+fn const_vars_since_snapshot<'tcx>(\n+    mut table: RefMut<'_, ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>>,\n+    snapshot: &ut::Snapshot<ut::InPlace<ConstVid<'tcx>>>,\n+) -> (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>) {\n+    let range = table.vars_since_snapshot(snapshot);\n+    (range.start..range.end, (range.start.index..range.end.index).map(|index| {\n+        table.probe_value(ConstVid::from_index(index)).origin.clone()\n+    }).collect())\n+}\n+\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// This rather funky routine is used while processing expected\n     /// types. What happens here is that we want to propagate a\n@@ -80,13 +94,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let region_vars = self.borrow_region_constraints().vars_since_snapshot(\n                         &snapshot.region_constraints_snapshot,\n                     );\n+                    let const_vars = const_vars_since_snapshot(\n+                        self.const_unification_table.borrow_mut(),\n+                        &snapshot.const_snapshot,\n+                    );\n \n                     let fudger = InferenceFudger {\n                         infcx: self,\n                         type_vars,\n                         int_vars,\n                         float_vars,\n                         region_vars,\n+                        const_vars,\n                     };\n \n                     Ok((fudger, value))\n@@ -105,7 +124,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         if fudger.type_vars.0.is_empty() &&\n             fudger.int_vars.is_empty() &&\n             fudger.float_vars.is_empty() &&\n-            fudger.region_vars.0.is_empty() {\n+            fudger.region_vars.0.is_empty() &&\n+            fudger.const_vars.0.is_empty() {\n             Ok(value)\n         } else {\n             Ok(value.fold_with(&mut fudger))\n@@ -119,6 +139,7 @@ pub struct InferenceFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     int_vars: Range<IntVid>,\n     float_vars: Range<FloatVid>,\n     region_vars: (Range<RegionVid>, Vec<RegionVariableOrigin>),\n+    const_vars: (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>),\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx> {\n@@ -166,9 +187,9 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx>\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if let ty::ReVar(vid) = r {\n+        if let ty::ReVar(vid) = *r {\n             if self.region_vars.0.contains(&vid) {\n-                let idx = (vid.index() - self.region_vars.0.start.index()) as usize;\n+                let idx = vid.index() - self.region_vars.0.start.index();\n                 let origin = self.region_vars.1[idx];\n                 return self.infcx.next_region_var(origin);\n             }\n@@ -177,14 +198,12 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx>\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ConstValue::Infer(ty::InferConst::Var(vid)), ty } = *ct {\n-            if self.const_variables.contains(&vid) {\n-                // This variable was created during the\n-                // fudging. Recreate it with a fresh variable\n-                // here.\n-                let origin = self.infcx.const_unification_table.borrow_mut()\n-                    .probe_value(vid)\n-                    .origin;\n+        if let ty::Const { val: ConstValue::Infer(ty::InferConst::Var(vid)), ty } = ct {\n+            if self.const_vars.0.contains(&vid) {\n+                // This variable was created during the fudging.\n+                // Recreate it with a fresh variable here.\n+                let idx = (vid.index - self.const_vars.0.start.index) as usize;\n+                let origin = self.const_vars.1[idx];\n                 self.infcx.next_const_var(ty, origin)\n             } else {\n                 ct"}, {"sha": "f4f5c868e2c8d51218b69c18c02fb702d549a61d", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/972e25410651e31a9458a4a47cc739ecd446f35a/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/972e25410651e31a9458a4a47cc739ecd446f35a/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=972e25410651e31a9458a4a47cc739ecd446f35a", "patch": "@@ -28,6 +28,7 @@ use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::Kind;\n use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::mir::interpret::ConstValue;\n use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Debug;\n "}]}