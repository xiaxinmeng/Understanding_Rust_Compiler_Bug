{"sha": "80e988d7a6494caffe162578760ed390cd47c0cc", "node_id": "C_kwDOAAsO6NoAKDgwZTk4OGQ3YTY0OTRjYWZmZTE2MjU3ODc2MGVkMzkwY2Q0N2MwY2M", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-29T19:19:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-29T19:19:49Z"}, "message": "Rollup merge of #109675 - compiler-errors:object-heck, r=lcnr\n\nDo not consider elaborated projection predicates for objects in new solver\n\nObject types have projection bounds which are elaborated during astconv. There's no need to do it again for projection goals, since that'll give us duplicate projection candidatesd that are distinct up to regions due to the fact that we canonicalize every region to a separate variable. See quick example below the break for a better explanation.\n\nDiscussed this with lcnr, and adding a stop-gap until we get something like intersection region constraints (or modify canonicalization to canonicalize identical regions to the same canonical regions) -- after which, this will hopefully not matter and may be removed.\n\nr? `@lcnr`\n\n---\n\nSee `tests/ui/traits/new-solver/more-object-bound.rs`:\n\nConsider a goal: `<dyn Iter<'a, ()> as Iterator>::Item = &'a ()`.\n\nAfter canonicalization: `<dyn Iter<'!0r, (), Item = '!1r ()> as Iterator>::Item == &!'2r ()`\n* First object candidate comes from the item bound in the dyn's bounds itself, giving us `<dyn Iter<'!0r, (), Item = '?!r ()> as Iterator>::Item == &!'1r ()`. This gives us one region constraint: `!'1r == !'2r`.\n* Second object candidate comes from elaborating the principal trait ref, gives us `<dyn Iter<'!0r, (), Item = '!1r ()> as Iterator>::Item == &!'0r ()`. This gives us one region constraint: `!'0r == !'2r`.\n* Oops! Ambiguity!", "tree": {"sha": "eaf76b480b5070474639875b4de81652fab9b864", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaf76b480b5070474639875b4de81652fab9b864"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80e988d7a6494caffe162578760ed390cd47c0cc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkJI9VCRBK7hj4Ov3rIwAApOMIAGVDIFeDD/a/cUpMVRMs4Vc9\nnvKaSjtdtoOdSdQFS3Sgjgjo/kaIoYx15VL7H6JzRYZUT12w7G8nGPC1NRfXtFuM\npZfX6OoUeoaYZj1hwsR9HlkhBVxfALAgUDmMzxWt9F0n5n+pUBoiBCDnGEG9Wubz\nWeyeLCKe/1NXvBYi7QGE/L8ae4ksBSomzSLVqND50142jXY5vgWsIVN4q+QfCs7Z\ncSP3UuoIStgDJ5GoY4g8tbo8sYB8ACGwecq4veAEgvVuZuclujUQgfGkcpC6Szj6\n6AiXWyM0WDYIBsFsOGt0w5TqtxE2yF7tH85VFK+Yibu4SSEGgdlKt4B+nm5subY=\n=qj/7\n-----END PGP SIGNATURE-----\n", "payload": "tree eaf76b480b5070474639875b4de81652fab9b864\nparent 83573a377602a27dd65c8b564391e5706d5d76be\nparent d62238d6a8ed57fecddfa9b97fd79cb0ac814791\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1680117589 +0200\ncommitter GitHub <noreply@github.com> 1680117589 +0200\n\nRollup merge of #109675 - compiler-errors:object-heck, r=lcnr\n\nDo not consider elaborated projection predicates for objects in new solver\n\nObject types have projection bounds which are elaborated during astconv. There's no need to do it again for projection goals, since that'll give us duplicate projection candidatesd that are distinct up to regions due to the fact that we canonicalize every region to a separate variable. See quick example below the break for a better explanation.\n\nDiscussed this with lcnr, and adding a stop-gap until we get something like intersection region constraints (or modify canonicalization to canonicalize identical regions to the same canonical regions) -- after which, this will hopefully not matter and may be removed.\n\nr? `@lcnr`\n\n---\n\nSee `tests/ui/traits/new-solver/more-object-bound.rs`:\n\nConsider a goal: `<dyn Iter<'a, ()> as Iterator>::Item = &'a ()`.\n\nAfter canonicalization: `<dyn Iter<'!0r, (), Item = '!1r ()> as Iterator>::Item == &!'2r ()`\n* First object candidate comes from the item bound in the dyn's bounds itself, giving us `<dyn Iter<'!0r, (), Item = '?!r ()> as Iterator>::Item == &!'1r ()`. This gives us one region constraint: `!'1r == !'2r`.\n* Second object candidate comes from elaborating the principal trait ref, gives us `<dyn Iter<'!0r, (), Item = '!1r ()> as Iterator>::Item == &!'0r ()`. This gives us one region constraint: `!'0r == !'2r`.\n* Oops! Ambiguity!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80e988d7a6494caffe162578760ed390cd47c0cc", "html_url": "https://github.com/rust-lang/rust/commit/80e988d7a6494caffe162578760ed390cd47c0cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80e988d7a6494caffe162578760ed390cd47c0cc/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83573a377602a27dd65c8b564391e5706d5d76be", "url": "https://api.github.com/repos/rust-lang/rust/commits/83573a377602a27dd65c8b564391e5706d5d76be", "html_url": "https://github.com/rust-lang/rust/commit/83573a377602a27dd65c8b564391e5706d5d76be"}, {"sha": "d62238d6a8ed57fecddfa9b97fd79cb0ac814791", "url": "https://api.github.com/repos/rust-lang/rust/commits/d62238d6a8ed57fecddfa9b97fd79cb0ac814791", "html_url": "https://github.com/rust-lang/rust/commit/d62238d6a8ed57fecddfa9b97fd79cb0ac814791"}], "stats": {"total": 46, "additions": 37, "deletions": 9}, "files": [{"sha": "856b1c08b7237d610a36290b30e2448601aaa5fa", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/80e988d7a6494caffe162578760ed390cd47c0cc/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e988d7a6494caffe162578760ed390cd47c0cc/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=80e988d7a6494caffe162578760ed390cd47c0cc", "patch": "@@ -6,6 +6,7 @@ use super::trait_goals::structural_traits::*;\n use super::{EvalCtxt, SolverMode};\n use crate::traits::coherence;\n use itertools::Itertools;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -489,9 +490,21 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         };\n \n         let tcx = self.tcx();\n-        for assumption in\n-            elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n-        {\n+        let own_bounds: FxIndexSet<_> =\n+            bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)).collect();\n+        for assumption in elaborate_predicates(tcx, own_bounds.iter().copied()) {\n+            // FIXME: Predicates are fully elaborated in the object type's existential bounds\n+            // list. We want to only consider these pre-elaborated projections, and not other\n+            // projection predicates that we reach by elaborating the principal trait ref,\n+            // since that'll cause ambiguity.\n+            //\n+            // We can remove this when we have implemented intersections in responses.\n+            if assumption.to_opt_poly_projection_pred().is_some()\n+                && !own_bounds.contains(&assumption)\n+            {\n+                continue;\n+            }\n+\n             match G::consider_object_bound_candidate(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })"}, {"sha": "e608250063c0bdc63c1410ea5a5b47b3df4355fa", "filename": "tests/ui/traits/new-solver/dont-elaborate-for-projections.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80e988d7a6494caffe162578760ed390cd47c0cc/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-elaborate-for-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e988d7a6494caffe162578760ed390cd47c0cc/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-elaborate-for-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-elaborate-for-projections.rs?ref=80e988d7a6494caffe162578760ed390cd47c0cc", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Iter<'a, I: 'a>: Iterator<Item = &'a I> {}\n+\n+fn needs_iter<'a, T: Iter<'a, I> + ?Sized, I: 'a>(_: &T) {}\n+\n+fn test(x: &dyn Iter<'_, ()>) {\n+    needs_iter(x);\n+}\n+\n+fn main() {}"}, {"sha": "bb730b18ef77be91f90dbdf04ca312de5145cf54", "filename": "tests/ui/traits/new-solver/more-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80e988d7a6494caffe162578760ed390cd47c0cc/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80e988d7a6494caffe162578760ed390cd47c0cc/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs?ref=80e988d7a6494caffe162578760ed390cd47c0cc", "patch": "@@ -10,7 +10,7 @@ trait Trait: SuperTrait<A = <Self as SuperTrait>::B> {}\n \n fn transmute<A, B>(x: A) -> B {\n     foo::<A, B, dyn Trait<A = A, B = B>>(x)\n-    //~^ ERROR type annotations needed: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n+    //~^ ERROR the trait bound `dyn Trait<A = A, B = B>: Trait` is not satisfied\n }\n \n fn foo<A, B, T: ?Sized>(x: T::A) -> B"}, {"sha": "4554b8c7473cb7f37e7092414e9b8cdb70058b51", "filename": "tests/ui/traits/new-solver/more-object-bound.stderr", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/80e988d7a6494caffe162578760ed390cd47c0cc/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80e988d7a6494caffe162578760ed390cd47c0cc/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr?ref=80e988d7a6494caffe162578760ed390cd47c0cc", "patch": "@@ -1,10 +1,9 @@\n-error[E0283]: type annotations needed: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n-  --> $DIR/more-object-bound.rs:12:5\n+error[E0277]: the trait bound `dyn Trait<A = A, B = B>: Trait` is not satisfied\n+  --> $DIR/more-object-bound.rs:12:17\n    |\n LL |     foo::<A, B, dyn Trait<A = A, B = B>>(x)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait` is not implemented for `dyn Trait<A = A, B = B>`\n    |\n-   = note: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n note: required by a bound in `foo`\n   --> $DIR/more-object-bound.rs:18:8\n    |\n@@ -13,7 +12,11 @@ LL | fn foo<A, B, T: ?Sized>(x: T::A) -> B\n LL | where\n LL |     T: Trait<B = B>,\n    |        ^^^^^^^^^^^^ required by this bound in `foo`\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn transmute<A, B>(x: A) -> B where dyn Trait<A = A, B = B>: Trait {\n+   |                               ++++++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0283`.\n+For more information about this error, try `rustc --explain E0277`."}]}