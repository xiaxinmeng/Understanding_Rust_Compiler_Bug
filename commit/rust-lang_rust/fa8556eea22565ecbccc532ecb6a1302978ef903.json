{"sha": "fa8556eea22565ecbccc532ecb6a1302978ef903", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhODU1NmVlYTIyNTY1ZWNiY2NjNTMyZWNiNmExMzAyOTc4ZWY5MDM=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2016-02-25T14:09:26Z"}, "committer": {"name": "Jonathan S", "email": "gereeter+code@gmail.com", "date": "2016-02-25T14:09:26Z"}, "message": "Fix review comments in BTreeMap's Node documentation", "tree": {"sha": "1ac11e9309562f362a30549ba2a20e641163cace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ac11e9309562f362a30549ba2a20e641163cace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa8556eea22565ecbccc532ecb6a1302978ef903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8556eea22565ecbccc532ecb6a1302978ef903", "html_url": "https://github.com/rust-lang/rust/commit/fa8556eea22565ecbccc532ecb6a1302978ef903", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa8556eea22565ecbccc532ecb6a1302978ef903/comments", "author": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gereeter", "id": 2328242, "node_id": "MDQ6VXNlcjIzMjgyNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2328242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gereeter", "html_url": "https://github.com/gereeter", "followers_url": "https://api.github.com/users/gereeter/followers", "following_url": "https://api.github.com/users/gereeter/following{/other_user}", "gists_url": "https://api.github.com/users/gereeter/gists{/gist_id}", "starred_url": "https://api.github.com/users/gereeter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gereeter/subscriptions", "organizations_url": "https://api.github.com/users/gereeter/orgs", "repos_url": "https://api.github.com/users/gereeter/repos", "events_url": "https://api.github.com/users/gereeter/events{/privacy}", "received_events_url": "https://api.github.com/users/gereeter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3", "html_url": "https://github.com/rust-lang/rust/commit/762d4ac734e096e8e4ea9fdeb23cf6ce9965d2c3"}], "stats": {"total": 167, "additions": 96, "deletions": 71}, "files": [{"sha": "0f54803da23a838e589c3bbea6a01456d991101f", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 96, "deletions": 71, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/fa8556eea22565ecbccc532ecb6a1302978ef903/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8556eea22565ecbccc532ecb6a1302978ef903/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=fa8556eea22565ecbccc532ecb6a1302978ef903", "patch": "@@ -39,7 +39,7 @@\n // - Trees must have uniform depth/height. This means that every path down to a leaf from a\n //   given node has exactly the same length.\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n-//   This implies that even an empty node has at least one edge.\n+//   This implies that even an empty internal node has at least one edge.\n \n use alloc::heap;\n use core::marker::PhantomData;\n@@ -53,34 +53,38 @@ use boxed::Box;\n const B: usize = 6;\n pub const CAPACITY: usize = 2 * B - 1;\n \n-/// The underlying representation of leaf nodes. Note that is often unsafe to actually store\n-/// these, since only the first `len` keys and values are assumed to initialized. See also\n-/// rust-lang/rfcs#197, which would make this structure significantly more safe by avoiding\n-/// accidentally dropping unused and uninitialized keys and values.\n+/// The underlying representation of leaf nodes. Note that it is often unsafe to actually store\n+/// these, since only the first `len` keys and values are assumed to be initialized. As such,\n+/// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n+/// case.\n+///\n+/// See also rust-lang/rfcs#197, which would make this structure significantly more safe by\n+/// avoiding accidentally dropping unused and uninitialized keys and values.\n struct LeafNode<K, V> {\n-    // The arrays storing the actual data of the node. Only the first `len` elements of each\n-    // array are initialized and valid.\n+    /// The arrays storing the actual data of the node. Only the first `len` elements of each\n+    /// array are initialized and valid.\n     keys: [K; CAPACITY],\n     vals: [V; CAPACITY],\n \n-    // We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n-    // This either points to an actual node or is null.\n+    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n+    /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n \n-    // The index into the parent node's `edges` array. `*node.parent.edges[node.parent_idx]`\n-    // should be the same thing as `node`.\n-    // This is only guaranteed to be initialized when `parent` is nonnull.\n+    /// This node's index into the parent node's `edges` array.\n+    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n+    /// This is only guaranteed to be initialized when `parent` is nonnull.\n     parent_idx: u16,\n \n-    // The number of keys and values this node stores.\n-    // This is at the end of the node's representation and next to `parent_idx` to encourage\n-    // the compiler to join `len` and `parent_idx` into the same 32-bit word, reducing space\n-    // overhead.\n+    /// The number of keys and values this node stores.\n+    ///\n+    /// This is at the end of the node's representation and next to `parent_idx` to encourage\n+    /// the compiler to join `len` and `parent_idx` into the same 32-bit word, reducing space\n+    /// overhead.\n     len: u16,\n }\n \n impl<K, V> LeafNode<K, V> {\n-    /// Create a new `LeafNode`. Unsafe because all nodes should really be hidden behind\n+    /// Creates a new `LeafNode`. Unsafe because all nodes should really be hidden behind\n     /// `BoxedNode`, preventing accidental dropping of uninitialized keys and values.\n     unsafe fn new() -> Self {\n         LeafNode {\n@@ -104,16 +108,19 @@ impl<K, V> LeafNode<K, V> {\n struct InternalNode<K, V> {\n     data: LeafNode<K, V>,\n \n-    // `len + 1` of these are considered to be initialized and valid.\n+    /// The pointers to the children of this node. `len + 1` of these are considered\n+    /// initialized and valid.\n     edges: [BoxedNode<K, V>; 2 * B],\n }\n \n impl<K, V> InternalNode<K, V> {\n-    /// Create a new `InternalNode`. This is unsafe for two reasons. First, it returns an\n-    /// `InternalNode` by value, risking dropping of uninitialized fields. Second, an invariant of\n-    /// internal nodes is that `len + 1` edges are initialized and valid, meaning that even when\n-    /// the node is empty (having `len` 0), there must be one initialized and valid edge. This\n-    /// function does not set up such an edge.\n+    /// Creates a new `InternalNode`.\n+    ///\n+    /// This is unsafe for two reasons. First, it returns an `InternalNode` by value, risking\n+    /// dropping of uninitialized fields. Second, an invariant of internal nodes is that `len + 1`\n+    /// edges are initialized and valid, meaning that even when the node is empty (having a\n+    /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n+    /// such an edge.\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n@@ -202,7 +209,7 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n-    /// Add a new internal node with a single edge, pointing to the previous root, and make that\n+    /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self)\n             -> NodeRef<marker::Mut, K, V, marker::Internal> {\n@@ -226,7 +233,7 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    ///\u00a0Remove the root node, using its first child as the new root. This cannot be called when\n+    /// Removes the root node, using its first child as the new root. This cannot be called when\n     /// the tree consists only of a leaf node. As it is intended only to be called when the root\n     /// has only one edge, no cleanup is done on any of the other children are elements of the root.\n     /// This decreases the height by 1 and is the opposite of `push_level`.\n@@ -315,13 +322,13 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n \n \n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n-    /// Find the length of the node. This is the number of keys or values. In an\n+    /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n     pub fn len(&self) -> usize {\n         self.as_leaf().len as usize\n     }\n \n-    /// Remove any static information about whether this node is a `Leaf` or an\n+    /// Removes any static information about whether this node is a `Leaf` or an\n     /// `Internal` node.\n     pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         NodeRef {\n@@ -332,7 +339,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n-    /// Temporarily take out another, immutable reference to the same node.\n+    /// Temporarily takes out another, immutable reference to the same node.\n     fn reborrow<'a>(&'a self) -> NodeRef<marker::Immut<'a>, K, V, Type> {\n         NodeRef {\n             height: self.height,\n@@ -356,7 +363,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         self.reborrow().into_slices().1\n     }\n \n-    /// Find the parent of the current node. Returns `Ok(handle)` if the current\n+    /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n     /// node actually has a parent, where `handle` points to the edge of the parent\n     /// that points to the current node. Returns `Err(self)` if the current node has\n     /// no parent, giving back the original `NodeRef`.\n@@ -403,7 +410,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n-    /// Similar to `ascend`, get a reference to a node's parent node, but also\n+    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocate the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(self) -> Option<\n@@ -424,7 +431,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n-    /// Similar to `ascend`, get a reference to a node's parent node, but also\n+    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocate the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(self) -> Option<\n@@ -449,7 +456,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n }\n \n impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// Unsafely assert to the compiler some static information about whether this\n+    /// Unsafely asserts to the compiler some static information about whether this\n     /// node is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n             -> NodeRef<marker::Mut, K, V, NewType> {\n@@ -462,7 +469,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    /// Temporarily take out another, mutable reference to the same node. Beware, as\n+    /// Temporarily takes out another, mutable reference to the same node. Beware, as\n     /// this method is very dangerous, doubly so since it may not immediately appear\n     /// dangerous.\n     ///\n@@ -514,7 +521,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    /// Get a mutable reference to the root itself. This is useful primarily when the\n+    /// Gets a mutable reference to the root itself. This is useful primarily when the\n     /// height of the tree needs to be adjusted. Never call this on a reborrowed pointer.\n     pub fn into_root_mut(self) -> &'a mut Root<K, V> {\n         unsafe {\n@@ -539,7 +546,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n-    /// Add a key/value pair the end of the node.\n+    /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n@@ -554,7 +561,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         self.as_leaf_mut().len += 1;\n     }\n \n-    /// Add a key/value pair to the beginning of the node.\n+    /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n@@ -569,7 +576,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Add a key/value pair and an edge to go to the right of that pair to\n+    /// Adds a key/value pair and an edge to go to the right of that pair to\n     /// the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but this is an internal module\n@@ -589,7 +596,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n-    /// Add a key/value pair and an edge to go to the left of that pair to\n+    /// Adds a key/value pair and an edge to go to the left of that pair to\n     /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but this is an internal module\n@@ -619,8 +626,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n-    /// Remove a key/value pair from the end of this node. If this is an internal node,\n-    /// also remove the edge that was to the right of that pair.\n+    /// Removes a key/value pair from the end of this node. If this is an internal node,\n+    /// also removes the edge that was to the right of that pair.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() > 0);\n@@ -645,8 +652,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Remove a key/value pair from the beginning of this node. If this is an internal node,\n-    /// also remove the edge that was to the left of that pair.\n+    /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n+    /// also removes the edge that was to the left of that pair.\n     pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() > 0);\n@@ -686,7 +693,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n }\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-    /// Check whether a node is an `Internal` node or a `Leaf` node.\n+    /// Checks whether a node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         NodeRef<BorrowType, K, V, marker::Leaf>,\n         NodeRef<BorrowType, K, V, marker::Internal>\n@@ -712,6 +719,11 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n /// A reference to a specific key/value pair or edge within a node. The `Node` parameter\n /// must be a `NodeRef`, while the `Type` can either be `KV` (signifying a handle on a key/value\n /// pair) or `Edge` (signifying a handle on an edge).\n+///\n+/// Note that even `Leaf` nodes can have `Edge` handles. Instead of representing a pointer to\n+/// a child node, these represent the spaces where child pointers would go between the key/value\n+/// pairs. For example, in a node with length 2, there would be 3 possible edge locations - one\n+/// to the left of the node, one between the two pairs, and one at the right of the node.\n pub struct Handle<Node, Type> {\n     node: Node,\n     idx: usize,\n@@ -728,14 +740,14 @@ impl<Node: Copy, Type> Clone for Handle<Node, Type> {\n }\n \n impl<Node, Type> Handle<Node, Type> {\n-    /// Retrieve the node that contains the edge of key/value pair this handle pointes to.\n+    /// Retrieves the node that contains the edge of key/value pair this handle pointes to.\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n-    /// Create a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n+    /// Creates a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n     pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n         debug_assert!(idx < node.len());\n@@ -767,7 +779,7 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n impl<BorrowType, K, V, NodeType, HandleType>\n         Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n \n-    /// Temporarily take out another, immutable handle on the same location.\n+    /// Temporarily takes out another, immutable handle on the same location.\n     pub fn reborrow(&self)\n             -> Handle<NodeRef<marker::Immut, K, V, NodeType>, HandleType> {\n \n@@ -783,7 +795,7 @@ impl<BorrowType, K, V, NodeType, HandleType>\n impl<'a, K, V, NodeType, HandleType>\n         Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n \n-    /// Temporarily take out another, mutable handle on the same location. Beware, as\n+    /// Temporarily takes out another, mutable handle on the same location. Beware, as\n     /// this method is very dangerous, doubly so since it may not immediately appear\n     /// dangerous.\n     ///\n@@ -808,7 +820,7 @@ impl<'a, K, V, NodeType, HandleType>\n impl<BorrowType, K, V, NodeType>\n         Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n \n-    /// Create a new handle to an edge in `node`. `idx` must be less than or equal to\n+    /// Creates a new handle to an edge in `node`. `idx` must be less than or equal to\n     /// `node.len()`.\n     pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         // Necessary for correctness, but in a private module\n@@ -843,8 +855,9 @@ impl<BorrowType, K, V, NodeType>\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n-    /// Insert a new key/value pair into the space defined by this edge, assuming that there\n-    /// is enough space in the node for the new pair to fit.\n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method assumes that there is enough space in the node for the new\n+    /// pair to fit.\n     ///\n     /// The returned pointer points to the inserted value.\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n@@ -861,8 +874,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n         }\n     }\n \n-    /// Insert a new key/value pair into the space defined by this edge, possibly splitting\n-    /// the node if there isn't enough room.\n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method splits the node if there isn't enough room.\n     ///\n     /// The returned pointer points to the inserted value.\n     pub fn insert(mut self, key: K, val: V)\n@@ -892,7 +905,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n-    /// Fix the parent pointer and index in the child node below this edge. This is useful\n+    /// Fixes the parent pointer and index in the child node below this edge. This is useful\n     /// when the ordering of edges has been changed, such as in the various `insert` methods.\n     fn correct_parent_link(mut self) {\n         let idx = self.idx as u16;\n@@ -902,17 +915,17 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         child.as_leaf_mut().parent_idx = idx;\n     }\n \n-    /// Unsafely assert to the compiler some static information about whether the underlying\n+    /// Unsafely asserts to the compiler some static information about whether the underlying\n     /// node of this handle is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n             -> Handle<NodeRef<marker::Mut, K, V, NewType>, marker::Edge> {\n \n         Handle::new_edge(self.node.cast_unchecked(), self.idx)\n     }\n \n-    /// Insert a new key/value pair into the space defined by this edge, as well as a new edge\n-    /// to go to the right of the new pair, assuming that there is enough space in the node for\n-    /// the new pair to fit.\n+    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n+    /// between this edge and the key/value pair to the right of this edge. This method assumes\n+    /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n         // Necessary for correctness, but in an internal module\n         debug_assert!(self.node.len() < CAPACITY);\n@@ -937,9 +950,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Insert a new key/value pair into the space defined by this edge, as well as a new edge\n-    /// to go to the right of the new pair, possibly splitting the node if there isn't enough\n-    /// room.\n+    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n+    /// between this edge and the key/value pair to the right of this edge. This method splits\n+    /// the node if there isn't enough room.\n     pub fn insert(mut self, key: K, val: V, edge: Root<K, V>)\n             -> InsertResult<'a, K, V, marker::Internal> {\n \n@@ -972,7 +985,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n impl<BorrowType, K, V>\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n \n-    /// Find the node pointed to by this edge.\n+    /// Finds the node pointed to by this edge.\n     ///\n     /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n     /// both, upon success, do nothing.\n@@ -1018,9 +1031,13 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n-    /// Split the underlying node into three parts. The node is truncated in place to what is\n-    /// to the left of this handle, and the key and value pointed at by this handle and the\n-    /// rest of the node to the right of this handle are returned separately.\n+    /// Splits the underlying node into three parts:\n+    ///\n+    /// - The node is truncated to only contain the key/value pairs to the right of\n+    ///   this handle.\n+    /// - The key and value pointed to by this handle and extracted.\n+    /// - All the key/value pairs to the right of this handle are put into a newly\n+    ///   allocated node.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n         unsafe {\n@@ -1056,8 +1073,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         }\n     }\n \n-    /// Remove the key/value pair pointed to by this handle, returning the edge representing\n-    /// the empty space left behind.\n+    /// Removes the key/value pair pointed to by this handle, returning the edge between the\n+    /// now adjacent key/value pairs to the left and right of this handle.\n     pub fn remove(mut self)\n             -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n         unsafe {\n@@ -1070,9 +1087,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n }\n \n impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n-    /// Split the underlying node into three parts. The node is truncated in place to what is\n-    /// to the left of this handle, and the key and value pointed at by this handle and the\n-    /// rest of the node to the right of this handle are returned separately.\n+    /// Splits the underlying node into three parts:\n+    ///\n+    /// - The node is truncated to only contain the edges and key/value pairs to the\n+    ///   right of this handle.\n+    /// - The key and value pointed to by this handle and extracted.\n+    /// - All the edges and key/value pairs to the right of this handle are put into\n+    ///   a newly allocated node.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n@@ -1120,7 +1141,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Return whether it is valid to call `.merge()`.\n+    /// Returns whether it is valid to call `.merge()`, i.e., whether there is enough room in\n+    /// a node to hold the combination of the nodes to the left and right of this handle along\n+    /// with the key/value pair at this handle.\n     pub fn can_merge(&self) -> bool {\n         (\n             self.reborrow()\n@@ -1135,9 +1158,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         ) <= CAPACITY\n     }\n \n-    /// Combine the node immediately to the left of this handle, the key/value pair pointed\n+    /// Combines the node immediately to the left of this handle, the key/value pair pointed\n     /// to by this handle, and the node immediately to the right of this handle into one new\n     /// child of the underlying node, returning an edge referencing that new child.\n+    ///\n+    /// Assumes that this edge `.can_merge()`.\n     pub fn merge(mut self)\n             -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n         let self1 = unsafe { ptr::read(&self) };"}]}