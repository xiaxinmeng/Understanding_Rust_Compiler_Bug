{"sha": "b13ae65b8b995bc851708380d80eae301c39f1c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxM2FlNjViOGI5OTViYzg1MTcwODM4MGQ4MGVhZTMwMWMzOWYxYzY=", "commit": {"author": {"name": "Aaron Loucks", "email": "aloucks@cofront.net", "date": "2019-05-27T16:47:47Z"}, "committer": {"name": "Aaron Loucks", "email": "aloucks@cofront.net", "date": "2019-05-27T16:47:47Z"}, "message": "Refactor DrainFilter::next and update comments", "tree": {"sha": "a8eae86fec1d545449b7ed58874412022df1fad1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8eae86fec1d545449b7ed58874412022df1fad1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b13ae65b8b995bc851708380d80eae301c39f1c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b13ae65b8b995bc851708380d80eae301c39f1c6", "html_url": "https://github.com/rust-lang/rust/commit/b13ae65b8b995bc851708380d80eae301c39f1c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b13ae65b8b995bc851708380d80eae301c39f1c6/comments", "author": {"login": "aloucks", "id": 221559, "node_id": "MDQ6VXNlcjIyMTU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/221559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aloucks", "html_url": "https://github.com/aloucks", "followers_url": "https://api.github.com/users/aloucks/followers", "following_url": "https://api.github.com/users/aloucks/following{/other_user}", "gists_url": "https://api.github.com/users/aloucks/gists{/gist_id}", "starred_url": "https://api.github.com/users/aloucks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aloucks/subscriptions", "organizations_url": "https://api.github.com/users/aloucks/orgs", "repos_url": "https://api.github.com/users/aloucks/repos", "events_url": "https://api.github.com/users/aloucks/events{/privacy}", "received_events_url": "https://api.github.com/users/aloucks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aloucks", "id": 221559, "node_id": "MDQ6VXNlcjIyMTU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/221559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aloucks", "html_url": "https://github.com/aloucks", "followers_url": "https://api.github.com/users/aloucks/followers", "following_url": "https://api.github.com/users/aloucks/following{/other_user}", "gists_url": "https://api.github.com/users/aloucks/gists{/gist_id}", "starred_url": "https://api.github.com/users/aloucks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aloucks/subscriptions", "organizations_url": "https://api.github.com/users/aloucks/orgs", "repos_url": "https://api.github.com/users/aloucks/repos", "events_url": "https://api.github.com/users/aloucks/events{/privacy}", "received_events_url": "https://api.github.com/users/aloucks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53d46ae96e2e8ac153680cb6711c9935d6dfe0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/53d46ae96e2e8ac153680cb6711c9935d6dfe0f6", "html_url": "https://github.com/rust-lang/rust/commit/53d46ae96e2e8ac153680cb6711c9935d6dfe0f6"}], "stats": {"total": 29, "additions": 13, "deletions": 16}, "files": [{"sha": "99116ac2d2f133358d40efbac4615db966d3b928", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b13ae65b8b995bc851708380d80eae301c39f1c6/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b13ae65b8b995bc851708380d80eae301c39f1c6/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=b13ae65b8b995bc851708380d80eae301c39f1c6", "patch": "@@ -2762,26 +2762,17 @@ impl<T, F> Iterator for DrainFilter<'_, T, F>\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n-        struct SetIdxOnDrop<'a> {\n-            idx: &'a mut usize,\n-            new_idx: usize,\n-        }\n-\n-        impl<'a> Drop for SetIdxOnDrop<'a> {\n-            fn drop(&mut self) {\n-                *self.idx = self.new_idx;\n-            }\n-        }\n-\n         unsafe {\n             while self.idx < self.old_len {\n                 let i = self.idx;\n                 let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n-                let mut set_idx = SetIdxOnDrop { new_idx: self.idx, idx: &mut self.idx };\n                 self.panic_flag = true;\n                 let drained = (self.pred)(&mut v[i]);\n                 self.panic_flag = false;\n-                set_idx.new_idx += 1;\n+                // Update the index *after* the predicate is called. If the index\n+                // is updated prior and the predicate panics, the element at this\n+                // index would be leaked.\n+                self.idx += 1;\n                 if drained {\n                     self.del += 1;\n                     return Some(ptr::read(&v[i]));\n@@ -2806,9 +2797,6 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        // If the predicate panics, we still need to backshift everything\n-        // down after the last successfully drained element, but no additional\n-        // elements are drained or checked.\n         struct BackshiftOnDrop<'a, 'b, T, F>\n             where\n                 F: FnMut(&mut T) -> bool,\n@@ -2822,6 +2810,12 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n         {\n             fn drop(&mut self) {\n                 unsafe {\n+                    // Backshift any unprocessed elements, preventing double-drop\n+                    // of any element that *should* have been previously overwritten\n+                    // but was not due to a panic in the filter predicate. This is\n+                    // implemented via drop so that it's guaranteed to run even in\n+                    // the event of a panic while consuming the remainder of the\n+                    // DrainFilter.\n                     while self.drain.idx < self.drain.old_len {\n                         let i = self.drain.idx;\n                         self.drain.idx += 1;\n@@ -2845,6 +2839,9 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n             drain: self\n         };\n \n+        // Attempt to consume any remaining elements if the filter predicate\n+        // has not yet panicked. We'll backshift any remaining elements\n+        // whether we've already panicked or if the consumption here panics.\n         if !backshift.drain.panic_flag {\n             backshift.drain.for_each(drop);\n         }"}]}