{"sha": "9d3f57ef0869805e0dde99cdce9548a587df7893", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkM2Y1N2VmMDg2OTgwNWUwZGRlOTljZGNlOTU0OGE1ODdkZjc4OTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-10-29T10:08:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-09T00:43:20Z"}, "message": "Introduce new variance inference pass that replaces (and generalizes) old\nregion-parameterization/variance inference. We now compute variance for\ntype parameters but do not make use of it (most of the way towards #3598).", "tree": {"sha": "bfe948f501aa97e706dcd9ea5aede11f66e0bf07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfe948f501aa97e706dcd9ea5aede11f66e0bf07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3f57ef0869805e0dde99cdce9548a587df7893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3f57ef0869805e0dde99cdce9548a587df7893", "html_url": "https://github.com/rust-lang/rust/commit/9d3f57ef0869805e0dde99cdce9548a587df7893", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3f57ef0869805e0dde99cdce9548a587df7893/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "html_url": "https://github.com/rust-lang/rust/commit/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a"}], "stats": {"total": 2085, "additions": 1278, "deletions": 807}, "files": [{"sha": "5e6d0f276152341c3f282e6583a3ac6649f86f4b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -89,7 +89,7 @@ pub static tag_path_elt_name: uint = 0x43u;\n pub static tag_item_field: uint = 0x44u;\n pub static tag_struct_mut: uint = 0x45u;\n \n-pub static tag_region_param: uint = 0x46u;\n+pub static tag_item_variances: uint = 0x46;\n pub static tag_mod_impl_trait: uint = 0x47u;\n /*\n   trait items contain tag_item_trait_method elements,"}, {"sha": "fdda6b38462e32228f9b9f9a5174720f2149c2f6", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -14,7 +14,6 @@\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n-use metadata;\n use middle::ty;\n use middle::typeck;\n \n@@ -144,6 +143,12 @@ pub fn get_trait_method_def_ids(cstore: @mut cstore::CStore,\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n+pub fn get_item_variances(cstore: @mut cstore::CStore,\n+                          def: ast::DefId) -> ty::ItemVariances {\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_item_variances(cdata, def.node)\n+}\n+\n pub fn get_provided_trait_methods(tcx: ty::ctxt,\n                                   def: ast::DefId)\n                                -> ~[@ty::Method] {"}, {"sha": "b63d9320bd6e0c816d2b799e44d3eafe157cad3d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -1088,6 +1088,14 @@ pub fn get_trait_method_def_ids(cdata: Cmd,\n     result\n }\n \n+pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n+    let data = cdata.data;\n+    let item_doc = lookup_item(id, data);\n+    let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n+    let mut decoder = reader::Decoder(variance_doc);\n+    Decodable::decode(&mut decoder)\n+}\n+\n pub fn get_provided_trait_methods(intr: @ident_interner, cdata: Cmd,\n                                   id: ast::NodeId, tcx: ty::ctxt) ->\n         ~[@ty::Method] {"}, {"sha": "9ce0b676e7e27a46bbfdbe625845a391f495480b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -211,6 +211,15 @@ fn encode_region_param_defs(ebml_w: &mut writer::Encoder,\n     }\n }\n \n+fn encode_item_variances(ebml_w: &mut writer::Encoder,\n+                         ecx: &EncodeContext,\n+                         id: ast::NodeId) {\n+    let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n+    ebml_w.start_tag(tag_item_variances);\n+    v.encode(ebml_w);\n+    ebml_w.end_tag();\n+}\n+\n fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n                           ecx: &EncodeContext,\n                           tpt: &ty::ty_param_bounds_and_ty) {\n@@ -992,6 +1001,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 't');\n+        encode_item_variances(ebml_w, ecx, item.id);\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -1032,6 +1042,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(ebml_w, 'S');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n \n+        encode_item_variances(ebml_w, ecx, item.id);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -1138,6 +1149,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'I');\n+        encode_item_variances(ebml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_ty_type_param_defs(ebml_w, ecx,\n                                   trait_def.generics.type_param_defs,"}, {"sha": "80103aa410688d73a163882ee712a0de1737ffdb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 485, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -22,22 +22,14 @@ Most of the documentation on regions can be found in\n \n \n use driver::session::Session;\n-use metadata::csearch;\n-use middle::resolve;\n-use middle::ty::{region_variance, rv_covariant, rv_invariant};\n-use middle::ty::{rv_contravariant, FreeRegion};\n+use middle::ty::{FreeRegion};\n use middle::ty;\n \n use std::hashmap::{HashMap, HashSet};\n-use syntax::ast_map;\n use syntax::codemap::Span;\n-use syntax::print::pprust;\n-use syntax::parse::token;\n-use syntax::parse::token::special_idents;\n use syntax::{ast, visit};\n use syntax::visit::{Visitor,fn_kind};\n use syntax::ast::{Block,item,fn_decl,NodeId,Arm,Pat,Stmt,Expr,Local};\n-use syntax::ast::{Ty,TypeMethod,struct_field};\n \n /**\n The region maps encode information about region relationships.\n@@ -74,7 +66,6 @@ pub struct Context {\n \n struct RegionResolutionVisitor {\n     sess: Session,\n-    def_map: resolve::DefMap,\n \n     // Generated maps:\n     region_maps: @mut RegionMaps,\n@@ -504,7 +495,6 @@ impl Visitor<Context> for RegionResolutionVisitor {\n }\n \n pub fn resolve_crate(sess: Session,\n-                     def_map: resolve::DefMap,\n                      crate: &ast::Crate) -> @mut RegionMaps\n {\n     let region_maps = @mut RegionMaps {\n@@ -516,483 +506,9 @@ pub fn resolve_crate(sess: Session,\n                       var_parent: None};\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n-        def_map: def_map,\n         region_maps: region_maps,\n     };\n     visit::walk_crate(&mut visitor, crate, cx);\n     return region_maps;\n }\n \n-// ___________________________________________________________________________\n-// Determining region parameterization\n-//\n-// Infers which type defns must be region parameterized---this is done\n-// by scanning their contents to see whether they reference a region\n-// type, directly or indirectly.  This is a fixed-point computation.\n-//\n-// We do it in two passes.  First we walk the AST and construct a map\n-// from each type defn T1 to other defns which make use of it.  For example,\n-// if we have a type like:\n-//\n-//    type S = *int;\n-//    type T = S;\n-//\n-// Then there would be a map entry from S to T.  During the same walk,\n-// we also construct add any types that reference regions to a set and\n-// a worklist.  We can then process the worklist, propagating indirect\n-// dependencies until a fixed point is reached.\n-\n-pub type region_paramd_items = @mut HashMap<ast::NodeId, region_variance>;\n-\n-#[deriving(Eq)]\n-pub struct region_dep {\n-    ambient_variance: region_variance,\n-    id: ast::NodeId\n-}\n-\n-pub struct DetermineRpCtxt {\n-    sess: Session,\n-    ast_map: ast_map::map,\n-    def_map: resolve::DefMap,\n-    region_paramd_items: region_paramd_items,\n-    dep_map: @mut HashMap<ast::NodeId, @mut ~[region_dep]>,\n-    worklist: ~[ast::NodeId],\n-\n-    // the innermost enclosing item id\n-    item_id: ast::NodeId,\n-\n-    // true when we are within an item but not within a method.\n-    // see long discussion on region_is_relevant().\n-    anon_implies_rp: bool,\n-\n-    // encodes the context of the current type; invariant if\n-    // mutable, covariant otherwise\n-    ambient_variance: region_variance,\n-}\n-\n-pub fn join_variance(variance1: region_variance,\n-                     variance2: region_variance)\n-                  -> region_variance {\n-    match (variance1, variance2) {\n-      (rv_invariant, _) => {rv_invariant}\n-      (_, rv_invariant) => {rv_invariant}\n-      (rv_covariant, rv_contravariant) => {rv_invariant}\n-      (rv_contravariant, rv_covariant) => {rv_invariant}\n-      (rv_covariant, rv_covariant) => {rv_covariant}\n-      (rv_contravariant, rv_contravariant) => {rv_contravariant}\n-    }\n-}\n-\n-/// Combines the ambient variance with the variance of a\n-/// particular site to yield the final variance of the reference.\n-///\n-/// Example: if we are checking function arguments then the ambient\n-/// variance is contravariant.  If we then find a `&'r T` pointer, `r`\n-/// appears in a co-variant position.  This implies that this\n-/// occurrence of `r` is contra-variant with respect to the current\n-/// item, and hence the function returns `rv_contravariant`.\n-pub fn add_variance(ambient_variance: region_variance,\n-                    variance: region_variance)\n-                 -> region_variance {\n-    match (ambient_variance, variance) {\n-      (rv_invariant, _) => rv_invariant,\n-      (_, rv_invariant) => rv_invariant,\n-      (rv_covariant, c) => c,\n-      (c, rv_covariant) => c,\n-      (rv_contravariant, rv_contravariant) => rv_covariant\n-    }\n-}\n-\n-impl DetermineRpCtxt {\n-    pub fn add_variance(&self, variance: region_variance) -> region_variance {\n-        add_variance(self.ambient_variance, variance)\n-    }\n-\n-    /// Records that item `id` is region-parameterized with the\n-    /// variance `variance`.  If `id` was already parameterized, then\n-    /// the new variance is joined with the old variance.\n-    pub fn add_rp(&mut self, id: ast::NodeId, variance: region_variance) {\n-        assert!(id != 0);\n-        let old_variance = self.region_paramd_items.find(&id).map(|x| *x);\n-        let joined_variance = match old_variance {\n-          None => variance,\n-          Some(v) => join_variance(v, variance)\n-        };\n-\n-        debug!(\"add_rp() variance for {}: {:?} == {:?} ^ {:?}\",\n-               ast_map::node_id_to_str(self.ast_map, id,\n-                                       token::get_ident_interner()),\n-               joined_variance, old_variance, variance);\n-\n-        if Some(joined_variance) != old_variance {\n-            let region_paramd_items = self.region_paramd_items;\n-            region_paramd_items.insert(id, joined_variance);\n-            self.worklist.push(id);\n-        }\n-    }\n-\n-    /// Indicates that the region-parameterization of the current item\n-    /// is dependent on the region-parameterization of the item\n-    /// `from`.  Put another way, it indicates that the current item\n-    /// contains a value of type `from`, so if `from` is\n-    /// region-parameterized, so is the current item.\n-    pub fn add_dep(&mut self, from: ast::NodeId) {\n-        debug!(\"add dependency from {} -> {} ({} -> {}) with variance {:?}\",\n-               from, self.item_id,\n-               ast_map::node_id_to_str(self.ast_map, from,\n-                                       token::get_ident_interner()),\n-               ast_map::node_id_to_str(self.ast_map, self.item_id,\n-                                       token::get_ident_interner()),\n-               self.ambient_variance);\n-        let vec = do self.dep_map.find_or_insert_with(from) |_| {\n-            @mut ~[]\n-        };\n-        let dep = region_dep {\n-            ambient_variance: self.ambient_variance,\n-            id: self.item_id\n-        };\n-        if !vec.iter().any(|x| x == &dep) { vec.push(dep); }\n-    }\n-\n-    // Determines whether a reference to a region that appears in the\n-    // AST implies that the enclosing type is region-parameterized (RP).\n-    // This point is subtle.  Here are some examples to make it more\n-    // concrete.\n-    //\n-    // 1. impl foo for &int { ... }\n-    // 2. impl foo for &'self int { ... }\n-    // 3. impl foo for bar { fn m(@self) -> &'self int { ... } }\n-    // 4. impl foo for bar { fn m(&self) -> &'self int { ... } }\n-    // 5. impl foo for bar { fn m(&self) -> &int { ... } }\n-    //\n-    // In case 1, the anonymous region is being referenced,\n-    // but it appears in a context where the anonymous region\n-    // resolves to self, so the impl foo is RP.\n-    //\n-    // In case 2, the self parameter is written explicitly.\n-    //\n-    // In case 3, the method refers to the region `self`, so that\n-    // implies that the impl must be region parameterized.  (If the\n-    // type bar is not region parameterized, that is an error, because\n-    // the self region is effectively unconstrained, but that is\n-    // detected elsewhere).\n-    //\n-    // In case 4, the method refers to the region `self`, but the\n-    // `self` region is bound by the `&self` receiver, and so this\n-    // does not require that `bar` be RP.\n-    //\n-    // In case 5, the anonymous region is referenced, but it\n-    // bound by the method, so it does not refer to self.  This impl\n-    // need not be region parameterized.\n-    //\n-    // Normally, & or &self implies that the enclosing item is RP.\n-    // However, within a function, & is always bound.  Within a method\n-    // with &self type, &self is also bound.  We detect those last two\n-    // cases via flags (anon_implies_rp and self_implies_rp) that are\n-    // true when the anon or self region implies RP.\n-    pub fn region_is_relevant(&self, r: &Option<ast::Lifetime>) -> bool {\n-        match r {\n-            &None => {\n-                self.anon_implies_rp\n-            }\n-            &Some(ref l) if l.ident == special_idents::statik => {\n-                false\n-            }\n-            &Some(ref l) if l.ident == special_idents::self_ => {\n-                true\n-            }\n-            &Some(_) => {\n-                false\n-            }\n-        }\n-    }\n-\n-    pub fn with(@mut self,\n-                item_id: ast::NodeId,\n-                anon_implies_rp: bool,\n-                f: &fn()) {\n-        let old_item_id = self.item_id;\n-        let old_anon_implies_rp = self.anon_implies_rp;\n-        self.item_id = item_id;\n-        self.anon_implies_rp = anon_implies_rp;\n-        debug!(\"with_item_id({}, {})\",\n-               item_id,\n-               anon_implies_rp);\n-        let _i = ::util::common::indenter();\n-        f();\n-        self.item_id = old_item_id;\n-        self.anon_implies_rp = old_anon_implies_rp;\n-    }\n-\n-    pub fn with_ambient_variance(@mut self,\n-                                 variance: region_variance,\n-                                 f: &fn()) {\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.add_variance(variance);\n-        f();\n-        self.ambient_variance = old_ambient_variance;\n-    }\n-}\n-\n-fn determine_rp_in_item(visitor: &mut DetermineRpVisitor,\n-                        item: @ast::item) {\n-    do visitor.cx.with(item.id, true) {\n-        visit::walk_item(visitor, item, ());\n-    }\n-}\n-\n-fn determine_rp_in_fn(visitor: &mut DetermineRpVisitor,\n-                      fk: &visit::fn_kind,\n-                      decl: &ast::fn_decl,\n-                      body: &ast::Block,\n-                      _: Span,\n-                      _: ast::NodeId) {\n-    let cx = visitor.cx;\n-    do cx.with(cx.item_id, false) {\n-        do cx.with_ambient_variance(rv_contravariant) {\n-            for a in decl.inputs.iter() {\n-                visitor.visit_ty(&a.ty, ());\n-            }\n-        }\n-        visitor.visit_ty(&decl.output, ());\n-        let generics = visit::generics_of_fn(fk);\n-        visitor.visit_generics(&generics, ());\n-        visitor.visit_block(body, ());\n-    }\n-}\n-\n-fn determine_rp_in_ty_method(visitor: &mut DetermineRpVisitor,\n-                             ty_m: &ast::TypeMethod) {\n-    let cx = visitor.cx;\n-    do cx.with(cx.item_id, false) {\n-        visit::walk_ty_method(visitor, ty_m, ());\n-    }\n-}\n-\n-fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n-                      ty: &ast::Ty) {\n-    let cx = visitor.cx;\n-\n-    // we are only interested in types that will require an item to\n-    // be region-parameterized.  if cx.item_id is zero, then this type\n-    // is not a member of a type defn nor is it a constitutent of an\n-    // impl etc.  So we can ignore it and its components.\n-    if cx.item_id == 0 { return; }\n-\n-    // if this type directly references a region pointer like &'r ty,\n-    // add to the worklist/set.  Note that &'r ty is contravariant with\n-    // respect to &r, because &'r ty can be used whereever a *smaller*\n-    // region is expected (and hence is a supertype of those\n-    // locations)\n-    let sess = cx.sess;\n-    match ty.node {\n-        ast::ty_rptr(ref r, _) => {\n-            debug!(\"referenced rptr type {}\",\n-                   pprust::ty_to_str(ty, sess.intr()));\n-\n-            if cx.region_is_relevant(r) {\n-                let rv = cx.add_variance(rv_contravariant);\n-                cx.add_rp(cx.item_id, rv)\n-            }\n-        }\n-\n-        ast::ty_closure(ref f) => {\n-            debug!(\"referenced fn type: {}\",\n-                   pprust::ty_to_str(ty, sess.intr()));\n-            match f.region {\n-                Some(_) => {\n-                    if cx.region_is_relevant(&f.region) {\n-                        let rv = cx.add_variance(rv_contravariant);\n-                        cx.add_rp(cx.item_id, rv)\n-                    }\n-                }\n-                None => {\n-                    if f.sigil == ast::BorrowedSigil && cx.anon_implies_rp {\n-                        let rv = cx.add_variance(rv_contravariant);\n-                        cx.add_rp(cx.item_id, rv)\n-                    }\n-                }\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    // if this references another named type, add the dependency\n-    // to the dep_map.  If the type is not defined in this crate,\n-    // then check whether it is region-parameterized and consider\n-    // that as a direct dependency.\n-    match ty.node {\n-      ast::ty_path(ref path, _, id) => {\n-        match cx.def_map.find(&id) {\n-          Some(&ast::DefTy(did)) |\n-          Some(&ast::DefTrait(did)) |\n-          Some(&ast::DefStruct(did)) => {\n-            if did.crate == ast::LOCAL_CRATE {\n-                if cx.region_is_relevant(&path.segments.last().lifetime) {\n-                    cx.add_dep(did.node);\n-                }\n-            } else {\n-                let cstore = sess.cstore;\n-                match csearch::get_region_param(cstore, did) {\n-                  None => {}\n-                  Some(variance) => {\n-                    debug!(\"reference to external, rp'd type {}\",\n-                           pprust::ty_to_str(ty, sess.intr()));\n-                    if cx.region_is_relevant(&path.segments.last().lifetime) {\n-                        let rv = cx.add_variance(variance);\n-                        cx.add_rp(cx.item_id, rv)\n-                    }\n-                  }\n-                }\n-            }\n-          }\n-          _ => {}\n-        }\n-      }\n-      _ => {}\n-    }\n-\n-    match ty.node {\n-      ast::ty_box(ref mt) | ast::ty_uniq(ref mt) | ast::ty_vec(ref mt) |\n-      ast::ty_rptr(_, ref mt) | ast::ty_ptr(ref mt) => {\n-        visit_mt(visitor, mt);\n-      }\n-\n-      ast::ty_path(ref path, _, _) => {\n-        // type parameters are---for now, anyway---always invariant\n-        do cx.with_ambient_variance(rv_invariant) {\n-            for tp in path.segments.iter().flat_map(|s| s.types.iter()) {\n-                visitor.visit_ty(tp, ());\n-            }\n-        }\n-      }\n-\n-      ast::ty_closure(@ast::TyClosure {decl: ref decl, _}) |\n-      ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n-        // fn() binds the & region, so do not consider &T types that\n-        // appear *inside* a fn() type to affect the enclosing item:\n-        do cx.with(cx.item_id, false) {\n-            // parameters are contravariant\n-            do cx.with_ambient_variance(rv_contravariant) {\n-                for a in decl.inputs.iter() {\n-                    visitor.visit_ty(&a.ty, ());\n-                }\n-            }\n-            visitor.visit_ty(&decl.output, ());\n-        }\n-      }\n-\n-      _ => {\n-        visit::walk_ty(visitor, ty, ());\n-      }\n-    }\n-\n-    fn visit_mt(visitor: &mut DetermineRpVisitor,\n-                mt: &ast::mt) {\n-        let cx = visitor.cx;\n-        // mutability is invariant\n-        if mt.mutbl == ast::MutMutable {\n-            do cx.with_ambient_variance(rv_invariant) {\n-                visitor.visit_ty(mt.ty, ());\n-            }\n-        } else {\n-            visitor.visit_ty(mt.ty, ());\n-        }\n-    }\n-}\n-\n-fn determine_rp_in_struct_field(visitor: &mut DetermineRpVisitor,\n-                                cm: @ast::struct_field) {\n-    visit::walk_struct_field(visitor, cm, ());\n-}\n-\n-struct DetermineRpVisitor {\n-    cx: @mut DetermineRpCtxt\n-}\n-\n-impl Visitor<()> for DetermineRpVisitor {\n-\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n-                b:&Block, s:Span, n:NodeId, _:()) {\n-        determine_rp_in_fn(self, fk, fd, b, s, n);\n-    }\n-    fn visit_item(&mut self, i:@item, _:()) {\n-        determine_rp_in_item(self, i);\n-    }\n-    fn visit_ty(&mut self, t:&Ty, _:()) {\n-        determine_rp_in_ty(self, t);\n-    }\n-    fn visit_ty_method(&mut self, t:&TypeMethod, _:()) {\n-        determine_rp_in_ty_method(self, t);\n-    }\n-    fn visit_struct_field(&mut self, s:@struct_field, _:()) {\n-        determine_rp_in_struct_field(self, s);\n-    }\n-\n-}\n-\n-pub fn determine_rp_in_crate(sess: Session,\n-                             ast_map: ast_map::map,\n-                             def_map: resolve::DefMap,\n-                             crate: &ast::Crate)\n-                          -> region_paramd_items {\n-    let cx = @mut DetermineRpCtxt {\n-        sess: sess,\n-        ast_map: ast_map,\n-        def_map: def_map,\n-        region_paramd_items: @mut HashMap::new(),\n-        dep_map: @mut HashMap::new(),\n-        worklist: ~[],\n-        item_id: 0,\n-        anon_implies_rp: false,\n-        ambient_variance: rv_covariant\n-    };\n-\n-    // Gather up the base set, worklist and dep_map\n-    let mut visitor = DetermineRpVisitor { cx: cx };\n-    visit::walk_crate(&mut visitor, crate, ());\n-\n-    // Propagate indirect dependencies\n-    //\n-    // Each entry in the worklist is the id of an item C whose region\n-    // parameterization has been updated.  So we pull ids off of the\n-    // worklist, find the current variance, and then iterate through\n-    // all of the dependent items (that is, those items that reference\n-    // C).  For each dependent item D, we combine the variance of C\n-    // with the ambient variance where the reference occurred and then\n-    // update the region-parameterization of D to reflect the result.\n-    {\n-        let cx = &mut *cx;\n-        while cx.worklist.len() != 0 {\n-            let c_id = cx.worklist.pop();\n-            let c_variance = cx.region_paramd_items.get_copy(&c_id);\n-            debug!(\"popped {} from worklist\", c_id);\n-            match cx.dep_map.find(&c_id) {\n-              None => {}\n-              Some(deps) => {\n-                for dep in deps.iter() {\n-                    let v = add_variance(dep.ambient_variance, c_variance);\n-                    cx.add_rp(dep.id, v);\n-                }\n-              }\n-            }\n-        }\n-    }\n-\n-    debug!(\"{}\", {\n-        debug!(\"Region variance results:\");\n-        let region_paramd_items = cx.region_paramd_items;\n-        for (&key, &value) in region_paramd_items.iter() {\n-            debug!(\"item {:?} ({}) is parameterized with variance {:?}\",\n-                   key,\n-                   ast_map::node_id_to_str(ast_map, key,\n-                                           token::get_ident_interner()),\n-                   value);\n-        }\n-        \"----\"\n-    });\n-\n-    // return final set\n-    return cx.region_paramd_items;\n-}"}, {"sha": "a29591705844e81d749166527a33ba47ca845e34", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -209,13 +209,19 @@ pub enum ast_ty_to_ty_cache_entry {\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n-pub type opt_region_variance = Option<region_variance>;\n+#[deriving(Clone, Eq, Decodable, Encodable)]\n+pub struct ItemVariances {\n+    self_param: Option<Variance>,\n+    type_params: OptVec<Variance>,\n+    region_params: OptVec<Variance>\n+}\n \n #[deriving(Clone, Eq, Decodable, Encodable)]\n-pub enum region_variance {\n-    rv_covariant,\n-    rv_invariant,\n-    rv_contravariant,\n+pub enum Variance {\n+    Covariant,\n+    Invariant,\n+    Contravariant,\n+    Bivariant,\n }\n \n #[deriving(Decodable, Encodable)]\n@@ -264,7 +270,6 @@ struct ctxt_ {\n     named_region_map: @mut resolve_lifetime::NamedRegionMap,\n \n     region_maps: @mut middle::region::RegionMaps,\n-    region_paramd_items: middle::region::region_paramd_items,\n \n     // Stores the types for various nodes in the AST.  Note that this table\n     // is not guaranteed to be populated until after typeck.  See\n@@ -309,6 +314,10 @@ struct ctxt_ {\n     provided_method_sources: @mut HashMap<ast::DefId, ast::DefId>,\n     supertraits: @mut HashMap<ast::DefId, @~[@TraitRef]>,\n \n+    // Maps from def-id of a type or region parameter to its\n+    // (inferred) variance.\n+    item_variance_map: @mut HashMap<ast::DefId, @ItemVariances>,\n+\n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n     // present in this map, it does not have a destructor. This map is\n@@ -954,19 +963,18 @@ pub fn mk_ctxt(s: session::Session,\n                amap: ast_map::map,\n                freevars: freevars::freevar_map,\n                region_maps: @mut middle::region::RegionMaps,\n-               region_paramd_items: middle::region::region_paramd_items,\n                lang_items: middle::lang_items::LanguageItems)\n             -> ctxt {\n     @ctxt_ {\n         named_region_map: named_region_map,\n+        item_variance_map: @mut HashMap::new(),\n         diag: s.diagnostic(),\n         interner: @mut HashMap::new(),\n         next_id: @mut primitives::LAST_PRIMITIVE_ID,\n         cstore: s.cstore,\n         sess: s,\n         def_map: dm,\n         region_maps: region_maps,\n-        region_paramd_items: region_paramd_items,\n         node_types: @mut HashMap::new(),\n         node_type_substs: @mut HashMap::new(),\n         trait_refs: @mut HashMap::new(),\n@@ -4410,6 +4418,12 @@ pub fn visitor_object_ty(tcx: ctxt,\n                  EmptyBuiltinBounds())))\n }\n \n+pub fn item_variances(tcx: ctxt, item_id: ast::DefId) -> @ItemVariances {\n+    lookup_locally_or_in_crate_store(\n+        \"item_variance_map\", item_id, tcx.item_variance_map,\n+        || @csearch::get_item_variances(tcx.cstore, item_id))\n+}\n+\n /// Records a trait-to-implementation mapping.\n fn record_trait_implementation(tcx: ctxt,\n                                trait_def_id: DefId,\n@@ -4692,6 +4706,17 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n     hash.result_u64()\n }\n \n+impl Variance {\n+    pub fn to_str(self) -> &'static str {\n+        match self {\n+            Covariant => \"+\",\n+            Contravariant => \"-\",\n+            Invariant => \"o\",\n+            Bivariant => \"*\",\n+        }\n+    }\n+}\n+\n pub fn construct_parameter_environment(\n     tcx: ctxt,\n     self_bound: Option<@TraitRef>,"}, {"sha": "c42f74864d249d1ac63be19baed74b387f9eb509", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 78, "deletions": 95, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -123,76 +123,70 @@ pub trait Combine {\n         }\n     }\n \n-    fn substs(&self, generics: &ty::Generics, as_: &ty::substs,\n+    fn substs(&self,\n+              item_def_id: ast::DefId,\n+              as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n \n-        fn relate_region_params<C:Combine>(\n-                                           this: &C,\n-                                           generics: &ty::Generics,\n+        fn relate_region_params<C:Combine>(this: &C,\n+                                           item_def_id: ast::DefId,\n                                            a: &ty::RegionSubsts,\n                                            b: &ty::RegionSubsts)\n-            -> cres<ty::RegionSubsts>\n-            {\n+                                           -> cres<ty::RegionSubsts> {\n+            let tcx = this.infcx().tcx;\n             match (a, b) {\n-                (&ty::ErasedRegions, _) |\n-                    (_, &ty::ErasedRegions) => {\n+                (&ty::ErasedRegions, _) | (_, &ty::ErasedRegions) => {\n                     Ok(ty::ErasedRegions)\n                 }\n \n                 (&ty::NonerasedRegions(ref a_rs),\n                  &ty::NonerasedRegions(ref b_rs)) => {\n-                    match generics.region_param {\n-                        None => {\n-                            assert!(a_rs.is_empty());\n-                            assert!(b_rs.is_empty());\n-                            Ok(ty::NonerasedRegions(opt_vec::Empty))\n-                        }\n-\n-                        Some(variance) => {\n-                            assert_eq!(a_rs.len(), 1);\n-                            assert_eq!(b_rs.len(), 1);\n-                            let a_r = *a_rs.get(0);\n-                            let b_r = *b_rs.get(0);\n-\n-                            match variance {\n-                                ty::rv_invariant => {\n-                                    do eq_regions(this, a_r, b_r).then {\n-                                        Ok(ty::NonerasedRegions(opt_vec::with(a_r)))\n-                                    }\n-                                }\n-\n-                                ty::rv_covariant => {\n-                                    do this.regions(a_r, b_r).and_then |r| {\n-                                        Ok(ty::NonerasedRegions(opt_vec::with(r)))\n-                                    }\n-                                }\n-\n-                                ty::rv_contravariant => {\n-                                    do this.contraregions(a_r, b_r).and_then |r| {\n-                                        Ok(ty::NonerasedRegions(opt_vec::with(r)))\n-                                    }\n-                                }\n+                    let variances = ty::item_variances(tcx, item_def_id);\n+                    let region_params = &variances.region_params;\n+                    let num_region_params = region_params.len();\n+\n+                    debug!(\"relate_region_params(\\\n+                            item_def_id={}, \\\n+                            a_rs={}, \\\n+                            b_rs={},\n+                            region_params={})\",\n+                            item_def_id.repr(tcx),\n+                            a_rs.repr(tcx),\n+                            b_rs.repr(tcx),\n+                            region_params.repr(tcx));\n+\n+                    assert_eq!(num_region_params, a_rs.len());\n+                    assert_eq!(num_region_params, b_rs.len());\n+                    let mut rs = opt_vec::Empty;\n+                    for i in range(0, num_region_params) {\n+                        let a_r = *a_rs.get(i);\n+                        let b_r = *b_rs.get(i);\n+                        let variance = *region_params.get(i);\n+                        let r = match variance {\n+                            ty::Invariant => {\n+                                eq_regions(this, a_r, b_r)\n+                                    .and_then(|()| Ok(a_r))\n                             }\n-                        }\n+                            ty::Covariant => this.regions(a_r, b_r),\n+                            ty::Contravariant => this.contraregions(a_r, b_r),\n+                            ty::Bivariant => Ok(a_r),\n+                        };\n+                        rs.push(if_ok!(r));\n                     }\n+                    Ok(ty::NonerasedRegions(rs))\n                 }\n             }\n         }\n \n-        do self.tps(as_.tps, bs.tps).and_then |tps| {\n-            do self.self_tys(as_.self_ty, bs.self_ty).and_then |self_ty| {\n-                do relate_region_params(self,\n-                                        generics,\n-                                        &as_.regions,\n-                                        &bs.regions).and_then |regions| {\n-                    Ok(substs {\n-                            regions: regions,\n-                            self_ty: self_ty,\n-                            tps: tps.clone()\n-                        })\n-                }\n-            }\n-        }\n+        let tps = if_ok!(self.tps(as_.tps, bs.tps));\n+        let self_ty = if_ok!(self.self_tys(as_.self_ty, bs.self_ty));\n+        let regions = if_ok!(relate_region_params(self,\n+                                                  item_def_id,\n+                                                  &as_.regions,\n+                                                  &bs.regions));\n+        Ok(substs { regions: regions,\n+                    self_ty: self_ty,\n+                    tps: tps.clone() })\n     }\n \n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n@@ -267,9 +261,11 @@ pub trait Combine {\n                   -> cres<ty::Region>;\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n \n-    fn vstores(&self, vk: ty::terr_vstore_kind,\n-               a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-\n+    fn vstores(&self,\n+               vk: ty::terr_vstore_kind,\n+               a: ty::vstore,\n+               b: ty::vstore)\n+               -> cres<ty::vstore> {\n         debug!(\"{}.vstores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n@@ -293,8 +289,7 @@ pub trait Combine {\n                     vk: ty::terr_vstore_kind,\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n-                 -> cres<ty::TraitStore> {\n-\n+                    -> cres<ty::TraitStore> {\n         debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n \n         match (a, b) {\n@@ -317,7 +312,8 @@ pub trait Combine {\n \n     fn trait_refs(&self,\n                   a: &ty::TraitRef,\n-                  b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+                  b: &ty::TraitRef)\n+                  -> cres<ty::TraitRef> {\n         // Different traits cannot be related\n \n         // - NOTE in the future, expand out subtraits!\n@@ -326,15 +322,9 @@ pub trait Combine {\n             Err(ty::terr_traits(\n                                 expected_found(self, a.def_id, b.def_id)))\n         } else {\n-            let tcx = self.infcx().tcx;\n-            let trait_def = ty::lookup_trait_def(tcx, a.def_id);\n-            let substs = if_ok!(self.substs(&trait_def.generics,\n-                                            &a.substs,\n-                                            &b.substs));\n-            Ok(ty::TraitRef {\n-                    def_id: a.def_id,\n-                    substs: substs\n-                })\n+            let substs = if_ok!(self.substs(a.def_id, &a.substs, &b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id,\n+                              substs: substs })\n         }\n     }\n }\n@@ -366,8 +356,8 @@ pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n                           -> ures {\n     debug!(\"eq_regions({}, {})\",\n-           a.inf_str(this.infcx()),\n-           b.inf_str(this.infcx()));\n+            a.repr(this.infcx().tcx),\n+            b.repr(this.infcx().tcx));\n     let sub = this.sub();\n     do indent {\n         this.infcx().try(|| {\n@@ -511,36 +501,30 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       (&ty::ty_enum(a_id, ref a_substs),\n        &ty::ty_enum(b_id, ref b_substs))\n       if a_id == b_id => {\n-          let type_def = ty::lookup_item_type(tcx, a_id);\n-          do this.substs(&type_def.generics, a_substs, b_substs).and_then |substs| {\n-              Ok(ty::mk_enum(tcx, a_id, substs))\n-          }\n+          let substs = if_ok!(this.substs(a_id,\n+                                          a_substs,\n+                                          b_substs));\n+          Ok(ty::mk_enum(tcx, a_id, substs))\n       }\n \n       (&ty::ty_trait(a_id, ref a_substs, a_store, a_mutbl, a_bounds),\n        &ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl, b_bounds))\n       if a_id == b_id && a_mutbl == b_mutbl => {\n-          let trait_def = ty::lookup_trait_def(tcx, a_id);\n-          do this.substs(&trait_def.generics, a_substs, b_substs).and_then |substs| {\n-              do this.trait_stores(ty::terr_trait, a_store, b_store).and_then |s| {\n-                  do this.bounds(a_bounds, b_bounds).and_then |bounds| {\n-                    Ok(ty::mk_trait(tcx,\n-                                    a_id,\n-                                    substs.clone(),\n-                                    s,\n-                                    a_mutbl,\n-                                    bounds))\n-                  }\n-              }\n-          }\n+          let substs = if_ok!(this.substs(a_id, a_substs, b_substs));\n+          let s = if_ok!(this.trait_stores(ty::terr_trait, a_store, b_store));\n+          let bounds = if_ok!(this.bounds(a_bounds, b_bounds));\n+          Ok(ty::mk_trait(tcx,\n+                          a_id,\n+                          substs.clone(),\n+                          s,\n+                          a_mutbl,\n+                          bounds))\n       }\n \n       (&ty::ty_struct(a_id, ref a_substs), &ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n-          let type_def = ty::lookup_item_type(tcx, a_id);\n-          do this.substs(&type_def.generics, a_substs, b_substs).and_then |substs| {\n-              Ok(ty::mk_struct(tcx, a_id, substs))\n-          }\n+            let substs = if_ok!(this.substs(a_id, a_substs, b_substs));\n+            Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n       (&ty::ty_box(ref a_mt), &ty::ty_box(ref b_mt)) => {\n@@ -576,9 +560,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_estr(vs_a), &ty::ty_estr(vs_b)) => {\n-        do this.vstores(ty::terr_str, vs_a, vs_b).and_then |vs| {\n-            Ok(ty::mk_estr(tcx,vs))\n-        }\n+        let vs = if_ok!(this.vstores(ty::terr_str, vs_a, vs_b));\n+        Ok(ty::mk_estr(tcx,vs))\n       }\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {"}, {"sha": "ed6c810e52cd674d1162e8aad899a119d68b3686", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -19,16 +19,23 @@ The type checker is responsible for:\n 3. Guaranteeing that most type rules are met (\"most?\", you say, \"why most?\"\n    Well, dear reader, read on)\n \n-The main entry point is `check_crate()`.  Type checking operates in two major\n-phases: collect and check.  The collect phase passes over all items and\n-determines their type, without examining their \"innards\".  The check phase\n-then checks function bodies and so forth.\n+The main entry point is `check_crate()`.  Type checking operates in\n+several major phases:\n \n-Within the check phase, we check each function body one at a time (bodies of\n-function expressions are checked as part of the containing function).\n-Inference is used to supply types wherever they are unknown. The actual\n-checking of a function itself has several phases (check, regionck, writeback),\n-as discussed in the documentation for the `check` module.\n+1. The collect phase first passes over all items and determines their\n+   type, without examining their \"innards\".\n+\n+2. Variance inference then runs to compute the variance of each parameter\n+\n+3. Coherence checks for overlapping or orphaned impls\n+\n+4. Finally, the check phase then checks function bodies and so forth.\n+   Within the check phase, we check each function body one at a time\n+   (bodies of function expressions are checked as part of the\n+   containing function).  Inference is used to supply types wherever\n+   they are unknown. The actual checking of a function itself has\n+   several phases (check, regionck, writeback), as discussed in the\n+   documentation for the `check` module.\n \n The type checker is defined into various submodules which are documented\n independently:\n@@ -39,6 +46,10 @@ independently:\n - collect: computes the types of each top-level item and enters them into\n   the `cx.tcache` table for later use\n \n+- coherence: enforces coherence rules, builds some tables\n+\n+- variance: variance inference\n+\n - check: walks over function bodies and type checks them, inferring types for\n   local variables, type parameters, etc as necessary.\n \n@@ -71,6 +82,7 @@ pub mod astconv;\n pub mod infer;\n pub mod collect;\n pub mod coherence;\n+pub mod variance;\n \n #[deriving(Clone, Encodable, Decodable, Eq, Ord)]\n pub enum param_index {\n@@ -455,6 +467,9 @@ pub fn check_crate(tcx: ty::ctxt,\n     // have valid types and not error\n     tcx.sess.abort_if_errors();\n \n+    time(time_passes, \"variance inference\", (), |_|\n+         variance::infer_variance(tcx, crate));\n+\n     time(time_passes, \"coherence checking\", (), |_|\n         coherence::check_coherence(ccx, crate));\n "}, {"sha": "adb05d252e64c63eb07b9332e485be16391f4820", "filename": "src/librustc/middle/typeck/variance.rs", "status": "added", "additions": 841, "deletions": 0, "changes": 841, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -0,0 +1,841 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+This file infers the variance of type and lifetime parameters. The\n+algorithm is taken from Section 4 of the paper \"Taming the Wildcards:\n+Combining Definition- and Use-Site Variance\" published in PLDI'11 and\n+written by Altidor et al., and hereafter referred to as The Paper.\n+\n+The basic idea is quite straightforward. We iterate over the types\n+defined and, for each use of a type parameter X, accumulate a\n+constraint indicating that the variance of X must be valid for the\n+variance of that use site. We then iteratively refine the variance of\n+X until all constraints are met. There is *always* a sol'n, because at\n+the limit we can declare all type parameters to be invariant and all\n+constriants will be satisfied.\n+\n+As a simple example, consider:\n+\n+    enum Option<A> { Some(A), None }\n+    enum OptionalFn<B> { Some(&fn(B)), None }\n+    enum OptionalMap<C> { Some(&fn(C) -> C), None }\n+\n+Here, we will generate the constraints:\n+\n+    1. V(A) <= +\n+    2. V(B) <= -\n+    3. V(C) <= +\n+    4. V(C) <= -\n+\n+These indicate that (1) the variance of A must be at most covariant;\n+(2) the variance of B must be at most contravariant; and (3, 4) the\n+variance of C must be at most covariant *and* contravariant. All of these\n+results are based on a variance lattice defined as follows:\n+\n+      *      Top (bivariant)\n+   -     +\n+      o      Bottom (invariant)\n+\n+Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n+minimal solution (which is what we are looking for; the maximal\n+solution is just that all variables are invariant. Not so exciting.).\n+\n+You may be wondering why fixed-point iteration is required. The reason\n+is that the variance of a use site may itself be a function of the\n+variance of other type parameters. In full generality, our constraints\n+take the form:\n+\n+    V(X) <= Term\n+    Term := + | - | * | o | V(X) | Term x Term\n+\n+Here the notation V(X) indicates the variance of a type/region\n+parameter `X` with respect to its defining class. `Term x Term`\n+represents the \"variance transform\" as defined in the paper -- `V1 x\n+V2` is the resulting variance when a use site with variance V2 appears\n+inside a use site with variance V1.\n+\n+*/\n+\n+use std::hashmap::HashMap;\n+use extra::arena;\n+use extra::arena::Arena;\n+use middle::ty;\n+use std::vec;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::ast_util;\n+use syntax::parse::token;\n+use syntax::opt_vec;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+\n+pub fn infer_variance(tcx: ty::ctxt,\n+                      crate: &ast::Crate) {\n+    let mut arena = arena::Arena::new();\n+    let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, crate);\n+    let constraints_cx = add_constraints_from_crate(terms_cx, crate);\n+    solve_constraints(constraints_cx);\n+}\n+\n+/**************************************************************************\n+ * Representing terms\n+ *\n+ * Terms are structured as a straightforward tree. Rather than rely on\n+ * GC, we allocate terms out of a bounded arena (the lifetime of this\n+ * arena is the lifetime 'self that is threaded around).\n+ *\n+ * We assign a unique index to each type/region parameter whose variance\n+ * is to be inferred. We refer to such variables as \"inferreds\". An\n+ * `InferredIndex` is a newtype'd int representing the index of such\n+ * a variable.\n+ */\n+\n+type VarianceTermPtr<'self> = &'self VarianceTerm<'self>;\n+\n+struct InferredIndex(uint);\n+\n+enum VarianceTerm<'self> {\n+    ConstantTerm(ty::Variance),\n+    TransformTerm(VarianceTermPtr<'self>, VarianceTermPtr<'self>),\n+    InferredTerm(InferredIndex),\n+}\n+\n+impl<'self> ToStr for VarianceTerm<'self> {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ConstantTerm(c1) => format!(\"{}\", c1.to_str()),\n+            TransformTerm(v1, v2) => format!(\"({} \\u00D7 {})\",\n+                                          v1.to_str(), v2.to_str()),\n+            InferredTerm(id) => format!(\"[{}]\", *id)\n+        }\n+    }\n+}\n+\n+/**************************************************************************\n+ * The first pass over the crate simply builds up the set of inferreds.\n+ */\n+\n+struct TermsContext<'self> {\n+    tcx: ty::ctxt,\n+    arena: &'self Arena,\n+\n+    // Maps from the node id of a type/generic parameter to the\n+    // corresponding inferred index.\n+    inferred_map: HashMap<ast::NodeId, InferredIndex>,\n+    inferred_infos: ~[InferredInfo<'self>],\n+}\n+\n+enum ParamKind { TypeParam, RegionParam, SelfParam }\n+\n+struct InferredInfo<'self> {\n+    item_id: ast::NodeId,\n+    kind: ParamKind,\n+    index: uint,\n+    param_id: ast::NodeId,\n+    term: VarianceTermPtr<'self>,\n+}\n+\n+fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n+                                           arena: &'a mut Arena,\n+                                           crate: &ast::Crate)\n+                                           -> TermsContext<'a> {\n+    let mut terms_cx = TermsContext {\n+        tcx: tcx,\n+        arena: arena,\n+        inferred_map: HashMap::new(),\n+        inferred_infos: ~[],\n+    };\n+\n+    visit::walk_crate(&mut terms_cx, crate, ());\n+\n+    terms_cx\n+}\n+\n+impl<'self> TermsContext<'self> {\n+    fn add_inferred(&mut self,\n+                    item_id: ast::NodeId,\n+                    kind: ParamKind,\n+                    index: uint,\n+                    param_id: ast::NodeId) {\n+        let inf_index = InferredIndex(self.inferred_infos.len());\n+        let term = self.arena.alloc(|| InferredTerm(inf_index));\n+        self.inferred_infos.push(InferredInfo { item_id: item_id,\n+                                                kind: kind,\n+                                                index: index,\n+                                                param_id: param_id,\n+                                                term: term });\n+        let newly_added = self.inferred_map.insert(param_id, inf_index);\n+        assert!(newly_added);\n+\n+        debug!(\"add_inferred(item_id={}, \\\n+                kind={:?}, \\\n+                index={}, \\\n+                param_id={},\n+                inf_index={:?})\",\n+                item_id, kind, index, param_id, inf_index);\n+    }\n+\n+    fn num_inferred(&self) -> uint {\n+        self.inferred_infos.len()\n+    }\n+}\n+\n+impl<'self> Visitor<()> for TermsContext<'self> {\n+    fn visit_item(&mut self,\n+                  item: @ast::item,\n+                  (): ()) {\n+        debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n+\n+        let inferreds_on_entry = self.num_inferred();\n+\n+        // NB: In the code below for writing the results back into the\n+        // tcx, we rely on the fact that all inferreds for a particular\n+        // item are assigned continuous indices.\n+        match item.node {\n+            ast::item_trait(*) => {\n+                self.add_inferred(item.id, SelfParam, 0, item.id);\n+            }\n+            _ => { }\n+        }\n+\n+        match item.node {\n+            ast::item_enum(_, ref generics) |\n+            ast::item_struct(_, ref generics) |\n+            ast::item_trait(ref generics, _, _) => {\n+                for (i, p) in generics.lifetimes.iter().enumerate() {\n+                    self.add_inferred(item.id, RegionParam, i, p.id);\n+                }\n+                for (i, p) in generics.ty_params.iter().enumerate() {\n+                    self.add_inferred(item.id, TypeParam, i, p.id);\n+                }\n+\n+                // If this item has no type or lifetime parameters,\n+                // then there are no variances to infer, so just\n+                // insert an empty entry into the variance map.\n+                // Arguably we could just leave the map empty in this\n+                // case but it seems cleaner to be able to distinguish\n+                // \"invalid item id\" from \"item id with no\n+                // parameters\".\n+                if self.num_inferred() == inferreds_on_entry {\n+                    let newly_added = self.tcx.item_variance_map.insert(\n+                        ast_util::local_def(item.id),\n+                        @ty::ItemVariances {\n+                            self_param: None,\n+                            type_params: opt_vec::Empty,\n+                            region_params: opt_vec::Empty\n+                        });\n+                    assert!(newly_added);\n+                }\n+\n+                visit::walk_item(self, item, ());\n+            }\n+\n+            ast::item_impl(*) |\n+            ast::item_static(*) |\n+            ast::item_fn(*) |\n+            ast::item_mod(*) |\n+            ast::item_foreign_mod(*) |\n+            ast::item_ty(*) |\n+            ast::item_mac(*) => {\n+                visit::walk_item(self, item, ());\n+            }\n+        }\n+    }\n+}\n+\n+/**************************************************************************\n+ * Constraint construction and representation\n+ *\n+ * The second pass over the AST determines the set of constraints.\n+ * We walk the set of items and, for each member, generate new constraints.\n+ */\n+\n+struct ConstraintContext<'self> {\n+    terms_cx: TermsContext<'self>,\n+\n+    covariant: VarianceTermPtr<'self>,\n+    contravariant: VarianceTermPtr<'self>,\n+    invariant: VarianceTermPtr<'self>,\n+    bivariant: VarianceTermPtr<'self>,\n+\n+    constraints: ~[Constraint<'self>],\n+}\n+\n+/// Declares that the variable `decl_id` appears in a location with\n+/// variance `variance`.\n+struct Constraint<'self> {\n+    inferred: InferredIndex,\n+    variance: &'self VarianceTerm<'self>,\n+}\n+\n+fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n+                                  crate: &ast::Crate)\n+                                  -> ConstraintContext<'a> {\n+    let covariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Covariant));\n+    let contravariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Contravariant));\n+    let invariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Invariant));\n+    let bivariant = terms_cx.arena.alloc(|| ConstantTerm(ty::Bivariant));\n+    let mut constraint_cx = ConstraintContext {\n+        terms_cx: terms_cx,\n+        covariant: covariant,\n+        contravariant: contravariant,\n+        invariant: invariant,\n+        bivariant: bivariant,\n+        constraints: ~[],\n+    };\n+    visit::walk_crate(&mut constraint_cx, crate, ());\n+    constraint_cx\n+}\n+\n+impl<'self> Visitor<()> for ConstraintContext<'self> {\n+    fn visit_item(&mut self,\n+                  item: @ast::item,\n+                  (): ()) {\n+        let did = ast_util::local_def(item.id);\n+        let tcx = self.terms_cx.tcx;\n+\n+        match item.node {\n+            ast::item_enum(ref enum_definition, _) => {\n+                // Hack: If we directly call `ty::enum_variants`, it\n+                // annoyingly takes it upon itself to run off and\n+                // evaluate the discriminants eagerly (*grumpy* that's\n+                // not the typical pattern). This results in double\n+                // error messagees because typeck goes off and does\n+                // this at a later time. All we really care about is\n+                // the types of the variant arguments, so we just call\n+                // `ty::VariantInfo::from_ast_variant()` ourselves\n+                // here, mainly so as to mask the differences between\n+                // struct-like enums and so forth.\n+                for ast_variant in enum_definition.variants.iter() {\n+                    let variant =\n+                        ty::VariantInfo::from_ast_variant(tcx,\n+                                                          ast_variant,\n+                                                          /*discrimant*/ 0);\n+                    for &arg_ty in variant.args.iter() {\n+                        self.add_constraints_from_ty(arg_ty, self.covariant);\n+                    }\n+                }\n+            }\n+\n+            ast::item_struct(*) => {\n+                let struct_fields = ty::lookup_struct_fields(tcx, did);\n+                for field_info in struct_fields.iter() {\n+                    assert_eq!(field_info.id.crate, ast::LOCAL_CRATE);\n+                    let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n+                    self.add_constraints_from_ty(field_ty, self.covariant);\n+                }\n+            }\n+\n+            ast::item_trait(*) => {\n+                let methods = ty::trait_methods(tcx, did);\n+                for method in methods.iter() {\n+                    match method.transformed_self_ty {\n+                        Some(self_ty) => {\n+                            // The self type is a parameter, so its type\n+                            // should be considered contravariant:\n+                            self.add_constraints_from_ty(\n+                                self_ty, self.contravariant);\n+                        }\n+                        None => {}\n+                    }\n+\n+                    self.add_constraints_from_sig(\n+                        &method.fty.sig, self.covariant);\n+                }\n+            }\n+\n+            ast::item_static(*) |\n+            ast::item_fn(*) |\n+            ast::item_mod(*) |\n+            ast::item_foreign_mod(*) |\n+            ast::item_ty(*) |\n+            ast::item_impl(*) |\n+            ast::item_mac(*) => {\n+                visit::walk_item(self, item, ());\n+            }\n+        }\n+    }\n+}\n+\n+impl<'self> ConstraintContext<'self> {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.terms_cx.tcx\n+    }\n+\n+    fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n+        match self.terms_cx.inferred_map.find(&param_id) {\n+            Some(&index) => index,\n+            None => {\n+                self.tcx().sess.bug(format!(\n+                        \"No inferred index entry for {}\",\n+                        ast_map::node_id_to_str(self.tcx().items,\n+                                                param_id,\n+                                                token::get_ident_interner())));\n+            }\n+        }\n+    }\n+\n+    fn declared_variance(&self,\n+                         param_def_id: ast::DefId,\n+                         item_def_id: ast::DefId,\n+                         kind: ParamKind,\n+                         index: uint)\n+                         -> VarianceTermPtr<'self> {\n+        /*!\n+         * Returns a variance term representing the declared variance of\n+         * the type/region parameter with the given id.\n+         */\n+\n+        assert_eq!(param_def_id.crate, item_def_id.crate);\n+        if param_def_id.crate == ast::LOCAL_CRATE {\n+            // Parameter on an item defined within current crate:\n+            // variance not yet inferred, so return a symbolic\n+            // variance.\n+            let index = self.inferred_index(param_def_id.node);\n+            self.terms_cx.inferred_infos[*index].term\n+        } else {\n+            // Parameter on an item defined within another crate:\n+            // variance already inferred, just look it up.\n+            let variances = ty::item_variances(self.tcx(), item_def_id);\n+            let variance = match kind {\n+                SelfParam => variances.self_param.unwrap(),\n+                TypeParam => *variances.type_params.get(index),\n+                RegionParam => *variances.region_params.get(index),\n+            };\n+            self.constant_term(variance)\n+        }\n+    }\n+\n+    fn add_constraint(&mut self,\n+                      index: InferredIndex,\n+                      variance: VarianceTermPtr<'self>) {\n+        debug!(\"add_constraint(index={}, variance={})\",\n+                *index, variance.to_str());\n+        self.constraints.push(Constraint { inferred: index,\n+                                           variance: variance });\n+    }\n+\n+    fn contravariant(&mut self,\n+                     variance: VarianceTermPtr<'self>)\n+                     -> VarianceTermPtr<'self> {\n+        self.xform(variance, self.contravariant)\n+    }\n+\n+    fn invariant(&mut self,\n+                 variance: VarianceTermPtr<'self>)\n+                 -> VarianceTermPtr<'self> {\n+        self.xform(variance, self.invariant)\n+    }\n+\n+    fn constant_term(&self, v: ty::Variance) -> VarianceTermPtr<'self> {\n+        match v {\n+            ty::Covariant => self.covariant,\n+            ty::Invariant => self.invariant,\n+            ty::Contravariant => self.contravariant,\n+            ty::Bivariant => self.bivariant,\n+        }\n+    }\n+\n+    fn xform(&mut self,\n+             v1: VarianceTermPtr<'self>,\n+             v2: VarianceTermPtr<'self>)\n+             -> VarianceTermPtr<'self> {\n+        match (*v1, *v2) {\n+            (_, ConstantTerm(ty::Covariant)) => {\n+                // Applying a \"covariant\" transform is always a no-op\n+                v1\n+            }\n+\n+            (ConstantTerm(c1), ConstantTerm(c2)) => {\n+                self.constant_term(c1.xform(c2))\n+            }\n+\n+            _ => {\n+                self.terms_cx.arena.alloc(|| TransformTerm(v1, v2))\n+            }\n+        }\n+    }\n+\n+    fn add_constraints_from_ty(&mut self,\n+                               ty: ty::t,\n+                               variance: VarianceTermPtr<'self>) {\n+        debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n+\n+        match ty::get(ty).sty {\n+            ty::ty_nil | ty::ty_bot | ty::ty_bool |\n+            ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n+            ty::ty_float(_) => {\n+                /* leaf type -- noop */\n+            }\n+\n+            ty::ty_rptr(region, ref mt) => {\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(region, contra);\n+                self.add_constraints_from_mt(mt, variance);\n+            }\n+\n+            ty::ty_estr(vstore) => {\n+                self.add_constraints_from_vstore(vstore, variance);\n+            }\n+\n+            ty::ty_evec(ref mt, vstore) => {\n+                self.add_constraints_from_vstore(vstore, variance);\n+                self.add_constraints_from_mt(mt, variance);\n+            }\n+\n+            ty::ty_box(ref mt) |\n+            ty::ty_uniq(ref mt) |\n+            ty::ty_ptr(ref mt) => {\n+                self.add_constraints_from_mt(mt, variance);\n+            }\n+\n+            ty::ty_tup(ref subtys) => {\n+                for &subty in subtys.iter() {\n+                    self.add_constraints_from_ty(subty, variance);\n+                }\n+            }\n+\n+            ty::ty_enum(def_id, ref substs) |\n+            ty::ty_struct(def_id, ref substs) => {\n+                let item_type = ty::lookup_item_type(self.tcx(), def_id);\n+                self.add_constraints_from_substs(def_id, &item_type.generics,\n+                                                 substs, variance);\n+            }\n+\n+            ty::ty_trait(def_id, ref substs, _, _, _) => {\n+                let trait_def = ty::lookup_trait_def(self.tcx(), def_id);\n+                self.add_constraints_from_substs(def_id, &trait_def.generics,\n+                                                 substs, variance);\n+            }\n+\n+            ty::ty_param(ty::param_ty { def_id: ref def_id, _ }) => {\n+                assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n+                match self.terms_cx.inferred_map.find(&def_id.node) {\n+                    Some(&index) => {\n+                        self.add_constraint(index, variance);\n+                    }\n+                    None => {\n+                        // We do not infer variance for type parameters\n+                        // declared on methods. They will not be present\n+                        // in the inferred_map.\n+                    }\n+                }\n+            }\n+\n+            ty::ty_self(ref def_id) => {\n+                assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n+                let index = self.inferred_index(def_id.node);\n+                self.add_constraint(index, variance);\n+            }\n+\n+            ty::ty_bare_fn(ty::BareFnTy { sig: ref sig, _ }) => {\n+                self.add_constraints_from_sig(sig, variance);\n+            }\n+\n+            ty::ty_closure(ty::ClosureTy { sig: ref sig, region, _ }) => {\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(region, contra);\n+                self.add_constraints_from_sig(sig, variance);\n+            }\n+\n+            ty::ty_infer(*) | ty::ty_err | ty::ty_type |\n+            ty::ty_opaque_box | ty::ty_opaque_closure_ptr(*) |\n+            ty::ty_unboxed_vec(*) => {\n+                self.tcx().sess.bug(\n+                    format!(\"Unexpected type encountered in \\\n+                            variance inference: {}\",\n+                            ty.repr(self.tcx())));\n+            }\n+        }\n+    }\n+\n+    fn add_constraints_from_vstore(&mut self,\n+                                   vstore: ty::vstore,\n+                                   variance: VarianceTermPtr<'self>) {\n+        match vstore {\n+            ty::vstore_slice(r) => {\n+                let contra = self.contravariant(variance);\n+                self.add_constraints_from_region(r, contra);\n+            }\n+\n+            ty::vstore_fixed(_) | ty::vstore_uniq | ty::vstore_box => {\n+            }\n+        }\n+    }\n+\n+    fn add_constraints_from_substs(&mut self,\n+                                   def_id: ast::DefId,\n+                                   generics: &ty::Generics,\n+                                   substs: &ty::substs,\n+                                   variance: VarianceTermPtr<'self>) {\n+        debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n+\n+        for (i, p) in generics.type_param_defs.iter().enumerate() {\n+            let variance_decl =\n+                self.declared_variance(p.def_id, def_id, TypeParam, i);\n+            let variance_i = self.xform(variance, variance_decl);\n+            self.add_constraints_from_ty(substs.tps[i], variance_i);\n+        }\n+\n+        match substs.regions {\n+            ty::ErasedRegions => {}\n+            ty::NonerasedRegions(ref rps) => {\n+                for (i, p) in generics.region_param_defs.iter().enumerate() {\n+                    let variance_decl =\n+                        self.declared_variance(p.def_id, def_id, RegionParam, i);\n+                    let variance_i = self.xform(variance, variance_decl);\n+                    self.add_constraints_from_region(*rps.get(i), variance_i);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_constraints_from_sig(&mut self,\n+                                sig: &ty::FnSig,\n+                                variance: VarianceTermPtr<'self>) {\n+        let contra = self.contravariant(variance);\n+        for &input in sig.inputs.iter() {\n+            self.add_constraints_from_ty(input, contra);\n+        }\n+        self.add_constraints_from_ty(sig.output, variance);\n+    }\n+\n+    fn add_constraints_from_region(&mut self,\n+                                   region: ty::Region,\n+                                   variance: VarianceTermPtr<'self>) {\n+        match region {\n+            ty::re_type_bound(param_id, _, _) => {\n+                let index = self.inferred_index(param_id);\n+                self.add_constraint(index, variance);\n+            }\n+\n+            ty::re_static => { }\n+\n+            ty::re_fn_bound(*) => {\n+                // We do not infer variance for region parameters on\n+                // methods or in fn types.\n+            }\n+\n+            ty::re_free(*) | ty::re_scope(*) | ty::re_infer(*) |\n+            ty::re_empty => {\n+                // We don't expect to see anything but 'static or bound\n+                // regions when visiting member types or method types.\n+                self.tcx().sess.bug(format!(\"Unexpected region encountered in \\\n+                                            variance inference: {}\",\n+                                            region.repr(self.tcx())));\n+            }\n+        }\n+    }\n+\n+    fn add_constraints_from_mt(&mut self,\n+                               mt: &ty::mt,\n+                               variance: VarianceTermPtr<'self>) {\n+        match mt.mutbl {\n+            ast::MutMutable => {\n+                let invar = self.invariant(variance);\n+                self.add_constraints_from_ty(mt.ty, invar);\n+            }\n+\n+            ast::MutImmutable => {\n+                self.add_constraints_from_ty(mt.ty, variance);\n+            }\n+        }\n+    }\n+}\n+\n+/**************************************************************************\n+ * Constraint solving\n+ *\n+ * The final phase iterates over the constraints, refining the variance\n+ * for each inferred until a fixed point is reached. This will be the\n+ * maximal solution to the constraints. The final variance for each\n+ * inferred is then written into the `variance_map` in the tcx.\n+ */\n+\n+struct SolveContext<'self> {\n+    terms_cx: TermsContext<'self>,\n+    constraints: ~[Constraint<'self>],\n+    solutions: ~[ty::Variance]\n+}\n+\n+fn solve_constraints(constraints_cx: ConstraintContext) {\n+    let ConstraintContext { terms_cx, constraints, _ } = constraints_cx;\n+    let solutions = vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n+    let mut solutions_cx = SolveContext {\n+        terms_cx: terms_cx,\n+        constraints: constraints,\n+        solutions: solutions\n+    };\n+    solutions_cx.solve();\n+    solutions_cx.write();\n+}\n+\n+impl<'self> SolveContext<'self> {\n+    fn solve(&mut self) {\n+        // Propagate constraints until a fixed point is reached.  Note\n+        // that the maximum number of iterations is 2C where C is the\n+        // number of constraints (each variable can change values at most\n+        // twice). Since number of constraints is linear in size of the\n+        // input, so is the inference process.\n+        let mut changed = true;\n+        while changed {\n+            changed = false;\n+\n+            for constraint in self.constraints.iter() {\n+                let Constraint { inferred, variance: term } = *constraint;\n+                let variance = self.evaluate(term);\n+                let old_value = self.solutions[*inferred];\n+                let new_value = glb(variance, old_value);\n+                if old_value != new_value {\n+                    debug!(\"Updating inferred {} (node {}) \\\n+                            from {:?} to {:?} due to {}\",\n+                            *inferred,\n+                            self.terms_cx.inferred_infos[*inferred].param_id,\n+                            old_value,\n+                            new_value,\n+                            term.to_str());\n+\n+                    self.solutions[*inferred] = new_value;\n+                    changed = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn write(&self) {\n+        // Collect all the variances for a particular item and stick\n+        // them into the variance map. We rely on the fact that we\n+        // generate all the inferreds for a particular item\n+        // consecutively.\n+        let tcx = self.terms_cx.tcx;\n+        let item_variance_map = tcx.item_variance_map;\n+        let solutions = &self.solutions;\n+        let inferred_infos = &self.terms_cx.inferred_infos;\n+        let mut index = 0;\n+        let num_inferred = self.terms_cx.num_inferred();\n+        while index < num_inferred {\n+            let item_id = inferred_infos[index].item_id;\n+            let mut item_variances = ty::ItemVariances {\n+                self_param: None,\n+                type_params: opt_vec::Empty,\n+                region_params: opt_vec::Empty\n+            };\n+            while (index < num_inferred &&\n+                   inferred_infos[index].item_id == item_id) {\n+                let info = &inferred_infos[index];\n+                match info.kind {\n+                    SelfParam => {\n+                        assert!(item_variances.self_param.is_none());\n+                        item_variances.self_param = Some(solutions[index]);\n+                    }\n+                    TypeParam => {\n+                        item_variances.type_params.push(solutions[index]);\n+                    }\n+                    RegionParam => {\n+                        item_variances.region_params.push(solutions[index]);\n+                    }\n+                }\n+                index += 1;\n+            }\n+\n+            debug!(\"item_id={} item_variances={}\",\n+                    item_id,\n+                    item_variances.repr(tcx));\n+\n+            let item_def_id = ast_util::local_def(item_id);\n+\n+            // For unit testing: check for a special \"rustc_variance\"\n+            // attribute and report an error with various results if found.\n+            if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n+                let found = item_variances.repr(tcx);\n+                tcx.sess.span_err(ast_map::item_span(tcx.items, item_id), found);\n+            }\n+\n+            let newly_added = item_variance_map.insert(item_def_id,\n+                                                       @item_variances);\n+            assert!(newly_added);\n+        }\n+    }\n+\n+    fn evaluate(&self, term: VarianceTermPtr<'self>) -> ty::Variance {\n+        match *term {\n+            ConstantTerm(v) => {\n+                v\n+            }\n+\n+            TransformTerm(t1, t2) => {\n+                let v1 = self.evaluate(t1);\n+                let v2 = self.evaluate(t2);\n+                v1.xform(v2)\n+            }\n+\n+            InferredTerm(index) => {\n+                self.solutions[*index]\n+            }\n+        }\n+    }\n+}\n+\n+/**************************************************************************\n+ * Miscellany transformations on variance\n+ */\n+\n+trait Xform {\n+    fn xform(self, v: Self) -> Self;\n+}\n+\n+impl Xform for ty::Variance {\n+    fn xform(self, v: ty::Variance) -> ty::Variance {\n+        // \"Variance transformation\", Figure 1 of The Paper\n+        match (self, v) {\n+            // Figure 1, column 1.\n+            (ty::Covariant, ty::Covariant) => ty::Covariant,\n+            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n+            (ty::Covariant, ty::Invariant) => ty::Invariant,\n+            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 2.\n+            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n+            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n+            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n+            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 3.\n+            (ty::Invariant, _) => ty::Invariant,\n+\n+            // Figure 1, column 4.\n+            (ty::Bivariant, _) => ty::Bivariant,\n+        }\n+    }\n+}\n+\n+fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n+    // Greatest lower bound of the variance lattice as\n+    // defined in The Paper:\n+    //\n+    //       *\n+    //    -     +\n+    //       o\n+    match (v1, v2) {\n+        (ty::Invariant, _) | (_, ty::Invariant) => ty::Invariant,\n+\n+        (ty::Covariant, ty::Contravariant) => ty::Invariant,\n+        (ty::Contravariant, ty::Covariant) => ty::Invariant,\n+\n+        (ty::Covariant, ty::Covariant) => ty::Covariant,\n+\n+        (ty::Contravariant, ty::Contravariant) => ty::Contravariant,\n+\n+        (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n+    }\n+}\n+"}, {"sha": "83e39ebd9f4d022ae3a016f5e67934fba7bbfb9c", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-immutability.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-immutability.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct contravariant<'self> {\n-    f: &'self int\n-}\n-\n-fn to_same_lifetime<'r>(bi: contravariant<'r>) {\n-    let bj: contravariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: contravariant<'r>) {\n-    let bj: contravariant<'blk> = bi;\n-}\n-\n-fn to_longer_lifetime<'r>(bi: contravariant<'r>) -> contravariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "3fcc5184b4a7c8404df6c416ffc032249090ba4b", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-ret.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Contravariant with respect to a region:\n-//\n-// You can upcast to a *smaller region* but not a larger one.  This is\n-// the normal case.\n-\n-struct contravariant<'self> {\n-    f: &'static fn() -> &'self int\n-}\n-\n-fn to_same_lifetime<'r>(bi: contravariant<'r>) {\n-    let bj: contravariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: contravariant<'r>) {\n-    let bj: contravariant<'blk> = bi;\n-}\n-\n-fn to_longer_lifetime<'r>(bi: contravariant<'r>) -> contravariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "4b26e6b60216372277337a5e10f8133b174a1339", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-arg.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Covariant with respect to a region:\n-//\n-// You can upcast to a *larger region* but not a smaller one.\n-\n-struct covariant<'self> {\n-    f: &'static fn(x: &'self int) -> int\n-}\n-\n-fn to_same_lifetime<'r>(bi: covariant<'r>) {\n-    let bj: covariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: covariant<'r>) {\n-    let bj: covariant<'blk> = bi; //~ ERROR mismatched types\n-    //~^ ERROR cannot infer an appropriate lifetime\n-}\n-\n-fn to_longer_lifetime<'r>(bi: covariant<'r>) -> covariant<'static> {\n-    bi\n-}\n-\n-fn main() {\n-}"}, {"sha": "0d4d4056a44011fb29fc7ab173710a529705c3e5", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-arg-and-ret.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-arg-and-ret.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Invariance with respect to a region:\n-//\n-// You cannot convert between regions.\n-\n-struct invariant<'self> {\n-    f: &'self fn(x: &'self int) -> &'self int\n-}\n-\n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'blk> = bi; //~ ERROR mismatched types\n-}\n-\n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "f7c9e5bda3b4f88a27c1149caa5ab175b9ff9cdd", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-1.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-1.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct invariant<'self> {\n-    f: @mut &'self int\n-}\n-\n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n-}\n-\n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "522e5675bfe69d43dc3ebf0ed9c34dddc2badf5c", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-2.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct invariant<'self> {\n-    f: @mut [&'self int]\n-}\n-\n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n-}\n-\n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "9853741d77a117cebcc0abd82350f708d0a9c20f", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct invariant<'self> {\n-    f: @mut &'self int\n-}\n-\n-fn to_same_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'r> = bi;\n-}\n-\n-fn to_shorter_lifetime<'r>(bi: invariant<'r>) {\n-    let bj: invariant<'blk> = bi; //~ ERROR mismatched types\n-}\n-\n-fn to_longer_lifetime<'r>(bi: invariant<'r>) -> invariant<'static> {\n-    bi //~ ERROR mismatched types\n-}\n-\n-fn main() {\n-}"}, {"sha": "b004bc471a56d1ec1cee84fee54414521fec7672", "filename": "src/test/compile-fail/regions-variance-covariant-use-contravariant.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is contravariant with respect to its region\n+// parameter yields an error when used in a covariant way.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+// This is covariant with respect to 'a, meaning that\n+// Covariant<'foo> <: Covariant<'static> because\n+// 'foo <= 'static\n+struct Covariant<'a> {\n+    f: extern \"Rust\" fn(&'a int)\n+}\n+\n+fn use_<'a>(c: Covariant<'a>) {\n+    let x = 3;\n+\n+    // 'b winds up being inferred to 'a because\n+    // Covariant<'a> <: Covariant<'b> => 'a <= 'b\n+    //\n+    // Borrow checker then reports an error because `x` does not\n+    // have the lifetime 'a.\n+    collapse(&x, c); //~ ERROR borrowed value does not live long enough\n+\n+\n+    fn collapse<'b>(x: &'b int, c: Covariant<'b>) { }\n+}\n+\n+fn main() {}"}, {"sha": "b105fc72692d27e89684d7bae529a07f4ba875f3", "filename": "src/test/compile-fail/regions-variance-invariant-use-contravariant.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-contravariant.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a covariant region parameter used in a covariant position\n+// yields an error.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+struct Invariant<'a> {\n+    f: &'static mut &'a int\n+}\n+\n+fn use_<'a>(c: Invariant<'a>) {\n+    let x = 3;\n+\n+    // 'b winds up being inferred to 'a, because that is the\n+    // only way that Invariant<'a> <: Invariant<'b>, and hence\n+    // we get an error in the borrow checker because &x cannot\n+    // live that long\n+    collapse(&x, c); //~ ERROR borrowed value does not live long enough\n+\n+    fn collapse<'b>(x: &'b int, c: Invariant<'b>) { }\n+}\n+\n+fn main() { }"}, {"sha": "9aae0f87f5bec67fde13a41a05d07d1bbcba3eec", "filename": "src/test/compile-fail/regions-variance-invariant-use-covariant.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-invariant-use-covariant.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is invariant with respect to its region\n+// parameter used in a covariant way yields an error.\n+//\n+// Note: see variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+struct Invariant<'a> {\n+    f: &'static mut &'a int\n+}\n+\n+fn use_<'a>(c: Invariant<'a>) {\n+    // For this assignment to be legal, Invariant<'a> <: Invariant<'static>,\n+    // which (if Invariant were covariant) would require 'a <= 'static.\n+    let _: Invariant<'static> = c; //~ ERROR mismatched types\n+}\n+\n+fn main() { }"}, {"sha": "ae8444f015e7e256d642f09ea98fa14141d2882d", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly infer variance for region parameters in\n+// various self-contained types.\n+\n+// Regions that just appear in normal spots are contravariant:\n+\n+#[rustc_variance]\n+struct Test2<'a, 'b, 'c> { //~ ERROR region_params=[-, -, -]\n+    x: &'a int,\n+    y: &'b [int],\n+    c: &'c str\n+}\n+\n+// Those same annotations in function arguments become covariant:\n+\n+#[rustc_variance]\n+struct Test3<'a, 'b, 'c> { //~ ERROR region_params=[+, +, +]\n+    x: extern \"Rust\" fn(&'a int),\n+    y: extern \"Rust\" fn(&'b [int]),\n+    c: extern \"Rust\" fn(&'c str),\n+}\n+\n+// Mutability induces invariance:\n+\n+#[rustc_variance]\n+struct Test4<'a, 'b> { //~ ERROR region_params=[-, o]\n+    x: &'a mut &'b int,\n+}\n+\n+// Mutability induces invariance, even when in a\n+// contravariant context:\n+\n+#[rustc_variance]\n+struct Test5<'a, 'b> { //~ ERROR region_params=[+, o]\n+    x: extern \"Rust\" fn(&'a mut &'b int),\n+}\n+\n+// Invariance is a trap from which NO ONE CAN ESCAPE.\n+// In other words, even though the `&'b int` occurs in\n+// a argument list (which is contravariant), that\n+// argument list occurs in an invariant context.\n+\n+#[rustc_variance]\n+struct Test6<'a, 'b> { //~ ERROR region_params=[-, o]\n+    x: &'a mut extern \"Rust\" fn(&'b int),\n+}\n+\n+// No uses at all is bivariant:\n+\n+#[rustc_variance]\n+struct Test7<'a> { //~ ERROR region_params=[*]\n+    x: int\n+}\n+\n+// Try enums too.\n+\n+#[rustc_variance]\n+enum Test8<'a, 'b, 'c> { //~ ERROR region_params=[+, -, o]\n+    Test8A(extern \"Rust\" fn(&'a int)),\n+    Test8B(&'b [int]),\n+    Test8C(&'b mut &'c str),\n+}\n+\n+fn main() {}"}, {"sha": "fa22bb41aa321fe13191f3b70bfb9e1ed2ab67c4", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we correctly infer variance for region parameters in\n+// case that involve multiple intracrate types.\n+// Try enums too.\n+\n+#[rustc_variance]\n+enum Base<'a, 'b, 'c, 'd> { //~ ERROR region_params=[+, -, o, *]\n+    Test8A(extern \"Rust\" fn(&'a int)),\n+    Test8B(&'b [int]),\n+    Test8C(&'b mut &'c str),\n+}\n+\n+#[rustc_variance]\n+struct Derived1<'w, 'x, 'y, 'z> { //~ ERROR region_params=[*, o, -, +]\n+    f: Base<'z, 'y, 'x, 'w>\n+}\n+\n+#[rustc_variance] // Combine - and + to yield o\n+struct Derived2<'a, 'b, 'c> { //~ ERROR region_params=[o, o, *]\n+    f: Base<'a, 'a, 'b, 'c>\n+}\n+\n+#[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n+struct Derived3<'a, 'b, 'c> { //~ ERROR region_params=[o, -, *]\n+    f: Base<'a, 'b, 'a, 'c>\n+}\n+\n+#[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n+struct Derived4<'a, 'b, 'c> { //~ ERROR region_params=[+, -, o]\n+    f: Base<'a, 'b, 'c, 'a>\n+}\n+\n+fn main() {}"}, {"sha": "1cc9a501ab6f4ce6df6748d652fe90f662a68582", "filename": "src/test/run-pass/regions-variance-contravariant-use-contravariant.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Frun-pass%2Fregions-variance-contravariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Frun-pass%2Fregions-variance-contravariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-variance-contravariant-use-contravariant.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is contravariant with respect to its region\n+// parameter compiles successfully when used in a contravariant way.\n+//\n+// Note: see compile-fail/variance-regions-*.rs for the tests that check that the\n+// variance inference works in the first place.\n+\n+struct Contravariant<'a> {\n+    f: &'a int\n+}\n+\n+fn use_<'a>(c: Contravariant<'a>) {\n+    let x = 3;\n+\n+    // 'b winds up being inferred to this call.\n+    // Contravariant<'a> <: Contravariant<'call> is true\n+    // if 'call <= 'a, which is true, so no error.\n+    collapse(&x, c);\n+\n+    fn collapse<'b>(x: &'b int, c: Contravariant<'b>) { }\n+}\n+\n+fn main() {}"}, {"sha": "ca32f7a52581aa3eb948bb36178baaf09e6e7a4b", "filename": "src/test/run-pass/regions-variance-covariant-use-covariant.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Frun-pass%2Fregions-variance-covariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3f57ef0869805e0dde99cdce9548a587df7893/src%2Ftest%2Frun-pass%2Fregions-variance-covariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-variance-covariant-use-covariant.rs?ref=9d3f57ef0869805e0dde99cdce9548a587df7893", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a type which is covariant with respect to its region\n+// parameter is successful when used in a covariant way.\n+//\n+// Note: see compile-fail/variance-regions-*.rs for the tests that\n+// check that the variance inference works in the first place.\n+\n+// This is covariant with respect to 'a, meaning that\n+// Covariant<'foo> <: Covariant<'static> because\n+// 'foo <= 'static\n+struct Covariant<'a> {\n+    f: extern \"Rust\" fn(&'a int)\n+}\n+\n+fn use_<'a>(c: Covariant<'a>) {\n+    // OK Because Covariant<'a> <: Covariant<'static> iff 'a <= 'static\n+    let _: Covariant<'static> = c;\n+}\n+\n+fn main() {}"}]}