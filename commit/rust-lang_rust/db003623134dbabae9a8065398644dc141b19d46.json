{"sha": "db003623134dbabae9a8065398644dc141b19d46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDAzNjIzMTM0ZGJhYmFlOWE4MDY1Mzk4NjQ0ZGMxNDFiMTlkNDY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-03-20T19:55:18Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-03-21T02:44:38Z"}, "message": "Make typechecker compositional\n\nThe typechecker previously passed around a boolean return flag to\nindicate whether it saw something with type _|_ (that is, something\nit knows at compile-time will definitely diverge) and also had some\nmanual checks for the `ty_err` pseudo-type that represents a previous\ntype error. This was because the typing rules implemented by the\ntypechecker didn't properly propagate _|_ and ty_err. I fixed it.\n\nThis also required changing expected error messages in a few tests,\nas now we're printing out fewer derived errors -- in fact, at this\npoint we should print out no derived errors, so report any that\nyou see (ones that include \"[type error]\") as bugs.", "tree": {"sha": "9e941110d5ff729b27d33a04601aa05a1e281eed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e941110d5ff729b27d33a04601aa05a1e281eed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db003623134dbabae9a8065398644dc141b19d46", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db003623134dbabae9a8065398644dc141b19d46", "html_url": "https://github.com/rust-lang/rust/commit/db003623134dbabae9a8065398644dc141b19d46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db003623134dbabae9a8065398644dc141b19d46/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63a292fd8686f56efe7836aef46709a063efab4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/63a292fd8686f56efe7836aef46709a063efab4e", "html_url": "https://github.com/rust-lang/rust/commit/63a292fd8686f56efe7836aef46709a063efab4e"}], "stats": {"total": 1309, "additions": 814, "deletions": 495}, "files": [{"sha": "884bfd219ab7a5cd5184e2e35f93dd28b35ebdbb", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -28,6 +28,7 @@ use util::ppaux::{expr_repr, ty_to_str};\n \n use core::libc::c_uint;\n use syntax::{ast, ast_util, codemap, ast_map};\n+use util::ppaux::ty_to_str;\n \n pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n@@ -45,7 +46,8 @@ pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n             C_integral(T_uint_ty(cx, t), i as u64, False)\n           }\n           _ => cx.sess.span_bug(lit.span,\n-                                ~\"integer literal doesn't have a type\")\n+                   fmt!(\"integer literal has type %s (expected int or uint)\",\n+                        ty_to_str(cx.tcx, lit_int_ty)))\n         }\n       }\n       ast::lit_float(fs, t) => C_floating(/*bad*/copy *fs, T_float_ty(cx, t)),"}, {"sha": "be5dd8af9d73097b6a61bb0920ba3167567002cc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -310,6 +310,7 @@ enum tbox_flag {\n     needs_infer = 4,\n     has_regions = 8,\n     has_ty_err = 16,\n+    has_ty_bot = 32,\n \n     // a meta-flag: subst may be required if the type has parameters, a self\n     // type, or references bound regions\n@@ -355,9 +356,6 @@ pub pure fn type_needs_infer(t: t) -> bool {\n pub pure fn type_has_regions(t: t) -> bool {\n     tbox_has_flag(get(t), has_regions)\n }\n-pub pure fn type_contains_err(t: t) -> bool {\n-    tbox_has_flag(get(t), has_ty_err)\n-}\n pub pure fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n pub pure fn type_id(t: t) -> uint { get(t).id }\n \n@@ -892,9 +890,17 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n         flags |= rflags(r);\n         flags |= get(mt.ty).flags;\n       }\n-      &ty_nil | &ty_bot | &ty_bool | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n+      &ty_nil | &ty_bool | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_estr(_) | &ty_type | &ty_opaque_closure_ptr(_) |\n       &ty_opaque_box => (),\n+      // You might think that we could just return ty_err for\n+      // any type containing ty_err as a component, and get\n+      // rid of the has_ty_err flag -- likewise for ty_bot (with\n+      // the exception of function types that return bot).\n+      // But doing so caused sporadic memory corruption, and\n+      // neither I (tjc) nor nmatsakis could figure out why,\n+      // so we're doing it this way.\n+      &ty_bot => flags |= has_ty_bot as uint,\n       &ty_err => flags |= has_ty_err as uint,\n       &ty_param(_) => flags |= has_params as uint,\n       &ty_infer(_) => flags |= needs_infer as uint,\n@@ -914,12 +920,16 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       &ty_tup(ref ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n         for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n-        flags |= get(f.sig.output).flags;\n+         flags |= get(f.sig.output).flags;\n+         // T -> _|_ is *not* _|_ !\n+         flags &= !(has_ty_bot as uint);\n       }\n       &ty_closure(ref f) => {\n         flags |= rflags(f.region);\n         for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n         flags |= get(f.sig.output).flags;\n+        // T -> _|_ is *not* _|_ !\n+        flags &= !(has_ty_bot as uint);\n       }\n     }\n \n@@ -1465,7 +1475,13 @@ pub fn subst_substs(cx: ctxt, sup: &substs, sub: &substs) -> substs {\n \n pub fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n \n-pub fn type_is_bot(ty: t) -> bool { get(ty).sty == ty_bot }\n+pub fn type_is_bot(ty: t) -> bool {\n+    (get(ty).flags & (has_ty_bot as uint)) != 0\n+}\n+\n+pub fn type_is_error(ty: t) -> bool {\n+    (get(ty).flags & (has_ty_err as uint)) != 0\n+}\n \n pub fn type_is_ty_var(ty: t) -> bool {\n     match get(ty).sty {"}, {"sha": "974d968e40671ccab6196b672a253e222dbef880", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -28,12 +28,11 @@ use syntax::print::pprust;\n pub fn check_match(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n                    discrim: @ast::expr,\n-                   arms: &[ast::arm]) -> bool {\n+                   arms: &[ast::arm]) {\n     let tcx = fcx.ccx.tcx;\n-    let mut bot;\n \n     let pattern_ty = fcx.infcx().next_ty_var();\n-    bot = check_expr_has_type(fcx, discrim, pattern_ty);\n+    check_expr_has_type(fcx, discrim, pattern_ty);\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n@@ -51,19 +50,46 @@ pub fn check_match(fcx: @mut FnCtxt,\n     // Now typecheck the blocks.\n     let mut result_ty = fcx.infcx().next_ty_var();\n     let mut arm_non_bot = false;\n+    let mut saw_err = false;\n     for arms.each |arm| {\n+        let mut guard_err = false;\n+        let mut guard_bot = false;\n         match arm.guard {\n-          Some(e) => { check_expr_has_type(fcx, e, ty::mk_bool(tcx)); },\n+          Some(e) => {\n+              check_expr_has_type(fcx, e, ty::mk_bool(tcx));\n+              let e_ty = fcx.expr_ty(e);\n+              if ty::type_is_error(e_ty) {\n+                  guard_err = true;\n+              }\n+              else if ty::type_is_bot(e_ty) {\n+                  guard_bot = true;\n+              }\n+          },\n           None => ()\n         }\n-        if !check_block(fcx, &arm.body) { arm_non_bot = true; }\n+        check_block(fcx, &arm.body);\n         let bty = fcx.node_ty(arm.body.node.id);\n+        saw_err = saw_err || ty::type_is_error(bty);\n+        if guard_err {\n+            fcx.write_error(arm.body.node.id);\n+            saw_err = true;\n+        }\n+        else if guard_bot {\n+            fcx.write_bot(arm.body.node.id);\n+        }\n+        else if !ty::type_is_bot(bty) {\n+            arm_non_bot = true; // If the match *may* evaluate to a non-_|_\n+                                // expr, the whole thing is non-_|_\n+        }\n         demand::suptype(fcx, arm.body.span, result_ty, bty);\n     }\n-    bot |= !arm_non_bot;\n-    if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n+    if saw_err {\n+        result_ty = ty::mk_err(tcx);\n+    }\n+    else if !arm_non_bot {\n+        result_ty = ty::mk_bot(tcx);\n+    }\n     fcx.write_ty(expr.id, result_ty);\n-    return bot;\n }\n \n pub struct pat_ctxt {"}, {"sha": "adcc94086947add9a5b994765d4f3dfb8111d86f", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -194,6 +194,10 @@ pub enum TransformTypeFlag {\n \n pub impl LookupContext/&self {\n     fn do_lookup(&self, self_ty: ty::t) -> Option<method_map_entry> {\n+        let mut self_ty = structurally_resolved_type(self.fcx,\n+                                                     self.self_expr.span,\n+                                                     self_ty);\n+\n         debug!(\"do_lookup(self_ty=%s, expr=%s, self_expr=%s)\",\n                self.ty_to_str(self_ty),\n                expr_repr(self.tcx(), self.expr),"}, {"sha": "e74c417b05fab131734c1b448db851e229fae5b6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 711, "deletions": 467, "changes": 1178, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -339,7 +339,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     };\n \n     gather_locals(fcx, decl, body, arg_tys, self_info);\n-    check_block(fcx, body);\n+    check_block_with_expected(fcx, body, Some(ret_ty));\n \n     // We unify the tail expr's type with the\n     // function result type, if there is a tail expr.\n@@ -741,6 +741,9 @@ pub impl FnCtxt {\n     fn write_bot(&self, node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_bot(self.tcx()));\n     }\n+    fn write_error(@mut self, node_id: ast::node_id) {\n+        self.write_ty(node_id, ty::mk_err(self.tcx()));\n+    }\n \n     fn to_ty(&self, ast_t: @ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, self, ast_t)\n@@ -889,6 +892,10 @@ pub impl FnCtxt {\n                                       e: ty::t,\n                                       a: ty::t,\n                                       err: &ty::type_err) {\n+        // Derived error\n+        if ty::type_is_error(e) || ty::type_is_error(a) {\n+            return;\n+        }\n         match self.fn_kind {\n             ForLoop(_) if !ty::type_is_bool(e) && !ty::type_is_nil(a) =>\n                     self.tcx().sess.span_err(sp, fmt!(\"A for-loop body must \\\n@@ -1003,33 +1010,33 @@ pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n \n pub fn check_expr_has_type(\n     fcx: @mut FnCtxt, expr: @ast::expr,\n-    expected: ty::t) -> bool {\n+    expected: ty::t) {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     }\n }\n \n pub fn check_expr_coercable_to_type(\n     fcx: @mut FnCtxt, expr: @ast::expr,\n-    expected: ty::t) -> bool {\n+    expected: ty::t) {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::coerce(fcx, expr.span, expected, expr)\n     }\n }\n \n pub fn check_expr_with_hint(\n     fcx: @mut FnCtxt, expr: @ast::expr,\n-    expected: ty::t) -> bool {\n+    expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || ())\n }\n \n pub fn check_expr_with_opt_hint(\n     fcx: @mut FnCtxt, expr: @ast::expr,\n-    expected: Option<ty::t>) -> bool {\n+    expected: Option<ty::t>)  {\n     check_expr_with_unifier(fcx, expr, expected, || ())\n }\n \n-pub fn check_expr(fcx: @mut FnCtxt, expr: @ast::expr) -> bool {\n+pub fn check_expr(fcx: @mut FnCtxt, expr: @ast::expr)  {\n     check_expr_with_unifier(fcx, expr, None, || ())\n }\n \n@@ -1123,7 +1130,7 @@ pub fn break_here() {\n pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::expr,\n                                expected: Option<ty::t>,\n-                               unifier: &fn()) -> bool {\n+                               unifier: &fn()) {\n     debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and\n@@ -1136,10 +1143,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         callee_expr: @ast::expr,\n         args: &[@ast::expr],\n         sugar: ast::CallSugar,\n-        deref_args: DerefArgs) -> (ty::t, bool)\n+        deref_args: DerefArgs) -> ty::t\n     {\n         let tcx = fcx.ccx.tcx;\n-        let mut bot = false;\n \n         // Replace all region parameters in the arguments and return\n         // type with fresh region variables.\n@@ -1164,8 +1170,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n                 let supplied_arg_count = args.len();\n \n-                bot |= ty::type_is_bot(sig.output);\n-\n                 // Grab the argument types, supplying fresh type variables\n                 // if the wrong number of arguments were supplied\n                 let expected_arg_count = sig.inputs.len();\n@@ -1246,6 +1250,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         DoDerefArgs => {\n                             match ty::get(formal_ty).sty {\n                                 ty::ty_rptr(_, mt) => formal_ty = mt.ty,\n+                                ty::ty_err => (),\n                                 _ => {\n                                     fcx.ccx.tcx.sess.span_bug(arg.span,\n                                                               ~\"no ref\");\n@@ -1255,28 +1260,26 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         DontDerefArgs => {}\n                     }\n \n-                    // mismatch error happens in here\n-                    bot |= check_expr_coercable_to_type(\n+                    check_expr_coercable_to_type(\n                         fcx, *arg, formal_ty);\n \n                 }\n             }\n         }\n \n-        (ret_ty, bot)\n+        ret_ty\n     }\n \n     // A generic function for checking assignment expressions\n     fn check_assignment(fcx: @mut FnCtxt,\n                         lhs: @ast::expr,\n                         rhs: @ast::expr,\n-                        id: ast::node_id)\n-                     -> bool {\n-        let mut bot = check_expr(fcx, lhs);\n+                        id: ast::node_id) {\n+        check_expr(fcx, lhs);\n         let lhs_type = fcx.expr_ty(lhs);\n-        bot |= check_expr_has_type(fcx, rhs, lhs_type);\n+        check_expr_has_type(fcx, rhs, lhs_type);\n         fcx.write_ty(id, ty::mk_nil(fcx.ccx.tcx));\n-        return bot;\n+        // The callee checks for bot / err, we don't need to\n     }\n \n     // A generic function for doing all of the checking for call or\n@@ -1287,20 +1290,16 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             fn_ty: ty::t,\n                             expr: @ast::expr,\n                             args: &[@ast::expr],\n-                            bot: bool,\n-                            sugar: ast::CallSugar) -> bool\n+                            sugar: ast::CallSugar)\n     {\n-        let mut bot = bot;\n \n         // Call the generic checker.\n-        let (ret_ty, b) = check_call_inner(fcx, sp, call_expr_id,\n+        let ret_ty = check_call_inner(fcx, sp, call_expr_id,\n                                            fn_ty, expr, args, sugar,\n                                            DontDerefArgs);\n-        bot |= b;\n-\n         // Pull the return type out of the type of the function.\n         fcx.write_ty(call_expr_id, ret_ty);\n-        return bot;\n+        // Callee checks for bot and err, no need for that\n     }\n \n     // A generic function for doing all of the checking for call expressions\n@@ -1309,13 +1308,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   call_expr_id: ast::node_id,\n                   f: @ast::expr,\n                   args: &[@ast::expr],\n-                  sugar: ast::CallSugar)\n-               -> bool {\n+                  sugar: ast::CallSugar) {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n-        let mut bot = match f.node {\n-            ast::expr_field(base, field, ref tys) => {\n-                check_field(fcx, f, true, base, field, *tys)\n+        match f.node {\n+            ast::expr_field(ref base, ref field, ref tys) => {\n+                check_field(fcx, f, true, *base, *field, *tys)\n             }\n             _ => check_expr(fcx, f)\n         };\n@@ -1326,7 +1324,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              fcx.expr_ty(f),\n                              f,\n                              args,\n-                             bot,\n                              sugar)\n     }\n \n@@ -1337,9 +1334,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          method_name: ast::ident,\n                          args: &[@ast::expr],\n                          tps: &[@ast::Ty],\n-                         sugar: ast::CallSugar)\n-                      -> bool {\n-        let bot = check_expr(fcx, rcvr);\n+                         sugar: ast::CallSugar) {\n+        check_expr(fcx, rcvr);\n+        // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n                                                 expr.span,\n                                                 fcx.expr_ty(rcvr));\n@@ -1371,8 +1368,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   None);\n \n                 // Add error type for the result\n-                fcx.write_ty(expr.id, ty::mk_err(fcx.ccx.tcx));\n-                fcx.write_ty(expr.callee_id, ty::mk_err(fcx.ccx.tcx));\n+                fcx.write_error(expr.id);\n+                fcx.write_error(expr.callee_id);\n             }\n         }\n \n@@ -1382,50 +1379,33 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              fcx.node_ty(expr.callee_id),\n                              expr,\n                              args,\n-                             bot,\n                              sugar)\n     }\n \n-    // A generic function for checking for or for-each loops\n-    fn check_for(fcx: @mut FnCtxt,\n-                 local: @ast::local,\n-                 element_ty: ty::t,\n-                 body: &ast::blk,\n-                 node_id: ast::node_id)\n-              -> bool {\n-        let local_ty = fcx.local_ty(local.span, local.node.id);\n-        demand::suptype(fcx, local.span, local_ty, element_ty);\n-        let bot = check_decl_local(fcx, local);\n-        check_block_no_value(fcx, body);\n-        fcx.write_nil(node_id);\n-        return bot;\n-    }\n-\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @mut FnCtxt,\n                        thn: &ast::blk,\n                        elsopt: Option<@ast::expr>,\n                        id: ast::node_id,\n-                       _sp: span)\n-                    -> bool {\n-        let (if_t, if_bot) =\n+                       _sp: span) {\n+        let if_t =\n             match elsopt {\n                 Some(els) => {\n                     let if_t = fcx.infcx().next_ty_var();\n-                    let thn_bot = check_block(fcx, thn);\n+                    check_block(fcx, thn);\n                     let thn_t = fcx.node_ty(thn.node.id);\n                     demand::suptype(fcx, thn.span, if_t, thn_t);\n-                    let els_bot = check_expr_has_type(fcx, els, if_t);\n-                    (if_t, thn_bot & els_bot)\n+                    check_expr_has_type(fcx, els, if_t);\n+                    if_t\n                 }\n                 None => {\n                     check_block_no_value(fcx, thn);\n-                    (ty::mk_nil(fcx.ccx.tcx), false)\n+                    ty::mk_nil(fcx.ccx.tcx)\n                 }\n             };\n+\n         fcx.write_ty(id, if_t);\n-        return if_bot;\n     }\n \n     fn lookup_op_method(fcx: @mut FnCtxt,\n@@ -1435,32 +1415,34 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         opname: ast::ident,\n                         +args: ~[@ast::expr],\n                         +deref_args: DerefArgs,\n-                        +autoderef_receiver: AutoderefReceiverFlag)\n-                     -> Option<(ty::t, bool)> {\n-        match method::lookup(fcx,\n-                             op_ex,\n-                             self_ex,\n-                             op_ex.callee_id,\n-                             opname,\n-                             self_t,\n-                             ~[],\n-                             deref_args,\n-                             CheckTraitsOnly,\n-                             autoderef_receiver) {\n-          Some(ref origin) => {\n-              let method_ty = fcx.node_ty(op_ex.callee_id);\n-              let method_map = fcx.ccx.method_map;\n-              method_map.insert(op_ex.id, *origin);\n-              Some(check_call_inner(fcx,\n-                                    op_ex.span,\n-                                    op_ex.id,\n-                                    method_ty,\n-                                    op_ex,\n-                                    args,\n-                                    ast::NoSugar,\n-                                    deref_args))\n-          }\n-          _ => None\n+                        +autoderef_receiver: AutoderefReceiverFlag,\n+                        unbound_method: &fn(),\n+                        _expected_result: Option<ty::t>\n+                       )\n+                     -> ty::t {\n+        match method::lookup(fcx, op_ex, self_ex,\n+                             op_ex.callee_id, opname, self_t, ~[],\n+                             deref_args, CheckTraitsOnly, autoderef_receiver) {\n+            Some(ref origin) => {\n+                let method_ty = fcx.node_ty(op_ex.callee_id);\n+                let method_map = fcx.ccx.method_map;\n+                method_map.insert(op_ex.id, *origin);\n+                check_call_inner(fcx, op_ex.span,\n+                                 op_ex.id, method_ty,\n+                                 op_ex, args,\n+                                 ast::NoSugar, deref_args)\n+            }\n+            _ => {\n+                let tcx = fcx.tcx();\n+                unbound_method();\n+                // Check the args anyway\n+                // so we get all the error messages\n+                let expected_ty = ty::mk_err(tcx);\n+                check_call_inner(fcx, op_ex.span, op_ex.id,\n+                                 expected_ty, op_ex, args,\n+                                 ast::NoSugar, deref_args);\n+                ty::mk_err(tcx)\n+            }\n         }\n     }\n \n@@ -1469,27 +1451,30 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n                    op: ast::binop,\n                    lhs: @ast::expr,\n-                   rhs: @ast::expr)\n-                -> bool {\n+                   rhs: @ast::expr,\n+                   // Used only in the error case\n+                   expected_result: Option<ty::t>\n+                  ) {\n         let tcx = fcx.ccx.tcx;\n \n-        let lhs_bot = check_expr(fcx, lhs);\n-        let lhs_t = fcx.expr_ty(lhs);\n-        let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n+        check_expr(fcx, lhs);\n+        // Callee does bot / err checking\n+        let lhs_t = structurally_resolved_type(fcx, lhs.span,\n+                                               fcx.expr_ty(lhs));\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type\n-            let rhs_bot = check_expr(fcx, rhs);\n+            check_expr(fcx, rhs);\n             let rhs_t = fcx.expr_ty(rhs);\n             require_integral(fcx, rhs.span, rhs_t);\n             fcx.write_ty(expr.id, lhs_t);\n-            return lhs_bot | rhs_bot;\n+            return;\n         }\n \n         if ty::is_binopable(tcx, lhs_t, op) {\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n-            let rhs_bot = check_expr_has_type(fcx, rhs, tvar);\n+            check_expr_has_type(fcx, rhs, tvar);\n \n             let result_t = match op {\n                 ast::eq | ast::ne | ast::lt | ast::le | ast::ge |\n@@ -1502,56 +1487,55 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             };\n \n             fcx.write_ty(expr.id, result_t);\n-            return {\n-                if !ast_util::lazy_binop(op) { lhs_bot | rhs_bot }\n-                else { lhs_bot }\n-            };\n+            return;\n         }\n \n-        // A hack, but this prevents multiple errors for the same code\n-        // (since check_user_binop calls structurally_resolve_type)\n-        let (result, rhs_bot) =\n-           match ty::deref(fcx.tcx(), lhs_t, false).map(\n-                      |tt| structurally_resolved_type(fcx,\n-                                                      expr.span, tt.ty)) {\n-                Some(t) if ty::get(t).sty == ty::ty_err => (t, false),\n-                _ => check_user_binop(fcx, expr, lhs, lhs_t, op, rhs)\n-           };\n-        fcx.write_ty(expr.id, result);\n-        return lhs_bot | rhs_bot;\n+        if op == ast::or || op == ast::and {\n+            // This is an error; one of the operands must have the wrong\n+            // type\n+            fcx.write_error(expr.id);\n+            fcx.write_error(rhs.id);\n+            fcx.type_error_message(expr.span, |actual| {\n+                fmt!(\"binary operation %s cannot be applied \\\n+                      to type `%s`\",\n+                     ast_util::binop_to_str(op), actual)},\n+                                   lhs_t, None)\n+\n+        }\n+\n+        let result_t = check_user_binop(fcx, expr, lhs, lhs_t, op, rhs,\n+                                       expected_result);\n+        fcx.write_ty(expr.id, result_t);\n+        if ty::type_is_error(result_t) {\n+            fcx.write_ty(rhs.id, result_t);\n+        }\n     }\n \n     fn check_user_binop(fcx: @mut FnCtxt,\n                         ex: @ast::expr,\n                         lhs_expr: @ast::expr,\n                         lhs_resolved_t: ty::t,\n                         op: ast::binop,\n-                        rhs: @ast::expr)\n-                     -> (ty::t, bool) {\n+                        rhs: @ast::expr,\n+                       expected_result: Option<ty::t>) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n         match ast_util::binop_to_method_name(op) {\n-          Some(ref name) => {\n-            match lookup_op_method(fcx,\n-                                   ex,\n-                                   lhs_expr,\n-                                   lhs_resolved_t,\n-                                   fcx.tcx().sess.ident_of(copy *name),\n-                                   ~[rhs],\n-                                   DoDerefArgs,\n-                                   DontAutoderefReceiver) {\n-              Some(pair) => return pair,\n-              _ => ()\n+            Some(ref name) => {\n+                let if_op_unbound = || {\n+                    fcx.type_error_message(ex.span, |actual| {\n+                        fmt!(\"binary operation %s cannot be applied \\\n+                              to type `%s`\",\n+                             ast_util::binop_to_str(op), actual)},\n+                            lhs_resolved_t, None)\n+                };\n+                return lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n+                                       fcx.tcx().sess.ident_of(copy *name),\n+                                       ~[rhs], DoDerefArgs, DontAutoderefReceiver, if_op_unbound,\n+                                       expected_result);\n             }\n-          }\n-          _ => ()\n-        }\n+            None => ()\n+        };\n         check_expr(fcx, rhs);\n-        fcx.type_error_message(ex.span,\n-           |actual| {\n-               fmt!(\"binary operation %s cannot be applied to type `%s`\",\n-                    ast_util::binop_to_str(op), actual)\n-           },\n-           lhs_resolved_t, None);\n \n         // If the or operator is used it might be that the user forgot to\n         // supply the do keyword.  Let's be more helpful in that situation.\n@@ -1566,33 +1550,27 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         }\n \n-        (lhs_resolved_t, false)\n+        ty::mk_err(tcx)\n     }\n \n     fn check_user_unop(fcx: @mut FnCtxt,\n                        op_str: ~str,\n                        +mname: ~str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr,\n-                       rhs_t: ty::t)\n+                       rhs_t: ty::t,\n+                       expected_t: Option<ty::t>)\n                     -> ty::t {\n-        match lookup_op_method(fcx,\n-                               ex,\n-                               rhs_expr,\n-                               rhs_t,\n-                               fcx.tcx().sess.ident_of(mname),\n-                               ~[],\n-                               DontDerefArgs,\n-                               DontAutoderefReceiver) {\n-          Some((ret_ty, _)) => ret_ty,\n-          _ => {\n-              fcx.type_error_message(ex.span, |actual| {\n-                  fmt!(\"cannot apply unary operator `%s` to type `%s`\",\n-                              op_str, actual)\n-              }, rhs_t, None);\n-              rhs_t\n-          }\n-        }\n+       lookup_op_method(\n+            fcx, ex, rhs_expr, rhs_t,\n+            fcx.tcx().sess.ident_of(mname), ~[],\n+            DontDerefArgs, DontAutoderefReceiver,\n+            || {\n+                fcx.type_error_message(ex.span, |actual| {\n+                    fmt!(\"cannot apply unary operator `%s` to type `%s`\",\n+                         op_str, actual)\n+                }, rhs_t, None);\n+            }, expected_t)\n     }\n \n     // Resolves `expected` by a single level if it is a variable and passes it\n@@ -1632,6 +1610,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // block syntax lambdas; that is, lambdas without explicit\n         // sigils.\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n+        let mut error_happened = false;\n         let (expected_tys,\n              expected_purity,\n              expected_sigil,\n@@ -1646,6 +1625,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     (Some(sig), cenv.purity, cenv.sigil, cenv.onceness)\n                 }\n                 _ => {\n+                    // Not an error! Means we're inferring the closure type\n                     (None, ast::impure_fn, ast::BorrowedSigil, ast::Many)\n                 }\n             }\n@@ -1664,7 +1644,22 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             sigil, purity, expected_onceness,\n             None, decl, expected_tys, expr.span);\n \n-        let fty = ty::mk_closure(tcx, copy fn_ty);\n+        let mut fty_sig;\n+        let fty = if error_happened {\n+            fty_sig = FnSig {\n+                inputs: fn_ty.sig.inputs.map(|an_arg| {\n+                    arg { mode: an_arg.mode,\n+                         ty: ty::mk_err(tcx)\n+                        }}),\n+                output: ty::mk_err(tcx)\n+            };\n+            ty::mk_err(tcx)\n+        }\n+        else {\n+            let fn_ty_copy = copy fn_ty;\n+            fty_sig = copy fn_ty.sig;\n+            ty::mk_closure(tcx, fn_ty_copy)\n+        };\n \n         debug!(\"check_expr_fn_with_unifier %s fty=%s\",\n                fcx.expr_to_str(expr),\n@@ -1674,11 +1669,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         let inherited_purity =\n             ty::determine_inherited_purity(copy fcx.purity, purity,\n-                                           fn_ty.sigil);\n+                                           sigil);\n \n-        check_fn(fcx.ccx, None, inherited_purity,\n-                 &fn_ty.sig, decl, body, fn_kind,\n-                 fcx.in_scope_regions, fcx.inh);\n+        check_fn(fcx.ccx, None, inherited_purity, &fty_sig,\n+                 decl, body, fn_kind, fcx.in_scope_regions, fcx.inh);\n     }\n \n \n@@ -1688,10 +1682,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    is_callee: bool,\n                    base: @ast::expr,\n                    field: ast::ident,\n-                   tys: &[@ast::Ty])\n-                -> bool {\n+                   tys: &[@ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n-        let bot = check_expr(fcx, base);\n+        let mut bot = check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n         let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n@@ -1743,7 +1736,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         ~\"attempted to take value of method \\\n                           (try writing an anonymous function)\");\n                     // Add error type for the result\n-                    fcx.write_ty(expr.id, ty::mk_err(tcx));\n+                    fcx.write_error(expr.id);\n                 }\n             }\n             None => {\n@@ -1755,25 +1748,21 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   },\n                   expr_t, None);\n                 // Add error type for the result\n-                fcx.write_ty(expr.id, ty::mk_err(tcx));\n+                fcx.write_error(expr.id);\n             }\n         }\n \n-        return bot;\n     }\n \n     fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n                                       span: span,\n                                       class_id: ast::def_id,\n-                                      substitutions: &ty::substs,\n+                                      node_id: ast::node_id,\n+                                      +substitutions: ty::substs,\n                                       field_types: &[ty::field_ty],\n                                       ast_fields: &[ast::field],\n-                                      check_completeness: bool)\n-                                   -> bool {\n+                                      check_completeness: bool)  {\n         let tcx = fcx.ccx.tcx;\n-        let mut bot = false;\n-\n-        debug!(\"%? %?\", ast_fields.len(), field_types.len());\n \n         let class_field_map = HashMap();\n         let mut fields_found = 0;\n@@ -1782,38 +1771,49 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             class_field_map.insert(field.ident, (field.id, false));\n         }\n \n+        let mut error_happened = false;\n+\n         // Typecheck each field.\n         for ast_fields.each |field| {\n+            let mut expected_field_type = ty::mk_err(tcx);\n+\n             match class_field_map.find(&field.node.ident) {\n                 None => {\n                     tcx.sess.span_err(\n                         field.span,\n                         fmt!(\"structure has no field named `%s`\",\n                              *tcx.sess.str_of(field.node.ident)));\n+                    error_happened = true;\n                 }\n                 Some((_, true)) => {\n                     tcx.sess.span_err(\n                         field.span,\n                         fmt!(\"field `%s` specified more than once\",\n                              *tcx.sess.str_of(field.node.ident)));\n+                    error_happened = true;\n                 }\n                 Some((field_id, false)) => {\n-                    let expected_field_type =\n+                    expected_field_type =\n                         ty::lookup_field_type(\n-                            tcx, class_id, field_id, substitutions);\n-                    bot |=\n-                        check_expr_coercable_to_type(\n-                            fcx,\n-                            field.node.expr,\n-                            expected_field_type);\n+                            tcx, class_id, field_id, &substitutions);\n                     class_field_map.insert(\n                         field.node.ident, (field_id, true));\n                     fields_found += 1;\n                 }\n             }\n+            // Make sure to give a type to the field even if there's\n+            // an error, so we can continue typechecking\n+            check_expr_coercable_to_type(\n+                    fcx,\n+                    field.node.expr,\n+                    expected_field_type);\n+        }\n+\n+        if error_happened {\n+            fcx.write_error(node_id);\n         }\n \n-        if check_completeness {\n+        if check_completeness && !error_happened {\n             // Make sure the programmer specified all the fields.\n             fail_unless!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n@@ -1835,20 +1835,21 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            ~\"s\"\n                                        },\n                                        str::connect(missing_fields, ~\", \")));\n-            }\n+             }\n         }\n \n-        return bot;\n+        if !error_happened {\n+            fcx.write_ty(node_id, ty::mk_struct(fcx.ccx.tcx,\n+                                class_id, substitutions));\n+        }\n     }\n \n     fn check_struct_constructor(fcx: @mut FnCtxt,\n                                 id: ast::node_id,\n                                 span: codemap::span,\n                                 class_id: ast::def_id,\n                                 fields: &[ast::field],\n-                                base_expr: Option<@ast::expr>)\n-                             -> bool {\n-        let mut bot = false;\n+                                base_expr: Option<@ast::expr>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -1900,39 +1901,43 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             tps: type_parameters\n         };\n \n-        let struct_type = ty::subst(tcx, &substitutions, raw_type);\n+        let mut struct_type = ty::subst(tcx, &substitutions, raw_type);\n \n         // Look up and check the fields.\n         let class_fields = ty::lookup_struct_fields(tcx, class_id);\n-        bot = check_struct_or_variant_fields(fcx,\n-                                             span,\n-                                             class_id,\n-                                             &substitutions,\n-                                             class_fields,\n-                                             fields,\n-                                             base_expr.is_none()) || bot;\n+        check_struct_or_variant_fields(fcx,\n+                                           span,\n+                                           class_id,\n+                                           id,\n+                                           substitutions,\n+                                           class_fields,\n+                                           fields,\n+                                           base_expr.is_none());\n+        if ty::type_is_error(fcx.node_ty(id)) {\n+            struct_type = ty::mk_err(tcx);\n+        }\n \n         // Check the base expression if necessary.\n         match base_expr {\n             None => {}\n             Some(base_expr) => {\n-                bot = check_expr_has_type(fcx, base_expr, struct_type) || bot\n+                check_expr_has_type(fcx, base_expr, struct_type);\n+                if ty::type_is_bot(fcx.node_ty(base_expr.id)) {\n+                    struct_type = ty::mk_bot(tcx);\n+                }\n             }\n         }\n \n         // Write in the resulting type.\n         fcx.write_ty(id, struct_type);\n-        return bot;\n     }\n \n     fn check_struct_enum_variant(fcx: @mut FnCtxt,\n                                  id: ast::node_id,\n                                  span: codemap::span,\n                                  enum_id: ast::def_id,\n                                  variant_id: ast::def_id,\n-                                 fields: &[ast::field])\n-                              -> bool {\n-        let mut bot = false;\n+                                 fields: &[ast::field]) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -1988,17 +1993,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Look up and check the enum variant fields.\n         let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n-        bot = check_struct_or_variant_fields(fcx,\n-                                             span,\n-                                             variant_id,\n-                                             &substitutions,\n-                                             variant_fields,\n-                                             fields,\n-                                             true) || bot;\n-\n-        // Write in the resulting type.\n+        check_struct_or_variant_fields(fcx,\n+                                       span,\n+                                       variant_id,\n+                                       id,\n+                                       substitutions,\n+                                       variant_fields,\n+                                       fields,\n+                                       true);\n         fcx.write_ty(id, enum_type);\n-        return bot;\n     }\n \n     fn check_loop_body(fcx: @mut FnCtxt,\n@@ -2046,15 +2049,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             fty.sig.output,\n                             None);\n                         err_happened = true;\n-\n-                        // Kind of a hack: create a function type with\n-                        // the result replaced with ty_err, to\n-                        // suppress derived errors.\n-                        let t = ty::replace_closure_return_type(\n-                            tcx, ty::mk_closure(tcx, copy *fty),\n-                            ty::mk_err(tcx));\n-                        fcx.write_ty(expr.id, ty::mk_err(tcx));\n-                        t\n+                        fcx.write_error(expr.id);\n+                        ty::mk_err(tcx)\n                     }\n                 }\n             }\n@@ -2070,7 +2066,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             },\n                             expected_t, None);\n                         let err_ty = ty::mk_err(tcx);\n-                        fcx.write_ty(expr.id, err_ty);\n+                        fcx.write_error(expr.id);\n                         err_happened = true;\n                         err_ty\n                     }\n@@ -2110,7 +2106,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(loop_body.id));\n         if err_happened {\n-            fcx.write_ty(expr.id, ty::mk_err(fcx.tcx()));\n+            fcx.write_error(expr.id);\n+            fcx.write_error(loop_body.id);\n         } else {\n             let loop_body_ty =\n                 ty::replace_closure_return_type(\n@@ -2121,34 +2118,61 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n-    let mut bot = false;\n     match expr.node {\n       ast::expr_vstore(ev, vst) => {\n         let typ = match ev.node {\n           ast::expr_lit(@codemap::spanned { node: ast::lit_str(s), _ }) => {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(*s), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, s.len(), vst);\n             ty::mk_estr(tcx, tt)\n           }\n           ast::expr_vec(ref args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, args.len(), vst);\n             let mutability;\n+            let mut any_error = false;\n+            let mut any_bot = false;\n             match vst {\n                 ast::expr_vstore_mut_box | ast::expr_vstore_mut_slice => {\n                     mutability = ast::m_mutbl\n                 }\n                 _ => mutability = mutbl\n             }\n             let t: ty::t = fcx.infcx().next_ty_var();\n-            for args.each |e| { bot |= check_expr_has_type(fcx, *e, t); }\n-            ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n+            for args.each |e| {\n+                check_expr_has_type(fcx, *e, t);\n+                let arg_t = fcx.expr_ty(*e);\n+                if ty::type_is_error(arg_t) {\n+                    any_error = true;\n+                }\n+                else if ty::type_is_bot(arg_t) {\n+                    any_bot = true;\n+                }\n+            }\n+            if any_error {\n+                ty::mk_err(tcx)\n+            }\n+            else if any_bot {\n+                ty::mk_bot(tcx)\n+            }\n+            else {\n+                ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n+            }\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n             let count = ty::eval_repeat_count(tcx, count_expr);\n             check_expr_with_hint(fcx, count_expr, ty::mk_uint(tcx));\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n             let t: ty::t = fcx.infcx().next_ty_var();\n-            bot |= check_expr_has_type(fcx, element, t);\n-            ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl}, tt)\n+            check_expr_has_type(fcx, element, t);\n+            let arg_t = fcx.expr_ty(element);\n+            if ty::type_is_error(arg_t) {\n+                ty::mk_err(tcx)\n+            }\n+            else if ty::type_is_bot(arg_t) {\n+                ty::mk_bot(tcx)\n+            }\n+            else {\n+                ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl}, tt)\n+            }\n           }\n           _ =>\n             tcx.sess.span_bug(expr.span, ~\"vstore modifier on non-sequence\")\n@@ -2162,18 +2186,31 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_binary(op, lhs, rhs) => {\n-        bot |= check_binop(fcx, expr, op, lhs, rhs);\n+        check_binop(fcx, expr, op, lhs, rhs, expected);\n+        let lhs_ty = fcx.expr_ty(lhs);\n+        let rhs_ty = fcx.expr_ty(rhs);\n+        if ty::type_is_error(lhs_ty) ||\n+            ty::type_is_error(rhs_ty) {\n+            fcx.write_error(id);\n+        }\n+        else if ty::type_is_bot(lhs_ty) ||\n+          (ty::type_is_bot(rhs_ty) && !ast_util::lazy_binop(op)) {\n+            fcx.write_bot(id);\n+        }\n       }\n       ast::expr_assign_op(op, lhs, rhs) => {\n-        bot |= check_binop(fcx, expr, op, lhs, rhs);\n+        check_binop(fcx, expr, op, lhs, rhs, expected);\n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n         demand::suptype(fcx, expr.span, result_t, lhs_t);\n \n         // Overwrite result of check_binop...this preserves existing behavior\n         // but seems quite dubious with regard to user-defined methods\n         // and so forth. - Niko\n-        fcx.write_nil(expr.id);\n+        if !ty::type_is_error(result_t)\n+            && !ty::type_is_bot(result_t) {\n+            fcx.write_nil(expr.id);\n+        }\n       }\n       ast::expr_unary(unop, oprnd) => {\n         let exp_inner = do unpack_expected(fcx, expected) |sty| {\n@@ -2186,75 +2223,82 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n               ast::deref => None\n             }\n         };\n-        bot = check_expr_with_opt_hint(fcx, oprnd, exp_inner);\n+        check_expr_with_opt_hint(fcx, oprnd, exp_inner);\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n-        match unop {\n-          ast::box(mutbl) => {\n-            oprnd_t = ty::mk_box(tcx, ty::mt {ty: oprnd_t, mutbl: mutbl});\n-          }\n-          ast::uniq(mutbl) => {\n-            oprnd_t = ty::mk_uniq(tcx, ty::mt {ty: oprnd_t, mutbl: mutbl});\n-          }\n-          ast::deref => {\n-            let sty = structure_of(fcx, expr.span, oprnd_t);\n-\n-            match sty {\n-              // deref'ing an unsafe pointer requires that we be in an unsafe\n-              // context\n-              ty::ty_ptr(*) => {\n-                fcx.require_unsafe(\n-                    expr.span,\n-                    ~\"dereference of unsafe pointer\");\n-              }\n-              _ => { /*ok*/ }\n-            }\n-\n-            let operand_ty = ty::deref_sty(tcx, &sty, true);\n-\n-            match operand_ty {\n-              Some(mt) => {\n-                  oprnd_t = mt.ty\n-              }\n-              None => {\n-                match sty {\n-                  ty::ty_enum(*) => {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        ~\"can only dereference enums \\\n-                         with a single variant which has a \\\n-                         single argument\");\n-                  }\n-                  ty::ty_struct(*) => {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        ~\"can only dereference structs with one anonymous \\\n-                          field\");\n-                  }\n-                  _ => {\n-                      fcx.type_error_message(expr.span, |actual| {\n-                          fmt!(\"type %s cannot be dereferenced\", actual)\n-                      }, oprnd_t, None);\n-                  }\n+        if !ty::type_is_error(oprnd_t) &&\n+              !ty::type_is_bot(oprnd_t) {\n+            match unop {\n+                ast::box(mutbl) => {\n+                    oprnd_t = ty::mk_box(tcx,\n+                                         ty::mt {ty: oprnd_t, mutbl: mutbl});\n+                }\n+                ast::uniq(mutbl) => {\n+                    oprnd_t = ty::mk_uniq(tcx,\n+                                          ty::mt {ty: oprnd_t, mutbl: mutbl});\n+                }\n+                ast::deref => {\n+                    let sty = structure_of(fcx, expr.span, oprnd_t);\n+                    match sty {\n+                        // deref'ing an unsafe pointer requires that we be in\n+                        // an unsafe context\n+                        ty::ty_ptr(*) => {\n+                            fcx.require_unsafe(\n+                                expr.span,\n+                                ~\"dereference of unsafe pointer\");\n+                        }\n+                        _ => { /*ok*/ }\n+                    }\n+                    let operand_ty = ty::deref_sty(tcx, &sty, true);\n+                    match operand_ty {\n+                        Some(mt) => {\n+                            oprnd_t = mt.ty\n+                        }\n+                        None => {\n+                            match sty {\n+                                ty::ty_enum(*) => {\n+                                    tcx.sess.span_err(\n+                                        expr.span,\n+                                        ~\"can only dereference enums \\\n+                                          with a single variant which has a \\\n+                                          single argument\");\n+                                }\n+                                ty::ty_struct(*) => {\n+                                    tcx.sess.span_err(\n+                                        expr.span,\n+                                        ~\"can only dereference structs with \\\n+                                          one anonymous field\");\n+                                }\n+                                _ => {\n+                                    fcx.type_error_message(expr.span,\n+                                        |actual| {\n+                                            fmt!(\"type %s cannot be \\\n+                                                  dereferenced\", actual)\n+                                    }, oprnd_t, None);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                ast::not => {\n+                    oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n+                                                         oprnd_t);\n+                    if !(ty::type_is_integral(oprnd_t) ||\n+                         ty::get(oprnd_t).sty == ty::ty_bool) {\n+                        oprnd_t = check_user_unop(fcx,\n+                            ~\"!\", ~\"not\", expr, oprnd, oprnd_t,\n+                                                  expected);\n+                    }\n+                }\n+                ast::neg => {\n+                    oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n+                                                         oprnd_t);\n+                    if !(ty::type_is_integral(oprnd_t) ||\n+                         ty::type_is_fp(oprnd_t)) {\n+                        oprnd_t = check_user_unop(fcx,\n+                            ~\"-\", ~\"neg\", expr, oprnd, oprnd_t, expected);\n+                    }\n                 }\n-              }\n-            }\n-          }\n-          ast::not => {\n-            oprnd_t = structurally_resolved_type(fcx, oprnd.span, oprnd_t);\n-            if !(ty::type_is_integral(oprnd_t) ||\n-                 ty::get(oprnd_t).sty == ty::ty_bool) {\n-                oprnd_t = check_user_unop(fcx, ~\"!\", ~\"not\", expr,\n-                                         oprnd, oprnd_t);\n-            }\n-          }\n-          ast::neg => {\n-            oprnd_t = structurally_resolved_type(fcx, oprnd.span, oprnd_t);\n-            if !(ty::type_is_integral(oprnd_t) ||\n-                 ty::type_is_fp(oprnd_t)) {\n-                oprnd_t = check_user_unop(fcx, ~\"-\", ~\"neg\", expr,\n-                                         oprnd, oprnd_t);\n             }\n-          }\n         }\n         fcx.write_ty(id, oprnd_t);\n       }\n@@ -2263,7 +2307,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n               fcx, expected,\n               |sty| match *sty { ty::ty_rptr(_, ref mt) => Some(mt.ty),\n                                  _ => None });\n-        bot = check_expr_with_opt_hint(fcx, oprnd, hint);\n+        check_expr_with_opt_hint(fcx, oprnd, hint);\n \n         // Note: at this point, we cannot say what the best lifetime\n         // is to use for resulting pointer.  We want to use the\n@@ -2282,7 +2326,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let region = fcx.infcx().next_region_var(expr.span, expr.id);\n \n         let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n-        let oprnd_t = ty::mk_rptr(tcx, region, tm);\n+        let oprnd_t = if ty::type_is_error(tm.ty) {\n+            ty::mk_err(tcx)\n+        } else if ty::type_is_bot(tm.ty) {\n+            ty::mk_bot(tcx)\n+        }\n+        else {\n+            ty::mk_rptr(tcx, region, tm)\n+        };\n         fcx.write_ty(id, oprnd_t);\n       }\n       ast::expr_path(pth) => {\n@@ -2304,10 +2355,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           fcx.write_nil(id);\n       }\n       ast::expr_mac(_) => tcx.sess.bug(~\"unexpanded macro\"),\n-      ast::expr_break(_) => { fcx.write_bot(id); bot = true; }\n-      ast::expr_again(_) => { fcx.write_bot(id); bot = true; }\n+      ast::expr_break(_) => { fcx.write_bot(id); }\n+      ast::expr_again(_) => { fcx.write_bot(id); }\n       ast::expr_ret(expr_opt) => {\n-        bot = true;\n         let ret_ty = match fcx.indirect_ret_ty {\n           Some(t) =>  t, None => fcx.ret_ty\n         };\n@@ -2328,43 +2378,124 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_bot(id);\n       }\n       ast::expr_log(_, lv, e) => {\n-        bot = check_expr_has_type(fcx, lv,\n+        check_expr_has_type(fcx, lv,\n                                   ty::mk_mach_uint(tcx, ast::ty_u32));\n \n         // Note: this does not always execute, so do not propagate bot:\n         check_expr(fcx, e);\n-        fcx.write_nil(id);\n+        if ty::type_is_error(fcx.expr_ty(e)) {\n+            fcx.write_error(id);\n+        }\n+        else {\n+            fcx.write_nil(id);\n+        }\n       }\n       ast::expr_copy(a) => {\n-        bot = check_expr_with_opt_hint(fcx, a, expected);\n+        check_expr_with_opt_hint(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_paren(a) => {\n-        bot = check_expr_with_opt_hint(fcx, a, expected);\n+        check_expr_with_opt_hint(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_assign(lhs, rhs) => {\n-        bot = check_assignment(fcx, lhs, rhs, id);\n+        check_assignment(fcx, lhs, rhs, id);\n+        let lhs_ty = fcx.expr_ty(lhs);\n+        let rhs_ty = fcx.expr_ty(rhs);\n+        if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n+            fcx.write_error(id);\n+        }\n+        else if ty::type_is_bot(lhs_ty) || ty::type_is_bot(rhs_ty) {\n+            fcx.write_bot(id);\n+        }\n+        else {\n+            fcx.write_nil(id);\n+        }\n       }\n       ast::expr_swap(lhs, rhs) => {\n-        bot = check_assignment(fcx, lhs, rhs, id);\n+        check_assignment(fcx, lhs, rhs, id);\n+        let lhs_ty = fcx.expr_ty(lhs);\n+        let rhs_ty = fcx.expr_ty(rhs);\n+        if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n+            fcx.write_error(id);\n+        }\n+        else if ty::type_is_bot(lhs_ty) || ty::type_is_bot(rhs_ty) {\n+            fcx.write_bot(id);\n+        }\n+        else {\n+            fcx.write_nil(id);\n+        }\n       }\n       ast::expr_if(cond, ref thn, elsopt) => {\n-        bot = check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n-        bot |= check_then_else(fcx, thn, elsopt, id, expr.span);\n+        check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n+        check_then_else(fcx, thn, elsopt, id, expr.span);\n+        let cond_ty = fcx.expr_ty(cond);\n+        let then_ty = fcx.node_ty(thn.node.id);\n+        let else_is_bot = elsopt.map_default(false, |els| {\n+              ty::type_is_bot(fcx.expr_ty(*els))});\n+        if ty::type_is_error(cond_ty) || ty::type_is_error(then_ty) {\n+            fcx.write_error(id);\n+        }\n+        else if elsopt.map_default(false, |els| {\n+            ty::type_is_error(fcx.expr_ty(*els)) }) {\n+            fcx.write_error(id);\n+        }\n+        else if ty::type_is_bot(cond_ty) ||\n+            (ty::type_is_bot(then_ty) && else_is_bot) {\n+            fcx.write_bot(id);\n+        }\n+          // Other cases were handled by check_then_else\n       }\n       ast::expr_while(cond, ref body) => {\n-        bot = check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n+        check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n         check_block_no_value(fcx, body);\n-        fcx.write_ty(id, ty::mk_nil(tcx));\n+        let cond_ty = fcx.expr_ty(cond);\n+        let body_ty = fcx.node_ty(body.node.id);\n+        if ty::type_is_error(cond_ty) || ty::type_is_error(body_ty) {\n+            fcx.write_error(id);\n+        }\n+        else if ty::type_is_bot(cond_ty) {\n+            fcx.write_bot(id);\n+        }\n+        else {\n+            fcx.write_nil(id);\n+        }\n       }\n       ast::expr_loop(ref body, _) => {\n-        check_block_no_value(fcx, body);\n-        fcx.write_ty(id, ty::mk_nil(tcx));\n-        bot = !may_break(tcx, expr.id, body);\n+        check_block_no_value(fcx, (body));\n+        if !may_break(tcx, expr.id, body) {\n+            fcx.write_bot(id);\n+        }\n+        else {\n+            fcx.write_nil(id);\n+        }\n       }\n       ast::expr_match(discrim, ref arms) => {\n-        bot = _match::check_match(fcx, expr, discrim, *arms);\n+        _match::check_match(fcx, expr, discrim, *arms);\n+        let discrim_ty = fcx.expr_ty(discrim);\n+        let arm_tys = arms.map(|a| fcx.node_ty(a.body.node.id));\n+        if ty::type_is_error(discrim_ty) ||\n+            arm_tys.any(|t| ty::type_is_error(*t)) {\n+            fcx.write_error(id);\n+        }\n+        // keep in mind that `all` returns true in the empty vec case,\n+        // which is what we want\n+        else if ty::type_is_bot(discrim_ty) ||\n+            arm_tys.all(|t| ty::type_is_bot(*t)) {\n+            fcx.write_bot(id);\n+        }\n+        else {\n+            // Find the first non-_|_ arm.\n+            // We know there's at least one because we already checked\n+            // for n=0 as well as all arms being _|_ in the previous\n+            // `if`.\n+            for arm_tys.each() |arm_ty| {\n+                if !ty::type_is_bot(*arm_ty) {\n+                    fcx.write_ty(id, *arm_ty);\n+                    break;\n+                }\n+            }\n+        }\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n@@ -2407,105 +2538,144 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(expr.id, fcx.node_ty(b.id));\n       }\n       ast::expr_block(ref b) => {\n-        // If this is an unchecked block, turn off purity-checking\n-        bot = check_block_with_expected(fcx, b, expected);\n-        let typ =\n-            match b.node.expr {\n-              Some(expr) => fcx.expr_ty(expr),\n-              None => ty::mk_nil(tcx)\n-            };\n-        fcx.write_ty(id, typ);\n+        check_block_with_expected(fcx, b, expected);\n+        fcx.write_ty(id, fcx.node_ty(b.node.id));\n       }\n       ast::expr_call(f, ref args, sugar) => {\n-        bot = check_call(fcx, expr.span, expr.id, f, *args, sugar);\n+          check_call(fcx, expr.span, expr.id, f, *args, sugar);\n+          let f_ty = fcx.expr_ty(f);\n+          let (args_bot, args_err) = args.foldl((false, false),\n+             |&(rest_bot, rest_err), a| {\n+                 // is this not working?\n+                 let a_ty = fcx.expr_ty(*a);\n+                 (rest_bot || ty::type_is_bot(a_ty),\n+                  rest_err || ty::type_is_error(a_ty))});\n+          if ty::type_is_error(f_ty) || args_err {\n+              fcx.write_error(id);\n+          }\n+          else if ty::type_is_bot(f_ty) || args_bot {\n+              fcx.write_bot(id);\n+          }\n       }\n       ast::expr_method_call(rcvr, ident, ref tps, ref args, sugar) => {\n-        bot = check_method_call(fcx, expr, rcvr, ident, *args, *tps, sugar);\n+        check_method_call(fcx, expr, rcvr, ident, *args, *tps, sugar);\n+        let f_ty = fcx.expr_ty(rcvr);\n+        let arg_tys = args.map(|a| fcx.expr_ty(*a));\n+        let (args_bot, args_err) = arg_tys.foldl((false, false),\n+             |&(rest_bot, rest_err), a| {\n+              (rest_bot || ty::type_is_bot(*a),\n+               rest_err || ty::type_is_error(*a))});\n+        if ty::type_is_error(f_ty) || args_err {\n+            fcx.write_error(id);\n+        }\n+        else if ty::type_is_bot(f_ty) || args_bot {\n+            fcx.write_bot(id);\n+        }\n       }\n       ast::expr_cast(e, t) => {\n-        bot = check_expr(fcx, e);\n+        check_expr(fcx, e);\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n         debug!(\"t_1=%s\", fcx.infcx().ty_to_str(t_1));\n         debug!(\"t_e=%s\", fcx.infcx().ty_to_str(t_e));\n \n-        match ty::get(t_1).sty {\n-          // This will be looked up later on\n-          ty::ty_trait(*) => (),\n+        if ty::type_is_error(t_e) {\n+            fcx.write_error(id);\n+        }\n+        else if ty::type_is_bot(t_e) {\n+            fcx.write_bot(id);\n+        }\n+        else {\n+            match ty::get(t_1).sty {\n+                // This will be looked up later on\n+                ty::ty_trait(*) => (),\n \n-          _ => {\n-            if ty::type_is_nil(t_e) {\n-                fcx.type_error_message(expr.span, |actual| {\n-                    fmt!(\"cast from nil: `%s` as `%s`\", actual,\n-                         fcx.infcx().ty_to_str(t_1))\n-                }, t_e, None);\n-            } else if ty::type_is_nil(t_1) {\n-                fcx.type_error_message(expr.span, |actual| {\n-                    fmt!(\"cast to nil: `%s` as `%s`\", actual,\n-                         fcx.infcx().ty_to_str(t_1))\n-                }, t_e, None);\n-            }\n-\n-            let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n-            if type_is_c_like_enum(fcx,expr.span,t_e) && t_1_is_scalar {\n-                /* this case is allowed */\n-            } else if type_is_region_ptr(fcx, expr.span, t_e) &&\n-                      type_is_unsafe_ptr(fcx, expr.span, t_1) {\n-\n-                fn is_vec(t: ty::t) -> bool {\n-                    match ty::get(t).sty {\n-                      ty::ty_evec(_,_) => true,\n-                      _ => false\n-                    }\n-                }\n-                fn types_compatible(fcx: @mut FnCtxt, sp: span, t1: ty::t,\n-                                    t2: ty::t) -> bool {\n-                    if !is_vec(t1) {\n-                        false\n-                    } else {\n-                        let el = ty::sequence_element_type(fcx.tcx(), t1);\n-                        infer::mk_eqty(fcx.infcx(), false, sp, el, t2).is_ok()\n+                _ => {\n+                    if ty::type_is_nil(t_e) {\n+                        fcx.type_error_message(expr.span, |actual| {\n+                            fmt!(\"cast from nil: `%s` as `%s`\", actual,\n+                                 fcx.infcx().ty_to_str(t_1))\n+                        }, t_e, None);\n+                    } else if ty::type_is_nil(t_1) {\n+                        fcx.type_error_message(expr.span, |actual| {\n+                            fmt!(\"cast to nil: `%s` as `%s`\", actual,\n+                                 fcx.infcx().ty_to_str(t_1))\n+                        }, t_e, None);\n                     }\n-                }\n \n-                // Due to the limitations of LLVM global constants,\n-                // region pointers end up pointing at copies of\n-                // vector elements instead of the original values.\n-                // To allow unsafe pointers to work correctly, we\n-                // need to special-case obtaining an unsafe pointer\n-                // from a region pointer to a vector.\n-\n-                /* this cast is only allowed from &[T] to *T or\n-                   &T to *T. */\n-                let te = structurally_resolved_type(fcx, e.span, t_e);\n-                match (&ty::get(te).sty, &ty::get(t_1).sty) {\n-                  (&ty::ty_rptr(_, mt1), &ty::ty_ptr(mt2))\n-                    if types_compatible(fcx, e.span, mt1.ty, mt2.ty) => {\n-                      /* this case is allowed */\n-                  }\n-                  _ => {\n-                    demand::coerce(fcx, e.span, t_1, e);\n-                  }\n+                    let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n+                    if type_is_c_like_enum(fcx,expr.span,t_e)\n+                        && t_1_is_scalar {\n+                        /* this case is allowed */\n+                    } else if type_is_region_ptr(fcx, expr.span, t_e) &&\n+                        type_is_unsafe_ptr(fcx, expr.span, t_1) {\n+\n+                        fn is_vec(t: ty::t) -> bool {\n+                            match ty::get(t).sty {\n+                                ty::ty_evec(_,_) => true,\n+                                _ => false\n+                            }\n+                        }\n+                        fn types_compatible(fcx: @mut FnCtxt, sp: span,\n+                                            t1: ty::t, t2: ty::t) -> bool {\n+                            if !is_vec(t1) {\n+                                false\n+                            } else {\n+                                let el = ty::sequence_element_type(fcx.tcx(),\n+                                                                   t1);\n+                                infer::mk_eqty(fcx.infcx(), false,\n+                                               sp, el, t2).is_ok()\n+                            }\n+                        }\n+\n+                        // Due to the limitations of LLVM global constants,\n+                        // region pointers end up pointing at copies of\n+                        // vector elements instead of the original values.\n+                        // To allow unsafe pointers to work correctly, we\n+                        // need to special-case obtaining an unsafe pointer\n+                        // from a region pointer to a vector.\n+\n+                        /* this cast is only allowed from &[T] to *T or\n+                        &T to *T. */\n+                        let te = structurally_resolved_type(fcx, e.span, t_e);\n+                        match (&ty::get(te).sty, &ty::get(t_1).sty) {\n+                            (&ty::ty_rptr(_, mt1), &ty::ty_ptr(mt2))\n+                            if types_compatible(fcx, e.span,\n+                                                mt1.ty, mt2.ty) => {\n+                                /* this case is allowed */\n+                            }\n+                            _ => {\n+                                demand::coerce(fcx, e.span, t_1, e);\n+                            }\n+                        }\n+                    } else if !(type_is_scalar(fcx,expr.span,t_e)\n+                                && t_1_is_scalar) {\n+                        /*\n+                        If more type combinations should be supported than are\n+                        supported here, then file an enhancement issue and\n+                        record the issue number in this comment.\n+                        */\n+                        fcx.type_error_message(expr.span, |actual| {\n+                            fmt!(\"non-scalar cast: `%s` as `%s`\", actual,\n+                                 fcx.infcx().ty_to_str(t_1))\n+                        }, t_e, None);\n+                    }\n                 }\n-            } else if !(type_is_scalar(fcx,expr.span,t_e) && t_1_is_scalar) {\n-                /*\n-                If more type combinations should be supported than are\n-                supported here, then file an enhancement issue and record the\n-                issue number in this comment.\n-                */\n-                fcx.type_error_message(expr.span, |actual| {\n-                    fmt!(\"non-scalar cast: `%s` as `%s`\", actual,\n-                         fcx.infcx().ty_to_str(t_1))\n-                }, t_e, None);\n             }\n-          }\n+            fcx.write_ty(id, t_1);\n         }\n-        fcx.write_ty(id, t_1);\n       }\n       ast::expr_vec(ref args, mutbl) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n-        for args.each |e| { bot |= check_expr_has_type(fcx, *e, t); }\n+        let mut arg_is_bot = false;\n+        let mut arg_is_err = false;\n+        for args.each |e| {\n+            check_expr_has_type(fcx, *e, t);\n+            let arg_t = fcx.expr_ty(*e);\n+            arg_is_bot |= ty::type_is_bot(arg_t);\n+            arg_is_err |= ty::type_is_error(arg_t);\n+        }\n         let typ = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n                               ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n@@ -2514,21 +2684,43 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let count = ty::eval_repeat_count(tcx, count_expr);\n         check_expr_with_hint(fcx, count_expr, ty::mk_uint(tcx));\n         let t: ty::t = fcx.infcx().next_ty_var();\n-        bot |= check_expr_has_type(fcx, element, t);\n-        let t = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n-                            ty::vstore_fixed(count));\n-        fcx.write_ty(id, t);\n+        check_expr_has_type(fcx, element, t);\n+        let element_ty = fcx.expr_ty(element);\n+        if ty::type_is_error(element_ty) {\n+            fcx.write_error(id);\n+        }\n+        else if ty::type_is_bot(element_ty) {\n+            fcx.write_bot(id);\n+        }\n+        else {\n+            let t = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n+                                ty::vstore_fixed(count));\n+            fcx.write_ty(id, t);\n+        }\n       }\n       ast::expr_tup(ref elts) => {\n         let flds = unpack_expected(fcx, expected, |sty| {\n             match *sty { ty::ty_tup(ref flds) => Some(copy *flds), _ => None }\n         });\n+        let mut bot_field = false;\n+        let mut err_field = false;\n         let elt_ts = do elts.mapi |i, e| {\n             check_expr_with_opt_hint(fcx, *e, flds.map(|fs| fs[i]));\n-            fcx.expr_ty(*e)\n+            let t = fcx.expr_ty(*e);\n+            err_field = err_field || ty::type_is_error(t);\n+            bot_field = bot_field || ty::type_is_bot(t);\n+            t\n         };\n-        let typ = ty::mk_tup(tcx, elt_ts);\n-        fcx.write_ty(id, typ);\n+        if bot_field {\n+            fcx.write_bot(id);\n+        }\n+        else if err_field {\n+            fcx.write_error(id);\n+        }\n+        else {\n+            let typ = ty::mk_tup(tcx, elt_ts);\n+            fcx.write_ty(id, typ);\n+        }\n       }\n       ast::expr_struct(path, ref fields, base_expr) => {\n         // Resolve the path.\n@@ -2548,48 +2740,57 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::expr_field(base, field, ref tys) => {\n-        bot = check_field(fcx, expr, false, base, field, *tys);\n+          check_field(fcx, expr, false, base, field, * tys);\n+          let base_t = fcx.expr_ty(base);\n+          if ty::type_is_error(base_t) {\n+              fcx.write_error(id);\n+          }\n+          else if ty::type_is_bot(base_t) {\n+              fcx.write_bot(id);\n+          }\n+          // Otherwise, type already got written\n       }\n       ast::expr_index(base, idx) => {\n-          bot |= check_expr(fcx, base);\n+          check_expr(fcx, base);\n+          check_expr(fcx, idx);\n           let raw_base_t = fcx.expr_ty(base);\n-          let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n-          bot |= check_expr(fcx, idx);\n           let idx_t = fcx.expr_ty(idx);\n-          let base_sty = structure_of(fcx, expr.span, base_t);\n-          match ty::index_sty(tcx, &base_sty) {\n-              Some(mt) => {\n-                  require_integral(fcx, idx.span, idx_t);\n-                  fcx.write_ty(id, mt.ty);\n-                  fcx.write_autoderef_adjustment(base.id, derefs);\n-              }\n-              None => {\n-                  let resolved = structurally_resolved_type(fcx, expr.span,\n-                                                            raw_base_t);\n-                  match lookup_op_method(fcx,\n-                                         expr,\n-                                         base,\n-                                         resolved,\n-                                         tcx.sess.ident_of(~\"index\"),\n-                                         ~[idx],\n-                                         DontDerefArgs,\n-                                         AutoderefReceiver) {\n-                      Some((ret_ty, _)) => fcx.write_ty(id, ret_ty),\n-                      _ => {\n-                          fcx.type_error_message(expr.span, |actual|\n-                              fmt!(\"cannot index a value of type `%s`\",\n-                                   actual), base_t, None);\n-                          fcx.write_ty(id, ty::mk_err(tcx));\n-                          return true;\n-                      }\n+          if ty::type_is_error(raw_base_t)\n+              || ty::type_is_bot(raw_base_t) {\n+              fcx.write_ty(id, raw_base_t);\n+          }\n+          else if ty::type_is_error(idx_t)\n+              || ty::type_is_bot(idx_t) {\n+              fcx.write_ty(id, idx_t);\n+          }\n+          else {\n+              let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n+              let base_sty = structure_of(fcx, expr.span, base_t);\n+              match ty::index_sty(tcx, &base_sty) {\n+                  Some(mt) => {\n+                      require_integral(fcx, idx.span, idx_t);\n+                      fcx.write_ty(id, mt.ty);\n+                      fcx.write_autoderef_adjustment(base.id, derefs);\n+                  }\n+                  None => {\n+                      let resolved = structurally_resolved_type(fcx,\n+                          expr.span, raw_base_t);\n+                      let ret_ty = lookup_op_method(fcx, expr, base, resolved,\n+                                             tcx.sess.ident_of(~\"index\"),\n+                                             ~[idx], DontDerefArgs, AutoderefReceiver,\n+                        || {\n+                            fcx.type_error_message(expr.span, |actual|\n+                                fmt!(\"cannot index a value \\\n+                                      of type `%s`\", actual), base_t, None);\n+                        }, expected);\n+                      fcx.write_ty(id, ret_ty);\n                   }\n               }\n           }\n-      }\n+       }\n     }\n-    if bot { fcx.write_bot(expr.id); }\n \n-    debug!(\"type of expr %s is...\",\n+    debug!(\"type of expr(%d) %s is...\", expr.id,\n            syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()));\n     debug!(\"... %s, expected is %s\",\n            ppaux::ty_to_str(tcx, fcx.expr_ty(expr)),\n@@ -2599,9 +2800,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n            });\n \n     unifier();\n-\n-    debug!(\"<< bot=%b\", bot);\n-    return bot;\n }\n \n pub fn require_integral(fcx: @mut FnCtxt, sp: span, t: ty::t) {\n@@ -2616,21 +2814,24 @@ pub fn require_integral(fcx: @mut FnCtxt, sp: span, t: ty::t) {\n pub fn check_decl_initializer(fcx: @mut FnCtxt,\n                               nid: ast::node_id,\n                               init: @ast::expr)\n-                           -> bool {\n+                            {\n     let local_ty = fcx.local_ty(init.span, nid);\n-    return check_expr_coercable_to_type(fcx, init, local_ty);\n+    check_expr_coercable_to_type(fcx, init, local_ty)\n }\n \n-pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local) -> bool {\n-    let mut bot = false;\n+pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n     let tcx = fcx.ccx.tcx;\n \n     let t = fcx.local_ty(local.span, local.node.id);\n     fcx.write_ty(local.node.id, t);\n \n     match local.node.init {\n         Some(init) => {\n-            bot = check_decl_initializer(fcx, local.node.id, init);\n+            check_decl_initializer(fcx, local.node.id, init);\n+            let init_ty = fcx.expr_ty(init);\n+            if ty::type_is_error(init_ty) || ty::type_is_bot(init_ty) {\n+                fcx.write_ty(local.node.id, init_ty);\n+            }\n         }\n         _ => {}\n     }\n@@ -2644,64 +2845,92 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local) -> bool {\n         block_region: region,\n     };\n     _match::check_pat(pcx, local.node.pat, t);\n-    return bot;\n+    let pat_ty = fcx.node_ty(local.node.pat.id);\n+    if ty::type_is_error(pat_ty) || ty::type_is_bot(pat_ty) {\n+        fcx.write_ty(local.node.id, pat_ty);\n+    }\n }\n \n-pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt) -> bool {\n+pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt)  {\n     let mut node_id;\n-    let mut bot = false;\n+    let mut saw_bot = false;\n+    let mut saw_err = false;\n     match stmt.node {\n       ast::stmt_decl(decl, id) => {\n         node_id = id;\n         match decl.node {\n           ast::decl_local(ref ls) => for ls.each |l| {\n-            bot |= check_decl_local(fcx, *l);\n+              check_decl_local(fcx, *l);\n+              let l_t = fcx.node_ty(l.node.id);\n+              saw_bot = saw_bot || ty::type_is_bot(l_t);\n+              saw_err = saw_err || ty::type_is_error(l_t);\n           },\n           ast::decl_item(_) => {/* ignore for now */ }\n         }\n       }\n       ast::stmt_expr(expr, id) => {\n         node_id = id;\n-        bot = check_expr_has_type(fcx, expr, ty::mk_nil(fcx.ccx.tcx));\n+        // Check with expected type of ()\n+        check_expr_has_type(fcx, expr, ty::mk_nil(fcx.ccx.tcx));\n+        let expr_ty = fcx.expr_ty(expr);\n+        saw_bot = saw_bot || ty::type_is_bot(expr_ty);\n+        saw_err = saw_err || ty::type_is_error(expr_ty);\n       }\n       ast::stmt_semi(expr, id) => {\n         node_id = id;\n-        bot = check_expr(fcx, expr);\n+        check_expr(fcx, expr);\n+        let expr_ty = fcx.expr_ty(expr);\n+        saw_bot |= ty::type_is_bot(expr_ty);\n+        saw_err |= ty::type_is_error(expr_ty);\n       }\n       ast::stmt_mac(*) => fcx.ccx.tcx.sess.bug(~\"unexpanded macro\")\n     }\n-    fcx.write_nil(node_id);\n-    return bot;\n+    if saw_bot {\n+        fcx.write_bot(node_id);\n+    }\n+    else if saw_err {\n+        fcx.write_error(node_id);\n+    }\n+    else {\n+        fcx.write_nil(node_id)\n+    }\n }\n \n-pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::blk) -> bool {\n-    let bot = check_block(fcx, blk);\n-    if !bot {\n-        let blkty = fcx.node_ty(blk.node.id);\n+pub fn check_block_no_value(fcx: @mut FnCtxt, blk: &ast::blk)  {\n+    check_block_with_expected(fcx, blk, Some(ty::mk_nil(fcx.ccx.tcx)));\n+    let blkty = fcx.node_ty(blk.node.id);\n+    if ty::type_is_error(blkty) {\n+        fcx.write_error(blk.node.id);\n+    }\n+    else if ty::type_is_bot(blkty) {\n+        fcx.write_bot(blk.node.id);\n+    }\n+    else {\n         let nilty = ty::mk_nil(fcx.ccx.tcx);\n         demand::suptype(fcx, blk.span, nilty, blkty);\n     }\n-    return bot;\n }\n \n-pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::blk) -> bool {\n+pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::blk)  {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n                                  blk: &ast::blk,\n-                                 expected: Option<ty::t>)\n-                              -> bool {\n+                                 expected: Option<ty::t>) {\n     let fcx = match blk.node.rules {\n       ast::unsafe_blk => @mut FnCtxt {purity: ast::unsafe_fn,.. copy *fcx0},\n       ast::default_blk => fcx0\n     };\n     do fcx.with_region_lb(blk.node.id) {\n-        let mut bot = false;\n         let mut warned = false;\n+        let mut last_was_bot = false;\n+        let mut any_bot = false;\n+        let mut any_err = false;\n         for blk.node.stmts.each |s| {\n-            if bot && !warned &&\n-                match s.node {\n+            check_stmt(fcx, *s);\n+            let s_ty = fcx.node_ty(ast_util::stmt_id(**s));\n+            if last_was_bot && !warned && match s.node {\n                   ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n                                                  _}, _) |\n                   ast::stmt_expr(_, _) | ast::stmt_semi(_, _) => {\n@@ -2712,23 +2941,37 @@ pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n                 fcx.ccx.tcx.sess.span_warn(s.span, ~\"unreachable statement\");\n                 warned = true;\n             }\n-            bot |= check_stmt(fcx, *s);\n+            if ty::type_is_bot(s_ty) {\n+                last_was_bot = true;\n+            }\n+            any_bot = any_bot || ty::type_is_bot(s_ty);\n+            any_err = any_err || ty::type_is_error(s_ty);\n         }\n         match blk.node.expr {\n-          None => fcx.write_nil(blk.node.id),\n+            None => if any_err {\n+                fcx.write_error(blk.node.id);\n+            }\n+            else if any_bot {\n+                fcx.write_bot(blk.node.id);\n+            }\n+            else  {\n+                fcx.write_nil(blk.node.id);\n+            },\n           Some(e) => {\n-            if bot && !warned {\n+            if any_bot && !warned {\n                 fcx.ccx.tcx.sess.span_warn(e.span, ~\"unreachable expression\");\n             }\n-            bot |= check_expr_with_opt_hint(fcx, e, expected);\n-            let ety = fcx.expr_ty(e);\n-            fcx.write_ty(blk.node.id, ety);\n+            check_expr_with_opt_hint(fcx, e, expected);\n+              let ety = fcx.expr_ty(e);\n+              fcx.write_ty(blk.node.id, ety);\n+              if any_err {\n+                  fcx.write_error(blk.node.id);\n+              }\n+              else if any_bot {\n+                  fcx.write_bot(blk.node.id);\n+              }\n           }\n-        }\n-        if bot {\n-            fcx.write_bot(blk.node.id);\n-        }\n-        bot\n+        };\n     }\n }\n \n@@ -3030,12 +3273,13 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: span, tp: ty::t)\n                                -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n-        Ok(t_s) if !ty::type_is_ty_var(t_s) => return t_s,\n+        Ok(t_s) if !ty::type_is_ty_var(t_s) => t_s,\n         _ => {\n             fcx.type_error_message(sp, |_actual| {\n                 ~\"the type of this value must be known in this context\"\n             }, tp, None);\n-            return ty::mk_err(fcx.tcx());\n+            demand::suptype(fcx, sp, ty::mk_err(fcx.tcx()), tp);\n+            tp\n         }\n     }\n }"}, {"sha": "2007742b43a00b12af68a655c55e0fe160df0045", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -150,7 +150,7 @@ pub fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     // Note: we do this here rather than in visit_pat because we do\n     // not wish to constrain the regions in *patterns* in quite the\n     // same way.  `visit_node()` guarantees that the region encloses\n-    // the node in question, which ultimately constraints the regions\n+    // the node in question, which ultimately constrains the regions\n     // in patterns to enclose the match expression as a whole.  But we\n     // want them to enclose the *arm*.  However, regions in patterns\n     // must either derive from the discriminant or a ref pattern: in\n@@ -616,7 +616,7 @@ pub mod guarantor {\n         // expressions, both of which always yield a region variable, so\n         // mk_subr should never fail.\n         let rptr_ty = rcx.resolve_node_type(id);\n-        if !ty::type_contains_err(rptr_ty) {\n+        if !ty::type_is_error(rptr_ty) {\n             debug!(\"rptr_ty=%s\", ty_to_str(rcx.fcx.ccx.tcx, rptr_ty));\n             let r = ty::ty_region(rptr_ty);\n             infallibly_mk_subr(rcx, true, span, r, bound);\n@@ -890,7 +890,7 @@ pub mod guarantor {\n             }\n             ast::pat_region(p) => {\n                 let rptr_ty = rcx.resolve_node_type(pat.id);\n-                if !ty::type_contains_err(rptr_ty) {\n+                if !ty::type_is_error(rptr_ty) {\n                     let r = ty::ty_region(rptr_ty);\n                     link_ref_bindings_in_pat(rcx, p, Some(r));\n                 }\n@@ -899,7 +899,7 @@ pub mod guarantor {\n             ast::pat_range(*) => {}\n             ast::pat_vec(ref before, ref slice, ref after) => {\n                 let vec_ty = rcx.resolve_node_type(pat.id);\n-                if !ty::type_contains_err(vec_ty) {\n+                if !ty::type_is_error(vec_ty) {\n                     let vstore = ty::ty_vstore(vec_ty);\n                     let guarantor1 = match vstore {\n                         ty::vstore_fixed(_) | ty::vstore_uniq => guarantor,"}, {"sha": "c376fef696c05c2c5552e0baf16dc9f6067f7ef7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -712,7 +712,7 @@ pub impl InferCtxt {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n-        if ty::type_contains_err(actual_ty) {\n+        if ty::type_is_error(actual_ty) {\n             return;\n         }\n         let error_str = err.map_default(~\"\", |t_err|"}, {"sha": "01c2dccb7b92dfa494c726bec08093703c6c9e1a", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -25,4 +25,11 @@ pub enum e {\n \n pub fn nominal() -> e { e_val }\n \n+pub pure fn nominal_eq(e1: e, e2: e) -> bool { true }\n+\n+impl Eq for e {\n+    pure fn eq(&self, other: &e) -> bool { nominal_eq(*self, *other) }\n+    pure fn ne(&self, other: &e) -> bool { !nominal_eq(*self, *other) }\n+}\n+\n pub fn f() -> int { 10 }"}, {"sha": "328b9aa0ecbd5a5dadc3297377594de1cd074d87", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -22,6 +22,13 @@ pub enum e {\n     e_val\n }\n \n+impl Eq for e {\n+    pure fn eq(&self, other: &e) -> bool { !nominal_neq(*self, *other) }\n+    pure fn ne(&self, other: &e) -> bool { nominal_neq(*self, *other) }\n+}\n+\n pub fn nominal() -> e { e_val }\n \n+pub pure fn nominal_neq(e1: e, e2: e) -> bool { false }\n+\n pub fn f() -> int { 20 }"}, {"sha": "000d03ea73c0db93879d33e6950f5ea81693e0e7", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: mismatched types\n struct clam {\n     x: @int,\n     y: @int,\n@@ -21,12 +20,12 @@ struct fish {\n fn main() {\n     let a: clam = clam{x: @1, y: @2};\n     let b: clam = clam{x: @10, y: @20};\n-    let z: int = a.x + b.y;\n+    let z: int = a.x + b.y; //~ ERROR binary operation + cannot be applied to type `@int`\n     debug!(z);\n     fail_unless!((z == 21));\n     let forty: fish = fish{a: @40};\n     let two: fish = fish{a: @2};\n-    let answer: int = forty.a + two.a;\n+    let answer: int = forty.a + two.a;  //~ ERROR binary operation + cannot be applied to type `@int`\n     debug!(answer);\n     fail_unless!((answer == 42));\n }"}, {"sha": "96e88f99bcb18b146488403f383409bcd67a2ca7", "filename": "src/test/compile-fail/crateresolve5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -11,12 +11,12 @@\n // xfail-fast\n // aux-build:crateresolve5-1.rs\n // aux-build:crateresolve5-2.rs\n-// error-pattern:mismatched types\n \n extern mod cr5_1 (name = \"crateresolve5\", vers = \"0.1\");\n extern mod cr5_2 (name = \"crateresolve5\", vers = \"0.2\");\n \n+\n fn main() {\n     // Nominal types from two multiple versions of a crate are different types\n-    fail_unless!(cr5_1::nominal() == cr5_2::nominal());\n+    fail_unless!(cr5_1::nominal() == cr5_2::nominal()); //~ ERROR mismatched types: expected\n }"}, {"sha": "f7144b4c8fa91fa8c5356081ae63135c49bbc365", "filename": "src/test/compile-fail/issue-4736.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct NonCopyable(());\n+\n+fn main() {\n+    let z = NonCopyable{ p: () }; //~ ERROR structure has no field named `p`\n+}\n\\ No newline at end of file"}, {"sha": "41529b3da93edd6d44a9dccf6a3dba94363963ce", "filename": "src/test/compile-fail/pattern-tyvar-2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db003623134dbabae9a8065398644dc141b19d46/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-tyvar-2.rs?ref=db003623134dbabae9a8065398644dc141b19d46", "patch": "@@ -12,10 +12,9 @@\n \n extern mod std;\n \n-// error-pattern: mismatched types\n-\n enum bar { t1((), Option<~[int]>), t2, }\n \n-fn foo(t: bar) -> int { match t { t1(_, Some(x)) => { return x * 3; } _ => { fail!(); } } }\n+// n.b. my change changes this error message, but I think it's right -- tjc\n+fn foo(t: bar) -> int { match t { t1(_, Some(x)) => { return x * 3; } _ => { fail!(); } } } //~ ERROR binary operation * cannot be applied to\n \n fn main() { }"}]}