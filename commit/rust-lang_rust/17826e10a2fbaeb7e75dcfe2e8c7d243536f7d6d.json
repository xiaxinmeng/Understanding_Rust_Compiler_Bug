{"sha": "17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3ODI2ZTEwYTJmYmFlYjdlNzVkY2ZlMmU4YzdkMjQzNTM2ZjdkNmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-15T00:17:11Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-23T20:12:45Z"}, "message": "Type checking and trans for ranges", "tree": {"sha": "81ad0d8c75d1851aec17d70a3eaa1e6b2477062a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81ad0d8c75d1851aec17d70a3eaa1e6b2477062a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "html_url": "https://github.com/rust-lang/rust/commit/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a357e1d87971574817a033e5467785402d5fcfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a357e1d87971574817a033e5467785402d5fcfb", "html_url": "https://github.com/rust-lang/rust/commit/8a357e1d87971574817a033e5467785402d5fcfb"}], "stats": {"total": 131, "additions": 102, "deletions": 29}, "files": [{"sha": "f50790f7e9b15a56442a3032003376ce20b83ab4", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "patch": "@@ -439,8 +439,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                           start.iter().chain(end.iter()).map(|x| &**x))\n             }\n \n-            ast::ExprRange(..) => {\n-                self.tcx.sess.span_bug(expr.span, \"non-desugared range\");\n+            ast::ExprRange(ref start, ref end) => {\n+                let fields = Some(&**start).into_iter()\n+                    .chain(end.as_ref().map(|e| &**e).into_iter());\n+                self.straightline(expr, pred, fields)\n             }\n \n             ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {"}, {"sha": "bf939e98338629daecd0c57f32b04e17702ac14d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "patch": "@@ -465,8 +465,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 assert!(overloaded);\n             }\n \n-            ast::ExprRange(..) => {\n-                self.tcx().sess.span_bug(expr.span, \"non-desugared range\");\n+            ast::ExprRange(ref start, ref end) => {\n+                self.consume_expr(&**start);\n+                end.as_ref().map(|e| self.consume_expr(&**e));\n             }\n \n             ast::ExprCall(ref callee, ref args) => {    // callee(args)"}, {"sha": "f59a67e2e806dcf1556acd1179244303180b7fdb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "patch": "@@ -486,9 +486,6 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprWhileLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ast::ExprRange(..) => {\n-          ir.tcx.sess.span_bug(expr.span, \"non-desugared range\");\n-      }\n       ast::ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from for loop with bm {}\",\n@@ -517,7 +514,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprBlock(..) | ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n       ast::ExprMac(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n       ast::ExprParen(..) | ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n-      ast::ExprSlice(..) => {\n+      ast::ExprSlice(..) | ast::ExprRange(..) => {\n           visit::walk_expr(ir, expr);\n       }\n     }\n@@ -1200,8 +1197,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**e1, succ)\n           }\n \n-          ast::ExprRange(..) => {\n-              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared range\");\n+          ast::ExprRange(ref e1, ref e2) => {\n+            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n+            self.propagate_through_expr(&**e1, succ)\n           }\n \n           ast::ExprBox(None, ref e) |\n@@ -1496,7 +1494,8 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprBreak(..) | ast::ExprAgain(..) | ast::ExprLit(_) |\n       ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n       ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n-      ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) | ast::ExprSlice(..) => {\n+      ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) |\n+      ast::ExprSlice(..) | ast::ExprRange(..) => {\n         visit::walk_expr(this, expr);\n       }\n       ast::ExprIfLet(..) => {\n@@ -1505,9 +1504,6 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprWhileLet(..) => {\n         this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ast::ExprRange(..) => {\n-        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared range\");\n-      }\n     }\n }\n "}, {"sha": "932a124ed339b19ea9e03dc342a3a27645b4e86b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "patch": "@@ -541,7 +541,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n           ast::ExprClosure(..) | ast::ExprRet(..) |\n-          ast::ExprUnary(..) | ast::ExprSlice(..) |\n+          ast::ExprUnary(..) | ast::ExprSlice(..) | ast::ExprRange(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprBinary(..) | ast::ExprWhile(..) |\n@@ -559,9 +559,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprWhileLet(..) => {\n             self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n-          ast::ExprRange(..) => {\n-            self.tcx().sess.span_bug(expr.span, \"non-desugared range\");\n-          }\n         }\n     }\n "}, {"sha": "236312dac6e9e8335932f7df9f0147eb9fe18c28", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "patch": "@@ -4257,6 +4257,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprCall(..) |\n         ast::ExprMethodCall(..) |\n         ast::ExprStruct(..) |\n+        ast::ExprRange(..) |\n         ast::ExprTup(..) |\n         ast::ExprIf(..) |\n         ast::ExprMatch(..) |\n@@ -4273,9 +4274,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprWhileLet(..) => {\n             tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n         }\n-        ast::ExprRange(..) => {\n-            tcx.sess.span_bug(expr.span, \"non-desugared range\");\n-        }\n \n         ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n             RvalueDpsExpr"}, {"sha": "8fadaa05203e1829a3b76ef5b0429dc57e78ddb0", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "patch": "@@ -3494,9 +3494,9 @@ fn populate_scope_map(cx: &CrateContext,\n                 end.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n             }\n \n-            ast::ExprRange(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n-                                              Found unexpanded range.\");\n+            ast::ExprRange(ref start, ref end) => {\n+                walk_expr(cx, &**start, scope_stack, scope_map);\n+                end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n             }\n \n             ast::ExprVec(ref init_expressions) |"}, {"sha": "6f9990a3e9ed90655ef8e601ddd12cbcc29a1250", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "patch": "@@ -39,7 +39,7 @@ use back::abi;\n use llvm::{mod, ValueRef};\n use middle::def;\n use middle::mem_categorization::Typer;\n-use middle::subst::{mod, Subst};\n+use middle::subst::{mod, Subst, Substs};\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n@@ -66,6 +66,7 @@ use trans::type_::Type;\n use syntax::{ast, ast_util, codemap};\n use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n+use syntax::parse::token;\n use std::rc::Rc;\n \n // Destinations\n@@ -1048,8 +1049,49 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n+                         node_id_type(bcx, expr.id),\n                          dest)\n         }\n+        ast::ExprRange(ref start, ref end) => {\n+            // FIXME it is just not right that we are synthesising ast nodes in\n+            // trans. Shudder.\n+            fn make_field(field_name: &str, expr: P<ast::Expr>) -> ast::Field {\n+                ast::Field {\n+                    ident: codemap::dummy_spanned(token::str_to_ident(field_name)),\n+                    expr: expr,\n+                    span: codemap::DUMMY_SP,\n+                }\n+            }\n+\n+            // A range just desugars into a struct.\n+            let (did, fields) = match end {\n+                &Some(ref end) => {\n+                    // Desugar to Range\n+                    let fields = vec!(make_field(\"start\", start.clone()),\n+                                      make_field(\"end\", end.clone()));\n+                    (tcx.lang_items.range_struct(), fields)\n+                }\n+                &None => {\n+                    // Desugar to RangeFrom\n+                    let fields = vec!(make_field(\"start\", start.clone()));\n+                    (tcx.lang_items.range_from_struct(), fields)\n+                }\n+            };\n+\n+            if let Some(did) = did {\n+                let substs = Substs::new_type(vec![node_id_type(bcx, start.id)], vec![]);\n+                trans_struct(bcx,\n+                             fields.as_slice(),\n+                             None,\n+                             expr.span,\n+                             expr.id,\n+                             ty::mk_struct(tcx, did, substs),\n+                             dest)\n+            } else {\n+                tcx.sess.span_bug(expr.span,\n+                                  \"No lang item for ranges (how did we get this far?)\")\n+            }\n+        }\n         ast::ExprTup(ref args) => {\n             let numbered_fields: Vec<(uint, &ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n@@ -1347,10 +1389,10 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             base: Option<&ast::Expr>,\n                             expr_span: codemap::Span,\n                             expr_id: ast::NodeId,\n+                            ty: Ty<'tcx>,\n                             dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_rec\");\n \n-    let ty = node_id_type(bcx, expr_id);\n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n         let mut need_base = Vec::from_elem(field_tys.len(), true);"}, {"sha": "4a10954729db8cd352ad301f6e87760c8a7649b3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=17826e10a2fbaeb7e75dcfe2e8c7d243536f7d6d", "patch": "@@ -4238,7 +4238,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                   check_expr(fcx, e);\n                   let e_t = fcx.expr_ty(e);\n                   if ty::type_is_error(e_t) {\n-                    fcx.write_ty(id, e_t);\n+                    fcx.write_ty(e.id, e_t);\n                     some_err = true;\n                   }\n               };\n@@ -4278,8 +4278,45 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               }\n           }\n        }\n-       ast::ExprRange(..) => {\n-         tcx.sess.span_bug(expr.span, \"non-desugared range\");\n+       ast::ExprRange(ref start, ref end) => {\n+          let mut some_err = false;\n+\n+          check_expr(fcx, &**start);\n+          let t_start = fcx.expr_ty(&**start);\n+          if ty::type_is_error(t_start) {\n+            fcx.write_ty(start.id, t_start);\n+            some_err = true;\n+          }\n+\n+          if let &Some(ref e) = end {\n+              check_expr_has_type(fcx, &**e, t_start);\n+              let t_end = fcx.expr_ty(&**e);\n+              if ty::type_is_error(t_end) {\n+                fcx.write_ty(e.id, t_end);\n+                some_err = true;\n+              }\n+          }\n+\n+          // Note that we don't check the type of the start/end satisfy any\n+          // bounds because right the range structs do not have any. If we add\n+          // some bounds, then we'll need to check `t_start` against them here.\n+\n+          if !some_err {\n+            // Find the did from the appropriate lang item.\n+            let did = if end.is_some() {\n+                // Range\n+                fcx.tcx().lang_items.range_struct()\n+            } else {\n+                // RangeFrom\n+                fcx.tcx().lang_items.range_from_struct()\n+            };\n+            if let Some(did) = did {\n+                let substs = Substs::new_type(vec![t_start], vec![]);\n+                fcx.write_ty(id, ty::mk_struct(tcx, did, substs));\n+            } else {\n+                fcx.write_ty(id, ty::mk_err());\n+            }\n+          }\n        }\n \n     }"}]}