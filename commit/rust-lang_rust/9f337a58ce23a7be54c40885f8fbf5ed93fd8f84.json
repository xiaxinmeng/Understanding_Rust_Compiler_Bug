{"sha": "9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMzM3YTU4Y2UyM2E3YmU1NGM0MDg4NWY4ZmJmNWVkOTNmZDhmODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-13T20:51:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-13T20:51:58Z"}, "message": "auto merge of #5869 : bjz/rust/master, r=graydon\n\nThis restores the trait that was lost in 216e85fadf465c25fe7bc4a9f06f8162ec12b552. `Num` will eventually be broken up into a more fine-grained trait hierarchy in the future once a design can be agreed upon.\r\n\r\nTo contribute to the discussion about the future of Rust's numeric traits, please see issue #4819 and the [wiki page](https://github.com/mozilla/rust/wiki/Bikeshed-Numeric-Traits).\r\n\r\nI have also switched to [implementing NumCast using macros](https://github.com/bjz/rust/commit/353ce872e287edf3764ca416d2a8cd8e1f54329b). This removes a significant number of lines of code.", "tree": {"sha": "fd1e7689224269109c368f544faee864a5f212d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd1e7689224269109c368f544faee864a5f212d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "html_url": "https://github.com/rust-lang/rust/commit/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2d5cebe32c0b1fae7f612a16a9e7b62ed740660", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660", "html_url": "https://github.com/rust-lang/rust/commit/e2d5cebe32c0b1fae7f612a16a9e7b62ed740660"}, {"sha": "0615fddd80116d63fba7040bdd89ad59117037dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0615fddd80116d63fba7040bdd89ad59117037dd", "html_url": "https://github.com/rust-lang/rust/commit/0615fddd80116d63fba7040bdd89ad59117037dd"}], "stats": {"total": 1157, "additions": 166, "deletions": 991}, "files": [{"sha": "41db07ca34c577e3dc3fdaa31904bb8bfe130985", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -99,7 +99,7 @@ pub use vec::{OwnedVector, OwnedCopyableVector};\n pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n \n-pub use num::NumCast;\n+pub use num::{Num, NumCast};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "5e672ea0dfa867996f79bc16c04e787d9708a21b", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -12,7 +12,6 @@\n \n use cmath;\n use libc::{c_float, c_int};\n-use num::NumCast;\n use num::strconv;\n use num;\n use option::Option;\n@@ -287,30 +286,6 @@ impl num::One for f32 {\n     fn one() -> f32 { 1.0 }\n }\n \n-impl NumCast for f32 {\n-    /**\n-     * Cast `n` to an `f32`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> f32 { n.to_f32() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self          }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n #[cfg(notest)]\n impl ops::Add<f32,f32> for f32 {\n     fn add(&self, other: &f32) -> f32 { *self + *other }\n@@ -580,63 +555,6 @@ impl num::FromStrRadix for f32 {\n     }\n }\n \n-#[test]\n-pub fn test_num() {\n-    let ten: f32 = num::cast(10);\n-    let two: f32 = num::cast(2);\n-\n-    assert!((ten.add(&two)    == num::cast(12)));\n-    assert!((ten.sub(&two)    == num::cast(8)));\n-    assert!((ten.mul(&two)    == num::cast(20)));\n-    assert!((ten.div(&two)    == num::cast(5)));\n-    assert!((ten.modulo(&two) == num::cast(0)));\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u     == 20f32.to_uint()));\n-    assert!((20u8    == 20f32.to_u8()));\n-    assert!((20u16   == 20f32.to_u16()));\n-    assert!((20u32   == 20f32.to_u32()));\n-    assert!((20u64   == 20f32.to_u64()));\n-    assert!((20i     == 20f32.to_int()));\n-    assert!((20i8    == 20f32.to_i8()));\n-    assert!((20i16   == 20f32.to_i16()));\n-    assert!((20i32   == 20f32.to_i32()));\n-    assert!((20i64   == 20f32.to_i64()));\n-    assert!((20f     == 20f32.to_float()));\n-    assert!((20f32   == 20f32.to_f32()));\n-    assert!((20f64   == 20f32.to_f64()));\n-\n-    assert!((20f32 == NumCast::from(20u)));\n-    assert!((20f32 == NumCast::from(20u8)));\n-    assert!((20f32 == NumCast::from(20u16)));\n-    assert!((20f32 == NumCast::from(20u32)));\n-    assert!((20f32 == NumCast::from(20u64)));\n-    assert!((20f32 == NumCast::from(20i)));\n-    assert!((20f32 == NumCast::from(20i8)));\n-    assert!((20f32 == NumCast::from(20i16)));\n-    assert!((20f32 == NumCast::from(20i32)));\n-    assert!((20f32 == NumCast::from(20i64)));\n-    assert!((20f32 == NumCast::from(20f)));\n-    assert!((20f32 == NumCast::from(20f32)));\n-    assert!((20f32 == NumCast::from(20f64)));\n-\n-    assert!((20f32 == num::cast(20u)));\n-    assert!((20f32 == num::cast(20u8)));\n-    assert!((20f32 == num::cast(20u16)));\n-    assert!((20f32 == num::cast(20u32)));\n-    assert!((20f32 == num::cast(20u64)));\n-    assert!((20f32 == num::cast(20i)));\n-    assert!((20f32 == num::cast(20i8)));\n-    assert!((20f32 == num::cast(20i16)));\n-    assert!((20f32 == num::cast(20i32)));\n-    assert!((20f32 == num::cast(20i64)));\n-    assert!((20f32 == num::cast(20f)));\n-    assert!((20f32 == num::cast(20f32)));\n-    assert!((20f32 == num::cast(20f64)));\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "4c96da73d2130522112899b86ece62f937f8451a", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -12,7 +12,6 @@\n \n use cmath;\n use libc::{c_double, c_int};\n-use num::NumCast;\n use num::strconv;\n use num;\n use option::Option;\n@@ -299,30 +298,6 @@ impl cmp::Ord for f64 {\n     fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n }\n \n-impl NumCast for f64 {\n-    /**\n-     * Cast `n` to an `f64`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> f64 { n.to_f64() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self          }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n impl num::Zero for f64 {\n     #[inline(always)]\n     fn zero() -> f64 { 0.0 }\n@@ -602,63 +577,6 @@ impl num::FromStrRadix for f64 {\n     }\n }\n \n-#[test]\n-pub fn test_num() {\n-    let ten: f64 = num::cast(10);\n-    let two: f64 = num::cast(2);\n-\n-    assert!((ten.add(&two)    == num::cast(12)));\n-    assert!((ten.sub(&two)    == num::cast(8)));\n-    assert!((ten.mul(&two)    == num::cast(20)));\n-    assert!((ten.div(&two)    == num::cast(5)));\n-    assert!((ten.modulo(&two) == num::cast(0)));\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20f64.to_uint()));\n-    assert!((20u8  == 20f64.to_u8()));\n-    assert!((20u16 == 20f64.to_u16()));\n-    assert!((20u32 == 20f64.to_u32()));\n-    assert!((20u64 == 20f64.to_u64()));\n-    assert!((20i   == 20f64.to_int()));\n-    assert!((20i8  == 20f64.to_i8()));\n-    assert!((20i16 == 20f64.to_i16()));\n-    assert!((20i32 == 20f64.to_i32()));\n-    assert!((20i64 == 20f64.to_i64()));\n-    assert!((20f   == 20f64.to_float()));\n-    assert!((20f32 == 20f64.to_f32()));\n-    assert!((20f64 == 20f64.to_f64()));\n-\n-    assert!((20f64 == NumCast::from(20u)));\n-    assert!((20f64 == NumCast::from(20u8)));\n-    assert!((20f64 == NumCast::from(20u16)));\n-    assert!((20f64 == NumCast::from(20u32)));\n-    assert!((20f64 == NumCast::from(20u64)));\n-    assert!((20f64 == NumCast::from(20i)));\n-    assert!((20f64 == NumCast::from(20i8)));\n-    assert!((20f64 == NumCast::from(20i16)));\n-    assert!((20f64 == NumCast::from(20i32)));\n-    assert!((20f64 == NumCast::from(20i64)));\n-    assert!((20f64 == NumCast::from(20f)));\n-    assert!((20f64 == NumCast::from(20f32)));\n-    assert!((20f64 == NumCast::from(20f64)));\n-\n-    assert!((20f64 == num::cast(20u)));\n-    assert!((20f64 == num::cast(20u8)));\n-    assert!((20f64 == num::cast(20u16)));\n-    assert!((20f64 == num::cast(20u32)));\n-    assert!((20f64 == num::cast(20u64)));\n-    assert!((20f64 == num::cast(20i)));\n-    assert!((20f64 == num::cast(20i8)));\n-    assert!((20f64 == num::cast(20i16)));\n-    assert!((20f64 == num::cast(20i32)));\n-    assert!((20f64 == num::cast(20i64)));\n-    assert!((20f64 == num::cast(20f)));\n-    assert!((20f64 == num::cast(20f32)));\n-    assert!((20f64 == num::cast(20f64)));\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "1ab0e24f62dc94dd8b08de9825f1dfe54cb2a047", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -21,7 +21,6 @@\n // PORT this must match in width according to architecture\n \n use f64;\n-use num::NumCast;\n use num::strconv;\n use num;\n use option::Option;\n@@ -417,30 +416,6 @@ impl num::One for float {\n     fn one() -> float { 1.0 }\n }\n \n-impl NumCast for float {\n-    /**\n-     * Cast `n` to a `float`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> float { n.to_float() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self          }\n-}\n-\n impl num::Round for float {\n     #[inline(always)]\n     fn round(&self, mode: num::RoundMode) -> float {\n@@ -688,63 +663,6 @@ pub fn test_round() {\n     assert!(round(-3.5) == -4.0);\n }\n \n-#[test]\n-pub fn test_num() {\n-    let ten: float = num::cast(10);\n-    let two: float = num::cast(2);\n-\n-    assert!((ten.add(&two)    == num::cast(12)));\n-    assert!((ten.sub(&two)    == num::cast(8)));\n-    assert!((ten.mul(&two)    == num::cast(20)));\n-    assert!((ten.div(&two)    == num::cast(5)));\n-    assert!((ten.modulo(&two) == num::cast(0)));\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20f.to_uint()));\n-    assert!((20u8  == 20f.to_u8()));\n-    assert!((20u16 == 20f.to_u16()));\n-    assert!((20u32 == 20f.to_u32()));\n-    assert!((20u64 == 20f.to_u64()));\n-    assert!((20i   == 20f.to_int()));\n-    assert!((20i8  == 20f.to_i8()));\n-    assert!((20i16 == 20f.to_i16()));\n-    assert!((20i32 == 20f.to_i32()));\n-    assert!((20i64 == 20f.to_i64()));\n-    assert!((20f   == 20f.to_float()));\n-    assert!((20f32 == 20f.to_f32()));\n-    assert!((20f64 == 20f.to_f64()));\n-\n-    assert!((20f == NumCast::from(20u)));\n-    assert!((20f == NumCast::from(20u8)));\n-    assert!((20f == NumCast::from(20u16)));\n-    assert!((20f == NumCast::from(20u32)));\n-    assert!((20f == NumCast::from(20u64)));\n-    assert!((20f == NumCast::from(20i)));\n-    assert!((20f == NumCast::from(20i8)));\n-    assert!((20f == NumCast::from(20i16)));\n-    assert!((20f == NumCast::from(20i32)));\n-    assert!((20f == NumCast::from(20i64)));\n-    assert!((20f == NumCast::from(20f)));\n-    assert!((20f == NumCast::from(20f32)));\n-    assert!((20f == NumCast::from(20f64)));\n-\n-    assert!((20f == num::cast(20u)));\n-    assert!((20f == num::cast(20u8)));\n-    assert!((20f == num::cast(20u16)));\n-    assert!((20f == num::cast(20u32)));\n-    assert!((20f == num::cast(20u64)));\n-    assert!((20f == num::cast(20i)));\n-    assert!((20f == num::cast(20i8)));\n-    assert!((20f == num::cast(20i16)));\n-    assert!((20f == num::cast(20i32)));\n-    assert!((20f == num::cast(20i64)));\n-    assert!((20f == num::cast(20f)));\n-    assert!((20f == num::cast(20f32)));\n-    assert!((20f == num::cast(20f64)));\n-}\n-\n \n //\n // Local Variables:"}, {"sha": "6fbe44737d1840d15dfba89548a2f2d693969e53", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -397,18 +397,6 @@ fn test_int_from_str_overflow() {\n     assert!((i64::from_str(~\"-9223372036854775809\").is_none()));\n }\n \n-#[test]\n-pub fn test_num() {\n-    let ten: T = num::cast(10);\n-    let two: T = num::cast(2);\n-\n-    assert!((ten.add(&two)    == num::cast(12)));\n-    assert!((ten.sub(&two)    == num::cast(8)));\n-    assert!((ten.mul(&two)    == num::cast(20)));\n-    assert!((ten.div(&two)    == num::cast(5)));\n-    assert!((ten.modulo(&two) == num::cast(0)));\n-}\n-\n #[test]\n pub fn test_ranges() {\n     let mut l = ~[];"}, {"sha": "34dcd508397854bb1abb7088df3b61c19753da48", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,78 +10,7 @@\n \n //! Operations and constants for `i16`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = i16;\n     pub static bits: uint = ::u16::bits;\n }\n-\n-impl NumCast for i16 {\n-    /**\n-     * Cast `n` to a `i16`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> i16 { n.to_i16() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self          }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i16.to_uint()));\n-    assert!((20u8  == 20i16.to_u8()));\n-    assert!((20u16 == 20i16.to_u16()));\n-    assert!((20u32 == 20i16.to_u32()));\n-    assert!((20u64 == 20i16.to_u64()));\n-    assert!((20i   == 20i16.to_int()));\n-    assert!((20i8  == 20i16.to_i8()));\n-    assert!((20i16 == 20i16.to_i16()));\n-    assert!((20i32 == 20i16.to_i32()));\n-    assert!((20i64 == 20i16.to_i64()));\n-    assert!((20f   == 20i16.to_float()));\n-    assert!((20f32 == 20i16.to_f32()));\n-    assert!((20f64 == 20i16.to_f64()));\n-\n-    assert!((20i16 == NumCast::from(20u)));\n-    assert!((20i16 == NumCast::from(20u8)));\n-    assert!((20i16 == NumCast::from(20u16)));\n-    assert!((20i16 == NumCast::from(20u32)));\n-    assert!((20i16 == NumCast::from(20u64)));\n-    assert!((20i16 == NumCast::from(20i)));\n-    assert!((20i16 == NumCast::from(20i8)));\n-    assert!((20i16 == NumCast::from(20i16)));\n-    assert!((20i16 == NumCast::from(20i32)));\n-    assert!((20i16 == NumCast::from(20i64)));\n-    assert!((20i16 == NumCast::from(20f)));\n-    assert!((20i16 == NumCast::from(20f32)));\n-    assert!((20i16 == NumCast::from(20f64)));\n-\n-    assert!((20i16 == num::cast(20u)));\n-    assert!((20i16 == num::cast(20u8)));\n-    assert!((20i16 == num::cast(20u16)));\n-    assert!((20i16 == num::cast(20u32)));\n-    assert!((20i16 == num::cast(20u64)));\n-    assert!((20i16 == num::cast(20i)));\n-    assert!((20i16 == num::cast(20i8)));\n-    assert!((20i16 == num::cast(20i16)));\n-    assert!((20i16 == num::cast(20i32)));\n-    assert!((20i16 == num::cast(20i64)));\n-    assert!((20i16 == num::cast(20f)));\n-    assert!((20i16 == num::cast(20f32)));\n-    assert!((20i16 == num::cast(20f64)));\n-}"}, {"sha": "91eea0e8d4709fe2cff71b9835aa4efcc64517c6", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,78 +10,7 @@\n \n //! Operations and constants for `i32`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = i32;\n     pub static bits: uint = ::u32::bits;\n }\n-\n-impl NumCast for i32 {\n-    /**\n-     * Cast `n` to a `i32`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> i32 { n.to_i32() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self          }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i32.to_uint()));\n-    assert!((20u8  == 20i32.to_u8()));\n-    assert!((20u16 == 20i32.to_u16()));\n-    assert!((20u32 == 20i32.to_u32()));\n-    assert!((20u64 == 20i32.to_u64()));\n-    assert!((20i   == 20i32.to_int()));\n-    assert!((20i8  == 20i32.to_i8()));\n-    assert!((20i16 == 20i32.to_i16()));\n-    assert!((20i32 == 20i32.to_i32()));\n-    assert!((20i64 == 20i32.to_i64()));\n-    assert!((20f   == 20i32.to_float()));\n-    assert!((20f32 == 20i32.to_f32()));\n-    assert!((20f64 == 20i32.to_f64()));\n-\n-    assert!((20i32 == NumCast::from(20u)));\n-    assert!((20i32 == NumCast::from(20u8)));\n-    assert!((20i32 == NumCast::from(20u16)));\n-    assert!((20i32 == NumCast::from(20u32)));\n-    assert!((20i32 == NumCast::from(20u64)));\n-    assert!((20i32 == NumCast::from(20i)));\n-    assert!((20i32 == NumCast::from(20i8)));\n-    assert!((20i32 == NumCast::from(20i16)));\n-    assert!((20i32 == NumCast::from(20i32)));\n-    assert!((20i32 == NumCast::from(20i64)));\n-    assert!((20i32 == NumCast::from(20f)));\n-    assert!((20i32 == NumCast::from(20f32)));\n-    assert!((20i32 == NumCast::from(20f64)));\n-\n-    assert!((20i32 == num::cast(20u)));\n-    assert!((20i32 == num::cast(20u8)));\n-    assert!((20i32 == num::cast(20u16)));\n-    assert!((20i32 == num::cast(20u32)));\n-    assert!((20i32 == num::cast(20u64)));\n-    assert!((20i32 == num::cast(20i)));\n-    assert!((20i32 == num::cast(20i8)));\n-    assert!((20i32 == num::cast(20i16)));\n-    assert!((20i32 == num::cast(20i32)));\n-    assert!((20i32 == num::cast(20i64)));\n-    assert!((20i32 == num::cast(20f)));\n-    assert!((20i32 == num::cast(20f32)));\n-    assert!((20i32 == num::cast(20f64)));\n-}"}, {"sha": "3834a1e2a0387e584c19817c67004cbf2a589531", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,78 +10,7 @@\n \n //! Operations and constants for `i64`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = i64;\n     pub static bits: uint = ::u64::bits;\n }\n-\n-impl NumCast for i64 {\n-    /**\n-     * Cast `n` to a `i64`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> i64 { n.to_i64() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self          }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i64.to_uint()));\n-    assert!((20u8  == 20i64.to_u8()));\n-    assert!((20u16 == 20i64.to_u16()));\n-    assert!((20u32 == 20i64.to_u32()));\n-    assert!((20u64 == 20i64.to_u64()));\n-    assert!((20i   == 20i64.to_int()));\n-    assert!((20i8  == 20i64.to_i8()));\n-    assert!((20i16 == 20i64.to_i16()));\n-    assert!((20i32 == 20i64.to_i32()));\n-    assert!((20i64 == 20i64.to_i64()));\n-    assert!((20f   == 20i64.to_float()));\n-    assert!((20f32 == 20i64.to_f32()));\n-    assert!((20f64 == 20i64.to_f64()));\n-\n-    assert!((20i64 == NumCast::from(20u)));\n-    assert!((20i64 == NumCast::from(20u8)));\n-    assert!((20i64 == NumCast::from(20u16)));\n-    assert!((20i64 == NumCast::from(20u32)));\n-    assert!((20i64 == NumCast::from(20u64)));\n-    assert!((20i64 == NumCast::from(20i)));\n-    assert!((20i64 == NumCast::from(20i8)));\n-    assert!((20i64 == NumCast::from(20i16)));\n-    assert!((20i64 == NumCast::from(20i32)));\n-    assert!((20i64 == NumCast::from(20i64)));\n-    assert!((20i64 == NumCast::from(20f)));\n-    assert!((20i64 == NumCast::from(20f32)));\n-    assert!((20i64 == NumCast::from(20f64)));\n-\n-    assert!((20i64 == num::cast(20u)));\n-    assert!((20i64 == num::cast(20u8)));\n-    assert!((20i64 == num::cast(20u16)));\n-    assert!((20i64 == num::cast(20u32)));\n-    assert!((20i64 == num::cast(20u64)));\n-    assert!((20i64 == num::cast(20i)));\n-    assert!((20i64 == num::cast(20i8)));\n-    assert!((20i64 == num::cast(20i16)));\n-    assert!((20i64 == num::cast(20i32)));\n-    assert!((20i64 == num::cast(20i64)));\n-    assert!((20i64 == num::cast(20f)));\n-    assert!((20i64 == num::cast(20f32)));\n-    assert!((20i64 == num::cast(20f64)));\n-}"}, {"sha": "9486ed748d7d00334e97a7c1decf5e2dfc7ff42c", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,78 +10,7 @@\n \n //! Operations and constants for `i8`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = i8;\n     pub static bits: uint = ::u8::bits;\n }\n-\n-impl NumCast for i8 {\n-    /**\n-     * Cast `n` to a `i8`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> i8 { n.to_i8() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self          }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i8.to_uint()));\n-    assert!((20u8  == 20i8.to_u8()));\n-    assert!((20u16 == 20i8.to_u16()));\n-    assert!((20u32 == 20i8.to_u32()));\n-    assert!((20u64 == 20i8.to_u64()));\n-    assert!((20i   == 20i8.to_int()));\n-    assert!((20i8  == 20i8.to_i8()));\n-    assert!((20i16 == 20i8.to_i16()));\n-    assert!((20i32 == 20i8.to_i32()));\n-    assert!((20i64 == 20i8.to_i64()));\n-    assert!((20f   == 20i8.to_float()));\n-    assert!((20f32 == 20i8.to_f32()));\n-    assert!((20f64 == 20i8.to_f64()));\n-\n-    assert!((20i8 == NumCast::from(20u)));\n-    assert!((20i8 == NumCast::from(20u8)));\n-    assert!((20i8 == NumCast::from(20u16)));\n-    assert!((20i8 == NumCast::from(20u32)));\n-    assert!((20i8 == NumCast::from(20u64)));\n-    assert!((20i8 == NumCast::from(20i)));\n-    assert!((20i8 == NumCast::from(20i8)));\n-    assert!((20i8 == NumCast::from(20i16)));\n-    assert!((20i8 == NumCast::from(20i32)));\n-    assert!((20i8 == NumCast::from(20i64)));\n-    assert!((20i8 == NumCast::from(20f)));\n-    assert!((20i8 == NumCast::from(20f32)));\n-    assert!((20i8 == NumCast::from(20f64)));\n-\n-    assert!((20i8 == num::cast(20u)));\n-    assert!((20i8 == num::cast(20u8)));\n-    assert!((20i8 == num::cast(20u16)));\n-    assert!((20i8 == num::cast(20u32)));\n-    assert!((20i8 == num::cast(20u64)));\n-    assert!((20i8 == num::cast(20i)));\n-    assert!((20i8 == num::cast(20i8)));\n-    assert!((20i8 == num::cast(20i16)));\n-    assert!((20i8 == num::cast(20i32)));\n-    assert!((20i8 == num::cast(20i64)));\n-    assert!((20i8 == num::cast(20f)));\n-    assert!((20i8 == num::cast(20f32)));\n-    assert!((20i8 == num::cast(20f64)));\n-}"}, {"sha": "6649b364015d3a5dbec43b9f27f8e335327ffcad", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,8 +10,6 @@\n \n //! Operations and constants for `int`\n \n-use num::NumCast;\n-\n pub use self::inst::pow;\n \n mod inst {\n@@ -57,72 +55,3 @@ mod inst {\n         assert!((::int::min_value + ::int::max_value + 1 == 0));\n     }\n }\n-\n-impl NumCast for int {\n-    /**\n-     * Cast `n` to a `int`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> int { n.to_int() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self          }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20i.to_uint()));\n-    assert!((20u8  == 20i.to_u8()));\n-    assert!((20u16 == 20i.to_u16()));\n-    assert!((20u32 == 20i.to_u32()));\n-    assert!((20u64 == 20i.to_u64()));\n-    assert!((20i   == 20i.to_int()));\n-    assert!((20i8  == 20i.to_i8()));\n-    assert!((20i16 == 20i.to_i16()));\n-    assert!((20i32 == 20i.to_i32()));\n-    assert!((20i64 == 20i.to_i64()));\n-    assert!((20f   == 20i.to_float()));\n-    assert!((20f32 == 20i.to_f32()));\n-    assert!((20f64 == 20i.to_f64()));\n-\n-    assert!((20i == NumCast::from(20u)));\n-    assert!((20i == NumCast::from(20u8)));\n-    assert!((20i == NumCast::from(20u16)));\n-    assert!((20i == NumCast::from(20u32)));\n-    assert!((20i == NumCast::from(20u64)));\n-    assert!((20i == NumCast::from(20i)));\n-    assert!((20i == NumCast::from(20i8)));\n-    assert!((20i == NumCast::from(20i16)));\n-    assert!((20i == NumCast::from(20i32)));\n-    assert!((20i == NumCast::from(20i64)));\n-    assert!((20i == NumCast::from(20f)));\n-    assert!((20i == NumCast::from(20f32)));\n-    assert!((20i == NumCast::from(20f64)));\n-\n-    assert!((20i == num::cast(20u)));\n-    assert!((20i == num::cast(20u8)));\n-    assert!((20i == num::cast(20u16)));\n-    assert!((20i == num::cast(20u32)));\n-    assert!((20i == num::cast(20u64)));\n-    assert!((20i == num::cast(20i)));\n-    assert!((20i == num::cast(20i8)));\n-    assert!((20i == num::cast(20i16)));\n-    assert!((20i == num::cast(20i32)));\n-    assert!((20i == num::cast(20i64)));\n-    assert!((20i == num::cast(20f)));\n-    assert!((20i == num::cast(20f32)));\n-    assert!((20i == num::cast(20f64)));\n-}"}, {"sha": "19a1e276d37540d90b9abd5735432dc112535c21", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 159, "deletions": 4, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -9,13 +9,35 @@\n // except according to those terms.\n \n //! An interface for numeric types\n-use cmp::Ord;\n-use ops::{Div, Mul, Neg};\n+use cmp::{Eq, Ord};\n+use ops::{Neg, Add, Sub, Mul, Div, Modulo};\n use option::Option;\n use kinds::Copy;\n \n pub mod strconv;\n \n+pub trait Num: Eq + Zero + One\n+             + Neg<Self>\n+             + Add<Self,Self>\n+             + Sub<Self,Self>\n+             + Mul<Self,Self>\n+             + Div<Self,Self>\n+             + Modulo<Self,Self> {}\n+\n+impl Num for u8 {}\n+impl Num for u16 {}\n+impl Num for u32 {}\n+impl Num for u64 {}\n+impl Num for uint {}\n+impl Num for i8 {}\n+impl Num for i16 {}\n+impl Num for i32 {}\n+impl Num for i64 {}\n+impl Num for int {}\n+impl Num for f32 {}\n+impl Num for f64 {}\n+impl Num for float {}\n+\n pub trait IntConvertible {\n     fn to_int(&self) -> int;\n     fn from_int(n: int) -> Self;\n@@ -49,7 +71,7 @@ pub enum RoundMode {\n }\n \n /**\n- * Cast a number the the enclosing type\n+ * Cast from one machine scalar to another\n  *\n  * # Example\n  *\n@@ -64,7 +86,7 @@ pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n }\n \n /**\n- * An interface for generic numeric type casts\n+ * An interface for casting between machine scalars\n  */\n pub trait NumCast {\n     fn from<T:NumCast>(n: T) -> Self;\n@@ -86,6 +108,49 @@ pub trait NumCast {\n     fn to_float(&self) -> float;\n }\n \n+macro_rules! impl_num_cast(\n+    ($T:ty, $conv:ident) => (\n+        impl NumCast for $T {\n+            #[inline(always)]\n+            fn from<N:NumCast>(n: N) -> $T {\n+                // `$conv` could be generated using `concat_idents!`, but that\n+                // macro seems to be broken at the moment\n+                n.$conv()\n+            }\n+\n+            #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n+            #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n+            #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n+            #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n+            #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n+\n+            #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n+            #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n+            #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n+            #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n+            #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n+\n+            #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n+            #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n+            #[inline(always)] fn to_float(&self) -> float { *self as float }\n+        }\n+    )\n+)\n+\n+impl_num_cast!(u8,    to_u8)\n+impl_num_cast!(u16,   to_u16)\n+impl_num_cast!(u32,   to_u32)\n+impl_num_cast!(u64,   to_u64)\n+impl_num_cast!(uint,  to_uint)\n+impl_num_cast!(i8,    to_i8)\n+impl_num_cast!(i16,   to_i16)\n+impl_num_cast!(i32,   to_i32)\n+impl_num_cast!(i64,   to_i64)\n+impl_num_cast!(int,   to_int)\n+impl_num_cast!(f32,   to_f32)\n+impl_num_cast!(f64,   to_f64)\n+impl_num_cast!(float, to_float)\n+\n pub trait ToStrRadix {\n     pub fn to_str_radix(&self, radix: uint) -> ~str;\n }\n@@ -129,3 +194,93 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n     total\n }\n \n+#[cfg(test)]\n+fn test_num<T:Num + NumCast>(ten: T, two: T) {\n+    assert!(ten.add(&two)    == cast(12));\n+    assert!(ten.sub(&two)    == cast(8));\n+    assert!(ten.mul(&two)    == cast(20));\n+    assert!(ten.div(&two)    == cast(5));\n+    assert!(ten.modulo(&two) == cast(0));\n+\n+    assert!(ten.add(&two)    == ten + two);\n+    assert!(ten.sub(&two)    == ten - two);\n+    assert!(ten.mul(&two)    == ten * two);\n+    assert!(ten.div(&two)    == ten / two);\n+    assert!(ten.modulo(&two) == ten % two);\n+}\n+\n+#[test] fn test_u8_num()    { test_num(10u8,  2u8)  }\n+#[test] fn test_u16_num()   { test_num(10u16, 2u16) }\n+#[test] fn test_u32_num()   { test_num(10u32, 2u32) }\n+#[test] fn test_u64_num()   { test_num(10u64, 2u64) }\n+#[test] fn test_uint_num()  { test_num(10u,   2u)   }\n+#[test] fn test_i8_num()    { test_num(10i8,  2i8)  }\n+#[test] fn test_i16_num()   { test_num(10i16, 2i16) }\n+#[test] fn test_i32_num()   { test_num(10i32, 2i32) }\n+#[test] fn test_i64_num()   { test_num(10i64, 2i64) }\n+#[test] fn test_int_num()   { test_num(10i,   2i)   }\n+#[test] fn test_f32_num()   { test_num(10f32, 2f32) }\n+#[test] fn test_f64_num()   { test_num(10f64, 2f64) }\n+#[test] fn test_float_num() { test_num(10f,   2f)   }\n+\n+macro_rules! test_cast_20(\n+    ($_20:expr) => ({\n+        let _20 = $_20;\n+\n+        assert!(20u   == _20.to_uint());\n+        assert!(20u8  == _20.to_u8());\n+        assert!(20u16 == _20.to_u16());\n+        assert!(20u32 == _20.to_u32());\n+        assert!(20u64 == _20.to_u64());\n+        assert!(20i   == _20.to_int());\n+        assert!(20i8  == _20.to_i8());\n+        assert!(20i16 == _20.to_i16());\n+        assert!(20i32 == _20.to_i32());\n+        assert!(20i64 == _20.to_i64());\n+        assert!(20f   == _20.to_float());\n+        assert!(20f32 == _20.to_f32());\n+        assert!(20f64 == _20.to_f64());\n+\n+        assert!(_20 == NumCast::from(20u));\n+        assert!(_20 == NumCast::from(20u8));\n+        assert!(_20 == NumCast::from(20u16));\n+        assert!(_20 == NumCast::from(20u32));\n+        assert!(_20 == NumCast::from(20u64));\n+        assert!(_20 == NumCast::from(20i));\n+        assert!(_20 == NumCast::from(20i8));\n+        assert!(_20 == NumCast::from(20i16));\n+        assert!(_20 == NumCast::from(20i32));\n+        assert!(_20 == NumCast::from(20i64));\n+        assert!(_20 == NumCast::from(20f));\n+        assert!(_20 == NumCast::from(20f32));\n+        assert!(_20 == NumCast::from(20f64));\n+\n+        assert!(_20 == cast(20u));\n+        assert!(_20 == cast(20u8));\n+        assert!(_20 == cast(20u16));\n+        assert!(_20 == cast(20u32));\n+        assert!(_20 == cast(20u64));\n+        assert!(_20 == cast(20i));\n+        assert!(_20 == cast(20i8));\n+        assert!(_20 == cast(20i16));\n+        assert!(_20 == cast(20i32));\n+        assert!(_20 == cast(20i64));\n+        assert!(_20 == cast(20f));\n+        assert!(_20 == cast(20f32));\n+        assert!(_20 == cast(20f64));\n+    })\n+)\n+\n+#[test] fn test_u8_cast()    { test_cast_20!(20u8)  }\n+#[test] fn test_u16_cast()   { test_cast_20!(20u16) }\n+#[test] fn test_u32_cast()   { test_cast_20!(20u32) }\n+#[test] fn test_u64_cast()   { test_cast_20!(20u64) }\n+#[test] fn test_uint_cast()  { test_cast_20!(20u)   }\n+#[test] fn test_i8_cast()    { test_cast_20!(20i8)  }\n+#[test] fn test_i16_cast()   { test_cast_20!(20i16) }\n+#[test] fn test_i32_cast()   { test_cast_20!(20i32) }\n+#[test] fn test_i64_cast()   { test_cast_20!(20i64) }\n+#[test] fn test_int_cast()   { test_cast_20!(20i)   }\n+#[test] fn test_f32_cast()   { test_cast_20!(20f32) }\n+#[test] fn test_f64_cast()   { test_cast_20!(20f64) }\n+#[test] fn test_float_cast() { test_cast_20!(20f)   }"}, {"sha": "1cbdabafdab9693c88c77ce506b315e427ed8271", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -411,18 +411,6 @@ pub fn test_ranges() {\n     }\n }\n \n-#[test]\n-pub fn test_num() {\n-    let ten: T = num::cast(10);\n-    let two: T = num::cast(2);\n-\n-    assert!((ten.add(&two)    == num::cast(12)));\n-    assert!((ten.sub(&two)    == num::cast(8)));\n-    assert!((ten.mul(&two)    == num::cast(20)));\n-    assert!((ten.div(&two)    == num::cast(5)));\n-    assert!((ten.modulo(&two) == num::cast(0)));\n-}\n-\n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]"}, {"sha": "63144162fc50aa842647fbdb55079336792d3e92", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,80 +10,9 @@\n \n //! Operations and constants for `u16`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = u16;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i16;\n     pub static bits: uint = 16;\n }\n-\n-impl NumCast for u16 {\n-    /**\n-     * Cast `n` to a `u16`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> u16 { n.to_u16() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self          }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20u16.to_uint()));\n-    assert!((20u8  == 20u16.to_u8()));\n-    assert!((20u16 == 20u16.to_u16()));\n-    assert!((20u32 == 20u16.to_u32()));\n-    assert!((20u64 == 20u16.to_u64()));\n-    assert!((20i   == 20u16.to_int()));\n-    assert!((20i8  == 20u16.to_i8()));\n-    assert!((20i16 == 20u16.to_i16()));\n-    assert!((20i32 == 20u16.to_i32()));\n-    assert!((20i64 == 20u16.to_i64()));\n-    assert!((20f   == 20u16.to_float()));\n-    assert!((20f32 == 20u16.to_f32()));\n-    assert!((20f64 == 20u16.to_f64()));\n-\n-    assert!((20u16 == NumCast::from(20u)));\n-    assert!((20u16 == NumCast::from(20u8)));\n-    assert!((20u16 == NumCast::from(20u16)));\n-    assert!((20u16 == NumCast::from(20u32)));\n-    assert!((20u16 == NumCast::from(20u64)));\n-    assert!((20u16 == NumCast::from(20i)));\n-    assert!((20u16 == NumCast::from(20i8)));\n-    assert!((20u16 == NumCast::from(20i16)));\n-    assert!((20u16 == NumCast::from(20i32)));\n-    assert!((20u16 == NumCast::from(20i64)));\n-    assert!((20u16 == NumCast::from(20f)));\n-    assert!((20u16 == NumCast::from(20f32)));\n-    assert!((20u16 == NumCast::from(20f64)));\n-\n-    assert!((20u16 == num::cast(20u)));\n-    assert!((20u16 == num::cast(20u8)));\n-    assert!((20u16 == num::cast(20u16)));\n-    assert!((20u16 == num::cast(20u32)));\n-    assert!((20u16 == num::cast(20u64)));\n-    assert!((20u16 == num::cast(20i)));\n-    assert!((20u16 == num::cast(20i8)));\n-    assert!((20u16 == num::cast(20i16)));\n-    assert!((20u16 == num::cast(20i32)));\n-    assert!((20u16 == num::cast(20i64)));\n-    assert!((20u16 == num::cast(20f)));\n-    assert!((20u16 == num::cast(20f32)));\n-    assert!((20u16 == num::cast(20f64)));\n-}"}, {"sha": "4d9958fe38aaf4e273d08838664642754f9ddeb5", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,80 +10,9 @@\n \n //! Operations and constants for `u32`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = u32;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i32;\n     pub static bits: uint = 32;\n }\n-\n-impl NumCast for u32 {\n-    /**\n-     * Cast `n` to a `u32`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> u32 { n.to_u32() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self          }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20u64.to_uint()));\n-    assert!((20u8  == 20u64.to_u8()));\n-    assert!((20u16 == 20u64.to_u16()));\n-    assert!((20u32 == 20u64.to_u32()));\n-    assert!((20u64 == 20u64.to_u64()));\n-    assert!((20i   == 20u64.to_int()));\n-    assert!((20i8  == 20u64.to_i8()));\n-    assert!((20i16 == 20u64.to_i16()));\n-    assert!((20i32 == 20u64.to_i32()));\n-    assert!((20i64 == 20u64.to_i64()));\n-    assert!((20f   == 20u64.to_float()));\n-    assert!((20f32 == 20u64.to_f32()));\n-    assert!((20f64 == 20u64.to_f64()));\n-\n-    assert!((20u64 == NumCast::from(20u)));\n-    assert!((20u64 == NumCast::from(20u8)));\n-    assert!((20u64 == NumCast::from(20u16)));\n-    assert!((20u64 == NumCast::from(20u32)));\n-    assert!((20u64 == NumCast::from(20u64)));\n-    assert!((20u64 == NumCast::from(20i)));\n-    assert!((20u64 == NumCast::from(20i8)));\n-    assert!((20u64 == NumCast::from(20i16)));\n-    assert!((20u64 == NumCast::from(20i32)));\n-    assert!((20u64 == NumCast::from(20i64)));\n-    assert!((20u64 == NumCast::from(20f)));\n-    assert!((20u64 == NumCast::from(20f32)));\n-    assert!((20u64 == NumCast::from(20f64)));\n-\n-    assert!((20u64 == num::cast(20u)));\n-    assert!((20u64 == num::cast(20u8)));\n-    assert!((20u64 == num::cast(20u16)));\n-    assert!((20u64 == num::cast(20u32)));\n-    assert!((20u64 == num::cast(20u64)));\n-    assert!((20u64 == num::cast(20i)));\n-    assert!((20u64 == num::cast(20i8)));\n-    assert!((20u64 == num::cast(20i16)));\n-    assert!((20u64 == num::cast(20i32)));\n-    assert!((20u64 == num::cast(20i64)));\n-    assert!((20u64 == num::cast(20f)));\n-    assert!((20u64 == num::cast(20f32)));\n-    assert!((20u64 == num::cast(20f64)));\n-}"}, {"sha": "af198dd69424b79f879a79aae7c8d6f64048cfb1", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,80 +10,9 @@\n \n //! Operations and constants for `u64`\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = u64;\n     #[allow(non_camel_case_types)]\n     pub type T_SIGNED = i64;\n     pub static bits: uint = 64;\n }\n-\n-impl NumCast for u64 {\n-    /**\n-     * Cast `n` to a `u64`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> u64 { n.to_u64() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self          }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20u64.to_uint()));\n-    assert!((20u8  == 20u64.to_u8()));\n-    assert!((20u16 == 20u64.to_u16()));\n-    assert!((20u32 == 20u64.to_u32()));\n-    assert!((20u64 == 20u64.to_u64()));\n-    assert!((20i   == 20u64.to_int()));\n-    assert!((20i8  == 20u64.to_i8()));\n-    assert!((20i16 == 20u64.to_i16()));\n-    assert!((20i32 == 20u64.to_i32()));\n-    assert!((20i64 == 20u64.to_i64()));\n-    assert!((20f   == 20u64.to_float()));\n-    assert!((20f32 == 20u64.to_f32()));\n-    assert!((20f64 == 20u64.to_f64()));\n-\n-    assert!((20u64 == NumCast::from(20u)));\n-    assert!((20u64 == NumCast::from(20u8)));\n-    assert!((20u64 == NumCast::from(20u16)));\n-    assert!((20u64 == NumCast::from(20u32)));\n-    assert!((20u64 == NumCast::from(20u64)));\n-    assert!((20u64 == NumCast::from(20i)));\n-    assert!((20u64 == NumCast::from(20i8)));\n-    assert!((20u64 == NumCast::from(20i16)));\n-    assert!((20u64 == NumCast::from(20i32)));\n-    assert!((20u64 == NumCast::from(20i64)));\n-    assert!((20u64 == NumCast::from(20f)));\n-    assert!((20u64 == NumCast::from(20f32)));\n-    assert!((20u64 == NumCast::from(20f64)));\n-\n-    assert!((20u64 == num::cast(20u)));\n-    assert!((20u64 == num::cast(20u8)));\n-    assert!((20u64 == num::cast(20u16)));\n-    assert!((20u64 == num::cast(20u32)));\n-    assert!((20u64 == num::cast(20u64)));\n-    assert!((20u64 == num::cast(20i)));\n-    assert!((20u64 == num::cast(20i8)));\n-    assert!((20u64 == num::cast(20i16)));\n-    assert!((20u64 == num::cast(20i32)));\n-    assert!((20u64 == num::cast(20i64)));\n-    assert!((20u64 == num::cast(20f)));\n-    assert!((20u64 == num::cast(20f32)));\n-    assert!((20u64 == num::cast(20f64)));\n-}"}, {"sha": "ce23bebacdad136976305038d0ea41db19f5fe9b", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -12,8 +12,6 @@\n \n pub use self::inst::is_ascii;\n \n-use num::NumCast;\n-\n mod inst {\n     pub type T = u8;\n     #[allow(non_camel_case_types)]\n@@ -25,72 +23,3 @@ mod inst {\n \n     pub fn is_ascii(x: T) -> bool { return 0 as T == x & 128 as T; }\n }\n-\n-impl NumCast for u8 {\n-    /**\n-     * Cast `n` to a `u8`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> u8 { n.to_u8() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self          }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u     == 20u8.to_uint()));\n-    assert!((20u8    == 20u8.to_u8()));\n-    assert!((20u16   == 20u8.to_u16()));\n-    assert!((20u32   == 20u8.to_u32()));\n-    assert!((20u64   == 20u8.to_u64()));\n-    assert!((20i     == 20u8.to_int()));\n-    assert!((20i8    == 20u8.to_i8()));\n-    assert!((20i16   == 20u8.to_i16()));\n-    assert!((20i32   == 20u8.to_i32()));\n-    assert!((20i64   == 20u8.to_i64()));\n-    assert!((20f     == 20u8.to_float()));\n-    assert!((20f32   == 20u8.to_f32()));\n-    assert!((20f64   == 20u8.to_f64()));\n-\n-    assert!((20u8 == NumCast::from(20u)));\n-    assert!((20u8 == NumCast::from(20u8)));\n-    assert!((20u8 == NumCast::from(20u16)));\n-    assert!((20u8 == NumCast::from(20u32)));\n-    assert!((20u8 == NumCast::from(20u64)));\n-    assert!((20u8 == NumCast::from(20i)));\n-    assert!((20u8 == NumCast::from(20i8)));\n-    assert!((20u8 == NumCast::from(20i16)));\n-    assert!((20u8 == NumCast::from(20i32)));\n-    assert!((20u8 == NumCast::from(20i64)));\n-    assert!((20u8 == NumCast::from(20f)));\n-    assert!((20u8 == NumCast::from(20f32)));\n-    assert!((20u8 == NumCast::from(20f64)));\n-\n-    assert!((20u8 == num::cast(20u)));\n-    assert!((20u8 == num::cast(20u8)));\n-    assert!((20u8 == num::cast(20u16)));\n-    assert!((20u8 == num::cast(20u32)));\n-    assert!((20u8 == num::cast(20u64)));\n-    assert!((20u8 == num::cast(20i)));\n-    assert!((20u8 == num::cast(20i8)));\n-    assert!((20u8 == num::cast(20i16)));\n-    assert!((20u8 == num::cast(20i32)));\n-    assert!((20u8 == num::cast(20i64)));\n-    assert!((20u8 == num::cast(20f)));\n-    assert!((20u8 == num::cast(20f32)));\n-    assert!((20u8 == num::cast(20f64)));\n-}"}, {"sha": "efcf68aba3160f228c2a208f3acc3d0512b406d7", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -10,8 +10,6 @@\n \n //! Operations and constants for `uint`\n \n-use num::NumCast;\n-\n pub use self::inst::{\n     div_ceil, div_round, div_floor, iterate,\n     next_power_of_two\n@@ -209,72 +207,3 @@ pub mod inst {\n         assert!((accum == 10));\n     }\n }\n-\n-impl NumCast for uint {\n-    /**\n-     * Cast `n` to a `uint`\n-     */\n-    #[inline(always)]\n-    fn from<N:NumCast>(n: N) -> uint { n.to_uint() }\n-\n-    #[inline(always)] fn to_u8(&self)    -> u8    { *self as u8    }\n-    #[inline(always)] fn to_u16(&self)   -> u16   { *self as u16   }\n-    #[inline(always)] fn to_u32(&self)   -> u32   { *self as u32   }\n-    #[inline(always)] fn to_u64(&self)   -> u64   { *self as u64   }\n-    #[inline(always)] fn to_uint(&self)  -> uint  { *self          }\n-\n-    #[inline(always)] fn to_i8(&self)    -> i8    { *self as i8    }\n-    #[inline(always)] fn to_i16(&self)   -> i16   { *self as i16   }\n-    #[inline(always)] fn to_i32(&self)   -> i32   { *self as i32   }\n-    #[inline(always)] fn to_i64(&self)   -> i64   { *self as i64   }\n-    #[inline(always)] fn to_int(&self)   -> int   { *self as int   }\n-\n-    #[inline(always)] fn to_f32(&self)   -> f32   { *self as f32   }\n-    #[inline(always)] fn to_f64(&self)   -> f64   { *self as f64   }\n-    #[inline(always)] fn to_float(&self) -> float { *self as float }\n-}\n-\n-#[test]\n-fn test_numcast() {\n-    assert!((20u   == 20u.to_uint()));\n-    assert!((20u8  == 20u.to_u8()));\n-    assert!((20u16 == 20u.to_u16()));\n-    assert!((20u32 == 20u.to_u32()));\n-    assert!((20u64 == 20u.to_u64()));\n-    assert!((20i   == 20u.to_int()));\n-    assert!((20i8  == 20u.to_i8()));\n-    assert!((20i16 == 20u.to_i16()));\n-    assert!((20i32 == 20u.to_i32()));\n-    assert!((20i64 == 20u.to_i64()));\n-    assert!((20f   == 20u.to_float()));\n-    assert!((20f32 == 20u.to_f32()));\n-    assert!((20f64 == 20u.to_f64()));\n-\n-    assert!((20u == NumCast::from(20u)));\n-    assert!((20u == NumCast::from(20u8)));\n-    assert!((20u == NumCast::from(20u16)));\n-    assert!((20u == NumCast::from(20u32)));\n-    assert!((20u == NumCast::from(20u64)));\n-    assert!((20u == NumCast::from(20i)));\n-    assert!((20u == NumCast::from(20i8)));\n-    assert!((20u == NumCast::from(20i16)));\n-    assert!((20u == NumCast::from(20i32)));\n-    assert!((20u == NumCast::from(20i64)));\n-    assert!((20u == NumCast::from(20f)));\n-    assert!((20u == NumCast::from(20f32)));\n-    assert!((20u == NumCast::from(20f64)));\n-\n-    assert!((20u == num::cast(20u)));\n-    assert!((20u == num::cast(20u8)));\n-    assert!((20u == num::cast(20u16)));\n-    assert!((20u == num::cast(20u32)));\n-    assert!((20u == num::cast(20u64)));\n-    assert!((20u == num::cast(20i)));\n-    assert!((20u == num::cast(20i8)));\n-    assert!((20u == num::cast(20i16)));\n-    assert!((20u == num::cast(20i32)));\n-    assert!((20u == num::cast(20i64)));\n-    assert!((20u == num::cast(20f)));\n-    assert!((20u == num::cast(20f32)));\n-    assert!((20u == num::cast(20f64)));\n-}"}, {"sha": "e148493ca45121a29f39fec847ed9837f5a5fd4a", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -34,7 +34,7 @@ pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::Times;\n-pub use num::NumCast;\n+pub use num::{Num, NumCast};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "0fb2a6b2e724bf7c453f146025161c831525e196", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -16,7 +16,7 @@ use core::cmp::{Eq, Ord};\n use core::num::NumCast::from;\n use std::cmp::FuzzyEq;\n \n-pub trait NumExt: NumCast + Eq + Ord {}\n+pub trait NumExt: Num + NumCast + Eq + Ord {}\n \n pub trait FloatExt: NumExt + FuzzyEq<Self> {}\n "}, {"sha": "d580b99012fa5a3b6878f27eaaceb1519bd32b7d", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -11,7 +11,7 @@\n use core::cmp::Ord;\n use core::num::NumCast::from;\n \n-pub trait NumExt: NumCast + Ord { }\n+pub trait NumExt: Num + NumCast + Ord { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n     *n > from(1)"}, {"sha": "b40f647814f0c87cdfb17b55b4d45cb8491b475d", "filename": "src/test/run-pass/trait-inheritance-num2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num2.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -38,7 +38,7 @@ impl TypeExt for f64 {}\n impl TypeExt for float {}\n \n \n-pub trait NumExt: TypeExt + Eq + Ord + NumCast {}\n+pub trait NumExt: TypeExt + Eq + Ord + Num + NumCast {}\n \n impl NumExt for u8 {}\n impl NumExt for u16 {}"}, {"sha": "5f1fef80ef20139e00fe2b059ff7e72d29f43104", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -11,7 +11,7 @@\n use core::cmp::{Eq, Ord};\n use core::num::NumCast::from;\n \n-pub trait NumExt: Eq + Ord + NumCast {}\n+pub trait NumExt: Eq + Ord + Num + NumCast {}\n \n impl NumExt for f32 {}\n "}, {"sha": "02cc9a3d221f8f8db465eb16cfad3c7ab2c8a476", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f337a58ce23a7be54c40885f8fbf5ed93fd8f84/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=9f337a58ce23a7be54c40885f8fbf5ed93fd8f84", "patch": "@@ -11,7 +11,7 @@\n use core::cmp::{Eq, Ord};\n use core::num::NumCast::from;\n \n-pub trait NumExt: Eq + NumCast {}\n+pub trait NumExt: Eq + Num + NumCast {}\n \n impl NumExt for f32 {}\n impl NumExt for int {}"}]}