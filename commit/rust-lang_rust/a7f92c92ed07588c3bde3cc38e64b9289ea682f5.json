{"sha": "a7f92c92ed07588c3bde3cc38e64b9289ea682f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZjkyYzkyZWQwNzU4OGMzYmRlM2NjMzhlNjRiOTI4OWVhNjgyZjU=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-14T19:04:11Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-14T19:04:11Z"}, "message": "Added a UdpWatcher and UdpSendRequest with associated callbacks", "tree": {"sha": "2dbfa471a12238f9c06b0ab4cb124821fa1903ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dbfa471a12238f9c06b0ab4cb124821fa1903ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7f92c92ed07588c3bde3cc38e64b9289ea682f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f92c92ed07588c3bde3cc38e64b9289ea682f5", "html_url": "https://github.com/rust-lang/rust/commit/a7f92c92ed07588c3bde3cc38e64b9289ea682f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7f92c92ed07588c3bde3cc38e64b9289ea682f5/comments", "author": null, "committer": null, "parents": [{"sha": "03fe59aefa6ec84531335fd93e8dbf44dee65570", "url": "https://api.github.com/repos/rust-lang/rust/commits/03fe59aefa6ec84531335fd93e8dbf44dee65570", "html_url": "https://github.com/rust-lang/rust/commit/03fe59aefa6ec84531335fd93e8dbf44dee65570"}], "stats": {"total": 189, "additions": 184, "deletions": 5}, "files": [{"sha": "f7cc5c6cc8b02c289b476c2ee1eccdf39cc39a6f", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a7f92c92ed07588c3bde3cc38e64b9289ea682f5/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f92c92ed07588c3bde3cc38e64b9289ea682f5/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=a7f92c92ed07588c3bde3cc38e64b9289ea682f5", "patch": "@@ -54,7 +54,7 @@ use rt::io::IoError;\n #[cfg(test)] use unstable::run_in_bare_thread;\n \n pub use self::file::FsRequest;\n-pub use self::net::{StreamWatcher, TcpWatcher};\n+pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n@@ -128,6 +128,8 @@ pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n+pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, Ipv4, uint, Option<UvError>);\n+pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n \n \n /// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n@@ -139,7 +141,9 @@ struct WatcherData {\n     alloc_cb: Option<AllocCallback>,\n     idle_cb: Option<IdleCallback>,\n     timer_cb: Option<TimerCallback>,\n-    async_cb: Option<AsyncCallback>\n+    async_cb: Option<AsyncCallback>,\n+    udp_recv_cb: Option<UdpReceiveCallback>,\n+    udp_send_cb: Option<UdpSendCallback>\n }\n \n pub trait WatcherInterop {\n@@ -169,7 +173,9 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 alloc_cb: None,\n                 idle_cb: None,\n                 timer_cb: None,\n-                async_cb: None\n+                async_cb: None,\n+                udp_recv_cb: None,\n+                udp_send_cb: None\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);\n@@ -309,6 +315,9 @@ pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError>\n /// The uv buffer type\n pub type Buf = uvll::uv_buf_t;\n \n+/// The uv IPv4 type\n+pub type Ipv4 = uvll::sockaddr_in;\n+\n /// Borrow a slice to a Buf\n pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     let data = vec::raw::to_ptr(v);"}, {"sha": "4079a2f7b770b322d1b75d67580a446b5dd8c1ce", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 172, "deletions": 2, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/a7f92c92ed07588c3bde3cc38e64b9289ea682f5/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f92c92ed07588c3bde3cc38e64b9289ea682f5/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=a7f92c92ed07588c3bde3cc38e64b9289ea682f5", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n use prelude::*;\n-use libc::{size_t, ssize_t, c_int, c_void};\n+use libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n-use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback};\n+use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback, UdpSendCallback};\n use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n              status_to_maybe_uv_error};\n use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n@@ -254,6 +254,142 @@ impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n     }\n }\n \n+pub struct UdpWatcher(*uvll::uv_udp_t);\n+impl Watcher for UdpWatcher { }\n+\n+pub impl UdpWatcher {\n+    fn new(loop_: &mut Loop) -> UdpWatcher {\n+        unsafe {\n+            let handle = malloc_handle(UV_UDP);\n+            assert!(handle.is_not_null());\n+            assert_eq!(0, uvll::udp_init(loop_.native_handle(), handle));\n+            let mut watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n+        match address {\n+            Ipv4(*) => {\n+                do ip4_as_uv_ip4(address) |addr| {\n+                    let result = unsafe {\n+                        uvll::udp_bind(self.native_handle(), addr, 0u32)\n+                    };\n+                    if result == 0 {\n+                        Ok(())\n+                    } else {\n+                        Err(last_uv_error(self))\n+                    }\n+                }\n+            }\n+            _ => fail!() // TODO ipv6\n+        }\n+    }\n+\n+    fn recv_start(&mut self, alloc: AllocCallback, cb: UdpReceiveCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.alloc_cb = Some(alloc);\n+            data.udp_recv_cb = Some(cb);\n+        }\n+\n+        let handle = self.native_handle();\n+        unsafe { uvll::read_start(handle, alloc_cb, recv_cb); }\n+\n+        extern fn alloc_cb(handle: *uvll::uv_udp_t, suggested_size: size_t) -> Buf {\n+            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            let data = udp_watcher.get_watcher_data();\n+            let alloc_cb = data.alloc_cb.get_ref();\n+            return (*alloc_cb)(suggested_size as uint);\n+        }\n+\n+        /* TODO the socket address should actually be a pointer to either a sockaddr_in or sockaddr_in6.\n+           In libuv, the udp_recv callback takes a struct *sockaddr */\n+        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: Buf, \n+                          address: *uvll::sockaddr_in, flags: c_uint) {\n+            rtdebug!(\"buf addr: %x\", buf.base as uint);\n+            rtdebug!(\"buf len: %d\", buf.len as int);\n+            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            let data = udp_watcher.get_watcher_data();\n+            let cb = data.udp_recv_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, nread as c_int);\n+            unsafe { (*cb)(udp_watcher, nread as int, buf, *address, flags as uint, status) };\n+        }\n+    }\n+\n+    fn recv_stop(&mut self) {\n+        let handle = self.native_handle();\n+        unsafe { uvll::udp_recv_stop(handle); }\n+    }\n+\n+    fn send(&mut self, buf: Buf, address: IpAddr, cb: UdpSendCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.udp_send_cb.is_none());\n+            data.udp_send_cb = Some(cb);\n+        }\n+\n+        let req = UdpSendRequest::new();\n+        let bufs = [buf];\n+        match address {\n+            Ipv4(*) => {\n+                do ip4_as_uv_ip4(address) |addr| {\n+                    unsafe {\n+                        assert!(0 == uvll::udp_send(req.native_handle(),\n+                                                    self.native_handle(),\n+                                                    bufs, addr, send_cb));\n+                    }\n+                }\n+            }\n+            _ => fail!() // TODO ipv6\n+        }\n+\n+        extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n+            let send_request: UdpSendRequest = NativeHandle::from_native_handle(req);\n+            let mut udp_watcher = send_request.handle();\n+            send_request.delete();\n+            let cb = {\n+                let data = udp_watcher.get_watcher_data();\n+                let cb = data.udp_send_cb.swap_unwrap();\n+                cb\n+            };\n+            let status = status_to_maybe_uv_error(udp_watcher.native_handle(), status);\n+            cb(udp_watcher, status);\n+        }\n+    }\n+\n+    fn close(self, cb: NullCallback) {\n+        {\n+            let mut this = self;\n+            let data = this.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n+\n+        extern fn close_cb(handle: *uvll::uv_udp_t) {\n+            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n+            {\n+                let data = udp_watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n+            }\n+            udp_watcher.drop_watcher_data();\n+            unsafe { free_handle(handle as *c_void) }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {\n+    fn from_native_handle(handle: *uvll::uv_udp_t) -> UdpWatcher {\n+        UdpWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_udp_t {\n+        match self { &UdpWatcher(ptr) => ptr }\n+    }\n+}\n+\n // uv_connect_t is a subclass of uv_req_t\n struct ConnectRequest(*uvll::uv_connect_t);\n impl Request for ConnectRequest { }\n@@ -327,6 +463,40 @@ impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n     }\n }\n \n+pub struct UdpSendRequest(*uvll::uv_udp_send_t);\n+\n+impl Request for UdpSendRequest { }\n+\n+pub impl UdpSendRequest {\n+    fn new() -> UdpSendRequest {\n+        let send_handle = unsafe {\n+            malloc_req(UV_UDP_SEND)\n+        };\n+        assert!(send_handle.is_not_null());\n+        let send_handle = send_handle as *uvll::uv_udp_send_t;\n+        UdpSendRequest(send_handle)\n+    }\n+\n+    fn handle(&self) -> UdpWatcher {\n+        unsafe {\n+            let udp_handle = uvll::get_udp_handle_from_send_req(self.native_handle());\n+            NativeHandle::from_native_handle(udp_handle)\n+        }\n+    }\n+\n+    fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_udp_send_t> for UdpSendRequest {\n+    fn from_native_handle(handle: *uvll::uv_udp_send_t) -> UdpSendRequest {\n+        UdpSendRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_udp_send_t {\n+        match self { &UdpSendRequest(ptr) => ptr }\n+    }\n+}\n \n #[cfg(test)]\n mod test {"}]}