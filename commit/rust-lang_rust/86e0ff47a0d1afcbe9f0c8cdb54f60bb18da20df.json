{"sha": "86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZTBmZjQ3YTBkMWFmY2JlOWYwYzhjZGI1NGY2MGJiMThkYTIwZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-18T08:39:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-18T08:39:31Z"}, "message": "Auto merge of #80995 - tmandry:instrument-method-checker, r=lcnr\n\nAdd tracing instrumentation to method typeck\n\nI was recently digging into how this code works, and this instrumentation was helpful.", "tree": {"sha": "2cd5b2725f86d2948c117bdcd84b9c008b41535f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cd5b2725f86d2948c117bdcd84b9c008b41535f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "html_url": "https://github.com/rust-lang/rust/commit/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0677d9729318441a1cdb0c74812ec4140fa4d35f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0677d9729318441a1cdb0c74812ec4140fa4d35f", "html_url": "https://github.com/rust-lang/rust/commit/0677d9729318441a1cdb0c74812ec4140fa4d35f"}, {"sha": "6af831ace693ed380c3dba78cf133ffdd6d460de", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af831ace693ed380c3dba78cf133ffdd6d460de", "html_url": "https://github.com/rust-lang/rust/commit/6af831ace693ed380c3dba78cf133ffdd6d460de"}], "stats": {"total": 14, "additions": 12, "deletions": 2}, "files": [{"sha": "97c9620eb16c3fb39eba9c78d47bd0ba71aabdef", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "patch": "@@ -31,6 +31,7 @@ impl<'a, 'tcx> Deref for ConfirmContext<'a, 'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n pub struct ConfirmResult<'tcx> {\n     pub callee: MethodCallee<'tcx>,\n     pub illegal_sized_bound: Option<Span>,"}, {"sha": "9a3d1e42b732ab7c7bfa40aec0ad4cabb78ab003", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "patch": "@@ -102,6 +102,7 @@ pub enum CandidateSource {\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn method_exists(\n         &self,\n         method_name: Ident,\n@@ -129,6 +130,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Adds a suggestion to call the given method to the provided diagnostic.\n+    #[instrument(level = \"debug\", skip(self, err, call_expr))]\n     crate fn suggest_method_call(\n         &self,\n         err: &mut DiagnosticBuilder<'a>,\n@@ -177,6 +179,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// * `span`:                  the span for the method call\n     /// * `call_expr`:             the complete method call: (`foo.bar::<T1,...Tn>(...)`)\n     /// * `self_expr`:             the self expression (`foo`)\n+    #[instrument(level = \"debug\", skip(self, call_expr, self_expr))]\n     pub fn lookup_method(\n         &self,\n         self_ty: Ty<'tcx>,\n@@ -204,6 +207,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result =\n             self.confirm_method(span, self_expr, call_expr, self_ty, pick.clone(), segment);\n+        debug!(\"result = {:?}\", result);\n \n         if let Some(span) = result.illegal_sized_bound {\n             let mut needs_mut = false;\n@@ -256,6 +260,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(result.callee)\n     }\n \n+    #[instrument(level = \"debug\", skip(self, call_expr))]\n     pub fn lookup_probe(\n         &self,\n         span: Span,\n@@ -286,6 +291,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // FIXME(#18741): it seems likely that we can consolidate some of this\n     // code with the other method-lookup code. In particular, the second half\n     // of this method is basically the same as confirmation.\n+    #[instrument(level = \"debug\", skip(self, span, opt_input_types))]\n     pub fn lookup_method_in_trait(\n         &self,\n         span: Span,\n@@ -409,6 +415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Some(InferOk { obligations, value: callee })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn resolve_ufcs(\n         &self,\n         span: Span,"}, {"sha": "8335239f804b02b21a0197a7ff63861acbba3ef3", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "patch": "@@ -48,7 +48,7 @@ pub use self::PickKind::*;\n \n /// Boolean flag used to indicate if this search is for a suggestion\n /// or not. If true, we can allow ambiguity and so forth.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub struct IsSuggestion(pub bool);\n \n struct ProbeContext<'a, 'tcx> {\n@@ -219,6 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// would result in an error (basically, the same criteria we\n     /// would use to decide if a method is a plausible fit for\n     /// ambiguity purposes).\n+    #[instrument(level = \"debug\", skip(self, scope_expr_id))]\n     pub fn probe_for_return_type(\n         &self,\n         span: Span,\n@@ -264,6 +265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n+    #[instrument(level = \"debug\", skip(self, scope_expr_id))]\n     pub fn probe_for_name(\n         &self,\n         span: Span,\n@@ -770,7 +772,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // will be reported by `object_safety.rs` if the method refers to the\n         // `Self` type anywhere other than the receiver. Here, we use a\n         // substitution that replaces `Self` with the object type itself. Hence,\n-        // a `&self` method will wind up with an argument type like `&Trait`.\n+        // a `&self` method will wind up with an argument type like `&dyn Trait`.\n         let trait_ref = principal.with_self_ty(self.tcx, self_ty);\n         self.elaborate_bounds(iter::once(trait_ref), |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(new_trait_ref);"}]}