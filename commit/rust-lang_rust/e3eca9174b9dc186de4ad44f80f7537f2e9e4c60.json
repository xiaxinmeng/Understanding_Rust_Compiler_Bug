{"sha": "e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZWNhOTE3NGI5ZGMxODZkZTRhZDQ0ZjgwZjc1MzdmMmU5ZTRjNjA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-07T20:06:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-07T20:08:28Z"}, "message": "Change literal representation to not truncate\n\nAlso shuffles around the organization of numeric literals and types,\nseparating by int/uint/float instead of machine-vs-non-machine types.\nThis simplifies some code.\n\nCloses #974\nCloses #1252", "tree": {"sha": "ff9c8c7fd97f0cb8daecc002b1855412846f7757", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff9c8c7fd97f0cb8daecc002b1855412846f7757"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "html_url": "https://github.com/rust-lang/rust/commit/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6daa233a73541c4daf135ac5dd9e339289fdfbfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6daa233a73541c4daf135ac5dd9e339289fdfbfd", "html_url": "https://github.com/rust-lang/rust/commit/6daa233a73541c4daf135ac5dd9e339289fdfbfd"}], "stats": {"total": 1210, "additions": 479, "deletions": 731}, "files": [{"sha": "590f8a1f1929981995b43b58da50a17659aca74e", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -2,7 +2,7 @@\n import syntax::{ast, codemap};\n import syntax::ast::node_id;\n import codemap::span;\n-import syntax::ast::ty_mach;\n+import syntax::ast::{int_ty, uint_ty, float_ty};\n import std::{option};\n import std::option::{some, none};\n import syntax::parse::parser::parse_sess;\n@@ -17,9 +17,9 @@ type config =\n     {os: os,\n      arch: arch,\n      target_strs: target_strs::t,\n-     int_type: ty_mach,\n-     uint_type: ty_mach,\n-     float_type: ty_mach};\n+     int_type: int_ty,\n+     uint_type: uint_ty,\n+     float_type: float_ty};\n \n type options =\n     // The crate config requested for the session, which may be combined"}, {"sha": "3b71e09c1f787d6773a035c21c13fc39e2f24262", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -174,16 +174,16 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       'l' { ret ty::mk_float(st.tcx); }\n       'M' {\n         alt next(st) as char {\n-          'b' { ret ty::mk_mach(st.tcx, ast::ty_u8); }\n-          'w' { ret ty::mk_mach(st.tcx, ast::ty_u16); }\n-          'l' { ret ty::mk_mach(st.tcx, ast::ty_u32); }\n-          'd' { ret ty::mk_mach(st.tcx, ast::ty_u64); }\n-          'B' { ret ty::mk_mach(st.tcx, ast::ty_i8); }\n-          'W' { ret ty::mk_mach(st.tcx, ast::ty_i16); }\n-          'L' { ret ty::mk_mach(st.tcx, ast::ty_i32); }\n-          'D' { ret ty::mk_mach(st.tcx, ast::ty_i64); }\n-          'f' { ret ty::mk_mach(st.tcx, ast::ty_f32); }\n-          'F' { ret ty::mk_mach(st.tcx, ast::ty_f64); }\n+          'b' { ret ty::mk_mach_uint(st.tcx, ast::ty_u8); }\n+          'w' { ret ty::mk_mach_uint(st.tcx, ast::ty_u16); }\n+          'l' { ret ty::mk_mach_uint(st.tcx, ast::ty_u32); }\n+          'd' { ret ty::mk_mach_uint(st.tcx, ast::ty_u64); }\n+          'B' { ret ty::mk_mach_int(st.tcx, ast::ty_i8); }\n+          'W' { ret ty::mk_mach_int(st.tcx, ast::ty_i16); }\n+          'L' { ret ty::mk_mach_int(st.tcx, ast::ty_i32); }\n+          'D' { ret ty::mk_mach_int(st.tcx, ast::ty_i64); }\n+          'f' { ret ty::mk_mach_float(st.tcx, ast::ty_f32); }\n+          'F' { ret ty::mk_mach_float(st.tcx, ast::ty_f64); }\n         }\n       }\n       'c' { ret ty::mk_char(st.tcx); }"}, {"sha": "dafae567244b1a523ed02020db4cfa945f4ab383", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -90,24 +90,32 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_nil. { w.write_char('n'); }\n       ty::ty_bot. { w.write_char('z'); }\n       ty::ty_bool. { w.write_char('b'); }\n-      ty::ty_int. { w.write_char('i'); }\n-      ty::ty_uint. { w.write_char('u'); }\n-      ty::ty_float. { w.write_char('l'); }\n-      ty::ty_machine(mach) {\n-        alt mach {\n-          ty_u8. { w.write_str(\"Mb\"); }\n-          ty_u16. { w.write_str(\"Mw\"); }\n-          ty_u32. { w.write_str(\"Ml\"); }\n-          ty_u64. { w.write_str(\"Md\"); }\n+      ty::ty_int(t) {\n+        alt t {\n+          ty_i. { w.write_char('i'); }\n+          ty_char. { w.write_char('c'); }\n           ty_i8. { w.write_str(\"MB\"); }\n           ty_i16. { w.write_str(\"MW\"); }\n           ty_i32. { w.write_str(\"ML\"); }\n           ty_i64. { w.write_str(\"MD\"); }\n+        }\n+      }\n+      ty::ty_uint(t) {\n+        alt t {\n+          ty_u. { w.write_char('u'); }\n+          ty_u8. { w.write_str(\"Mb\"); }\n+          ty_u16. { w.write_str(\"Mw\"); }\n+          ty_u32. { w.write_str(\"Ml\"); }\n+          ty_u64. { w.write_str(\"Md\"); }\n+        }\n+      }\n+      ty::ty_float(t) {\n+        alt t {\n+          ty_f. { w.write_char('l'); }\n           ty_f32. { w.write_str(\"Mf\"); }\n           ty_f64. { w.write_str(\"MF\"); }\n         }\n       }\n-      ty::ty_char. { w.write_char('c'); }\n       ty::ty_str. { w.write_char('S'); }\n       ty::ty_tag(def, tys) {\n         w.write_str(\"t[\");"}, {"sha": "eb9122bfa7dc321610d1e7585becba788ec2f09a", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -553,9 +553,8 @@ fn local_id_of_node(cx: ctx, id: node_id) -> uint {\n fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n     fn score_ty(tcx: ty::ctxt, ty: ty::t) -> uint {\n         ret alt ty::struct(tcx, ty) {\n-          ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. |\n-          ty::ty_uint. | ty::ty_float. | ty::ty_machine(_) |\n-          ty::ty_char. | ty::ty_type. | ty::ty_native(_) |\n+          ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int(_) |\n+          ty::ty_uint(_) | ty::ty_float(_) | ty::ty_type. | ty::ty_native(_) |\n           ty::ty_ptr(_) { 1u }\n           ty::ty_box(_) { 3u }\n           ty::ty_constr(t, _) | ty::ty_res(_, t, _) { score_ty(tcx, t) }"}, {"sha": "c14ef93f3623a10024d5b3e47cf0b17efe679788", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -102,8 +102,8 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n \n fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n     alt ty::struct(cx, ty) {\n-      ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. | ty::ty_float. |\n-      ty::ty_uint. | ty::ty_machine(_) | ty::ty_char. | ty::ty_str. |\n+      ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int(_) |\n+      ty::ty_float(_) | ty::ty_uint(_) | ty::ty_str. |\n       ty::ty_type. | ty::ty_native(_) | ty::ty_ptr(_) | ty::ty_type. |\n       ty::ty_native(_) {\n         ret false;"}, {"sha": "6bf91384cbb6be64142503478eb247862281af03", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 16, "deletions": 66, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -299,54 +299,27 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n     let s = [];\n \n     alt ty::struct(ccx.tcx, t) {\n-      ty::ty_nil. | ty::ty_bool. | ty::ty_machine(ast::ty_u8.) | ty::ty_bot. {\n-        s += [shape_u8];\n-      }\n-\n-\n-\n-\n-\n-      ty::ty_int. {\n-        s += [s_int(ccx.tcx)];\n-      }\n-      ty::ty_float. { s += [s_float(ccx.tcx)]; }\n-\n-\n-\n-\n-\n-      ty::ty_uint. | ty::ty_ptr(_) | ty::ty_type. | ty::ty_native(_) {\n-        s += [s_uint(ccx.tcx)];\n-      }\n-\n-\n-\n-\n-\n-      ty::ty_machine(ast::ty_i8.) {\n-        s += [shape_i8];\n-      }\n-      ty::ty_machine(ast::ty_u16.) { s += [shape_u16]; }\n-      ty::ty_machine(ast::ty_i16.) { s += [shape_i16]; }\n-      ty::ty_machine(ast::ty_u32.) | ty::ty_char. { s += [shape_u32]; }\n-      ty::ty_machine(ast::ty_i32.) { s += [shape_i32]; }\n-      ty::ty_machine(ast::ty_u64.) { s += [shape_u64]; }\n-      ty::ty_machine(ast::ty_i64.) { s += [shape_i64]; }\n-\n-      ty::ty_machine(ast::ty_f32.) { s += [shape_f32]; }\n-      ty::ty_machine(ast::ty_f64.) { s += [shape_f64]; }\n-\n+      ty::ty_nil. | ty::ty_bool. | ty::ty_uint(ast::ty_u8.) |\n+      ty::ty_bot. { s += [shape_u8]; }\n+      ty::ty_int(ast::ty_i.) { s += [s_int(ccx.tcx)]; }\n+      ty::ty_float(ast::ty_f.) { s += [s_float(ccx.tcx)]; }\n+      ty::ty_uint(ast::ty_u.) | ty::ty_ptr(_) | ty::ty_type. |\n+      ty::ty_native(_) { s += [s_uint(ccx.tcx)]; }\n+      ty::ty_int(ast::ty_i8.) { s += [shape_i8]; }\n+      ty::ty_uint(ast::ty_u16.) { s += [shape_u16]; }\n+      ty::ty_int(ast::ty_i16.) { s += [shape_i16]; }\n+      ty::ty_uint(ast::ty_u32.) { s += [shape_u32]; }\n+      ty::ty_int(ast::ty_i32.) | ty::ty_int(ast::ty_char.) {s += [shape_i32];}\n+      ty::ty_uint(ast::ty_u64.) { s += [shape_u64]; }\n+      ty::ty_int(ast::ty_i64.) { s += [shape_i64]; }\n+      ty::ty_float(ast::ty_f32.) { s += [shape_f32]; }\n+      ty::ty_float(ast::ty_f64.) { s += [shape_f64]; }\n       ty::ty_str. {\n         s += [shape_vec];\n         add_bool(s, true); // type is POD\n-        let unit_ty = ty::mk_mach(ccx.tcx, ast::ty_u8);\n+        let unit_ty = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         add_substr(s, shape_of(ccx, unit_ty, ty_param_map, is_obj_body));\n       }\n-\n-\n-\n-\n       ty::ty_tag(did, tps) {\n         alt tag_kind(ccx, did) {\n           tk_unit. {\n@@ -382,11 +355,6 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n           }\n         }\n       }\n-\n-\n-\n-\n-\n       ty::ty_box(mt) {\n         s += [shape_box];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map, is_obj_body));\n@@ -416,21 +384,11 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n         }\n         add_substr(s, sub);\n       }\n-\n-\n-\n-\n-\n       ty::ty_fn(_, _, _, _, _) {\n         s += [shape_fn];\n       }\n       ty::ty_native_fn(_, _) { s += [shape_u32]; }\n       ty::ty_obj(_) { s += [shape_obj]; }\n-\n-\n-\n-\n-\n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n         let ri = {did: did, t: subt};\n@@ -445,17 +403,9 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n         add_substr(s, shape_of(ccx, subt, ty_param_map, is_obj_body));\n \n       }\n-\n-\n-\n-\n       ty::ty_var(n) {\n         fail \"shape_of ty_var\";\n       }\n-\n-\n-\n-\n       ty::ty_param(n, _) {\n         if is_obj_body {\n             // Just write in the parameter number."}, {"sha": "458266298d4b0e7dcef8cba14d15bce5621de648", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 13, "deletions": 62, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -130,20 +130,9 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         T_nil() /* ...I guess? */\n       }\n       ty::ty_bool. { T_bool() }\n-      ty::ty_int. { cx.int_type }\n-      ty::ty_float. { cx.float_type }\n-      ty::ty_uint. { cx.int_type }\n-      ty::ty_machine(tm) {\n-        alt tm {\n-          ast::ty_i8. | ast::ty_u8. { T_i8() }\n-          ast::ty_i16. | ast::ty_u16. { T_i16() }\n-          ast::ty_i32. | ast::ty_u32. { T_i32() }\n-          ast::ty_i64. | ast::ty_u64. { T_i64() }\n-          ast::ty_f32. { T_f32() }\n-          ast::ty_f64. { T_f64() }\n-        }\n-      }\n-      ty::ty_char. { T_char() }\n+      ty::ty_int(t) { T_int_ty(cx, t) }\n+      ty::ty_uint(t) { T_uint_ty(cx, t) }\n+      ty::ty_float(t) { T_float_ty(cx, t) }\n       ty::ty_str. { T_ptr(T_vec(cx, T_i8())) }\n       ty::ty_tag(did, _) { type_of_tag(cx, sp, did, t) }\n       ty::ty_box(mt) {\n@@ -1516,23 +1505,10 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n \n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_nil. { ret rslt(cx, f(nil_type)); }\n-      ty::ty_bool. | ty::ty_uint. | ty::ty_ptr(_) | ty::ty_char. {\n-        ret rslt(cx, f(unsigned_int));\n-      }\n-      ty::ty_int. { ret rslt(cx, f(signed_int)); }\n-      ty::ty_float. { ret rslt(cx, f(floating_point)); }\n-      ty::ty_machine(_) {\n-        if ty::type_is_fp(bcx_tcx(cx), t) {\n-            // Floating point machine types\n-            ret rslt(cx, f(floating_point));\n-        } else if ty::type_is_signed(bcx_tcx(cx), t) {\n-            // Signed, integral machine types\n-            ret rslt(cx, f(signed_int));\n-        } else {\n-            // Unsigned, integral machine types\n-            ret rslt(cx, f(unsigned_int));\n-        }\n-      }\n+      ty::ty_bool. | ty::ty_ptr(_) { ret rslt(cx, f(unsigned_int)); }\n+      ty::ty_int(_) { ret rslt(cx, f(signed_int)); }\n+      ty::ty_uint(_) { ret rslt(cx, f(unsigned_int)); }\n+      ty::ty_float(_) { ret rslt(cx, f(floating_point)); }\n       ty::ty_type. {\n         ret rslt(trans_fail(cx, none,\n                             \"attempt to compare values of type type\"),\n@@ -2120,36 +2096,11 @@ fn store_temp_expr(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n \n fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n     alt lit.node {\n-      ast::lit_int(i) { ret C_int(cx, i); }\n-      ast::lit_uint(u) { ret C_uint(cx, u); }\n-      ast::lit_mach_int(tm, i) {\n-        // FIXME: the entire handling of mach types falls apart\n-        // if target int width is larger than host, at the moment;\n-        // re-do the mach-int types using 'big' when that works.\n-\n-        let t = cx.int_type;\n-        let s = True;\n-        alt tm {\n-          ast::ty_u8. { t = T_i8(); s = False; }\n-          ast::ty_u16. { t = T_i16(); s = False; }\n-          ast::ty_u32. { t = T_i32(); s = False; }\n-          ast::ty_u64. { t = T_i64(); s = False; }\n-          ast::ty_i8. { t = T_i8(); }\n-          ast::ty_i16. { t = T_i16(); }\n-          ast::ty_i32. { t = T_i32(); }\n-          ast::ty_i64. { t = T_i64(); }\n-        }\n-        ret C_integral(t, i as u64, s);\n-      }\n-      ast::lit_float(fs) { ret C_float(cx, fs); }\n-      ast::lit_mach_float(tm, s) {\n-        let t = cx.float_type;\n-        alt tm { ast::ty_f32. { t = T_f32(); } ast::ty_f64. { t = T_f64(); } }\n-        ret C_floating(s, t);\n-      }\n-      ast::lit_char(c) { ret C_integral(T_char(), c as u64, False); }\n-      ast::lit_bool(b) { ret C_bool(b); }\n-      ast::lit_nil. { ret C_nil(); }\n+      ast::lit_int(i, t) { C_integral(T_int_ty(cx, t), i as u64, True) }\n+      ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n+      ast::lit_float(fs, t) { C_floating(fs, T_float_ty(cx, t)) }\n+      ast::lit_bool(b) { C_bool(b) }\n+      ast::lit_nil. { C_nil() }\n       ast::lit_str(s) {\n         cx.sess.span_unimpl(lit.span, \"unique string in this context\");\n       }\n@@ -4359,7 +4310,7 @@ fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option::t<span>,\n         if ty::type_is_str(tcx, e_ty) {\n             let data = tvec::get_dataptr(\n                 bcx, expr_res.val, type_of_or_i8(\n-                    bcx, ty::mk_mach(tcx, ast::ty_u8)));\n+                    bcx, ty::mk_mach_uint(tcx, ast::ty_u8)));\n             ret trans_fail_value(bcx, sp_opt, data);\n         } else if bcx.unreachable {\n             ret bcx;"}, {"sha": "703aa9fcd770ecfbabbeeb0619bdcdb1b9be6583", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -485,6 +485,35 @@ fn T_int(targ_cfg: @session::config) -> TypeRef {\n     };\n }\n \n+fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n+    alt t {\n+      ast::ty_i. { cx.int_type }\n+      ast::ty_char. { T_char() }\n+      ast::ty_i8. { T_i8() }\n+      ast::ty_i16. { T_i16() }\n+      ast::ty_i32. { T_i32() }\n+      ast::ty_i64. { T_i64() }\n+    }\n+}\n+\n+fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n+    alt t {\n+      ast::ty_u. { cx.int_type }\n+      ast::ty_u8. { T_i8() }\n+      ast::ty_u16. { T_i16() }\n+      ast::ty_u32. { T_i32() }\n+      ast::ty_u64. { T_i64() }\n+    }\n+}\n+\n+fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n+    alt t {\n+      ast::ty_f. { cx.float_type }\n+      ast::ty_f32. { T_f32() }\n+      ast::ty_f64. { T_f64() }\n+    }\n+}\n+\n fn T_float(targ_cfg: @session::config) -> TypeRef {\n     ret alt targ_cfg.arch {\n       session::arch_x86. { T_f64() }\n@@ -734,12 +763,6 @@ fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n     ret llvm::LLVMRustConstInt(t, u_hi, u_lo, sign_extend);\n }\n \n-fn C_float(cx: @crate_ctxt, s: str) -> ValueRef {\n-    ret str::as_buf(s, {|buf|\n-        llvm::LLVMConstRealOfString(cx.float_type, buf)\n-    });\n-}\n-\n fn C_floating(s: str, t: TypeRef) -> ValueRef {\n     ret str::as_buf(s, {|buf| llvm::LLVMConstRealOfString(t, buf) });\n }"}, {"sha": "9c2ddedc56b8ddc543bd63e01e0f0b753366f5f6", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 94, "deletions": 177, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -71,7 +71,9 @@ export mk_mut_ptr;\n export mk_int;\n export mk_str;\n export mk_vec;\n-export mk_mach;\n+export mk_mach_int;\n+export mk_mach_uint;\n+export mk_mach_float;\n export mk_native;\n export mk_native_fn;\n export mk_nil;\n@@ -111,7 +113,6 @@ export ty_native_fn;\n export ty_bool;\n export ty_bot;\n export ty_box;\n-export ty_char;\n export ty_constr;\n export ty_constr_arg;\n export ty_float;\n@@ -122,7 +123,6 @@ export ty_fn_ret_style;\n export ty_int;\n export ty_str;\n export ty_vec;\n-export ty_machine;\n export ty_native;\n export ty_nil;\n export ty_obj;\n@@ -249,18 +249,15 @@ type raw_t =\n \n type t = uint;\n \n-\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast::rs as well.\n tag sty {\n     ty_nil;\n     ty_bot;\n     ty_bool;\n-    ty_int;\n-    ty_float;\n-    ty_uint;\n-    ty_machine(ast::ty_mach);\n-    ty_char;\n+    ty_int(ast::int_ty);\n+    ty_uint(ast::uint_ty);\n+    ty_float(ast::float_ty);\n     ty_str;\n     ty_tag(def_id, [t]);\n     ty_box(mt);\n@@ -361,20 +358,20 @@ type node_type_table =\n fn populate_type_store(cx: ctxt) {\n     intern(cx, ty_nil, none);\n     intern(cx, ty_bool, none);\n-    intern(cx, ty_int, none);\n-    intern(cx, ty_float, none);\n-    intern(cx, ty_uint, none);\n-    intern(cx, ty_machine(ast::ty_i8), none);\n-    intern(cx, ty_machine(ast::ty_i16), none);\n-    intern(cx, ty_machine(ast::ty_i32), none);\n-    intern(cx, ty_machine(ast::ty_i64), none);\n-    intern(cx, ty_machine(ast::ty_u8), none);\n-    intern(cx, ty_machine(ast::ty_u16), none);\n-    intern(cx, ty_machine(ast::ty_u32), none);\n-    intern(cx, ty_machine(ast::ty_u64), none);\n-    intern(cx, ty_machine(ast::ty_f32), none);\n-    intern(cx, ty_machine(ast::ty_f64), none);\n-    intern(cx, ty_char, none);\n+    intern(cx, ty_int(ast::ty_i), none);\n+    intern(cx, ty_float(ast::ty_f), none);\n+    intern(cx, ty_uint(ast::ty_u), none);\n+    intern(cx, ty_int(ast::ty_i8), none);\n+    intern(cx, ty_int(ast::ty_i16), none);\n+    intern(cx, ty_int(ast::ty_i32), none);\n+    intern(cx, ty_int(ast::ty_i64), none);\n+    intern(cx, ty_uint(ast::ty_u8), none);\n+    intern(cx, ty_uint(ast::ty_u16), none);\n+    intern(cx, ty_uint(ast::ty_u32), none);\n+    intern(cx, ty_uint(ast::ty_u64), none);\n+    intern(cx, ty_float(ast::ty_f32), none);\n+    intern(cx, ty_float(ast::ty_f64), none);\n+    intern(cx, ty_int(ast::ty_char), none);\n     intern(cx, ty_str, none);\n     intern(cx, ty_type, none);\n     intern(cx, ty_bot, none);\n@@ -445,17 +442,8 @@ fn mk_raw_ty(cx: ctxt, st: sty, _in_cname: option::t<str>) -> @raw_t {\n         derive_flags_t(cx, has_params, has_vars, tt);\n     }\n     alt st {\n-      ty_nil. {/* no-op */ }\n-      ty_bot. {/* no-op */ }\n-      ty_bool. {/* no-op */ }\n-      ty_int. {/* no-op */ }\n-      ty_float. {/* no-op */ }\n-      ty_uint. {/* no-op */ }\n-      ty_machine(_) {/* no-op */ }\n-      ty_char. {/* no-op */ }\n-      ty_str. {/* no-op */ }\n-      ty_type. {/* no-op */ }\n-      ty_native(_) {/* no-op */ }\n+      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_str. | ty_type. | ty_native(_) {/* no-op */ }\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) { has_vars = true; }\n       ty_tag(_, tys) {\n@@ -523,21 +511,36 @@ fn mk_float(_cx: ctxt) -> t { ret idx_float; }\n \n fn mk_uint(_cx: ctxt) -> t { ret idx_uint; }\n \n-fn mk_mach(_cx: ctxt, tm: ast::ty_mach) -> t {\n+fn mk_mach_int(_cx: ctxt, tm: ast::int_ty) -> t {\n     alt tm {\n-      ast::ty_u8. { ret idx_u8; }\n-      ast::ty_u16. { ret idx_u16; }\n-      ast::ty_u32. { ret idx_u32; }\n-      ast::ty_u64. { ret idx_u64; }\n+      ast::ty_i. { ret idx_int; }\n+      ast::ty_char. { ret idx_char; }\n       ast::ty_i8. { ret idx_i8; }\n       ast::ty_i16. { ret idx_i16; }\n       ast::ty_i32. { ret idx_i32; }\n       ast::ty_i64. { ret idx_i64; }\n+    }\n+}\n+\n+fn mk_mach_uint(_cx: ctxt, tm: ast::uint_ty) -> t {\n+    alt tm {\n+      ast::ty_u. { ret idx_uint; }\n+      ast::ty_u8. { ret idx_u8; }\n+      ast::ty_u16. { ret idx_u16; }\n+      ast::ty_u32. { ret idx_u32; }\n+      ast::ty_u64. { ret idx_u64; }\n+    }\n+}\n+\n+fn mk_mach_float(_cx: ctxt, tm: ast::float_ty) -> t {\n+    alt tm {\n+      ast::ty_f. { ret idx_float; }\n       ast::ty_f32. { ret idx_f32; }\n       ast::ty_f64. { ret idx_f64; }\n     }\n }\n \n+\n fn mk_char(_cx: ctxt) -> t { ret idx_char; }\n \n fn mk_str(_cx: ctxt) -> t { ret idx_str; }\n@@ -614,20 +617,9 @@ type ty_walk = fn@(t);\n \n fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n     alt struct(cx, ty) {\n-      ty_nil. {/* no-op */ }\n-      ty_bot. {/* no-op */ }\n-      ty_bool. {/* no-op */ }\n-      ty_int. {/* no-op */ }\n-      ty_uint. {/* no-op */ }\n-      ty_float. {/* no-op */ }\n-      ty_machine(_) {/* no-op */ }\n-      ty_char. {/* no-op */ }\n-      ty_str. {/* no-op */ }\n-      ty_type. {/* no-op */ }\n-      ty_native(_) {/* no-op */ }\n-      ty_box(tm) { walk_ty(cx, walker, tm.ty); }\n-      ty_vec(tm) { walk_ty(cx, walker, tm.ty); }\n-      ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n+      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_str. | ty_type. | ty_native(_) {/* no-op */ }\n+      ty_box(tm) | ty_vec(tm) | ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_tag(tid, subtys) {\n         for subty: t in subtys { walk_ty(cx, walker, subty); }\n       }\n@@ -677,17 +669,8 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       fm_general(_) {/* no fast path */ }\n     }\n     alt struct(cx, ty) {\n-      ty_nil. {/* no-op */ }\n-      ty_bot. {/* no-op */ }\n-      ty_bool. {/* no-op */ }\n-      ty_int. {/* no-op */ }\n-      ty_uint. {/* no-op */ }\n-      ty_float. {/* no-op */ }\n-      ty_machine(_) {/* no-op */ }\n-      ty_char. {/* no-op */ }\n-      ty_str. {/* no-op */ }\n-      ty_type. {/* no-op */ }\n-      ty_native(_) {/* no-op */ }\n+      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_str. | ty_type. | ty_native(_) {/* no-op */ }\n       ty_box(tm) {\n         ty = mk_box(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n@@ -725,21 +708,17 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += [{mode: a.mode, ty: new_ty}];\n         }\n-        ty =\n-            copy_cname(cx,\n-                       mk_fn(cx, proto, new_args, fold_ty(cx, fld, ret_ty),\n-                             cf, constrs), ty);\n+        ty = copy_cname(cx, mk_fn(cx, proto, new_args,\n+                                  fold_ty(cx, fld, ret_ty), cf, constrs), ty);\n       }\n       ty_native_fn(args, ret_ty) {\n         let new_args: [arg] = [];\n         for a: arg in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += [{mode: a.mode, ty: new_ty}];\n         }\n-        ty =\n-            copy_cname(cx,\n-                       mk_native_fn(cx, new_args,\n-                                    fold_ty(cx, fld, ret_ty)), ty);\n+        ty = copy_cname(cx, mk_native_fn(cx, new_args,\n+                                         fold_ty(cx, fld, ret_ty)), ty);\n       }\n       ty_obj(methods) {\n         let new_methods: [method] = [];\n@@ -773,7 +752,6 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       }\n     }\n \n-\n     // If this is a general type fold, then we need to run it now.\n     alt fld { fm_general(folder) { ret folder(ty); } _ { ret ty; } }\n }\n@@ -842,7 +820,7 @@ fn type_is_str(cx: ctxt, ty: t) -> bool {\n \n fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     alt struct(cx, ty) {\n-      ty_str. { ret mk_mach(cx, ast::ty_u8); }\n+      ty_str. { ret mk_mach_uint(cx, ast::ty_u8); }\n       ty_vec(mt) { ret mt.ty; }\n       _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n@@ -917,17 +895,9 @@ pure fn type_is_unique(cx: ctxt, ty: t) -> bool {\n \n pure fn type_is_scalar(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_nil. { ret true; }\n-      ty_bool. { ret true; }\n-      ty_int. { ret true; }\n-      ty_float. { ret true; }\n-      ty_uint. { ret true; }\n-      ty_machine(_) { ret true; }\n-      ty_char. { ret true; }\n-      ty_type. { ret true; }\n-      ty_native(_) { ret true; }\n-      ty_ptr(_) { ret true; }\n-      _ { ret false; }\n+      ty_nil. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_type. | ty_native(_) | ty_ptr(_) { true }\n+      _ { false }\n     }\n }\n \n@@ -946,8 +916,8 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     let accum = false;\n     let result = alt struct(cx, ty) {\n       // scalar types\n-      ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n-      ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) { false }\n+      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_type. | ty_native(_) | ty_ptr(_) { false }\n       ty_rec(flds) {\n         for f in flds { if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum\n@@ -998,8 +968,8 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n \n     let result = alt struct(cx, ty) {\n       // Scalar and unique types are sendable\n-      ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float. |\n-      ty_machine(_) | ty_char. | ty_native(_) | ty_ptr(_) |\n+      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_native(_) | ty_ptr(_) |\n       ty_type. | ty_str. | ty_native_fn(_, _) { ast::kind_sendable }\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n@@ -1151,38 +1121,15 @@ fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n \n fn type_is_integral(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_int. { ret true; }\n-      ty_uint. { ret true; }\n-      ty_machine(m) {\n-        alt m {\n-          ast::ty_i8. { ret true; }\n-          ast::ty_i16. { ret true; }\n-          ast::ty_i32. { ret true; }\n-          ast::ty_i64. { ret true; }\n-          ast::ty_u8. { ret true; }\n-          ast::ty_u16. { ret true; }\n-          ast::ty_u32. { ret true; }\n-          ast::ty_u64. { ret true; }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_char. { ret true; }\n-      ty_bool. { ret true; }\n-      _ { ret false; }\n+      ty_int(_) | ty_uint(_) | ty_bool. { true }\n+      _ { false }\n     }\n }\n \n fn type_is_fp(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_machine(tm) {\n-        alt tm {\n-          ast::ty_f32. { ret true; }\n-          ast::ty_f64. { ret true; }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_float. { ret true; }\n-      _ { ret false; }\n+      ty_float(_) { true }\n+      _ { false }\n     }\n }\n \n@@ -1192,17 +1139,8 @@ fn type_is_numeric(cx: ctxt, ty: t) -> bool {\n \n fn type_is_signed(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_int. { ret true; }\n-      ty_machine(tm) {\n-        alt tm {\n-          ast::ty_i8. { ret true; }\n-          ast::ty_i16. { ret true; }\n-          ast::ty_i32. { ret true; }\n-          ast::ty_i64. { ret true; }\n-          _ { ret false; }\n-        }\n-      }\n-      _ { ret false; }\n+      ty_int(_) { true }\n+      _ { false }\n     }\n }\n \n@@ -1211,10 +1149,8 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let result = true;\n     alt struct(cx, ty) {\n       // Scalar types\n-      ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n-      ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) {\n-        result = true;\n-      }\n+      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_type. | ty_native(_) | ty_ptr(_) { result = true; }\n       // Boxed types\n       ty_str. | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n       ty_native_fn(_, _) | ty_obj(_) {\n@@ -1343,26 +1279,22 @@ fn hash_type_structure(st: sty) -> uint {\n         ret h;\n     }\n     alt st {\n-      ty_nil. { ret 0u; }\n-      ty_bool. { ret 1u; }\n-      ty_int. { ret 2u; }\n-      ty_float. { ret 3u; }\n-      ty_uint. { ret 4u; }\n-      ty_machine(tm) {\n-        alt tm {\n-          ast::ty_i8. { ret 5u; }\n-          ast::ty_i16. { ret 6u; }\n-          ast::ty_i32. { ret 7u; }\n-          ast::ty_i64. { ret 8u; }\n-          ast::ty_u8. { ret 9u; }\n-          ast::ty_u16. { ret 10u; }\n-          ast::ty_u32. { ret 11u; }\n-          ast::ty_u64. { ret 12u; }\n-          ast::ty_f32. { ret 13u; }\n-          ast::ty_f64. { ret 14u; }\n+      ty_nil. { 0u } ty_bool. { 1u }\n+      ty_int(t) {\n+        alt t {\n+          ast::ty_i. { 2u } ast::ty_char. { 3u } ast::ty_i8. { 4u }\n+          ast::ty_i16. { 5u } ast::ty_i32. { 6u } ast::ty_i64. { 7u }\n         }\n       }\n-      ty_char. { ret 15u; }\n+      ty_uint(t) {\n+        alt t {\n+          ast::ty_u. { 8u } ast::ty_u8. { 9u } ast::ty_u16. { 10u }\n+          ast::ty_u32. { 11u } ast::ty_u64. { 12u }\n+        }\n+      }\n+      ty_float(t) {\n+        alt t { ast::ty_f. { 13u } ast::ty_f32. { 14u } ast::ty_f64. { 15u } }\n+      }\n       ty_str. { ret 17u; }\n       ty_tag(did, tys) {\n         let h = hash_def(18u, did);\n@@ -1505,17 +1437,17 @@ fn eq_ty(&&a: t, &&b: t) -> bool { ret a == b; }\n fn ty_to_machine_ty(cx: ctxt, ty: t) -> t {\n     fn sub_fn(cx: ctxt, uint_ty: t, int_ty: t, float_ty: t, in: t) -> t {\n         alt struct(cx, in) {\n-          ty_uint. { ret uint_ty; }\n-          ty_int. { ret int_ty; }\n-          ty_float. { ret float_ty; }\n+          ty_uint(ast::ty_u.) { ret uint_ty; }\n+          ty_int(ast::ty_i.) { ret int_ty; }\n+          ty_float(ast::ty_f.) { ret float_ty; }\n           _ { ret in; }\n         }\n     }\n \n     let cfg      = cx.sess.get_targ_cfg();\n-    let uint_ty  = mk_mach(cx, cfg.uint_type);\n-    let int_ty   = mk_mach(cx, cfg.int_type);\n-    let float_ty = mk_mach(cx, cfg.float_type);\n+    let uint_ty  = mk_mach_uint(cx, cfg.uint_type);\n+    let int_ty   = mk_mach_int(cx, cfg.int_type);\n+    let float_ty = mk_mach_float(cx, cfg.float_type);\n     let fold_m   = fm_general(bind sub_fn(cx, uint_ty, int_ty, float_ty, _));\n \n     ret fold_ty(cx, fold_m, ty);\n@@ -2289,14 +2221,10 @@ mod unify {\n           ty::ty_bot. {\n             ret ures_ok(actual);\n           }\n-          ty::ty_bool. { ret struct_cmp(cx, expected, actual); }\n-          ty::ty_int. { ret struct_cmp(cx, expected, actual); }\n-          ty::ty_uint. { ret struct_cmp(cx, expected, actual); }\n-          ty::ty_machine(_) { ret struct_cmp(cx, expected, actual); }\n-          ty::ty_float. { ret struct_cmp(cx, expected, actual); }\n-          ty::ty_char. { ret struct_cmp(cx, expected, actual); }\n-          ty::ty_str. { ret struct_cmp(cx, expected, actual); }\n-          ty::ty_type. { ret struct_cmp(cx, expected, actual); }\n+          ty::ty_bool. | ty::ty_int(_) | ty_uint(_) | ty_float(_) |\n+          ty::ty_str. | ty::ty_type. {\n+            ret struct_cmp(cx, expected, actual);\n+          }\n           ty::ty_native(ex_id) {\n             alt struct(cx.tcx, actual) {\n               ty_native(act_id) {\n@@ -2891,20 +2819,9 @@ fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n     fn tycat(cx: ctxt, ty: t) -> int {\n         alt struct(cx, ty) {\n           ty_bool. { tycat_bool }\n-          ty_int. { tycat_int }\n-          ty_uint. { tycat_int }\n-          ty_machine(ast::ty_i8.) { tycat_int }\n-          ty_machine(ast::ty_i16.) { tycat_int }\n-          ty_machine(ast::ty_i32.) { tycat_int }\n-          ty_machine(ast::ty_i64.) { tycat_int }\n-          ty_machine(ast::ty_u8.) { tycat_int }\n-          ty_machine(ast::ty_u16.) { tycat_int }\n-          ty_machine(ast::ty_u32.) { tycat_int }\n-          ty_machine(ast::ty_u64.) { tycat_int }\n-          ty_float. { tycat_float }\n-          ty_machine(ast::ty_f32.) { tycat_float }\n-          ty_machine(ast::ty_f64.) { tycat_float }\n-          ty_char. { tycat_int }\n+          ty_int(_) { tycat_int }\n+          ty_uint(_) { tycat_int }\n+          ty_float(_) { tycat_float }\n           ty_str. { tycat_str }\n           ty_vec(_) { tycat_vec }\n           ty_rec(_) { tycat_struct }"}, {"sha": "e8847b1ebbc9b5b66c0fbccca5db7548dd0cc5f9", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -289,11 +289,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n       ast::ty_nil. { typ = ty::mk_nil(tcx); }\n       ast::ty_bot. { typ = ty::mk_bot(tcx); }\n       ast::ty_bool. { typ = ty::mk_bool(tcx); }\n-      ast::ty_int. { typ = ty::mk_int(tcx); }\n-      ast::ty_uint. { typ = ty::mk_uint(tcx); }\n-      ast::ty_float. { typ = ty::mk_float(tcx); }\n-      ast::ty_machine(tm) { typ = ty::mk_mach(tcx, tm); }\n-      ast::ty_char. { typ = ty::mk_char(tcx); }\n+      ast::ty_int(it) { typ = ty::mk_mach_int(tcx, it); }\n+      ast::ty_uint(uit) { typ = ty::mk_mach_uint(tcx, uit); }\n+      ast::ty_float(ft) { typ = ty::mk_mach_float(tcx, ft); }\n       ast::ty_str. { typ = ty::mk_str(tcx); }\n       ast::ty_box(mt) {\n         typ = ty::mk_box(tcx, ast_mt_to_mt(tcx, getter, mt));\n@@ -1223,32 +1221,12 @@ fn gather_locals(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n // AST fragment checking\n fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n     alt lit.node {\n-      ast::lit_str(_) { ret ty::mk_str(ccx.tcx); }\n-      ast::lit_char(_) { ret ty::mk_char(ccx.tcx); }\n-      ast::lit_int(_) { ret ty::mk_int(ccx.tcx); }\n-      ast::lit_float(_) { ret ty::mk_float(ccx.tcx); }\n-      ast::lit_mach_float(tm, _) { ret ty::mk_mach(ccx.tcx, tm); }\n-      ast::lit_uint(_) { ret ty::mk_uint(ccx.tcx); }\n-      ast::lit_mach_int(tm, _) { ret ty::mk_mach(ccx.tcx, tm); }\n-      ast::lit_nil. { ret ty::mk_nil(ccx.tcx); }\n-      ast::lit_bool(_) { ret ty::mk_bool(ccx.tcx); }\n-    }\n-}\n-\n-fn lit_as_uint(l: @ast::lit) -> uint {\n-    alt l.node {\n-      ast::lit_uint(u) { u }\n-      ast::lit_char(c) { c as uint }\n-    }\n-}\n-fn lit_as_int(l: @ast::lit) -> int {\n-    alt l.node {\n-      ast::lit_int(i) | ast::lit_mach_int(_, i) { i }\n-    }\n-}\n-fn lit_as_float(l: @ast::lit) -> str {\n-    alt l.node {\n-      ast::lit_float(f) | ast::lit_mach_float(_, f) { f }\n+      ast::lit_str(_) { ty::mk_str(ccx.tcx) }\n+      ast::lit_int(_, t) { ty::mk_mach_int(ccx.tcx, t) }\n+      ast::lit_uint(_, t) { ty::mk_mach_uint(ccx.tcx, t) }\n+      ast::lit_float(_, t) { ty::mk_mach_float(ccx.tcx, t) }\n+      ast::lit_nil. { ty::mk_nil(ccx.tcx) }\n+      ast::lit_bool(_) { ty::mk_bool(ccx.tcx) }\n     }\n }\n \n@@ -1919,7 +1897,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let ety = expr_ty(tcx, seq);\n         alt structure_of(fcx, expr.span, ety) {\n           ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n-          ty::ty_str. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n+          ty::ty_str. { elt_ty = ty::mk_mach_uint(tcx, ast::ty_u8); }\n           _ {\n             tcx.sess.span_fatal(expr.span,\n                                 \"mismatched types: expected vector or string \"\n@@ -2258,7 +2236,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n           ty::ty_str. {\n-            let typ = ty::mk_mach(tcx, ast::ty_u8);\n+            let typ = ty::mk_mach_uint(tcx, ast::ty_u8);\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           _ {"}, {"sha": "e0fd6617708ab96b572acad6cdcd36e1b295e7e6", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -251,12 +251,9 @@ type lit = spanned<lit_>;\n \n tag lit_ {\n     lit_str(str);\n-    lit_char(char);\n-    lit_int(int);\n-    lit_uint(uint);\n-    lit_mach_int(ty_mach, int);\n-    lit_float(str);\n-    lit_mach_float(ty_mach, str);\n+    lit_int(i64, int_ty);\n+    lit_uint(u64, uint_ty);\n+    lit_float(str, float_ty);\n     lit_nil;\n     lit_bool(bool);\n }\n@@ -283,18 +280,11 @@ type ty_arg = spanned<ty_arg_>;\n \n type ty_method = spanned<ty_method_>;\n \n-tag ty_mach {\n-    ty_i8;\n-    ty_i16;\n-    ty_i32;\n-    ty_i64;\n-    ty_u8;\n-    ty_u16;\n-    ty_u32;\n-    ty_u64;\n-    ty_f32;\n-    ty_f64;\n-}\n+tag int_ty { ty_i; ty_char; ty_i8; ty_i16; ty_i32; ty_i64; }\n+\n+tag uint_ty { ty_u; ty_u8; ty_u16; ty_u32; ty_u64; }\n+\n+tag float_ty { ty_f; ty_f32; ty_f64; }\n \n type ty = spanned<ty_>;\n \n@@ -304,18 +294,13 @@ tag ty_ {\n              ret/fail/break/cont. there is no syntax\n              for this type. */\n \n-\n-\n-\n      /* bot represents the value of functions that don't return a value\n         locally to their context. in contrast, things like log that do\n         return, but don't return a meaningful value, have result type nil. */\n-     ty_bool;\n-    ty_int;\n-    ty_uint;\n-    ty_float;\n-    ty_machine(ty_mach);\n-    ty_char;\n+    ty_bool;\n+    ty_int(int_ty);\n+    ty_uint(uint_ty);\n+    ty_float(float_ty);\n     ty_str;\n     ty_box(mt);\n     ty_uniq(mt);\n@@ -332,7 +317,6 @@ tag ty_ {\n     ty_type;\n     ty_constr(@ty, [@ty_constr]);\n     ty_mac(mac);\n-\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n     // nested in one."}, {"sha": "f6d019c2a85ffa389ab3da6f7b28d3a849d36fbe", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -125,21 +125,23 @@ fn is_path(e: @expr) -> bool {\n     ret alt e.node { expr_path(_) { true } _ { false } };\n }\n \n-fn ty_mach_to_str(tm: ty_mach) -> str {\n-    alt tm {\n-      ty_u8. { ret \"u8\"; }\n-      ty_u16. { ret \"u16\"; }\n-      ty_u32. { ret \"u32\"; }\n-      ty_u64. { ret \"u64\"; }\n-      ty_i8. { ret \"i8\"; }\n-      ty_i16. { ret \"i16\"; }\n-      ty_i32. { ret \"i32\"; }\n-      ty_i64. { ret \"i64\"; }\n-      ty_f32. { ret \"f32\"; }\n-      ty_f64. { ret \"f64\"; }\n+fn int_ty_to_str(t: int_ty) -> str {\n+    alt t {\n+      ty_i. { \"\" } ty_i8. { \"i8\" } ty_i16. { \"i16\" }\n+      ty_i32. { \"i32\" } ty_i64. { \"i64\" }\n     }\n }\n \n+fn uint_ty_to_str(t: uint_ty) -> str {\n+    alt t {\n+      ty_u. { \"\" } ty_u8. { \"u8\" } ty_u16. { \"u16\" }\n+      ty_u32. { \"u32\" } ty_u64. { \"u64\" }\n+    }\n+}\n+\n+fn float_ty_to_str(t: float_ty) -> str {\n+    alt t { ty_f. { \"\" } ty_f32. { \"f32\" } ty_f64. { \"f64\" } }\n+}\n \n fn is_exported(i: ident, m: _mod) -> bool {\n     let nonlocal = true;\n@@ -245,7 +247,12 @@ fn ty_param_kind(tp: ty_param) -> kind { tp.kind }\n \n // FIXME this doesn't handle big integer/float literals correctly (nor does\n // the rest of our literal handling)\n-tag const_val { const_float(float); const_int(i64); const_str(str); }\n+tag const_val {\n+    const_float(float);\n+    const_int(i64);\n+    const_uint(u64);\n+    const_str(str);\n+}\n \n fn eval_const_expr(e: @expr) -> const_val {\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n@@ -254,11 +261,13 @@ fn eval_const_expr(e: @expr) -> const_val {\n         alt eval_const_expr(inner) {\n           const_float(f) { const_float(-f) }\n           const_int(i) { const_int(-i) }\n+          const_uint(i) { const_uint(-i) }\n         }\n       }\n       expr_unary(not., inner) {\n         alt eval_const_expr(inner) {\n           const_int(i) { const_int(!i) }\n+          const_uint(i) { const_uint(!i) }\n         }\n       }\n       expr_binary(op, a, b) {\n@@ -283,6 +292,17 @@ fn eval_const_expr(e: @expr) -> const_val {\n               ge. { fromb(a >= b) } gt. { fromb(a > b) }\n             }\n           }\n+          (const_uint(a), const_uint(b)) {\n+            alt op {\n+              add. { const_uint(a + b) } sub. { const_uint(a - b) }\n+              mul. { const_uint(a * b) } div. { const_uint(a / b) }\n+              rem. { const_uint(a % b) } and. | bitand. { const_uint(a & b) }\n+              or. | bitor. { const_uint(a | b) } bitxor. { const_uint(a ^ b) }\n+              eq. { fromb(a == b) } lt. { fromb(a < b) }\n+              le. { fromb(a <= b) } ne. { fromb(a != b) }\n+              ge. { fromb(a >= b) } gt. { fromb(a > b) }\n+            }\n+          }\n         }\n       }\n       expr_lit(lit) { lit_to_const(lit) }\n@@ -292,12 +312,9 @@ fn eval_const_expr(e: @expr) -> const_val {\n fn lit_to_const(lit: @lit) -> const_val {\n     alt lit.node {\n       lit_str(s) { const_str(s) }\n-      lit_char(ch) { const_int(ch as i64) }\n-      lit_int(i) | lit_mach_int(_, i) { const_int(i as i64) }\n-      lit_uint(ui) { const_int(ui as i64) }\n-      lit_float(s) | lit_mach_float(_, s) {\n-        const_float(std::float::from_str(s))\n-      }\n+      lit_int(n, _) { const_int(n) }\n+      lit_uint(n, _) { const_uint(n) }\n+      lit_float(n, _) { const_float(std::float::from_str(n)) }\n       lit_nil. { const_int(0i64) }\n       lit_bool(b) { const_int(b as i64) }\n     }\n@@ -306,6 +323,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n fn compare_const_vals(a: const_val, b: const_val) -> int {\n   alt (a, b) {\n     (const_int(a), const_int(b)) { a == b ? 0 : a < b ? -1 : 1 }\n+    (const_uint(a), const_uint(b)) { a == b ? 0 : a < b ? -1 : 1 }\n     (const_float(a), const_float(b)) { a == b ? 0 : a < b ? -1 : 1 }\n     (const_str(a), const_str(b)) { a == b ? 0 : a < b ? -1 : 1 }\n   }"}, {"sha": "2d36d973870997a2d875e0126cd62c7a2c3fd794", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -52,11 +52,11 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n         ret make_new_lit(cx, sp, lit);\n     }\n     fn make_new_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n-        let lit = ast::lit_int(i);\n+        let lit = ast::lit_int(i as i64, ast::ty_i);\n         ret make_new_lit(cx, sp, lit);\n     }\n     fn make_new_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n-        let lit = ast::lit_uint(u);\n+        let lit = ast::lit_uint(u as u64, ast::ty_u);\n         ret make_new_lit(cx, sp, lit);\n     }\n     fn make_add_expr(cx: ext_ctxt, sp: span, lhs: @ast::expr, rhs: @ast::expr)"}, {"sha": "aa35635f1787656e280cabe0d5f9e223829b875a", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 50, "deletions": 69, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -1,5 +1,5 @@\n \n-import std::{io, vec, str, option};\n+import std::{io, vec, str, option, either};\n import std::option::{some, none};\n import util::interner;\n import util::interner::intern;\n@@ -161,103 +161,89 @@ fn scan_exponent(rdr: reader) -> option::t<str> {\n     let c = rdr.curr();\n     let rslt = \"\";\n     if c == 'e' || c == 'E' {\n-        rslt += str::unsafe_from_bytes([c as u8]);\n+        str::push_byte(rslt, c as u8);\n         rdr.bump();\n         c = rdr.curr();\n         if c == '-' || c == '+' {\n-            rslt += str::unsafe_from_bytes([c as u8]);\n+            str::push_byte(rslt, c as u8);\n             rdr.bump();\n         }\n-        let exponent = scan_dec_digits(rdr);\n+        let exponent = scan_digits(rdr, 10u);\n         if str::byte_len(exponent) > 0u {\n             ret some(rslt + exponent);\n         } else { rdr.err(\"scan_exponent: bad fp literal\"); fail; }\n     } else { ret none::<str>; }\n }\n \n-fn scan_dec_digits(rdr: reader) -> str {\n-    let c = rdr.curr();\n-    let rslt: str = \"\";\n-    while is_dec_digit(c) || c == '_' {\n-        if c != '_' { rslt += str::unsafe_from_bytes([c as u8]); }\n-        rdr.bump();\n-        c = rdr.curr();\n+fn scan_digits(rdr: reader, radix: uint) -> str {\n+    radix; // FIXME work around issue #1265\n+    let rslt = \"\";\n+    while true {\n+        let c = rdr.curr();\n+        if c == '_' { rdr.bump(); cont; }\n+        alt std::char::maybe_digit(c) {\n+          some(d) when (d as uint) < radix {\n+            str::push_byte(rslt, c as u8);\n+            rdr.bump();\n+          }\n+          _ { break; }\n+        }\n     }\n     ret rslt;\n }\n \n fn scan_number(c: char, rdr: reader) -> token::token {\n-    let accum_int = 0, c = c;\n-    let num_str: str = \"\";\n-    let n = rdr.next();\n+    let num_str, base = 10u, c = c, n = rdr.next();\n     if c == '0' && n == 'x' {\n         rdr.bump();\n         rdr.bump();\n-        c = rdr.curr();\n-        while is_hex_digit(c) || c == '_' {\n-            if c != '_' { accum_int *= 16; accum_int += hex_digit_val(c); }\n-            rdr.bump();\n-            c = rdr.curr();\n-        }\n+        base = 16u;\n     } else if c == '0' && n == 'b' {\n         rdr.bump();\n         rdr.bump();\n-        c = rdr.curr();\n-        while is_bin_digit(c) || c == '_' {\n-            if c != '_' { accum_int *= 2; accum_int += bin_digit_value(c); }\n-            rdr.bump();\n-            c = rdr.curr();\n-        }\n-    } else {\n-        num_str = scan_dec_digits(rdr);\n-        accum_int = std::int::from_str(num_str);\n+        base = 2u;\n     }\n+    num_str = scan_digits(rdr, base);\n     c = rdr.curr();\n     n = rdr.next();\n     if c == 'u' || c == 'i' {\n-        let signed: bool = c == 'i';\n+        let signed = c == 'i', tp = signed ? either::left(ast::ty_i)\n+                                           : either::right(ast::ty_u);\n         rdr.bump();\n         c = rdr.curr();\n         if c == '8' {\n             rdr.bump();\n-            if signed {\n-                ret token::LIT_MACH_INT(ast::ty_i8, accum_int);\n-            } else { ret token::LIT_MACH_INT(ast::ty_u8, accum_int); }\n+            tp = signed ? either::left(ast::ty_i8)\n+                        : either::right(ast::ty_u8);\n         }\n         n = rdr.next();\n         if c == '1' && n == '6' {\n             rdr.bump();\n             rdr.bump();\n-            if signed {\n-                ret token::LIT_MACH_INT(ast::ty_i16, accum_int);\n-            } else { ret token::LIT_MACH_INT(ast::ty_u16, accum_int); }\n-        }\n-        if c == '3' && n == '2' {\n+            tp = signed ? either::left(ast::ty_i16)\n+                        : either::right(ast::ty_u16);\n+        } else if c == '3' && n == '2' {\n             rdr.bump();\n             rdr.bump();\n-            if signed {\n-                ret token::LIT_MACH_INT(ast::ty_i32, accum_int);\n-            } else { ret token::LIT_MACH_INT(ast::ty_u32, accum_int); }\n-        }\n-        if c == '6' && n == '4' {\n+            tp = signed ? either::left(ast::ty_i32)\n+                        : either::right(ast::ty_u32);\n+        } else if c == '6' && n == '4' {\n             rdr.bump();\n             rdr.bump();\n-            if signed {\n-                ret token::LIT_MACH_INT(ast::ty_i64, accum_int);\n-            } else { ret token::LIT_MACH_INT(ast::ty_u64, accum_int); }\n+            tp = signed ? either::left(ast::ty_i64)\n+                        : either::right(ast::ty_u64);\n         }\n-        if signed {\n-            ret token::LIT_INT(accum_int);\n-        } else {\n-            // FIXME: should cast in the target bit-width.\n-            ret token::LIT_UINT(accum_int as uint);\n+        let parsed = std::u64::from_str(num_str, base as u64);\n+        alt tp {\n+          either::left(t) { ret token::LIT_INT(parsed as i64, t); }\n+          either::right(t) { ret token::LIT_UINT(parsed, t); }\n         }\n     }\n     let is_float = false;\n     if rdr.curr() == '.' {\n         is_float = true;\n         rdr.bump();\n-        let dec_part = scan_dec_digits(rdr);\n+        let dec_part = scan_digits(rdr, 10u);\n         num_str += \".\" + dec_part;\n     }\n     alt scan_exponent(rdr) {\n@@ -274,26 +260,25 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         if c == '3' && n == '2' {\n             rdr.bump();\n             rdr.bump();\n-            ret token::LIT_MACH_FLOAT(ast::ty_f32,\n-                                      intern(*rdr.get_interner(),\n-                                             num_str));\n+            ret token::LIT_FLOAT(intern(*rdr.get_interner(), num_str),\n+                                 ast::ty_f32);\n         } else if c == '6' && n == '4' {\n             rdr.bump();\n             rdr.bump();\n-            ret token::LIT_MACH_FLOAT(ast::ty_f64,\n-                                      intern(*rdr.get_interner(),\n-                                             num_str));\n+            ret token::LIT_FLOAT(intern(*rdr.get_interner(), num_str),\n+                                 ast::ty_f64);\n             /* FIXME: if this is out of range for either a 32-bit or\n             64-bit float, it won't be noticed till the back-end */\n         } else {\n             is_float = true;\n         }\n     }\n     if is_float {\n-        ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n-                                                     num_str));\n+        ret token::LIT_FLOAT(interner::intern(*rdr.get_interner(), num_str),\n+                             ast::ty_f);\n     } else {\n-        ret token::LIT_INT(accum_int);\n+        let parsed = std::u64::from_str(num_str, base as u64);\n+        ret token::LIT_INT(parsed as i64, ast::ty_i);\n     }\n }\n \n@@ -463,8 +448,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n             fail;\n         }\n         rdr.bump(); // advance curr past token\n-\n-        ret token::LIT_CHAR(c2);\n+        ret token::LIT_INT(c2 as i64, ast::ty_char);\n       }\n       '\"' {\n         let n = rdr.get_chpos();\n@@ -685,13 +669,10 @@ fn consume_comment(rdr: reader, code_to_the_left: bool, &comments: [cmnt]) {\n \n fn is_lit(t: token::token) -> bool {\n     ret alt t {\n-          token::LIT_INT(_) { true }\n-          token::LIT_UINT(_) { true }\n-          token::LIT_MACH_INT(_, _) { true }\n-          token::LIT_FLOAT(_) { true }\n-          token::LIT_MACH_FLOAT(_, _) { true }\n+          token::LIT_INT(_, _) { true }\n+          token::LIT_UINT(_, _) { true }\n+          token::LIT_FLOAT(_, _) { true }\n           token::LIT_STR(_) { true }\n-          token::LIT_CHAR(_) { true }\n           token::LIT_BOOL(_) { true }\n           _ { false }\n         }"}, {"sha": "23ed2485f6904e43241afc3e9cde60d9e1d3926a", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -459,39 +459,35 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     if eat_word(p, \"bool\") {\n         t = ast::ty_bool;\n     } else if eat_word(p, \"int\") {\n-        t = ast::ty_int;\n+        t = ast::ty_int(ast::ty_i);\n     } else if eat_word(p, \"uint\") {\n-        t = ast::ty_uint;\n+        t = ast::ty_uint(ast::ty_u);\n     } else if eat_word(p, \"float\") {\n-        t = ast::ty_float;\n+        t = ast::ty_float(ast::ty_f);\n     } else if eat_word(p, \"str\") {\n         t = ast::ty_str;\n     } else if eat_word(p, \"char\") {\n-        t = ast::ty_char;\n-        /*\n-            } else if (eat_word(p, \"task\")) {\n-                t = ast::ty_task;\n-        */\n+        t = ast::ty_int(ast::ty_char);\n     } else if eat_word(p, \"i8\") {\n-        t = ast::ty_machine(ast::ty_i8);\n+        t = ast::ty_int(ast::ty_i8);\n     } else if eat_word(p, \"i16\") {\n-        t = ast::ty_machine(ast::ty_i16);\n+        t = ast::ty_int(ast::ty_i16);\n     } else if eat_word(p, \"i32\") {\n-        t = ast::ty_machine(ast::ty_i32);\n+        t = ast::ty_int(ast::ty_i32);\n     } else if eat_word(p, \"i64\") {\n-        t = ast::ty_machine(ast::ty_i64);\n+        t = ast::ty_int(ast::ty_i64);\n     } else if eat_word(p, \"u8\") {\n-        t = ast::ty_machine(ast::ty_u8);\n+        t = ast::ty_uint(ast::ty_u8);\n     } else if eat_word(p, \"u16\") {\n-        t = ast::ty_machine(ast::ty_u16);\n+        t = ast::ty_uint(ast::ty_u16);\n     } else if eat_word(p, \"u32\") {\n-        t = ast::ty_machine(ast::ty_u32);\n+        t = ast::ty_uint(ast::ty_u32);\n     } else if eat_word(p, \"u64\") {\n-        t = ast::ty_machine(ast::ty_u64);\n+        t = ast::ty_uint(ast::ty_u64);\n     } else if eat_word(p, \"f32\") {\n-        t = ast::ty_machine(ast::ty_f32);\n+        t = ast::ty_float(ast::ty_f32);\n     } else if eat_word(p, \"f64\") {\n-        t = ast::ty_machine(ast::ty_f64);\n+        t = ast::ty_float(ast::ty_f64);\n     } else if p.peek() == token::LPAREN {\n         p.bump();\n         if p.peek() == token::RPAREN {\n@@ -662,12 +658,9 @@ fn parse_seq<copy T>(bra: token::token, ket: token::token,\n \n fn lit_from_token(p: parser, tok: token::token) -> ast::lit_ {\n     alt tok {\n-      token::LIT_INT(i) { ast::lit_int(i) }\n-      token::LIT_UINT(u) { ast::lit_uint(u) }\n-      token::LIT_FLOAT(s) { ast::lit_float(p.get_str(s)) }\n-      token::LIT_MACH_INT(tm, i) { ast::lit_mach_int(tm, i) }\n-      token::LIT_MACH_FLOAT(tm, s) { ast::lit_mach_float(tm, p.get_str(s)) }\n-      token::LIT_CHAR(c) { ast::lit_char(c) }\n+      token::LIT_INT(i, it) { ast::lit_int(i, it) }\n+      token::LIT_UINT(u, ut) { ast::lit_uint(u, ut) }\n+      token::LIT_FLOAT(s, ft) { ast::lit_float(p.get_str(s), ft) }\n       token::LIT_STR(s) { ast::lit_str(p.get_str(s)) }\n       token::LPAREN. { expect(p, token::RPAREN); ast::lit_nil }\n       _ { unexpected(p, tok); }"}, {"sha": "6740ba74c001b42db5d6ac22ff017638093f7cd4", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 47, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -1,6 +1,4 @@\n \n-import ast::ty_mach;\n-import ast_util::ty_mach_to_str;\n import util::interner;\n import std::{int, uint, str};\n \n@@ -21,8 +19,6 @@ tag binop {\n }\n \n tag token {\n-\n-\n     /* Expression-operator symbols. */\n     EQ;\n     LT;\n@@ -38,7 +34,6 @@ tag token {\n     BINOP(binop);\n     BINOPEQ(binop);\n \n-\n     /* Structural symbols */\n     AT;\n     DOT;\n@@ -61,18 +56,13 @@ tag token {\n     POUND_LBRACE;\n     POUND_LT;\n \n-\n     /* Literals */\n-    LIT_INT(int);\n-    LIT_UINT(uint);\n-    LIT_MACH_INT(ty_mach, int);\n-    LIT_FLOAT(str_num);\n-    LIT_MACH_FLOAT(ty_mach, str_num);\n+    LIT_INT(i64, ast::int_ty);\n+    LIT_UINT(u64, ast::uint_ty);\n+    LIT_FLOAT(str_num, ast::float_ty);\n     LIT_STR(str_num);\n-    LIT_CHAR(char);\n     LIT_BOOL(bool);\n \n-\n     /* Name components */\n     IDENT(str_num, bool);\n     IDX(int);\n@@ -113,10 +103,6 @@ fn to_str(r: lexer::reader, t: token) -> str {\n       BINOP(op) { ret binop_to_str(op); }\n       BINOPEQ(op) { ret binop_to_str(op) + \"=\"; }\n \n-\n-\n-\n-\n       /* Structural symbols */\n       AT. {\n         ret \"@\";\n@@ -141,39 +127,29 @@ fn to_str(r: lexer::reader, t: token) -> str {\n       POUND_LBRACE. { ret \"#{\"; }\n       POUND_LT. { ret \"#<\"; }\n \n-\n-\n-\n-\n       /* Literals */\n-      LIT_INT(i) {\n-        ret int::to_str(i, 10u);\n+      LIT_INT(c, ast::ty_char.) {\n+        // FIXME: escape.\n+        let tmp = \"'\";\n+        str::push_char(tmp, c as char);\n+        str::push_byte(tmp, '\\'' as u8);\n+        ret tmp;\n+      }\n+      LIT_INT(i, t) {\n+        ret int::to_str(i as int, 10u) + ast_util::int_ty_to_str(t);\n       }\n-      LIT_UINT(u) { ret uint::to_str(u, 10u); }\n-      LIT_MACH_INT(tm, i) {\n-        ret int::to_str(i, 10u) + \"_\" + ty_mach_to_str(tm);\n+      LIT_UINT(u, t) {\n+        ret uint::to_str(u as uint, 10u) + ast_util::uint_ty_to_str(t);\n       }\n-      LIT_MACH_FLOAT(tm, s) {\n-        ret interner::get::<str>(*r.get_interner(), s) + \"_\" +\n-                ty_mach_to_str(tm);\n+      LIT_FLOAT(s, t) {\n+        ret interner::get::<str>(*r.get_interner(), s) +\n+            ast_util::float_ty_to_str(t);\n       }\n-      LIT_FLOAT(s) { ret interner::get::<str>(*r.get_interner(), s); }\n       LIT_STR(s) { // FIXME: escape.\n         ret \"\\\"\" + interner::get::<str>(*r.get_interner(), s) + \"\\\"\";\n       }\n-      LIT_CHAR(c) {\n-        // FIXME: escape.\n-        let tmp = \"'\";\n-        str::push_char(tmp, c);\n-        str::push_byte(tmp, '\\'' as u8);\n-        ret tmp;\n-      }\n       LIT_BOOL(b) { if b { ret \"true\"; } else { ret \"false\"; } }\n \n-\n-\n-\n-\n       /* Name components */\n       IDENT(s, _) {\n         ret interner::get::<str>(*r.get_interner(), s);\n@@ -194,13 +170,10 @@ pure fn can_begin_expr(t: token) -> bool {\n       IDENT(_, _) { true }\n       UNDERSCORE. { true }\n       TILDE. { true }\n-      LIT_INT(_) { true }\n-      LIT_UINT(_) { true }\n-      LIT_MACH_INT(_, _) { true }\n-      LIT_FLOAT(_) { true }\n-      LIT_MACH_FLOAT(_, _) { true }\n+      LIT_INT(_, _) { true }\n+      LIT_UINT(_, _) { true }\n+      LIT_FLOAT(_, _) { true }\n       LIT_STR(_) { true }\n-      LIT_CHAR(_) { true }\n       POUND. { true }\n       AT. { true }\n       NOT. { true }"}, {"sha": "2bb8463e2b9bf4262d360677ca25883ebfe35e24", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -252,11 +252,13 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n       ast::ty_nil. { word(s.s, \"()\"); }\n       ast::ty_bool. { word(s.s, \"bool\"); }\n       ast::ty_bot. { word(s.s, \"!\"); }\n-      ast::ty_int. { word(s.s, \"int\"); }\n-      ast::ty_uint. { word(s.s, \"uint\"); }\n-      ast::ty_float. { word(s.s, \"float\"); }\n-      ast::ty_machine(tm) { word(s.s, ast_util::ty_mach_to_str(tm)); }\n-      ast::ty_char. { word(s.s, \"char\"); }\n+      ast::ty_int(ast::ty_i.) { word(s.s, \"int\"); }\n+      ast::ty_int(ast::ty_char.) { word(s.s, \"char\"); }\n+      ast::ty_int(t) { word(s.s, ast_util::int_ty_to_str(t)); }\n+      ast::ty_uint(ast::ty_u.) { word(s.s, \"uint\"); }\n+      ast::ty_uint(t) { word(s.s, ast_util::uint_ty_to_str(t)); }\n+      ast::ty_float(ast::ty_f.) { word(s.s, \"float\"); }\n+      ast::ty_float(t) { word(s.s, ast_util::float_ty_to_str(t)); }\n       ast::ty_str. { word(s.s, \"str\"); }\n       ast::ty_box(mt) { word(s.s, \"@\"); print_mt(s, mt); }\n       ast::ty_uniq(mt) { word(s.s, \"~\"); print_mt(s, mt); }\n@@ -1385,22 +1387,17 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n     }\n     alt lit.node {\n       ast::lit_str(st) { print_string(s, st); }\n-      ast::lit_char(ch) {\n-        word(s.s,\n-             \"'\" + escape_str(str::unsafe_from_bytes([ch as u8]), '\\'') +\n-                 \"'\");\n-      }\n-      ast::lit_int(val) { word(s.s, int::str(val)); }\n-      ast::lit_uint(val) { word(s.s, uint::str(val) + \"u\"); }\n-      ast::lit_float(fstr) { word(s.s, fstr); }\n-      ast::lit_mach_int(mach, val) {\n-        word(s.s, int::str(val as int));\n-        word(s.s, ast_util::ty_mach_to_str(mach));\n-      }\n-      ast::lit_mach_float(mach, val) {\n-        // val is already a str\n-        word(s.s, val);\n-        word(s.s, ast_util::ty_mach_to_str(mach));\n+      ast::lit_int(ch, ast::ty_char.) {\n+        word(s.s, \"'\" + escape_str(str::from_char(ch as char), '\\'') + \"'\");\n+      }\n+      ast::lit_int(i, t) {\n+        word(s.s, int::str(i as int) + ast_util::int_ty_to_str(t));\n+      }\n+      ast::lit_uint(u, t) {\n+        word(s.s, uint::str(u as uint) + ast_util::uint_ty_to_str(t));\n+      }\n+      ast::lit_float(f, t) {\n+        word(s.s, f + ast_util::float_ty_to_str(t));\n       }\n       ast::lit_nil. { word(s.s, \"()\"); }\n       ast::lit_bool(val) {\n@@ -1622,7 +1619,7 @@ fn ast_ty_constrs_str(constrs: [@ast::ty_constr]) -> str {\n \n fn ends_in_lit_int(ex: @ast::expr) -> bool {\n     alt ex.node {\n-      ast::expr_lit(@{node: ast::lit_int(_), _}) { true }\n+      ast::expr_lit(@{node: ast::lit_int(_, ast::ty_i.), _}) { true }\n       ast::expr_binary(_, _, sub) | ast::expr_unary(_, sub) |\n       ast::expr_ternary(_, _, sub) | ast::expr_move(_, sub) |\n       ast::expr_copy(sub) | ast::expr_assign(_, sub) | ast::expr_be(sub) |"}, {"sha": "a4052cec2a0146a89d2b29bb44640c24ee4c9dc5", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -112,22 +112,10 @@ fn skip_ty<E>(_t: @ty, _e: E, _v: vt<E>) {}\n \n fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n     alt t.node {\n-      ty_nil. {/* no-op */ }\n-      ty_bot. {/* no-op */ }\n-      ty_bool. {/* no-op */ }\n-      ty_int. {/* no-op */ }\n-      ty_float. {/* no-op */ }\n-      ty_uint. {/* no-op */ }\n-      ty_machine(_) {/* no-op */ }\n-      ty_char. {/* no-op */ }\n-      ty_str. {/* no-op */ }\n       ty_box(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_uniq(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_vec(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_ptr(mt) { v.visit_ty(mt.ty, e, v); }\n-      ty_port(t) { v.visit_ty(t, e, v); }\n-      ty_chan(t) { v.visit_ty(t, e, v); }\n-      ty_task. {/* no-op */ }\n       ty_rec(flds) {\n         for f: ty_field in flds { v.visit_ty(f.node.mt.ty, e, v); }\n       }\n@@ -146,14 +134,13 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         }\n       }\n       ty_path(p, _) { for tp: @ty in p.node.types { v.visit_ty(tp, e, v); } }\n-      ty_type. {/* no-op */ }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n         for tc: @spanned<constr_general_<@path, node_id>> in cs {\n             v.visit_constr(tc.node.path, tc.span, tc.node.id, e, v);\n         }\n       }\n-      ty_infer. {/* no-op */ }\n+      _ {}\n     }\n }\n "}, {"sha": "26db274875ef21e40f1c3e8920e78ad2b0952dad", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -5,8 +5,7 @@ import middle::ty::*;\n import metadata::encoder;\n import syntax::print::pprust;\n import syntax::print::pprust::{path_to_str, constr_args_to_str, proto_to_str};\n-import syntax::ast_util::ty_mach_to_str;\n-import syntax::ast;\n+import syntax::{ast, ast_util};\n import middle::ast_map;\n \n fn mode_str(m: ty::mode) -> str {\n@@ -86,58 +85,60 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n     alt cname(cx, typ) { some(cs) { ret cs; } _ { } }\n     ret alt struct(cx, typ) {\n-          ty_native(_) { \"native\" }\n-          ty_nil. { \"()\" }\n-          ty_bot. { \"_|_\" }\n-          ty_bool. { \"bool\" }\n-          ty_int. { \"int\" }\n-          ty_float. { \"float\" }\n-          ty_uint. { \"uint\" }\n-          ty_machine(tm) { ty_mach_to_str(tm) }\n-          ty_char. { \"char\" }\n-          ty_str. { \"str\" }\n-          ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n-          ty_uniq(tm) { \"~\" + mt_to_str(cx, tm) }\n-          ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n-          ty_type. { \"type\" }\n-          ty_rec(elems) {\n+      ty_native(_) { \"native\" }\n+      ty_nil. { \"()\" }\n+      ty_bot. { \"_|_\" }\n+      ty_bool. { \"bool\" }\n+      ty_int(ast::ty_i.) { \"int\" }\n+      ty_int(ast::ty_char.) { \"char\" }\n+      ty_int(t) { ast_util::int_ty_to_str(t) }\n+      ty_uint(ast::ty_u.) { \"uint\" }\n+      ty_uint(t) { ast_util::uint_ty_to_str(t) }\n+      ty_float(ast::ty_f.) { \"float\" }\n+      ty_float(t) { ast_util::float_ty_to_str(t) }\n+      ty_str. { \"str\" }\n+      ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n+      ty_uniq(tm) { \"~\" + mt_to_str(cx, tm) }\n+      ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n+      ty_type. { \"type\" }\n+      ty_rec(elems) {\n+        let strs: [str] = [];\n+        for fld: field in elems { strs += [field_to_str(cx, fld)]; }\n+        \"{\" + str::connect(strs, \",\") + \"}\"\n+      }\n+      ty_tup(elems) {\n+        let strs = [];\n+        for elem in elems { strs += [ty_to_str(cx, elem)]; }\n+        \"(\" + str::connect(strs, \",\") + \")\"\n+      }\n+      ty_tag(id, tps) {\n+        let s = get_id_ident(cx, id);\n+        if vec::len::<t>(tps) > 0u {\n             let strs: [str] = [];\n-            for fld: field in elems { strs += [field_to_str(cx, fld)]; }\n-            \"{\" + str::connect(strs, \",\") + \"}\"\n-          }\n-          ty_tup(elems) {\n-            let strs = [];\n-            for elem in elems { strs += [ty_to_str(cx, elem)]; }\n-            \"(\" + str::connect(strs, \",\") + \")\"\n-          }\n-          ty_tag(id, tps) {\n-            let s = get_id_ident(cx, id);\n-            if vec::len::<t>(tps) > 0u {\n-                let strs: [str] = [];\n-                for typ: t in tps { strs += [ty_to_str(cx, typ)]; }\n-                s += \"<\" + str::connect(strs, \",\") + \">\";\n-            }\n-            s\n-          }\n-          ty_fn(proto, inputs, output, cf, constrs) {\n-            fn_to_str(cx, proto, none, inputs, output, cf, constrs)\n-          }\n-          ty_native_fn(inputs, output) {\n-            fn_to_str(cx, ast::proto_bare, none, inputs, output,\n-                      ast::return_val, [])\n-          }\n-          ty_obj(meths) {\n-            let strs = [];\n-            for m: method in meths { strs += [method_to_str(cx, m)]; }\n-            \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\"\n-          }\n-          ty_res(id, _, _) { get_id_ident(cx, id) }\n-          ty_var(v) { \"<T\" + int::str(v) + \">\" }\n-          ty_param(id, _) {\n-            \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n-          }\n-          _ { ty_to_short_str(cx, typ) }\n+            for typ: t in tps { strs += [ty_to_str(cx, typ)]; }\n+            s += \"<\" + str::connect(strs, \",\") + \">\";\n         }\n+        s\n+      }\n+      ty_fn(proto, inputs, output, cf, constrs) {\n+        fn_to_str(cx, proto, none, inputs, output, cf, constrs)\n+      }\n+      ty_native_fn(inputs, output) {\n+        fn_to_str(cx, ast::proto_bare, none, inputs, output,\n+                  ast::return_val, [])\n+      }\n+      ty_obj(meths) {\n+        let strs = [];\n+        for m: method in meths { strs += [method_to_str(cx, m)]; }\n+        \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\"\n+      }\n+      ty_res(id, _, _) { get_id_ident(cx, id) }\n+      ty_var(v) { \"<T\" + int::str(v) + \">\" }\n+      ty_param(id, _) {\n+        \"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n+      }\n+      _ { ty_to_short_str(cx, typ) }\n+    }\n }\n \n fn ty_to_short_str(cx: ctxt, typ: t) -> str {"}, {"sha": "5ff7681ae8ab484dc377d2f71541d5dcc24d283a", "filename": "src/libstd/char.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -109,12 +109,25 @@ pure fn is_whitespace(c: char) -> bool {\n  Safety note:\n    This function fails if `c` is not a valid char\n */\n-pure fn to_digit(c: char) -> u8 {\n+pure fn to_digit(c: char) -> u8 unsafe {\n+    alt maybe_digit(c) {\n+      option::some(x) { x }\n+      option::none. { fail; }\n+    }\n+}\n+\n+/*\n+ Function: to_digit\n+\n+ Convert a char to the corresponding digit. Returns none when the\n+ character is not a valid hexadecimal digit.\n+*/\n+fn maybe_digit(c: char) -> option::t<u8> {\n     alt c {\n-        '0' to '9' { c as u8 - ('0' as u8) }\n-        'a' to 'z' { c as u8 + 10u8 - ('a' as u8) }\n-        'A' to 'Z' { c as u8 + 10u8 - ('A' as u8) }\n-        _ { fail; }\n+      '0' to '9' { option::some(c as u8 - ('0' as u8)) }\n+      'a' to 'z' { option::some(c as u8 + 10u8 - ('a' as u8)) }\n+      'A' to 'Z' { option::some(c as u8 + 10u8 - ('A' as u8)) }\n+      _ { option::none }\n     }\n }\n "}, {"sha": "0e1a330c6631176565a0f9d144ef565d69e68583", "filename": "src/libstd/u64.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Flibstd%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Flibstd%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fu64.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -63,3 +63,26 @@ Function: str\n Convert to a string\n */\n fn str(n: u64) -> str { ret to_str(n, 10u); }\n+\n+/*\n+Function: parse_buf\n+\n+Parse a string as an unsigned integer.\n+*/\n+fn from_str(buf: str, radix: u64) -> u64 {\n+    if str::byte_len(buf) == 0u {\n+        log_err \"parse_buf(): buf is empty\";\n+        fail;\n+    }\n+    let i = str::byte_len(buf) - 1u;\n+    let power = 1u64, n = 0u64;\n+    while true {\n+        let digit = char::to_digit(buf[i] as char) as u64;\n+        if digit >= radix { fail; }\n+        n += digit * power;\n+        power *= radix;\n+        if i == 0u { ret n; }\n+        i -= 1u;\n+    }\n+    fail;\n+}"}, {"sha": "b2e4ac8c8e0ff2706b54ded22a1b5c9508f09217", "filename": "src/test/run-pass/big-literals.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbig-literals.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    assert 0xffffffffu32 == (-1 as u32);\n+    assert 4294967295u32 == (-1 as u32);\n+    assert 0xffffffffffffffffu64 == (-1 as u64);\n+    assert 18446744073709551615u64 == (-1 as u64);\n+\n+    assert -2147483648i32 - 1i32 == 2147483647i32;\n+    assert -9223372036854775808i64 - 1i64 == 9223372036854775807i64;\n+}\n\\ No newline at end of file"}, {"sha": "de78341a199c56108e1dcc4f55163e84a7133970", "filename": "src/test/run-pass/float-nan.rs", "status": "modified", "additions": 18, "deletions": 74, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Ftest%2Frun-pass%2Ffloat-nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-nan.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -1,82 +1,26 @@\n use std;\n-import std::float;\n \n-fn main() {\n-  let nan = float::NaN;\n-  assert(float::isNaN(nan));\n-\n-  let inf = float::infinity;\n-  assert(-inf == float::neg_infinity);\n-\n-  assert( nan !=  nan);\n-  assert( nan != -nan);\n-  assert(-nan != -nan);\n-  assert(-nan !=  nan);\n+import std::ctypes::*;\n \n-  assert( nan !=   1.);\n-  assert( nan !=   0.);\n-  assert( nan !=  inf);\n-  assert( nan != -inf);\n+fn foo_float() -> m_float { ret 0.0 as m_float; }\n+fn bar_float() -> float { be foo_float() as float; }\n \n-  assert(  1. !=  nan);\n-  assert(  0. !=  nan);\n-  assert( inf !=  nan);\n-  assert(-inf !=  nan);\n+fn foo_int() -> m_int { ret 0 as m_int; }\n+fn bar_int() -> int { be foo_int() as int; }\n \n-  assert(!( nan ==  nan));\n-  assert(!( nan == -nan));\n-  assert(!( nan ==   1.));\n-  assert(!( nan ==   0.));\n-  assert(!( nan ==  inf));\n-  assert(!( nan == -inf));\n-  assert(!(  1. ==  nan));\n-  assert(!(  0. ==  nan));\n-  assert(!( inf ==  nan));\n-  assert(!(-inf ==  nan));\n-  assert(!(-nan ==  nan));\n-  assert(!(-nan == -nan));\n+fn foo_uint() -> m_uint { ret 0u as m_uint; }\n+fn bar_uint() -> uint { be foo_uint() as uint; }\n \n-  assert(!( nan >  nan));\n-  assert(!( nan > -nan));\n-  assert(!( nan >   0.));\n-  assert(!( nan >  inf));\n-  assert(!( nan > -inf));\n-  assert(!(  0. >  nan));\n-  assert(!( inf >  nan));\n-  assert(!(-inf >  nan));\n-  assert(!(-nan >  nan));\n+fn foo_long() -> long { ret 0 as long; }\n+fn bar_long() -> int { be foo_long() as int; }\n \n-  assert(!(nan <   0.));\n-  assert(!(nan <   1.));\n-  assert(!(nan <  -1.));\n-  assert(!(nan <  inf));\n-  assert(!(nan < -inf));\n-  assert(!(nan <  nan));\n-  assert(!(nan < -nan));\n+fn foo_ulong() -> ulong { ret 0u as ulong; }\n+fn bar_ulong() -> uint { be foo_uint() as uint; }\n \n-  assert(!(  0. < nan));\n-  assert(!(  1. < nan));\n-  assert(!( -1. < nan));\n-  assert(!( inf < nan));\n-  assert(!(-inf < nan));\n-  assert(!(-nan < nan));\n-\n-  assert(float::isNaN(nan + inf));\n-  assert(float::isNaN(nan + -inf));\n-  assert(float::isNaN(nan + 0.));\n-  assert(float::isNaN(nan + 1.));\n-  assert(float::isNaN(nan * 1.));\n-  assert(float::isNaN(nan / 1.));\n-  assert(float::isNaN(nan / 0.));\n-  assert(float::isNaN(0. / 0.));\n-  assert(float::isNaN(-inf + inf));\n-  assert(float::isNaN(inf - inf));\n-\n-  assert(!float::isNaN(-1.));\n-  assert(!float::isNaN(0.));\n-  assert(!float::isNaN(0.1));\n-  assert(!float::isNaN(1.));\n-  assert(!float::isNaN(inf));\n-  assert(!float::isNaN(-inf));\n-  assert(!float::isNaN(1./-inf));\n-}\n+fn main() {\n+    assert bar_float() == 0.0;\n+    assert bar_int() == 0;\n+    assert bar_uint() == 0u;\n+    assert bar_long() == 0;\n+    assert bar_ulong() == 0u;\n+}\n\\ No newline at end of file"}, {"sha": "93e18580c645ec28b55d14445186d19ef924e0e2", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eca9174b9dc186de4ad44f80f7537f2e9e4c60/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=e3eca9174b9dc186de4ad44f80f7537f2e9e4c60", "patch": "@@ -41,8 +41,7 @@ fn part1() {\n     test(#fmt[\"%f\", 5.82], \"5.82\");\n     // 32-bit limits\n \n-    // FIXME Disabled until issue 1252 is resolved.\n-    // test(#fmt[\"%i\", -2147483648], \"-2147483648\");\n+    test(#fmt[\"%i\", -2147483648], \"-2147483648\");\n     test(#fmt[\"%i\", 2147483647], \"2147483647\");\n     test(#fmt[\"%u\", 4294967295u], \"4294967295\");\n     test(#fmt[\"%x\", 0xffffffff_u], \"ffffffff\");"}]}