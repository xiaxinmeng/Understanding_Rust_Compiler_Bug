{"sha": "119289b0f2359472ff07b4fac14188c3dc37b63c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTI4OWIwZjIzNTk0NzJmZjA3YjRmYWMxNDE4OGMzZGMzN2I2M2M=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-24T13:39:40Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-01T09:46:09Z"}, "message": "std: migrate the errno -> IoError converter from libnative.\n\nThis also adds a direct `errno` -> `~str` converter, rather than only\nbeing possible to get a string for the very last error.", "tree": {"sha": "f14d1573479651a6f72a1b4e85fc955daffee247", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f14d1573479651a6f72a1b4e85fc955daffee247"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/119289b0f2359472ff07b4fac14188c3dc37b63c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/119289b0f2359472ff07b4fac14188c3dc37b63c", "html_url": "https://github.com/rust-lang/rust/commit/119289b0f2359472ff07b4fac14188c3dc37b63c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/119289b0f2359472ff07b4fac14188c3dc37b63c/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c329a17461b29da3c9f004154d32e4f153d727df", "url": "https://api.github.com/repos/rust-lang/rust/commits/c329a17461b29da3c9f004154d32e4f153d727df", "html_url": "https://github.com/rust-lang/rust/commit/c329a17461b29da3c9f004154d32e4f153d727df"}], "stats": {"total": 185, "additions": 104, "deletions": 81}, "files": [{"sha": "bca564870e2f63fd784b41a0733b4bc13acfa839", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=119289b0f2359472ff07b4fac14188c3dc37b63c", "patch": "@@ -96,10 +96,8 @@ extern \"system\" {\n \n #[cfg(windows)]\n fn get_error(_: c_int) -> IoError {\n-    use super::translate_error;\n-\n     unsafe {\n-        translate_error(WSAGetLastError() as i32, true)\n+        IoError::from_errno(WSAGetLastError() as uint, true)\n     }\n }\n "}, {"sha": "e74321610035215048664bb040dc2bfef1dcde52", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 2, "deletions": 65, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=119289b0f2359472ff07b4fac14188c3dc37b63c", "patch": "@@ -86,73 +86,10 @@ fn unimpl() -> IoError {\n     }\n }\n \n-fn translate_error(errno: i32, detail: bool) -> IoError {\n-    #[cfg(windows)]\n-    fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n-        match errno {\n-            libc::EOF => (io::EndOfFile, \"end of file\"),\n-            libc::ERROR_NO_DATA => (io::BrokenPipe, \"the pipe is being closed\"),\n-            libc::ERROR_FILE_NOT_FOUND => (io::FileNotFound, \"file not found\"),\n-            libc::ERROR_INVALID_NAME => (io::InvalidInput, \"invalid file name\"),\n-            libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n-            libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n-            libc::WSAEACCES => (io::PermissionDenied, \"permission denied\"),\n-            libc::WSAEWOULDBLOCK => {\n-                (io::ResourceUnavailable, \"resource temporarily unavailable\")\n-            }\n-            libc::WSAENOTCONN => (io::NotConnected, \"not connected\"),\n-            libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n-            libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n-            libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-            libc::ERROR_BROKEN_PIPE => (io::EndOfFile, \"the pipe has ended\"),\n-\n-            // libuv maps this error code to EISDIR. we do too. if it is found\n-            // to be incorrect, we can add in some more machinery to only\n-            // return this message when ERROR_INVALID_FUNCTION after certain\n-            // win32 calls.\n-            libc::ERROR_INVALID_FUNCTION => (io::InvalidInput,\n-                                             \"illegal operation on a directory\"),\n-\n-            _ => (io::OtherIoError, \"unknown error\")\n-        }\n-    }\n-\n-    #[cfg(not(windows))]\n-    fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n-        // FIXME: this should probably be a bit more descriptive...\n-        match errno {\n-            libc::EOF => (io::EndOfFile, \"end of file\"),\n-            libc::ECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n-            libc::ECONNRESET => (io::ConnectionReset, \"connection reset\"),\n-            libc::EPERM | libc::EACCES =>\n-                (io::PermissionDenied, \"permission denied\"),\n-            libc::EPIPE => (io::BrokenPipe, \"broken pipe\"),\n-            libc::ENOTCONN => (io::NotConnected, \"not connected\"),\n-            libc::ECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n-            libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n-            libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-            libc::ENOENT => (io::FileNotFound, \"no such file or directory\"),\n-            libc::EISDIR => (io::InvalidInput, \"illegal operation on a directory\"),\n-\n-            // These two constants can have the same value on some systems, but\n-            // different values on others, so we can't use a match clause\n-            x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-                (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n-\n-            _ => (io::OtherIoError, \"unknown error\")\n-        }\n-    }\n-\n-    let (kind, desc) = get_err(errno);\n-    IoError {\n-        kind: kind,\n-        desc: desc,\n-        detail: if detail {Some(os::last_os_error())} else {None},\n-    }\n+fn last_error() -> IoError {\n+    IoError::last_error()\n }\n \n-fn last_error() -> IoError { translate_error(os::errno() as i32, true) }\n-\n // unix has nonzero values as errors\n fn mkerr_libc(ret: libc::c_int) -> IoResult<()> {\n     if ret != 0 {"}, {"sha": "832f4b8df20bf182d2a2ac0245225feb5736e8fd", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=119289b0f2359472ff07b4fac14188c3dc37b63c", "patch": "@@ -120,7 +120,7 @@ fn last_error() -> io::IoError {\n     extern \"system\" {\n         fn WSAGetLastError() -> libc::c_int;\n     }\n-    super::translate_error(unsafe { WSAGetLastError() }, true)\n+    io::IoError::from_errno(unsafe { WSAGetLastError() } as uint, true)\n }\n \n #[cfg(not(windows))]"}, {"sha": "3578c0c39ced96463d1e2a81fd81f01a8a3ef6d1", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=119289b0f2359472ff07b4fac14188c3dc37b63c", "patch": "@@ -469,7 +469,7 @@ fn spawn_process_os(config: p::ProcessConfig,\n                                     (bytes[1] << 16) as i32 |\n                                     (bytes[2] <<  8) as i32 |\n                                     (bytes[3] <<  0) as i32;\n-                        Err(super::translate_error(errno, false))\n+                        Err(io::IoError::from_errno(errno as uint, false))\n                     }\n                     Err(e) => {\n                         assert!(e.kind == io::BrokenPipe ||"}, {"sha": "92c4171efc869c4ab68bca14b8e98472930648e2", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=119289b0f2359472ff07b4fac14188c3dc37b63c", "patch": "@@ -216,6 +216,8 @@ use container::Container;\n use fmt;\n use int;\n use iter::Iterator;\n+use libc;\n+use os;\n use option::{Option, Some, None};\n use path::Path;\n use result::{Ok, Err, Result};\n@@ -290,6 +292,88 @@ pub struct IoError {\n     detail: Option<~str>\n }\n \n+impl IoError {\n+    /// Convert an `errno` value into an `IoError`.\n+    ///\n+    /// If `detail` is `true`, the `detail` field of the `IoError`\n+    /// struct is filled with an allocated string describing the error\n+    /// in more detail, retrieved from the operating system.\n+    pub fn from_errno(errno: uint, detail: bool) -> IoError {\n+        #[cfg(windows)]\n+        fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n+            match errno {\n+                libc::EOF => (EndOfFile, \"end of file\"),\n+                libc::ERROR_NO_DATA => (BrokenPipe, \"the pipe is being closed\"),\n+                libc::ERROR_FILE_NOT_FOUND => (FileNotFound, \"file not found\"),\n+                libc::ERROR_INVALID_NAME => (InvalidInput, \"invalid file name\"),\n+                libc::WSAECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n+                libc::WSAECONNRESET => (ConnectionReset, \"connection reset\"),\n+                libc::WSAEACCES => (PermissionDenied, \"permission denied\"),\n+                libc::WSAEWOULDBLOCK => {\n+                    (ResourceUnavailable, \"resource temporarily unavailable\")\n+                }\n+                libc::WSAENOTCONN => (NotConnected, \"not connected\"),\n+                libc::WSAECONNABORTED => (ConnectionAborted, \"connection aborted\"),\n+                libc::WSAEADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n+                libc::WSAEADDRINUSE => (ConnectionRefused, \"address in use\"),\n+                libc::ERROR_BROKEN_PIPE => (EndOfFile, \"the pipe has ended\"),\n+\n+                // libuv maps this error code to EISDIR. we do too. if it is found\n+                // to be incorrect, we can add in some more machinery to only\n+                // return this message when ERROR_INVALID_FUNCTION after certain\n+                // win32 calls.\n+                libc::ERROR_INVALID_FUNCTION => (InvalidInput,\n+                                                 \"illegal operation on a directory\"),\n+\n+                _ => (OtherIoError, \"unknown error\")\n+            }\n+        }\n+\n+        #[cfg(not(windows))]\n+        fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n+            // FIXME: this should probably be a bit more descriptive...\n+            match errno {\n+                libc::EOF => (EndOfFile, \"end of file\"),\n+                libc::ECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n+                libc::ECONNRESET => (ConnectionReset, \"connection reset\"),\n+                libc::EPERM | libc::EACCES =>\n+                    (PermissionDenied, \"permission denied\"),\n+                libc::EPIPE => (BrokenPipe, \"broken pipe\"),\n+                libc::ENOTCONN => (NotConnected, \"not connected\"),\n+                libc::ECONNABORTED => (ConnectionAborted, \"connection aborted\"),\n+                libc::EADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n+                libc::EADDRINUSE => (ConnectionRefused, \"address in use\"),\n+                libc::ENOENT => (FileNotFound, \"no such file or directory\"),\n+                libc::EISDIR => (InvalidInput, \"illegal operation on a directory\"),\n+\n+                // These two constants can have the same value on some systems, but\n+                // different values on others, so we can't use a match clause\n+                x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+                    (ResourceUnavailable, \"resource temporarily unavailable\"),\n+\n+                _ => (OtherIoError, \"unknown error\")\n+            }\n+        }\n+\n+        let (kind, desc) = get_err(errno as i32);\n+        IoError {\n+            kind: kind,\n+            desc: desc,\n+            detail: if detail {Some(os::error_string(errno))} else {None},\n+        }\n+    }\n+\n+    /// Retrieve the last error to occur as a (detailed) IoError.\n+    ///\n+    /// This uses the OS `errno`, and so there should not be any task\n+    /// descheduling or migration (other than that performed by the\n+    /// operating system) between the call(s) for which errors are\n+    /// being checked and the call of this function.\n+    pub fn last_error() -> IoError {\n+        IoError::from_errno(os::errno() as uint, true)\n+    }\n+}\n+\n impl fmt::Show for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(fmt.buf.write_str(self.desc));"}, {"sha": "f0695b2ef75d89a5bff5c3ac3ae44f4a0a881a83", "filename": "src/libstd/os.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119289b0f2359472ff07b4fac14188c3dc37b63c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=119289b0f2359472ff07b4fac14188c3dc37b63c", "patch": "@@ -663,10 +663,12 @@ pub fn errno() -> uint {\n     }\n }\n \n-/// Get a string representing the platform-dependent last error\n-pub fn last_os_error() -> ~str {\n+/// Return the string corresponding to an `errno()` value of `errnum`.\n+pub fn error_string(errnum: uint) -> ~str {\n+    return strerror(errnum);\n+\n     #[cfg(unix)]\n-    fn strerror() -> ~str {\n+    fn strerror(errnum: uint) -> ~str {\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n@@ -702,7 +704,7 @@ pub fn last_os_error() -> ~str {\n \n         let p = buf.as_mut_ptr();\n         unsafe {\n-            if strerror_r(errno() as c_int, p, buf.len() as libc::size_t) < 0 {\n+            if strerror_r(errnum as c_int, p, buf.len() as libc::size_t) < 0 {\n                 fail!(\"strerror_r failure\");\n             }\n \n@@ -711,7 +713,7 @@ pub fn last_os_error() -> ~str {\n     }\n \n     #[cfg(windows)]\n-    fn strerror() -> ~str {\n+    fn strerror(errnum: uint) -> ~str {\n         use libc::types::os::arch::extra::DWORD;\n         use libc::types::os::arch::extra::LPWSTR;\n         use libc::types::os::arch::extra::LPVOID;\n@@ -735,34 +737,36 @@ pub fn last_os_error() -> ~str {\n         // This value is calculated from the macro\n         // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n         let langId = 0x0800 as DWORD;\n-        let err = errno() as DWORD;\n \n         let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n \n         unsafe {\n             let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n                                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                                      ptr::mut_null(),\n-                                     err,\n+                                     errnum as DWORD,\n                                      langId,\n                                      buf.as_mut_ptr(),\n                                      buf.len() as DWORD,\n                                      ptr::null());\n             if res == 0 {\n                 // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n                 let fm_err = errno();\n-                return format!(\"OS Error {} (FormatMessageW() returned error {})\", err, fm_err);\n+                return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n             }\n \n             let msg = str::from_utf16(str::truncate_utf16_at_nul(buf));\n             match msg {\n-                Some(msg) => format!(\"OS Error {}: {}\", err, msg),\n-                None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", err),\n+                Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n+                None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n             }\n         }\n     }\n+}\n \n-    strerror()\n+/// Get a string representing the platform-dependent last error\n+pub fn last_os_error() -> ~str {\n+    error_string(errno() as uint)\n }\n \n static mut EXIT_STATUS: AtomicInt = INIT_ATOMIC_INT;"}]}