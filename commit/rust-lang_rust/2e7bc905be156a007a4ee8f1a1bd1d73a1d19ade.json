{"sha": "2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlN2JjOTA1YmUxNTZhMDA3YTRlZThmMWExYmQxZDczYTFkMTlhZGU=", "commit": {"author": {"name": "Ville Penttinen", "email": "villem.penttinen@gmail.com", "date": "2019-02-21T21:57:07Z"}, "committer": {"name": "Ville Penttinen", "email": "villem.penttinen@gmail.com", "date": "2019-02-21T21:57:07Z"}, "message": "Remove Const inference for now, refactor PathResult", "tree": {"sha": "2159410676f8fcddfd8e23b0fbc0fcb759c6ce7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2159410676f8fcddfd8e23b0fbc0fcb759c6ce7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade", "html_url": "https://github.com/rust-lang/rust/commit/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/comments", "author": {"login": "vipentti", "id": 4726680, "node_id": "MDQ6VXNlcjQ3MjY2ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/4726680?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vipentti", "html_url": "https://github.com/vipentti", "followers_url": "https://api.github.com/users/vipentti/followers", "following_url": "https://api.github.com/users/vipentti/following{/other_user}", "gists_url": "https://api.github.com/users/vipentti/gists{/gist_id}", "starred_url": "https://api.github.com/users/vipentti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vipentti/subscriptions", "organizations_url": "https://api.github.com/users/vipentti/orgs", "repos_url": "https://api.github.com/users/vipentti/repos", "events_url": "https://api.github.com/users/vipentti/events{/privacy}", "received_events_url": "https://api.github.com/users/vipentti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vipentti", "id": 4726680, "node_id": "MDQ6VXNlcjQ3MjY2ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/4726680?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vipentti", "html_url": "https://github.com/vipentti", "followers_url": "https://api.github.com/users/vipentti/followers", "following_url": "https://api.github.com/users/vipentti/following{/other_user}", "gists_url": "https://api.github.com/users/vipentti/gists{/gist_id}", "starred_url": "https://api.github.com/users/vipentti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vipentti/subscriptions", "organizations_url": "https://api.github.com/users/vipentti/orgs", "repos_url": "https://api.github.com/users/vipentti/repos", "events_url": "https://api.github.com/users/vipentti/events{/privacy}", "received_events_url": "https://api.github.com/users/vipentti/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "816971ebc9207c5fb5779d448613dd171c27f398", "url": "https://api.github.com/repos/rust-lang/rust/commits/816971ebc9207c5fb5779d448613dd171c27f398", "html_url": "https://github.com/rust-lang/rust/commit/816971ebc9207c5fb5779d448613dd171c27f398"}], "stats": {"total": 170, "additions": 93, "deletions": 77}, "files": [{"sha": "b1872110451a129222d6a28eb2e0bc5e5fe3aa41", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade", "patch": "@@ -119,10 +119,6 @@ impl<T> PerNs<T> {\n         self.types.is_some() && self.values.is_some()\n     }\n \n-    pub fn is_values(&self) -> bool {\n-        self.values.is_some() && self.types.is_none()\n-    }\n-\n     pub fn take(self, namespace: Namespace) -> Option<T> {\n         match namespace {\n             Namespace::Types => self.types,\n@@ -671,23 +667,20 @@ impl ItemMap {\n                         }\n                     }\n                 }\n-                ModuleDef::Struct(s) => {\n-                    return ResolvePathResult::with(\n-                        PerNs::types((*s).into()),\n-                        ReachedFixedPoint::Yes,\n-                        Some(i),\n-                    );\n-                }\n-                _ => {\n+                s => {\n                     // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated\n-                    // item... Which we currently don't handle (TODO)\n+                    // (`Struct::method`), or some other kind of associated item\n                     log::debug!(\n                         \"path segment {:?} resolved to non-module {:?}, but is not last\",\n                         segment.name,\n                         curr,\n                     );\n-                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n+\n+                    return ResolvePathResult::with(\n+                        PerNs::types((*s).into()),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n                 }\n             };\n         }"}, {"sha": "9f4d4ab424f9d4e04dd1c52f43b47b1238c003ba", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade", "patch": "@@ -33,27 +33,68 @@ pub(crate) struct ExprScope {\n }\n \n #[derive(Debug, Clone)]\n-pub enum PathResult {\n-    /// Path was fully resolved\n-    FullyResolved(PerNs<Resolution>),\n-    /// Path was partially resolved, first element contains the resolution\n-    /// second contains the index in the Path.segments which we were unable to resolve\n-    PartiallyResolved(PerNs<Resolution>, usize),\n+pub struct PathResult {\n+    /// The actual path resolution\n+    resolution: PerNs<Resolution>,\n+    /// The first index in the path that we\n+    /// were unable to resolve.\n+    /// When path is fully resolved, this is 0.\n+    remaining_index: usize,\n }\n \n impl PathResult {\n-    pub fn segment_index(&self) -> Option<usize> {\n-        match self {\n-            PathResult::FullyResolved(_) => None,\n-            PathResult::PartiallyResolved(_, ref i) => Some(*i),\n+    /// Returns the remaining index in the result\n+    /// returns None if the path was fully resolved\n+    pub fn remaining_index(&self) -> Option<usize> {\n+        if self.remaining_index > 0 {\n+            Some(self.remaining_index)\n+        } else {\n+            None\n         }\n     }\n \n     /// Consumes `PathResult` and returns the contained `PerNs<Resolution>`\n+    /// if the path was fully resolved, meaning we have no remaining items\n     pub fn into_per_ns(self) -> PerNs<Resolution> {\n-        match self {\n-            PathResult::FullyResolved(def) => def,\n-            PathResult::PartiallyResolved(def, _) => def,\n+        if self.remaining_index().is_none() {\n+            self.resolution\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n+\n+    /// Consumes `PathResult` and returns the resolution and the\n+    /// remaining_index as a tuple.\n+    pub fn into_inner(self) -> (PerNs<Resolution>, Option<usize>) {\n+        let index = self.remaining_index();\n+        (self.resolution, index)\n+    }\n+\n+    /// Path is fully resolved when `remaining_index` is none\n+    /// and the resolution contains anything\n+    pub fn is_fully_resolved(&self) -> bool {\n+        !self.resolution.is_none() && self.remaining_index().is_none()\n+    }\n+\n+    /// Empty path result is where the resolution is `none`\n+    /// and the remaining index is 0\n+    pub fn is_empty(&self) -> bool {\n+        self.resolution.is_none() && self.remaining_index().is_none()\n+    }\n+\n+    fn empty() -> PathResult {\n+        PathResult { resolution: PerNs::none(), remaining_index: 0 }\n+    }\n+\n+    fn from_resolution(res: PerNs<Resolution>) -> PathResult {\n+        PathResult::from_resolution_with_index(res, 0)\n+    }\n+\n+    fn from_resolution_with_index(res: PerNs<Resolution>, remaining_index: usize) -> PathResult {\n+        if res.is_none() {\n+            PathResult::empty()\n+        } else {\n+            PathResult { resolution: res, remaining_index }\n         }\n     }\n }\n@@ -94,24 +135,23 @@ impl Resolver {\n     }\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PathResult {\n-        use self::PathResult::*;\n         if let Some(name) = path.as_ident() {\n-            FullyResolved(self.resolve_name(db, name))\n+            PathResult::from_resolution(self.resolve_name(db, name))\n         } else if path.is_self() {\n-            FullyResolved(self.resolve_name(db, &Name::self_param()))\n+            PathResult::from_resolution(self.resolve_name(db, &Name::self_param()))\n         } else {\n             let (item_map, module) = match self.module() {\n                 Some(m) => m,\n-                _ => return FullyResolved(PerNs::none()),\n+                _ => return PathResult::empty(),\n             };\n             let (module_res, segment_index) = item_map.resolve_path(db, module, path);\n \n             let def = module_res.map(Resolution::Def);\n \n             if let Some(index) = segment_index {\n-                PartiallyResolved(def, index)\n+                PathResult::from_resolution_with_index(def, index)\n             } else {\n-                FullyResolved(def)\n+                PathResult::from_resolution(def)\n             }\n         }\n     }"}, {"sha": "b1f35ab1ffbd95d4d03eb48d45eae9825f450220", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade", "patch": "@@ -32,20 +32,17 @@ use rustc_hash::FxHashMap;\n \n use test_utils::tested_by;\n \n-use ra_syntax::ast::NameOwner;\n-\n use crate::{\n     Function, Struct, StructField, Enum, EnumVariant, Path, Name,\n-    Const,\n     FnSignature, ModuleDef, AdtDef,\n     HirDatabase,\n     type_ref::{TypeRef, Mutability},\n-    name::{KnownName, AsName},\n+    name::{KnownName},\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n     generics::GenericParams,\n     path::GenericArg,\n     adt::VariantDef,\n-    resolve::{Resolver, Resolution, PathResult}, nameres::Namespace\n+    resolve::{Resolver, Resolution}, nameres::Namespace\n };\n \n /// The ID of a type variable.\n@@ -681,19 +678,6 @@ fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     Ty::FnDef { def: def.into(), sig, name, substs }\n }\n \n-fn type_for_const(db: &impl HirDatabase, resolver: &Resolver, def: Const) -> Ty {\n-    let node = def.source(db).1;\n-\n-    let tr = node\n-        .type_ref()\n-        .map(TypeRef::from_ast)\n-        .as_ref()\n-        .map(|tr| Ty::from_hir(db, resolver, tr))\n-        .unwrap_or_else(|| Ty::Unknown);\n-\n-    tr\n-}\n-\n /// Compute the type of a tuple struct constructor.\n fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n     let var_data = def.variant_data(db);\n@@ -1190,21 +1174,28 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n         let resolved = resolver.resolve_path(self.db, &path);\n \n-        let (resolved, segment_index) = match resolved {\n-            PathResult::FullyResolved(def) => (def.take_values()?, None),\n-            PathResult::PartiallyResolved(def, index) => (def.take_types()?, Some(index)),\n-        };\n+        let (def, remaining_index) = resolved.into_inner();\n+\n+        // if the remaining_index is None, we expect the path\n+        // to be fully resolved, in this case we continue with\n+        // the default by attempting to `take_values\u00b4 from the resolution.\n+        // Otherwise the path was partially resolved, which means\n+        // we might have resolved into a type for which\n+        // we may find some associated item starting at the\n+        // path.segment pointed to by `remaining_index\u00b4\n+        let resolved =\n+            if remaining_index.is_none() { def.take_values()? } else { def.take_types()? };\n \n         match resolved {\n             Resolution::Def(def) => {\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n \n-                if let Some(segment_index) = segment_index {\n+                if let Some(remaining_index) = remaining_index {\n                     let ty = self.db.type_for_def(typable, Namespace::Types);\n-                    // TODO: What to do if segment_index is not the last segment\n-                    // in the path\n-                    let segment = &path.segments[segment_index];\n+                    // TODO: Keep resolving the segments\n+                    // if we have more segments to process\n+                    let segment = &path.segments[remaining_index];\n \n                     // Attempt to find an impl_item for the type which has a name matching\n                     // the current segment\n@@ -1216,17 +1207,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             }\n                             None\n                         }\n-                        crate::ImplItem::Const(c) => {\n-                            let node = c.source(self.db).1;\n-\n-                            if let Some(name) = node.name().map(|n| n.as_name()) {\n-                                if segment.name == name {\n-                                    return Some(type_for_const(self.db, resolver, c));\n-                                }\n-                            }\n \n-                            None\n-                        }\n+                        // TODO: Resolve associated const\n+                        crate::ImplItem::Const(_) => None,\n \n                         // TODO: Resolve associated types\n                         crate::ImplItem::Type(_) => None,"}, {"sha": "131d1fa16c6b6c4535e7bbfc2ae357939d235e8d", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_const.snap", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap", "raw_url": "https://github.com/rust-lang/rust/raw/2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap?ref=2e7bc905be156a007a4ee8f1a1bd1d73a1d19ade", "patch": "@@ -1,14 +1,14 @@\n ---\n-created: \"2019-02-20T11:04:56.553382800Z\"\n+created: \"2019-02-21T21:51:46.497925200Z\"\n creator: insta@0.6.3\n source: crates/ra_hir/src/ty/tests.rs\n expression: \"&result\"\n ---\n [227; 305) '{     ...:ID; }': ()\n-[237; 238) 'x': u32\n-[241; 252) 'Struct::FOO': u32\n-[262; 263) 'y': u32\n-[266; 275) 'Enum::BAR': u32\n-[285; 286) 'z': u32\n-[289; 302) 'TraitTest::ID': u32\n+[237; 238) 'x': [unknown]\n+[241; 252) 'Struct::FOO': [unknown]\n+[262; 263) 'y': [unknown]\n+[266; 275) 'Enum::BAR': [unknown]\n+[285; 286) 'z': [unknown]\n+[289; 302) 'TraitTest::ID': [unknown]\n "}]}