{"sha": "c4dd3f4ef98f8527aa652e8154ff044ca3e88455", "node_id": "C_kwDOAAsO6NoAKGM0ZGQzZjRlZjk4Zjg1MjdhYTY1MmU4MTU0ZmYwNDRjYTNlODg0NTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T15:10:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T15:10:56Z"}, "message": "Auto merge of #2228 - cbeuw:futex-fix, r=RalfJung\n\nPrevent futex_wait from actually waiting if a concurrent waker was executed before us\n\nFixes #2223\n\nTwo SC fences were placed in `futex_wake` (after the caller has changed `addr`), and in `futex_wait` (before we read `addr`). This guarantees that `futex_wait` sees the value written to `addr` before the last `futex_wake` call, should one exists, and avoid going into sleep with no one else to wake us up.\nhttps://github.com/rust-lang/miri/blob/ada7b72a879d79aaa06f0a2a95edd520615da1a2/src/concurrency/weak_memory.rs#L324-L326\n\nEarlier I proposed to use `fetch_add(0)` to read the latest value in MO, though this isn't the proper way to do it and breaks aliasing: syscall caller may pass in a `*const` from a `&` and Miri complains about write to a `SharedReadOnly` location, causing this test to fail.\nhttps://github.com/rust-lang/miri/blob/ada7b72a879d79aaa06f0a2a95edd520615da1a2/tests/pass/concurrency/linux-futex.rs#L56-L68", "tree": {"sha": "4486c10154a6aa989ad3d32e8a51a1c0d22fa6a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4486c10154a6aa989ad3d32e8a51a1c0d22fa6a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4dd3f4ef98f8527aa652e8154ff044ca3e88455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4dd3f4ef98f8527aa652e8154ff044ca3e88455", "html_url": "https://github.com/rust-lang/rust/commit/c4dd3f4ef98f8527aa652e8154ff044ca3e88455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4dd3f4ef98f8527aa652e8154ff044ca3e88455/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a58f1a2db55cfd30089328245d3f0760877f93", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a58f1a2db55cfd30089328245d3f0760877f93", "html_url": "https://github.com/rust-lang/rust/commit/c3a58f1a2db55cfd30089328245d3f0760877f93"}, {"sha": "737a5b3b9814e919d30f60323a7679697a34b153", "url": "https://api.github.com/repos/rust-lang/rust/commits/737a5b3b9814e919d30f60323a7679697a34b153", "html_url": "https://github.com/rust-lang/rust/commit/737a5b3b9814e919d30f60323a7679697a34b153"}], "stats": {"total": 105, "additions": 94, "deletions": 11}, "files": [{"sha": "0fdbde8d6775f726106c8b522ad0f2842e5020f8", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c4dd3f4ef98f8527aa652e8154ff044ca3e88455/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4dd3f4ef98f8527aa652e8154ff044ca3e88455/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=c4dd3f4ef98f8527aa652e8154ff044ca3e88455", "patch": "@@ -126,28 +126,63 @@ pub fn futex<'tcx>(\n                 Align::from_bytes(4).unwrap(),\n                 CheckInAllocMsg::MemoryAccessTest,\n             )?;\n+            // There may be a concurrent thread changing the value of addr\n+            // and then invoking the FUTEX_WAKE syscall. It is critical that the\n+            // effects of this and the other thread are correctly observed,\n+            // otherwise we will deadlock.\n+            //\n+            // There are two scenarios to consider:\n+            // 1. If we (FUTEX_WAIT) execute first, we'll push ourselves into\n+            //    the waiters queue and go to sleep. They (addr write & FUTEX_WAKE)\n+            //    will see us in the queue and wake us up.\n+            // 2. If they (addr write & FUTEX_WAKE) execute first, we must observe\n+            //    addr's new value. If we see an outdated value that happens to equal\n+            //    the expected val, then we'll put ourselves to sleep with no one to wake us\n+            //    up, so we end up with a deadlock. This is prevented by having a SeqCst\n+            //    fence inside FUTEX_WAKE syscall, and another SeqCst fence\n+            //    below, the atomic read on addr after the SeqCst fence is guaranteed\n+            //    not to see any value older than the addr write immediately before\n+            //    calling FUTEX_WAKE. We'll see futex_val != val and return without\n+            //    sleeping.\n+            //\n+            //    Note that the fences do not create any happens-before relationship.\n+            //    The read sees the write immediately before the fence not because\n+            //    one happens after the other, but is instead due to a guarantee unique\n+            //    to SeqCst fences that restricts what an atomic read placed AFTER the\n+            //    fence can see. The read still has to be atomic, otherwise it's a data\n+            //    race. This guarantee cannot be achieved with acquire-release fences\n+            //    since they only talk about reads placed BEFORE a fence - and places\n+            //    no restrictions on what the read itself can see, only that there is\n+            //    a happens-before between the fences IF the read happens to see the\n+            //    right value. This is useless to us, since we need the read itself\n+            //    to see an up-to-date value.\n+            //\n+            // The above case distinction is valid since both FUTEX_WAIT and FUTEX_WAKE\n+            // contain a SeqCst fence, therefore inducting a total order between the operations.\n+            // It is also critical that the fence, the atomic load, and the comparison in FUTEX_WAIT\n+            // altogether happen atomically. If the other thread's fence in FUTEX_WAKE\n+            // gets interleaved after our fence, then we lose the guarantee on the\n+            // atomic load being up-to-date; if the other thread's write on addr and FUTEX_WAKE\n+            // call are interleaved after the load but before the comparison, then we get a TOCTOU\n+            // race condition, and go to sleep thinking the other thread will wake us up,\n+            // even though they have already finished.\n+            //\n+            // Thankfully, preemptions cannot happen inside a Miri shim, so we do not need to\n+            // do anything special to guarantee fence-load-comparison atomicity.\n+            this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n             // FIXME: this fails if `addr` is not a pointer type.\n-            // The atomic ordering for futex(https://man7.org/linux/man-pages/man2/futex.2.html):\n-            //  \"The load of the value of the futex word is an\n-            //   atomic memory access (i.e., using atomic machine instructions\n-            //   of the respective architecture).  This load, the comparison\n-            //   with the expected value, and starting to sleep are performed\n-            //   atomically and totally ordered with respect to other futex\n-            //   operations on the same futex word.\"\n-            // SeqCst is total order over all operations.\n-            // FIXME: check if this should be changed when weak memory orders are added.\n             let futex_val = this\n                 .read_scalar_at_offset_atomic(\n                     &addr.into(),\n                     0,\n                     this.machine.layouts.i32,\n-                    AtomicReadOp::SeqCst,\n+                    AtomicReadOp::Relaxed,\n                 )?\n                 .to_i32()?;\n             if val == futex_val {\n-                // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n+                // The value still matches, so we block the thread make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n                 this.futex_wait(addr_usize, thread, bitset);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n@@ -203,6 +238,10 @@ pub fn futex<'tcx>(\n                 this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n                 return Ok(());\n             }\n+            // Together with the SeqCst fence in futex_wait, this makes sure that futex_wait\n+            // will see the latest value on addr which could be changed by our caller\n+            // before doing the syscall.\n+            this.atomic_fence(&[], AtomicFenceOp::SeqCst)?;\n             let mut n = 0;\n             for _ in 0..val {\n                 if let Some(thread) = this.futex_wake(addr_usize, bitset) {"}, {"sha": "0d30ddff4809fd4b0cb9935e3437edc5e1cf724f", "filename": "tests/pass/concurrency/linux-futex.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c4dd3f4ef98f8527aa652e8154ff044ca3e88455/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4dd3f4ef98f8527aa652e8154ff044ca3e88455/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs?ref=c4dd3f4ef98f8527aa652e8154ff044ca3e88455", "patch": "@@ -6,6 +6,8 @@ extern crate libc;\n \n use std::mem::MaybeUninit;\n use std::ptr;\n+use std::sync::atomic::AtomicI32;\n+use std::sync::atomic::Ordering;\n use std::thread;\n use std::time::{Duration, Instant};\n \n@@ -206,6 +208,47 @@ fn wait_wake_bitset() {\n     t.join().unwrap();\n }\n \n+const FREE: i32 = 0;\n+const HELD: i32 = 1;\n+fn concurrent_wait_wake() {\n+    static FUTEX: AtomicI32 = AtomicI32::new(0);\n+    for _ in 0..20 {\n+        // Suppose the main thread is holding a lock implemented using futex...\n+        FUTEX.store(HELD, Ordering::Relaxed);\n+\n+        let t = thread::spawn(move || {\n+            // If this syscall runs first, then we'll be woken up by\n+            // the main thread's FUTEX_WAKE, and all is fine.\n+            //\n+            // If this sycall runs after the main thread's store\n+            // and FUTEX_WAKE, the syscall must observe that\n+            // the FUTEX is FREE != HELD and return without waiting\n+            // or we'll deadlock.\n+            unsafe {\n+                libc::syscall(\n+                    libc::SYS_futex,\n+                    &FUTEX as *const AtomicI32,\n+                    libc::FUTEX_WAIT,\n+                    HELD,\n+                    ptr::null::<libc::timespec>(),\n+                );\n+            }\n+        });\n+\n+        FUTEX.store(FREE, Ordering::Relaxed);\n+        unsafe {\n+            libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const AtomicI32,\n+                libc::FUTEX_WAKE,\n+                1,\n+            );\n+        }\n+\n+        t.join().unwrap();\n+    }\n+}\n+\n fn main() {\n     wake_nobody();\n     wake_dangling();\n@@ -214,4 +257,5 @@ fn main() {\n     wait_absolute_timeout();\n     wait_wake();\n     wait_wake_bitset();\n+    concurrent_wait_wake();\n }"}]}