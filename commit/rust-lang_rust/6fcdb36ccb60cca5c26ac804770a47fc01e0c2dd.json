{"sha": "6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmY2RiMzZjY2I2MGNjYTVjMjZhYzgwNDc3MGE0N2ZjMDFlMGMyZGQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-08-25T20:03:24Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-09-05T14:07:16Z"}, "message": "Make use of hygiene in AST passes", "tree": {"sha": "d93ac96d0d64b2a5473a5c04bcb41244a626bc83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d93ac96d0d64b2a5473a5c04bcb41244a626bc83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "html_url": "https://github.com/rust-lang/rust/commit/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4082cd95a8de6c8244e9b44908f9859e75acdeea", "url": "https://api.github.com/repos/rust-lang/rust/commits/4082cd95a8de6c8244e9b44908f9859e75acdeea", "html_url": "https://github.com/rust-lang/rust/commit/4082cd95a8de6c8244e9b44908f9859e75acdeea"}], "stats": {"total": 555, "additions": 298, "deletions": 257}, "files": [{"sha": "649cc8a2fb51515e9a710e8e25395f9d523a30e7", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -233,7 +233,7 @@ pub fn register_plugins<'a>(\n         syntax::attr::inject(krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr)\n     });\n \n-    let (mut krate, features) = syntax::config::features(\n+    let (krate, features) = syntax::config::features(\n         krate,\n         &sess.parse_sess,\n         sess.edition(),\n@@ -268,16 +268,6 @@ pub fn register_plugins<'a>(\n         middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n-    krate = time(sess, \"crate injection\", || {\n-        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        let (krate, name) =\n-            syntax_ext::standard_library_imports::inject(krate, alt_std_name, sess.edition());\n-        if let Some(name) = name {\n-            sess.parse_sess.injected_crate_name.set(name);\n-        }\n-        krate\n-    });\n-\n     let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(\n             sess,\n@@ -370,6 +360,21 @@ fn configure_and_expand_inner<'a>(\n         &resolver_arenas,\n     );\n     syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n+\n+    krate = time(sess, \"crate injection\", || {\n+        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n+        let (krate, name) = syntax_ext::standard_library_imports::inject(\n+            krate,\n+            &mut resolver,\n+            alt_std_name,\n+            sess.edition(),\n+        );\n+        if let Some(name) = name {\n+            sess.parse_sess.injected_crate_name.set(name);\n+        }\n+        krate\n+    });\n+\n     syntax_ext::plugin_macro_defs::inject(\n         &mut krate, &mut resolver, plugin_info.syntax_exts, sess.edition()\n     );"}, {"sha": "20d281f1e997af2878f42ca812fe632279635b1d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -97,16 +97,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: NodeId) -> ExpnId {\n-        let expn_id = ExpnId::fresh(Some(ExpnData::default(\n-            ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n-        )));\n-        let module = self.module_map[&self.definitions.local_def_id(id)];\n-        self.invocation_parent_scopes.insert(expn_id, ParentScope::module(module));\n-        self.definitions.set_invocation_parent(expn_id, module.def_id().unwrap().index);\n-        expn_id\n-    }\n-\n     fn resolve_dollar_crates(&mut self) {\n         hygiene::update_dollar_crate_names(|ctxt| {\n             let ident = Ident::new(kw::DollarCrate, DUMMY_SP.with_ctxt(ctxt));"}, {"sha": "962447e8cf07f31239a64fbf0c3b0ee99250c7e4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -653,8 +653,6 @@ bitflags::bitflags! {\n pub trait Resolver {\n     fn next_node_id(&mut self) -> NodeId;\n \n-    fn get_module_scope(&mut self, id: NodeId) -> ExpnId;\n-\n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n                                             extra_placeholders: &[NodeId]);"}, {"sha": "ccdc5bd81a04b0bc133e71c0795e9ee3c01fa79a", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -11,7 +11,7 @@ use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax::tokenstream::*;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnData, ExpnKind, MacroKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind, AstPass};\n \n use std::mem;\n \n@@ -44,7 +44,7 @@ pub fn inject(\n     if !named_exts.is_empty() {\n         let mut extra_items = Vec::new();\n         let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-            ExpnKind::Macro(MacroKind::Attr, sym::plugin), DUMMY_SP, edition,\n+            ExpnKind::AstPass(AstPass::PluginMacroDefs), DUMMY_SP, edition,\n             [sym::rustc_attrs][..].into(),\n         ));\n         for (name, ext) in named_exts {"}, {"sha": "1cdaa1190fae360efb0dbe9194c16d7f08cf16a9", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 52, "deletions": 34, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -3,15 +3,15 @@ use std::mem;\n use smallvec::smallvec;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::source_map::{ExpnData, ExpnKind, respan};\n-use syntax::ext::base::{ExtCtxt, MacroKind};\n+use syntax::ext::base::ExtCtxt;\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::hygiene::AstPass;\n \n struct ProcMacroDerive {\n     trait_name: ast::Name,\n@@ -308,8 +308,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n // Creates a new module which looks like:\n //\n-//      #[doc(hidden)]\n-//      mod $gensym {\n+//      const _: () = {\n //          extern crate proc_macro;\n //\n //          use proc_macro::bridge::client::ProcMacro;\n@@ -327,32 +326,29 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n-        [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n-    ));\n-\n-    let hidden = cx.meta_list_item_word(span, sym::hidden);\n-    let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n-    let doc_hidden = cx.attribute(doc);\n-\n-    let proc_macro = Ident::with_dummy_span(sym::proc_macro);\n+    let span = cx.resolver.span_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::ProcMacroHarness,\n+        &[sym::rustc_attrs, sym::proc_macro_internals],\n+        None,\n+    );\n+\n+    let proc_macro = Ident::new(sym::proc_macro, span);\n     let krate = cx.item(span,\n                         proc_macro,\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let bridge = Ident::from_str(\"bridge\");\n-    let client = Ident::from_str(\"client\");\n-    let proc_macro_ty = Ident::from_str(\"ProcMacro\");\n-    let custom_derive = Ident::from_str(\"custom_derive\");\n-    let attr = Ident::from_str(\"attr\");\n-    let bang = Ident::from_str(\"bang\");\n-    let crate_kw = Ident::with_dummy_span(kw::Crate);\n+    let bridge = Ident::from_str_and_span(\"bridge\", span);\n+    let client = Ident::from_str_and_span(\"client\", span);\n+    let proc_macro_ty = Ident::from_str_and_span(\"ProcMacro\", span);\n+    let custom_derive = Ident::from_str_and_span(\"custom_derive\", span);\n+    let attr = Ident::from_str_and_span(\"attr\", span);\n+    let bang = Ident::from_str_and_span(\"bang\", span);\n \n     let decls = {\n         let local_path = |sp: Span, name| {\n-            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![crate_kw, name]))\n+            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![name]))\n         };\n         let proc_macro_ty_method_path = |method| cx.expr_path(cx.path(span, vec![\n             proc_macro, bridge, client, proc_macro_ty, method,\n@@ -381,7 +377,7 @@ fn mk_decls(\n \n     let decls_static = cx.item_static(\n         span,\n-        Ident::from_str(\"_DECLS\"),\n+        Ident::from_str_and_span(\"_DECLS\", span),\n         cx.ty_rptr(span,\n             cx.ty(span, ast::TyKind::Slice(\n                 cx.ty_path(cx.path(span,\n@@ -392,22 +388,44 @@ fn mk_decls(\n     ).map(|mut i| {\n         let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n         i.attrs.push(cx.attribute(attr));\n-        i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });\n \n-    let module = cx.item_mod(\n-        span,\n+    let block = P(ast::Expr {\n+        id: ast::DUMMY_NODE_ID,\n+        attrs: syntax::ThinVec::new(),\n+        node: ast::ExprKind::Block(P(ast::Block {\n+            id: ast::DUMMY_NODE_ID,\n+            rules: ast::BlockCheckMode::Default,\n+            stmts: vec![\n+                ast::Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: ast::StmtKind::Item(krate),\n+                    span,\n+                },\n+                ast::Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: ast::StmtKind::Item(decls_static),\n+                    span,\n+                }\n+            ],\n+            span,\n+        }), None),\n         span,\n-        ast::Ident::from_str(\"decls\").gensym(),\n-        vec![doc_hidden],\n-        vec![krate, decls_static],\n-    ).map(|mut i| {\n-        i.vis = respan(span, ast::VisibilityKind::Public);\n-        i\n     });\n \n+    let anon_constant = cx.item_const(\n+        span,\n+        ast::Ident::new(kw::Underscore, span),\n+        P(ast::Ty {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::TyKind::Tup(Vec::new()),\n+            span,\n+        }),\n+        block,\n+    );\n+\n     // Integrate the new module into existing module structures.\n-    let module = AstFragment::Items(smallvec![module]);\n-    cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap()\n+    let items = AstFragment::Items(smallvec![anon_constant]);\n+    cx.monotonic_expander().fully_expand_fragment(items).make_items().pop().unwrap()\n }"}, {"sha": "61e423266fa05b3ac08f2ea4c605c66b8bf47cbc", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 95, "deletions": 35, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -1,52 +1,56 @@\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n-use syntax::ext::hygiene::MacroKind;\n+use syntax::ext::hygiene::AstPass;\n+use syntax::ext::base::Resolver;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned, respan};\n+use syntax::source_map::respan;\n use syntax::symbol::{Ident, Symbol, kw, sym};\n use syntax_pos::DUMMY_SP;\n \n-use std::iter;\n-\n pub fn inject(\n-    mut krate: ast::Crate, alt_std_name: Option<&str>, edition: Edition\n+    mut krate: ast::Crate,\n+    resolver: &mut dyn Resolver,\n+    alt_std_name: Option<Symbol>,\n+    edition: Edition,\n ) -> (ast::Crate, Option<Symbol>) {\n     let rust_2018 = edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[&str] = if attr::contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n         return (krate, None);\n     } else if attr::contains_name(&krate.attrs, sym::no_std) {\n         if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n-            &[\"core\"]\n+            &[sym::core]\n         } else {\n-            &[\"core\", \"compiler_builtins\"]\n+            &[sym::core, sym::compiler_builtins]\n         }\n     } else {\n-        &[\"std\"]\n+        &[sym::std]\n     };\n \n+    let span = resolver.span_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::StdImports,\n+        &[sym::prelude_import],\n+        None,\n+    );\n+\n     // .rev() to preserve ordering above in combination with insert(0, ...)\n-    let alt_std_name = alt_std_name.map(Symbol::intern);\n-    for orig_name_str in names.iter().rev() {\n-        // HACK(eddyb) gensym the injected crates on the Rust 2018 edition,\n-        // so they don't accidentally interfere with the new import paths.\n-        let orig_name_sym = Symbol::intern(orig_name_str);\n-        let orig_name_ident = Ident::with_dummy_span(orig_name_sym);\n+    for &orig_name_sym in names.iter().rev() {\n         let (rename, orig_name) = if rust_2018 {\n-            (orig_name_ident.gensym(), Some(orig_name_sym))\n+            (Ident::new(kw::Underscore, span), Some(orig_name_sym))\n         } else {\n-            (orig_name_ident, None)\n+            (Ident::with_dummy_span(orig_name_sym), None)\n         };\n         krate.module.items.insert(0, P(ast::Item {\n             attrs: vec![attr::mk_attr_outer(\n-                attr::mk_word_item(ast::Ident::with_dummy_span(sym::macro_use))\n+                attr::mk_word_item(ast::Ident::new(sym::macro_use, span))\n             )],\n-            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n+            vis: respan(span, ast::VisibilityKind::Inherited),\n             node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n             ident: rename,\n             id: ast::DUMMY_NODE_ID,\n-            span: DUMMY_SP,\n+            span,\n             tokens: None,\n         }));\n     }\n@@ -55,32 +59,88 @@ pub fn inject(\n     // the prelude.\n     let name = names[0];\n \n-    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n-        [sym::prelude_import][..].into(),\n-    ));\n+    let segments = if rust_2018 {\n+        [name, sym::prelude, sym::v1].iter()\n+            .map(|symbol| ast::PathSegment::from_ident(ast::Ident::new(*symbol, span)))\n+            .collect()\n+    } else {\n+        [kw::PathRoot, name, sym::prelude, sym::v1].iter()\n+            .map(|symbol| ast::PathSegment::from_ident(ast::Ident::with_dummy_span(*symbol)))\n+            .collect()\n+    };\n \n-    krate.module.items.insert(0, P(ast::Item {\n+    let use_item = P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(\n             attr::mk_word_item(ast::Ident::new(sym::prelude_import, span)))],\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n-            prefix: ast::Path {\n-                segments: iter::once(ast::Ident::with_dummy_span(kw::PathRoot))\n-                    .chain(\n-                        [name, \"prelude\", \"v1\"].iter().cloned()\n-                            .map(ast::Ident::from_str)\n-                    ).map(ast::PathSegment::from_ident).collect(),\n-                span,\n-            },\n+            prefix: ast::Path { segments, span },\n             kind: ast::UseTreeKind::Glob,\n             span,\n         })),\n         id: ast::DUMMY_NODE_ID,\n         ident: ast::Ident::invalid(),\n         span,\n         tokens: None,\n-    }));\n+    });\n+\n+    let prelude_import_item = if rust_2018 {\n+        let hygienic_extern_crate = P(ast::Item {\n+            attrs: vec![],\n+            vis: respan(span, ast::VisibilityKind::Inherited),\n+            node: ast::ItemKind::ExternCrate(alt_std_name),\n+            ident: ast::Ident::new(name, span),\n+            id: ast::DUMMY_NODE_ID,\n+            span,\n+            tokens: None,\n+        });\n+\n+        // Use an anonymous const to hide `extern crate std as hygienic_std`\n+        // FIXME: Once inter-crate hygiene exists, this can just be `use_item`.\n+        P(ast::Item {\n+            attrs: Vec::new(),\n+            vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+            node: ast::ItemKind::Const(\n+                P(ast::Ty {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: ast::TyKind::Tup(Vec::new()),\n+                    span,\n+                }),\n+                P(ast::Expr {\n+                    id: ast::DUMMY_NODE_ID,\n+                    attrs: syntax::ThinVec::new(),\n+                    node: ast::ExprKind::Block(P(ast::Block {\n+                        id: ast::DUMMY_NODE_ID,\n+                        rules: ast::BlockCheckMode::Default,\n+                        stmts: vec![\n+                            ast::Stmt {\n+                                id: ast::DUMMY_NODE_ID,\n+                                node: ast::StmtKind::Item(use_item),\n+                                span,\n+                            },\n+                            ast::Stmt {\n+                                id: ast::DUMMY_NODE_ID,\n+                                node: ast::StmtKind::Item(hygienic_extern_crate),\n+                                span,\n+                            }\n+                        ],\n+                        span,\n+                    }), None),\n+                    span,\n+                })\n+            ),\n+            id: ast::DUMMY_NODE_ID,\n+            ident: ast::Ident::new(kw::Underscore, span),\n+            span,\n+            tokens: None,\n+        })\n+    } else {\n+        // Have `extern crate std` at the root, so don't need to create a named\n+        // extern crate item.\n+        use_item\n+    };\n+\n+    krate.module.items.insert(0, prelude_import_item);\n \n-    (krate, Some(Symbol::intern(name)))\n+    (krate, Some(name))\n }"}, {"sha": "be5aca73f5cb1d504849c19ece1f934b0837c2ee", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -28,11 +28,11 @@ pub fn expand_test_case(\n \n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = ecx.with_legacy_ctxt(attr_sp);\n+    let sp = ecx.with_def_site_ctxt(attr_sp);\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n-        item.ident = item.ident.gensym();\n+        item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n         item.attrs.push(\n             ecx.attribute(ecx.meta_word(sp, sym::rustc_test_marker))\n         );\n@@ -92,10 +92,9 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let (sp, attr_sp) = (cx.with_legacy_ctxt(item.span), cx.with_legacy_ctxt(attr_sp));\n+    let (sp, attr_sp) = (cx.with_def_site_ctxt(item.span), cx.with_def_site_ctxt(attr_sp));\n \n-    // Gensym \"test\" so we can extern crate without conflicting with any local names\n-    let test_id = cx.ident_of(\"test\").gensym();\n+    let test_id = ast::Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n     let test_path = |name| {\n@@ -112,7 +111,7 @@ pub fn expand_test_or_bench(\n \n     let test_fn = if is_bench {\n         // A simple ident for a lambda\n-        let b = cx.ident_of(\"b\");\n+        let b = ast::Ident::from_str_and_span(\"b\", attr_sp);\n \n         cx.expr_call(sp, cx.expr_path(test_path(\"StaticBenchFn\")), vec![\n             // |b| self::test::assert_test_result(\n@@ -143,7 +142,7 @@ pub fn expand_test_or_bench(\n         ])\n     };\n \n-    let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp).gensym(),\n+    let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp),\n         vec![\n             // #[cfg(test)]\n             cx.attribute(cx.meta_list(attr_sp, sym::cfg, vec![\n@@ -192,17 +191,17 @@ pub fn expand_test_or_bench(\n         ));\n     test_const = test_const.map(|mut tc| { tc.vis.node = ast::VisibilityKind::Public; tc});\n \n-    // extern crate test as test_gensym\n+    // extern crate test\n     let test_extern = cx.item(sp,\n         test_id,\n         vec![],\n-        ast::ItemKind::ExternCrate(Some(sym::test))\n+        ast::ItemKind::ExternCrate(None)\n     );\n \n     log::debug!(\"synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n \n     vec![\n-        // Access to libtest under a gensymed name\n+        // Access to libtest under a hygienic name\n         Annotatable::Item(test_extern),\n         // The generated test case\n         Annotatable::Item(test_const),"}, {"sha": "6eb132979df8f7a1cec8bcf32184ee3d339c5435", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 46, "deletions": 129, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -5,32 +5,29 @@ use smallvec::{smallvec, SmallVec};\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n-use syntax::ext::base::{ExtCtxt, MacroKind, Resolver};\n+use syntax::ext::base::{ExtCtxt, Resolver};\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::feature_gate::Features;\n use syntax::mut_visit::{*, ExpectOne};\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned};\n-use syntax::symbol::{kw, sym, Symbol};\n+use syntax::source_map::respan;\n+use syntax::symbol::{sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::hygiene::{AstPass, SyntaxContext, Transparency};\n \n use std::{iter, mem};\n \n struct Test {\n     span: Span,\n-    path: Vec<Ident>,\n+    ident: Ident,\n }\n \n struct TestCtxt<'a> {\n-    span_diagnostic: &'a errors::Handler,\n-    path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     test_runner: Option<ast::Path>,\n-    // top-level re-export submodule, filled out after folding is finished\n-    toplevel_reexport: Option<Ident>,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n@@ -43,8 +40,8 @@ pub fn inject(\n     span_diagnostic: &errors::Handler,\n     features: &Features,\n ) {\n-    // Check for #[reexport_test_harness_main = \"some_name\"] which\n-    // creates a `use __test::main as some_name;`. This needs to be\n+    // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n+    // main test function the name `some_name` without hygiene. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n@@ -56,16 +53,13 @@ pub fn inject(\n \n     if should_test {\n         generate_test_harness(sess, resolver, reexport_test_harness_main,\n-                              krate, span_diagnostic, features, test_runner)\n+                              krate, features, test_runner)\n     }\n }\n \n struct TestHarnessGenerator<'a> {\n     cx: TestCtxt<'a>,\n-    tests: Vec<Ident>,\n-\n-    // submodule name, gensym'd identifier for re-exports\n-    tested_submods: Vec<(Ident, Ident)>,\n+    tests: Vec<Test>,\n }\n \n impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n@@ -77,49 +71,46 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n     }\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        let ident = i.ident;\n-        if ident.name != kw::Invalid {\n-            self.cx.path.push(ident);\n-        }\n-        debug!(\"current path: {}\", path_name_i(&self.cx.path));\n-\n         let mut item = i.into_inner();\n         if is_test_case(&item) {\n             debug!(\"this is a test item\");\n \n             let test = Test {\n                 span: item.span,\n-                path: self.cx.path.clone(),\n+                ident: item.ident,\n             };\n-            self.cx.test_cases.push(test);\n-            self.tests.push(item.ident);\n+            self.tests.push(test);\n         }\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         if let ast::ItemKind::Mod(mut module) = item.node {\n             let tests = mem::take(&mut self.tests);\n-            let tested_submods = mem::take(&mut self.tested_submods);\n             noop_visit_mod(&mut module, self);\n-            let tests = mem::replace(&mut self.tests, tests);\n-            let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n+            let mut tests = mem::replace(&mut self.tests, tests);\n \n-            if !tests.is_empty() || !tested_submods.is_empty() {\n-                let (it, sym) = mk_reexport_mod(&mut self.cx, item.id, tests, tested_submods);\n-                module.items.push(it);\n-\n-                if !self.cx.path.is_empty() {\n-                    self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n+            if !tests.is_empty() {\n+                let parent = if item.id == ast::DUMMY_NODE_ID {\n+                    ast::CRATE_NODE_ID\n                 } else {\n-                    debug!(\"pushing nothing, sym: {:?}\", sym);\n-                    self.cx.toplevel_reexport = Some(sym);\n+                    item.id\n+                };\n+                // Create an identifier that will hygienically resolve the test\n+                // case name, even in another module.\n+                let sp = self.cx.ext_cx.resolver.span_for_ast_pass(\n+                    module.inner,\n+                    AstPass::TestHarness,\n+                    &[],\n+                    Some(parent),\n+                );\n+                let expn = sp.ctxt().outer_expn();\n+                for test in &mut tests {\n+                    test.ident.span = test.ident.span.apply_mark(expn, Transparency::Opaque);\n                 }\n+                self.cx.test_cases.extend(tests);\n             }\n             item.node = ast::ItemKind::Mod(module);\n         }\n-        if ident.name != kw::Invalid {\n-            self.cx.path.pop();\n-        }\n         smallvec![P(item)]\n     }\n \n@@ -181,59 +172,11 @@ impl MutVisitor for EntryPointCleaner {\n     }\n }\n \n-/// Creates an item (specifically a module) that \"pub use\"s the tests passed in.\n-/// Each tested submodule will contain a similar reexport module that we will export\n-/// under the name of the original module. That is, `submod::__test_reexports` is\n-/// reexported like so `pub use submod::__test_reexports as submod`.\n-fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n-                   parent: ast::NodeId,\n-                   tests: Vec<Ident>,\n-                   tested_submods: Vec<(Ident, Ident)>)\n-                   -> (P<ast::Item>, Ident) {\n-    let super_ = Ident::with_dummy_span(kw::Super);\n-\n-    let items = tests.into_iter().map(|r| {\n-        cx.ext_cx.item_use_simple(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n-                                  cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n-    }).chain(tested_submods.into_iter().map(|(r, sym)| {\n-        let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.item_use_simple_(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n-                                   Some(r), path)\n-    })).collect();\n-\n-    let reexport_mod = ast::Mod {\n-        inline: true,\n-        inner: DUMMY_SP,\n-        items,\n-    };\n-\n-    let name = Ident::from_str(\"__test_reexports\").gensym();\n-    let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n-    cx.ext_cx.current_expansion.id = cx.ext_cx.resolver.get_module_scope(parent);\n-    let module = P(ast::Item {\n-        ident: name,\n-        attrs: Vec::new(),\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemKind::Mod(reexport_mod),\n-        vis: dummy_spanned(ast::VisibilityKind::Public),\n-        span: DUMMY_SP,\n-        tokens: None,\n-    });\n-\n-    // Integrate the new module into existing module structures.\n-    let module = AstFragment::Items(smallvec![module]);\n-    let module =\n-        cx.ext_cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap();\n-\n-    (module, name)\n-}\n-\n /// Crawl over the crate, inserting test reexports and the test main function\n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut dyn Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: &mut ast::Crate,\n-                         sd: &errors::Handler,\n                          features: &Features,\n                          test_runner: Option<ast::Path>) {\n     // Remove the entry points\n@@ -244,19 +187,15 @@ fn generate_test_harness(sess: &ParseSess,\n     econfig.features = Some(features);\n \n     let cx = TestCtxt {\n-        span_diagnostic: sd,\n         ext_cx: ExtCtxt::new(sess, econfig, resolver),\n-        path: Vec::new(),\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n-        toplevel_reexport: None,\n         test_runner\n     };\n \n     TestHarnessGenerator {\n         cx,\n         tests: Vec::new(),\n-        tested_submods: Vec::new(),\n     }.visit_crate(krate);\n }\n \n@@ -268,12 +207,14 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n-        [sym::main, sym::test, sym::rustc_attrs][..].into(),\n-    ));\n+    let sp = cx.ext_cx.resolver.span_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::TestHarness,\n+        &[sym::main, sym::test, sym::rustc_attrs],\n+        None,\n+    );\n     let ecx = &cx.ext_cx;\n-    let test_id = Ident::with_dummy_span(sym::test);\n+    let test_id = Ident::new(sym::test, sp);\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n@@ -285,14 +226,14 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     let test_main_path_expr = ecx.expr_path(test_runner);\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n-                                       vec![mk_tests_slice(cx)]);\n+                                       vec![mk_tests_slice(cx, sp)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n     // #![main]\n     let main_meta = ecx.meta_word(sp, sym::main);\n     let main_attr = ecx.attribute(main_meta);\n \n-    // extern crate test as test_gensym\n+    // extern crate test\n     let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,\n         test_id,\n         vec![],\n@@ -316,16 +257,16 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     // Honor the reexport_test_harness_main attribute\n     let main_id = match cx.reexport_test_harness_main {\n-        Some(sym) => Ident::new(sym, sp),\n-        None => Ident::from_str_and_span(\"main\", sp).gensym(),\n+        Some(sym) => Ident::new(sym, sp.with_ctxt(SyntaxContext::root())),\n+        None => Ident::from_str_and_span(\"main\", sp),\n     };\n \n     let main = P(ast::Item {\n         ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n-        vis: dummy_spanned(ast::VisibilityKind::Public),\n+        vis: respan(sp, ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n     });\n@@ -335,44 +276,20 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     cx.ext_cx.monotonic_expander().fully_expand_fragment(main).make_items().pop().unwrap()\n }\n \n-fn path_name_i(idents: &[Ident]) -> String {\n-    let mut path_name = \"\".to_string();\n-    let mut idents_iter = idents.iter().peekable();\n-    while let Some(ident) = idents_iter.next() {\n-        path_name.push_str(&ident.as_str());\n-        if idents_iter.peek().is_some() {\n-            path_name.push_str(\"::\")\n-        }\n-    }\n-    path_name\n-}\n-\n /// Creates a slice containing every test like so:\n-/// &[path::to::test1, path::to::test2]\n-fn mk_tests_slice(cx: &TestCtxt<'_>) -> P<ast::Expr> {\n+/// &[test1, test2]\n+fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.test_cases.len());\n     let ref ecx = cx.ext_cx;\n \n-    ecx.expr_vec_slice(DUMMY_SP,\n+\n+    ecx.expr_vec_slice(sp,\n         cx.test_cases.iter().map(|test| {\n             ecx.expr_addr_of(test.span,\n-                ecx.expr_path(ecx.path(test.span, visible_path(cx, &test.path))))\n+                ecx.expr_path(ecx.path(test.span, vec![test.ident])))\n         }).collect())\n }\n \n-/// Creates a path from the top-level __test module to the test via __test_reexports\n-fn visible_path(cx: &TestCtxt<'_>, path: &[Ident]) -> Vec<Ident>{\n-    let mut visible_path = vec![];\n-    match cx.toplevel_reexport {\n-        Some(id) => visible_path.push(id),\n-        None => {\n-            cx.span_diagnostic.bug(\"expected to find top-level re-export name, but found None\");\n-        }\n-    }\n-    visible_path.extend_from_slice(path);\n-    visible_path\n-}\n-\n fn is_test_case(i: &ast::Item) -> bool {\n     attr::contains_name(&i.attrs, sym::rustc_test_marker)\n }"}, {"sha": "babba293d03bdded07a45c0a558a857cedb7445c", "filename": "src/test/ui/hygiene/auxiliary/not-libstd.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -0,0 +1 @@\n+pub fn not_in_lib_std() {}"}, {"sha": "51e7bed6580b35b369281f9a7b4399d33089d3e1", "filename": "src/test/ui/hygiene/prelude-import-hygiene.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -0,0 +1,29 @@\n+// Make sure that attribute used when injecting the prelude are resolved\n+// hygienically.\n+\n+// check-pass\n+// aux-build:not-libstd.rs\n+\n+//revisions: rust2015 rust2018\n+//[rust2018] edition:2018\n+\n+// The prelude import shouldn't see these as candidates for when it's trying to\n+// use the built-in macros.\n+extern crate core;\n+use core::prelude::v1::test as prelude_import;\n+use core::prelude::v1::test as macro_use;\n+\n+// Should not be used for the prelude import - not a concern in the 2015 edition\n+// because `std` is already declared in the crate root.\n+#[cfg(rust2018)]\n+extern crate not_libstd as std;\n+\n+#[cfg(rust2018)]\n+mod x {\n+    // The extern crate item should override `std` in the extern prelude.\n+    fn f() {\n+        std::not_in_lib_std();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7b53f0c536ad9917b1f40e40e61b2112ce3d023e", "filename": "src/test/ui/imports/gensymed.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -1,7 +1,9 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n // edition:2018\n // aux-build:gensymed.rs\n \n extern crate gensymed;\n \n+use gensymed::*;\n+\n fn main() {}"}, {"sha": "b6a817e6b1d303c6c1444105ae1c9d585ebd45a2", "filename": "src/test/ui/inaccessible-test-modules.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4082cd95a8de6c8244e9b44908f9859e75acdeea/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4082cd95a8de6c8244e9b44908f9859e75acdeea/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr?ref=4082cd95a8de6c8244e9b44908f9859e75acdeea", "patch": "@@ -1,21 +0,0 @@\n-error[E0432]: unresolved import `__test`\n-  --> $DIR/inaccessible-test-modules.rs:5:5\n-   |\n-LL | use __test as x;\n-   |     ------^^^^^\n-   |     |\n-   |     no `__test` in the root\n-   |     help: a similar name exists in the module: `test`\n-\n-error[E0432]: unresolved import `__test_reexports`\n-  --> $DIR/inaccessible-test-modules.rs:6:5\n-   |\n-LL | use __test_reexports as y;\n-   |     ----------------^^^^^\n-   |     |\n-   |     no `__test_reexports` in the root\n-   |     help: a similar name exists in the module: `__test_reexports`\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0432`."}, {"sha": "fcbe9f49e556497b49d0ed97162969ac9f86a78e", "filename": "src/test/ui/test-attrs/decl-macro-test.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -0,0 +1,22 @@\n+// Check that declarative macros can declare tests\n+\n+// check-pass\n+// compile-flags: --test\n+\n+#![feature(decl_macro)]\n+\n+macro create_test() {\n+    #[test]\n+    fn test() {}\n+}\n+\n+macro create_module_test() {\n+    mod x {\n+        #[test]\n+        fn test() {}\n+    }\n+}\n+\n+create_test!();\n+create_test!();\n+create_module_test!();"}, {"sha": "f5b34793794805cf44dbd090e16b977b5b40e670", "filename": "src/test/ui/test-attrs/inaccessible-test-modules.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -2,8 +2,8 @@\n \n // the `--test` harness creates modules with these textual names, but\n // they should be inaccessible from normal code.\n-use __test as x; //~ ERROR unresolved import `__test`\n-use __test_reexports as y; //~ ERROR unresolved import `__test_reexports`\n+use main as x; //~ ERROR unresolved import `main`\n+use test as y; //~ ERROR unresolved import `test`\n \n #[test]\n fn baz() {}", "previous_filename": "src/test/ui/inaccessible-test-modules.rs"}, {"sha": "a94ea1e79bc5199afe75779d024cf0f59551ff8d", "filename": "src/test/ui/test-attrs/inaccessible-test-modules.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr?ref=6fcdb36ccb60cca5c26ac804770a47fc01e0c2dd", "patch": "@@ -0,0 +1,21 @@\n+error[E0432]: unresolved import `main`\n+  --> $DIR/inaccessible-test-modules.rs:5:5\n+   |\n+LL | use main as x;\n+   |     ----^^^^^\n+   |     |\n+   |     no `main` in the root\n+   |     help: a similar name exists in the module: `main`\n+\n+error[E0432]: unresolved import `test`\n+  --> $DIR/inaccessible-test-modules.rs:6:5\n+   |\n+LL | use test as y;\n+   |     ----^^^^^\n+   |     |\n+   |     no `test` in the root\n+   |     help: a similar name exists in the module: `test`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}]}