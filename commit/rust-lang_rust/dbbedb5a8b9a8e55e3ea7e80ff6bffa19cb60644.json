{"sha": "dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYmVkYjVhOGI5YThlNTVlM2VhN2U4MGZmNmJmZmExOWNiNjA2NDQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-11T13:34:37Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-11T13:34:37Z"}, "message": "Rollup merge of #24253 - steveklabnik:doc_primitive_types, r=alexcrichton\n\n A brief introduction to each type, with pointers to the primitive pages\nfor more info.", "tree": {"sha": "1f7a1ab6372e841f4b4405de3a75cbb0a1d0e57a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f7a1ab6372e841f4b4405de3a75cbb0a1d0e57a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644", "html_url": "https://github.com/rust-lang/rust/commit/dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f1723b2b7065be0b7f311b761e89bdb18265f50", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f1723b2b7065be0b7f311b761e89bdb18265f50", "html_url": "https://github.com/rust-lang/rust/commit/0f1723b2b7065be0b7f311b761e89bdb18265f50"}, {"sha": "7bb0cd76f323b6d9f0b5a3347188183ce346c489", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bb0cd76f323b6d9f0b5a3347188183ce346c489", "html_url": "https://github.com/rust-lang/rust/commit/7bb0cd76f323b6d9f0b5a3347188183ce346c489"}], "stats": {"total": 438, "additions": 267, "deletions": 171}, "files": [{"sha": "029facdec762b3a0dd8d610b369f97aea01cab73", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644", "patch": "@@ -17,8 +17,8 @@\n     * [`Deref` coercions](deref-coercions.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n-    * [Primitive Types](primitive-types.md)\n     * [Functions](functions.md)\n+    * [Primitive Types](primitive-types.md)\n     * [Comments](comments.md)\n     * [Structs](structs.md)\n     * [Mutability](mutability.md)\n@@ -35,8 +35,6 @@\n     * [Move semantics](move-semantics.md)\n     * [Drop](drop.md)\n     * [Vectors](vectors.md)\n-    * [Arrays](arrays.md)\n-    * [Slices](slices.md)\n     * [Strings](strings.md)\n     * [Traits](traits.md)\n     * [Operators and Overloading](operators-and-overloading.md)\n@@ -47,7 +45,6 @@\n     * [Crates and Modules](crates-and-modules.md)\n     * [`static`](static.md)\n     * [`const`](const.md)\n-    * [Tuples](tuples.md)\n     * [Tuple Structs](tuple-structs.md)\n     * [Attributes](attributes.md)\n     * [Conditional Compilation](conditional-compilation.md)"}, {"sha": "a6ecac962d60de4acb58795e19bcb03b0a98ec7e", "filename": "src/doc/trpl/arrays.md", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0f1723b2b7065be0b7f311b761e89bdb18265f50/src%2Fdoc%2Ftrpl%2Farrays.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1723b2b7065be0b7f311b761e89bdb18265f50/src%2Fdoc%2Ftrpl%2Farrays.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays.md?ref=0f1723b2b7065be0b7f311b761e89bdb18265f50", "patch": "@@ -1,48 +0,0 @@\n-% Arrays\n-\n-Like many programming languages, Rust has list types to represent a sequence of\n-things. The most basic is the *array*, a fixed-size list of elements of the\n-same type. By default, arrays are immutable.\n-\n-```{rust}\n-let a = [1, 2, 3]; // a: [i32; 3]\n-let mut m = [1, 2, 3]; // mut m: [i32; 3]\n-```\n-\n-There's a shorthand for initializing each element of an array to the same\n-value. In this example, each element of `a` will be initialized to `0`:\n-\n-```{rust}\n-let a = [0; 20]; // a: [i32; 20]\n-```\n-\n-Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we\n-cover generics.\n-\n-You can get the number of elements in an array `a` with `a.len()`, and use\n-`a.iter()` to iterate over them with a for loop. This code will print each\n-number in order:\n-\n-```{rust}\n-let a = [1, 2, 3];\n-\n-println!(\"a has {} elements\", a.len());\n-for e in a.iter() {\n-    println!(\"{}\", e);\n-}\n-```\n-\n-You can access a particular element of an array with *subscript notation*:\n-\n-```{rust}\n-let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n-\n-println!(\"The second name is: {}\", names[1]);\n-```\n-\n-Subscripts start at zero, like in most programming languages, so the first name\n-is `names[0]` and the second name is `names[1]`. The above example prints\n-`The second name is: Brian`. If you try to use a subscript that is not in the\n-array, you will get an error: array access is bounds-checked at run-time. Such\n-errant access is the source of many bugs in other systems programming\n-languages."}, {"sha": "fcbe2b2f8bf7073f4674c0dde222a3e88bed760d", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 266, "deletions": 1, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=dbbedb5a8b9a8e55e3ea7e80ff6bffa19cb60644", "patch": "@@ -1,3 +1,268 @@\n % Primitive Types\n \n-Coming Soon!\n+The Rust language has a number of types that are considered \u2018primitive\u2019. This\n+means that they\u2019re built-in to the language. Rust is structured in such a way\n+that the standard library also provides a number of useful types built on top\n+of these ones, as well, but these are the most primitive.\n+\n+# Booleans\n+\n+Rust has a built in boolean type, named `bool`. It has two values, `true` and `false`:\n+\n+```rust\n+let x = true;\n+\n+let y: bool = false;\n+```\n+\n+A common use of booleans is in [`if` statements][if].\n+\n+[if]: if.html\n+\n+You can find more documentation for `bool`s [in the standard library\n+documentation][bool].\n+\n+[bool]: ../std/primitive.bool.html\n+\n+# `char`\n+\n+The `char` type represents a single Unicode scalar value. You can create `char`s\n+with a single tick: (`'`)\n+\n+```rust\n+let x = 'x';\n+let two_hearts = '\ud83d\udc95';\n+```\n+\n+Unlike some other languages, this means that Rust\u2019s `char` is not a single byte,\n+but four.\n+\n+You can find more documentation for `char`s [in the standard library\n+documentation][char].\n+\n+[char]: ../std/primitive.char.html\n+\n+# Numeric types\n+\n+Rust has a variety of numeric types in a few categories: signed and unsigned,\n+fixed and variable, floating-point and integer.\n+\n+These types consist of two parts: the category, and the size. For example,\n+`u16` is an unsigned type with sixteen bits of size. More bits lets you have\n+bigger numbers.\n+\n+If a number literal has nothing to cause its type to be inferred, it defaults:\n+\n+```rust\n+let x = 42; // x has type i32\n+\n+let y = 1.0; // y has type f64\n+```\n+\n+Here\u2019s a list of the different numeric types, with links to their documentation\n+in the standard library:\n+\n+* [i16](../std/primitive.i16.html)\n+* [i32](../std/primitive.i32.html)\n+* [i64](../std/primitive.i64.html)\n+* [i8](../std/primitive.i8.html)\n+* [u16](../std/primitive.u16.html)\n+* [u32](../std/primitive.u32.html)\n+* [u64](../std/primitive.u64.html)\n+* [u8](../std/primitive.u8.html)\n+* [isize](../std/primitive.isize.html)\n+* [usize](../std/primitive.usize.html)\n+* [f32](../std/primitive.f32.html)\n+* [f64](../std/primitive.f64.html)\n+\n+Let\u2019s go over them by category:\n+\n+## Signed and Unsigned\n+\n+Integer types come in two varieties: signed and unsigned. To understand the\n+difference, let\u2019s consider a number with four bits of size. A signed, four-bit\n+number would let you store numbers from `-8` to `+7`. Signed numbers use\n+\u2018two\u2019s compliment representation\u2019. An unsigned four bit number, since it does\n+not need to store negatives, can store values from `0` to `+15`.\n+\n+Unsigned types use a `u` for their category, and signed types use `i`. The `i`\n+is for \u2018integer\u2019. So `u8` is an eight-bit unsigned number, and `i8` is an\n+eight-bit signed number. \n+\n+## Fixed size types\n+\n+Fixed size types have a specific number of bits in their representation. Valid\n+bit sizes are `8`, `16`, `32`, and `64`. So, `u32` is an unsigned, 32-bit integer,\n+and `i64` is a signed, 64-bit integer.\n+\n+## Variable sized types\n+\n+Rust also provides types whose size depends on the size of a pointer of the\n+underlying machine. These types have \u2018size\u2019 as the category, and come in signed\n+and unsigned varieties. This makes for two types: `isize` and `usize`.\n+\n+## Floating-point types\n+\n+Rust also two floating point types: `f32` and `f64`. These correspond to \n+IEEE-754 single and double precision numbers.\n+\n+# Arrays\n+\n+Like many programming languages, Rust has list types to represent a sequence of\n+things. The most basic is the *array*, a fixed-size list of elements of the\n+same type. By default, arrays are immutable.\n+\n+```rust\n+let a = [1, 2, 3]; // a: [i32; 3]\n+let mut m = [1, 2, 3]; // m: [i32; 3]\n+```\n+\n+Arrays have type `[T; N]`. We\u2019ll talk about this `T` notation [in the generics\n+section][generics]. The `N` is a compile-time constant, for the length of the\n+array.\n+\n+There\u2019s a shorthand for initializing each element of an array to the same\n+value. In this example, each element of `a` will be initialized to `0`:\n+\n+```rust\n+let a = [0; 20]; // a: [i32; 20]\n+```\n+\n+You can get the number of elements in an array `a` with `a.len()`:\n+\n+```rust\n+let a = [1, 2, 3];\n+\n+println!(\"a has {} elements\", a.len());\n+```\n+\n+You can access a particular element of an array with *subscript notation*:\n+\n+```rust\n+let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n+\n+println!(\"The second name is: {}\", names[1]);\n+```\n+\n+Subscripts start at zero, like in most programming languages, so the first name\n+is `names[0]` and the second name is `names[1]`. The above example prints\n+`The second name is: Brian`. If you try to use a subscript that is not in the\n+array, you will get an error: array access is bounds-checked at run-time. Such\n+errant access is the source of many bugs in other systems programming\n+languages.\n+\n+You can find more documentation for `array`s [in the standard library\n+documentation][array].\n+\n+[array]: ../std/primitive.array.html\n+\n+# Slices\n+\n+A \u2018slice\u2019 is a reference to (or \u201cview\u201d into) another data structure. They are\n+useful for allowing safe, efficient access to a portion of an array without\n+copying. For example, you might want to reference just one line of a file read\n+into memory. By nature, a slice is not created directly, but from an existing\n+variable. Slices have a length, can be mutable or not, and in many ways behave\n+like arrays:\n+\n+```rust\n+let a = [0, 1, 2, 3, 4];\n+let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n+```\n+\n+Slices have type `&[T]`. We\u2019ll talk about that `T` when we cover\n+[generics][generics].\n+\n+[generics]: generics.html\n+\n+You can find more documentation for `slices`s [in the standard library\n+documentation][slice].\n+\n+[slice]: ../std/primitive.slice.html\n+\n+# `str`\n+\n+Rust\u2019s `str` type is the most primitive string type. As an [unsized type][dst],\n+it\u2019s not very useful by itself, but becomes useful when placed behind a reference,\n+like [`&str`][strings]. As such, we\u2019ll just leave it at that.\n+\n+[dst]: unsized-types.html\n+[strings]: strings.html\n+\n+You can find more documentation for `str` [in the standard library\n+documentation][str].\n+\n+[str]: ../std/primitive.str.html\n+\n+# Tuples\n+\n+A tuple is an ordered list of fixed size. Like this:\n+\n+```rust\n+let x = (1, \"hello\");\n+```\n+\n+The parentheses and commas form this two-length tuple. Here\u2019s the same code, but\n+with the type annotated:\n+\n+```rust\n+let x: (i32, &str) = (1, \"hello\");\n+```\n+\n+As you can see, the type of a tuple looks just like the tuple, but with each\n+position having a type name rather than the value. Careful readers will also\n+note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n+In systems programming languages, strings are a bit more complex than in other\n+languages. For now, just read `&str` as a *string slice*, and we\u2019ll learn more\n+soon.\n+\n+You can access the fields in a tuple through a *destructuring let*. Here\u2019s\n+an example:\n+\n+```rust\n+let (x, y, z) = (1, 2, 3);\n+\n+println!(\"x is {}\", x);\n+```\n+\n+Remember [before][let] when I said the left-hand side of a `let` statement was more\n+powerful than just assigning a binding? Here we are. We can put a pattern on\n+the left-hand side of the `let`, and if it matches up to the right-hand side,\n+we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n+or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n+\n+[let]: variable-bindings.html\n+\n+This pattern is very powerful, and we\u2019ll see it repeated more later.\n+\n+There are also a few things you can do with a tuple as a whole, without\n+destructuring. You can assign one tuple into another, if they have the same\n+contained types and [arity]. Tuples have the same arity when they have the same\n+length.\n+\n+[arity]: glossary.html#arity\n+\n+```rust\n+let mut x = (1, 2); // x: (i32, i32)\n+let y = (2, 3); // y: (i32, i32)\n+\n+x = y;\n+```\n+\n+You can find more documentation for tuples [in the standard library\n+documentation][tuple].\n+\n+[tuple]: ../std/primitive.tuple.html\n+\n+# Functions\n+\n+Functions also have a type! They look like this:\n+\n+```\n+fn foo(x: i32) -> i32 { x }\n+\n+let x: fn(i32) -> i32 = foo;\n+```\n+\n+In this case, `x` is a \u2018function pointer\u2019 to a function that takes an `i32` and\n+returns an `i32`."}, {"sha": "a31c0ac3c4e69f5dfc5829571feceed4ddd2688d", "filename": "src/doc/trpl/slices.md", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f1723b2b7065be0b7f311b761e89bdb18265f50/src%2Fdoc%2Ftrpl%2Fslices.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1723b2b7065be0b7f311b761e89bdb18265f50/src%2Fdoc%2Ftrpl%2Fslices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslices.md?ref=0f1723b2b7065be0b7f311b761e89bdb18265f50", "patch": "@@ -1,21 +0,0 @@\n-% Slices\n-\n-A *slice* is a reference to (or \"view\" into) an array. They are useful for\n-allowing safe, efficient access to a portion of an array without copying. For\n-example, you might want to reference just one line of a file read into memory.\n-By nature, a slice is not created directly, but from an existing variable.\n-Slices have a length, can be mutable or not, and in many ways behave like\n-arrays:\n-\n-```{rust}\n-let a = [0, 1, 2, 3, 4];\n-let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n-\n-for e in middle.iter() {\n-    println!(\"{}\", e); // Prints 1, 2, 3\n-}\n-```\n-\n-You can also take a slice of a vector, `String`, or `&str`, because they are\n-backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover\n-generics."}, {"sha": "dd526d05b671e1d8904aa072a9b0273ad56c70c4", "filename": "src/doc/trpl/tuples.md", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0f1723b2b7065be0b7f311b761e89bdb18265f50/src%2Fdoc%2Ftrpl%2Ftuples.md", "raw_url": "https://github.com/rust-lang/rust/raw/0f1723b2b7065be0b7f311b761e89bdb18265f50/src%2Fdoc%2Ftrpl%2Ftuples.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuples.md?ref=0f1723b2b7065be0b7f311b761e89bdb18265f50", "patch": "@@ -1,97 +0,0 @@\n-% Tuples\n-\n-The first compound data type we're going to talk about is called the *tuple*.\n-A tuple is an ordered list of fixed size. Like this:\n-\n-```rust\n-let x = (1, \"hello\");\n-```\n-\n-The parentheses and commas form this two-length tuple. Here's the same code, but\n-with the type annotated:\n-\n-```rust\n-let x: (i32, &str) = (1, \"hello\");\n-```\n-\n-As you can see, the type of a tuple looks just like the tuple, but with each\n-position having a type name rather than the value. Careful readers will also\n-note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n-You have briefly seen `&str` used as a type before, and we'll discuss the\n-details of strings later. In systems programming languages, strings are a bit\n-more complex than in other languages. For now, just read `&str` as a *string\n-slice*, and we'll learn more soon.\n-\n-You can access the fields in a tuple through a *destructuring let*. Here's\n-an example:\n-\n-```rust\n-let (x, y, z) = (1, 2, 3);\n-\n-println!(\"x is {}\", x);\n-```\n-\n-Remember before when I said the left-hand side of a `let` statement was more\n-powerful than just assigning a binding? Here we are. We can put a pattern on\n-the left-hand side of the `let`, and if it matches up to the right-hand side,\n-we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n-or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n-\n-This pattern is very powerful, and we'll see it repeated more later.\n-\n-There are also a few things you can do with a tuple as a whole, without\n-destructuring. You can assign one tuple into another, if they have the same\n-contained types and [arity]. Tuples have the same arity when they have the same\n-length.\n-\n-```rust\n-let mut x = (1, 2); // x: (i32, i32)\n-let y = (2, 3); // y: (i32, i32)\n-\n-x = y;\n-```\n-\n-You can also check for equality with `==`. Again, this will only compile if the\n-tuples have the same type.\n-\n-```rust\n-let x = (1, 2, 3);\n-let y = (2, 2, 4);\n-\n-if x == y {\n-    println!(\"yes\");\n-} else {\n-    println!(\"no\");\n-}\n-```\n-\n-This will print `no`, because some of the values aren't equal.\n-\n-Note that the order of the values is considered when checking for equality,\n-so the following example will also print `no`.\n-\n-```rust\n-let x = (1, 2, 3);\n-let y = (2, 1, 3);\n-\n-if x == y {\n-    println!(\"yes\");\n-} else {\n-    println!(\"no\");\n-}\n-```\n-\n-One other use of tuples is to return multiple values from a function:\n-\n-```rust\n-fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }\n-\n-fn main() {\n-    let (x, y) = next_two(5);\n-    println!(\"x, y = {}, {}\", x, y);\n-}\n-```\n-\n-Even though Rust functions can only return one value, a tuple *is* one value,\n-that happens to be made up of more than one value. You can also see in this\n-example how you can destructure a pattern returned by a function, as well."}]}