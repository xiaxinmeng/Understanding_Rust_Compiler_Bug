{"sha": "8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNWY4ZjkxNmYwMGY3OTg5YTRlYmY3YjdkYmZlMWFmZDYwNWY4Mjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-27T07:38:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-27T07:38:52Z"}, "message": "Auto merge of #67192 - oli-obk:const_zst_addr, r=RalfJung,varkor\n\nVarious const eval and pattern matching ICE fixes\n\nr? @RalfJung\ncc @spastorino\n\nThis PR does not change existing behaviour anymore and just fixes a bunch of ICEs reachable from user code (sometimes even on stable via obscure union transmutes).", "tree": {"sha": "2377f49273a8b0573a56488d1c194048885a4492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2377f49273a8b0573a56488d1c194048885a4492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "html_url": "https://github.com/rust-lang/rust/commit/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a04c789f699a3470edd8cc76d016c68e99cfe4db", "url": "https://api.github.com/repos/rust-lang/rust/commits/a04c789f699a3470edd8cc76d016c68e99cfe4db", "html_url": "https://github.com/rust-lang/rust/commit/a04c789f699a3470edd8cc76d016c68e99cfe4db"}, {"sha": "f65a91eb47453448e27a03eccaad581ebc130d1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f65a91eb47453448e27a03eccaad581ebc130d1a", "html_url": "https://github.com/rust-lang/rust/commit/f65a91eb47453448e27a03eccaad581ebc130d1a"}], "stats": {"total": 251, "additions": 192, "deletions": 59}, "files": [{"sha": "51f0818fe0be114a9e64f3141a012f16d8b21c81", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -432,6 +432,7 @@ pub enum UnsupportedOpInfo<'tcx> {\n     HeapAllocNonPowerOfTwoAlignment(u64),\n     ReadFromReturnPointer,\n     PathNotFound(Vec<String>),\n+    TransmuteSizeDiff(Ty<'tcx>, Ty<'tcx>),\n }\n \n impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n@@ -460,6 +461,11 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                            passing data of type {:?}\",\n                 callee_ty, caller_ty\n             ),\n+            TransmuteSizeDiff(from_ty, to_ty) => write!(\n+                f,\n+                \"tried to transmute from {:?} to {:?}, but their sizes differed\",\n+                from_ty, to_ty\n+            ),\n             FunctionRetMismatch(caller_ty, callee_ty) => write!(\n                 f,\n                 \"tried to call a function with return type {:?} \\"}, {"sha": "93f167cdb9e54cf9b14e830ea41a14818c81447a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -367,8 +367,9 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n+    /// This method is intentionally private, do not make it public.\n     #[inline]\n-    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n+    fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n             Scalar::Raw { data: 0, .. } => throw_unsup!(InvalidNullPointerUsage),\n             Scalar::Raw { .. } => throw_unsup!(ReadBytesAsPointer),\n@@ -544,12 +545,6 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n         }\n     }\n \n-    /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n-    #[inline(always)]\n-    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n-        self.not_undef()?.to_ptr()\n-    }\n-\n     /// Do not call this method!  Use either `assert_bits` or `force_bits`.\n     #[inline(always)]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {"}, {"sha": "120f05ba7d974f8a3ad1277198614d01d78da89f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -537,8 +537,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                         Ok(ConstValue::Scalar(a_val))\n                     } else if let ty::FnPtr(_) = a.ty.kind {\n                         let alloc_map = tcx.alloc_map.lock();\n-                        let a_instance = alloc_map.unwrap_fn(a_val.to_ptr().unwrap().alloc_id);\n-                        let b_instance = alloc_map.unwrap_fn(b_val.to_ptr().unwrap().alloc_id);\n+                        let a_instance = alloc_map.unwrap_fn(a_val.assert_ptr().alloc_id);\n+                        let b_instance = alloc_map.unwrap_fn(b_val.assert_ptr().alloc_id);\n                         if a_instance == b_instance {\n                             Ok(ConstValue::Scalar(a_val))\n                         } else {"}, {"sha": "745b6aabfa6bbd3e474112dcbc1f1b8c9601a457", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -119,7 +119,7 @@ pub(super) fn op_to_const<'tcx>(\n     };\n     let val = match immediate {\n         Ok(mplace) => {\n-            let ptr = mplace.ptr.to_ptr().unwrap();\n+            let ptr = mplace.ptr.assert_ptr();\n             let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n@@ -133,7 +133,7 @@ pub(super) fn op_to_const<'tcx>(\n                 // comes from a constant so it can happen have `Undef`, because the indirect\n                 // memory that was read had undefined bytes.\n                 let mplace = op.assert_mem_place();\n-                let ptr = mplace.ptr.to_ptr().unwrap();\n+                let ptr = mplace.ptr.assert_ptr();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                 ConstValue::ByRef { alloc, offset: ptr.offset }\n             }\n@@ -176,7 +176,7 @@ fn validate_and_turn_into_const<'tcx>(\n         // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n         // whether they become immediates.\n         if is_static || cid.promoted.is_some() {\n-            let ptr = mplace.ptr.to_ptr()?;\n+            let ptr = mplace.ptr.assert_ptr();\n             Ok(tcx.mk_const(ty::Const {\n                 val: ty::ConstKind::Value(ConstValue::ByRef {\n                     alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),"}, {"sha": "c6efbe883327910427f17c396b9f7dac24a7d392", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -252,6 +252,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use arena::TypedArena;\n \n use smallvec::{smallvec, SmallVec};\n+use std::borrow::Cow;\n use std::cmp::{self, max, min, Ordering};\n use std::convert::TryInto;\n use std::fmt;\n@@ -260,11 +261,12 @@ use std::ops::RangeInclusive;\n use std::u128;\n \n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n-    LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat)\n+    LiteralExpander { tcx: cx.tcx, param_env: cx.param_env }.fold_pattern(&pat)\n }\n \n struct LiteralExpander<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl LiteralExpander<'tcx> {\n@@ -284,9 +286,23 @@ impl LiteralExpander<'tcx> {\n         debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n         match (val, &crty.kind, &rty.kind) {\n             // the easy case, deref a reference\n-            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n-                let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n-                ConstValue::ByRef { alloc, offset: p.offset }\n+            (ConstValue::Scalar(p), x, y) if x == y => {\n+                match p {\n+                    Scalar::Ptr(p) => {\n+                        let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n+                        ConstValue::ByRef { alloc, offset: p.offset }\n+                    }\n+                    Scalar::Raw { .. } => {\n+                        let layout = self.tcx.layout_of(self.param_env.and(rty)).unwrap();\n+                        if layout.is_zst() {\n+                            // Deref of a reference to a ZST is a nop.\n+                            ConstValue::Scalar(Scalar::zst())\n+                        } else {\n+                            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;`\n+                            bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty);\n+                        }\n+                    }\n+                }\n             }\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n@@ -2348,16 +2364,30 @@ fn specialize_one_pattern<'p, 'tcx>(\n             // just integers. The only time they should be pointing to memory\n             // is when they are subslices of nonzero slices.\n             let (alloc, offset, n, ty) = match value.ty.kind {\n-                ty::Array(t, n) => match value.val {\n-                    ty::ConstKind::Value(ConstValue::ByRef { offset, alloc, .. }) => {\n-                        (alloc, offset, n.eval_usize(cx.tcx, cx.param_env), t)\n+                ty::Array(t, n) => {\n+                    let n = n.eval_usize(cx.tcx, cx.param_env);\n+                    // Shortcut for `n == 0` where no matter what `alloc` and `offset` we produce,\n+                    // the result would be exactly what we early return here.\n+                    if n == 0 {\n+                        if ctor_wild_subpatterns.len() as u64 == 0 {\n+                            return Some(PatStack::from_slice(&[]));\n+                        } else {\n+                            return None;\n+                        }\n                     }\n-                    _ => span_bug!(pat.span, \"array pattern is {:?}\", value,),\n-                },\n+                    match value.val {\n+                        ty::ConstKind::Value(ConstValue::ByRef { offset, alloc, .. }) => {\n+                            (Cow::Borrowed(alloc), offset, n, t)\n+                        }\n+                        _ => span_bug!(pat.span, \"array pattern is {:?}\", value,),\n+                    }\n+                }\n                 ty::Slice(t) => {\n                     match value.val {\n                         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                            (data, Size::from_bytes(start as u64), (end - start) as u64, t)\n+                            let offset = Size::from_bytes(start as u64);\n+                            let n = (end - start) as u64;\n+                            (Cow::Borrowed(data), offset, n, t)\n                         }\n                         ty::ConstKind::Value(ConstValue::ByRef { .. }) => {\n                             // FIXME(oli-obk): implement `deref` for `ConstValue`"}, {"sha": "6dd3c0f80da243e5ff0eb434c07c4516ebc3e29a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -992,6 +992,12 @@ pub fn compare_const_vals<'tcx>(\n         return fallback();\n     }\n \n+    // Early return for equal constants (so e.g. references to ZSTs can be compared, even if they\n+    // are just integer addresses).\n+    if a.val == b.val {\n+        return from_bool(true);\n+    }\n+\n     let a_bits = a.try_eval_bits(tcx, param_env, ty);\n     let b_bits = b.try_eval_bits(tcx, param_env, ty);\n "}, {"sha": "766ef6ab6feac7627858ae0c60c3cd5b17aef69f", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -20,8 +20,8 @@ use rustc_macros::HashStable;\n use syntax::source_map::{self, Span, DUMMY_SP};\n \n use super::{\n-    Immediate, MPlaceTy, Machine, MemPlace, Memory, Operand, Place, PlaceTy, ScalarMaybeUndef,\n-    StackPopInfo,\n+    Immediate, MPlaceTy, Machine, MemPlace, Memory, OpTy, Operand, Place, PlaceTy,\n+    ScalarMaybeUndef, StackPopInfo,\n };\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -118,7 +118,7 @@ pub struct LocalState<'tcx, Tag = (), Id = AllocId> {\n }\n \n /// Current value of a local variable\n-#[derive(Clone, PartialEq, Eq, Debug, HashStable)] // Miri debug-prints these\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable)] // Miri debug-prints these\n pub enum LocalValue<Tag = (), Id = AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n@@ -743,7 +743,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             trace!(\"deallocating local\");\n-            let ptr = ptr.to_ptr()?;\n+            // All locals have a backing allocation, even if the allocation is empty\n+            // due to the local having ZST type.\n+            let ptr = ptr.assert_ptr();\n             if log_enabled!(::log::Level::Trace) {\n                 self.memory.dump_alloc(ptr.alloc_id);\n             }\n@@ -752,13 +754,33 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n+    pub(super) fn const_eval(\n+        &self,\n+        gid: GlobalId<'tcx>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        let val = if self.tcx.is_static(gid.instance.def_id()) {\n+            self.tcx.const_eval_poly(gid.instance.def_id())?\n+        } else if let Some(promoted) = gid.promoted {\n+            self.tcx.const_eval_promoted(gid.instance, promoted)?\n+        } else {\n+            self.tcx.const_eval_instance(self.param_env, gid.instance, Some(self.tcx.span))?\n+        };\n+        // Even though `ecx.const_eval` is called from `eval_const_to_op` we can never have a\n+        // recursion deeper than one level, because the `tcx.const_eval` above is guaranteed to not\n+        // return `ConstValue::Unevaluated`, which is the only way that `eval_const_to_op` will call\n+        // `ecx.const_eval`.\n+        self.eval_const_to_op(val, None)\n+    }\n+\n     pub fn const_eval_raw(\n         &self,\n         gid: GlobalId<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        // FIXME(oli-obk): make this check an assertion that it's not a static here\n-        // FIXME(RalfJ, oli-obk): document that `Place::Static` can never be anything but a static\n-        // and `ConstValue::Unevaluated` can never be a static\n+        // For statics we pick `ParamEnv::reveal_all`, because statics don't have generics\n+        // and thus don't care about the parameter environment. While we could just use\n+        // `self.param_env`, that would mean we invoke the query to evaluate the static\n+        // with different parameter environments, thus causing the static to be evaluated\n+        // multiple times.\n         let param_env = if self.tcx.is_static(gid.instance.def_id()) {\n             ty::ParamEnv::reveal_all()\n         } else {"}, {"sha": "dffc8e8256c423ece083a25c6baa1b2b8022d309", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -187,14 +187,21 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n         if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n             let mplace = self.ecx.ref_to_mplace(value)?;\n-            // Handle trait object vtables\n+            // Handle trait object vtables.\n             if let ty::Dynamic(..) =\n                 self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n             {\n-                if let Ok(vtable) = mplace.meta.unwrap().to_ptr() {\n-                    // explitly choose `Immutable` here, since vtables are immutable, even\n-                    // if the reference of the fat pointer is mutable\n+                // Validation has already errored on an invalid vtable pointer so we can safely not\n+                // do anything if this is not a real pointer.\n+                if let Scalar::Ptr(vtable) = mplace.meta.unwrap() {\n+                    // Explicitly choose `Immutable` here, since vtables are immutable, even\n+                    // if the reference of the fat pointer is mutable.\n                     self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n+                } else {\n+                    self.ecx().tcx.sess.delay_span_bug(\n+                        syntax_pos::DUMMY_SP,\n+                        \"vtables pointers cannot be integer pointers\",\n+                    );\n                 }\n             }\n             // Check if we have encountered this pointer+layout combination before.\n@@ -280,7 +287,9 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         ecx,\n         leftover_allocations,\n         base_intern_mode,\n-        ret.ptr.to_ptr()?.alloc_id,\n+        // The outermost allocation must exist, because we allocated it with\n+        // `Memory::allocate`.\n+        ret.ptr.assert_ptr().alloc_id,\n         base_mutability,\n         Some(ret.layout.ty),\n     )?;"}, {"sha": "da7cff97ee2c2b1b4804088303ba8e2c5a5d8611", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -5,7 +5,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     self,\n-    interpret::{ConstValue, InterpResult, Scalar},\n+    interpret::{ConstValue, GlobalId, InterpResult, Scalar},\n     BinOp,\n };\n use rustc::ty;\n@@ -118,9 +118,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::size_of\n             | sym::type_id\n             | sym::type_name => {\n-                let val =\n-                    self.tcx.const_eval_instance(self.param_env, instance, Some(self.tcx.span))?;\n-                let val = self.eval_const_to_op(val, None)?;\n+                let gid = GlobalId { instance, promoted: None };\n+                let val = self.const_eval(gid)?;\n                 self.copy_op(val, dest)?;\n             }\n "}, {"sha": "def979b63b52a5206ba3706ef5738f4102a08c05", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -578,7 +578,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Param(_) => throw_inval!(TooGeneric),\n             ty::ConstKind::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                return Ok(OpTy::from(self.const_eval_raw(GlobalId { instance, promoted: None })?));\n+                // We use `const_eval` here and `const_eval_raw` elsewhere in mir interpretation.\n+                // The reason we use `const_eval_raw` everywhere else is to prevent cycles during\n+                // validation, because validation automatically reads through any references, thus\n+                // potentially requiring the current static to be evaluated again. This is not a\n+                // problem here, because we are building an operand which means an actual read is\n+                // happening.\n+                // FIXME(oli-obk): eliminate all the `const_eval_raw` usages when we get rid of\n+                // `StaticKind` once and for all.\n+                return self.const_eval(GlobalId { instance, promoted: None });\n             }\n             ty::ConstKind::Infer(..)\n             | ty::ConstKind::Bound(..)"}, {"sha": "f4ac7de852af00dff61823b7642d02888e421036", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -923,12 +923,14 @@ where\n             return self.copy_op(src, dest);\n         }\n         // We still require the sizes to match.\n-        assert!(\n-            src.layout.size == dest.layout.size,\n-            \"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\",\n-            src,\n-            dest\n-        );\n+        if src.layout.size != dest.layout.size {\n+            // FIXME: This should be an assert instead of an error, but if we transmute within an\n+            // array length computation, `typeck` may not have yet been run and errored out. In fact\n+            // most likey we *are* running `typeck` right now. Investigate whether we can bail out\n+            // on `typeck_tables().has_errors` at all const eval entry points.\n+            debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+            throw_unsup!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));\n+        }\n         // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n         // to avoid that here.\n         assert!(\n@@ -974,31 +976,20 @@ where\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n                 match self.stack[frame].locals[local].access_mut()? {\n-                    Ok(local_val) => {\n+                    Ok(&mut local_val) => {\n                         // We need to make an allocation.\n-                        // FIXME: Consider not doing anything for a ZST, and just returning\n-                        // a fake pointer?  Are we even called for ZST?\n-\n-                        // We cannot hold on to the reference `local_val` while allocating,\n-                        // but we can hold on to the value in there.\n-                        let old_val =\n-                            if let LocalValue::Live(Operand::Immediate(value)) = *local_val {\n-                                Some(value)\n-                            } else {\n-                                None\n-                            };\n \n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n-                        // We also need to support unsized types, and hence cannot use `allocate`.\n                         let local_layout = self.layout_of_local(&self.stack[frame], local, None)?;\n+                        // We also need to support unsized types, and hence cannot use `allocate`.\n                         let (size, align) = self\n                             .size_and_align_of(meta, local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n                         let ptr = self.memory.allocate(size, align, MemoryKind::Stack);\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n-                        if let Some(value) = old_val {\n+                        if let LocalValue::Live(Operand::Immediate(value)) = local_val {\n                             // Preserve old value.\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type."}, {"sha": "ee1e3cc22f77d13e3ff00cb53c4dc019b1041edc", "filename": "src/test/ui/consts/consts-in-patterns.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -1,7 +1,10 @@\n // run-pass\n+#![feature(const_transmute)]\n \n const FOO: isize = 10;\n const BAR: isize = 3;\n+const ZST: &() = unsafe { std::mem::transmute(1usize) };\n+const ZST_ARR: &[u8; 0] = unsafe { std::mem::transmute(1usize) };\n \n const fn foo() -> isize { 4 }\n const BOO: isize = foo();\n@@ -15,4 +18,14 @@ pub fn main() {\n         _ => 3\n     };\n     assert_eq!(y, 2);\n+    let z = match &() {\n+        ZST => 9,\n+        // FIXME: this should not be required\n+        _ => 42,\n+    };\n+    assert_eq!(z, 9);\n+    let z = match b\"\" {\n+        ZST_ARR => 10,\n+    };\n+    assert_eq!(z, 10);\n }"}, {"sha": "df7562bd9f5d212f4391e207f007d9572af6e778", "filename": "src/test/ui/consts/recursive-zst-static.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frecursive-zst-static.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -0,0 +1,7 @@\n+// build-pass\n+\n+static FOO: () = FOO;\n+\n+fn main() {\n+    FOO\n+}"}, {"sha": "b5d2b4396f9a9de08e86e0e831f4da76ed200ae9", "filename": "src/test/ui/consts/transmute-size-mismatch-before-typeck.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.rs?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -0,0 +1,19 @@\n+#![feature(const_transmute)]\n+\n+// normalize-stderr-64bit \"64 bits\" -> \"word size\"\n+// normalize-stderr-32bit \"32 bits\" -> \"word size\"\n+// normalize-stderr-64bit \"128 bits\" -> \"2 * word size\"\n+// normalize-stderr-32bit \"64 bits\" -> \"2 * word size\"\n+\n+fn main() {\n+    match &b\"\"[..] {\n+        ZST => {} //~ ERROR could not evaluate constant pattern\n+    }\n+}\n+\n+const ZST: &[u8] = unsafe { std::mem::transmute(1usize) };\n+//~^ ERROR any use of this value will cause an error\n+//~| ERROR cannot transmute between types of different sizes\n+\n+// Once the `any use of this value will cause an error` disappears in this test, make sure to\n+// remove the `TransmuteSizeDiff` error variant and make its emitter site an assertion again."}, {"sha": "5f84204f4086a7edb85320804d7b4c992c493c39", "filename": "src/test/ui/consts/transmute-size-mismatch-before-typeck.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftransmute-size-mismatch-before-typeck.stderr?ref=8f5f8f916f00f7989a4ebf7b7dbfe1afd605f828", "patch": "@@ -0,0 +1,28 @@\n+error: any use of this value will cause an error\n+  --> $DIR/transmute-size-mismatch-before-typeck.rs:14:29\n+   |\n+LL | const ZST: &[u8] = unsafe { std::mem::transmute(1usize) };\n+   | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                             |\n+   |                             tried to transmute from usize to &[u8], but their sizes differed\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/transmute-size-mismatch-before-typeck.rs:10:9\n+   |\n+LL |         ZST => {}\n+   |         ^^^\n+\n+error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n+  --> $DIR/transmute-size-mismatch-before-typeck.rs:14:29\n+   |\n+LL | const ZST: &[u8] = unsafe { std::mem::transmute(1usize) };\n+   |                             ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: source type: `usize` (word size)\n+   = note: target type: `&'static [u8]` (2 * word size)\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0512`."}]}