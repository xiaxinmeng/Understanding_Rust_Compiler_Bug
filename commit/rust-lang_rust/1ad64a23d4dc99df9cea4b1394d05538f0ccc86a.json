{"sha": "1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "node_id": "C_kwDOAAsO6NoAKDFhZDY0YTIzZDRkYzk5ZGY5Y2VhNGIxMzk0ZDA1NTM4ZjBjY2M4NmE", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-03-23T23:55:22Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-03-24T23:03:54Z"}, "message": "resolve: Rename `CrateLint` to `Finalize`\n\nAnd `crate_lint`/`record_used` to `finalize`", "tree": {"sha": "c3229f20cc4db2c700d7c146367c2ecf452713f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3229f20cc4db2c700d7c146367c2ecf452713f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "html_url": "https://github.com/rust-lang/rust/commit/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74d079d566255e83ccfdb7da9494079a1cf2c086", "url": "https://api.github.com/repos/rust-lang/rust/commits/74d079d566255e83ccfdb7da9494079a1cf2c086", "html_url": "https://github.com/rust-lang/rust/commit/74d079d566255e83ccfdb7da9494079a1cf2c086"}], "stats": {"total": 317, "additions": 147, "deletions": 170}, "files": [{"sha": "34218e87b51a60a0336b18565f2eeb8069956123", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "patch": "@@ -9,7 +9,7 @@ use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n use crate::macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n-use crate::{CrateLint, Determinacy, ExternPreludeEntry, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Determinacy, ExternPreludeEntry, Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{NameBinding, NameBindingKind, ParentScope, PathResult, PerNS, ResolutionError};\n use crate::{Resolver, ResolverArenas, Segment, ToNameBinding, VisResolutionError};\n \n@@ -235,16 +235,16 @@ impl<'a> AsMut<Resolver<'a>> for BuildReducedGraphVisitor<'a, '_> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n-        self.resolve_visibility_speculative(vis, false).unwrap_or_else(|err| {\n+        self.try_resolve_visibility(vis, true).unwrap_or_else(|err| {\n             self.r.report_vis_error(err);\n             ty::Visibility::Public\n         })\n     }\n \n-    fn resolve_visibility_speculative<'ast>(\n+    fn try_resolve_visibility<'ast>(\n         &mut self,\n         vis: &'ast ast::Visibility,\n-        speculative: bool,\n+        finalize: bool,\n     ) -> Result<ty::Visibility, VisResolutionError<'ast>> {\n         let parent_scope = &self.parent_scope;\n         match vis.kind {\n@@ -296,11 +296,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     &segments,\n                     Some(TypeNS),\n                     parent_scope,\n-                    if speculative { CrateLint::No } else { CrateLint::SimplePath(id, path.span) },\n+                    if finalize { Finalize::SimplePath(id, path.span) } else { Finalize::No },\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         let res = module.res().expect(\"visibility resolved to unnamed block\");\n-                        if !speculative {\n+                        if finalize {\n                             self.r.record_partial_res(id, PartialRes::new(res));\n                         }\n                         if module.is_normal() {\n@@ -770,7 +770,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         // correct visibilities for unnamed field placeholders specifically, so the\n                         // constructor visibility should still be determined correctly.\n                         let field_vis = self\n-                            .resolve_visibility_speculative(&field.vis, true)\n+                            .try_resolve_visibility(&field.vis, false)\n                             .unwrap_or(ty::Visibility::Public);\n                         if ctor_vis.is_at_least(field_vis, &*self.r) {\n                             ctor_vis = field_vis;\n@@ -1269,9 +1269,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             let vis = match item.kind {\n                 // Visibilities must not be resolved non-speculatively twice\n                 // and we already resolved this one as a `fn` item visibility.\n-                ItemKind::Fn(..) => self\n-                    .resolve_visibility_speculative(&item.vis, true)\n-                    .unwrap_or(ty::Visibility::Public),\n+                ItemKind::Fn(..) => {\n+                    self.try_resolve_visibility(&item.vis, false).unwrap_or(ty::Visibility::Public)\n+                }\n                 _ => self.resolve_visibility(&item.vis),\n             };\n             if vis != ty::Visibility::Public {"}, {"sha": "d1685006881d5c3aa783b865ec55ce0c54b58a54", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "patch": "@@ -24,10 +24,8 @@ use tracing::debug;\n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{\n-    BindingError, CrateLint, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot,\n-};\n-use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n+use crate::{BindingError, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot};\n+use crate::{Finalize, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -1424,7 +1422,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.r.resolve_path(&path, None, parent_scope, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1443,7 +1441,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.r.resolve_path(&path, None, parent_scope, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1474,7 +1472,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.r.resolve_path(&path, None, parent_scope, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1508,7 +1506,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.r.resolve_path(&path, None, parent_scope, CrateLint::No);\n+            let result = self.r.resolve_path(&path, None, parent_scope, Finalize::No);\n             debug!(\n                 \"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                 name, path, result"}, {"sha": "4f0dad13b5bbeed1540b9d0d3d3ac59ab05ed967", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "patch": "@@ -6,7 +6,7 @@ use crate::Namespace::{self, MacroNS, TypeNS};\n use crate::{module_to_string, names_to_string};\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n-use crate::{CrateLint, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet, Weak};\n+use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet, Weak};\n use crate::{NameBinding, NameBindingKind, PathResult, PrivacyError, ToNameBinding};\n \n use rustc_ast::NodeId;\n@@ -175,29 +175,29 @@ impl<'a> Resolver<'a> {\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: Option<Span>,\n+        finalize: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.resolve_ident_in_module_unadjusted_ext(\n             module,\n             ident,\n             ns,\n             parent_scope,\n             false,\n-            record_used,\n+            finalize,\n         )\n         .map_err(|(determinacy, _)| determinacy)\n     }\n \n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n-    /// Invariant: if `record_used` is `Some`, expansion and import resolution must be complete.\n+    /// Invariant: if `finalize` is `Some`, expansion and import resolution must be complete.\n     crate fn resolve_ident_in_module_unadjusted_ext(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n         restricted_shadowing: bool,\n-        record_used: Option<Span>,\n+        finalize: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n@@ -207,17 +207,16 @@ impl<'a> Resolver<'a> {\n                     ident,\n                     ScopeSet::AbsolutePath(ns),\n                     parent_scope,\n-                    record_used,\n-                    record_used.is_some(),\n+                    finalize,\n+                    finalize.is_some(),\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n                 assert!(!restricted_shadowing);\n                 return if ns != TypeNS {\n                     Err((Determined, Weak::No))\n-                } else if let Some(binding) = self.extern_prelude_get(ident, record_used.is_none())\n-                {\n+                } else if let Some(binding) = self.extern_prelude_get(ident, finalize.is_some()) {\n                     Ok(binding)\n                 } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n                     // Macro-expanded `extern crate` items can add names to extern prelude.\n@@ -247,8 +246,8 @@ impl<'a> Resolver<'a> {\n                     ident,\n                     scopes,\n                     parent_scope,\n-                    record_used,\n-                    record_used.is_some(),\n+                    finalize,\n+                    finalize.is_some(),\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n@@ -258,7 +257,7 @@ impl<'a> Resolver<'a> {\n         let resolution =\n             self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n-        if let Some(binding) = resolution.binding && let Some(path_span) = record_used {\n+        if let Some(binding) = resolution.binding && let Some(path_span) = finalize {\n             if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n                 if let NameBindingKind::Res(_, true) = binding.kind {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n@@ -276,7 +275,7 @@ impl<'a> Resolver<'a> {\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n         };\n \n-        if let Some(path_span) = record_used {\n+        if let Some(path_span) = finalize {\n             return resolution\n                 .binding\n                 .and_then(|binding| {\n@@ -773,7 +772,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // not define any names while resolving its module path.\n             let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n             let path_res =\n-                self.r.resolve_path(&import.module_path, None, &import.parent_scope, CrateLint::No);\n+                self.r.resolve_path(&import.module_path, None, &import.parent_scope, Finalize::No);\n             import.vis.set(orig_vis);\n \n             match path_res {\n@@ -865,13 +864,13 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             _ => None,\n         };\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n-        let crate_lint = CrateLint::UsePath {\n+        let finalize = Finalize::UsePath {\n             root_id: import.root_id,\n             root_span: import.root_span,\n             path_span: import.span,\n         };\n         let path_res =\n-            self.r.resolve_path(&import.module_path, None, &import.parent_scope, crate_lint);\n+            self.r.resolve_path(&import.module_path, None, &import.parent_scope, finalize);\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         if let Some(orig_unusable_binding) = orig_unusable_binding {\n             self.r.unusable_binding = orig_unusable_binding;\n@@ -958,7 +957,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = import.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::empty()));\n-                    self.r.lint_if_path_starts_with_module(crate_lint, &full_path, None);\n+                    self.r.lint_if_path_starts_with_module(finalize, &full_path, None);\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n@@ -1223,7 +1222,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             full_path.push(Segment::from_ident(ident));\n             self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n-                    this.lint_if_path_starts_with_module(crate_lint, &full_path, Some(binding));\n+                    this.lint_if_path_starts_with_module(finalize, &full_path, Some(binding));\n                 }\n             });\n         }"}, {"sha": "bb05a3d7510e1f465046237c2d280f6a839253e5", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "patch": "@@ -7,7 +7,7 @@\n \n use RibKind::*;\n \n-use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n+use crate::{path_names_to_string, BindingError, Finalize, LexicalScopeBinding};\n use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n@@ -486,7 +486,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     .resolve_ident_in_lexical_scope(\n                         self_ty,\n                         TypeNS,\n-                        CrateLint::SimplePath(ty.id, ty.span),\n+                        Finalize::SimplePath(ty.id, ty.span),\n                     )\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n@@ -679,7 +679,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             self.resolve_ident_in_lexical_scope(\n                                 path.segments[0].ident,\n                                 ns,\n-                                CrateLint::No,\n+                                Finalize::No,\n                             )\n                             .is_some()\n                         };\n@@ -754,13 +754,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         ident: Ident,\n         ns: Namespace,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         self.r.resolve_ident_in_lexical_scope(\n             ident,\n             ns,\n             &self.parent_scope,\n-            crate_lint,\n+            finalize,\n             &self.ribs[ns],\n         )\n     }\n@@ -769,15 +769,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> PathResult<'a> {\n-        self.r.resolve_path_with_ribs(\n-            path,\n-            opt_ns,\n-            &self.parent_scope,\n-            crate_lint,\n-            Some(&self.ribs),\n-        )\n+        self.r.resolve_path_with_ribs(path, opt_ns, &self.parent_scope, finalize, Some(&self.ribs))\n     }\n \n     // AST resolution\n@@ -940,15 +934,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n             for &ns in nss {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, CrateLint::No) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No) {\n                     Some(LexicalScopeBinding::Res(..)) => {\n                         report_error(self, ns);\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n                         let orig_unusable_binding =\n                             replace(&mut self.r.unusable_binding, Some(binding));\n                         if let Some(LexicalScopeBinding::Res(..)) =\n-                            self.resolve_ident_in_lexical_scope(ident, ns, CrateLint::No)\n+                            self.resolve_ident_in_lexical_scope(ident, ns, Finalize::No)\n                         {\n                             report_error(self, ns);\n                         }\n@@ -1246,7 +1240,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 None,\n                 &path,\n                 PathSource::Trait(AliasPossibility::No),\n-                CrateLint::SimplePath(trait_ref.ref_id, trait_ref.path.span),\n+                Finalize::SimplePath(trait_ref.ref_id, trait_ref.path.span),\n             );\n             if let Some(def_id) = res.base_res().opt_def_id() {\n                 new_id = Some(def_id);\n@@ -1808,7 +1802,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n-        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, CrateLint::No)?;\n+        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No)?;\n         let (res, binding) = match ls_binding {\n             LexicalScopeBinding::Item(binding)\n                 if is_syntactic_ambiguity && binding.is_ambiguity() =>\n@@ -1900,7 +1894,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             qself,\n             &Segment::from_path(path),\n             source,\n-            CrateLint::SimplePath(id, path.span),\n+            Finalize::SimplePath(id, path.span),\n         );\n     }\n \n@@ -1909,18 +1903,18 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         qself: Option<&QSelf>,\n         path: &[Segment],\n         source: PathSource<'ast>,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> PartialRes {\n         tracing::debug!(\n-            \"smart_resolve_path_fragment(qself={:?}, path={:?}, crate_lint={:?})\",\n+            \"smart_resolve_path_fragment(qself={:?}, path={:?}, finalize={:?})\",\n             qself,\n             path,\n-            crate_lint,\n+            finalize,\n         );\n         let ns = source.namespace();\n \n         let (id, path_span) =\n-            crate_lint.node_id_and_path_span().expect(\"unexpected speculative resolution\");\n+            finalize.node_id_and_path_span().expect(\"unexpected speculative resolution\");\n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             if this.should_report_errs() {\n                 let (err, candidates) =\n@@ -2016,7 +2010,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ns,\n             path_span,\n             source.defer_to_typeck(),\n-            crate_lint,\n+            finalize,\n         ) {\n             Ok(Some(partial_res)) if partial_res.unresolved_segments() == 0 => {\n                 if source.is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err\n@@ -2043,7 +2037,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     std_path.push(Segment::from_ident(Ident::with_dummy_span(sym::std)));\n                     std_path.extend(path);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n-                        self.resolve_path(&std_path, Some(ns), CrateLint::No)\n+                        self.resolve_path(&std_path, Some(ns), Finalize::No)\n                     {\n                         // Check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n                         let item_span =\n@@ -2080,14 +2074,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let binding = self.resolve_ident_in_lexical_scope(\n             Ident::with_dummy_span(kw::SelfUpper),\n             TypeNS,\n-            CrateLint::No,\n+            Finalize::No,\n         );\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span) -> bool {\n         let ident = Ident::new(kw::SelfLower, self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, CrateLint::No);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, Finalize::No);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n@@ -2114,13 +2108,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         primary_ns: Namespace,\n         span: Span,\n         defer_to_typeck: bool,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         let mut fin_res = None;\n \n         for (i, &ns) in [primary_ns, TypeNS, ValueNS].iter().enumerate() {\n             if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(qself, path, ns, crate_lint)? {\n+                match self.resolve_qpath(qself, path, ns, finalize)? {\n                     Some(partial_res)\n                         if partial_res.unresolved_segments() == 0 || defer_to_typeck =>\n                     {\n@@ -2156,11 +2150,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         qself: Option<&QSelf>,\n         path: &[Segment],\n         ns: Namespace,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         debug!(\n-            \"resolve_qpath(qself={:?}, path={:?}, ns={:?}, crate_lint={:?})\",\n-            qself, path, ns, crate_lint,\n+            \"resolve_qpath(qself={:?}, path={:?}, ns={:?}, finalize={:?})\",\n+            qself, path, ns, finalize,\n         );\n \n         if let Some(qself) = qself {\n@@ -2187,20 +2181,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // *actually* appears, so for the purposes of the crate\n             // lint we pass along information that this is the trait\n             // name from a fully qualified path, and this also\n-            // contains the full span (the `CrateLint::QPathTrait`).\n+            // contains the full span (the `Finalize::QPathTrait`).\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let partial_res = self.smart_resolve_path_fragment(\n                 None,\n                 &path[..=qself.position],\n                 PathSource::TraitItem(ns),\n-                crate_lint.node_id_and_path_span().map_or(\n-                    CrateLint::No,\n-                    |(qpath_id, path_span)| CrateLint::QPathTrait {\n-                        qpath_id,\n-                        qpath_span: qself.path_span,\n-                        path_span,\n-                    },\n-                ),\n+                finalize.node_id_and_path_span().map_or(Finalize::No, |(qpath_id, path_span)| {\n+                    Finalize::QPathTrait { qpath_id, qpath_span: qself.path_span, path_span }\n+                }),\n             );\n \n             // The remaining segments (the `C` in our example) will\n@@ -2212,7 +2201,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             )));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), crate_lint) {\n+        let result = match self.resolve_path(&path, Some(ns), finalize) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n                 PartialRes::new(module.res().unwrap())\n@@ -2250,10 +2239,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             && result.base_res() != Res::Err\n             && path[0].ident.name != kw::PathRoot\n             && path[0].ident.name != kw::DollarCrate\n-            && let Some((id, path_span)) = crate_lint.node_id_and_path_span()\n+            && let Some((id, path_span)) = finalize.node_id_and_path_span()\n         {\n             let unqualified_result = {\n-                match self.resolve_path(&[*path.last().unwrap()], Some(ns), CrateLint::No) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), Finalize::No) {\n                     PathResult::NonModule(path_res) => path_res.base_res(),\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         module.res().unwrap()"}, {"sha": "038ba2206086e5e3e01a1b69a1602bd4018329e0", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "patch": "@@ -2,7 +2,7 @@ use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n use crate::path_names_to_string;\n-use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n use rustc_ast::visit::FnKind;\n@@ -187,7 +187,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 (String::new(), \"the crate root\".to_string())\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n-                let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), CrateLint::No) {\n+                let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), Finalize::No) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n                     _ => None,\n                 }\n@@ -646,7 +646,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         if let crate::PathSource::TraitItem(_) = source {\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                self.resolve_path(mod_path, None, CrateLint::No)\n+                self.resolve_path(mod_path, None, Finalize::No)\n             {\n                 let resolutions = self.r.resolutions(module).borrow();\n                 let targets: Vec<_> =\n@@ -702,7 +702,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 Namespace::TypeNS,\n                 span,\n                 true,\n-                CrateLint::No,\n+                Finalize::No,\n             ) else {\n                 return false;\n             };\n@@ -726,7 +726,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 Namespace::TypeNS,\n                 span,\n                 true,\n-                CrateLint::No,\n+                Finalize::No,\n             ) else {\n                 return false;\n             };\n@@ -1378,7 +1378,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                self.resolve_path(mod_path, Some(TypeNS), CrateLint::No)\n+                self.resolve_path(mod_path, Some(TypeNS), Finalize::No)\n             {\n                 self.r.add_module_candidates(module, &mut names, &filter_fn);\n             }"}, {"sha": "19eeae4cf233ba238c386074af156becf4350707", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 66, "deletions": 75, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "patch": "@@ -454,11 +454,11 @@ impl<'a> PathResult<'a> {\n     fn failed(\n         span: Span,\n         is_error_from_last_segment: bool,\n-        record_used: bool,\n+        finalize: bool,\n         label_and_suggestion: impl FnOnce() -> (String, Option<Suggestion>),\n     ) -> PathResult<'a> {\n         let (label, suggestion) =\n-            if record_used { label_and_suggestion() } else { (String::new(), None) };\n+            if finalize { label_and_suggestion() } else { (String::new(), None) };\n         PathResult::Failed { span, label, suggestion, is_error_from_last_segment }\n     }\n }\n@@ -1950,7 +1950,7 @@ impl<'a> Resolver<'a> {\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        crate_lint: CrateLint,\n+        finalize_full: Finalize,\n         ribs: &[Rib<'a>],\n     ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n@@ -1972,7 +1972,7 @@ impl<'a> Resolver<'a> {\n         let normalized_ident = Ident { span: normalized_span, ..ident };\n \n         // Walk backwards up the ribs in scope.\n-        let record_used = crate_lint.path_span();\n+        let finalize = finalize_full.path_span();\n         let mut module = self.graph_root;\n         for i in (0..ribs.len()).rev() {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n@@ -1986,7 +1986,7 @@ impl<'a> Resolver<'a> {\n                     i,\n                     rib_ident,\n                     *res,\n-                    record_used,\n+                    finalize,\n                     *original_rib_ident_def,\n                     ribs,\n                 )));\n@@ -2013,7 +2013,7 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ns,\n                 parent_scope,\n-                record_used,\n+                finalize,\n             );\n             if let Ok(binding) = item {\n                 // The ident resolves to an item.\n@@ -2022,10 +2022,10 @@ impl<'a> Resolver<'a> {\n         }\n         self.early_resolve_ident_in_lexical_scope(\n             orig_ident,\n-            ScopeSet::Late(ns, module, crate_lint.node_id()),\n+            ScopeSet::Late(ns, module, finalize_full.node_id()),\n             parent_scope,\n-            record_used,\n-            record_used.is_some(),\n+            finalize,\n+            finalize.is_some(),\n         )\n         .ok()\n         .map(LexicalScopeBinding::Item)\n@@ -2085,9 +2085,9 @@ impl<'a> Resolver<'a> {\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: Option<Span>,\n+        finalize: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, record_used)\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize)\n             .map_err(|(determinacy, _)| determinacy)\n     }\n \n@@ -2097,7 +2097,7 @@ impl<'a> Resolver<'a> {\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: Option<Span>,\n+        finalize: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let tmp_parent_scope;\n         let mut adjusted_parent_scope = parent_scope;\n@@ -2122,7 +2122,7 @@ impl<'a> Resolver<'a> {\n             ns,\n             adjusted_parent_scope,\n             false,\n-            record_used,\n+            finalize,\n         )\n     }\n \n@@ -2213,30 +2213,30 @@ impl<'a> Resolver<'a> {\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(path, opt_ns, parent_scope, crate_lint, None)\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None)\n     }\n \n     fn resolve_path_with_ribs(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        crate_lint: CrateLint,\n+        finalize_full: Finalize,\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n     ) -> PathResult<'a> {\n-        debug!(\"resolve_path(path={:?}, opt_ns={:?}, crate_lint={:?})\", path, opt_ns, crate_lint);\n+        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n \n-        let record_used = crate_lint.path_span();\n+        let finalize = finalize_full.path_span();\n         let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n         for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n             let record_segment_res = |this: &mut Self, res| {\n-                if record_used.is_some() {\n+                if finalize.is_some() {\n                     if let Some(id) = id {\n                         if !this.partial_res_map.contains_key(&id) {\n                             assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n@@ -2270,7 +2270,7 @@ impl<'a> Resolver<'a> {\n                             continue;\n                         }\n                     }\n-                    return PathResult::failed(ident.span, false, record_used.is_some(), || {\n+                    return PathResult::failed(ident.span, false, finalize.is_some(), || {\n                         (\"there are too many leading `super` keywords\".to_string(), None)\n                     });\n                 }\n@@ -2301,7 +2301,7 @@ impl<'a> Resolver<'a> {\n \n             // Report special messages for path segment keywords in wrong positions.\n             if ident.is_path_segment_keyword() && i != 0 {\n-                return PathResult::failed(ident.span, false, record_used.is_some(), || {\n+                return PathResult::failed(ident.span, false, finalize.is_some(), || {\n                     let name_str = if name == kw::PathRoot {\n                         \"crate root\".to_string()\n                     } else {\n@@ -2322,22 +2322,22 @@ impl<'a> Resolver<'a> {\n             }\n             let find_binding_in_ns = |this: &mut Self, ns| {\n                 let binding = if let Some(module) = module {\n-                    this.resolve_ident_in_module(module, ident, ns, parent_scope, record_used)\n+                    this.resolve_ident_in_module(module, ident, ns, parent_scope, finalize)\n                 } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                     let scopes = ScopeSet::All(ns, opt_ns.is_none());\n                     this.early_resolve_ident_in_lexical_scope(\n                         ident,\n                         scopes,\n                         parent_scope,\n-                        record_used,\n-                        record_used.is_some(),\n+                        finalize,\n+                        finalize.is_some(),\n                     )\n                 } else {\n                     match this.resolve_ident_in_lexical_scope(\n                         ident,\n                         ns,\n                         parent_scope,\n-                        crate_lint,\n+                        finalize_full,\n                         &ribs.unwrap()[ns],\n                     ) {\n                         // we found a locally-imported or available item/module\n@@ -2351,7 +2351,7 @@ impl<'a> Resolver<'a> {\n                                 PartialRes::with_unresolved_segments(res, path.len() - 1),\n                             ));\n                         }\n-                        _ => Err(Determinacy::determined(record_used.is_some())),\n+                        _ => Err(Determinacy::determined(finalize.is_some())),\n                     }\n                 };\n                 FindBindingResult::Binding(binding)\n@@ -2385,25 +2385,20 @@ impl<'a> Resolver<'a> {\n                     } else if res == Res::Err {\n                         return PathResult::NonModule(PartialRes::new(Res::Err));\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        self.lint_if_path_starts_with_module(crate_lint, path, second_binding);\n+                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n                         return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res,\n                             path.len() - i - 1,\n                         ));\n                     } else {\n-                        return PathResult::failed(\n-                            ident.span,\n-                            is_last,\n-                            record_used.is_some(),\n-                            || {\n-                                let label = format!(\n-                                    \"`{ident}` is {} {}, not a module\",\n-                                    res.article(),\n-                                    res.descr()\n-                                );\n-                                (label, None)\n-                            },\n-                        );\n+                        return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n+                            let label = format!(\n+                                \"`{ident}` is {} {}, not a module\",\n+                                res.article(),\n+                                res.descr()\n+                            );\n+                            (label, None)\n+                        });\n                     }\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n@@ -2417,7 +2412,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n \n-                    return PathResult::failed(ident.span, is_last, record_used.is_some(), || {\n+                    return PathResult::failed(ident.span, is_last, finalize.is_some(), || {\n                         let module_res = match module {\n                             Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n                             _ => None,\n@@ -2457,7 +2452,7 @@ impl<'a> Resolver<'a> {\n                                         ident,\n                                         ValueNS,\n                                         parent_scope,\n-                                        CrateLint::No,\n+                                        Finalize::No,\n                                         &ribs.unwrap()[ValueNS],\n                                     ) {\n                                         // Name matches a local variable. For example:\n@@ -2582,7 +2577,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        self.lint_if_path_starts_with_module(crate_lint, path, second_binding);\n+        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n \n         PathResult::Module(match module {\n             Some(module) => module,\n@@ -2593,15 +2588,15 @@ impl<'a> Resolver<'a> {\n \n     fn lint_if_path_starts_with_module(\n         &mut self,\n-        crate_lint: CrateLint,\n+        finalize: Finalize,\n         path: &[Segment],\n         second_binding: Option<&NameBinding<'_>>,\n     ) {\n-        let (diag_id, diag_span) = match crate_lint {\n-            CrateLint::No => return,\n-            CrateLint::SimplePath(id, path_span) => (id, path_span),\n-            CrateLint::UsePath { root_id, root_span, .. } => (root_id, root_span),\n-            CrateLint::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n+        let (diag_id, diag_span) = match finalize {\n+            Finalize::No => return,\n+            Finalize::SimplePath(id, path_span) => (id, path_span),\n+            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n+            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n         };\n \n         let first_name = match path.get(0) {\n@@ -2656,7 +2651,7 @@ impl<'a> Resolver<'a> {\n         rib_index: usize,\n         rib_ident: Ident,\n         mut res: Res,\n-        record_used: Option<Span>,\n+        finalize: Option<Span>,\n         original_rib_ident_def: Ident,\n         all_ribs: &[Rib<'a>],\n     ) -> Res {\n@@ -2666,7 +2661,7 @@ impl<'a> Resolver<'a> {\n \n         // An invalid forward use of a generic parameter from a previous default.\n         if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n-            if let Some(span) = record_used {\n+            if let Some(span) = finalize {\n                 let res_error = if rib_ident.name == kw::SelfUpper {\n                     ResolutionError::SelfInGenericParamDefault\n                 } else {\n@@ -2696,7 +2691,7 @@ impl<'a> Resolver<'a> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-                            if let Some(span) = record_used {\n+                            if let Some(span) = finalize {\n                                 // We don't immediately trigger a resolve error, because\n                                 // we want certain other resolution errors (namely those\n                                 // emitted for `ConstantItemRibKind` below) to take\n@@ -2706,7 +2701,7 @@ impl<'a> Resolver<'a> {\n                         }\n                         ConstantItemRibKind(_, item) => {\n                             // Still doesn't deal with upvars\n-                            if let Some(span) = record_used {\n+                            if let Some(span) = finalize {\n                                 let (span, resolution_error) =\n                                     if let Some((ident, constant_item_kind)) = item {\n                                         let kind_str = match constant_item_kind {\n@@ -2734,7 +2729,7 @@ impl<'a> Resolver<'a> {\n                             return Res::Err;\n                         }\n                         ConstParamTyRibKind => {\n-                            if let Some(span) = record_used {\n+                            if let Some(span) = finalize {\n                                 self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n                             }\n                             return Res::Err;\n@@ -2769,7 +2764,7 @@ impl<'a> Resolver<'a> {\n                                 if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n                                     res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n                                 } else {\n-                                    if let Some(span) = record_used {\n+                                    if let Some(span) = finalize {\n                                         self.report_error(\n                                             span,\n                                             ResolutionError::ParamInNonTrivialAnonConst {\n@@ -2791,7 +2786,7 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind(has_generic_params) => has_generic_params,\n                         FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n-                            if let Some(span) = record_used {\n+                            if let Some(span) = finalize {\n                                 self.report_error(\n                                     span,\n                                     ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n@@ -2801,7 +2796,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     };\n \n-                    if let Some(span) = record_used {\n+                    if let Some(span) = finalize {\n                         self.report_error(\n                             span,\n                             ResolutionError::GenericParamsFromOuterFunction(\n@@ -2835,7 +2830,7 @@ impl<'a> Resolver<'a> {\n                             let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial || features.generic_const_exprs) {\n-                                if let Some(span) = record_used {\n+                                if let Some(span) = finalize {\n                                     self.report_error(\n                                         span,\n                                         ResolutionError::ParamInNonTrivialAnonConst {\n@@ -2855,7 +2850,7 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind(has_generic_params) => has_generic_params,\n                         FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n-                            if let Some(span) = record_used {\n+                            if let Some(span) = finalize {\n                                 self.report_error(\n                                     span,\n                                     ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n@@ -2866,7 +2861,7 @@ impl<'a> Resolver<'a> {\n                     };\n \n                     // This was an attempt to use a const parameter outside its scope.\n-                    if let Some(span) = record_used {\n+                    if let Some(span) = finalize {\n                         self.report_error(\n                             span,\n                             ResolutionError::GenericParamsFromOuterFunction(\n@@ -3254,23 +3249,19 @@ impl<'a> Resolver<'a> {\n         err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n     }\n \n-    fn extern_prelude_get(\n-        &mut self,\n-        ident: Ident,\n-        speculative: bool,\n-    ) -> Option<&'a NameBinding<'a>> {\n+    fn extern_prelude_get(&mut self, ident: Ident, finalize: bool) -> Option<&'a NameBinding<'a>> {\n         if ident.is_path_segment_keyword() {\n             // Make sure `self`, `super` etc produce an error when passed to here.\n             return None;\n         }\n         self.extern_prelude.get(&ident.normalize_to_macros_2_0()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n-                if !speculative && entry.introduced_by_item {\n+                if finalize && entry.introduced_by_item {\n                     self.record_use(ident, binding, false);\n                 }\n                 Some(binding)\n             } else {\n-                let crate_id = if !speculative {\n+                let crate_id = if finalize {\n                     let Some(crate_id) =\n                         self.crate_loader.process_path_extern(ident.name, ident.span) else { return Some(self.dummy_binding); };\n                     crate_id\n@@ -3307,7 +3298,7 @@ impl<'a> Resolver<'a> {\n             &segments,\n             Some(ns),\n             &ParentScope::module(module, self),\n-            CrateLint::No,\n+            Finalize::No,\n         ) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n@@ -3458,8 +3449,8 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n     Some(names_to_string(&names))\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-enum CrateLint {\n+#[derive(Copy, Clone, Debug)]\n+enum Finalize {\n     /// Do not issue the lint.\n     No,\n \n@@ -3479,13 +3470,13 @@ enum CrateLint {\n     QPathTrait { qpath_id: NodeId, qpath_span: Span, path_span: Span },\n }\n \n-impl CrateLint {\n+impl Finalize {\n     fn node_id_and_path_span(&self) -> Option<(NodeId, Span)> {\n         match *self {\n-            CrateLint::No => None,\n-            CrateLint::SimplePath(id, path_span)\n-            | CrateLint::UsePath { root_id: id, path_span, .. }\n-            | CrateLint::QPathTrait { qpath_id: id, path_span, .. } => Some((id, path_span)),\n+            Finalize::No => None,\n+            Finalize::SimplePath(id, path_span)\n+            | Finalize::UsePath { root_id: id, path_span, .. }\n+            | Finalize::QPathTrait { qpath_id: id, path_span, .. } => Some((id, path_span)),\n         }\n     }\n "}, {"sha": "dc94ba49a5400b7b64640229519bb37dc942e880", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad64a23d4dc99df9cea4b1394d05538f0ccc86a/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=1ad64a23d4dc99df9cea4b1394d05538f0ccc86a", "patch": "@@ -4,7 +4,7 @@\n use crate::imports::ImportResolver;\n use crate::Namespace::*;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BuiltinMacroState, Determinacy};\n-use crate::{CrateLint, DeriveData, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n+use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n@@ -415,7 +415,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n         let mut indeterminate = false;\n         for ns in [TypeNS, ValueNS, MacroNS].iter().copied() {\n-            match self.resolve_path(path, Some(ns), &parent_scope, CrateLint::No) {\n+            match self.resolve_path(path, Some(ns), &parent_scope, Finalize::No) {\n                 PathResult::Module(ModuleOrUniformRoot::Module(_)) => return Ok(true),\n                 PathResult::NonModule(partial_res) if partial_res.unresolved_segments() == 0 => {\n                     return Ok(true);\n@@ -575,7 +575,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let res = if path.len() > 1 {\n-            let res = match self.resolve_path(&path, Some(MacroNS), parent_scope, CrateLint::No) {\n+            let res = match self.resolve_path(&path, Some(MacroNS), parent_scope, Finalize::No) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     Ok(path_res.base_res())\n                 }\n@@ -640,7 +640,7 @@ impl<'a> Resolver<'a> {\n         orig_ident: Ident,\n         scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n-        record_used: Option<Span>,\n+        finalize: Option<Span>,\n         force: bool,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         bitflags::bitflags! {\n@@ -653,7 +653,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        assert!(force || !record_used.is_some()); // `record_used` implies `force`\n+        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n         if orig_ident.is_path_segment_keyword() {\n@@ -760,7 +760,7 @@ impl<'a> Resolver<'a> {\n                             ident,\n                             ns,\n                             parent_scope,\n-                            record_used,\n+                            finalize,\n                         );\n                         match binding {\n                             Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n@@ -781,7 +781,7 @@ impl<'a> Resolver<'a> {\n                             ns,\n                             adjusted_parent_scope,\n                             !matches!(scope_set, ScopeSet::Late(..)),\n-                            record_used,\n+                            finalize,\n                         );\n                         match binding {\n                             Ok(binding) => {\n@@ -846,7 +846,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n                     Scope::ExternPrelude => {\n-                        match this.extern_prelude_get(ident, record_used.is_none()) {\n+                        match this.extern_prelude_get(ident, finalize.is_some()) {\n                             Some(binding) => Ok((binding, Flags::empty())),\n                             None => Err(Determinacy::determined(\n                                 this.graph_root.unexpanded_invocations.borrow().is_empty(),\n@@ -884,7 +884,7 @@ impl<'a> Resolver<'a> {\n                     Ok((binding, flags))\n                         if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n                     {\n-                        if record_used.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n+                        if finalize.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n                             return Some(Ok(binding));\n                         }\n \n@@ -1023,7 +1023,7 @@ impl<'a> Resolver<'a> {\n                 &path,\n                 Some(MacroNS),\n                 &parent_scope,\n-                CrateLint::SimplePath(ast::CRATE_NODE_ID, path_span),\n+                Finalize::SimplePath(ast::CRATE_NODE_ID, path_span),\n             ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     let res = path_res.base_res();"}]}