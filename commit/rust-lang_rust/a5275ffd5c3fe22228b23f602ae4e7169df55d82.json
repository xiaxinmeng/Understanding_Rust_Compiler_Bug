{"sha": "a5275ffd5c3fe22228b23f602ae4e7169df55d82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1Mjc1ZmZkNWMzZmUyMjIyOGIyM2Y2MDJhZTRlNzE2OWRmNTVkODI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T17:14:15Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T17:14:15Z"}, "message": "std: whitespace clean up io::file docs", "tree": {"sha": "8ab7ffccbe8615c55eb5b249702a40efe6555994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ab7ffccbe8615c55eb5b249702a40efe6555994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5275ffd5c3fe22228b23f602ae4e7169df55d82", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5275ffd5c3fe22228b23f602ae4e7169df55d82", "html_url": "https://github.com/rust-lang/rust/commit/a5275ffd5c3fe22228b23f602ae4e7169df55d82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5275ffd5c3fe22228b23f602ae4e7169df55d82/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d9932fddba27572b0aeb1424b014cd21a5cf28e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9932fddba27572b0aeb1424b014cd21a5cf28e", "html_url": "https://github.com/rust-lang/rust/commit/5d9932fddba27572b0aeb1424b014cd21a5cf28e"}], "stats": {"total": 104, "additions": 52, "deletions": 52}, "files": [{"sha": "a884961fd1e0de77d2155988ee3cdaabc19bbd1a", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a5275ffd5c3fe22228b23f602ae4e7169df55d82/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5275ffd5c3fe22228b23f602ae4e7169df55d82/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=a5275ffd5c3fe22228b23f602ae4e7169df55d82", "patch": "@@ -45,17 +45,17 @@ use path::Path;\n use super::super::test::*;\n \n /// Open a file for reading/writing, as indicated by `path`.\n-/// \n+///\n /// # Example\n-/// \n+///\n ///     use std;\n ///     use std::path::Path;\n ///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::open;\n ///     use std::rt::io::{FileMode, FileAccess};\n-/// \n+///\n ///     let p = &Path(\"/some/file/path.txt\");\n-///     \n+///\n ///     do io_error::cond.trap(|_| {\n ///         // hoo-boy...\n ///     }).inside {\n@@ -64,26 +64,26 @@ use super::super::test::*;\n ///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n ///         }\n ///         // do some stuff with that stream\n-/// \n+///\n ///         // the file stream will be closed at the end of this block\n ///     }\n ///     // ..\n-/// \n+///\n /// `FileMode` and `FileAccess` provide information about the permissions\n /// context in which a given stream is created. More information about them\n /// can be found in `std::rt::io`'s docs.\n-/// \n+///\n /// Note that, with this function, a `FileStream` is returned regardless of\n /// the access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n /// `FileStream` opened as `ReadOnly` will raise an `io_error` condition at runtime). If you\n /// desire a more-correctly-constrained interface to files, use the\n /// `{open_stream, open_reader, open_writer}` methods that are a part of `FileInfo`\n-/// \n+///\n /// # Errors\n-/// \n+///\n /// This function will raise an `io_error` condition under a number of different circumstances,\n /// to include but not limited to:\n-/// \n+///\n /// * Opening a file that already exists with `FileMode` of `Create` or vice versa (e.g.\n ///   opening a non-existant file with `FileMode` or `Open`)\n /// * Attempting to open a file with a `FileAccess` that the user lacks permissions\n@@ -110,25 +110,25 @@ pub fn open<P: PathLike>(path: &P,\n }\n \n /// Unlink a file from the underlying filesystem.\n-/// \n+///\n /// # Example\n-/// \n+///\n ///     use std;\n ///     use std::path::Path;\n ///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::unlink;\n-/// \n+///\n ///     let p = &Path(\"/some/file/path.txt\");\n ///     unlink(p);\n ///     // if we made it here without failing, then the\n ///     // unlink operation was successful\n-/// \n+///\n /// Note that, just because an unlink call was successful, it is not\n /// guaranteed that a file is immediately deleted (e.g. depending on\n /// platform, other open file descriptors may prevent immediate removal)\n-/// \n+///\n /// # Errors\n-/// \n+///\n /// This function will raise an `io_error` condition if the user lacks permissions to\n /// remove the file or if some other filesystem-level error occurs\n pub fn unlink<P: PathLike>(path: &P) {\n@@ -145,20 +145,20 @@ pub fn unlink<P: PathLike>(path: &P) {\n }\n \n /// Create a new, empty directory at the provided path\n-/// \n+///\n /// # Example\n-/// \n+///\n ///     use std;\n ///     use std::path::Path;\n ///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::mkdir;\n-/// \n+///\n ///     let p = &Path(\"/some/dir\");\n ///     mkdir(p);\n ///     // If we got here, our directory exists! Horray!\n-/// \n+///\n /// # Errors\n-/// \n+///\n /// This call will raise an `io_error` condition if the user lacks permissions to make a\n /// new directory at the provided path, or if the directory already exists\n pub fn mkdir<P: PathLike>(path: &P) {\n@@ -175,20 +175,20 @@ pub fn mkdir<P: PathLike>(path: &P) {\n }\n \n /// Remove an existing, empty directory\n-/// \n+///\n /// # Example\n-/// \n+///\n ///     use std;\n ///     use std::path::Path;\n ///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::rmdir;\n-/// \n+///\n ///     let p = &Path(\"/some/dir\");\n ///     rmdir(p);\n ///     // good riddance, you mean ol' directory\n-/// \n+///\n /// # Errors\n-/// \n+///\n /// This call will raise an `io_error` condition if the user lacks permissions to remove the\n /// directory at the provided path, or if the directory isn't empty\n pub fn rmdir<P: PathLike>(path: &P) {\n@@ -205,21 +205,21 @@ pub fn rmdir<P: PathLike>(path: &P) {\n }\n \n /// Get information on the file, directory, etc at the provided path\n-/// \n+///\n /// Given a `rt::io::support::PathLike`, query the file system to get\n /// information about a file, directory, etc.\n-/// \n+///\n /// Returns a `Some(std::rt::io::PathInfo)` on success\n-/// \n+///\n /// # Example\n-/// \n+///\n ///     use std;\n ///     use std::path::Path;\n ///     use std::rt::io::support::PathLike;\n ///     use std::rt::io::file::stat;\n-/// \n+///\n ///     let p = &Path(\"/some/file/path.txt\");\n-/// \n+///\n ///     do io_error::cond.trap(|_| {\n ///         // hoo-boy...\n ///     }).inside {\n@@ -230,13 +230,13 @@ pub fn rmdir<P: PathLike>(path: &P) {\n ///         if stat.is_file {\n ///             // just imagine the possibilities ...\n ///         }\n-/// \n+///\n ///         // the file stream will be closed at the end of this block\n ///     }\n ///     // ..\n-/// \n+///\n /// # Errors\n-/// \n+///\n /// This call will raise an `io_error` condition if the user lacks the requisite\n /// permissions to perform a `stat` call on the given path or if there is no\n /// entry in the filesystem at the provided path.\n@@ -325,7 +325,7 @@ impl Seek for FileReader {\n }\n \n /// Constrained version of `FileStream` that only exposes write-specific operations.\n-/// \n+///\n /// Can be retreived via `FileInfo.open_writer()`.\n pub struct FileWriter { priv stream: FileStream }\n \n@@ -352,15 +352,15 @@ impl Seek for FileWriter {\n }\n \n /// Unconstrained file access type that exposes read and write operations\n-/// \n+///\n /// Can be retreived via `file::open()` and `FileInfo.open_stream()`.\n-/// \n+///\n /// # Errors\n-/// \n+///\n /// This type will raise an io_error condition if operations are attempted against\n /// it for which its underlying file descriptor was not configured at creation\n /// time, via the `FileAccess` parameter to `file::open()`.\n-/// \n+///\n /// For this reason, it is best to use the access-constrained wrappers that are\n /// exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n pub struct FileStream {\n@@ -474,25 +474,25 @@ pub trait FileSystemInfo {\n }\n \n /// Represents a file, whose underlying path may or may not be valid\n-/// \n+///\n /// # Example\n-/// \n+///\n /// * Check if a file exists, reading from it if so\n-/// \n+///\n ///     use std;\n ///     use std::path::Path;\n ///     use std::rt::io::file::{FileInfo, FileReader};\n-/// \n+///\n ///     let f = &Path(\"/some/file/path.txt\");\n ///     if f.exists() {\n ///         let reader = f.open_reader(Open);\n ///         let mut mem = [0u8, 8*64000];\n ///         reader.read(mem);\n ///         // ...\n ///     }\n-/// \n+///\n /// * Is the given path a file?\n-/// \n+///\n ///    let f = get_file_path_from_wherever();\n ///    match f.is_file() {\n ///        true => doing_something_with_a_file(f),\n@@ -567,22 +567,22 @@ impl FileSystemInfo for Path {\n impl FileInfo for Path { }\n \n /// Represents a directory, whose underlying path may or may not be valid\n-/// \n+///\n /// # Example\n-/// \n+///\n /// * Check if a directory exists, `mkdir`'ing it if not\n-/// \n+///\n ///     use std;\n ///     use std::path::Path;\n ///     use std::rt::io::file::{DirectoryInfo};\n-/// \n+///\n ///     let dir = &Path(\"/some/dir\");\n ///     if !dir.exists() {\n ///         dir.mkdir();\n ///     }\n-/// \n+///\n /// * Is the given path a directory? If so, iterate on its contents\n-/// \n+///\n ///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n ///         if dir.is_dir() {\n ///             let contents = dir.readdir();"}]}