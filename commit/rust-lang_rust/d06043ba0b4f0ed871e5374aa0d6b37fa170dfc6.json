{"sha": "d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNjA0M2JhMGI0ZjBlZDg3MWU1Mzc0YWEwZDZiMzdmYTE3MGRmYzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-02T22:39:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-02T23:17:08Z"}, "message": "rustdoc: Generate hyperlinks between crates\n\nThe general idea of hyperlinking between crates is that it should require as\nlittle configuration as possible, if any at all. In this vein, there are two\nseparate ways to generate hyperlinks between crates:\n\n1. When you're generating documentation for a crate 'foo' into folder 'doc',\n   then if foo's external crate dependencies already have documented in the\n   folder 'doc', then hyperlinks will be generated. This will work because all\n   documentation is in the same folder, allowing links to work seamlessly both\n   on the web and on the local filesystem browser.\n\n   The rationale for this use case is a package with multiple libraries/crates\n   that all want to link to one another, and you don't want to have to deal with\n   going to the web. In theory this could be extended to have a RUST_PATH-style\n   searching situtation, but I'm not sure that it would work seamlessly on the\n   web as it does on the local filesystem, so I'm not attempting to explore this\n   case in this pull request. I believe to fully realize this potential rustdoc\n   would have to be acting as a server instead of a static site generator.\n\n2. One of foo's external dependencies has a #[doc(html_root_url = \"...\")]\n   attribute. This means that all hyperlinks to the dependency will be rooted at\n   this url.\n\n   This use case encompasses all packages using libstd/libextra. These two\n   crates now have this attribute encoded (currently at the /doc/master url) and\n   will be read by anything which has a dependency on libstd/libextra. This\n   should also work for arbitrary crates in the wild that have online\n   documentation. I don't like how the version is hard-wired into the url, but I\n   think that this may be a case-by-case thing which doesn't end up being too\n   bad in the long run.\n\nCloses #9539", "tree": {"sha": "c64da86a53e4bb297626125834edbe0f9b8a047f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c64da86a53e4bb297626125834edbe0f9b8a047f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "html_url": "https://github.com/rust-lang/rust/commit/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f00d72b78b5fbcc865500184b883f5991e2cf68d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f00d72b78b5fbcc865500184b883f5991e2cf68d", "html_url": "https://github.com/rust-lang/rust/commit/f00d72b78b5fbcc865500184b883f5991e2cf68d"}], "stats": {"total": 377, "additions": 253, "deletions": 124}, "files": [{"sha": "74787e66fecfd3b853939f6be91057d3ec4d728d", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "patch": "@@ -26,7 +26,8 @@ Rust extras are part of the standard Rust distribution.\n        url = \"https://github.com/mozilla/rust/tree/master/src/libextra\")];\n \n #[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n-      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\")];\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n #[comment = \"Rust extras\"];\n #[license = \"MIT/ASL2\"];"}, {"sha": "b9100d6e365111cff25a00a22616492b1072e6c9", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 79, "deletions": 32, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "patch": "@@ -15,11 +15,18 @@ use its = syntax::parse::token::ident_to_str;\n \n use syntax;\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttributeMethods;\n \n+use rustc::metadata::cstore;\n+use rustc::metadata::csearch;\n+use rustc::metadata::decoder;\n+\n use std;\n+use std::hashmap::HashMap;\n+\n use doctree;\n use visit_ast;\n use std::local_data;\n@@ -61,19 +68,44 @@ impl<T: Clean<U>, U> Clean<~[U]> for syntax::opt_vec::OptVec<T> {\n pub struct Crate {\n     name: ~str,\n     module: Option<Item>,\n+    externs: HashMap<ast::CrateNum, ExternalCrate>,\n }\n \n impl Clean<Crate> for visit_ast::RustdocVisitor {\n     fn clean(&self) -> Crate {\n         use syntax::attr::{find_linkage_metas, last_meta_item_value_str_by_name};\n-        let maybe_meta = last_meta_item_value_str_by_name(find_linkage_metas(self.attrs), \"name\");\n+        let maybe_meta = last_meta_item_value_str_by_name(\n+                                find_linkage_metas(self.attrs), \"name\");\n+        let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+\n+        let mut externs = HashMap::new();\n+        do cstore::iter_crate_data(cx.sess.cstore) |n, meta| {\n+            externs.insert(n, meta.clean());\n+        }\n \n         Crate {\n             name: match maybe_meta {\n                 Some(x) => x.to_owned(),\n-                None => fail2!(\"rustdoc_ng requires a \\\\#[link(name=\\\"foo\\\")] crate attribute\"),\n+                None => fail2!(\"rustdoc requires a \\\\#[link(name=\\\"foo\\\")] \\\n+                                crate attribute\"),\n             },\n             module: Some(self.module.clean()),\n+            externs: externs,\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct ExternalCrate {\n+    name: ~str,\n+    attrs: ~[Attribute],\n+}\n+\n+impl Clean<ExternalCrate> for cstore::crate_metadata {\n+    fn clean(&self) -> ExternalCrate {\n+        ExternalCrate {\n+            name: self.name.to_owned(),\n+            attrs: decoder::get_crate_attributes(self.data).clean()\n         }\n     }\n }\n@@ -542,7 +574,15 @@ pub enum Type {\n     ResolvedPath {\n         path: Path,\n         typarams: Option<~[TyParamBound]>,\n-        did: ast::DefId\n+        id: ast::NodeId,\n+    },\n+    /// Same as above, but only external variants\n+    ExternalPath {\n+        path: Path,\n+        typarams: Option<~[TyParamBound]>,\n+        fqn: ~[~str],\n+        kind: TypeKind,\n+        crate: ast::CrateNum,\n     },\n     // I have no idea how to usefully use this.\n     TyParamBinder(ast::NodeId),\n@@ -572,6 +612,14 @@ pub enum Type {\n     // region, raw, other boxes, mutable\n }\n \n+#[deriving(Clone, Encodable, Decodable)]\n+pub enum TypeKind {\n+    TypeStruct,\n+    TypeEnum,\n+    TypeTrait,\n+    TypeFunction,\n+}\n+\n impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n@@ -1099,26 +1147,12 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n     }\n }\n \n-fn remove_comment_tags(s: &str) -> ~str {\n-    if s.starts_with(\"/\") {\n-        match s.slice(0,3) {\n-            &\"///\" => return s.slice(3, s.len()).trim().to_owned(),\n-            &\"/**\" | &\"/*!\" => return s.slice(3, s.len() - 2).trim().to_owned(),\n-            _ => return s.trim().to_owned()\n-        }\n-    } else {\n-        return s.to_owned();\n-    }\n-}\n-\n /// Given a Type, resolve it using the def_map\n fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n                 id: ast::NodeId) -> Type {\n-    use syntax::ast::*;\n-\n-    let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n+    let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n     debug2!(\"searching for {:?} in defmap\", id);\n-    let d = match dm.find(&id) {\n+    let d = match cx.tycx.def_map.find(&id) {\n         Some(k) => k,\n         None => {\n             let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n@@ -1128,28 +1162,41 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         }\n     };\n \n-    let def_id = match *d {\n-        DefFn(i, _) => i,\n-        DefSelf(i) | DefSelfTy(i) => return Self(i),\n-        DefTy(i) => i,\n-        DefTrait(i) => {\n+    let (def_id, kind) = match *d {\n+        ast::DefFn(i, _) => (i, TypeFunction),\n+        ast::DefSelf(i) | ast::DefSelfTy(i) => return Self(i),\n+        ast::DefTy(i) => (i, TypeEnum),\n+        ast::DefTrait(i) => {\n             debug2!(\"saw DefTrait in def_to_id\");\n-            i\n+            (i, TypeTrait)\n         },\n-        DefPrimTy(p) => match p {\n-            ty_str => return String,\n-            ty_bool => return Bool,\n+        ast::DefPrimTy(p) => match p {\n+            ast::ty_str => return String,\n+            ast::ty_bool => return Bool,\n             _ => return Primitive(p)\n         },\n-        DefTyParam(i, _) => return Generic(i.node),\n-        DefStruct(i) => i,\n-        DefTyParamBinder(i) => {\n+        ast::DefTyParam(i, _) => return Generic(i.node),\n+        ast::DefStruct(i) => (i, TypeStruct),\n+        ast::DefTyParamBinder(i) => {\n             debug2!(\"found a typaram_binder, what is it? {}\", i);\n             return TyParamBinder(i);\n         },\n         x => fail2!(\"resolved type maps to a weird def {:?}\", x),\n     };\n-    ResolvedPath{ path: path, typarams: tpbs, did: def_id }\n+    if ast_util::is_local(def_id) {\n+        ResolvedPath{ path: path, typarams: tpbs, id: def_id.node }\n+    } else {\n+        let fqn = csearch::get_item_path(cx.tycx, def_id);\n+        let fqn = fqn.move_iter().map(|i| {\n+            match i {\n+                ast_map::path_mod(id) |\n+                ast_map::path_name(id) |\n+                ast_map::path_pretty_name(id, _) => id.clean()\n+            }\n+        }).to_owned_vec();\n+        ExternalPath{ path: path, typarams: tpbs, fqn: fqn, kind: kind,\n+                      crate: def_id.crate }\n+    }\n }\n \n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {"}, {"sha": "c5f6d7c44fde10545a76cac75df64767e12c2258", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 113, "deletions": 68, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "patch": "@@ -16,6 +16,7 @@ use syntax::ast;\n use syntax::ast_util;\n \n use clean;\n+use html::render;\n use html::render::{cache_key, current_location_key};\n \n pub struct VisSpace(Option<ast::visibility>);\n@@ -97,8 +98,46 @@ impl fmt::Default for clean::Path {\n     }\n }\n \n-fn resolved_path(w: &mut io::Writer, did: ast::DefId,\n-                 path: &clean::Path, print_all: bool) {\n+fn resolved_path(w: &mut io::Writer, id: ast::NodeId, p: &clean::Path,\n+                 print_all: bool) {\n+    path(w, p, print_all,\n+        |_cache, loc| {\n+            match p.segments[0].name.as_slice() {\n+                \"super\" => Some(\"../\".repeat(loc.len() - 1)),\n+                _ => Some(\"../\".repeat(loc.len())),\n+            }\n+        },\n+        |cache| {\n+            match cache.paths.find(&id) {\n+                None => None,\n+                Some(&(ref fqp, shortty)) => Some((fqp.clone(), shortty))\n+            }\n+        });\n+}\n+\n+fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n+                 fqn: &[~str], kind: clean::TypeKind, crate: ast::CrateNum) {\n+    path(w, p, print_all,\n+        |cache, loc| {\n+            match *cache.extern_locations.get(&crate) {\n+                render::Remote(ref s) => Some(s.clone()),\n+                render::Local => Some(\"../\".repeat(loc.len())),\n+                render::Unknown => None,\n+            }\n+        },\n+        |_cache| {\n+            Some((fqn.to_owned(), match kind {\n+                clean::TypeStruct => \"struct\",\n+                clean::TypeEnum => \"enum\",\n+                clean::TypeFunction => \"fn\",\n+                clean::TypeTrait => \"trait\",\n+            }))\n+        })\n+}\n+\n+fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n+        root: &fn(&render::Cache, &[~str]) -> Option<~str>,\n+        info: &fn(&render::Cache) -> Option<(~[~str], &'static str)>) {\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n     let last = path.segments.last();\n@@ -121,51 +160,49 @@ fn resolved_path(w: &mut io::Writer, did: ast::DefId,\n     do local_data::get(current_location_key) |loc| {\n         let loc = loc.unwrap();\n \n-        if print_all {\n-            let mut root = match path.segments[0].name.as_slice() {\n-                \"super\" => ~\"../\",\n-                \"self\" => ~\"\",\n-                _ => \"../\".repeat(loc.len() - 1),\n-            };\n-            let amt = path.segments.len() - 1;\n-            for seg in path.segments.slice_to(amt).iter() {\n-                if \"super\" == seg.name || \"self\" == seg.name {\n-                    write!(w, \"{}::\", seg.name);\n-                } else {\n-                    root.push_str(seg.name);\n-                    root.push_str(\"/\");\n-                    write!(w, \"<a class='mod'\n-                                  href='{}index.html'>{}</a>::\",\n-                           root,\n-                           seg.name);\n-                }\n-            }\n-        }\n-\n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {\n-                match cache.paths.find(&did.node) {\n-                    // This is a documented path, link to it!\n-                    // FIXME(#9539): this is_local check should not exist\n-                    Some(&(ref fqp, shortty)) if ast_util::is_local(did) => {\n-                        let fqn = fqp.connect(\"::\");\n-                        let same = loc.iter().zip(fqp.iter())\n-                                      .take_while(|&(a, b)| *a == *b).len();\n+                let abs_root = root(cache, loc.as_slice());\n+                let rel_root = match path.segments[0].name.as_slice() {\n+                    \"self\" => Some(~\"./\"),\n+                    _ => None,\n+                };\n \n-                        let mut url = ~\"\";\n-                        if \"super\" == path.segments[0].name {\n-                            url.push_str(\"../\");\n-                        } else if \"self\" != path.segments[0].name {\n-                            url.push_str(\"../\".repeat(loc.len() - same));\n+                if print_all {\n+                    let amt = path.segments.len() - 1;\n+                    match rel_root {\n+                        Some(root) => {\n+                            let mut root = root;\n+                            for seg in path.segments.slice_to(amt).iter() {\n+                                if \"super\" == seg.name || \"self\" == seg.name {\n+                                    write!(w, \"{}::\", seg.name);\n+                                } else {\n+                                    root.push_str(seg.name);\n+                                    root.push_str(\"/\");\n+                                    write!(w, \"<a class='mod'\n+                                                  href='{}index.html'>{}</a>::\",\n+                                           root,\n+                                           seg.name);\n+                                }\n+                            }\n                         }\n-                        if same < fqp.len() {\n-                            let remaining = fqp.slice_from(same);\n-                            let to_link = remaining.slice_to(remaining.len() - 1);\n-                            for component in to_link.iter() {\n-                                url.push_str(*component);\n-                                url.push_str(\"/\");\n+                        None => {\n+                            for seg in path.segments.slice_to(amt).iter() {\n+                                write!(w, \"{}::\", seg.name);\n                             }\n                         }\n+                    }\n+                }\n+\n+                match info(cache) {\n+                    // This is a documented path, link to it!\n+                    Some((ref fqp, shortty)) if abs_root.is_some() => {\n+                        let mut url = abs_root.unwrap();\n+                        let to_link = fqp.slice_to(fqp.len() - 1);\n+                        for component in to_link.iter() {\n+                            url.push_str(*component);\n+                            url.push_str(\"/\");\n+                        }\n                         match shortty {\n                             \"mod\" => {\n                                 url.push_str(*fqp.last());\n@@ -178,24 +215,35 @@ fn resolved_path(w: &mut io::Writer, did: ast::DefId,\n                                 url.push_str(\".html\");\n                             }\n                         }\n-                        write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>{}\",\n-                               shortty, url, fqn, last.name, generics);\n+\n+                        write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n+                               shortty, url, fqp.connect(\"::\"), last.name);\n                     }\n+\n                     _ => {\n-                        if print_all {\n-                            let amt = path.segments.len() - 1;\n-                            for seg in path.segments.iter().take(amt) {\n-                                write!(w, \"{}::\", seg.name);\n-                            }\n-                        }\n-                        write!(w, \"{}{}\", last.name, generics);\n+                        write!(w, \"{}\", last.name);\n                     }\n-                };\n+                }\n+                write!(w, \"{}\", generics);\n             }\n         }\n     }\n }\n \n+fn typarams(w: &mut io::Writer, typarams: &Option<~[clean::TyParamBound]>) {\n+    match *typarams {\n+        Some(ref params) => {\n+            write!(w, \"&lt;\");\n+            for (i, param) in params.iter().enumerate() {\n+                if i > 0 { write!(w, \", \"); }\n+                write!(w, \"{}\", *param);\n+            }\n+            write!(w, \"&gt;\");\n+        }\n+        None => {}\n+    }\n+}\n+\n impl fmt::Default for clean::Type {\n     fn fmt(g: &clean::Type, f: &mut fmt::Formatter) {\n         match *g {\n@@ -206,19 +254,14 @@ impl fmt::Default for clean::Type {\n                     }\n                 }\n             }\n-            clean::ResolvedPath{did, typarams: ref typarams, path: ref path} => {\n-                resolved_path(f.buf, did, path, false);\n-                match *typarams {\n-                    Some(ref params) => {\n-                        f.buf.write(\"&lt;\".as_bytes());\n-                        for (i, param) in params.iter().enumerate() {\n-                            if i > 0 { f.buf.write(\", \".as_bytes()) }\n-                            write!(f.buf, \"{}\", *param);\n-                        }\n-                        f.buf.write(\"&gt;\".as_bytes());\n-                    }\n-                    None => {}\n-                }\n+            clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {\n+                resolved_path(f.buf, id, path, false);\n+                typarams(f.buf, tp);\n+            }\n+            clean::ExternalPath{path: ref path, typarams: ref tp,\n+                                fqn: ref fqn, kind, crate} => {\n+                external_path(f.buf, path, false, fqn.as_slice(), kind, crate);\n+                typarams(f.buf, tp);\n             }\n             clean::Self(*) => f.buf.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n@@ -417,8 +460,9 @@ impl fmt::Default for clean::ViewPath {\n impl fmt::Default for clean::ImportSource {\n     fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) {\n         match v.did {\n-            Some(did) => {\n-                resolved_path(f.buf, did, &v.path, true);\n+            // XXX: shouldn't be restricted to just local imports\n+            Some(did) if ast_util::is_local(did) => {\n+                resolved_path(f.buf, did.node, &v.path, true);\n             }\n             _ => {\n                 for (i, seg) in v.path.segments.iter().enumerate() {\n@@ -433,7 +477,8 @@ impl fmt::Default for clean::ImportSource {\n impl fmt::Default for clean::ViewListIdent {\n     fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) {\n         match v.source {\n-            Some(did) => {\n+            // XXX: shouldn't be limited to just local imports\n+            Some(did) if ast_util::is_local(did) => {\n                 let path = clean::Path {\n                     global: false,\n                     segments: ~[clean::PathSegment {\n@@ -442,7 +487,7 @@ impl fmt::Default for clean::ViewListIdent {\n                         types: ~[],\n                     }]\n                 };\n-                resolved_path(f.buf, did, &path, false);\n+                resolved_path(f.buf, did.node, &path, false);\n             }\n             _ => write!(f.buf, \"{}\", v.name),\n         }"}, {"sha": "6f3595ac2d96922098bd9e6d295bfdf757108673", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "patch": "@@ -28,10 +28,8 @@ use std::vec;\n use extra::arc::RWArc;\n use extra::json::ToJson;\n use extra::sort;\n-use extra::time;\n \n use syntax::ast;\n-use syntax::ast_util::is_local;\n use syntax::attr;\n \n use clean;\n@@ -52,6 +50,12 @@ pub struct Context {\n     include_sources: bool,\n }\n \n+pub enum ExternalLocation {\n+    Remote(~str),   // remote url root of the documentation\n+    Local,          // inside local folder\n+    Unknown,        // unknown where the documentation is\n+}\n+\n enum Implementor {\n     PathType(clean::Type),\n     OtherType(clean::Generics, /* trait */ clean::Type, /* for */ clean::Type),\n@@ -68,6 +72,8 @@ struct Cache {\n     traits: HashMap<ast::NodeId, HashMap<~str, ~str>>,\n     // trait id => implementors of the trait\n     implementors: HashMap<ast::NodeId, ~[Implementor]>,\n+    // crate number => where is the crate's dox located at\n+    extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n \n     priv stack: ~[~str],\n     priv parent_stack: ~[ast::NodeId],\n@@ -142,6 +148,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         stack: ~[],\n         parent_stack: ~[],\n         search_index: ~[],\n+        extern_locations: HashMap::new(),\n     };\n     cache.stack.push(crate.name.clone());\n     crate = cache.fold_crate(crate);\n@@ -154,6 +161,7 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     write(dst.push(\"main.css\"), include_str!(\"static/main.css\"));\n     write(dst.push(\"normalize.css\"), include_str!(\"static/normalize.css\"));\n \n+    // Publish the search index\n     {\n         let dst = dst.push(\"search-index.js\");\n         let mut w = BufferedWriter::new(dst.open_writer(io::CreateOrTruncate));\n@@ -180,9 +188,9 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         w.flush();\n     }\n \n-    info2!(\"emitting source files\");\n-    let started = time::precise_time_ns();\n+    // Render all source files (this may turn into a giant no-op)\n     {\n+        info2!(\"emitting source files\");\n         let dst = cx.dst.push(\"src\");\n         mkdir(&dst);\n         let dst = dst.push(crate.name);\n@@ -194,14 +202,13 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         };\n         crate = folder.fold_crate(crate);\n     }\n-    let ended = time::precise_time_ns();\n-    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1e9f64);\n \n-    info2!(\"rendering the whole crate\");\n-    let started = time::precise_time_ns();\n+    for (&n, e) in crate.externs.iter() {\n+        cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n+    }\n+\n+    // And finally render the whole crate's documentation\n     cx.crate(crate, cache);\n-    let ended = time::precise_time_ns();\n-    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1e9f64);\n }\n \n fn write(dst: Path, contents: &str) {\n@@ -235,6 +242,38 @@ fn clean_srcpath(src: &str, f: &fn(&str)) {\n     }\n }\n \n+fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n+    // See if there's documentation generated into the local directory\n+    let local_location = dst.push(e.name);\n+    if local_location.is_dir() {\n+        return Local;\n+    }\n+\n+    // Failing that, see if there's an attribute specifying where to find this\n+    // external crate\n+    for attr in e.attrs.iter() {\n+        match *attr {\n+            clean::List(~\"doc\", ref list) => {\n+                for attr in list.iter() {\n+                    match *attr {\n+                        clean::NameValue(~\"html_root_url\", ref s) => {\n+                            if s.ends_with(\"/\") {\n+                                return Remote(s.to_owned());\n+                            }\n+                            return Remote(*s + \"/\");\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    // Well, at least we tried.\n+    return Unknown;\n+}\n+\n impl<'self> DocFolder for SourceCollector<'self> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if self.cx.include_sources && !self.seen.contains(&item.source.filename) {\n@@ -353,8 +392,7 @@ impl DocFolder for Cache {\n         match item.inner {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n-                    Some(clean::ResolvedPath{ did, _ }) if is_local(did) => {\n-                        let id = did.node;\n+                    Some(clean::ResolvedPath{ id, _ }) => {\n                         let v = do self.implementors.find_or_insert_with(id) |_|{\n                             ~[]\n                         };\n@@ -441,8 +479,8 @@ impl DocFolder for Cache {\n             }\n             clean::ImplItem(ref i) => {\n                 match i.for_ {\n-                    clean::ResolvedPath{ did, _ } if is_local(did) => {\n-                        self.parent_stack.push(did.node); true\n+                    clean::ResolvedPath{ id, _ } => {\n+                        self.parent_stack.push(id); true\n                     }\n                     _ => false\n                 }\n@@ -457,8 +495,7 @@ impl DocFolder for Cache {\n                 match item {\n                     clean::Item{ attrs, inner: clean::ImplItem(i), _ } => {\n                         match i.for_ {\n-                            clean::ResolvedPath { did, _ } if is_local(did) => {\n-                                let id = did.node;\n+                            clean::ResolvedPath { id, _ } => {\n                                 let v = do self.impls.find_or_insert_with(id) |_| {\n                                     ~[]\n                                 };\n@@ -1258,7 +1295,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n         Some(ref ty) => {\n             write!(w, \"{} for \", *ty);\n             match *ty {\n-                clean::ResolvedPath { did, _ } => Some(did),\n+                clean::ResolvedPath { id, _ } => Some(id),\n                 _ => None,\n             }\n         }\n@@ -1289,8 +1326,7 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n         // No documentation? Attempt to slurp in the trait's documentation\n         let trait_id = match trait_id {\n             None => continue,\n-            Some(id) if is_local(id) => continue,\n-            Some(id) => id.node,\n+            Some(id) => id,\n         };\n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {"}, {"sha": "e7b4ce9e0568d5e4e6cb7f80c4c1ea56544a6509", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "patch": "@@ -13,7 +13,6 @@ use std::uint;\n use std::hashmap::HashSet;\n \n use syntax::ast;\n-use syntax::ast_util::is_local;\n \n use clean;\n use clean::Item;\n@@ -131,8 +130,8 @@ pub fn strip_private(mut crate: clean::Crate) -> plugins::PluginResult {\n             match i.inner {\n                 clean::ImplItem(ref imp) => {\n                     match imp.trait_ {\n-                        Some(clean::ResolvedPath{ did, _ }) => {\n-                            if is_local(did) && !self.contains(&did.node) {\n+                        Some(clean::ResolvedPath{ id, _ }) => {\n+                            if !self.contains(&id) {\n                                 return None;\n                             }\n                         }"}, {"sha": "5501cdfdcd513af6912db12f844f5656a912eb0b", "filename": "src/libstd/std.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=d06043ba0b4f0ed871e5374aa0d6b37fa170dfc6", "patch": "@@ -58,7 +58,8 @@ they contained the following prologue:\n #[crate_type = \"lib\"];\n \n #[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n-      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\")];\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n // Don't link to std. We are std.\n #[no_std];"}]}