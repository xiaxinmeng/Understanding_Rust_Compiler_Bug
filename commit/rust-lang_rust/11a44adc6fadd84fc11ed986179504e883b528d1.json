{"sha": "11a44adc6fadd84fc11ed986179504e883b528d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYTQ0YWRjNmZhZGQ4NGZjMTFlZDk4NjE3OTUwNGU4ODNiNTI4ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-19T10:54:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-19T10:54:44Z"}, "message": "Auto merge of #75600 - nagisa:improve_align_offset, r=KodrAus\n\nImprove codegen for `align_offset`\n\nIn this PR the `align_offset` implementation is changed/improved to produce better code in certain scenarios such as when pointer type is has a stride of 1 or when building for low optimisation levels.\n\nWhile these changes do not achieve the \"ideal\" codegen referenced in #75579, it gets significantly closer to it. I\u2019m not actually sure if the codegen can actually be much better with this function returning the offset, rather than the aligned pointer.\n\nSee the descriptions for separate commits for further information.", "tree": {"sha": "0362d9765046249f3def07345190cd2750bfdf39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0362d9765046249f3def07345190cd2750bfdf39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11a44adc6fadd84fc11ed986179504e883b528d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11a44adc6fadd84fc11ed986179504e883b528d1", "html_url": "https://github.com/rust-lang/rust/commit/11a44adc6fadd84fc11ed986179504e883b528d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11a44adc6fadd84fc11ed986179504e883b528d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b04bbfcbb79ed7325ea2b580458a80d95da6bbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b04bbfcbb79ed7325ea2b580458a80d95da6bbb", "html_url": "https://github.com/rust-lang/rust/commit/5b04bbfcbb79ed7325ea2b580458a80d95da6bbb"}, {"sha": "5d22b18bf28a54586008e9d8d4bfd72012c00e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d22b18bf28a54586008e9d8d4bfd72012c00e2e", "html_url": "https://github.com/rust-lang/rust/commit/5d22b18bf28a54586008e9d8d4bfd72012c00e2e"}], "stats": {"total": 75, "additions": 47, "deletions": 28}, "files": [{"sha": "68b5d1df71cb265c9c1cc18f9cbc912d76d35662", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/11a44adc6fadd84fc11ed986179504e883b528d1/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a44adc6fadd84fc11ed986179504e883b528d1/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=11a44adc6fadd84fc11ed986179504e883b528d1", "patch": "@@ -1166,16 +1166,20 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n /// Any questions go to @nagisa.\n #[lang = \"align_offset\"]\n pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n+    // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n+    // 1, where the method versions of these operations are not inlined.\n+    use intrinsics::{unchecked_shl, unchecked_shr, unchecked_sub, wrapping_mul, wrapping_sub};\n+\n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n     ///\n-    /// This implementation is tailored for align_offset and has following preconditions:\n+    /// This implementation is tailored for `align_offset` and has following preconditions:\n     ///\n     /// * `m` is a power-of-two;\n     /// * `x < m`; (if `x \u2265 m`, pass in `x % m` instead)\n     ///\n     /// Implementation of this function shall not panic. Ever.\n     #[inline]\n-    fn mod_inv(x: usize, m: usize) -> usize {\n+    unsafe fn mod_inv(x: usize, m: usize) -> usize {\n         /// Multiplicative modular inverse table modulo 2\u2074 = 16.\n         ///\n         /// Note, that this table does not contain values where inverse does not exist (i.e., for\n@@ -1187,8 +1191,10 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         const INV_TABLE_MOD_SQUARED: usize = INV_TABLE_MOD * INV_TABLE_MOD;\n \n         let table_inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n+        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n+        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n         if m <= INV_TABLE_MOD {\n-            table_inverse & (m - 1)\n+            table_inverse & m_minus_one\n         } else {\n             // We iterate \"up\" using the following formula:\n             //\n@@ -1204,49 +1210,50 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                 // usize::MAX` instead, because we take the result `mod n` at the end\n                 // anyway.\n-                inverse = inverse.wrapping_mul(2usize.wrapping_sub(x.wrapping_mul(inverse)));\n+                inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n                 if going_mod >= m {\n-                    return inverse & (m - 1);\n+                    return inverse & m_minus_one;\n                 }\n-                going_mod = going_mod.wrapping_mul(going_mod);\n+                going_mod = wrapping_mul(going_mod, going_mod);\n             }\n         }\n     }\n \n     let stride = mem::size_of::<T>();\n-    let a_minus_one = a.wrapping_sub(1);\n-    let pmoda = p as usize & a_minus_one;\n+    // SAFETY: `a` is a power-of-two, therefore non-zero.\n+    let a_minus_one = unsafe { unchecked_sub(a, 1) };\n+    if stride == 1 {\n+        // `stride == 1` case can be computed more efficiently through `-p (mod a)`.\n+        return wrapping_sub(0, p as usize) & a_minus_one;\n+    }\n \n+    let pmoda = p as usize & a_minus_one;\n     if pmoda == 0 {\n         // Already aligned. Yay!\n         return 0;\n-    }\n-\n-    if stride <= 1 {\n-        return if stride == 0 {\n-            // If the pointer is not aligned, and the element is zero-sized, then no amount of\n-            // elements will ever align the pointer.\n-            !0\n-        } else {\n-            a.wrapping_sub(pmoda)\n-        };\n+    } else if stride == 0 {\n+        // If the pointer is not aligned, and the element is zero-sized, then no amount of\n+        // elements will ever align the pointer.\n+        return usize::MAX;\n     }\n \n     let smoda = stride & a_minus_one;\n-    // SAFETY: a is power-of-two so cannot be 0. stride = 0 is handled above.\n+    // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n     let gcdpow = unsafe { intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a)) };\n-    let gcd = 1usize << gcdpow;\n+    // SAFETY: gcdpow has an upper-bound that\u2019s at most the number of bits in an usize.\n+    let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n \n-    if p as usize & (gcd.wrapping_sub(1)) == 0 {\n+    // SAFETY: gcd is always greater or equal to 1.\n+    if p as usize & unsafe { unchecked_sub(gcd, 1) } == 0 {\n         // This branch solves for the following linear congruence equation:\n         //\n         // ` p + so = 0 mod a `\n         //\n         // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n         // requested alignment.\n         //\n-        // With `g = gcd(a, s)`, and the above asserting that `p` is also divisible by `g`, we can\n-        // denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n+        // With `g = gcd(a, s)`, and the above condition asserting that `p` is also divisible by\n+        // `g`, we can denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n         //\n         // ` p' + s'o = 0 mod a' `\n         // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n@@ -1259,11 +1266,23 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         //\n         // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n         // to take the result `o mod lcm(s, a)`. We can replace `lcm(s, a)` with just a `a'`.\n-        let a2 = a >> gcdpow;\n-        let a2minus1 = a2.wrapping_sub(1);\n-        let s2 = smoda >> gcdpow;\n-        let minusp2 = a2.wrapping_sub(pmoda >> gcdpow);\n-        return (minusp2.wrapping_mul(mod_inv(s2, a2))) & a2minus1;\n+\n+        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n+        // `a`.\n+        let a2 = unsafe { unchecked_shr(a, gcdpow) };\n+        // SAFETY: `a2` is non-zero. Shifting `a` by `gcdpow` cannot shift out any of the set bits\n+        // in `a` (of which it has exactly one).\n+        let a2minus1 = unsafe { unchecked_sub(a2, 1) };\n+        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n+        // `a`.\n+        let s2 = unsafe { unchecked_shr(smoda, gcdpow) };\n+        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n+        // `a`. Furthermore, the subtraction cannot overflow, because `a2 = a >> gcdpow` will\n+        // always be strictly greater than `(p % a) >> gcdpow`.\n+        let minusp2 = unsafe { unchecked_sub(a2, unchecked_shr(pmoda, gcdpow)) };\n+        // SAFETY: `a2` is a power-of-two, as proven above. `s2` is strictly less than `a2`\n+        // because `(s % a) >> gcdpow` is strictly less than `a >> gcdpow`.\n+        return wrapping_mul(minusp2, unsafe { mod_inv(s2, a2) }) & a2minus1;\n     }\n \n     // Cannot be aligned at all."}]}