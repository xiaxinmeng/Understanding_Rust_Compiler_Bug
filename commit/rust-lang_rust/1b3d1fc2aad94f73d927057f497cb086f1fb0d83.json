{"sha": "1b3d1fc2aad94f73d927057f497cb086f1fb0d83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiM2QxZmMyYWFkOTRmNzNkOTI3MDU3ZjQ5N2NiMDg2ZjFmYjBkODM=", "commit": {"author": {"name": "1011X", "email": "1011XXXXX@gmail.com", "date": "2018-03-05T21:39:09Z"}, "committer": {"name": "1011X", "email": "1011XXXXX@gmail.com", "date": "2018-03-05T21:39:09Z"}, "message": "Move tests, re-export items from core::ascii", "tree": {"sha": "623b7b28764416af1ede7cab53a496996b78a7f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/623b7b28764416af1ede7cab53a496996b78a7f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b3d1fc2aad94f73d927057f497cb086f1fb0d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b3d1fc2aad94f73d927057f497cb086f1fb0d83", "html_url": "https://github.com/rust-lang/rust/commit/1b3d1fc2aad94f73d927057f497cb086f1fb0d83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b3d1fc2aad94f73d927057f497cb086f1fb0d83/comments", "author": {"login": "1011X", "id": 1851619, "node_id": "MDQ6VXNlcjE4NTE2MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1851619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1011X", "html_url": "https://github.com/1011X", "followers_url": "https://api.github.com/users/1011X/followers", "following_url": "https://api.github.com/users/1011X/following{/other_user}", "gists_url": "https://api.github.com/users/1011X/gists{/gist_id}", "starred_url": "https://api.github.com/users/1011X/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1011X/subscriptions", "organizations_url": "https://api.github.com/users/1011X/orgs", "repos_url": "https://api.github.com/users/1011X/repos", "events_url": "https://api.github.com/users/1011X/events{/privacy}", "received_events_url": "https://api.github.com/users/1011X/received_events", "type": "User", "site_admin": false}, "committer": {"login": "1011X", "id": 1851619, "node_id": "MDQ6VXNlcjE4NTE2MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1851619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1011X", "html_url": "https://github.com/1011X", "followers_url": "https://api.github.com/users/1011X/followers", "following_url": "https://api.github.com/users/1011X/following{/other_user}", "gists_url": "https://api.github.com/users/1011X/gists{/gist_id}", "starred_url": "https://api.github.com/users/1011X/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1011X/subscriptions", "organizations_url": "https://api.github.com/users/1011X/orgs", "repos_url": "https://api.github.com/users/1011X/repos", "events_url": "https://api.github.com/users/1011X/events{/privacy}", "received_events_url": "https://api.github.com/users/1011X/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bfc06272310600e93e3127a3a257031d15eab7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bfc06272310600e93e3127a3a257031d15eab7f", "html_url": "https://github.com/rust-lang/rust/commit/9bfc06272310600e93e3127a3a257031d15eab7f"}], "stats": {"total": 1182, "additions": 353, "deletions": 829}, "files": [{"sha": "f409536d1b0e42ff8341899a2706783e643defbd", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 1, "deletions": 355, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/1b3d1fc2aad94f73d927057f497cb086f1fb0d83/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3d1fc2aad94f73d927057f497cb086f1fb0d83/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=1b3d1fc2aad94f73d927057f497cb086f1fb0d83", "patch": "@@ -19,7 +19,7 @@\n //!\n //! [`escape_default`]: fn.escape_default.html\n \n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n \n use fmt;\n use ops::Range;\n@@ -145,357 +145,3 @@ impl fmt::Debug for EscapeDefault {\n         f.pad(\"EscapeDefault { .. }\")\n     }\n }\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use char::from_u32;\n-\n-    #[test]\n-    fn test_is_ascii() {\n-        assert!(b\"\".is_ascii());\n-        assert!(b\"banana\\0\\x7F\".is_ascii());\n-        assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n-        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n-        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n-        assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n-\n-        assert!(\"\".is_ascii());\n-        assert!(\"banana\\0\\u{7F}\".is_ascii());\n-        assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n-    }\n-\n-    #[test]\n-    fn test_to_ascii_uppercase() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n-\n-        for i in 0..501 {\n-            let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n-                        else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n-                       (from_u32(upper).unwrap()).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_ascii_lowercase() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n-\n-        for i in 0..501 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n-                       (from_u32(lower).unwrap()).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_make_ascii_lower_case() {\n-        macro_rules! test {\n-            ($from: expr, $to: expr) => {\n-                {\n-                    let mut x = $from;\n-                    x.make_ascii_lowercase();\n-                    assert_eq!(x, $to);\n-                }\n-            }\n-        }\n-        test!(b'A', b'a');\n-        test!(b'a', b'a');\n-        test!(b'!', b'!');\n-        test!('A', 'a');\n-        test!('\u00c0', '\u00c0');\n-        test!('a', 'a');\n-        test!('!', '!');\n-        test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n-        test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n-    }\n-\n-\n-    #[test]\n-    fn test_make_ascii_upper_case() {\n-        macro_rules! test {\n-            ($from: expr, $to: expr) => {\n-                {\n-                    let mut x = $from;\n-                    x.make_ascii_uppercase();\n-                    assert_eq!(x, $to);\n-                }\n-            }\n-        }\n-        test!(b'a', b'A');\n-        test!(b'A', b'A');\n-        test!(b'!', b'!');\n-        test!('a', 'A');\n-        test!('\u00e0', '\u00e0');\n-        test!('A', 'A');\n-        test!('!', '!');\n-        test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n-        test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n-\n-        let mut x = \"Hello\".to_string();\n-        x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n-        assert_eq!(x, \"HELlo\")\n-    }\n-\n-    #[test]\n-    fn test_eq_ignore_ascii_case() {\n-        assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n-        assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n-        assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n-        assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n-        assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n-\n-        for i in 0..501 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n-                    &from_u32(lower).unwrap().to_string()));\n-        }\n-    }\n-\n-    #[test]\n-    fn inference_works() {\n-        let x = \"a\".to_string();\n-        x.eq_ignore_ascii_case(\"A\");\n-    }\n-\n-    // Shorthands used by the is_ascii_* tests.\n-    macro_rules! assert_all {\n-        ($what:ident, $($str:tt),+) => {{\n-            $(\n-                for b in $str.chars() {\n-                    if !b.$what() {\n-                        panic!(\"expected {}({}) but it isn't\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                for b in $str.as_bytes().iter() {\n-                    if !b.$what() {\n-                        panic!(\"expected {}(0x{:02x})) but it isn't\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                assert!($str.$what());\n-                assert!($str.as_bytes().$what());\n-            )+\n-        }};\n-        ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n-    }\n-    macro_rules! assert_none {\n-        ($what:ident, $($str:tt),+) => {{\n-            $(\n-                for b in $str.chars() {\n-                    if b.$what() {\n-                        panic!(\"expected not-{}({}) but it is\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                for b in $str.as_bytes().iter() {\n-                    if b.$what() {\n-                        panic!(\"expected not-{}(0x{:02x})) but it is\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-            )*\n-        }};\n-        ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_alphabetic() {\n-        assert_all!(is_ascii_alphabetic,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-        );\n-        assert_none!(is_ascii_alphabetic,\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_uppercase() {\n-        assert_all!(is_ascii_uppercase,\n-            \"\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-        );\n-        assert_none!(is_ascii_uppercase,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_lowercase() {\n-        assert_all!(is_ascii_lowercase,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-        );\n-        assert_none!(is_ascii_lowercase,\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_alphanumeric() {\n-        assert_all!(is_ascii_alphanumeric,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-        );\n-        assert_none!(is_ascii_alphanumeric,\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_digit() {\n-        assert_all!(is_ascii_digit,\n-            \"\",\n-            \"0123456789\",\n-        );\n-        assert_none!(is_ascii_digit,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_hexdigit() {\n-        assert_all!(is_ascii_hexdigit,\n-            \"\",\n-            \"0123456789\",\n-            \"abcdefABCDEF\",\n-        );\n-        assert_none!(is_ascii_hexdigit,\n-            \"ghijklmnopqrstuvwxyz\",\n-            \"GHIJKLMNOQPRSTUVWXYZ\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_punctuation() {\n-        assert_all!(is_ascii_punctuation,\n-            \"\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-        );\n-        assert_none!(is_ascii_punctuation,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_graphic() {\n-        assert_all!(is_ascii_graphic,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-        );\n-        assert_none!(is_ascii_graphic,\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_whitespace() {\n-        assert_all!(is_ascii_whitespace,\n-            \"\",\n-            \" \\t\\n\\x0c\\r\",\n-        );\n-        assert_none!(is_ascii_whitespace,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x0b\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_control() {\n-        assert_all!(is_ascii_control,\n-            \"\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-        assert_none!(is_ascii_control,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \",\n-        );\n-    }\n-}"}, {"sha": "9cc3cd18be5bccee3f9f4f897d31c178e81ceaca", "filename": "src/libcore/tests/ascii.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/1b3d1fc2aad94f73d927057f497cb086f1fb0d83/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3d1fc2aad94f73d927057f497cb086f1fb0d83/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=1b3d1fc2aad94f73d927057f497cb086f1fb0d83", "patch": "@@ -0,0 +1,349 @@\n+use char::from_u32;\n+\n+#[test]\n+fn test_is_ascii() {\n+    assert!(b\"\".is_ascii());\n+    assert!(b\"banana\\0\\x7F\".is_ascii());\n+    assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n+    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n+    assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n+    assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n+\n+    assert!(\"\".is_ascii());\n+    assert!(\"banana\\0\\u{7F}\".is_ascii());\n+    assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n+    assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n+    assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n+}\n+\n+#[test]\n+fn test_to_ascii_uppercase() {\n+    assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n+    assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n+\n+    for i in 0..501 {\n+        let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n+                    else { i };\n+        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n+                   (from_u32(upper).unwrap()).to_string());\n+    }\n+}\n+\n+#[test]\n+fn test_to_ascii_lowercase() {\n+    assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n+    // Dotted capital I, Kelvin sign, Sharp S.\n+    assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n+\n+    for i in 0..501 {\n+        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                    else { i };\n+        assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n+                   (from_u32(lower).unwrap()).to_string());\n+    }\n+}\n+\n+#[test]\n+fn test_make_ascii_lower_case() {\n+    macro_rules! test {\n+        ($from: expr, $to: expr) => {\n+            {\n+                let mut x = $from;\n+                x.make_ascii_lowercase();\n+                assert_eq!(x, $to);\n+            }\n+        }\n+    }\n+    test!(b'A', b'a');\n+    test!(b'a', b'a');\n+    test!(b'!', b'!');\n+    test!('A', 'a');\n+    test!('\u00c0', '\u00c0');\n+    test!('a', 'a');\n+    test!('!', '!');\n+    test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n+    test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n+}\n+\n+\n+#[test]\n+fn test_make_ascii_upper_case() {\n+    macro_rules! test {\n+        ($from: expr, $to: expr) => {\n+            {\n+                let mut x = $from;\n+                x.make_ascii_uppercase();\n+                assert_eq!(x, $to);\n+            }\n+        }\n+    }\n+    test!(b'a', b'A');\n+    test!(b'A', b'A');\n+    test!(b'!', b'!');\n+    test!('a', 'A');\n+    test!('\u00e0', '\u00e0');\n+    test!('A', 'A');\n+    test!('!', '!');\n+    test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n+    test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n+\n+    let mut x = \"Hello\".to_string();\n+    x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n+    assert_eq!(x, \"HELlo\")\n+}\n+\n+#[test]\n+fn test_eq_ignore_ascii_case() {\n+    assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n+    assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n+    // Dotted capital I, Kelvin sign, Sharp S.\n+    assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n+    assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n+    assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n+    assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n+\n+    for i in 0..501 {\n+        let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                    else { i };\n+        assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n+                &from_u32(lower).unwrap().to_string()));\n+    }\n+}\n+\n+#[test]\n+fn inference_works() {\n+    let x = \"a\".to_string();\n+    x.eq_ignore_ascii_case(\"A\");\n+}\n+\n+// Shorthands used by the is_ascii_* tests.\n+macro_rules! assert_all {\n+    ($what:ident, $($str:tt),+) => {{\n+        $(\n+            for b in $str.chars() {\n+                if !b.$what() {\n+                    panic!(\"expected {}({}) but it isn't\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            for b in $str.as_bytes().iter() {\n+                if !b.$what() {\n+                    panic!(\"expected {}(0x{:02x})) but it isn't\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            assert!($str.$what());\n+            assert!($str.as_bytes().$what());\n+        )+\n+    }};\n+    ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n+}\n+macro_rules! assert_none {\n+    ($what:ident, $($str:tt),+) => {{\n+        $(\n+            for b in $str.chars() {\n+                if b.$what() {\n+                    panic!(\"expected not-{}({}) but it is\",\n+                           stringify!($what), b);\n+                }\n+            }\n+            for b in $str.as_bytes().iter() {\n+                if b.$what() {\n+                    panic!(\"expected not-{}(0x{:02x})) but it is\",\n+                           stringify!($what), b);\n+                }\n+            }\n+        )*\n+    }};\n+    ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n+}\n+\n+#[test]\n+fn test_is_ascii_alphabetic() {\n+    assert_all!(is_ascii_alphabetic,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+    );\n+    assert_none!(is_ascii_alphabetic,\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_uppercase() {\n+    assert_all!(is_ascii_uppercase,\n+        \"\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+    );\n+    assert_none!(is_ascii_uppercase,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_lowercase() {\n+    assert_all!(is_ascii_lowercase,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+    );\n+    assert_none!(is_ascii_lowercase,\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_alphanumeric() {\n+    assert_all!(is_ascii_alphanumeric,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+    );\n+    assert_none!(is_ascii_alphanumeric,\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_digit() {\n+    assert_all!(is_ascii_digit,\n+        \"\",\n+        \"0123456789\",\n+    );\n+    assert_none!(is_ascii_digit,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_hexdigit() {\n+    assert_all!(is_ascii_hexdigit,\n+        \"\",\n+        \"0123456789\",\n+        \"abcdefABCDEF\",\n+    );\n+    assert_none!(is_ascii_hexdigit,\n+        \"ghijklmnopqrstuvwxyz\",\n+        \"GHIJKLMNOQPRSTUVWXYZ\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_punctuation() {\n+    assert_all!(is_ascii_punctuation,\n+        \"\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+    );\n+    assert_none!(is_ascii_punctuation,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_graphic() {\n+    assert_all!(is_ascii_graphic,\n+        \"\",\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+    );\n+    assert_none!(is_ascii_graphic,\n+        \" \\t\\n\\x0c\\r\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_whitespace() {\n+    assert_all!(is_ascii_whitespace,\n+        \"\",\n+        \" \\t\\n\\x0c\\r\",\n+    );\n+    assert_none!(is_ascii_whitespace,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x0b\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+}\n+\n+#[test]\n+fn test_is_ascii_control() {\n+    assert_all!(is_ascii_control,\n+        \"\",\n+        \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+        \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+        \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+        \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+        \"\\x7f\",\n+    );\n+    assert_none!(is_ascii_control,\n+        \"abcdefghijklmnopqrstuvwxyz\",\n+        \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        \"0123456789\",\n+        \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        \" \",\n+    );\n+}"}, {"sha": "70fef9ef5d443539f12b34b6ae3c25c1f742167d", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 3, "deletions": 474, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/1b3d1fc2aad94f73d927057f497cb086f1fb0d83/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b3d1fc2aad94f73d927057f497cb086f1fb0d83/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=1b3d1fc2aad94f73d927057f497cb086f1fb0d83", "patch": "@@ -30,6 +30,9 @@ use fmt;\n use ops::Range;\n use iter::FusedIterator;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::ascii::{EscapeDefault, escape_default};\n+\n /// Extension methods for ASCII-subset only operations.\n ///\n /// Be aware that operations on seemingly non-ASCII characters can sometimes\n@@ -483,477 +486,3 @@ impl AsciiExt for str {\n         self.bytes().all(|b| b.is_ascii_control())\n     }\n }\n-\n-/// An iterator over the escaped version of a byte.\n-///\n-/// This `struct` is created by the [`escape_default`] function. See its\n-/// documentation for more.\n-///\n-/// [`escape_default`]: fn.escape_default.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct EscapeDefault {\n-    range: Range<usize>,\n-    data: [u8; 4],\n-}\n-\n-/// Returns an iterator that produces an escaped version of a `u8`.\n-///\n-/// The default is chosen with a bias toward producing literals that are\n-/// legal in a variety of languages, including C++11 and similar C-family\n-/// languages. The exact rules are:\n-///\n-/// - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-/// - Single-quote, double-quote and backslash chars are backslash-escaped.\n-/// - Any other chars in the range [0x20,0x7e] are not escaped.\n-/// - Any other chars are given hex escapes of the form '\\xNN'.\n-/// - Unicode escapes are never generated by this function.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::ascii;\n-///\n-/// let escaped = ascii::escape_default(b'0').next().unwrap();\n-/// assert_eq!(b'0', escaped);\n-///\n-/// let mut escaped = ascii::escape_default(b'\\t');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b't', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\r');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'r', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\n');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'n', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\'');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'\\'', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\"');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'\"', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\\\');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-///\n-/// let mut escaped = ascii::escape_default(b'\\x9d');\n-///\n-/// assert_eq!(b'\\\\', escaped.next().unwrap());\n-/// assert_eq!(b'x', escaped.next().unwrap());\n-/// assert_eq!(b'9', escaped.next().unwrap());\n-/// assert_eq!(b'd', escaped.next().unwrap());\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn escape_default(c: u8) -> EscapeDefault {\n-    let (data, len) = match c {\n-        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n-        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n-        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n-        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n-        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n-        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n-        b'\\x20' ... b'\\x7e' => ([c, 0, 0, 0], 1),\n-        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n-    };\n-\n-    return EscapeDefault { range: (0.. len), data: data };\n-\n-    fn hexify(b: u8) -> u8 {\n-        match b {\n-            0 ... 9 => b'0' + b,\n-            _ => b'a' + b - 10,\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for EscapeDefault {\n-    type Item = u8;\n-    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl DoubleEndedIterator for EscapeDefault {\n-    fn next_back(&mut self) -> Option<u8> {\n-        self.range.next_back().map(|i| self.data[i])\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ExactSizeIterator for EscapeDefault {}\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl FusedIterator for EscapeDefault {}\n-\n-#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n-impl fmt::Debug for EscapeDefault {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"EscapeDefault { .. }\")\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    //! Note that most of these tests are not testing `AsciiExt` methods, but\n-    //! test inherent ascii methods of char, u8, str and [u8]. `AsciiExt` is\n-    //! just using those methods, though.\n-    use super::AsciiExt;\n-    use char::from_u32;\n-\n-    #[test]\n-    fn test_is_ascii() {\n-        assert!(b\"\".is_ascii());\n-        assert!(b\"banana\\0\\x7F\".is_ascii());\n-        assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n-        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n-        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n-        assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n-\n-        assert!(\"\".is_ascii());\n-        assert!(\"banana\\0\\u{7F}\".is_ascii());\n-        assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n-        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n-    }\n-\n-    #[test]\n-    fn test_to_ascii_uppercase() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n-\n-        for i in 0..501 {\n-            let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n-                        else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n-                       (from_u32(upper).unwrap()).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_ascii_lowercase() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n-\n-        for i in 0..501 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n-                       (from_u32(lower).unwrap()).to_string());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_make_ascii_lower_case() {\n-        macro_rules! test {\n-            ($from: expr, $to: expr) => {\n-                {\n-                    let mut x = $from;\n-                    x.make_ascii_lowercase();\n-                    assert_eq!(x, $to);\n-                }\n-            }\n-        }\n-        test!(b'A', b'a');\n-        test!(b'a', b'a');\n-        test!(b'!', b'!');\n-        test!('A', 'a');\n-        test!('\u00c0', '\u00c0');\n-        test!('a', 'a');\n-        test!('!', '!');\n-        test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n-        test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n-    }\n-\n-\n-    #[test]\n-    fn test_make_ascii_upper_case() {\n-        macro_rules! test {\n-            ($from: expr, $to: expr) => {\n-                {\n-                    let mut x = $from;\n-                    x.make_ascii_uppercase();\n-                    assert_eq!(x, $to);\n-                }\n-            }\n-        }\n-        test!(b'a', b'A');\n-        test!(b'A', b'A');\n-        test!(b'!', b'!');\n-        test!('a', 'A');\n-        test!('\u00e0', '\u00e0');\n-        test!('A', 'A');\n-        test!('!', '!');\n-        test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n-        test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n-\n-        let mut x = \"Hello\".to_string();\n-        x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n-        assert_eq!(x, \"HELlo\")\n-    }\n-\n-    #[test]\n-    fn test_eq_ignore_ascii_case() {\n-        assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n-        assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n-        // Dotted capital I, Kelvin sign, Sharp S.\n-        assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n-        assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n-        assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n-        assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n-\n-        for i in 0..501 {\n-            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n-                        else { i };\n-            assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n-                    &from_u32(lower).unwrap().to_string()));\n-        }\n-    }\n-\n-    #[test]\n-    fn inference_works() {\n-        let x = \"a\".to_string();\n-        x.eq_ignore_ascii_case(\"A\");\n-    }\n-\n-    // Shorthands used by the is_ascii_* tests.\n-    macro_rules! assert_all {\n-        ($what:ident, $($str:tt),+) => {{\n-            $(\n-                for b in $str.chars() {\n-                    if !b.$what() {\n-                        panic!(\"expected {}({}) but it isn't\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                for b in $str.as_bytes().iter() {\n-                    if !b.$what() {\n-                        panic!(\"expected {}(0x{:02x})) but it isn't\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                assert!($str.$what());\n-                assert!($str.as_bytes().$what());\n-            )+\n-        }};\n-        ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n-    }\n-    macro_rules! assert_none {\n-        ($what:ident, $($str:tt),+) => {{\n-            $(\n-                for b in $str.chars() {\n-                    if b.$what() {\n-                        panic!(\"expected not-{}({}) but it is\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-                for b in $str.as_bytes().iter() {\n-                    if b.$what() {\n-                        panic!(\"expected not-{}(0x{:02x})) but it is\",\n-                               stringify!($what), b);\n-                    }\n-                }\n-            )*\n-        }};\n-        ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_alphabetic() {\n-        assert_all!(is_ascii_alphabetic,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-        );\n-        assert_none!(is_ascii_alphabetic,\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_uppercase() {\n-        assert_all!(is_ascii_uppercase,\n-            \"\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-        );\n-        assert_none!(is_ascii_uppercase,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_lowercase() {\n-        assert_all!(is_ascii_lowercase,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-        );\n-        assert_none!(is_ascii_lowercase,\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_alphanumeric() {\n-        assert_all!(is_ascii_alphanumeric,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-        );\n-        assert_none!(is_ascii_alphanumeric,\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_digit() {\n-        assert_all!(is_ascii_digit,\n-            \"\",\n-            \"0123456789\",\n-        );\n-        assert_none!(is_ascii_digit,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_hexdigit() {\n-        assert_all!(is_ascii_hexdigit,\n-            \"\",\n-            \"0123456789\",\n-            \"abcdefABCDEF\",\n-        );\n-        assert_none!(is_ascii_hexdigit,\n-            \"ghijklmnopqrstuvwxyz\",\n-            \"GHIJKLMNOQPRSTUVWXYZ\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_punctuation() {\n-        assert_all!(is_ascii_punctuation,\n-            \"\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-        );\n-        assert_none!(is_ascii_punctuation,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_graphic() {\n-        assert_all!(is_ascii_graphic,\n-            \"\",\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-        );\n-        assert_none!(is_ascii_graphic,\n-            \" \\t\\n\\x0c\\r\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_whitespace() {\n-        assert_all!(is_ascii_whitespace,\n-            \"\",\n-            \" \\t\\n\\x0c\\r\",\n-        );\n-        assert_none!(is_ascii_whitespace,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x0b\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_is_ascii_control() {\n-        assert_all!(is_ascii_control,\n-            \"\",\n-            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n-            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n-            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n-            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n-            \"\\x7f\",\n-        );\n-        assert_none!(is_ascii_control,\n-            \"abcdefghijklmnopqrstuvwxyz\",\n-            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n-            \"0123456789\",\n-            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n-            \" \",\n-        );\n-    }\n-}"}]}