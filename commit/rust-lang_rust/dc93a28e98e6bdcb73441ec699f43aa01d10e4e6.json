{"sha": "dc93a28e98e6bdcb73441ec699f43aa01d10e4e6", "node_id": "C_kwDOAAsO6NoAKGRjOTNhMjhlOThlNmJkY2I3MzQ0MWVjNjk5ZjQzYWEwMWQxMGU0ZTY", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-29T12:42:52Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-29T12:42:52Z"}, "message": "reduce allocations", "tree": {"sha": "77365abdd115eb77a6adb6e5297ee2dcc2fd8540", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77365abdd115eb77a6adb6e5297ee2dcc2fd8540"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc93a28e98e6bdcb73441ec699f43aa01d10e4e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc93a28e98e6bdcb73441ec699f43aa01d10e4e6", "html_url": "https://github.com/rust-lang/rust/commit/dc93a28e98e6bdcb73441ec699f43aa01d10e4e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc93a28e98e6bdcb73441ec699f43aa01d10e4e6/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9061ffba8ceb6a3a927aff15b570f9bd4247862a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9061ffba8ceb6a3a927aff15b570f9bd4247862a", "html_url": "https://github.com/rust-lang/rust/commit/9061ffba8ceb6a3a927aff15b570f9bd4247862a"}], "stats": {"total": 149, "additions": 111, "deletions": 38}, "files": [{"sha": "3f52334b724726a10264e95394ab29317d1ae2d1", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 111, "deletions": 38, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/dc93a28e98e6bdcb73441ec699f43aa01d10e4e6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc93a28e98e6bdcb73441ec699f43aa01d10e4e6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=dc93a28e98e6bdcb73441ec699f43aa01d10e4e6", "patch": "@@ -218,7 +218,7 @@ fn to_upvars_resolved_place_builder<'tcx>(\n     let upvar_resolved_place_builder = PlaceBuilder::construct_local_place_builder(\n         cx,\n         upvar_resolved_local,\n-        local_projection.to_vec(),\n+        local_projection.as_slice(),\n         upvar_projection,\n     );\n \n@@ -266,7 +266,7 @@ fn strip_prefix<'a, 'tcx>(\n     mut base_ty: Ty<'tcx>,\n     projections: &'a [UpvarProjectionElem<'tcx>],\n     prefix_projections: &[HirProjection<'tcx>],\n-) -> Vec<UpvarProjectionElem<'tcx>> {\n+) -> impl Iterator<Item = UpvarProjectionElem<'tcx>> + 'a {\n     let mut iter = projections\n         .iter()\n         // Filter out opaque casts, they are unnecessary in the prefix.\n@@ -293,7 +293,7 @@ fn strip_prefix<'a, 'tcx>(\n         base_ty = projection.ty;\n     }\n \n-    iter.collect::<Vec<_>>()\n+    iter\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n@@ -342,10 +342,14 @@ impl<'tcx> PlaceBuilder<'tcx> {\n \n     #[instrument(skip(cx), level = \"debug\")]\n     pub(crate) fn field(self, cx: &Builder<'_, 'tcx>, f: Field) -> Self {\n-        let field_ty = match self {\n-            PlaceBuilder::Local(..) => {\n-                let base_place = self.clone();\n-                PlaceBuilder::compute_field_ty(cx, f, base_place)\n+        let field_ty = match self.clone() {\n+            PlaceBuilder::Local(local, projection) => {\n+                let base_place = PlaceBuilder::Local(local, projection);\n+                let PlaceTy { ty, variant_index } =\n+                    base_place.to_place(cx).ty(&cx.local_decls, cx.tcx);\n+                let base_ty = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+\n+                PlaceBuilder::compute_field_ty(cx, f, base_ty, variant_index)\n             }\n             PlaceBuilder::UpVar(..) => {\n                 let dummy_ty = cx.tcx.mk_ty_infer(ty::FreshTy(0));\n@@ -410,13 +414,10 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     fn compute_field_ty(\n         cx: &Builder<'_, 'tcx>,\n         field: Field,\n-        base_place: PlaceBuilder<'tcx>,\n+        base_ty: Ty<'tcx>,\n+        variant_index: Option<VariantIdx>,\n     ) -> Ty<'tcx> {\n         let field_idx = field.as_usize();\n-        let PlaceTy { ty, variant_index } = base_place.to_place(cx).ty(&cx.local_decls, cx.tcx);\n-        let base_ty = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-        debug!(?base_ty);\n-\n         let field_ty = match base_ty.kind() {\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n                 let variant_idx = variant_index.unwrap();\n@@ -479,41 +480,38 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// contains the projections of the captured upvar and `upvar_projection` the\n     /// projections that are applied to the captured upvar. The main purpose of this\n     /// function is to figure out the `Ty`s of the field projections in `upvar_projection`.\n-    #[instrument(skip(cx, local))]\n+    #[instrument(skip(cx, local, upvar_projection))]\n     fn construct_local_place_builder(\n         cx: &Builder<'_, 'tcx>,\n         local: Local,\n-        mut local_projection: Vec<PlaceElem<'tcx>>,\n-        upvar_projection: Vec<UpvarProjectionElem<'tcx>>,\n+        local_projection: &[PlaceElem<'tcx>],\n+        upvar_projection: impl Iterator<Item = UpvarProjectionElem<'tcx>>,\n     ) -> Self {\n-        // We iterate through `upvar_projection` and whenever we find a `ProjectionElem::Field` we use\n-        // the ancestor projections, i.e. those projection elements that come before the field projection,\n-        // to get the `Ty` for the field.\n-\n-        for proj in upvar_projection.iter() {\n-            debug!(\"proj: {:?}, local_projection: {:?}\", proj, local_projection);\n-            match *proj {\n+        // We maintain a `Ty` to which we apply a projection in each iteration over `upvar_projection`.\n+        // This `ancestor_ty` let's us infer the field type whenever we encounter a\n+        // `ProjectionElem::Field`.\n+        let (mut ancestor_ty, mut opt_variant_idx) =\n+            local_projections_to_ty(cx, local, local_projection);\n+\n+        // We add all projection elements we encounter to this `Vec`.\n+        let mut local_projection = local_projection.to_vec();\n+\n+        for (i, proj) in upvar_projection.enumerate() {\n+            debug!(\"i: {:?}, proj: {:?}, local_projection: {:?}\", i, proj, local_projection);\n+            match proj {\n                 ProjectionElem::Field(field, _) => {\n-                    let ancestor_proj = local_projection.to_vec();\n-                    let base_place = PlaceBuilder::Local(local, ancestor_proj);\n-                    let field_ty = PlaceBuilder::compute_field_ty(cx, field, base_place);\n+                    let field_ty =\n+                        PlaceBuilder::compute_field_ty(cx, field, ancestor_ty, opt_variant_idx);\n                     debug!(?field_ty);\n \n                     local_projection.push(ProjectionElem::Field(field, field_ty));\n-                    debug!(?local_projection);\n-                }\n-                ProjectionElem::Deref => local_projection.push(ProjectionElem::Deref),\n-                ProjectionElem::Index(idx) => local_projection.push(ProjectionElem::Index(idx)),\n-                ProjectionElem::ConstantIndex { offset, min_length, from_end } => local_projection\n-                    .push(ProjectionElem::ConstantIndex { offset, min_length, from_end }),\n-                ProjectionElem::Subslice { from, to, from_end } => {\n-                    local_projection.push(ProjectionElem::Subslice { from, to, from_end })\n+                    ancestor_ty = field_ty;\n+                    opt_variant_idx = None;\n                 }\n-                ProjectionElem::Downcast(sym, variant_idx) => {\n-                    local_projection.push(ProjectionElem::Downcast(sym, variant_idx))\n-                }\n-                ProjectionElem::OpaqueCast(ty) => {\n-                    local_projection.push(ProjectionElem::OpaqueCast(ty))\n+                _ => {\n+                    let proj = upvar_proj_to_place_elem_no_field_proj(proj);\n+                    (ancestor_ty, opt_variant_idx) = project_ty(cx.tcx, ancestor_ty, proj);\n+                    local_projection.push(proj);\n                 }\n             }\n         }\n@@ -534,6 +532,81 @@ impl<'tcx> From<Place<'tcx>> for PlaceBuilder<'tcx> {\n     }\n }\n \n+fn project_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    elem: PlaceElem<'tcx>,\n+) -> (Ty<'tcx>, Option<VariantIdx>) {\n+    match elem {\n+        ProjectionElem::Deref => {\n+            let updated_ty = ty\n+                .builtin_deref(true)\n+                .unwrap_or_else(|| bug!(\"deref projection of non-dereferenceable ty {:?}\", ty))\n+                .ty;\n+\n+            (updated_ty, None)\n+        }\n+        ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } => {\n+            (ty.builtin_index().unwrap(), None)\n+        }\n+        ProjectionElem::Subslice { from, to, from_end } => {\n+            let ty = match ty.kind() {\n+                ty::Slice(..) => ty,\n+                ty::Array(inner, _) if !from_end => tcx.mk_array(*inner, (to - from) as u64),\n+                ty::Array(inner, size) if from_end => {\n+                    let size = size.eval_usize(tcx, ty::ParamEnv::empty());\n+                    let len = size - (from as u64) - (to as u64);\n+                    tcx.mk_array(*inner, len)\n+                }\n+                _ => bug!(\"cannot subslice non-array type: `{:?}`\", ty),\n+            };\n+\n+            (ty, None)\n+        }\n+        ProjectionElem::Downcast(_, variant_idx) => (ty, Some(variant_idx)),\n+        ProjectionElem::Field(_, ty) => {\n+            if matches!(ty.kind(), ty::Infer(..)) {\n+                bug!(\"Field ty should have been resolved\");\n+            }\n+\n+            (ty, None)\n+        }\n+        ProjectionElem::OpaqueCast(..) => bug!(\"didn't expect OpaqueCast\"),\n+    }\n+}\n+\n+fn local_projections_to_ty<'a, 'tcx>(\n+    cx: &'a Builder<'a, 'tcx>,\n+    local: Local,\n+    projection: &'a [PlaceElem<'tcx>],\n+) -> (Ty<'tcx>, Option<VariantIdx>) {\n+    let local_ty = cx.local_decls.local_decls()[local].ty;\n+    projection.iter().fold((local_ty, None), |ty_variant_idx, elem| {\n+        let ty = ty_variant_idx.0;\n+        project_ty(cx.tcx, ty, *elem)\n+    })\n+}\n+\n+// Converts an `UpvarProjectionElem` to `PlaceElem`, ICE'ing when being passed a\n+// field projection.\n+fn upvar_proj_to_place_elem_no_field_proj<'tcx>(\n+    upvar_proj: UpvarProjectionElem<'tcx>,\n+) -> PlaceElem<'tcx> {\n+    match upvar_proj {\n+        ProjectionElem::Deref => ProjectionElem::Deref,\n+        ProjectionElem::Index(i) => ProjectionElem::Index(i),\n+        ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+            ProjectionElem::ConstantIndex { offset, min_length, from_end }\n+        }\n+        ProjectionElem::Subslice { from, to, from_end } => {\n+            ProjectionElem::Subslice { from, to, from_end }\n+        }\n+        ProjectionElem::Downcast(ty, variant_idx) => ProjectionElem::Downcast(ty, variant_idx),\n+        ProjectionElem::OpaqueCast(ty) => ProjectionElem::OpaqueCast(ty),\n+        ProjectionElem::Field(..) => bug!(\"should not be called with `ProjectionElem::Field`\"),\n+    }\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a place that we can move from etc.\n     ///"}]}