{"sha": "f4850f7292efa33759b4f7f9b7621268979e9914", "node_id": "C_kwDOAAsO6NoAKGY0ODUwZjcyOTJlZmEzMzc1OWI0ZjdmOWI3NjIxMjY4OTc5ZTk5MTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-21T19:16:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-21T19:16:14Z"}, "message": "Auto merge of #9881 - flip1995:rustup, r=flip1995\n\nRustup\n\nr? `@ghost`\n\nIt took >4 weeks, but I finally got to do the sync \ud83c\udf89\n\nchangelog: none", "tree": {"sha": "d29792ae44e057b928bf21513db1cef6634d1f4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d29792ae44e057b928bf21513db1cef6634d1f4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4850f7292efa33759b4f7f9b7621268979e9914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4850f7292efa33759b4f7f9b7621268979e9914", "html_url": "https://github.com/rust-lang/rust/commit/f4850f7292efa33759b4f7f9b7621268979e9914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4850f7292efa33759b4f7f9b7621268979e9914/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51ec465cc3dfb62a2dad7e808b399fa76a1c9170", "url": "https://api.github.com/repos/rust-lang/rust/commits/51ec465cc3dfb62a2dad7e808b399fa76a1c9170", "html_url": "https://github.com/rust-lang/rust/commit/51ec465cc3dfb62a2dad7e808b399fa76a1c9170"}, {"sha": "05b914a92b9385066c756c9fc59822545e0fbe0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/05b914a92b9385066c756c9fc59822545e0fbe0a", "html_url": "https://github.com/rust-lang/rust/commit/05b914a92b9385066c756c9fc59822545e0fbe0a"}], "stats": {"total": 1334, "additions": 631, "deletions": 703}, "files": [{"sha": "6bdac84ada003bd56778d3bd6c5dc569eaae9f61", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "dcadd012a44d35a084f3f5924814904fcfa44ff2", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "df92579a85df280a7846addaad0aa94045ed4fc1", "filename": "clippy_lints/src/almost_complete_letter_range.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Falmost_complete_letter_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Falmost_complete_letter_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Falmost_complete_letter_range.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -73,12 +73,21 @@ impl EarlyLintPass for AlmostCompleteLetterRange {\n }\n \n fn check_range(cx: &EarlyContext<'_>, span: Span, start: &Expr, end: &Expr, sugg: Option<(Span, &str)>) {\n-    if let ExprKind::Lit(start_lit) = &start.peel_parens().kind\n-        && let ExprKind::Lit(end_lit) = &end.peel_parens().kind\n+    if let ExprKind::Lit(start_token_lit) = start.peel_parens().kind\n+        && let ExprKind::Lit(end_token_lit) = end.peel_parens().kind\n         && matches!(\n-            (&start_lit.kind, &end_lit.kind),\n-            (LitKind::Byte(b'a') | LitKind::Char('a'), LitKind::Byte(b'z') | LitKind::Char('z'))\n-            | (LitKind::Byte(b'A') | LitKind::Char('A'), LitKind::Byte(b'Z') | LitKind::Char('Z'))\n+            (\n+                LitKind::from_token_lit(start_token_lit),\n+                LitKind::from_token_lit(end_token_lit),\n+            ),\n+            (\n+                Ok(LitKind::Byte(b'a') | LitKind::Char('a')),\n+                Ok(LitKind::Byte(b'z') | LitKind::Char('z'))\n+            )\n+            | (\n+                Ok(LitKind::Byte(b'A') | LitKind::Char('A')),\n+                Ok(LitKind::Byte(b'Z') | LitKind::Char('Z')),\n+            )\n         )\n         && !in_external_macro(cx.sess(), span)\n     {"}, {"sha": "b9509ca656f7a170117e115cf0a6cd47023eee80", "filename": "clippy_lints/src/casts/ptr_as_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: Option<RustcVer\n             (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n         // The `U` in `pointer::cast` have to be `Sized`\n         // as explained here: https://github.com/rust-lang/rust/issues/60602.\n-        if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n+        if to_pointee_ty.is_sized(cx.tcx, cx.param_env);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);"}, {"sha": "e38f77268530113414767597feb7ccb767804ae2", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for CopyIterator {\n                 of_trait: Some(ref trait_ref),\n                 ..\n             }) = item.kind;\n-            let ty = cx.tcx.type_of(item.def_id);\n+            let ty = cx.tcx.type_of(item.owner_id);\n             if is_copy(cx, ty);\n             if let Some(trait_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Iterator, trait_id);"}, {"sha": "dec357ab75c3662064a0e1794758b9abb005f037", "filename": "clippy_lints/src/default_union_representation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fdefault_union_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fdefault_union_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_union_representation.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultUnionRepresentation {\n                 None,\n                 &format!(\n                     \"consider annotating `{}` with `#[repr(C)]` to explicitly specify memory layout\",\n-                    cx.tcx.def_path_str(item.def_id.to_def_id())\n+                    cx.tcx.def_path_str(item.owner_id.to_def_id())\n                 ),\n             );\n         }"}, {"sha": "9da64ffc13e169d93faae6c153f15c4845a80883", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::{\n };\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n+use rustc_span::{symbol::sym, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n use std::collections::VecDeque;\n@@ -714,47 +714,47 @@ fn walk_parents<'tcx>(\n             },\n             Node::Item(&Item {\n                 kind: ItemKind::Static(..) | ItemKind::Const(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             })\n             | Node::TraitItem(&TraitItem {\n                 kind: TraitItemKind::Const(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             })\n             | Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Const(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             }) if span.ctxt() == ctxt => {\n-                let ty = cx.tcx.type_of(def_id.def_id);\n+                let ty = cx.tcx.type_of(owner_id.def_id);\n                 Some(ty_auto_deref_stability(cx, ty, precedence).position_for_result(cx))\n             },\n \n             Node::Item(&Item {\n                 kind: ItemKind::Fn(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             })\n             | Node::TraitItem(&TraitItem {\n                 kind: TraitItemKind::Fn(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             })\n             | Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Fn(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             }) if span.ctxt() == ctxt => {\n                 let output = cx\n                     .tcx\n-                    .erase_late_bound_regions(cx.tcx.fn_sig(def_id.to_def_id()).output());\n+                    .erase_late_bound_regions(cx.tcx.fn_sig(owner_id.to_def_id()).output());\n                 Some(ty_auto_deref_stability(cx, output, precedence).position_for_result(cx))\n             },\n \n@@ -1000,7 +1000,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                                 cx.typeck_results().node_type(ty.ty.hir_id),\n                                 binder_args,\n                             ))\n-                            .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                            .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n                     )\n                 }\n             },\n@@ -1015,7 +1015,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                         cx.typeck_results().node_type(ty.ty.hir_id),\n                         binder_args,\n                     ))\n-                    .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                    .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n             ),\n             TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::TraitObject(..) | TyKind::Err => {\n                 Position::ReborrowStable(precedence)\n@@ -1116,7 +1116,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n         .iter()\n         .filter_map(|predicate| {\n             if let PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder()\n-                && trait_predicate.self_ty() == param_ty.to_ty(cx.tcx)\n+                && trait_predicate.trait_ref.self_ty() == param_ty.to_ty(cx.tcx)\n             {\n                 Some(trait_predicate.trait_ref.def_id)\n             } else {\n@@ -1188,7 +1188,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n             }\n \n             let predicate = EarlyBinder(predicate).subst(cx.tcx, &substs_with_referent_ty);\n-            let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n+            let obligation = Obligation::new(cx.tcx, ObligationCause::dummy(), cx.param_env, predicate);\n             let infcx = cx.tcx.infer_ctxt().build();\n             infcx.predicate_must_hold_modulo_regions(&obligation)\n         })\n@@ -1362,7 +1362,7 @@ impl<'tcx> TyPosition<'tcx> {\n     fn position_for_result(self, cx: &LateContext<'tcx>) -> Position {\n         match (self.position, self.ty) {\n             (Position::ReborrowStable(precedence), Some(ty)) => {\n-                Position::DerefStable(precedence, ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env))\n+                Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env))\n             },\n             (position, _) => position,\n         }\n@@ -1412,11 +1412,9 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             | ty::Closure(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Projection(_) => Position::DerefStable(\n-                precedence,\n-                ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n-            )\n-            .into(),\n+            | ty::Projection(_) => {\n+                Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds())).into()\n+            },\n         };\n     }\n }"}, {"sha": "ae8f6b794499fc47439d2a093fc45944dc47452a", "filename": "clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -70,15 +70,15 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                 self_ty,\n                 ..\n             }) = item.kind;\n-            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n+            if !cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n             if !item.span.from_expansion();\n             if let Some(def_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Default, def_id);\n             if let impl_item_hir = child.id.hir_id();\n             if let Some(Node::ImplItem(impl_item)) = cx.tcx.hir().find(impl_item_hir);\n             if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n             if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n-            if let Some(adt_def) = cx.tcx.type_of(item.def_id).ty_adt_def();\n+            if let Some(adt_def) = cx.tcx.type_of(item.owner_id).ty_adt_def();\n             if let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|attr| attr.doc_str().is_some());\n             if let child_attrs = cx.tcx.hir().attrs(impl_item_hir);"}, {"sha": "102a02138bc87e783bf179bc0d7da5a6ae6044e2", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -210,8 +210,8 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n             ..\n         }) = item.kind\n         {\n-            let ty = cx.tcx.type_of(item.def_id);\n-            let is_automatically_derived = cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n+            let ty = cx.tcx.type_of(item.owner_id);\n+            let is_automatically_derived = cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n             check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "4557e43288542eac8e232f059e0257039ce27ddd", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -294,15 +294,15 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let Some(headers) = check_attrs(cx, &self.valid_idents, attrs) else { return };\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, _, body_id) => {\n-                if !(is_entrypoint_fn(cx, item.def_id.to_def_id()) || in_external_macro(cx.tcx.sess, item.span)) {\n+                if !(is_entrypoint_fn(cx, item.owner_id.to_def_id()) || in_external_macro(cx.tcx.sess, item.span)) {\n                     let body = cx.tcx.hir().body(body_id);\n                     let mut fpu = FindPanicUnwrap {\n                         cx,\n-                        typeck_results: cx.tcx.typeck(item.def_id.def_id),\n+                        typeck_results: cx.tcx.typeck(item.owner_id.def_id),\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(body.value);\n-                    lint_for_missing_headers(cx, item.def_id.def_id, sig, headers, Some(body_id), fpu.panic_span);\n+                    lint_for_missing_headers(cx, item.owner_id.def_id, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n             hir::ItemKind::Impl(impl_) => {\n@@ -312,13 +312,13 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                 (false, hir::Unsafety::Unsafe) => span_lint(\n                     cx,\n                     MISSING_SAFETY_DOC,\n-                    cx.tcx.def_span(item.def_id),\n+                    cx.tcx.def_span(item.owner_id),\n                     \"docs for unsafe trait missing `# Safety` section\",\n                 ),\n                 (true, hir::Unsafety::Normal) => span_lint(\n                     cx,\n                     UNNECESSARY_SAFETY_DOC,\n-                    cx.tcx.def_span(item.def_id),\n+                    cx.tcx.def_span(item.owner_id),\n                     \"docs for safe trait have unnecessary `# Safety` section\",\n                 ),\n                 _ => (),\n@@ -338,7 +338,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let Some(headers) = check_attrs(cx, &self.valid_idents, attrs) else { return };\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             if !in_external_macro(cx.tcx.sess, item.span) {\n-                lint_for_missing_headers(cx, item.def_id.def_id, sig, headers, None, None);\n+                lint_for_missing_headers(cx, item.owner_id.def_id, sig, headers, None, None);\n             }\n         }\n     }\n@@ -353,11 +353,11 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n             let body = cx.tcx.hir().body(body_id);\n             let mut fpu = FindPanicUnwrap {\n                 cx,\n-                typeck_results: cx.tcx.typeck(item.def_id.def_id),\n+                typeck_results: cx.tcx.typeck(item.owner_id.def_id),\n                 panic_span: None,\n             };\n             fpu.visit_expr(body.value);\n-            lint_for_missing_headers(cx, item.def_id.def_id, sig, headers, Some(body_id), fpu.panic_span);\n+            lint_for_missing_headers(cx, item.owner_id.def_id, sig, headers, Some(body_id), fpu.panic_span);\n         }\n     }\n }\n@@ -370,7 +370,7 @@ fn lint_for_missing_headers(\n     body_id: Option<hir::BodyId>,\n     panic_span: Option<Span>,\n ) {\n-    if !cx.access_levels.is_exported(def_id) {\n+    if !cx.effective_visibilities.is_exported(def_id) {\n         return; // Private functions do not require doc comments\n     }\n \n@@ -720,6 +720,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                     false,\n                     None,\n                     false,\n+                    false,\n                 );\n                 let handler = Handler::with_emitter(false, None, Box::new(emitter));\n                 let sess = ParseSess::with_span_handler(handler, sm);"}, {"sha": "29425b2e5541791db6c485d904a38981abda173b", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -61,10 +61,10 @@ impl EarlyLintPass for DoubleParens {\n                     }\n                 }\n             },\n-            ExprKind::MethodCall(_, _, ref params, _) => {\n-                if let [ref param] = params[..] {\n-                    if let ExprKind::Paren(_) = param.kind {\n-                        span_lint(cx, DOUBLE_PARENS, param.span, msg);\n+            ExprKind::MethodCall(ref call) => {\n+                if let [ref arg] = call.args[..] {\n+                    if let ExprKind::Paren(_) = arg.kind {\n+                        span_lint(cx, DOUBLE_PARENS, arg.span, msg);\n                     }\n                 }\n             },"}, {"sha": "0570c2a1013890545e493dbd7c369ee8569859fc", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n         }\n \n         if let ItemKind::Enum(..) = item.kind {\n-            let ty = cx.tcx.type_of(item.def_id);\n+            let ty = cx.tcx.type_of(item.owner_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n             if adt.variants().is_empty() {\n                 span_lint_and_help("}, {"sha": "b77b5621b4c68be05a7fef4177687bbb13e823e4", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -265,7 +265,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n                     }\n                     // The `module_name_repetitions` lint should only trigger if the item has the module in its\n                     // name. Having the same name is accepted.\n-                    if cx.tcx.visibility(item.def_id).is_public() && item_camel.len() > mod_camel.len() {\n+                    if cx.tcx.visibility(item.owner_id).is_public() && item_camel.len() > mod_camel.len() {\n                         let matching = count_match_start(mod_camel, &item_camel);\n                         let rmatching = count_match_end(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();\n@@ -296,7 +296,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n             }\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            if !(self.avoid_breaking_exported_api && cx.access_levels.is_exported(item.def_id.def_id)) {\n+            if !(self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(item.owner_id.def_id)) {\n                 check_variant(cx, self.threshold, def, item_name, item.span);\n             }\n         }"}, {"sha": "1d09adec12f3ffe7bdf58bb5785dc947aa86f0f9", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_hir;\n use rustc_hir::intravisit;\n use rustc_hir::{self, AssocItemKind, Body, FnDecl, HirId, HirIdSet, Impl, ItemKind, Node, Pat, PatKind};\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::FakeReadCause;\n@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n                         // be sure we have `self` parameter in this function\n                         if trait_item.kind == (AssocItemKind::Fn { has_self: true }) {\n                             trait_self_ty = Some(\n-                                TraitRef::identity(cx.tcx, trait_item.id.def_id.to_def_id())\n+                                TraitRef::identity(cx.tcx, trait_item.id.owner_id.to_def_id())\n                                     .self_ty()\n                                     .skip_binder(),\n                             );\n@@ -176,13 +176,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {\n-    }\n+    fn fake_read(&mut self, _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {"}, {"sha": "1fece5d1c480917f606856b1896611b8f3d2016e", "filename": "clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -73,7 +73,7 @@ impl LateLintPass<'_> for ExhaustiveItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if_chain! {\n             if let ItemKind::Enum(..) | ItemKind::Struct(..) = item.kind;\n-            if cx.access_levels.is_exported(item.def_id.def_id);\n+            if cx.effective_visibilities.is_exported(item.owner_id.def_id);\n             let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {"}, {"sha": "9a1058470e18e6155af9a4c5a1ee711dde9553da", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n         // check for `impl From<???> for ..`\n         if_chain! {\n             if let hir::ItemKind::Impl(impl_) = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id);\n             if cx.tcx.is_diagnostic_item(sym::From, impl_trait_ref.def_id);\n             then {\n                 lint_impl_body(cx, item.span, impl_.items);\n@@ -107,7 +107,7 @@ fn lint_impl_body(cx: &LateContext<'_>, impl_span: Span, impl_items: &[hir::Impl\n                 let body = cx.tcx.hir().body(body_id);\n                 let mut fpu = FindPanicUnwrap {\n                     lcx: cx,\n-                    typeck_results: cx.tcx.typeck(impl_item.id.def_id.def_id),\n+                    typeck_results: cx.tcx.typeck(impl_item.id.owner_id.def_id),\n                     result: Vec::new(),\n                 };\n                 fpu.visit_expr(body.value);"}, {"sha": "d0fab6949604090dfb02129c971eccb4246dd7be", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n                 if format_args.format_string.parts == [kw::Empty];\n                 if arg.format.is_default();\n                 if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n-                    ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did()),\n+                    ty::Adt(adt, _) => Some(adt.did()) == cx.tcx.lang_items().string(),\n                     ty::Str => true,\n                     _ => false,\n                 };"}, {"sha": "68c5c3673fe1544fb3e3c0b80df66870afa9df52", "filename": "clippy_lints/src/format_push_string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fformat_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fformat_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_push_string.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use clippy_utils::{match_def_path, paths, peel_hir_expr_refs};\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, LangItem};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -41,7 +41,7 @@ declare_clippy_lint! {\n declare_lint_pass!(FormatPushString => [FORMAT_PUSH_STRING]);\n \n fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym::String)\n+    is_type_lang_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), LangItem::String)\n }\n fn is_format(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     if let Some(macro_def_id) = e.span.ctxt().outer_expn_data().macro_def_id {"}, {"sha": "8b24a4962fb296ca4366c36e933206b987d1fa25", "filename": "clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n             && let Some(into_trait_seg) = hir_trait_ref.path.segments.last()\n             // `impl Into<target_ty> for self_ty`\n             && let Some(GenericArgs { args: [GenericArg::Type(target_ty)], .. }) = into_trait_seg.args\n-            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n+            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id)\n             && cx.tcx.is_diagnostic_item(sym::Into, middle_trait_ref.def_id)\n         {\n             span_lint_and_then("}, {"sha": "74a60b6a0d24b4ba8ba1a70f604d9bce2d5791be", "filename": "clippy_lints/src/from_str_radix_10.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_str_radix_10.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::is_integer_literal;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def, Expr, ExprKind, PrimTy, QPath, TyKind};\n+use rustc_hir::{def, Expr, ExprKind, LangItem, PrimTy, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -98,5 +98,5 @@ impl<'tcx> LateLintPass<'tcx> for FromStrRadix10 {\n \n /// Checks if a Ty is `String` or `&str`\n fn is_ty_stringish(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    is_type_diagnostic_item(cx, ty, sym::String) || is_type_diagnostic_item(cx, ty, sym::str)\n+    is_type_lang_item(cx, ty, LangItem::String) || is_type_diagnostic_item(cx, ty, sym::str)\n }"}, {"sha": "d22bede36b419944b372f84594dd294b926442e1", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -22,9 +22,9 @@ use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n+    let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n     if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n@@ -34,7 +34,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n                 sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n-                item.def_id.def_id,\n+                item.owner_id.def_id,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 \"this function could have a `#[must_use]` attribute\",\n             );\n@@ -44,20 +44,22 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n \n pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n+        let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id.def_id).is_none()\n+        } else if is_public\n+            && !is_proc_macro(cx.sess(), attrs)\n+            && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n         {\n             check_must_use_candidate(\n                 cx,\n                 sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n-                item.def_id.def_id,\n+                item.owner_id.def_id,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 \"this method could have a `#[must_use]` attribute\",\n             );\n@@ -67,11 +69,11 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n \n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n+        let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n@@ -82,7 +84,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n                     sig.decl,\n                     body,\n                     item.span,\n-                    item.def_id.def_id,\n+                    item.owner_id.def_id,\n                     item.span.with_hi(sig.decl.output.span().hi()),\n                     \"this method could have a `#[must_use]` attribute\",\n                 );\n@@ -137,7 +139,7 @@ fn check_must_use_candidate<'tcx>(\n         || mutates_static(cx, body)\n         || in_external_macro(cx.sess(), item_span)\n         || returns_unit(decl)\n-        || !cx.access_levels.is_exported(item_id)\n+        || !cx.effective_visibilities.is_exported(item_id)\n         || is_must_use_ty(cx, return_ty(cx, cx.tcx.hir().local_def_id_to_hir_id(item_id)))\n     {\n         return;\n@@ -175,29 +177,29 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut DefIdSet)\n         return false; // ignore `_` patterns\n     }\n     if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n-        is_mutable_ty(cx, cx.tcx.typeck(pat.hir_id.owner.def_id).pat_ty(pat), pat.span, tys)\n+        is_mutable_ty(cx, cx.tcx.typeck(pat.hir_id.owner.def_id).pat_ty(pat), tys)\n     } else {\n         false\n     }\n }\n \n static KNOWN_WRAPPER_TYS: &[Symbol] = &[sym::Rc, sym::Arc];\n \n-fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut DefIdSet) -> bool {\n+fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, tys: &mut DefIdSet) -> bool {\n     match *ty.kind() {\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(adt, substs) => {\n-            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx, cx.param_env)\n                 || KNOWN_WRAPPER_TYS\n                     .iter()\n                     .any(|&sym| cx.tcx.is_diagnostic_item(sym, adt.did()))\n-                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n+                    && substs.types().any(|ty| is_mutable_ty(cx, ty, tys))\n         },\n-        ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n-        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n+        ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, tys)),\n+        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, tys),\n         ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n-            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n+            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, tys)\n         },\n         // calling something constitutes a side effect, so return true on all callables\n         // also never calls need not be used, so return true for them, too\n@@ -225,12 +227,7 @@ fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bo\n                 let mut tys = DefIdSet::default();\n                 for arg in args {\n                     if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n-                        && is_mutable_ty(\n-                            cx,\n-                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n-                            arg.span,\n-                            &mut tys,\n-                        )\n+                        && is_mutable_ty(cx, cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg), &mut tys)\n                         && is_mutated_static(arg)\n                     {\n                         return ControlFlow::Break(());\n@@ -243,12 +240,7 @@ fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bo\n                 let mut tys = DefIdSet::default();\n                 for arg in std::iter::once(receiver).chain(args.iter()) {\n                     if cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n-                        && is_mutable_ty(\n-                            cx,\n-                            cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n-                            arg.span,\n-                            &mut tys,\n-                        )\n+                        && is_mutable_ty(cx, cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg), &mut tys)\n                         && is_mutated_static(arg)\n                     {\n                         return ControlFlow::Break(());"}, {"sha": "2c0bf551fd7e2b790c5c5896b85d3e327740d79d", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -31,7 +31,7 @@ pub(super) fn check_fn<'tcx>(\n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n         let body = cx.tcx.hir().body(eid);\n-        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.def_id.def_id);\n+        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.owner_id.def_id);\n     }\n }\n \n@@ -42,7 +42,7 @@ fn check_raw_ptr<'tcx>(\n     body: &'tcx hir::Body<'tcx>,\n     def_id: LocalDefId,\n ) {\n-    if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(def_id) {\n+    if unsafety == hir::Unsafety::Normal && cx.effective_visibilities.is_exported(def_id) {\n         let raw_ptrs = iter_input_pats(decl, body)\n             .filter_map(|arg| raw_ptr_arg(cx, arg))\n             .collect::<HirIdSet>();"}, {"sha": "f7e30b051a694a84d6be001e103f067a804d58b7", "filename": "clippy_lints/src/functions/result.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fresult.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -34,9 +34,9 @@ fn result_err_ty<'tcx>(\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, large_err_threshold: u64) {\n     if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind\n-        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span)\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.owner_id.def_id, item.span)\n     {\n-        if cx.access_levels.is_exported(item.def_id.def_id) {\n+        if cx.effective_visibilities.is_exported(item.owner_id.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             check_result_unit_err(cx, err_ty, fn_header_span);\n         }\n@@ -47,10 +47,10 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, l\n pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem<'tcx>, large_err_threshold: u64) {\n     // Don't lint if method is a trait's implementation, we can't do anything about those\n     if let hir::ImplItemKind::Fn(ref sig, _) = item.kind\n-        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span)\n-        && trait_ref_of_method(cx, item.def_id.def_id).is_none()\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.owner_id.def_id, item.span)\n+        && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n     {\n-        if cx.access_levels.is_exported(item.def_id.def_id) {\n+        if cx.effective_visibilities.is_exported(item.owner_id.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             check_result_unit_err(cx, err_ty, fn_header_span);\n         }\n@@ -61,8 +61,8 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem\n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::TraitItem<'tcx>, large_err_threshold: u64) {\n     if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span) {\n-            if cx.access_levels.is_exported(item.def_id.def_id) {\n+        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.owner_id.def_id, item.span) {\n+            if cx.effective_visibilities.is_exported(item.owner_id.def_id) {\n                 check_result_unit_err(cx, err_ty, fn_header_span);\n             }\n             check_result_large_err(cx, err_ty, hir_ty.span, large_err_threshold);"}, {"sha": "64a4a3fa741bca2e6af1c40663564a3d5c3e1f83", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -111,7 +111,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(item.owner_id.def_id) {\n             return;\n         }\n "}, {"sha": "aaecc4fa8f25698e68b705906deba938d01ed6f8", "filename": "clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_to_string.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n+use clippy_utils::ty::{implements_trait, is_type_lang_item};\n use clippy_utils::{return_ty, trait_ref_of_method};\n use if_chain::if_chain;\n-use rustc_hir::{GenericParamKind, ImplItem, ImplItemKind};\n+use rustc_hir::{GenericParamKind, ImplItem, ImplItemKind, LangItem};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -105,10 +105,10 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n             if impl_item.generics.params.iter().all(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }));\n \n             // Check if return type is String\n-            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id()), sym::String);\n+            if is_type_lang_item(cx, return_ty(cx, impl_item.hir_id()), LangItem::String);\n \n             // Filters instances of to_string which are required by a trait\n-            if trait_ref_of_method(cx, impl_item.def_id.def_id).is_none();\n+            if trait_ref_of_method(cx, impl_item.owner_id.def_id).is_none();\n \n             then {\n                 show_lint(cx, impl_item);\n@@ -124,7 +124,7 @@ fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n         .expect(\"Failed to get trait ID of `Display`!\");\n \n     // Get the real type of 'self'\n-    let self_type = cx.tcx.fn_sig(item.def_id).input(0);\n+    let self_type = cx.tcx.fn_sig(item.owner_id).input(0);\n     let self_type = self_type.skip_binder().peel_refs();\n \n     // Emit either a warning or an error"}, {"sha": "1b14e525d9a84462dd3ed9e4daf24c455bcd0f97", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -2,7 +2,8 @@\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n-use rustc_ast::ast::{BinOpKind, Expr, ExprKind, Lit, LitKind};\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, LitKind};\n+use rustc_ast::token;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -52,8 +53,8 @@ enum Side {\n \n impl IntPlusOne {\n     #[expect(clippy::cast_sign_loss)]\n-    fn check_lit(lit: &Lit, target_value: i128) -> bool {\n-        if let LitKind::Int(value, ..) = lit.kind {\n+    fn check_lit(token_lit: token::Lit, target_value: i128) -> bool {\n+        if let Ok(LitKind::Int(value, ..)) = LitKind::from_token_lit(token_lit) {\n             return value == (target_value as u128);\n         }\n         false\n@@ -65,11 +66,11 @@ impl IntPlusOne {\n             (BinOpKind::Ge, ExprKind::Binary(lhskind, lhslhs, lhsrhs), _) => {\n                 match (lhskind.node, &lhslhs.kind, &lhsrhs.kind) {\n                     // `-1 + x`\n-                    (BinOpKind::Add, ExprKind::Lit(lit), _) if Self::check_lit(lit, -1) => {\n+                    (BinOpKind::Add, ExprKind::Lit(lit), _) if Self::check_lit(*lit, -1) => {\n                         Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::Lhs)\n                     },\n                     // `x - 1`\n-                    (BinOpKind::Sub, _, ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n+                    (BinOpKind::Sub, _, ExprKind::Lit(lit)) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::Lhs)\n                     },\n                     _ => None,\n@@ -79,10 +80,10 @@ impl IntPlusOne {\n             (BinOpKind::Ge, _, ExprKind::Binary(rhskind, rhslhs, rhsrhs)) if rhskind.node == BinOpKind::Add => {\n                 match (&rhslhs.kind, &rhsrhs.kind) {\n                     // `y + 1` and `1 + y`\n-                    (ExprKind::Lit(lit), _) if Self::check_lit(lit, 1) => {\n+                    (ExprKind::Lit(lit), _) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::Rhs)\n                     },\n-                    (_, ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n+                    (_, ExprKind::Lit(lit)) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::Rhs)\n                     },\n                     _ => None,\n@@ -92,10 +93,10 @@ impl IntPlusOne {\n             (BinOpKind::Le, ExprKind::Binary(lhskind, lhslhs, lhsrhs), _) if lhskind.node == BinOpKind::Add => {\n                 match (&lhslhs.kind, &lhsrhs.kind) {\n                     // `1 + x` and `x + 1`\n-                    (ExprKind::Lit(lit), _) if Self::check_lit(lit, 1) => {\n+                    (ExprKind::Lit(lit), _) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhsrhs, rhs, Side::Lhs)\n                     },\n-                    (_, ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n+                    (_, ExprKind::Lit(lit)) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, lhslhs, rhs, Side::Lhs)\n                     },\n                     _ => None,\n@@ -105,11 +106,11 @@ impl IntPlusOne {\n             (BinOpKind::Le, _, ExprKind::Binary(rhskind, rhslhs, rhsrhs)) => {\n                 match (rhskind.node, &rhslhs.kind, &rhsrhs.kind) {\n                     // `-1 + y`\n-                    (BinOpKind::Add, ExprKind::Lit(lit), _) if Self::check_lit(lit, -1) => {\n+                    (BinOpKind::Add, ExprKind::Lit(lit), _) if Self::check_lit(*lit, -1) => {\n                         Self::generate_recommendation(cx, binop, rhsrhs, lhs, Side::Rhs)\n                     },\n                     // `y - 1`\n-                    (BinOpKind::Sub, _, ExprKind::Lit(lit)) if Self::check_lit(lit, 1) => {\n+                    (BinOpKind::Sub, _, ExprKind::Lit(lit)) if Self::check_lit(*lit, 1) => {\n                         Self::generate_recommendation(cx, binop, rhslhs, lhs, Side::Rhs)\n                     },\n                     _ => None,"}, {"sha": "e76de77f195d7aedd1357fdaafbcfeb253c3feaf", "filename": "clippy_lints/src/iter_not_returning_iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for IterNotReturningIterator {\n         let name = item.ident.name.as_str();\n         if matches!(name, \"iter\" | \"iter_mut\") {\n             if let TraitItemKind::Fn(fn_sig, _) = &item.kind {\n-                check_sig(cx, name, fn_sig, item.def_id.def_id);\n+                check_sig(cx, name, fn_sig, item.owner_id.def_id);\n             }\n         }\n     }\n@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for IterNotReturningIterator {\n             )\n         {\n             if let ImplItemKind::Fn(fn_sig, _) = &item.kind {\n-                check_sig(cx, name, fn_sig, item.def_id.def_id);\n+                check_sig(cx, name, fn_sig, item.owner_id.def_id);\n             }\n         }\n     }"}, {"sha": "b18456ee523401759104bbb383178e7d87b5cb5c", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n             return;\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            let ty = cx.tcx.type_of(item.def_id);\n+            let ty = cx.tcx.type_of(item.owner_id);\n             let Adt(adt, subst) = ty.kind() else {\n                 panic!(\"already checked whether this is an enum\")\n             };"}, {"sha": "4c133c06a157ac9e0fcc6ce422bc1c2191404536", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -134,7 +134,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if item.ident.name == sym::len;\n             if let ImplItemKind::Fn(sig, _) = &item.kind;\n             if sig.decl.implicit_self.has_implicit_self();\n-            if cx.access_levels.is_exported(item.def_id.def_id);\n+            if cx.effective_visibilities.is_exported(item.owner_id.def_id);\n             if matches!(sig.decl.output, FnRetTy::Return(_));\n             if let Some(imp) = get_parent_as_impl(cx.tcx, item.hir_id());\n             if imp.of_trait.is_none();\n@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if let Some(local_id) = ty_id.as_local();\n             let ty_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n             if !is_lint_allowed(cx, LEN_WITHOUT_IS_EMPTY, ty_hir_id);\n-            if let Some(output) = parse_len_output(cx, cx.tcx.fn_sig(item.def_id).skip_binder());\n+            if let Some(output) = parse_len_output(cx, cx.tcx.fn_sig(item.owner_id).skip_binder());\n             then {\n                 let (name, kind) = match cx.tcx.hir().find(ty_hir_id) {\n                     Some(Node::ForeignItem(x)) => (x.ident.name, \"extern type\"),\n@@ -195,7 +195,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     fn is_named_self(cx: &LateContext<'_>, item: &TraitItemRef, name: Symbol) -> bool {\n         item.ident.name == name\n             && if let AssocItemKind::Fn { has_self } = item.kind {\n-                has_self && { cx.tcx.fn_sig(item.id.def_id).inputs().skip_binder().len() == 1 }\n+                has_self && { cx.tcx.fn_sig(item.id.owner_id).inputs().skip_binder().len() == 1 }\n             } else {\n                 false\n             }\n@@ -210,11 +210,11 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.def_id.def_id)\n+    if cx.effective_visibilities.is_exported(visited_trait.owner_id.def_id)\n         && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n-        fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n+        fill_trait_set(visited_trait.owner_id.to_def_id(), &mut current_and_super_traits, cx);\n         let is_empty = sym!(is_empty);\n \n         let is_empty_method_found = current_and_super_traits\n@@ -331,7 +331,7 @@ fn check_for_is_empty<'tcx>(\n             None,\n             None,\n         ),\n-        Some(is_empty) if !cx.access_levels.is_exported(is_empty.def_id.expect_local()) => (\n+        Some(is_empty) if !cx.effective_visibilities.is_exported(is_empty.def_id.expect_local()) => (\n             format!(\n                 \"{item_kind} `{}` has a public `len` method, but a private `is_empty` method\",\n                 item_name.as_str(),"}, {"sha": "db41bc67da1a7f34f1d57eef78db8d0c8f29b780", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     let span = stmt.span.to(if_.span);\n \n                     let has_interior_mutability = !cx.typeck_results().node_type(canonical_id).is_freeze(\n-                        cx.tcx.at(span),\n+                        cx.tcx,\n                         cx.param_env,\n                     );\n                     if has_interior_mutability { return; }"}, {"sha": "b481314abedc8b8f91178583863b2e5253a32ed6", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -33,6 +33,7 @@ extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_analysis;\n extern crate rustc_hir_pretty;\n+extern crate rustc_hir_typeck;\n extern crate rustc_index;\n extern crate rustc_infer;\n extern crate rustc_lexer;"}, {"sha": "d9acaa99c6d1909267a2a7902a39b328b7e617c0", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -6,11 +6,12 @@ use rustc_hir::intravisit::{\n     walk_fn_decl, walk_generic_param, walk_generics, walk_impl_item_ref, walk_item, walk_param_bound,\n     walk_poly_trait_ref, walk_trait_ref, walk_ty, Visitor,\n };\n+use rustc_hir::lang_items;\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n-    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin, TraitFn,\n-    TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n+    ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, ParamName, PolyTraitRef, PredicateOrigin, TraitFn, TraitItem,\n+    TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter as middle_nested_filter;\n@@ -102,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, id) = item.kind {\n-            let report_extra_lifetimes = trait_ref_of_method(cx, item.def_id.def_id).is_none();\n+            let report_extra_lifetimes = trait_ref_of_method(cx, item.owner_id.def_id).is_none();\n             check_fn_inner(\n                 cx,\n                 sig.decl,\n@@ -391,8 +392,6 @@ fn named_lifetime_occurrences(lts: &[RefLt]) -> Vec<(LocalDefId, usize)> {\n     occurrences\n }\n \n-const CLOSURE_TRAIT_BOUNDS: [LangItem; 3] = [LangItem::Fn, LangItem::FnMut, LangItem::FnOnce];\n-\n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n@@ -453,12 +452,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n \n     fn visit_poly_trait_ref(&mut self, poly_tref: &'tcx PolyTraitRef<'tcx>) {\n         let trait_ref = &poly_tref.trait_ref;\n-        if CLOSURE_TRAIT_BOUNDS.iter().any(|&item| {\n-            self.cx\n-                .tcx\n-                .lang_items()\n-                .require(item)\n-                .map_or(false, |id| Some(id) == trait_ref.trait_def_id())\n+        if let Some(id) = trait_ref.trait_def_id() && lang_items::FN_TRAITS.iter().any(|&item| {\n+            self.cx.tcx.lang_items().get(item) == Some(id)\n         }) {\n             let mut sub_visitor = RefVisitor::new(self.cx);\n             sub_visitor.visit_trait_ref(trait_ref);"}, {"sha": "3a7b7835c990f6adbe021b9e079b49b0c0217ce5", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -5,11 +5,13 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::numeric_literal::{NumericLiteral, Radix};\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n-use rustc_ast::ast::{Expr, ExprKind, Lit, LitKind};\n+use rustc_ast::ast::{Expr, ExprKind, LitKind};\n+use rustc_ast::token;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n use std::iter;\n \n declare_clippy_lint! {\n@@ -236,8 +238,8 @@ impl EarlyLintPass for LiteralDigitGrouping {\n             return;\n         }\n \n-        if let ExprKind::Lit(ref lit) = expr.kind {\n-            self.check_lit(cx, lit);\n+        if let ExprKind::Lit(lit) = expr.kind {\n+            self.check_lit(cx, lit, expr.span);\n         }\n     }\n }\n@@ -252,12 +254,13 @@ impl LiteralDigitGrouping {\n         }\n     }\n \n-    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: token::Lit, span: Span) {\n         if_chain! {\n-            if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(mut num_lit) = NumericLiteral::from_lit(&src, lit);\n+            if let Some(src) = snippet_opt(cx, span);\n+            if let Ok(lit_kind) = LitKind::from_token_lit(lit);\n+            if let Some(mut num_lit) = NumericLiteral::from_lit_kind(&src, &lit_kind);\n             then {\n-                if !Self::check_for_mistyped_suffix(cx, lit.span, &mut num_lit) {\n+                if !Self::check_for_mistyped_suffix(cx, span, &mut num_lit) {\n                     return;\n                 }\n \n@@ -293,14 +296,14 @@ impl LiteralDigitGrouping {\n                         | WarningType::InconsistentDigitGrouping\n                         | WarningType::UnusualByteGroupings\n                         | WarningType::LargeDigitGroups => {\n-                            !lit.span.from_expansion()\n+                            !span.from_expansion()\n                         }\n                         WarningType::DecimalRepresentation | WarningType::MistypedLiteralSuffix => {\n                             true\n                         }\n                     };\n                     if should_warn {\n-                        warning_type.display(num_lit.format(), cx, lit.span);\n+                        warning_type.display(num_lit.format(), cx, span);\n                     }\n                 }\n             }\n@@ -458,8 +461,8 @@ impl EarlyLintPass for DecimalLiteralRepresentation {\n             return;\n         }\n \n-        if let ExprKind::Lit(ref lit) = expr.kind {\n-            self.check_lit(cx, lit);\n+        if let ExprKind::Lit(lit) = expr.kind {\n+            self.check_lit(cx, lit, expr.span);\n         }\n     }\n }\n@@ -469,19 +472,20 @@ impl DecimalLiteralRepresentation {\n     pub fn new(threshold: u64) -> Self {\n         Self { threshold }\n     }\n-    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: token::Lit, span: Span) {\n         // Lint integral literals.\n         if_chain! {\n-            if let LitKind::Int(val, _) = lit.kind;\n-            if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(num_lit) = NumericLiteral::from_lit(&src, lit);\n+            if let Ok(lit_kind) = LitKind::from_token_lit(lit);\n+            if let LitKind::Int(val, _) = lit_kind;\n+            if let Some(src) = snippet_opt(cx, span);\n+            if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit_kind);\n             if num_lit.radix == Radix::Decimal;\n             if val >= u128::from(self.threshold);\n             then {\n                 let hex = format!(\"{val:#X}\");\n                 let num_lit = NumericLiteral::new(&hex, num_lit.suffix, false);\n                 let _ = Self::do_lint(num_lit.integer).map_err(|warning_type| {\n-                    warning_type.display(num_lit.format(), cx, lit.span);\n+                    warning_type.display(num_lit.format(), cx, span);\n                 });\n             }\n         }"}, {"sha": "4dae93f6028d421cd9fa7f759bcb4eaf1190959e", "filename": "clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::{get_enclosing_block, higher, path_to_local};\n use if_chain::if_chain;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{BindingAnnotation, Expr, ExprKind, HirId, Node, PatKind};\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::{mir::FakeReadCause, ty};\n@@ -113,13 +113,7 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n         }\n     }\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {\n-    }\n+    fn fake_read(&mut self, _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }\n \n impl MutatePairDelegate<'_, '_> {"}, {"sha": "b8ed9b9ec18f718b0cc56160b0966a9e0cf220a5", "filename": "clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_assert.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -69,11 +69,13 @@ impl<'tcx> LateLintPass<'tcx> for ManualAssert {\n                     \"only a `panic!` in `if`-then statement\",\n                     |diag| {\n                         // comments can be noisy, do not show them to the user\n-                        diag.tool_only_span_suggestion(\n-                                    expr.span.shrink_to_lo(),\n-                                    \"add comments back\",\n-                                    comments,\n-                                    applicability);\n+                        if !comments.is_empty() {\n+                            diag.tool_only_span_suggestion(\n+                                        expr.span.shrink_to_lo(),\n+                                        \"add comments back\",\n+                                        comments,\n+                                        applicability);\n+                        }\n                         diag.span_suggestion(\n                                     expr.span,\n                                     \"try instead\","}, {"sha": "5c6a342b3d074221eaaa9296b06e4a89c9e8e1ae", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n     AsyncGeneratorKind, Block, Body, Closure, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericArg, GenericBound,\n-    HirId, IsAsync, ItemKind, LifetimeName, Term, TraitRef, Ty, TyKind, TypeBindingKind,\n+    HirId, ItemKind, LifetimeName, Term, TraitRef, Ty, TyKind, TypeBindingKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -49,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n     ) {\n         if_chain! {\n             if let Some(header) = kind.header();\n-            if header.asyncness == IsAsync::NotAsync;\n+            if !header.asyncness.is_async();\n             // Check that this function returns `impl Future`\n             if let FnRetTy::Return(ret_ty) = decl.output;\n             if let Some((trait_ref, output_lifetimes)) = future_trait_ref(cx, ret_ty);"}, {"sha": "4877cee0cc1ea8ea8bc3b575cb38272e84a94b17", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -157,16 +157,16 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n             && def.variants.len() > 1\n         {\n             let mut iter = def.variants.iter().filter_map(|v| {\n-                let id = cx.tcx.hir().local_def_id(v.id);\n-                (matches!(v.data, hir::VariantData::Unit(_))\n+                let id = cx.tcx.hir().local_def_id(v.hir_id);\n+                (matches!(v.data, hir::VariantData::Unit(..))\n                     && v.ident.as_str().starts_with('_')\n-                    && is_doc_hidden(cx.tcx.hir().attrs(v.id)))\n+                    && is_doc_hidden(cx.tcx.hir().attrs(v.hir_id)))\n                 .then_some((id, v.span))\n             });\n             if let Some((id, span)) = iter.next()\n                 && iter.next().is_none()\n             {\n-                self.potential_enums.push((item.def_id.def_id, id, item.span, span));\n+                self.potential_enums.push((item.owner_id.def_id, id, item.span, span));\n             }\n         }\n     }"}, {"sha": "d6438ca7fec2aca306b8be7c776eef7fef382b33", "filename": "clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_retain.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use clippy_utils::{get_parent_expr, match_def_path, paths, SpanlessEq};\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n@@ -92,7 +92,7 @@ fn check_into_iter(\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n         && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &into_iter_expr.kind\n         && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n-        && cx.tcx.lang_items().require(hir::LangItem::IntoIterIntoIter).ok() == Some(into_iter_def_id)\n+        && Some(into_iter_def_id) == cx.tcx.lang_items().into_iter_fn()\n         && match_acceptable_type(cx, left_expr, msrv)\n         && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n         suggest(cx, parent_expr, left_expr, target_expr);\n@@ -140,7 +140,7 @@ fn check_to_owned(\n         && let Some(chars_expr_def_id) = cx.typeck_results().type_dependent_def_id(chars_expr.hir_id)\n         && match_def_path(cx, chars_expr_def_id, &paths::STR_CHARS)\n         && let ty = cx.typeck_results().expr_ty(str_expr).peel_refs()\n-        && is_type_diagnostic_item(cx, ty, sym::String)\n+        && is_type_lang_item(cx, ty, hir::LangItem::String)\n         && SpanlessEq::new(cx).eq_expr(left_expr, str_expr) {\n         suggest(cx, parent_expr, left_expr, filter_expr);\n     }"}, {"sha": "c20d7959fc4a258576c48ec3792fc2f90338c4cb", "filename": "clippy_lints/src/manual_string_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_string_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmanual_string_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_string_new.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -44,7 +44,7 @@ impl LateLintPass<'_> for ManualStringNew {\n         let ty = cx.typeck_results().expr_ty(expr);\n         match ty.kind() {\n             ty::Adt(adt_def, _) if adt_def.is_struct() => {\n-                if !cx.tcx.is_diagnostic_item(sym::String, adt_def.did()) {\n+                if cx.tcx.lang_items().string() != Some(adt_def.did()) {\n                     return;\n                 }\n             },"}, {"sha": "675a85ae5553a7833079969be6d354f0291bcdae", "filename": "clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,13 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n+use rustc_hir::{Arm, Expr, ExprKind, LangItem, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n \n use super::MATCH_STR_CASE_MISMATCH;\n \n@@ -59,7 +59,7 @@ impl<'a, 'tcx> MatchExprVisitor<'a, 'tcx> {\n         if let Some(case_method) = get_case_method(segment_ident) {\n             let ty = self.cx.typeck_results().expr_ty(receiver).peel_refs();\n \n-            if is_type_diagnostic_item(self.cx, ty, sym::String) || ty.kind() == &ty::Str {\n+            if is_type_lang_item(self.cx, ty, LangItem::String) || ty.kind() == &ty::Str {\n                 self.case_method = Some(case_method);\n                 return true;\n             }"}, {"sha": "4720a6e6888b88dc8a710b5ca497c3527cfdab34", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -41,7 +41,7 @@ pub(crate) trait BindInsteadOfMap {\n     const GOOD_METHOD_NAME: &'static str;\n \n     fn no_op_msg(cx: &LateContext<'_>) -> Option<String> {\n-        let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n+        let variant_id = cx.tcx.lang_items().get(Self::VARIANT_LANG_ITEM)?;\n         let item_id = cx.tcx.parent(variant_id);\n         Some(format!(\n             \"using `{}.{}({})`, which is a no-op\",\n@@ -52,7 +52,7 @@ pub(crate) trait BindInsteadOfMap {\n     }\n \n     fn lint_msg(cx: &LateContext<'_>) -> Option<String> {\n-        let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n+        let variant_id = cx.tcx.lang_items().get(Self::VARIANT_LANG_ITEM)?;\n         let item_id = cx.tcx.parent(variant_id);\n         Some(format!(\n             \"using `{}.{}(|x| {}(y))`, which is more succinctly expressed as `{}(|x| y)`\",\n@@ -144,7 +144,7 @@ pub(crate) trait BindInsteadOfMap {\n     fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) -> bool {\n         if_chain! {\n             if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def();\n-            if let Ok(vid) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM);\n+            if let Some(vid) = cx.tcx.lang_items().get(Self::VARIANT_LANG_ITEM);\n             if adt.did() == cx.tcx.parent(vid);\n             then {} else { return false; }\n         }\n@@ -181,7 +181,7 @@ pub(crate) trait BindInsteadOfMap {\n \n     fn is_variant(cx: &LateContext<'_>, res: Res) -> bool {\n         if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Ok(variant_id) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM) {\n+            if let Some(variant_id) = cx.tcx.lang_items().get(Self::VARIANT_LANG_ITEM) {\n                 return cx.tcx.parent(id) == variant_id;\n             }\n         }"}, {"sha": "89aaad359d4acf09662cd41e666620ec407ac5c6", "filename": "clippy_lints/src/methods/bytes_count_to_len.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_count_to_len.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_span::sym;\n \n use super::BYTES_COUNT_TO_LEN;\n \n@@ -20,7 +19,7 @@ pub(super) fn check<'tcx>(\n         if let Some(impl_id) = cx.tcx.impl_of_method(bytes_id);\n         if cx.tcx.type_of(impl_id).is_str();\n         let ty = cx.typeck_results().expr_ty(bytes_recv).peel_refs();\n-        if ty.is_str() || is_type_diagnostic_item(cx, ty, sym::String);\n+        if ty.is_str() || is_type_lang_item(cx, ty, hir::LangItem::String);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg("}, {"sha": "d512cc4eeae125acebd79058624d98ade6ab2d49", "filename": "clippy_lints/src/methods/bytes_nth.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,18 +1,17 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use rustc_errors::Applicability;\n-use rustc_hir::Expr;\n+use rustc_hir::{Expr, LangItem};\n use rustc_lint::LateContext;\n-use rustc_span::sym;\n \n use super::BYTES_NTH;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx Expr<'tcx>, n_arg: &'tcx Expr<'tcx>) {\n     let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n     let caller_type = if ty.is_str() {\n         \"str\"\n-    } else if is_type_diagnostic_item(cx, ty, sym::String) {\n+    } else if is_type_lang_item(cx, ty, LangItem::String) {\n         \"String\"\n     } else {\n         return;"}, {"sha": "d226c0bba6593f4fccfc89237d866d8d8d1784e2", "filename": "clippy_lints/src/methods/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcase_sensitive_file_extension_comparisons.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_span::{source_map::Spanned, symbol::sym, Span};\n+use rustc_span::{source_map::Spanned, Span};\n \n use super::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS;\n \n@@ -26,7 +26,7 @@ pub(super) fn check<'tcx>(\n         if ext_str.chars().skip(1).all(|c| c.is_uppercase() || c.is_ascii_digit())\n             || ext_str.chars().skip(1).all(|c| c.is_lowercase() || c.is_ascii_digit());\n         let recv_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n-        if recv_ty.is_str() || is_type_diagnostic_item(cx, recv_ty, sym::String);\n+        if recv_ty.is_str() || is_type_lang_item(cx, recv_ty, LangItem::String);\n         then {\n             span_lint_and_help(\n                 cx,"}, {"sha": "a9189b31c57108990d96fbe740632ede6cb3c6f6", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -33,7 +33,7 @@ pub(super) fn check<'tcx>(\n                     if (method_name.ident.name == sym::as_str || method_name.ident.name == sym::as_ref) && {\n                         let arg_type = cx.typeck_results().expr_ty(receiver);\n                         let base_type = arg_type.peel_refs();\n-                        *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::String)\n+                        *base_type.kind() == ty::Str || is_type_lang_item(cx, base_type, hir::LangItem::String)\n                     } {\n                         receiver\n                     } else {\n@@ -50,7 +50,7 @@ pub(super) fn check<'tcx>(\n     // converted to string.\n     fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n         let arg_ty = cx.typeck_results().expr_ty(arg);\n-        if is_type_diagnostic_item(cx, arg_ty, sym::String) {\n+        if is_type_lang_item(cx, arg_ty, hir::LangItem::String) {\n             return false;\n         }\n         if let ty::Ref(_, ty, ..) = arg_ty.kind() {"}, {"sha": "5c620d0271601fb575f7c9fcfdb5c29a2bae1004", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::{is_type_diagnostic_item, walk_ptrs_ty_depth};\n+use clippy_utils::ty::{is_type_lang_item, walk_ptrs_ty_depth};\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -60,7 +60,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n         return true;\n     }\n \n-    if is_type_diagnostic_item(cx, ty, sym::String) {\n+    if is_type_lang_item(cx, ty, hir::LangItem::String) {\n         return true;\n     }\n "}, {"sha": "a08f7254053fe1a499b74a22250f06a53297c4dd", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -36,14 +36,14 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n         }\n     } else {\n         let ty = cx.typeck_results().expr_ty(e);\n-        if is_type_diagnostic_item(cx, ty, sym::String)\n+        if is_type_lang_item(cx, ty, LangItem::String)\n             || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n             || (is_type_diagnostic_item(cx, ty, sym::Cow) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {\n             let ty = ty.peel_refs();\n-            (ty.is_str() || is_type_diagnostic_item(cx, ty, sym::String)).then_some(RepeatKind::String)\n+            (ty.is_str() || is_type_lang_item(cx, ty, LangItem::String)).then_some(RepeatKind::String)\n         }\n     }\n }\n@@ -58,7 +58,7 @@ pub(super) fn check(\n     if_chain! {\n         if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n         if is_path_diagnostic_item(cx, repeat_fn, sym::iter_repeat);\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(collect_expr), sym::String);\n+        if is_type_lang_item(cx, cx.typeck_results().expr_ty(collect_expr), LangItem::String);\n         if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);\n         if let Some(iter_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n         if cx.tcx.trait_of_item(take_id) == Some(iter_trait_id);"}, {"sha": "38165ab4fb26f4053a256c012a933307538b8452", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -3348,15 +3348,15 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let name = impl_item.ident.name.as_str();\n         let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let item = cx.tcx.hir().expect_item(parent);\n-        let self_ty = cx.tcx.type_of(item.def_id);\n+        let self_ty = cx.tcx.type_of(item.owner_id);\n \n         let implements_trait = matches!(item.kind, hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }));\n         if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind {\n-            let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n+            let method_sig = cx.tcx.fn_sig(impl_item.owner_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n             let first_arg_ty_opt = method_sig.inputs().iter().next().copied();\n             // if this impl block implements a trait, lint in trait definition instead\n-            if !implements_trait && cx.access_levels.is_exported(impl_item.def_id.def_id) {\n+            if !implements_trait && cx.effective_visibilities.is_exported(impl_item.owner_id.def_id) {\n                 // check missing trait implementations\n                 for method_config in &TRAIT_METHODS {\n                     if name == method_config.method_name\n@@ -3390,7 +3390,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             if sig.decl.implicit_self.has_implicit_self()\n                     && !(self.avoid_breaking_exported_api\n-                    && cx.access_levels.is_exported(impl_item.def_id.def_id))\n+                    && cx.effective_visibilities.is_exported(impl_item.owner_id.def_id))\n                     && let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next()\n                     && let Some(first_arg_ty) = first_arg_ty_opt\n                 {\n@@ -3442,7 +3442,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             then {\n                 let first_arg_span = first_arg_ty.span;\n                 let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n-                let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id())\n+                let self_ty = TraitRef::identity(cx.tcx, item.owner_id.to_def_id())\n                     .self_ty()\n                     .skip_binder();\n                 wrong_self_convention::check(\n@@ -3461,7 +3461,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id());\n-            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id())\n+            let self_ty = TraitRef::identity(cx.tcx, item.owner_id.to_def_id())\n                 .self_ty()\n                 .skip_binder();\n             if !ret_ty.contains(self_ty);"}, {"sha": "01655e860c43fa6c6c3d21f572ffc186d8dd899f", "filename": "clippy_lints/src/methods/no_effect_replace.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fno_effect_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fno_effect_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fno_effect_replace.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use clippy_utils::SpanlessEq;\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n-use rustc_hir::ExprKind;\n+use rustc_hir::{ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_span::sym;\n \n use super::NO_EFFECT_REPLACE;\n \n@@ -16,7 +15,7 @@ pub(super) fn check<'tcx>(\n     arg2: &'tcx rustc_hir::Expr<'_>,\n ) {\n     let ty = cx.typeck_results().expr_ty(expr).peel_refs();\n-    if !(ty.is_str() || is_type_diagnostic_item(cx, ty, sym::String)) {\n+    if !(ty.is_str() || is_type_lang_item(cx, ty, LangItem::String)) {\n         return;\n     }\n "}, {"sha": "a345ec813ff502f8231fc6cd777b35f042273401", "filename": "clippy_lints/src/methods/repeat_once.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Frepeat_once.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::consts::{constant_context, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use rustc_errors::Applicability;\n-use rustc_hir::Expr;\n+use rustc_hir::{Expr, LangItem};\n use rustc_lint::LateContext;\n-use rustc_span::sym;\n \n use super::REPEAT_ONCE;\n \n@@ -37,7 +36,7 @@ pub(super) fn check<'tcx>(\n                 format!(\"{}.to_vec()\", snippet(cx, recv.span, r#\"\"...\"\"#)),\n                 Applicability::MachineApplicable,\n             );\n-        } else if is_type_diagnostic_item(cx, ty, sym::String) {\n+        } else if is_type_lang_item(cx, ty, LangItem::String) {\n             span_lint_and_sugg(\n                 cx,\n                 REPEAT_ONCE,"}, {"sha": "1c031ad6acbafbda64f697eb47c202da7072a3a2", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::deref_closure_args;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use clippy_utils::{is_trait_method, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -105,7 +105,7 @@ pub(super) fn check<'tcx>(\n     else if search_method == \"find\" {\n         let is_string_or_str_slice = |e| {\n             let self_ty = cx.typeck_results().expr_ty(e).peel_refs();\n-            if is_type_diagnostic_item(cx, self_ty, sym::String) {\n+            if is_type_lang_item(cx, self_ty, hir::LangItem::String) {\n                 true\n             } else {\n                 *self_ty.kind() == ty::Str"}, {"sha": "f35d81cee8e97f969bb8b16c04ff39b494270704", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,18 +1,17 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::method_chain_args;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_span::symbol::sym;\n \n use super::STRING_EXTEND_CHARS;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n-    if !is_type_diagnostic_item(cx, obj_ty, sym::String) {\n+    if !is_type_lang_item(cx, obj_ty, hir::LangItem::String) {\n         return;\n     }\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n@@ -24,7 +23,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n             } else {\n                 \"\"\n             }\n-        } else if is_type_diagnostic_item(cx, self_ty, sym::String) {\n+        } else if is_type_lang_item(cx, self_ty, hir::LangItem::String) {\n             \"&\"\n         } else {\n             return;"}, {"sha": "4eb579af7a12a9d78569377f7dcca5e9c7974149", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n use clippy_utils::{fn_def_id, get_parent_expr};\n use rustc_errors::Applicability;\n-use rustc_hir::{def_id::DefId, Expr, ExprKind, LangItem};\n+use rustc_hir::{def_id::DefId, Expr, ExprKind};\n use rustc_lint::LateContext;\n use rustc_span::{sym, Symbol};\n \n@@ -100,5 +100,5 @@ pub fn check_for_loop_iter(\n \n /// Returns true if the named method is `IntoIterator::into_iter`.\n pub fn is_into_iter(cx: &LateContext<'_>, callee_def_id: DefId) -> bool {\n-    cx.tcx.lang_items().require(LangItem::IntoIterIntoIter) == Ok(callee_def_id)\n+    Some(callee_def_id) == cx.tcx.lang_items().into_iter_fn()\n }"}, {"sha": "087e1e4343b707b4e29a87bcd9012ecd38e6de62", "filename": "clippy_lints/src/methods/unnecessary_join.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,10 +1,10 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, ty::is_type_diagnostic_item};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::is_type_lang_item};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{Ref, Slice};\n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n \n use super::UNNECESSARY_JOIN;\n \n@@ -21,7 +21,7 @@ pub(super) fn check<'tcx>(\n         // the turbofish for collect is ::<Vec<String>>\n         if let Ref(_, ref_type, _) = collect_output_adjusted_type.kind();\n         if let Slice(slice) = ref_type.kind();\n-        if is_type_diagnostic_item(cx, *slice, sym::String);\n+        if is_type_lang_item(cx, *slice, LangItem::String);\n         // the argument for join is \"\"\n         if let ExprKind::Lit(spanned) = &join_arg.kind;\n         if let LitKind::Str(symbol, _) = spanned.node;"}, {"sha": "c7775313ecd0284a38bd866ac0a34fa4f07486af", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -7,8 +7,8 @@ use clippy_utils::visitors::find_all_ret_expressions;\n use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item, return_ty};\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_errors::Applicability;\n-use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, ItemKind, LangItem, Node};\n-use rustc_hir_analysis::check::{FnCtxt, Inherited};\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, ItemKind, Node};\n+use rustc_hir_typeck::{FnCtxt, Inherited};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::Mutability;\n@@ -378,7 +378,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n             Node::Expr(parent_expr) => {\n                 if let Some((callee_def_id, call_substs, recv, call_args)) = get_callee_substs_and_args(cx, parent_expr)\n                 {\n-                    if cx.tcx.lang_items().require(LangItem::IntoFutureIntoFuture) == Ok(callee_def_id) {\n+                    if Some(callee_def_id) == cx.tcx.lang_items().into_future_fn() {\n                         return false;\n                     }\n \n@@ -419,7 +419,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n \n                         if trait_predicates.any(|predicate| {\n                             let predicate = EarlyBinder(predicate).subst(cx.tcx, new_subst);\n-                            let obligation = Obligation::new(ObligationCause::dummy(), cx.param_env, predicate);\n+                            let obligation = Obligation::new(cx.tcx, ObligationCause::dummy(), cx.param_env, predicate);\n                             !cx.tcx.infer_ctxt().build().predicate_must_hold_modulo_regions(&obligation)\n                         }) {\n                             return false;"}, {"sha": "eda4376f200ee713c34fcfb93891aab4923e84eb", "filename": "clippy_lints/src/misc_early/literal_suffix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use rustc_ast::ast::Lit;\n use rustc_errors::Applicability;\n use rustc_lint::EarlyContext;\n+use rustc_span::Span;\n \n use super::{SEPARATED_LITERAL_SUFFIX, UNSEPARATED_LITERAL_SUFFIX};\n \n-pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &str, sugg_type: &str) {\n+pub(super) fn check(cx: &EarlyContext<'_>, lit_span: Span, lit_snip: &str, suffix: &str, sugg_type: &str) {\n     let Some(maybe_last_sep_idx) = lit_snip.len().checked_sub(suffix.len() + 1) else {\n         return; // It's useless so shouldn't lint.\n     };\n@@ -15,7 +15,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &s\n             span_lint_and_sugg(\n                 cx,\n                 SEPARATED_LITERAL_SUFFIX,\n-                lit.span,\n+                lit_span,\n                 &format!(\"{sugg_type} type suffix should not be separated by an underscore\"),\n                 \"remove the underscore\",\n                 format!(\"{}{suffix}\", &lit_snip[..maybe_last_sep_idx]),\n@@ -25,7 +25,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &s\n             span_lint_and_sugg(\n                 cx,\n                 UNSEPARATED_LITERAL_SUFFIX,\n-                lit.span,\n+                lit_span,\n                 &format!(\"{sugg_type} type suffix should be separated by an underscore\"),\n                 \"add an underscore\",\n                 format!(\"{}_{suffix}\", &lit_snip[..=maybe_last_sep_idx]),"}, {"sha": "ddb8b9173a537d15e4462efdfd7d9c5d0579bbcc", "filename": "clippy_lints/src/misc_early/mixed_case_hex_literals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast::Lit;\n use rustc_lint::EarlyContext;\n+use rustc_span::Span;\n \n use super::MIXED_CASE_HEX_LITERALS;\n \n-pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, suffix: &str, lit_snip: &str) {\n+pub(super) fn check(cx: &EarlyContext<'_>, lit_span: Span, suffix: &str, lit_snip: &str) {\n     let Some(maybe_last_sep_idx) = lit_snip.len().checked_sub(suffix.len() + 1) else {\n         return; // It's useless so shouldn't lint.\n     };\n@@ -23,7 +23,7 @@ pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, suffix: &str, lit_snip: &s\n             span_lint(\n                 cx,\n                 MIXED_CASE_HEX_LITERALS,\n-                lit.span,\n+                lit_span,\n                 \"inconsistent casing in hexadecimal literal\",\n             );\n             break;"}, {"sha": "78be6b9e23fa2f99c67dd0265d21f7a1fdd0741d", "filename": "clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -9,7 +9,8 @@ mod zero_prefixed_literal;\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::source::snippet_opt;\n-use rustc_ast::ast::{Expr, ExprKind, Generics, Lit, LitFloatType, LitIntType, LitKind, NodeId, Pat, PatKind};\n+use rustc_ast::ast::{Expr, ExprKind, Generics, LitFloatType, LitIntType, LitKind, NodeId, Pat, PatKind};\n+use rustc_ast::token;\n use rustc_ast::visit::FnKind;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n@@ -374,42 +375,43 @@ impl EarlyLintPass for MiscEarlyLints {\n             return;\n         }\n \n-        if let ExprKind::Lit(ref lit) = expr.kind {\n-            MiscEarlyLints::check_lit(cx, lit);\n+        if let ExprKind::Lit(lit) = expr.kind {\n+            MiscEarlyLints::check_lit(cx, lit, expr.span);\n         }\n         double_neg::check(cx, expr);\n     }\n }\n \n impl MiscEarlyLints {\n-    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n+    fn check_lit(cx: &EarlyContext<'_>, lit: token::Lit, span: Span) {\n         // We test if first character in snippet is a number, because the snippet could be an expansion\n         // from a built-in macro like `line!()` or a proc-macro like `#[wasm_bindgen]`.\n         // Note that this check also covers special case that `line!()` is eagerly expanded by compiler.\n         // See <https://github.com/rust-lang/rust-clippy/issues/4507> for a regression.\n         // FIXME: Find a better way to detect those cases.\n-        let lit_snip = match snippet_opt(cx, lit.span) {\n+        let lit_snip = match snippet_opt(cx, span) {\n             Some(snip) if snip.chars().next().map_or(false, |c| c.is_ascii_digit()) => snip,\n             _ => return,\n         };\n \n-        if let LitKind::Int(value, lit_int_type) = lit.kind {\n+        let lit_kind = LitKind::from_token_lit(lit);\n+        if let Ok(LitKind::Int(value, lit_int_type)) = lit_kind {\n             let suffix = match lit_int_type {\n                 LitIntType::Signed(ty) => ty.name_str(),\n                 LitIntType::Unsigned(ty) => ty.name_str(),\n                 LitIntType::Unsuffixed => \"\",\n             };\n-            literal_suffix::check(cx, lit, &lit_snip, suffix, \"integer\");\n+            literal_suffix::check(cx, span, &lit_snip, suffix, \"integer\");\n             if lit_snip.starts_with(\"0x\") {\n-                mixed_case_hex_literals::check(cx, lit, suffix, &lit_snip);\n+                mixed_case_hex_literals::check(cx, span, suffix, &lit_snip);\n             } else if lit_snip.starts_with(\"0b\") || lit_snip.starts_with(\"0o\") {\n                 // nothing to do\n             } else if value != 0 && lit_snip.starts_with('0') {\n-                zero_prefixed_literal::check(cx, lit, &lit_snip);\n+                zero_prefixed_literal::check(cx, span, &lit_snip);\n             }\n-        } else if let LitKind::Float(_, LitFloatType::Suffixed(float_ty)) = lit.kind {\n+        } else if let Ok(LitKind::Float(_, LitFloatType::Suffixed(float_ty))) = lit_kind {\n             let suffix = float_ty.name_str();\n-            literal_suffix::check(cx, lit, &lit_snip, suffix, \"float\");\n+            literal_suffix::check(cx, span, &lit_snip, suffix, \"float\");\n         }\n     }\n }"}, {"sha": "4f9578d1b25763f1f124a572e55be6ff733618e0", "filename": "clippy_lints/src/misc_early/zero_prefixed_literal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,28 +1,28 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use rustc_ast::ast::Lit;\n use rustc_errors::Applicability;\n use rustc_lint::EarlyContext;\n+use rustc_span::Span;\n \n use super::ZERO_PREFIXED_LITERAL;\n \n-pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str) {\n+pub(super) fn check(cx: &EarlyContext<'_>, lit_span: Span, lit_snip: &str) {\n     let trimmed_lit_snip = lit_snip.trim_start_matches(|c| c == '_' || c == '0');\n     span_lint_and_then(\n         cx,\n         ZERO_PREFIXED_LITERAL,\n-        lit.span,\n+        lit_span,\n         \"this is a decimal constant\",\n         |diag| {\n             diag.span_suggestion(\n-                lit.span,\n+                lit_span,\n                 \"if you mean to use a decimal constant, remove the `0` to avoid confusion\",\n                 trimmed_lit_snip.to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n             // do not advise to use octal form if the literal cannot be expressed in base 8.\n             if !lit_snip.contains(|c| c == '8' || c == '9') {\n                 diag.span_suggestion(\n-                    lit.span,\n+                    lit_span,\n                     \"if you mean to use an octal constant, use `0o`\",\n                     format!(\"0o{trimmed_lit_snip}\"),\n                     Applicability::MaybeIncorrect,"}, {"sha": "9942e8115b7f87b4c439fc9e1bc2bea6d1bbca75", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == sym::main {\n-                    let at_root = cx.tcx.local_parent(it.def_id.def_id) == CRATE_DEF_ID;\n+                    let at_root = cx.tcx.local_parent(it.owner_id.def_id) == CRATE_DEF_ID;\n                     if at_root {\n                         return;\n                     }\n@@ -156,7 +156,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             | hir::ItemKind::Use(..) => return,\n         };\n \n-        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.owner_id.to_def_id());\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         if !is_from_proc_macro(cx, it) {\n@@ -165,7 +165,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n-        let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(trait_item.owner_id.to_def_id());\n \n         let attrs = cx.tcx.hir().attrs(trait_item.hir_id());\n         if !is_from_proc_macro(cx, trait_item) {\n@@ -175,15 +175,15 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n-        if let Some(cid) = cx.tcx.associated_item(impl_item.def_id).impl_container(cx.tcx) {\n+        if let Some(cid) = cx.tcx.associated_item(impl_item.owner_id).impl_container(cx.tcx) {\n             if cx.tcx.impl_trait_ref(cid).is_some() {\n                 return;\n             }\n         } else {\n             return;\n         }\n \n-        let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(impl_item.owner_id.to_def_id());\n         let attrs = cx.tcx.hir().attrs(impl_item.hir_id());\n         if !is_from_proc_macro(cx, impl_item) {\n             self.check_missing_docs_attrs(cx, attrs, impl_item.span, article, desc);\n@@ -200,7 +200,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'tcx>, v: &'tcx hir::Variant<'_>) {\n-        let attrs = cx.tcx.hir().attrs(v.id);\n+        let attrs = cx.tcx.hir().attrs(v.hir_id);\n         if !is_from_proc_macro(cx, v) {\n             self.check_missing_docs_attrs(cx, attrs, v.span, \"a\", \"variant\");\n         }"}, {"sha": "758ce47cf114b8dc3aba594b3ba2ad3d24710a72", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(it.owner_id.def_id) {\n             return;\n         }\n         match it.kind {\n@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n                     match tit_.kind {\n                         hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => {},\n                         hir::TraitItemKind::Fn(..) => {\n-                            if cx.tcx.impl_defaultness(tit.id.def_id).has_value() {\n+                            if cx.tcx.impl_defaultness(tit.id.owner_id).has_value() {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n@@ -142,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        if !cx.access_levels.is_exported(impl_item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(impl_item.owner_id.def_id) {\n             return;\n         }\n \n@@ -151,15 +151,15 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) => return,\n         };\n \n-        let assoc_item = cx.tcx.associated_item(impl_item.def_id);\n+        let assoc_item = cx.tcx.associated_item(impl_item.owner_id);\n         let container_id = assoc_item.container_id(cx.tcx);\n         let trait_def_id = match assoc_item.container {\n             TraitContainer => Some(container_id),\n             ImplContainer => cx.tcx.impl_trait_ref(container_id).map(|t| t.def_id),\n         };\n \n         if let Some(trait_def_id) = trait_def_id {\n-            if trait_def_id.is_local() && !cx.access_levels.is_exported(impl_item.def_id.def_id) {\n+            if trait_def_id.is_local() && !cx.effective_visibilities.is_exported(impl_item.owner_id.def_id) {\n                 // If a trait is being implemented for an item, and the\n                 // trait is not exported, we don't need #[inline]\n                 return;"}, {"sha": "a651020ca6566341d086bb723d4a85af68c1187e", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n-            if trait_ref_of_method(cx, item.def_id.def_id).is_none() {\n+            if trait_ref_of_method(cx, item.owner_id.def_id).is_none() {\n                 self.check_sig(cx, item.hir_id(), sig.decl);\n             }\n         }\n@@ -153,25 +153,23 @@ impl MutableKeyType {\n             let is_keyed_type = [sym::HashMap, sym::BTreeMap, sym::HashSet, sym::BTreeSet]\n                 .iter()\n                 .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n-            if is_keyed_type && self.is_interior_mutable_type(cx, substs.type_at(0), span) {\n+            if is_keyed_type && self.is_interior_mutable_type(cx, substs.type_at(0)) {\n                 span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n             }\n         }\n     }\n \n     /// Determines if a type contains interior mutability which would affect its implementation of\n     /// [`Hash`] or [`Ord`].\n-    fn is_interior_mutable_type<'tcx>(&self, cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n+    fn is_interior_mutable_type<'tcx>(&self, cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         match *ty.kind() {\n-            Ref(_, inner_ty, mutbl) => {\n-                mutbl == hir::Mutability::Mut || self.is_interior_mutable_type(cx, inner_ty, span)\n-            },\n-            Slice(inner_ty) => self.is_interior_mutable_type(cx, inner_ty, span),\n+            Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || self.is_interior_mutable_type(cx, inner_ty),\n+            Slice(inner_ty) => self.is_interior_mutable_type(cx, inner_ty),\n             Array(inner_ty, size) => {\n                 size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n-                    && self.is_interior_mutable_type(cx, inner_ty, span)\n+                    && self.is_interior_mutable_type(cx, inner_ty)\n             },\n-            Tuple(fields) => fields.iter().any(|ty| self.is_interior_mutable_type(cx, ty, span)),\n+            Tuple(fields) => fields.iter().any(|ty| self.is_interior_mutable_type(cx, ty)),\n             Adt(def, substs) => {\n                 // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n                 // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n@@ -193,11 +191,11 @@ impl MutableKeyType {\n                 let is_box = Some(def_id) == cx.tcx.lang_items().owned_box();\n                 if is_std_collection || is_box || self.ignore_mut_def_ids.contains(&def_id) {\n                     // The type is mutable if any of its type parameters are\n-                    substs.types().any(|ty| self.is_interior_mutable_type(cx, ty, span))\n+                    substs.types().any(|ty| self.is_interior_mutable_type(cx, ty))\n                 } else {\n                     !ty.has_escaping_bound_vars()\n                         && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                        && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                        && !ty.is_freeze(cx.tcx, cx.param_env)\n                 }\n             },\n             _ => false,"}, {"sha": "bc90e131b7f3be65b1ff008599796c50d5da7f7f", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n             } else if let ty::Ref(_, ty, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind() {\n-                if ty.peel_refs().is_sized(self.cx.tcx.at(expr.span), self.cx.param_env) {\n+                if ty.peel_refs().is_sized(self.cx.tcx, self.cx.param_env) {\n                     span_lint(\n                         self.cx,\n                         MUT_MUT,"}, {"sha": "67debe7e08af6008c7ddf474c37a3c7a59e02614", "filename": "clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -180,10 +180,13 @@ fn assignment_suggestions<'tcx>(\n     let suggestions = assignments\n         .iter()\n         .flat_map(|assignment| {\n-            [\n-                assignment.span.until(assignment.rhs_span),\n-                assignment.rhs_span.shrink_to_hi().with_hi(assignment.span.hi()),\n-            ]\n+            let mut spans = vec![assignment.span.until(assignment.rhs_span)];\n+\n+            if assignment.rhs_span.hi() != assignment.span.hi() {\n+                spans.push(assignment.rhs_span.shrink_to_hi().with_hi(assignment.span.hi()));\n+            }\n+\n+            spans\n         })\n         .map(|span| (span, String::new()))\n         .collect::<Vec<(Span, String)>>();"}, {"sha": "2ef902965f66d4db276533355a4706eac991baeb", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::ptr::get_spans;\n use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{implements_trait, is_copy, is_type_diagnostic_item};\n+use clippy_utils::ty::{implements_trait, is_copy, is_type_diagnostic_item, is_type_lang_item};\n use clippy_utils::{get_trait_def_id, is_self, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n@@ -11,15 +11,15 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n     BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Mutability, Node, PatKind, QPath, TyKind,\n };\n-use rustc_hir::{HirIdMap, HirIdSet};\n-use rustc_hir_analysis::expr_use_visitor as euv;\n+use rustc_hir::{HirIdMap, HirIdSet, LangItem};\n+use rustc_hir_typeck::expr_use_visitor as euv;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, TypeVisitable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::kw;\n-use rustc_span::{sym, Span, DUMMY_SP};\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n@@ -184,7 +184,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !is_self(arg);\n                 if !ty.is_mutable_ptr();\n                 if !is_copy(cx, ty);\n-                if ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env);\n+                if ty.is_sized(cx.tcx, cx.param_env);\n                 if !allowed_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n@@ -249,7 +249,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                             }\n                         }\n \n-                        if is_type_diagnostic_item(cx, ty, sym::String) {\n+                        if is_type_lang_item(cx, ty, LangItem::String) {\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n                                 diag.span_suggestion(\n@@ -340,11 +340,5 @@ impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n \n     fn mutate(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: HirId) {}\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {\n-    }\n+    fn fake_read(&mut self, _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }"}, {"sha": "54a3c82b713daa36684d2da864cbeedc93b5abfc", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // can't be implemented for unsafe new\n                             return;\n                         }\n-                        if cx.tcx.is_doc_hidden(impl_item.def_id.def_id) {\n+                        if cx.tcx.is_doc_hidden(impl_item.owner_id.def_id) {\n                             // shouldn't be implemented when it is hidden in docs\n                             return;\n                         }\n@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                         if_chain! {\n                             if sig.decl.inputs.is_empty();\n                             if name == sym::new;\n-                            if cx.access_levels.is_reachable(impl_item.def_id.def_id);\n+                            if cx.effective_visibilities.is_reachable(impl_item.owner_id.def_id);\n                             let self_def_id = cx.tcx.hir().get_parent_item(id);\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if self_ty == return_ty(cx, id);"}, {"sha": "2a3bd4ee6ce65cadcedac6ac19558d43ac6b269a", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, InnerSpan, Span, DUMMY_SP};\n+use rustc_span::{sym, InnerSpan, Span};\n \n // FIXME: this is a correctness problem but there's no suitable\n // warn-by-default category.\n@@ -136,7 +136,7 @@ fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     // since it works when a pointer indirection involves (`Cell<*const T>`).\n     // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n     // but I'm not sure whether it's a decent way, if possible.\n-    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx, cx.param_env)\n }\n \n fn is_value_unfrozen_raw<'tcx>(\n@@ -303,7 +303,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                         if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n                         if let Some(of_assoc_item) = cx\n                             .tcx\n-                            .associated_item(impl_item.def_id)\n+                            .associated_item(impl_item.owner_id)\n                             .trait_item_def_id;\n                         if cx\n                             .tcx"}, {"sha": "714c0ff227bf829d01f535ea5fc89a944d362b91", "filename": "clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n             if let Some(trait_id) = trait_ref.trait_def_id();\n             if send_trait == trait_id;\n             if hir_impl.polarity == ImplPolarity::Positive;\n-            if let Some(ty_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n+            if let Some(ty_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id);\n             if let self_ty = ty_trait_ref.self_ty();\n             if let ty::Adt(adt_def, impl_trait_substs) = self_ty.kind();\n             then {"}, {"sha": "ae0a41db918a3447067342479161c62939e71e9e", "filename": "clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foctal_escapes.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -56,11 +56,11 @@ impl EarlyLintPass for OctalEscapes {\n             return;\n         }\n \n-        if let ExprKind::Lit(lit) = &expr.kind {\n-            if matches!(lit.token_lit.kind, LitKind::Str) {\n-                check_lit(cx, &lit.token_lit, lit.span, true);\n-            } else if matches!(lit.token_lit.kind, LitKind::ByteStr) {\n-                check_lit(cx, &lit.token_lit, lit.span, false);\n+        if let ExprKind::Lit(token_lit) = &expr.kind {\n+            if matches!(token_lit.kind, LitKind::Str) {\n+                check_lit(cx, token_lit, expr.span, true);\n+            } else if matches!(token_lit.kind, LitKind::ByteStr) {\n+                check_lit(cx, token_lit, expr.span, false);\n             }\n         }\n     }"}, {"sha": "7722a476d7b4e5182abeea83af939b5653c7bc32", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -227,33 +227,33 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n         // `skip_params` is either `0` or `1` to skip the `self` parameter in trait functions.\n         // It can't be renamed, and it can't be removed without removing it from multiple functions.\n         let (fn_id, fn_kind, skip_params) = match get_parent_node(cx.tcx, body.value.hir_id) {\n-            Some(Node::Item(i)) => (i.def_id.to_def_id(), FnKind::Fn, 0),\n+            Some(Node::Item(i)) => (i.owner_id.to_def_id(), FnKind::Fn, 0),\n             Some(Node::TraitItem(&TraitItem {\n                 kind: TraitItemKind::Fn(ref sig, _),\n-                def_id,\n+                owner_id,\n                 ..\n             })) => (\n-                def_id.to_def_id(),\n+                owner_id.to_def_id(),\n                 FnKind::TraitFn,\n                 usize::from(sig.decl.implicit_self.has_implicit_self()),\n             ),\n             Some(Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Fn(ref sig, _),\n-                def_id,\n+                owner_id,\n                 ..\n             })) => {\n                 #[allow(trivial_casts)]\n-                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, def_id.into())\n-                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n-                    && let Some(trait_item_id) = cx.tcx.associated_item(def_id).trait_item_def_id\n+                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, owner_id.into())\n+                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.owner_id)\n+                    && let Some(trait_item_id) = cx.tcx.associated_item(owner_id).trait_item_def_id\n                 {\n                     (\n                         trait_item_id,\n                         FnKind::ImplTraitFn(cx.tcx.erase_regions(trait_ref.substs) as *const _ as usize),\n                         usize::from(sig.decl.implicit_self.has_implicit_self()),\n                     )\n                 } else {\n-                    (def_id.to_def_id(), FnKind::Fn, 0)\n+                    (owner_id.to_def_id(), FnKind::Fn, 0)\n                 }\n             },\n             _ => return,"}, {"sha": "9bbf385fb5999938ff3d22c429f8ad6f14346c68", "filename": "clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -8,7 +8,7 @@ use core::ops::ControlFlow;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_lint::LateContext;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::BorrowKind;\n@@ -28,7 +28,7 @@ pub(super) fn check<'tcx>(\n             let rty = cx.typeck_results().expr_ty(rhs);\n             if_chain! {\n                 if let Some((_, lang_item)) = binop_traits(op.node);\n-                if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n+                if let Some(trait_id) = cx.tcx.lang_items().get(lang_item);\n                 let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id).def_id;\n                 if trait_ref_of_method(cx, parent_fn)\n                     .map_or(true, |t| t.path.res.def_id() != trait_id);"}, {"sha": "d7917e86a861f4fa57f5ada7f497293e51214f65", "filename": "clippy_lints/src/operators/op_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fop_ref.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -204,7 +204,7 @@ fn are_equal(cx: &LateContext<'_>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>\n         if let ty::Adt(adt_def, _) = middle_ty.kind();\n         if let Some(local_did) = adt_def.did().as_local();\n         let item = cx.tcx.hir().expect_item(local_did);\n-        let middle_ty_id = item.def_id.to_def_id();\n+        let middle_ty_id = item.owner_id.to_def_id();\n         if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n         if let Res::Def(_, hir_ty_id) = path.res;\n "}, {"sha": "377bddeaa5feabccaa30f4a6e759baf33b152741", "filename": "clippy_lints/src/option_env_unwrap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Foption_env_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Foption_env_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_env_unwrap.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::is_direct_expn_of;\n use if_chain::if_chain;\n-use rustc_ast::ast::{Expr, ExprKind};\n+use rustc_ast::ast::{Expr, ExprKind, MethodCall};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -37,8 +37,8 @@ declare_lint_pass!(OptionEnvUnwrap => [OPTION_ENV_UNWRAP]);\n impl EarlyLintPass for OptionEnvUnwrap {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path_segment, receiver, _, _) = &expr.kind;\n-            if matches!(path_segment.ident.name, sym::expect | sym::unwrap);\n+            if let ExprKind::MethodCall(box MethodCall { seg, receiver, .. }) = &expr.kind;\n+            if matches!(seg.ident.name, sym::expect | sym::unwrap);\n             if let ExprKind::Call(caller, _) = &receiver.kind;\n             if is_direct_expn_of(caller.span, \"option_env\").is_some();\n             then {"}, {"sha": "5aa3c6f2f9346b5dc39e810d751a90dba91e16c1", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: Some(ref trait_ref), items: impl_items, .. }) = item.kind;\n-            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n+            if !cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {"}, {"sha": "f9fd3645668a9959ee25a48f9fe46ba1fb9d5300", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> PassByRefOrValue {\n     }\n \n     fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, def_id: LocalDefId, decl: &FnDecl<'_>, span: Option<Span>) {\n-        if self.avoid_breaking_exported_api && cx.access_levels.is_exported(def_id) {\n+        if self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(def_id) {\n             return;\n         }\n \n@@ -261,7 +261,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n         }\n \n         if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n-            self.check_poly_fn(cx, item.def_id.def_id, method_sig.decl, None);\n+            self.check_poly_fn(cx, item.owner_id.def_id, method_sig.decl, None);\n         }\n     }\n "}, {"sha": "057b7e30642ec5bc0edd134d913bef1ec8c537e4", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,7 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use if_chain::if_chain;\n-use rustc_ast::ast::{BinOpKind, Expr, ExprKind, LitKind, UnOp};\n+use rustc_ast::ast::{BinOpKind, Expr, ExprKind, MethodCall, UnOp};\n+use rustc_ast::token;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -109,18 +110,18 @@ impl EarlyLintPass for Precedence {\n             let mut arg = operand;\n \n             let mut all_odd = true;\n-            while let ExprKind::MethodCall(path_segment, receiver, _, _) = &arg.kind {\n-                let path_segment_str = path_segment.ident.name.as_str();\n+            while let ExprKind::MethodCall(box MethodCall { seg, receiver, .. }) = &arg.kind {\n+                let seg_str = seg.ident.name.as_str();\n                 all_odd &= ALLOWED_ODD_FUNCTIONS\n                     .iter()\n-                    .any(|odd_function| **odd_function == *path_segment_str);\n+                    .any(|odd_function| **odd_function == *seg_str);\n                 arg = receiver;\n             }\n \n             if_chain! {\n                 if !all_odd;\n                 if let ExprKind::Lit(lit) = &arg.kind;\n-                if let LitKind::Int(..) | LitKind::Float(..) = &lit.kind;\n+                if let token::LitKind::Integer | token::LitKind::Float = &lit.kind;\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n                     span_lint_and_sugg("}, {"sha": "6aa5e13fe3186e31013bc94f0debdfef561cbae9", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -164,7 +164,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n             check_mut_from_ref(cx, sig, None);\n             for arg in check_fn_args(\n                 cx,\n-                cx.tcx.fn_sig(item.def_id).skip_binder().inputs(),\n+                cx.tcx.fn_sig(item.owner_id).skip_binder().inputs(),\n                 sig.decl.inputs,\n                 &[],\n             )\n@@ -188,7 +188,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n         let (item_id, sig, is_trait_item) = match parents.next() {\n             Some((_, Node::Item(i))) => {\n                 if let ItemKind::Fn(sig, ..) = &i.kind {\n-                    (i.def_id, sig, false)\n+                    (i.owner_id, sig, false)\n                 } else {\n                     return;\n                 }\n@@ -200,14 +200,14 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                     return;\n                 }\n                 if let ImplItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig, false)\n+                    (i.owner_id, sig, false)\n                 } else {\n                     return;\n                 }\n             },\n             Some((_, Node::TraitItem(i))) => {\n                 if let TraitItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig, true)\n+                    (i.owner_id, sig, true)\n                 } else {\n                     return;\n                 }\n@@ -450,7 +450,7 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                                 substs.type_at(0),\n                             ),\n                         ),\n-                        Some(sym::String) => (\n+                        _ if Some(adt.did()) == cx.tcx.lang_items().string() => (\n                             [(\"clone\", \".to_owned()\"), (\"as_str\", \"\")].as_slice(),\n                             DerefTy::Str,\n                         ),\n@@ -695,6 +695,7 @@ fn matches_preds<'tcx>(\n             .type_implements_trait(p.def_id, ty, p.substs, cx.param_env)\n             .must_apply_modulo_regions(),\n         ExistentialPredicate::Projection(p) => infcx.predicate_must_hold_modulo_regions(&Obligation::new(\n+            cx.tcx,\n             ObligationCause::dummy(),\n             cx.param_env,\n             cx.tcx.mk_predicate(Binder::bind_with_vars("}, {"sha": "5269bbd1f1acc06d510294fd2b018de8cf78c4c6", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -94,7 +94,7 @@ fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Ex\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let receiver_str = snippet_with_applicability(cx, caller.span, \"..\", &mut applicability);\n-            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx.at(caller.span), cx.param_env) &&\n+            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx, cx.param_env) &&\n                 !matches!(caller.kind, ExprKind::Call(..) | ExprKind::MethodCall(..));\n             let sugg = if let Some(else_inner) = r#else {\n                 if eq_expr_value(cx, caller, peel_blocks(else_inner)) {"}, {"sha": "c1677fb3da1c4850215dfd6a88e1ee485d4c54ed", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,12 +1,12 @@\n use clippy_utils::diagnostics::{span_lint_hir, span_lint_hir_and_then};\n use clippy_utils::mir::{visit_local_usage, LocalUsage, PossibleBorrowerMap};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{has_drop, is_copy, is_type_diagnostic_item, walk_ptrs_ty_depth};\n+use clippy_utils::ty::{has_drop, is_copy, is_type_diagnostic_item, is_type_lang_item, walk_ptrs_ty_depth};\n use clippy_utils::{fn_has_unsatisfiable_preds, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{def_id, Body, FnDecl, HirId};\n+use rustc_hir::{def_id, Body, FnDecl, HirId, LangItem};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty};\n@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n             let from_borrow = match_def_path(cx, fn_def_id, &paths::CLONE_TRAIT_METHOD)\n                 || match_def_path(cx, fn_def_id, &paths::TO_OWNED_METHOD)\n                 || (match_def_path(cx, fn_def_id, &paths::TO_STRING_METHOD)\n-                    && is_type_diagnostic_item(cx, arg_ty, sym::String));\n+                    && is_type_lang_item(cx, arg_ty, LangItem::String));\n \n             let from_deref = !from_borrow\n                 && (match_def_path(cx, fn_def_id, &paths::PATH_TO_PATH_BUF)"}, {"sha": "8e675d34a183698b970e86e0fca4f5dd27c1903d", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -69,24 +69,24 @@ impl EarlyLintPass for RedundantClosureCall {\n         if_chain! {\n             if let ast::ExprKind::Call(ref paren, _) = expr.kind;\n             if let ast::ExprKind::Paren(ref closure) = paren.kind;\n-            if let ast::ExprKind::Closure(_, _, ref r#async, _, ref decl, ref block, _) = closure.kind;\n+            if let ast::ExprKind::Closure(box ast::Closure { ref asyncness, ref fn_decl, ref body, .. }) = closure.kind;\n             then {\n                 let mut visitor = ReturnVisitor::new();\n-                visitor.visit_expr(block);\n+                visitor.visit_expr(body);\n                 if !visitor.found_return {\n                     span_lint_and_then(\n                         cx,\n                         REDUNDANT_CLOSURE_CALL,\n                         expr.span,\n                         \"try not to call a closure in the expression where it is declared\",\n                         |diag| {\n-                            if decl.inputs.is_empty() {\n+                            if fn_decl.inputs.is_empty() {\n                                 let app = Applicability::MachineApplicable;\n-                                let mut hint = Sugg::ast(cx, block, \"..\");\n+                                let mut hint = Sugg::ast(cx, body, \"..\");\n \n-                                if r#async.is_async() {\n+                                if asyncness.is_async() {\n                                     // `async x` is a syntax error, so it becomes `async { x }`\n-                                    if !matches!(block.kind, ast::ExprKind::Block(_, _)) {\n+                                    if !matches!(body.kind, ast::ExprKind::Block(_, _)) {\n                                         hint = hint.blockify();\n                                     }\n "}, {"sha": "833dc4913b46922a215653311abb91bb6da5c745", "filename": "clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -46,12 +46,12 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if_chain! {\n-            if cx.tcx.visibility(item.def_id.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n-            if !cx.access_levels.is_exported(item.def_id.def_id) && self.is_exported.last() == Some(&false);\n+            if cx.tcx.visibility(item.owner_id.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n+            if !cx.effective_visibilities.is_exported(item.owner_id.def_id) && self.is_exported.last() == Some(&false);\n             if is_not_macro_export(item);\n             then {\n                 let span = item.span.with_hi(item.ident.span.hi());\n-                let descr = cx.tcx.def_kind(item.def_id).descr(item.def_id.to_def_id());\n+                let descr = cx.tcx.def_kind(item.owner_id).descr(item.owner_id.to_def_id());\n                 span_lint_and_then(\n                     cx,\n                     REDUNDANT_PUB_CRATE,\n@@ -70,7 +70,8 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n \n         if let ItemKind::Mod { .. } = item.kind {\n-            self.is_exported.push(cx.access_levels.is_exported(item.def_id.def_id));\n+            self.is_exported\n+                .push(cx.effective_visibilities.is_exported(item.owner_id.def_id));\n         }\n     }\n "}, {"sha": "b77faf7322bd00c054a275f4249e844ec9866455", "filename": "clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -74,7 +74,7 @@ fn check_method(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_def: LocalDefId, spa\n         if !in_external_macro(cx.sess(), span);\n         if decl.implicit_self.has_implicit_self();\n         // We only show this warning for public exported methods.\n-        if cx.access_levels.is_exported(fn_def);\n+        if cx.effective_visibilities.is_exported(fn_def);\n         // We don't want to emit this lint if the `#[must_use]` attribute is already there.\n         if !cx.tcx.hir().attrs(hir_id).iter().any(|attr| attr.has_name(sym::must_use));\n         if cx.tcx.visibility(fn_def.to_def_id()).is_public();\n@@ -128,7 +128,7 @@ impl<'tcx> LateLintPass<'tcx> for ReturnSelfNotMustUse {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n         if let TraitItemKind::Fn(ref sig, _) = item.kind {\n-            check_method(cx, sig.decl, item.def_id.def_id, item.span, item.hir_id());\n+            check_method(cx, sig.decl, item.owner_id.def_id, item.span, item.hir_id());\n         }\n     }\n }"}, {"sha": "91326558cd8dc824e200f4b4e727f40d77acbd71", "filename": "clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n         for id in cx.tcx.hir().items() {\n-            if matches!(cx.tcx.def_kind(id.def_id), DefKind::Impl)\n+            if matches!(cx.tcx.def_kind(id.owner_id), DefKind::Impl)\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n                     items,"}, {"sha": "71b387c66a33084845f4b9adcb8ab930b138f672", "filename": "clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n \n         let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let item = cx.tcx.hir().expect_item(parent);\n-        let self_ty = cx.tcx.type_of(item.def_id);\n+        let self_ty = cx.tcx.type_of(item.owner_id);\n         let ret_ty = return_ty(cx, impl_item.hir_id());\n \n         // Do not check trait impls"}, {"sha": "f4705481d4e69b3131ad73ce0439ba6903092dca", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_type_lang_item;\n use clippy_utils::{get_parent_expr, is_lint_allowed, match_function_call, method_calls, paths};\n use clippy_utils::{peel_blocks, SpanlessEq};\n use if_chain::if_chain;\n@@ -190,7 +190,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n             },\n             ExprKind::Index(target, _idx) => {\n                 let e_ty = cx.typeck_results().expr_ty(target).peel_refs();\n-                if matches!(e_ty.kind(), ty::Str) || is_type_diagnostic_item(cx, e_ty, sym::String) {\n+                if matches!(e_ty.kind(), ty::Str) || is_type_lang_item(cx, e_ty, LangItem::String) {\n                     span_lint(\n                         cx,\n                         STRING_SLICE,\n@@ -205,7 +205,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n }\n \n fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym::String)\n+    is_type_lang_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), LangItem::String)\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n@@ -446,7 +446,7 @@ impl<'tcx> LateLintPass<'tcx> for StringToString {\n             if let ExprKind::MethodCall(path, self_arg, ..) = &expr.kind;\n             if path.ident.name == sym::to_string;\n             let ty = cx.typeck_results().expr_ty(self_arg);\n-            if is_type_diagnostic_item(cx, ty, sym::String);\n+            if is_type_lang_item(cx, ty, LangItem::String);\n             then {\n                 span_lint_and_help(\n                     cx,"}, {"sha": "78e83880e1a6121020f0d6e0d724fee457fe46e0", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -580,7 +580,7 @@ fn ident_difference_expr_with_base_location(\n         | (Await(_), Await(_))\n         | (Async(_, _, _), Async(_, _, _))\n         | (Block(_, _), Block(_, _))\n-        | (Closure(_, _, _, _, _, _, _), Closure(_, _, _, _, _, _, _))\n+        | (Closure(_), Closure(_))\n         | (Match(_, _), Match(_, _))\n         | (Loop(_, _), Loop(_, _))\n         | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n@@ -593,7 +593,7 @@ fn ident_difference_expr_with_base_location(\n         | (Unary(_, _), Unary(_, _))\n         | (Binary(_, _, _), Binary(_, _, _))\n         | (Tup(_), Tup(_))\n-        | (MethodCall(_, _, _, _), MethodCall(_, _, _, _))\n+        | (MethodCall(_), MethodCall(_))\n         | (Call(_, _), Call(_, _))\n         | (ConstBlock(_), ConstBlock(_))\n         | (Array(_), Array(_))"}, {"sha": "6271ea0273140e02193599843fb8bb1d8ebc23a0", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -60,8 +60,8 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n         if_chain! {\n             if let hir::ExprKind::Binary(binop, _, _) | hir::ExprKind::AssignOp(binop, ..) = expr.kind;\n             if let Some((binop_trait_lang, op_assign_trait_lang)) = binop_traits(binop.node);\n-            if let Ok(binop_trait_id) = cx.tcx.lang_items().require(binop_trait_lang);\n-            if let Ok(op_assign_trait_id) = cx.tcx.lang_items().require(op_assign_trait_lang);\n+            if let Some(binop_trait_id) = cx.tcx.lang_items().get(binop_trait_lang);\n+            if let Some(op_assign_trait_id) = cx.tcx.lang_items().get(op_assign_trait_lang);\n \n             // Check for more than one binary operation in the implemented function\n             // Linting when multiple operations are involved can result in false positives\n@@ -78,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n                 (&OP_ASSIGN_TRAITS, SUSPICIOUS_OP_ASSIGN_IMPL),\n             ]\n                 .iter()\n-                .find(|&(ts, _)| ts.iter().any(|&t| Ok(trait_id) == cx.tcx.lang_items().require(t)));\n+                .find(|&(ts, _)| ts.iter().any(|&t| Some(trait_id) == cx.tcx.lang_items().get(t)));\n             if count_binops(body.value) == 1;\n             then {\n                 span_lint("}, {"sha": "63b326048a48fe2c1f4322daa6b3d8fe10fbe573", "filename": "clippy_lints/src/trailing_empty_array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for TrailingEmptyArray {\n                 None,\n                 &format!(\n                     \"consider annotating `{}` with `#[repr(C)]` or another `repr` attribute\",\n-                    cx.tcx.def_path_str(item.def_id.to_def_id())\n+                    cx.tcx.def_path_str(item.owner_id.to_def_id())\n                 ),\n             );\n         }"}, {"sha": "34642f4b122f22f097df02fada46a66a69129192", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -5,7 +5,6 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, IntTy, Ty, TypeAndMut, UintTy};\n-use rustc_span::DUMMY_SP;\n \n #[expect(clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n@@ -210,12 +209,12 @@ fn reduce_refs<'tcx>(cx: &LateContext<'tcx>, mut from_ty: Ty<'tcx>, mut to_ty: T\n                 continue;\n             },\n             (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n-                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n+                if !unsized_ty.is_sized(cx.tcx, cx.param_env) =>\n             {\n                 (true, false)\n             },\n             (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n-                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n+                if !unsized_ty.is_sized(cx.tcx, cx.param_env) =>\n             {\n                 (false, true)\n             },"}, {"sha": "49d863ec03f1d014c575c776da02a9b3c712d1ba", "filename": "clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,5 +1,6 @@\n+use rustc_hir as hir;\n use rustc_hir::Expr;\n-use rustc_hir_analysis::check::{cast, FnCtxt, Inherited};\n+use rustc_hir_typeck::{cast, FnCtxt, Inherited};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;\n@@ -54,9 +55,14 @@ fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>\n         );\n \n         if let Ok(check) = cast::CastCheck::new(\n-            &fn_ctxt, e, from_ty, to_ty,\n+            &fn_ctxt,\n+            e,\n+            from_ty,\n+            to_ty,\n             // We won't show any error to the user, so we don't care what the span is here.\n-            DUMMY_SP, DUMMY_SP,\n+            DUMMY_SP,\n+            DUMMY_SP,\n+            hir::Constness::NotConst,\n         ) {\n             let res = check.do_check(&fn_ctxt);\n "}, {"sha": "43665a922d444750b6445975dd00fb12625fa1e2", "filename": "clippy_lints/src/types/box_collection.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -37,18 +37,26 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n fn get_std_collection(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Symbol> {\n     let param = qpath_generic_tys(qpath).next()?;\n     let id = path_def_id(cx, param)?;\n-    cx.tcx.get_diagnostic_name(id).filter(|&name| {\n-        matches!(\n-            name,\n-            sym::HashMap\n-                | sym::String\n-                | sym::Vec\n-                | sym::HashSet\n-                | sym::VecDeque\n-                | sym::LinkedList\n-                | sym::BTreeMap\n-                | sym::BTreeSet\n-                | sym::BinaryHeap\n-        )\n-    })\n+    cx.tcx\n+        .get_diagnostic_name(id)\n+        .filter(|&name| {\n+            matches!(\n+                name,\n+                sym::HashMap\n+                    | sym::Vec\n+                    | sym::HashSet\n+                    | sym::VecDeque\n+                    | sym::LinkedList\n+                    | sym::BTreeMap\n+                    | sym::BTreeSet\n+                    | sym::BinaryHeap\n+            )\n+        })\n+        .or_else(|| {\n+            cx.tcx\n+                .lang_items()\n+                .string()\n+                .filter(|did| id == *did)\n+                .map(|_| sym::String)\n+        })\n }"}, {"sha": "20978e81dc584619c5ade53fc1f15b806920fdf1", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -319,7 +319,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n                 false\n             };\n \n-        let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(id));\n+        let is_exported = cx.effective_visibilities.is_exported(cx.tcx.hir().local_def_id(id));\n \n         self.check_fn_decl(\n             cx,\n@@ -333,7 +333,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let is_exported = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_exported = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n \n         match item.kind {\n             ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(\n@@ -379,7 +379,9 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(field.hir_id));\n+        let is_exported = cx\n+            .effective_visibilities\n+            .is_exported(cx.tcx.hir().local_def_id(field.hir_id));\n \n         self.check_ty(\n             cx,\n@@ -392,7 +394,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &TraitItem<'_>) {\n-        let is_exported = cx.access_levels.is_exported(item.def_id.def_id);\n+        let is_exported = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n \n         let context = CheckTyContext {\n             is_exported,"}, {"sha": "855137b14d84bdbee4802b3659225c936aff981f", "filename": "clippy_lints/src/types/rc_buffer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -91,10 +91,10 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n     let ty = qpath_generic_tys(qpath).next()?;\n     let id = path_def_id(cx, ty)?;\n-    let path = match cx.tcx.get_diagnostic_name(id)? {\n-        sym::String => \"str\",\n-        sym::OsString => \"std::ffi::OsStr\",\n-        sym::PathBuf => \"std::path::Path\",\n+    let path = match cx.tcx.get_diagnostic_name(id) {\n+        Some(sym::OsString) => \"std::ffi::OsStr\",\n+        Some(sym::PathBuf) => \"std::path::Path\",\n+        _ if Some(id) == cx.tcx.lang_items().string() => \"str\",\n         _ => return None,\n     };\n     Some(path)"}, {"sha": "fae5385ffc848dc3d09805baac4d749f3fc5dfc4", "filename": "clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -57,7 +57,7 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             // here because `mod.rs` guarantees this lint is only run on types outside of bodies and\n             // is not run on locals.\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            if ty.has_escaping_bound_vars() || !ty.is_sized(cx.tcx.at(hir_ty.span), cx.param_env) {\n+            if ty.has_escaping_bound_vars() || !ty.is_sized(cx.tcx, cx.param_env) {\n                 return false;\n             }\n             hir_ty.span"}, {"sha": "7a3c7cd8a99fc714c1a0d3e7039a2e985f23c8bf", "filename": "clippy_lints/src/types/vec_box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -40,7 +40,7 @@ pub(super) fn check(\n             });\n             let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n             if !ty_ty.has_escaping_bound_vars();\n-            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n+            if ty_ty.is_sized(cx.tcx, cx.param_env);\n             if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n             if ty_ty_size < box_size_threshold;\n             then {"}, {"sha": "9f207d32fcfff1c4fff43c48266a9a24d72f1fa8", "filename": "clippy_lints/src/unnecessary_owned_empty_strings.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, ty::is_type_diagnostic_item};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::is_type_lang_item};\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -7,7 +7,6 @@ use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -55,13 +54,13 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryOwnedEmptyStrings {\n                         );\n                 } else {\n                     if_chain! {\n-                        if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(fun_def_id);\n+                        if Some(fun_def_id) == cx.tcx.lang_items().from_fn();\n                         if let [.., last_arg] = args;\n                         if let ExprKind::Lit(spanned) = &last_arg.kind;\n                         if let LitKind::Str(symbol, _) = spanned.node;\n                         if symbol.is_empty();\n                         let inner_expr_type = cx.typeck_results().expr_ty(inner_expr);\n-                        if is_type_diagnostic_item(cx, inner_expr_type, sym::String);\n+                        if is_type_lang_item(cx, inner_expr_type, LangItem::String);\n                         then {\n                             span_lint_and_sugg(\n                                 cx,"}, {"sha": "60b46854b4ffebb2fa84bcd8f721e19a76c2d330", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         match fn_kind {\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 let def_id = cx.tcx.hir().local_def_id(hir_id);\n-                if self.avoid_breaking_exported_api && cx.access_levels.is_exported(def_id) {\n+                if self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(def_id) {\n                     return;\n                 }\n             },"}, {"sha": "bb6fb38e9690e32a3e472c49f1462bc38fa28d1b", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -292,7 +292,7 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n /// So when we fixate on some `ident_k: pat_k`, we try to find `ident_k` in the other pattern\n /// and check that all `fp_i` where `i \u2208 ((0...n) \\ k)` between two patterns are equal.\n fn extend_with_struct_pat(\n-    qself1: &Option<ast::QSelf>,\n+    qself1: &Option<P<ast::QSelf>>,\n     path1: &ast::Path,\n     fps1: &mut [ast::PatField],\n     rest1: bool,"}, {"sha": "3538bef6e06185a13eb5a17ea1e5a9fb99816a8d", "filename": "clippy_lints/src/unused_async.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funused_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funused_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_async.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, Visitor};\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId, IsAsync, YieldSource};\n+use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId, YieldSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -68,7 +68,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAsync {\n         span: Span,\n         hir_id: HirId,\n     ) {\n-        if !span.from_expansion() && fn_kind.asyncness() == IsAsync::Async {\n+        if !span.from_expansion() && fn_kind.asyncness().is_async() {\n             let mut visitor = AsyncFnVisitor { cx, found_await: false };\n             walk_fn(&mut visitor, fn_kind, fn_decl, body.id(), hir_id);\n             if !visitor.found_await {"}, {"sha": "4ee16d9a5e4ad94d4a8631ad95ff845ed252fde4", "filename": "clippy_lints/src/unused_peekable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_peekable.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -3,7 +3,6 @@ use clippy_utils::ty::{match_type, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{fn_def_id, is_trait_method, path_to_local_id, paths, peel_ref_operators};\n use rustc_ast::Mutability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Block, Expr, ExprKind, HirId, Local, Node, PatKind, PathSegment, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter::OnlyBodies;\n@@ -132,11 +131,11 @@ impl<'tcx> Visitor<'tcx> for PeekableVisitor<'_, 'tcx> {\n                             // If the Peekable is passed to a function, stop\n                             ExprKind::Call(_, args) => {\n                                 if let Some(func_did) = fn_def_id(self.cx, expr)\n-                                    && let Ok(into_iter_did) = self\n+                                    && let Some(into_iter_did) = self\n                                         .cx\n                                         .tcx\n                                         .lang_items()\n-                                        .require(LangItem::IntoIterIntoIter)\n+                                        .into_iter_fn()\n                                     && func_did == into_iter_did\n                                 {\n                                     // Probably a for loop desugar, stop searching"}, {"sha": "aac6719a8dc0feef10b0ea7c4f1578f8732195ca", "filename": "clippy_lints/src/unused_rounding.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funused_rounding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funused_rounding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_rounding.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,5 +1,5 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, source::snippet};\n-use rustc_ast::ast::{Expr, ExprKind, LitKind};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::ast::{Expr, ExprKind, MethodCall};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -29,15 +29,18 @@ declare_clippy_lint! {\n }\n declare_lint_pass!(UnusedRounding => [UNUSED_ROUNDING]);\n \n-fn is_useless_rounding<'a>(cx: &EarlyContext<'a>, expr: &'a Expr) -> Option<(&'a str, String)> {\n-    if let ExprKind::MethodCall(name_ident, receiver, _, _) = &expr.kind\n+fn is_useless_rounding(expr: &Expr) -> Option<(&str, String)> {\n+    if let ExprKind::MethodCall(box MethodCall { seg:name_ident, receiver, .. }) = &expr.kind\n         && let method_name = name_ident.ident.name.as_str()\n         && (method_name == \"ceil\" || method_name == \"round\" || method_name == \"floor\")\n-        && let ExprKind::Lit(spanned) = &receiver.kind\n-        && let LitKind::Float(symbol, _) = spanned.kind {\n-            let f = symbol.as_str().parse::<f64>().unwrap();\n+        && let ExprKind::Lit(token_lit) = &receiver.kind\n+        && token_lit.is_semantic_float() {\n+            let mut f_str = token_lit.symbol.to_string();\n+            let f = f_str.trim_end_matches('_').parse::<f64>().unwrap();\n+            if let Some(suffix) = token_lit.suffix {\n+                f_str.push_str(suffix.as_str());\n+            }\n             if f.fract() == 0.0 {\n-                let f_str = snippet(cx, receiver.span, \"..\").to_string();\n                 Some((method_name, f_str))\n             } else {\n                 None\n@@ -49,7 +52,7 @@ fn is_useless_rounding<'a>(cx: &EarlyContext<'a>, expr: &'a Expr) -> Option<(&'a\n \n impl EarlyLintPass for UnusedRounding {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if let Some((method_name, float)) = is_useless_rounding(cx, expr) {\n+        if let Some((method_name, float)) = is_useless_rounding(expr) {\n             span_lint_and_sugg(\n                 cx,\n                 UNUSED_ROUNDING,"}, {"sha": "42bccc7212b3026216cabd16adefa30286f722db", "filename": "clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -56,12 +56,12 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n         }\n         let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let parent_item = cx.tcx.hir().expect_item(parent);\n-        let assoc_item = cx.tcx.associated_item(impl_item.def_id);\n+        let assoc_item = cx.tcx.associated_item(impl_item.owner_id);\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: None, .. }) = parent_item.kind;\n             if assoc_item.fn_has_self_parameter;\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n-            if !cx.access_levels.is_exported(impl_item.def_id.def_id) || !self.avoid_breaking_exported_api;\n+            if !cx.effective_visibilities.is_exported(impl_item.owner_id.def_id) || !self.avoid_breaking_exported_api;\n             let body = cx.tcx.hir().body(*body_id);\n             if let [self_param, ..] = body.params;\n             if !is_local_used(cx, body, self_param.pat.hir_id);"}, {"sha": "f3611d174340458fa97177f28b63ddb8ab997b2d", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n     if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n         let body = cx.tcx.hir().body(body_id);\n-        let typeck = cx.tcx.typeck(impl_item.def_id.def_id);\n+        let typeck = cx.tcx.typeck(impl_item.owner_id.def_id);\n         let mut result = Vec::new();\n         let _: Option<!> = for_each_expr(body.value, |e| {\n             // check for `expect`"}, {"sha": "1d2d3eb12e1147fd71a1bb14191e77f9da6972b3", "filename": "clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -105,7 +105,7 @@ impl LateLintPass<'_> for UpperCaseAcronyms {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &Item<'_>) {\n         // do not lint public items or in macros\n         if in_external_macro(cx.sess(), it.span)\n-            || (self.avoid_breaking_exported_api && cx.access_levels.is_exported(it.def_id.def_id))\n+            || (self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(it.owner_id.def_id))\n         {\n             return;\n         }"}, {"sha": "e2860db71a5a772a945f11bced95c435051bf8d7", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             if !is_from_proc_macro(cx, item); // expensive, should be last check\n             then {\n                 StackItem::Check {\n-                    impl_id: item.def_id.def_id,\n+                    impl_id: item.owner_id.def_id,\n                     in_body: 0,\n                     types_to_skip: std::iter::once(self_ty.hir_id).collect(),\n                 }\n@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 // trait, not in the impl of the trait.\n                 let trait_method = cx\n                     .tcx\n-                    .associated_item(impl_item.def_id)\n+                    .associated_item(impl_item.owner_id)\n                     .trait_item_def_id\n                     .expect(\"impl method matches a trait method\");\n                 let trait_method_sig = cx.tcx.fn_sig(trait_method);"}, {"sha": "3743d5d97a73585e50d2eabe9a312c3808ddfd3d", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{get_parent_expr, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId, LangItem, MatchSource};\n+use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -153,7 +153,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         }\n \n                         if_chain! {\n-                            if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(def_id);\n+                            if Some(def_id) == cx.tcx.lang_items().from_fn();\n                             if same_type_and_consts(a, b);\n \n                             then {"}, {"sha": "680935f2329e4e5037ffdf2c1f01022c962f3702", "filename": "clippy_lints/src/utils/internal_lints/invalid_paths.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -79,22 +79,22 @@ pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n         SimplifiedTypeGen::StrSimplifiedType,\n     ]\n     .iter()\n-    .flat_map(|&ty| cx.tcx.incoherent_impls(ty));\n-    for item_def_id in lang_items.items().iter().flatten().chain(incoherent_impls) {\n-        let lang_item_path = cx.get_def_path(*item_def_id);\n+    .flat_map(|&ty| cx.tcx.incoherent_impls(ty).iter().copied());\n+    for item_def_id in lang_items.iter().map(|(_, def_id)| def_id).chain(incoherent_impls) {\n+        let lang_item_path = cx.get_def_path(item_def_id);\n         if path_syms.starts_with(&lang_item_path) {\n             if let [item] = &path_syms[lang_item_path.len()..] {\n                 if matches!(\n-                    cx.tcx.def_kind(*item_def_id),\n+                    cx.tcx.def_kind(item_def_id),\n                     DefKind::Mod | DefKind::Enum | DefKind::Trait\n                 ) {\n-                    for child in cx.tcx.module_children(*item_def_id) {\n+                    for child in cx.tcx.module_children(item_def_id) {\n                         if child.ident.name == *item {\n                             return true;\n                         }\n                     }\n                 } else {\n-                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n+                    for child in cx.tcx.associated_item_def_ids(item_def_id) {\n                         if cx.tcx.item_name(*child) == *item {\n                             return true;\n                         }"}, {"sha": "08980cb12ed6b4d94e9cff29002c97815e65dbc7", "filename": "clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -91,7 +91,7 @@ impl UnnecessaryDefPath {\n     #[allow(clippy::too_many_lines)]\n     fn check_call(&mut self, cx: &LateContext<'_>, func: &Expr<'_>, args: &[Expr<'_>], span: Span) {\n         enum Item {\n-            LangItem(Symbol),\n+            LangItem(&'static str),\n             DiagnosticItem(Symbol),\n         }\n         static PATHS: &[&[&str]] = &[\n@@ -152,7 +152,7 @@ impl UnnecessaryDefPath {\n                         has_ctor,\n                     ),\n                     (0, Item::LangItem(item)) => (\n-                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n+                        format!(\"{cx_snip}.tcx.lang_items().get(LangItem::{item}) == Some({def_snip})\"),\n                         has_ctor,\n                     ),\n                     // match_trait_method\n@@ -184,7 +184,7 @@ impl UnnecessaryDefPath {\n                     (3, Item::LangItem(item)) => (\n                         format!(\n                             \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n-                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n+                                .map_or(false, |id| {cx_snip}.tcx.lang_items().get(LangItem::{item}) == Some(id))\",\n                         ),\n                         false,\n                     ),\n@@ -246,7 +246,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n \n fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n     let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n-        let &alloc = alloc.provenance().values().next()?;\n+        let &alloc = alloc.provenance().ptrs().values().next()?;\n         if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n             (alloc.inner(), ty)\n         } else {\n@@ -262,6 +262,7 @@ fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation\n     {\n         alloc\n             .provenance()\n+            .ptrs()\n             .values()\n             .map(|&alloc| {\n                 if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n@@ -293,20 +294,9 @@ fn path_from_array(exprs: &[Expr<'_>]) -> Option<Vec<String>> {\n         .collect()\n }\n \n-fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<Symbol> {\n-    if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n-        let lang_items = def_path_def_ids(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"])\n-            .next()\n-            .unwrap();\n-        let item_name = cx\n-            .tcx\n-            .adt_def(lang_items)\n-            .variants()\n-            .iter()\n-            .nth(lang_item)\n-            .unwrap()\n-            .name;\n-        Some(item_name)\n+fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<&'static str> {\n+    if let Some((lang_item, _)) = cx.tcx.lang_items().iter().find(|(_, id)| *id == def_id) {\n+        Some(lang_item.variant_name())\n     } else {\n         None\n     }"}, {"sha": "be98344470b9c5dbc2a6635b9657c820c201a47d", "filename": "clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -120,14 +120,14 @@ impl LateLintPass<'_> for WildcardImports {\n         if is_test_module_or_function(cx.tcx, item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n         }\n-        let module = cx.tcx.parent_module_from_def_id(item.def_id.def_id);\n-        if cx.tcx.visibility(item.def_id.def_id) != ty::Visibility::Restricted(module.to_def_id()) {\n+        let module = cx.tcx.parent_module_from_def_id(item.owner_id.def_id);\n+        if cx.tcx.visibility(item.owner_id.def_id) != ty::Visibility::Restricted(module.to_def_id()) {\n             return;\n         }\n         if_chain! {\n             if let ItemKind::Use(use_path, UseKind::Glob) = &item.kind;\n             if self.warn_on_all || !self.check_exceptions(item, use_path.segments);\n-            let used_imports = cx.tcx.names_imported_by_glob_use(item.def_id.def_id);\n+            let used_imports = cx.tcx.names_imported_by_glob_use(item.owner_id.def_id);\n             if !used_imports.is_empty(); // Already handled by `unused_imports`\n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "fb9f4740ecc5003922077019e7c3c12e4d634e77", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "939c61189ec8dadf090cad8f5ee3019143fa5e2a", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -75,11 +75,11 @@ pub fn eq_field_pat(l: &PatField, r: &PatField) -> bool {\n         && over(&l.attrs, &r.attrs, eq_attr)\n }\n \n-pub fn eq_qself(l: &QSelf, r: &QSelf) -> bool {\n+pub fn eq_qself(l: &P<QSelf>, r: &P<QSelf>) -> bool {\n     l.position == r.position && eq_ty(&l.ty, &r.ty)\n }\n \n-pub fn eq_maybe_qself(l: &Option<QSelf>, r: &Option<QSelf>) -> bool {\n+pub fn eq_maybe_qself(l: &Option<P<QSelf>>, r: &Option<P<QSelf>>) -> bool {\n     match (l, r) {\n         (Some(l), Some(r)) => eq_qself(l, r),\n         (None, None) => true,\n@@ -147,12 +147,23 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n         (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n         (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n-        (MethodCall(lc, ls, la, _), MethodCall(rc, rs, ra, _)) => {\n-            eq_path_seg(lc, rc) && eq_expr(ls, rs) && over(la, ra, |l, r| eq_expr(l, r))\n-        },\n+        (\n+            MethodCall(box ast::MethodCall {\n+                seg: ls,\n+                receiver: lr,\n+                args: la,\n+                ..\n+            }),\n+            MethodCall(box ast::MethodCall {\n+                seg: rs,\n+                receiver: rr,\n+                args: ra,\n+                ..\n+            }),\n+        ) => eq_path_seg(ls, rs) && eq_expr(lr, rr) && over(la, ra, |l, r| eq_expr(l, r)),\n         (Binary(lo, ll, lr), Binary(ro, rl, rr)) => lo.node == ro.node && eq_expr(ll, rl) && eq_expr(lr, rr),\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n-        (Lit(l), Lit(r)) => l.kind == r.kind,\n+        (Lit(l), Lit(r)) => l == r,\n         (Cast(l, lt), Cast(r, rt)) | (Type(l, lt), Type(r, rt)) => eq_expr(l, r) && eq_ty(lt, rt),\n         (Let(lp, le, _), Let(rp, re, _)) => eq_pat(lp, rp) && eq_expr(le, re),\n         (If(lc, lt, le), If(rc, rt, re)) => eq_expr(lc, rc) && eq_block(lt, rt) && eq_expr_opt(le, re),\n@@ -170,7 +181,26 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (AssignOp(lo, lp, lv), AssignOp(ro, rp, rv)) => lo.node == ro.node && eq_expr(lp, rp) && eq_expr(lv, rv),\n         (Field(lp, lf), Field(rp, rf)) => eq_id(*lf, *rf) && eq_expr(lp, rp),\n         (Match(ls, la), Match(rs, ra)) => eq_expr(ls, rs) && over(la, ra, eq_arm),\n-        (Closure(lb, lc, la, lm, lf, le, _), Closure(rb, rc, ra, rm, rf, re, _)) => {\n+        (\n+            Closure(box ast::Closure {\n+                binder: lb,\n+                capture_clause: lc,\n+                asyncness: la,\n+                movability: lm,\n+                fn_decl: lf,\n+                body: le,\n+                ..\n+            }),\n+            Closure(box ast::Closure {\n+                binder: rb,\n+                capture_clause: rc,\n+                asyncness: ra,\n+                movability: rm,\n+                fn_decl: rf,\n+                body: re,\n+                ..\n+            }),\n+        ) => {\n             eq_closure_binder(lb, rb)\n                 && lc == rc\n                 && la.is_async() == ra.is_async()"}, {"sha": "9e2682925a22116c71acdb6847f1572207f84d74", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -24,7 +24,7 @@ extern crate rustc_attr;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n-extern crate rustc_hir_analysis;\n+extern crate rustc_hir_typeck;\n extern crate rustc_index;\n extern crate rustc_infer;\n extern crate rustc_lexer;\n@@ -245,7 +245,7 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n /// For example, use this to check whether a function call or a pattern is `Some(..)`.\n pub fn is_res_lang_ctor(cx: &LateContext<'_>, res: Res, lang_item: LangItem) -> bool {\n     if let Res::Def(DefKind::Ctor(..), id) = res\n-        && let Ok(lang_id) = cx.tcx.lang_items().require(lang_item)\n+        && let Some(lang_id) = cx.tcx.lang_items().get(lang_item)\n         && let Some(id) = cx.tcx.opt_parent(id)\n     {\n         id == lang_id\n@@ -301,7 +301,7 @@ pub fn is_lang_item_or_ctor(cx: &LateContext<'_>, did: DefId, item: LangItem) ->\n         _ => did,\n     };\n \n-    cx.tcx.lang_items().require(item).map_or(false, |id| id == did)\n+    cx.tcx.lang_items().get(item) == Some(did)\n }\n \n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n@@ -432,6 +432,12 @@ pub fn is_expr_path_def_path(cx: &LateContext<'_>, expr: &Expr<'_>, segments: &[\n     path_def_id(cx, expr).map_or(false, |id| match_def_path(cx, id, segments))\n }\n \n+/// If `maybe_path` is a path node which resolves to an item, resolves it to a `DefId` and checks if\n+/// it matches the given lang item.\n+pub fn is_path_lang_item<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>, lang_item: LangItem) -> bool {\n+    path_def_id(cx, maybe_path).map_or(false, |id| cx.tcx.lang_items().get(lang_item) == Some(id))\n+}\n+\n /// If `maybe_path` is a path node which resolves to an item, resolves it to a `DefId` and checks if\n /// it matches the given diagnostic item.\n pub fn is_path_diagnostic_item<'tcx>(\n@@ -600,16 +606,16 @@ fn local_item_children_by_name(tcx: TyCtxt<'_>, local_id: LocalDefId, name: Symb\n         ItemKind::Mod(r#mod) => r#mod\n             .item_ids\n             .iter()\n-            .filter_map(|&item_id| res(hir.item(item_id).ident, item_id.def_id))\n+            .filter_map(|&item_id| res(hir.item(item_id).ident, item_id.owner_id))\n             .collect(),\n         ItemKind::Impl(r#impl) => r#impl\n             .items\n             .iter()\n-            .filter_map(|&ImplItemRef { ident, id, .. }| res(ident, id.def_id))\n+            .filter_map(|&ImplItemRef { ident, id, .. }| res(ident, id.owner_id))\n             .collect(),\n         ItemKind::Trait(.., trait_item_refs) => trait_item_refs\n             .iter()\n-            .filter_map(|&TraitItemRef { ident, id, .. }| res(ident, id.def_id))\n+            .filter_map(|&TraitItemRef { ident, id, .. }| res(ident, id.owner_id))\n             .collect(),\n         _ => Vec::new(),\n     }\n@@ -810,7 +816,6 @@ pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -\n /// constructor from the std library\n fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<'_>) -> bool {\n     let std_types_symbols = &[\n-        sym::String,\n         sym::Vec,\n         sym::VecDeque,\n         sym::LinkedList,\n@@ -825,9 +830,9 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n         if method.ident.name == sym::new {\n             if let Some(impl_did) = cx.tcx.impl_of_method(def_id) {\n                 if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def() {\n-                    return std_types_symbols\n-                        .iter()\n-                        .any(|&symbol| cx.tcx.is_diagnostic_item(symbol, adt.did()));\n+                    return std_types_symbols.iter().any(|&symbol| {\n+                        cx.tcx.is_diagnostic_item(symbol, adt.did()) || Some(adt.did()) == cx.tcx.lang_items().string()\n+                    });\n                 }\n             }\n         }\n@@ -884,7 +889,7 @@ fn is_default_equivalent_from(cx: &LateContext<'_>, from_func: &Expr<'_>, arg: &\n             ExprKind::Lit(hir::Lit {\n                 node: LitKind::Str(ref sym, _),\n                 ..\n-            }) => return sym.is_empty() && is_path_diagnostic_item(cx, ty, sym::String),\n+            }) => return sym.is_empty() && is_path_lang_item(cx, ty, LangItem::String),\n             ExprKind::Array([]) => return is_path_diagnostic_item(cx, ty, sym::Vec),\n             ExprKind::Repeat(_, ArrayLen::Body(len)) => {\n                 if let ExprKind::Lit(ref const_lit) = cx.tcx.hir().body(len.body).value.kind &&\n@@ -2322,7 +2327,7 @@ fn with_test_item_names(tcx: TyCtxt<'_>, module: LocalDefId, f: impl Fn(&[Symbol\n         Entry::Vacant(entry) => {\n             let mut names = Vec::new();\n             for id in tcx.hir().module_items(module) {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::Const)\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Const)\n                     && let item = tcx.hir().item(id)\n                     && let ItemKind::Const(ty, _body) = item.kind {\n                     if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {"}, {"sha": "d13b34a66cca783ea01a70426ca6316af8684471", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -199,12 +199,12 @@ pub fn first_node_in_macro(cx: &LateContext<'_>, node: &impl HirNode) -> Option<\n pub fn is_panic(cx: &LateContext<'_>, def_id: DefId) -> bool {\n     let Some(name) = cx.tcx.get_diagnostic_name(def_id) else { return false };\n     matches!(\n-        name.as_str(),\n-        \"core_panic_macro\"\n-            | \"std_panic_macro\"\n-            | \"core_panic_2015_macro\"\n-            | \"std_panic_2015_macro\"\n-            | \"core_panic_2021_macro\"\n+        name,\n+        sym::core_panic_macro\n+            | sym::std_panic_macro\n+            | sym::core_panic_2015_macro\n+            | sym::std_panic_2015_macro\n+            | sym::core_panic_2021_macro\n     )\n }\n "}, {"sha": "42bdfd4827f107ef1c2bea8b229af638cfe9f0c0", "filename": "clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::ast::{Lit, LitFloatType, LitIntType, LitKind};\n+use rustc_ast::ast::{LitFloatType, LitIntType, LitKind};\n use std::iter;\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n@@ -46,10 +46,6 @@ pub struct NumericLiteral<'a> {\n }\n \n impl<'a> NumericLiteral<'a> {\n-    pub fn from_lit(src: &'a str, lit: &Lit) -> Option<NumericLiteral<'a>> {\n-        NumericLiteral::from_lit_kind(src, &lit.kind)\n-    }\n-\n     pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n         let unsigned_src = src.strip_prefix('-').map_or(src, |s| s);\n         if lit_kind.is_numeric()"}, {"sha": "3cacdb493772138594a03114722fc2b10c9c74ff", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -12,7 +12,7 @@ use rustc_ast_pretty::pprust::token_kind_to_string;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::{Closure, ExprKind, HirId, MutTy, TyKind};\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{EarlyContext, LateContext, LintContext};\n use rustc_middle::hir::place::ProjectionKind;\n@@ -207,6 +207,7 @@ impl<'a> Sugg<'a> {\n             | ast::ExprKind::InlineAsm(..)\n             | ast::ExprKind::ConstBlock(..)\n             | ast::ExprKind::Lit(..)\n+            | ast::ExprKind::IncludedBytes(..)\n             | ast::ExprKind::Loop(..)\n             | ast::ExprKind::MacCall(..)\n             | ast::ExprKind::MethodCall(..)\n@@ -771,8 +772,7 @@ impl<T: LintContext> DiagnosticExt<T> for rustc_errors::Diagnostic {\n \n     fn suggest_remove_item(&mut self, cx: &T, item: Span, msg: &str, applicability: Applicability) {\n         let mut remove_span = item;\n-        let hi = cx.sess().source_map().next_point(remove_span).hi();\n-        let fmpos = cx.sess().source_map().lookup_byte_offset(hi);\n+        let fmpos = cx.sess().source_map().lookup_byte_offset(remove_span.hi());\n \n         if let Some(ref src) = fmpos.sf.src {\n             let non_whitespace_offset = src[fmpos.pos.to_usize()..].find(|c| c != ' ' && c != '\\t' && c != '\\n');\n@@ -1055,13 +1055,7 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n \n     fn mutate(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId) {}\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {\n-    }\n+    fn fake_read(&mut self, _: &PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }\n \n #[cfg(test)]"}, {"sha": "897edfc5495f45b87f9f04d6f042fa85c01303cd", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::{\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::symbol::Ident;\n-use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n+use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::{Size, VariantIdx};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n@@ -29,7 +29,7 @@ use crate::{match_def_path, path_res, paths};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n+    ty.is_copy_modulo_regions(cx.tcx, cx.param_env)\n }\n \n /// This checks whether a given type is known to implement Debug.\n@@ -371,11 +371,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n /// Returns `false` if the `LangItem` is not defined.\n pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => cx\n-            .tcx\n-            .lang_items()\n-            .require(lang_item)\n-            .map_or(false, |li| li == adt.did()),\n+        ty::Adt(adt, _) => cx.tcx.lang_items().get(lang_item) == Some(adt.did()),\n         _ => false,\n     }\n }\n@@ -710,21 +706,18 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n     let mut output = None;\n     let lang_items = cx.tcx.lang_items();\n \n-    for pred in cx\n+    for (pred, _) in cx\n         .tcx\n         .bound_explicit_item_bounds(ty.item_def_id)\n-        .transpose_iter()\n-        .map(|x| x.map_bound(|(p, _)| p))\n+        .subst_iter_copied(cx.tcx, ty.substs)\n     {\n-        match pred.0.kind().skip_binder() {\n+        match pred.kind().skip_binder() {\n             PredicateKind::Trait(p)\n                 if (lang_items.fn_trait() == Some(p.def_id())\n                     || lang_items.fn_mut_trait() == Some(p.def_id())\n                     || lang_items.fn_once_trait() == Some(p.def_id())) =>\n             {\n-                let i = pred\n-                    .map_bound(|pred| pred.kind().rebind(p.trait_ref.substs.type_at(1)))\n-                    .subst(cx.tcx, ty.substs);\n+                let i = pred.kind().rebind(p.trait_ref.substs.type_at(1));\n \n                 if inputs.map_or(false, |inputs| inputs != i) {\n                     // Multiple different fn trait impls. Is this even allowed?\n@@ -737,10 +730,7 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n                 }\n-                output = Some(\n-                    pred.map_bound(|pred| pred.kind().rebind(p.term.ty().unwrap()))\n-                        .subst(cx.tcx, ty.substs),\n-                );\n+                output = pred.kind().rebind(p.term.ty()).transpose();\n             },\n             _ => (),\n         }"}, {"sha": "797722cfc1fcc5c0a60b74cf9178037c4a0ed686", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -5,7 +5,7 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirIdSet;\n use rustc_hir::{Expr, ExprKind, HirId, Node};\n-use rustc_hir_analysis::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+use rustc_hir_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n@@ -73,13 +73,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n         self.update(cmt);\n     }\n \n-    fn fake_read(\n-        &mut self,\n-        _: &rustc_hir_analysis::expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _: FakeReadCause,\n-        _: HirId,\n-    ) {\n-    }\n+    fn fake_read(&mut self, _: &rustc_hir_typeck::expr_use_visitor::PlaceWithHirId<'tcx>, _: FakeReadCause, _: HirId) {}\n }\n \n pub struct ParamBindingIdCollector {"}, {"sha": "578109840fb70c44fd456aacd4105889c868bcc5", "filename": "declare_clippy_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/declare_clippy_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/declare_clippy_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/declare_clippy_lint%2FCargo.toml?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"declare_clippy_lint\"\n-version = \"0.1.66\"\n+version = \"0.1.67\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "a806c1564796ae2a5bb3b5fd5b0fde0659e17d9e", "filename": "rust-toolchain", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-10-20\"\n-components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]\n+channel = \"nightly-2022-11-21\"\n+components = [\"cargo\", \"llvm-tools\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "ee2a3ad20d3e5b0d77b0819ddd44bd2271c376ec", "filename": "src/driver.rs", "status": "modified", "additions": 11, "deletions": 67, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -24,8 +24,8 @@ use std::borrow::Cow;\n use std::env;\n use std::ops::Deref;\n use std::panic;\n-use std::path::{Path, PathBuf};\n-use std::process::{exit, Command};\n+use std::path::Path;\n+use std::process::exit;\n use std::sync::LazyLock;\n \n /// If a command-line option matches `find_arg`, then apply the predicate `pred` on its value. If\n@@ -214,6 +214,7 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         false,\n         None,\n         false,\n+        false,\n     ));\n     let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n \n@@ -244,68 +245,19 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     interface::try_print_query_stack(&handler, num_frames);\n }\n \n-fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<PathBuf> {\n-    home.and_then(|home| {\n-        toolchain.map(|toolchain| {\n-            let mut path = PathBuf::from(home);\n-            path.push(\"toolchains\");\n-            path.push(toolchain);\n-            path\n-        })\n-    })\n-}\n-\n #[allow(clippy::too_many_lines)]\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n     LazyLock::force(&ICE_HOOK);\n     exit(rustc_driver::catch_with_exit_code(move || {\n         let mut orig_args: Vec<String> = env::args().collect();\n \n-        // Get the sysroot, looking from most specific to this invocation to the least:\n-        // - command line\n-        // - runtime environment\n-        //    - SYSROOT\n-        //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n-        // - sysroot from rustc in the path\n-        // - compile-time environment\n-        //    - SYSROOT\n-        //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n-        let sys_root_arg = arg_value(&orig_args, \"--sysroot\", |_| true);\n-        let have_sys_root_arg = sys_root_arg.is_some();\n-        let sys_root = sys_root_arg\n-            .map(PathBuf::from)\n-            .or_else(|| std::env::var(\"SYSROOT\").ok().map(PathBuf::from))\n-            .or_else(|| {\n-                let home = std::env::var(\"RUSTUP_HOME\")\n-                    .or_else(|_| std::env::var(\"MULTIRUST_HOME\"))\n-                    .ok();\n-                let toolchain = std::env::var(\"RUSTUP_TOOLCHAIN\")\n-                    .or_else(|_| std::env::var(\"MULTIRUST_TOOLCHAIN\"))\n-                    .ok();\n-                toolchain_path(home, toolchain)\n-            })\n-            .or_else(|| {\n-                Command::new(\"rustc\")\n-                    .arg(\"--print\")\n-                    .arg(\"sysroot\")\n-                    .output()\n-                    .ok()\n-                    .and_then(|out| String::from_utf8(out.stdout).ok())\n-                    .map(|s| PathBuf::from(s.trim()))\n-            })\n-            .or_else(|| option_env!(\"SYSROOT\").map(PathBuf::from))\n-            .or_else(|| {\n-                let home = option_env!(\"RUSTUP_HOME\")\n-                    .or(option_env!(\"MULTIRUST_HOME\"))\n-                    .map(ToString::to_string);\n-                let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\")\n-                    .or(option_env!(\"MULTIRUST_TOOLCHAIN\"))\n-                    .map(ToString::to_string);\n-                toolchain_path(home, toolchain)\n-            })\n-            .map(|pb| pb.to_string_lossy().to_string())\n-            .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\");\n+        let sys_root_env = std::env::var(\"SYSROOT\").ok();\n+        let pass_sysroot_env_if_given = |args: &mut Vec<String>, sys_root_env| {\n+            if let Some(sys_root) = sys_root_env {\n+                args.extend(vec![\"--sysroot\".into(), sys_root]);\n+            };\n+        };\n \n         // make \"clippy-driver --rustc\" work like a subcommand that passes further args to \"rustc\"\n         // for example `clippy-driver --rustc --version` will print the rustc version that clippy-driver\n@@ -314,11 +266,8 @@ pub fn main() {\n             orig_args.remove(pos);\n             orig_args[0] = \"rustc\".to_string();\n \n-            // if we call \"rustc\", we need to pass --sysroot here as well\n             let mut args: Vec<String> = orig_args.clone();\n-            if !have_sys_root_arg {\n-                args.extend(vec![\"--sysroot\".into(), sys_root]);\n-            };\n+            pass_sysroot_env_if_given(&mut args, sys_root_env);\n \n             return rustc_driver::RunCompiler::new(&args, &mut DefaultCallbacks).run();\n         }\n@@ -343,13 +292,8 @@ pub fn main() {\n             exit(0);\n         }\n \n-        // this conditional check for the --sysroot flag is there so users can call\n-        // `clippy_driver` directly\n-        // without having to pass --sysroot or anything\n         let mut args: Vec<String> = orig_args.clone();\n-        if !have_sys_root_arg {\n-            args.extend(vec![\"--sysroot\".into(), sys_root]);\n-        };\n+        pass_sysroot_env_if_given(&mut args, sys_root_env);\n \n         let mut no_deps = false;\n         let clippy_args_var = env::var(\"CLIPPY_ARGS\").ok();"}, {"sha": "4be04f77f5bdcb7f497d89df1cbbac1ca87d88d0", "filename": "tests/ui-internal/custom_ice_message.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Fcustom_ice_message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Fcustom_ice_message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcustom_ice_message.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -2,6 +2,7 @@\n // normalize-stderr-test: \"Clippy version: .*\" -> \"Clippy version: foo\"\n // normalize-stderr-test: \"internal_lints.rs:\\d*:\\d*\" -> \"internal_lints.rs\"\n // normalize-stderr-test: \"', .*clippy_lints\" -> \"', clippy_lints\"\n+// normalize-stderr-test: \"'rustc'\" -> \"'<unnamed>'\"\n \n #![deny(clippy::internal)]\n #![allow(clippy::missing_clippy_version_attribute)]"}, {"sha": "2ba5890660fc97a774f67f81aa9ab0d44387d2a6", "filename": "tests/ui-internal/custom_ice_message.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Fcustom_ice_message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Fcustom_ice_message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcustom_ice_message.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,4 +1,4 @@\n-thread 'rustc' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints/produce_ice.rs:28:9\n+thread '<unnamed>' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints/produce_ice.rs:28:9\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n error: internal compiler error: unexpected panic"}, {"sha": "e474f370a5d172cbc4c2b4e469f1bb2daa91483b", "filename": "tests/ui-internal/unnecessary_def_path.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Funnecessary_def_path.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Funnecessary_def_path.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.fixed?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -48,14 +48,14 @@ fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n     let _ = is_type_lang_item(cx, ty, LangItem::OwnedBox);\n     let _ = is_type_diagnostic_item(cx, ty, sym::maybe_uninit_uninit);\n \n-    let _ = cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did);\n+    let _ = cx.tcx.lang_items().get(LangItem::OwnedBox) == Some(did);\n     let _ = cx.tcx.is_diagnostic_item(sym::Option, did);\n-    let _ = cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did);\n+    let _ = cx.tcx.lang_items().get(LangItem::OptionSome) == Some(did);\n \n     let _ = is_trait_method(cx, expr, sym::AsRef);\n \n     let _ = is_path_diagnostic_item(cx, expr, sym::Option);\n-    let _ = path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id));\n+    let _ = path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().get(LangItem::IteratorNext) == Some(id));\n     let _ = is_res_lang_ctor(cx, path_res(cx, expr), LangItem::OptionSome);\n }\n "}, {"sha": "3ca29f099771b9607ab423d6087c0bb2c95cabaf", "filename": "tests/ui-internal/unnecessary_def_path.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Funnecessary_def_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Funnecessary_def_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -57,7 +57,7 @@ error: use of a def path to a `LangItem`\n   --> $DIR/unnecessary_def_path.rs:51:13\n    |\n LL |     let _ = match_def_path(cx, did, &[\"alloc\", \"boxed\", \"Box\"]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().get(LangItem::OwnedBox) == Some(did)`\n \n error: use of a def path to a diagnostic item\n   --> $DIR/unnecessary_def_path.rs:52:13\n@@ -69,7 +69,7 @@ error: use of a def path to a `LangItem`\n   --> $DIR/unnecessary_def_path.rs:53:13\n    |\n LL |     let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\", \"Some\"]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().get(LangItem::OptionSome) == Some(did)`\n    |\n    = help: if this `DefId` came from a constructor expression or pattern then the parent `DefId` should be used instead\n \n@@ -89,7 +89,7 @@ error: use of a def path to a `LangItem`\n   --> $DIR/unnecessary_def_path.rs:58:13\n    |\n LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"iter\", \"traits\", \"Iterator\", \"next\"]);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id))`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().get(LangItem::IteratorNext) == Some(id))`\n \n error: use of a def path to a `LangItem`\n   --> $DIR/unnecessary_def_path.rs:59:13"}, {"sha": "8bfc060e991064d98905105f93fa9a398a709351", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -7,14 +7,6 @@ LL |     const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"]\n    = help: convert all references to use `LangItem::DerefMut`\n    = note: `-D clippy::unnecessary-def-path` implied by `-D warnings`\n \n-error: hardcoded path to a diagnostic item\n-  --> $DIR/unnecessary_def_path_hardcoded_path.rs:12:43\n-   |\n-LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n-   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: convert all references to use `sym::deref_method`\n-\n error: hardcoded path to a diagnostic item\n   --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n    |\n@@ -23,5 +15,13 @@ LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n    |\n    = help: convert all references to use `sym::Deref`\n \n+error: hardcoded path to a diagnostic item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:12:43\n+   |\n+LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `sym::deref_method`\n+\n error: aborting due to 3 previous errors\n "}, {"sha": "4506d1550bd4bbf4b7deadeedc89d63663b38e82", "filename": "tests/ui/crashes/ice-6250.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fcrashes%2Fice-6250.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fcrashes%2Fice-6250.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6250.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -23,6 +23,11 @@ error[E0308]: mismatched types\n    |\n LL |         Some(reference) = cache.data.get(key) {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n+   |\n+help: consider adding `let`\n+   |\n+LL |         let Some(reference) = cache.data.get(key) {\n+   |         +++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "79c29c04e05962f941499320b6feeb51724d6c60", "filename": "tests/ui/entry.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,3 +1,4 @@\n+// needs-asm-support\n // run-rustfix\n \n #![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]"}, {"sha": "2d7985457d8b4e6705f45066a5cc1647a37d4452", "filename": "tests/ui/entry.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,3 +1,4 @@\n+// needs-asm-support\n // run-rustfix\n \n #![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]"}, {"sha": "2c4c49d2522ca926db9adcc788a48b803e3cce1e", "filename": "tests/ui/entry.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,5 +1,5 @@\n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:24:5\n+  --> $DIR/entry.rs:25:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         m.insert(k, v);\n@@ -9,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::map-entry` implied by `-D warnings`\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:29:5\n+  --> $DIR/entry.rs:30:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         if true {\n@@ -32,7 +32,7 @@ LL +     });\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:38:5\n+  --> $DIR/entry.rs:39:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         if true {\n@@ -55,7 +55,7 @@ LL +     });\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:47:5\n+  --> $DIR/entry.rs:48:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         if true {\n@@ -79,7 +79,7 @@ LL +     }\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:57:5\n+  --> $DIR/entry.rs:58:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         foo();\n@@ -96,7 +96,7 @@ LL +     });\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:63:5\n+  --> $DIR/entry.rs:64:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         match 0 {\n@@ -122,7 +122,7 @@ LL +     });\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:75:5\n+  --> $DIR/entry.rs:76:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         match 0 {\n@@ -146,7 +146,7 @@ LL +     }\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:85:5\n+  --> $DIR/entry.rs:86:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         foo();\n@@ -187,15 +187,15 @@ LL +     });\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:119:5\n+  --> $DIR/entry.rs:120:5\n    |\n LL | /     if !m.contains_key(&m!(k)) {\n LL | |         m.insert(m!(k), m!(v));\n LL | |     }\n    | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:151:5\n+  --> $DIR/entry.rs:152:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         let x = (String::new(), String::new());"}, {"sha": "d8b6e3f1262b735345660276aa3456cb759aad52", "filename": "tests/ui/indexing_slicing_index.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Findexing_slicing_index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Findexing_slicing_index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing_index.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -4,11 +4,11 @@ error[E0080]: evaluation of `main::{constant#3}` failed\n LL |     const { &ARR[idx4()] }; // Ok, let rustc handle const contexts.\n    |              ^^^^^^^^^^^ index out of bounds: the length is 2 but the index is 4\n \n-error[E0080]: erroneous constant used\n+note: erroneous constant used\n   --> $DIR/indexing_slicing_index.rs:31:5\n    |\n LL |     const { &ARR[idx4()] }; // Ok, let rustc handle const contexts.\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: indexing may panic\n   --> $DIR/indexing_slicing_index.rs:22:5\n@@ -65,6 +65,6 @@ error[E0080]: evaluation of constant value failed\n LL | const REF_ERR: &i32 = &ARR[idx4()]; // Ok, let rustc handle const contexts.\n    |                        ^^^^^^^^^^^ index out of bounds: the length is 2 but the index is 4\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "1f2e1e3087bd09f7800184fc505a16f6f61a36aa", "filename": "tests/ui/manual_assert.edition2018.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fmanual_assert.edition2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fmanual_assert.edition2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -4,26 +4,17 @@ error: only a `panic!` in `if`-then statement\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qaqaq{:?}\", a);\n LL | |     }\n-   | |_____^\n+   | |_____^ help: try instead: `assert!(a.is_empty(), \"qaqaq{:?}\", a);`\n    |\n    = note: `-D clippy::manual-assert` implied by `-D warnings`\n-help: try instead\n-   |\n-LL |     assert!(a.is_empty(), \"qaqaq{:?}\", a);\n-   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:66:5\n    |\n LL | /     if a.is_empty() {\n LL | |         panic!(\"with expansion {}\", one!())\n LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!a.is_empty(), \"with expansion {}\", one!());\n-   |\n+   | |_____^ help: try instead: `assert!(!a.is_empty(), \"with expansion {}\", one!());`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "237638ee1344c60274bb31c1accbcf7f7456cee3", "filename": "tests/ui/manual_assert.edition2021.stderr", "status": "modified", "additions": 8, "deletions": 47, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fmanual_assert.edition2021.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fmanual_assert.edition2021.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2021.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -4,104 +4,65 @@ error: only a `panic!` in `if`-then statement\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qaqaq{:?}\", a);\n LL | |     }\n-   | |_____^\n+   | |_____^ help: try instead: `assert!(a.is_empty(), \"qaqaq{:?}\", a);`\n    |\n    = note: `-D clippy::manual-assert` implied by `-D warnings`\n-help: try instead\n-   |\n-LL |     assert!(a.is_empty(), \"qaqaq{:?}\", a);\n-   |\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:34:5\n    |\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qwqwq\");\n LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(a.is_empty(), \"qwqwq\");\n-   |\n+   | |_____^ help: try instead: `assert!(a.is_empty(), \"qwqwq\");`\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:51:5\n    |\n LL | /     if b.is_empty() {\n LL | |         panic!(\"panic1\");\n LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!b.is_empty(), \"panic1\");\n-   |\n+   | |_____^ help: try instead: `assert!(!b.is_empty(), \"panic1\");`\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:54:5\n    |\n LL | /     if b.is_empty() && a.is_empty() {\n LL | |         panic!(\"panic2\");\n LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(b.is_empty() && a.is_empty()), \"panic2\");\n-   |\n+   | |_____^ help: try instead: `assert!(!(b.is_empty() && a.is_empty()), \"panic2\");`\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:57:5\n    |\n LL | /     if a.is_empty() && !b.is_empty() {\n LL | |         panic!(\"panic3\");\n LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n-   |\n+   | |_____^ help: try instead: `assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");`\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:60:5\n    |\n LL | /     if b.is_empty() || a.is_empty() {\n LL | |         panic!(\"panic4\");\n LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n-   |\n+   | |_____^ help: try instead: `assert!(!(b.is_empty() || a.is_empty()), \"panic4\");`\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:63:5\n    |\n LL | /     if a.is_empty() || !b.is_empty() {\n LL | |         panic!(\"panic5\");\n LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n-   |\n+   | |_____^ help: try instead: `assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");`\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:66:5\n    |\n LL | /     if a.is_empty() {\n LL | |         panic!(\"with expansion {}\", one!())\n LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!a.is_empty(), \"with expansion {}\", one!());\n-   |\n+   | |_____^ help: try instead: `assert!(!a.is_empty(), \"with expansion {}\", one!());`\n \n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:73:5"}, {"sha": "590ad63c90be3a8972c0cd6568ec59f5f1623a22", "filename": "tests/ui/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,3 +1,4 @@\n+// needs-asm-support\n // aux-build: proc_macro_with_span.rs\n \n #![warn(clippy::missing_docs_in_private_items)]"}, {"sha": "d3bef28bf64c6707fffeb0b7ef853d49517742f2", "filename": "tests/ui/missing_doc.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fmissing_doc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Fmissing_doc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_doc.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -1,43 +1,43 @@\n error: missing documentation for a type alias\n-  --> $DIR/missing_doc.rs:15:1\n+  --> $DIR/missing_doc.rs:16:1\n    |\n LL | type Typedef = String;\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::missing-docs-in-private-items` implied by `-D warnings`\n \n error: missing documentation for a type alias\n-  --> $DIR/missing_doc.rs:16:1\n+  --> $DIR/missing_doc.rs:17:1\n    |\n LL | pub type PubTypedef = String;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a module\n-  --> $DIR/missing_doc.rs:18:1\n+  --> $DIR/missing_doc.rs:19:1\n    |\n LL | mod module_no_dox {}\n    | ^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a module\n-  --> $DIR/missing_doc.rs:19:1\n+  --> $DIR/missing_doc.rs:20:1\n    |\n LL | pub mod pub_module_no_dox {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing_doc.rs:23:1\n+  --> $DIR/missing_doc.rs:24:1\n    |\n LL | pub fn foo2() {}\n    | ^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing_doc.rs:24:1\n+  --> $DIR/missing_doc.rs:25:1\n    |\n LL | fn foo3() {}\n    | ^^^^^^^^^^^^\n \n error: missing documentation for an enum\n-  --> $DIR/missing_doc.rs:38:1\n+  --> $DIR/missing_doc.rs:39:1\n    |\n LL | / enum Baz {\n LL | |     BazA { a: isize, b: isize },\n@@ -46,75 +46,75 @@ LL | | }\n    | |_^\n \n error: missing documentation for a variant\n-  --> $DIR/missing_doc.rs:39:5\n+  --> $DIR/missing_doc.rs:40:5\n    |\n LL |     BazA { a: isize, b: isize },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing_doc.rs:39:12\n+  --> $DIR/missing_doc.rs:40:12\n    |\n LL |     BazA { a: isize, b: isize },\n    |            ^^^^^^^^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing_doc.rs:39:22\n+  --> $DIR/missing_doc.rs:40:22\n    |\n LL |     BazA { a: isize, b: isize },\n    |                      ^^^^^^^^\n \n error: missing documentation for a variant\n-  --> $DIR/missing_doc.rs:40:5\n+  --> $DIR/missing_doc.rs:41:5\n    |\n LL |     BarB,\n    |     ^^^^\n \n error: missing documentation for an enum\n-  --> $DIR/missing_doc.rs:43:1\n+  --> $DIR/missing_doc.rs:44:1\n    |\n LL | / pub enum PubBaz {\n LL | |     PubBazA { a: isize },\n LL | | }\n    | |_^\n \n error: missing documentation for a variant\n-  --> $DIR/missing_doc.rs:44:5\n+  --> $DIR/missing_doc.rs:45:5\n    |\n LL |     PubBazA { a: isize },\n    |     ^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a struct field\n-  --> $DIR/missing_doc.rs:44:15\n+  --> $DIR/missing_doc.rs:45:15\n    |\n LL |     PubBazA { a: isize },\n    |               ^^^^^^^^\n \n error: missing documentation for a constant\n-  --> $DIR/missing_doc.rs:64:1\n+  --> $DIR/missing_doc.rs:65:1\n    |\n LL | const FOO: u32 = 0;\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a constant\n-  --> $DIR/missing_doc.rs:71:1\n+  --> $DIR/missing_doc.rs:72:1\n    |\n LL | pub const FOO4: u32 = 0;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a static\n-  --> $DIR/missing_doc.rs:73:1\n+  --> $DIR/missing_doc.rs:74:1\n    |\n LL | static BAR: u32 = 0;\n    | ^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a static\n-  --> $DIR/missing_doc.rs:80:1\n+  --> $DIR/missing_doc.rs:81:1\n    |\n LL | pub static BAR4: u32 = 0;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a module\n-  --> $DIR/missing_doc.rs:82:1\n+  --> $DIR/missing_doc.rs:83:1\n    |\n LL | / mod internal_impl {\n LL | |     /// dox\n@@ -126,31 +126,31 @@ LL | | }\n    | |_^\n \n error: missing documentation for a function\n-  --> $DIR/missing_doc.rs:85:5\n+  --> $DIR/missing_doc.rs:86:5\n    |\n LL |     pub fn undocumented1() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing_doc.rs:86:5\n+  --> $DIR/missing_doc.rs:87:5\n    |\n LL |     pub fn undocumented2() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing_doc.rs:87:5\n+  --> $DIR/missing_doc.rs:88:5\n    |\n LL |     fn undocumented3() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing_doc.rs:92:9\n+  --> $DIR/missing_doc.rs:93:9\n    |\n LL |         pub fn also_undocumented1() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing documentation for a function\n-  --> $DIR/missing_doc.rs:93:9\n+  --> $DIR/missing_doc.rs:94:9\n    |\n LL |         fn also_undocumented2() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "fa9221ed02d7420efda22c38101df387b9a8ba07", "filename": "tests/ui/track-diagnostics.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Ftrack-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Ftrack-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrack-diagnostics.rs?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Z track-diagnostics\n+// error-pattern: created at\n+\n+// Normalize the emitted location so this doesn't need\n+// updating everytime someone adds or removes a line.\n+// normalize-stderr-test \".rs:\\d+:\\d+\" -> \".rs:LL:CC\"\n+\n+struct A;\n+struct B;\n+const S: A = B;\n+\n+fn main() {}"}, {"sha": "ec30318625311fadb7af2c1017c1add7d216a2f0", "filename": "tests/ui/track-diagnostics.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Ftrack-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4850f7292efa33759b4f7f9b7621268979e9914/tests%2Fui%2Ftrack-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrack-diagnostics.stderr?ref=f4850f7292efa33759b4f7f9b7621268979e9914", "patch": "@@ -0,0 +1,10 @@\n+error[E0308]: mismatched types\n+  --> $DIR/track-diagnostics.rs:LL:CC\n+   |\n+LL | const S: A = B;\n+   |              ^ expected struct `A`, found struct `B`\n+-Ztrack-diagnostics: created at compiler/rustc_infer/src/infer/error_reporting/mod.rs:LL:CC\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}