{"sha": "f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5Y2MwNmRmNTMyZjI4ODdkMWI5MTc5ZTVhMTZjYzFmNWU2MGRmYzc=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-11-10T22:16:20Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-11-10T22:16:20Z"}, "message": "Merge pull request #577 from nrc/docs\n\nInformation for new contributors", "tree": {"sha": "3cd90210a837d52e4d9678e170b0ccbc9f80e114", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cd90210a837d52e4d9678e170b0ccbc9f80e114"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7", "html_url": "https://github.com/rust-lang/rust/commit/f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6120b39ab91d94de46d9430b1552fdfef861f33", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6120b39ab91d94de46d9430b1552fdfef861f33", "html_url": "https://github.com/rust-lang/rust/commit/b6120b39ab91d94de46d9430b1552fdfef861f33"}, {"sha": "8ac0b3144c93af5108da779848c51825e01e1858", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac0b3144c93af5108da779848c51825e01e1858", "html_url": "https://github.com/rust-lang/rust/commit/8ac0b3144c93af5108da779848c51825e01e1858"}], "stats": {"total": 193, "additions": 183, "deletions": 10}, "files": [{"sha": "50209a22d4759f97cb15a7286d205e22fb9e8d5e", "filename": "Contributing.md", "status": "modified", "additions": 158, "deletions": 7, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7/Contributing.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7/Contributing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Contributing.md?ref=f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7", "patch": "@@ -1,16 +1,27 @@\n-## Contributing\n+# Contributing\n \n-### Test and file issues\n+There are many ways to contribute to Rustfmt. This document lays out what they\n+are and has information for how to get started. If you have any questions about\n+contributing or need help with anything, please ping nrc on irc, #rust-tools is\n+probably the best channel. Feel free to also ask questions on issues, or file\n+new issues specifically to get help.\n+\n+\n+## Test and file issues\n \n It would be really useful to have people use rustfmt on their projects and file\n issues where it does something you don't expect.\n \n A really useful thing to do that on a crate from the Rust repo. If it does\n something unexpected, file an issue; if not, make a PR to the Rust repo with the\n reformatted code. We hope to get the whole repo consistently rustfmt'ed and to\n-replace `make tidy` with rustfmt as a medium-term goal.\n+replace `make tidy` with rustfmt as a medium-term goal. Issues with stack traces\n+for bugs and/or minimal test cases are especially useful.\n+\n+See this [blog post](http://ncameron.org/blog/rustfmt-ing-rust/) for more details.\n+\n \n-### Create test cases\n+## Create test cases\n \n Having a strong test suite for a tool like this is essential. It is very easy\n to create regressions. Any tests you can add are very much appreciated.\n@@ -45,11 +56,151 @@ that toml file located in `./tests/config/` for its configuration. Including\n `// rustfmt-config: small_tabs.toml` will run your test with the configuration\n file found at `./tests/config/small_tabs.toml`.\n \n-### Hack!\n+\n+## Hack!\n \n Here are some [good starting issues](https://github.com/nrc/rustfmt/issues?q=is%3Aopen+is%3Aissue+label%3Aeasy).\n-Note than some of those issues tagged 'easy' are not that easy and might be better\n-second issues, rather than good first issues to fix.\n \n If you've found areas which need polish and don't have issues, please submit a\n PR, don't feel there needs to be an issue.\n+\n+\n+### Guidelines\n+\n+Rustfmt bootstraps, that is part of its test suite is running itself on its\n+source code. So, basically, the only style guideline is that you must pass the\n+tests. That ensures that the Rustfmt source code adheres to our own conventions.\n+\n+Talking of tests, if you add a new feature or fix a bug, please also add a test.\n+It's really easy, see above for details. Please run `cargo test` before\n+submitting a PR to ensure your patch passes all tests, it's pretty quick.\n+\n+Please try to avoid leaving `TODO`s in the code. There are a few around, but I\n+wish there weren't. You can leave `FIXME`s, preferably with an issue number.\n+\n+\n+### A quick tour of Rustfmt\n+\n+Rustfmt is basically a pretty printer - that is, it's mode of operation is to\n+take an AST (abstract syntax tree) and print it in a nice way (including staying\n+under the maximum permitted width for a line). In order to get that AST, we\n+first have to parse the source text, we use the Rust compiler's parser to do\n+that (see [src/lib.rs]). We shy away from doing anything too fancy, such as\n+algebraic approaches to pretty printing, instead relying on an heuristic\n+approach, 'manually' crafting a string for each AST node. This results in quite\n+a lot of code, but it is relatively simple.\n+\n+The AST is a tree view of source code. It carries all the semantic information\n+about the code, but not all of the syntax. In particular, we lose white space\n+and comments (although doc comments are preserved). Rustfmt uses a view of the\n+AST before macros are expanded, so there are still macro uses in the code. The\n+arguments to macros are not an AST, but raw tokens - this makes them harder to\n+format.\n+\n+There are different nodes for every kind of item and expression in Rust. For\n+more details see the source code in the compiler -\n+[ast.rs](https://dxr.mozilla.org/rust/source/src/libsyntax/ast.rs) - and/or the\n+[docs](http://manishearth.github.io/rust-internals-docs/syntax/ast/index.html).\n+\n+Many nodes in the AST (but not all, annoyingly) have a `Span`. A `Span` is a\n+range in the source code, it can easily be converted to a snippet of source\n+text. When the AST does not contain enough information for us, we rely heavily\n+on `Span`s. For example, we can look between spans to try and find comments, or\n+parse a snippet to see how the user wrote their source code.\n+\n+The downside of using the AST is that we miss some information - primarily white\n+space and comments. White space is sometimes significant, although mostly we\n+want to ignore it and make our own. We strive to reproduce all comments, but\n+this is sometimes difficult. The crufty corners of Rustfmt are where we hack\n+around the absence of comments in the AST and try to recreate them as best we\n+can.\n+\n+Our primary tool here is to look between spans for text we've missed. For\n+example, in a function call `foo(a, b)`, we have spans for `a` and `b`, in this\n+case there is only a comma and a single space between the end of `a` and the\n+start of `b`, so there is nothing much to do. But if we look at\n+`foo(a /* a comment */, b)`, then between `a` and `b` we find the comment.\n+\n+At a higher level, Rustfmt has machinery so that we account for text between\n+'top level' items. Then we can reproduce that text pretty much verbatim. We only\n+count spans we actually reformat, so if we can't format a span it is not missed\n+completely, but is reproduced in the output without being formatted. This is\n+mostly handled in [src/missed_spans.rs]. See also `FmtVisitor::last_pos` in\n+[src/visitor.rs].\n+\n+\n+#### Some important elements\n+\n+At the highest level, Rustfmt uses a `Visitor` implementation called `FmtVisitor`\n+to walk the AST. This is in [src/visitor.rs]. This is really just used to walk\n+items, rather than the bodies of functions. We also cover macros and attributes\n+here. Most methods of the visitor call out to `Rewrite` implementations that\n+then walk their own children.\n+\n+The `Rewrite` trait is defined in [src/rewrite.rs]. It is implemented for many\n+things that can be rewritten, mostly AST nodes. It has a single function,\n+`rewrite`, which is called to rewrite `self` into an `Option<String>`. The\n+arguments are `width` which is the horizontal space we write into, and `offset`\n+which is how much we are currently indented from the lhs of the page. We also\n+take a context which contains information used for parsing, the current block\n+indent, and a configuration (see below).\n+\n+To understand the indents, consider\n+\n+```\n+impl Foo {\n+    fn foo(...) {\n+        bar(argument_one,\n+            baz());\n+    }\n+}\n+```\n+\n+When formatting the `bar` call we will format the arguments in order, after the\n+first one we know we are working on multiple lines (imagine it is longer than\n+written). So, when we come to the second argument, the indent we pass to\n+`rewrite` is 12, which puts us under the first argument. The current block\n+indent (stored in the context) is 8. The former is used for visual indenting\n+(when objects are vertically aligned with some marker), the latter is used for\n+block indenting (when objects are tabbed in from the lhs). The width available\n+for `baz()` will be the maximum width, minus the space used for indenting, minus\n+the space used for the `);`. (Note that actual argument formatting does not\n+quite work like this, but it's close enough).\n+\n+The `rewrite` function returns an `Option` - either we successfully rewrite and\n+return the rewritten string for the caller to use, or we fail to rewrite and\n+return `None`. This could be because Rustfmt encounters something it doesn't\n+know how to reformat, but more often it is because Rustfmt can't fit the item\n+into the required width. How to handle this is up to the caller. Often the\n+caller just gives up, ultimately relying on the missed spans system to paste in\n+the un-formatted source. A better solution (although not performed in many\n+places) is for the caller to shuffle around some of it's other items to make\n+more width, then call the function again with more space.\n+\n+Since it is common for callers to bail out when a callee fails, we often use a\n+`try_opt!` macro to make this pattern more succinct.\n+\n+One way we might find out that we don't have enough space is when computing how much\n+space we have. Something like `available_space = budget - overhead`. Since\n+widths are unsized integers, this would cause underflow. Therefore we use\n+checked subtraction: `available_space = try_opt!(budget.checked_sub(overhead))`.\n+`checked_sub` returns an `Option`, and if we would underflow `try_opt!` returns\n+`None`, otherwise we proceed with the computed space.\n+\n+Much syntax in Rust is lists: lists of arguments, lists of fields, lists of\n+array elements, etc. We have some generic code to handle lists, including how to\n+space them in horizontal and vertical space, indentation, comments between\n+items, trailing separators, etc. However, since there are so many options, the\n+code is a bit complex. Look in [src/lists.rs]. `write_list` is the key function,\n+and `ListFormatting` the key structure for configuration. You'll need to make a\n+`ListItems` for input, this is usually done using `itemize_list`.\n+\n+Rustfmt strives to be highly configurable. Often the first part of a patch is\n+creating a configuration option for the feature you are implementing. All\n+handling of configuration options is done in [src/config.rs]. Look for the\n+`create_config!` macro at the end of the file for all the options. The rest of\n+the file defines a bunch of enums used for options, and the machinery to produce\n+the config struct and parse a config file, etc. Checking an option is done by\n+accessing the correct field on the config struct, e.g., `config.max_width`. Most\n+functions have a `Config`, or one can be accessed via a visitor or context of\n+some kind."}, {"sha": "4951ce5d5826adc39cccb7bb9863de66ac43af8a", "filename": "README.md", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f9cc06df532f2887d1b9179e5a16cc1f5e60dfc7", "patch": "@@ -2,6 +2,9 @@\n \n A tool for formatting Rust code according to style guidelines.\n \n+If you'd like to help out (and you should, it's a fun project!), see\n+[Contributing.md].\n+\n \n ## Installation\n \n@@ -47,12 +50,31 @@ the command line.\n screen, for example.\n \n \n+## What style does Rustfmt use?\n+\n+Rustfmt is designed to be very configurable. You can create a TOML file called\n+rustfmt.toml, place it in the project directory and it will apply the options\n+in that file. See `cargo run --help-config` for the options which are available,\n+or if you prefer to see source code, [src/config.rs].\n+\n+By default, Rustfmt uses a style which (mostly) confirms to the\n+[Rust style guidelines](https://github.com/rust-lang/rust/tree/master/src/doc/style).\n+There are many details which the style guidelines do not cover, and in these\n+cases we try to adhere to a style similar to that used in the\n+[Rust repo](https://github.com/rust-lang/rust). Once Rustfmt is more complete, and\n+able to re-format large repositories like Rust, we intend to go through the Rust\n+RFC process to nail down the default style in detail.\n+\n+If there are styling choices you don't agree with, we are usually happy to add\n+options covering different styles. File an issue, or even better, submit a PR.\n+\n+\n ## Gotchas\n \n * For things you do not want rustfmt to mangle, use one of\n-   ```rust\n-   #[rustfmt_skip]\n-   #[cfg_attr(rustfmt, rustfmt_skip)]\n+    ```rust\n+    #[rustfmt_skip]\n+    #[cfg_attr(rustfmt, rustfmt_skip)]\n     ```\n * When you run rustfmt, place a file named rustfmt.toml in target file\n   directory or its parents to override the default settings of rustfmt."}]}