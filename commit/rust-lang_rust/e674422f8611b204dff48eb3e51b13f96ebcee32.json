{"sha": "e674422f8611b204dff48eb3e51b13f96ebcee32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NzQ0MjJmODYxMWIyMDRkZmY0OGViM2U1MWIxM2Y5NmViY2VlMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-22T00:16:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-22T00:16:02Z"}, "message": "Auto merge of #75797 - Dylan-DPC:rollup-lfeytr7, r=Dylan-DPC\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #75705 (Move to intra-doc links for /library/core/src/intrinsics.rs)\n - #75711 (Split `astconv.rs` into its own submodule)\n - #75718 (Don't count variants/fields/consts/associated types in doc-coverage doc examples)\n - #75725 (Use intra-doc-links in `alloc`)\n - #75745 (Remove duplication in `fold_item`)\n - #75753 (Another motivation for CFG: return-oriented programming)\n - #75769 (Minor, remove double nesting of a test module)\n - #75771 (Extend normalization in const-eval-query-stack test)\n - #75781 (More inline asm register name fixups for LLVM)\n - #75782 (Convert core/src/str/pattern.rs to Intra-doc links)\n - #75787 (Use intra-doc-links in `core::ops::*`)\n - #75788 (MIR call terminator represents diverging calls too)\n\nFailed merges:\n\n - #75773 (Introduce expect snapshot testing library into rustc)\n\nr? @ghost", "tree": {"sha": "7e76b58c1e7a5967a933d72b688f8e9f0e506dfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e76b58c1e7a5967a933d72b688f8e9f0e506dfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e674422f8611b204dff48eb3e51b13f96ebcee32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e674422f8611b204dff48eb3e51b13f96ebcee32", "html_url": "https://github.com/rust-lang/rust/commit/e674422f8611b204dff48eb3e51b13f96ebcee32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e674422f8611b204dff48eb3e51b13f96ebcee32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de521cbb303c08febd9fa3755caccd4f3e491ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/de521cbb303c08febd9fa3755caccd4f3e491ea3", "html_url": "https://github.com/rust-lang/rust/commit/de521cbb303c08febd9fa3755caccd4f3e491ea3"}, {"sha": "2ab6fef19fb78dddc16fb03715e637dfd6f8663a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ab6fef19fb78dddc16fb03715e637dfd6f8663a", "html_url": "https://github.com/rust-lang/rust/commit/2ab6fef19fb78dddc16fb03715e637dfd6f8663a"}], "stats": {"total": 3969, "additions": 1857, "deletions": 2112}, "files": [{"sha": "87b86e590a4c82b23e5d4d5a030eef7c53057728", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -36,8 +36,6 @@ extern \"Rust\" {\n ///\n /// Note: while this type is unstable, the functionality it provides can be\n /// accessed through the [free functions in `alloc`](index.html#functions).\n-///\n-/// [`AllocRef`]: trait.AllocRef.html\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n@@ -55,10 +53,6 @@ pub struct Global;\n ///\n /// See [`GlobalAlloc::alloc`].\n ///\n-/// [`Global`]: struct.Global.html\n-/// [`AllocRef`]: trait.AllocRef.html\n-/// [`GlobalAlloc::alloc`]: trait.GlobalAlloc.html#tymethod.alloc\n-///\n /// # Examples\n ///\n /// ```\n@@ -92,10 +86,6 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n /// # Safety\n ///\n /// See [`GlobalAlloc::dealloc`].\n-///\n-/// [`Global`]: struct.Global.html\n-/// [`AllocRef`]: trait.AllocRef.html\n-/// [`GlobalAlloc::dealloc`]: trait.GlobalAlloc.html#tymethod.dealloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n@@ -114,10 +104,6 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n /// # Safety\n ///\n /// See [`GlobalAlloc::realloc`].\n-///\n-/// [`Global`]: struct.Global.html\n-/// [`AllocRef`]: trait.AllocRef.html\n-/// [`GlobalAlloc::realloc`]: trait.GlobalAlloc.html#method.realloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n@@ -137,10 +123,6 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n ///\n /// See [`GlobalAlloc::alloc_zeroed`].\n ///\n-/// [`Global`]: struct.Global.html\n-/// [`AllocRef`]: trait.AllocRef.html\n-/// [`GlobalAlloc::alloc_zeroed`]: trait.GlobalAlloc.html#method.alloc_zeroed\n-///\n /// # Examples\n ///\n /// ```"}, {"sha": "93d0df448ea1447f3bfbb7d8c832bbda8b737152", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -118,14 +118,13 @@\n //! described in [rust-lang/unsafe-code-guidelines#198][ucg#198].\n //!\n //! [ucg#198]: https://github.com/rust-lang/unsafe-code-guidelines/issues/198\n-//! [dereferencing]: ../../std/ops/trait.Deref.html\n-//! [`Box`]: struct.Box.html\n-//! [`Box<T>`]: struct.Box.html\n-//! [`Box::<T>::from_raw(value)`]: struct.Box.html#method.from_raw\n-//! [`Box::<T>::into_raw`]: struct.Box.html#method.into_raw\n-//! [`Global`]: ../alloc/struct.Global.html\n-//! [`Layout`]: ../alloc/struct.Layout.html\n-//! [`Layout::for_value(&*value)`]: ../alloc/struct.Layout.html#method.for_value\n+//! [dereferencing]: core::ops::Deref\n+//! [`Box<T>`]: Box\n+//! [`Box::<T>::from_raw(value)`]: Box::from_raw\n+//! [`Box::<T>::into_raw`]: Box::into_raw\n+//! [`Global`]: crate::alloc::Global\n+//! [`Layout`]: crate::alloc::Layout\n+//! [`Layout::for_value(&*value)`]: crate::alloc::Layout::for_value\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -240,7 +239,6 @@ impl<T> Box<T> {\n     /// Converts a `Box<T>` into a `Box<[T]>`\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n-    ///\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n     pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n         // *mut T and *mut [T; 1] have the same size and alignment\n@@ -386,9 +384,8 @@ impl<T: ?Sized> Box<T> {\n     /// }\n     /// ```\n     ///\n-    /// [memory layout]: index.html#memory-layout\n-    /// [`Layout`]: ../alloc/struct.Layout.html\n-    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n+    /// [memory layout]: self#memory-layout\n+    /// [`Layout`]: crate::Layout\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n@@ -433,8 +430,7 @@ impl<T: ?Sized> Box<T> {\n     /// }\n     /// ```\n     ///\n-    /// [memory layout]: index.html#memory-layout\n-    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n+    /// [memory layout]: self#memory-layout\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n@@ -478,8 +474,6 @@ impl<T: ?Sized> Box<T> {\n     /// to call it as `Box::leak(b)` instead of `b.leak()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n-    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n-    ///\n     /// # Examples\n     ///\n     /// Simple usage:"}, {"sha": "5390b57a1d98dddcd84ef1e2dfc0e7896c1ddd20", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -7,8 +7,8 @@\n //! array-based containers are generally faster,\n //! more memory efficient, and make better use of CPU cache.\n //!\n-//! [`Vec`]: ../../vec/struct.Vec.html\n-//! [`VecDeque`]: ../vec_deque/struct.VecDeque.html\n+//! [`Vec`]: crate::vec::Vec\n+//! [`VecDeque`]: super::vec_deque::VecDeque\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -50,11 +50,8 @@ struct Node<T> {\n \n /// An iterator over the elements of a `LinkedList`.\n ///\n-/// This `struct` is created by the [`iter`] method on [`LinkedList`]. See its\n+/// This `struct` is created by [`LinkedList::iter()`]. See its\n /// documentation for more.\n-///\n-/// [`iter`]: struct.LinkedList.html#method.iter\n-/// [`LinkedList`]: struct.LinkedList.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n     head: Option<NonNull<Node<T>>>,\n@@ -80,11 +77,8 @@ impl<T> Clone for Iter<'_, T> {\n \n /// A mutable iterator over the elements of a `LinkedList`.\n ///\n-/// This `struct` is created by the [`iter_mut`] method on [`LinkedList`]. See its\n+/// This `struct` is created by [`LinkedList::iter_mut()`]. See its\n /// documentation for more.\n-///\n-/// [`iter_mut`]: struct.LinkedList.html#method.iter_mut\n-/// [`LinkedList`]: struct.LinkedList.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     // We do *not* exclusively own the entire list here, references to node's `element`\n@@ -109,7 +103,6 @@ impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n /// (provided by the `IntoIterator` trait). See its documentation for more.\n ///\n /// [`into_iter`]: struct.LinkedList.html#method.into_iter\n-/// [`LinkedList`]: struct.LinkedList.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {"}, {"sha": "a886e17f5a9c3022a07467ccdded6bdec6e9c7b0", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -501,31 +501,23 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! [`usize`]: ../../std/primitive.usize.html\n-//! [`isize`]: ../../std/primitive.isize.html\n-//! [`i8`]: ../../std/primitive.i8.html\n-//! [`Display`]: trait.Display.html\n-//! [`Binary`]: trait.Binary.html\n-//! [`fmt::Result`]: type.Result.html\n-//! [`Result`]: ../../std/result/enum.Result.html\n-//! [`std::fmt::Error`]: struct.Error.html\n-//! [`Formatter`]: struct.Formatter.html\n-//! [`write!`]: ../../std/macro.write.html\n-//! [`Debug`]: trait.Debug.html\n-//! [`format!`]: ../../std/macro.format.html\n-//! [`to_string`]: ../../std/string/trait.ToString.html\n-//! [`writeln!`]: ../../std/macro.writeln.html\n+//! [`fmt::Result`]: Result\n+//! [`Result`]: core::result::Result\n+//! [`std::fmt::Error`]: Error\n+//! [`write!`]: core::write\n+//! [`write`]: core::write\n+//! [`format!`]: crate::format\n+//! [`to_string`]: crate::string::ToString\n+//! [`writeln!`]: core::writeln\n //! [`write_fmt`]: ../../std/io/trait.Write.html#method.write_fmt\n //! [`std::io::Write`]: ../../std/io/trait.Write.html\n //! [`print!`]: ../../std/macro.print.html\n //! [`println!`]: ../../std/macro.println.html\n //! [`eprint!`]: ../../std/macro.eprint.html\n //! [`eprintln!`]: ../../std/macro.eprintln.html\n-//! [`write!`]: ../../std/macro.write.html\n-//! [`format_args!`]: ../../std/macro.format_args.html\n-//! [`fmt::Arguments`]: struct.Arguments.html\n-//! [`write`]: fn.write.html\n-//! [`format`]: fn.format.html\n+//! [`format_args!`]: core::format_args\n+//! [`fmt::Arguments`]: Arguments\n+//! [`format`]: crate::format\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -576,9 +568,8 @@ use crate::string;\n /// assert_eq!(s, \"Hello, world!\");\n /// ```\n ///\n-/// [`Arguments`]: struct.Arguments.html\n-/// [`format_args!`]: ../../std/macro.format_args.html\n-/// [`format!`]: ../../std/macro.format.html\n+/// [`format_args!`]: core::format_args\n+/// [`format!`]: crate::format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();"}, {"sha": "892f794fc42326909cc4301605228af25067fc6c", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -50,11 +50,11 @@\n //! The [`alloc`](alloc/index.html) module defines the low-level interface to the\n //! default global allocator. It is not compatible with the libc allocator API.\n //!\n-//! [`Arc`]: sync/index.html\n-//! [`Box`]: boxed/index.html\n-//! [`Cell`]: ../core/cell/index.html\n-//! [`Rc`]: rc/index.html\n-//! [`RefCell`]: ../core/cell/index.html\n+//! [`Arc`]: sync\n+//! [`Box`]: boxed\n+//! [`Cell`]: core::cell\n+//! [`Rc`]: rc\n+//! [`RefCell`]: core::cell\n \n #![allow(unused_attributes)]\n #![stable(feature = \"alloc\", since = \"1.36.0\")]"}, {"sha": "2f744618d6936937224ee92fe41c1ac9f9b545ac", "filename": "library/alloc/src/macros.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fmacros.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -29,8 +29,7 @@\n /// to the same boxed integer value, not five references pointing to independently\n /// boxed integers.\n ///\n-/// [`Vec`]: ../std/vec/struct.Vec.html\n-/// [`Clone`]: ../std/clone/trait.Clone.html\n+/// [`Vec`]: crate::vec::Vec\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -81,11 +80,11 @@ macro_rules! vec {\n /// To convert a single value to a string, use the [`to_string`] method. This\n /// will use the [`Display`] formatting trait.\n ///\n-/// [fmt]: ../std/fmt/index.html\n+/// [fmt]: core::fmt\n /// [`print!`]: ../std/macro.print.html\n-/// [`write!`]: ../std/macro.write.html\n-/// [`to_string`]: ../std/string/trait.ToString.html\n-/// [`Display`]: ../std/fmt/trait.Display.html\n+/// [`write!`]: core::write\n+/// [`to_string`]: crate::string::ToString\n+/// [`Display`]: core::fmt::Display\n ///\n /// # Panics\n ///"}, {"sha": "f8b1c21e9771c3324823a27a20d1087d9d9d7663", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 33, "deletions": 62, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -214,18 +214,15 @@\n //! }\n //! ```\n //!\n-//! [`Rc`]: struct.Rc.html\n-//! [`Weak`]: struct.Weak.html\n-//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-//! [`Cell`]: ../../std/cell/struct.Cell.html\n-//! [`RefCell`]: ../../std/cell/struct.RefCell.html\n-//! [send]: ../../std/marker/trait.Send.html\n+//! [clone]: Clone::clone\n+//! [`Cell`]: core::cell::Cell\n+//! [`RefCell`]: core::cell::RefCell\n+//! [send]: core::marker::Send\n //! [arc]: ../../std/sync/struct.Arc.html\n-//! [`Deref`]: ../../std/ops/trait.Deref.html\n-//! [downgrade]: struct.Rc.html#method.downgrade\n-//! [upgrade]: struct.Weak.html#method.upgrade\n-//! [`None`]: ../../std/option/enum.Option.html#variant.None\n-//! [mutability]: ../../std/cell/index.html#introducing-mutability-inside-of-something-immutable\n+//! [`Deref`]: core::ops::Deref\n+//! [downgrade]: Rc::downgrade\n+//! [upgrade]: Weak::upgrade\n+//! [mutability]: core::cell#introducing-mutability-inside-of-something-immutable\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -396,13 +393,11 @@ impl<T> Rc<T> {\n \n     /// Returns the inner value, if the `Rc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n+    /// Otherwise, an [`Err`] is returned with the same `Rc` that was\n     /// passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n-    /// [result]: ../../std/result/enum.Result.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -553,7 +548,7 @@ impl<T: ?Sized> Rc<T> {\n     /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n     /// [`Rc::from_raw`][from_raw].\n     ///\n-    /// [from_raw]: struct.Rc.html#method.from_raw\n+    /// [from_raw]: Rc::from_raw\n     ///\n     /// # Examples\n     ///\n@@ -613,8 +608,8 @@ impl<T: ?Sized> Rc<T> {\n     /// This function is unsafe because improper use may lead to memory unsafety,\n     /// even if the returned `Rc<T>` is never accessed.\n     ///\n-    /// [into_raw]: struct.Rc.html#method.into_raw\n-    /// [transmute]: ../../std/mem/fn.transmute.html\n+    /// [into_raw]: Rc::into_raw\n+    /// [transmute]: core::mem::transmute\n     ///\n     /// # Examples\n     ///\n@@ -645,9 +640,7 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { Self::from_ptr(rc_ptr) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n+    /// Creates a new [`Weak`] pointer to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -666,9 +659,7 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n+    /// Gets the number of [`Weak`] pointers to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -704,28 +695,24 @@ impl<T: ?Sized> Rc<T> {\n         this.strong()\n     }\n \n-    /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// Returns `true` if there are no other `Rc` or [`Weak`] pointers to\n     /// this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n     #[inline]\n     fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n     /// Returns a mutable reference into the given `Rc`, if there are\n-    /// no other `Rc` or [`Weak`][weak] pointers to the same allocation.\n+    /// no other `Rc` or [`Weak`] pointers to the same allocation.\n     ///\n     /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n     /// the inner value when there are other pointers.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [make_mut]: struct.Rc.html#method.make_mut\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [make_mut]: Rc::make_mut\n+    /// [clone]: Clone::clone\n     ///\n     /// # Examples\n     ///\n@@ -750,7 +737,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n     ///\n-    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    /// [`get_mut`]: Rc::get_mut\n     ///\n     /// # Safety\n     ///\n@@ -796,7 +783,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n+    /// [`ptr::eq`]: core::ptr::eq\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -814,9 +801,8 @@ impl<T: Clone> Rc<T> {\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning.\n     ///\n-    /// [`Weak`]: struct.Weak.html\n-    /// [`clone`]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    /// [`clone`]: Clone::clone\n+    /// [`get_mut`]: Rc::get_mut\n     ///\n     /// # Examples\n     ///\n@@ -1117,8 +1103,6 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n-    ///\n-    /// [`Weak`]: ../../std/rc/struct.Weak.html\n     fn drop(&mut self) {\n         unsafe {\n             self.dec_strong();\n@@ -1600,11 +1584,7 @@ impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n ///\n /// The typical way to obtain a `Weak` pointer is to call [`Rc::downgrade`].\n ///\n-/// [`Rc`]: struct.Rc.html\n-/// [`Rc::downgrade`]: struct.Rc.html#method.downgrade\n-/// [`upgrade`]: struct.Weak.html#method.upgrade\n-/// [`Option`]: ../../std/option/enum.Option.html\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`upgrade`]: Weak::upgrade\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n@@ -1631,8 +1611,7 @@ impl<T> Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating any memory.\n     /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [`upgrade`]: #method.upgrade\n-    /// [`None`]: ../../std/option/enum.Option.html\n+    /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples\n     ///\n@@ -1671,7 +1650,7 @@ impl<T> Weak<T> {\n     /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n-    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`null`]: core::ptr::null\n     #[stable(feature = \"rc_as_ptr\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(self.ptr);\n@@ -1713,8 +1692,8 @@ impl<T> Weak<T> {\n     /// assert_eq!(0, Rc::weak_count(&strong));\n     /// ```\n     ///\n-    /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n+    /// [`from_raw`]: Weak::from_raw\n+    /// [`as_ptr`]: Weak::as_ptr\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n@@ -1761,12 +1740,9 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`into_raw`]: struct.Weak.html#method.into_raw\n-    /// [`upgrade`]: struct.Weak.html#method.upgrade\n-    /// [`Rc`]: struct.Rc.html\n-    /// [`Weak`]: struct.Weak.html\n-    /// [`new`]: struct.Weak.html#method.new\n-    /// [`forget`]: ../../std/mem/fn.forget.html\n+    /// [`into_raw`]: Weak::into_raw\n+    /// [`upgrade`]: Weak::upgrade\n+    /// [`new`]: Weak::new\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n@@ -1794,9 +1770,6 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// Returns [`None`] if the inner value has since been dropped.\n     ///\n-    /// [`Rc`]: struct.Rc.html\n-    /// [`None`]: ../../std/option/enum.Option.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1829,8 +1802,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n-    ///\n-    /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() { inner.strong() } else { 0 }\n@@ -1899,7 +1870,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n+    /// [`ptr::eq`]: core::ptr::eq\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1981,8 +1952,8 @@ impl<T> Default for Weak<T> {\n     /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n     /// it. Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html\n-    /// [`upgrade`]: ../../std/rc/struct.Weak.html#method.upgrade\n+    /// [`None`]: Option\n+    /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples\n     ///"}, {"sha": "8ea2c6dc859b274c4afa9764e777a7f488f68a77", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -70,11 +70,7 @@\n //! * Further methods that return iterators are [`.split`], [`.splitn`],\n //!   [`.chunks`], [`.windows`] and more.\n //!\n-//! [`Clone`]: ../../std/clone/trait.Clone.html\n-//! [`Eq`]: ../../std/cmp/trait.Eq.html\n-//! [`Ord`]: ../../std/cmp/trait.Ord.html\n-//! [`Iter`]: struct.Iter.html\n-//! [`Hash`]: ../../std/hash/trait.Hash.html\n+//! [`Hash`]: core::hash::Hash\n //! [`.iter`]: ../../std/primitive.slice.html#method.iter\n //! [`.iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n //! [`.split`]: ../../std/primitive.slice.html#method.split\n@@ -560,7 +556,7 @@ impl [u8] {\n     ///\n     /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n     ///\n-    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    /// [`make_ascii_uppercase`]: u8::make_ascii_uppercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n@@ -577,7 +573,7 @@ impl [u8] {\n     ///\n     /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n     ///\n-    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    /// [`make_ascii_lowercase`]: u8::make_ascii_lowercase\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> Vec<u8> {"}, {"sha": "4444a7a313298f25e047183b3376d58f68198170", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 43, "deletions": 76, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -2,9 +2,7 @@\n \n //! Thread-safe reference-counting pointers.\n //!\n-//! See the [`Arc<T>`][arc] documentation for more details.\n-//!\n-//! [arc]: struct.Arc.html\n+//! See the [`Arc<T>`][Arc] documentation for more details.\n \n use core::any::Any;\n use core::borrow;\n@@ -100,21 +98,21 @@ macro_rules! acquire {\n /// ## Breaking cycles with `Weak`\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n-/// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n+/// [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n /// to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n /// already been dropped. In other words, `Weak` pointers do not keep the value\n /// inside the allocation alive; however, they *do* keep the allocation\n /// (the backing store for the value) alive.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n-/// [`Weak`][weak] is used to break cycles. For example, a tree could have\n-/// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n+/// [`Weak`] is used to break cycles. For example, a tree could have\n+/// strong `Arc` pointers from parent nodes to children, and [`Weak`]\n /// pointers from children back to their parents.\n ///\n /// # Cloning references\n ///\n /// Creating a new reference from an existing reference counted pointer is done using the\n-/// `Clone` trait implemented for [`Arc<T>`][arc] and [`Weak<T>`][weak].\n+/// `Clone` trait implemented for [`Arc<T>`][Arc] and [`Weak<T>`][Weak].\n ///\n /// ```\n /// use std::sync::Arc;\n@@ -139,23 +137,20 @@ macro_rules! acquire {\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the inner value may have\n+/// [`Weak<T>`][Weak] does not auto-dereference to `T`, because the inner value may have\n /// already been dropped.\n ///\n-/// [arc]: struct.Arc.html\n-/// [weak]: struct.Weak.html\n-/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n-/// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+/// [`Rc<T>`]: crate::rc::Rc\n+/// [clone]: Clone::clone\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n-/// [atomic]: ../../std/sync/atomic/index.html\n-/// [`Send`]: ../../std/marker/trait.Send.html\n-/// [`Sync`]: ../../std/marker/trait.Sync.html\n-/// [deref]: ../../std/ops/trait.Deref.html\n-/// [downgrade]: struct.Arc.html#method.downgrade\n-/// [upgrade]: struct.Weak.html#method.upgrade\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n+/// [atomic]: core::sync::atomic\n+/// [`Send`]: core::marker::Send\n+/// [`Sync`]: core::marker::Sync\n+/// [deref]: core::ops::Deref\n+/// [downgrade]: Arc::downgrade\n+/// [upgrade]: Weak::upgrade\n+/// [`RefCell<T>`]: core::cell::RefCell\n /// [`std::sync`]: ../../std/sync/index.html\n /// [`Arc::clone(&from)`]: #method.clone\n ///\n@@ -184,7 +179,7 @@ macro_rules! acquire {\n ///\n /// Sharing a mutable [`AtomicUsize`]:\n ///\n-/// [`AtomicUsize`]: ../../std/sync/atomic/struct.AtomicUsize.html\n+/// [`AtomicUsize`]: core::sync::atomic::AtomicUsize\n ///\n /// ```no_run\n /// use std::sync::Arc;\n@@ -254,11 +249,7 @@ impl<T: ?Sized> Arc<T> {\n ///\n /// The typical way to obtain a `Weak` pointer is to call [`Arc::downgrade`].\n ///\n-/// [`Arc`]: struct.Arc.html\n-/// [`Arc::downgrade`]: struct.Arc.html#method.downgrade\n-/// [`upgrade`]: struct.Weak.html#method.upgrade\n-/// [`Option`]: ../../std/option/enum.Option.html\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`upgrade`]: Weak::upgrade\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n@@ -396,13 +387,11 @@ impl<T> Arc<T> {\n \n     /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n+    /// Otherwise, an [`Err`] is returned with the same `Arc` that was\n     /// passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n-    /// [result]: ../../std/result/enum.Result.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -550,9 +539,7 @@ impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n     /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n-    /// [`Arc::from_raw`][from_raw].\n-    ///\n-    /// [from_raw]: struct.Arc.html#method.from_raw\n+    /// [`Arc::from_raw`].\n     ///\n     /// # Examples\n     ///\n@@ -612,8 +599,8 @@ impl<T: ?Sized> Arc<T> {\n     /// This function is unsafe because improper use may lead to memory unsafety,\n     /// even if the returned `Arc<T>` is never accessed.\n     ///\n-    /// [into_raw]: struct.Arc.html#method.into_raw\n-    /// [transmute]: ../../std/mem/fn.transmute.html\n+    /// [into_raw]: Arc::into_raw\n+    /// [transmute]: core::mem::transmute\n     ///\n     /// # Examples\n     ///\n@@ -646,9 +633,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n+    /// Creates a new [`Weak`] pointer to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -690,9 +675,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n-    ///\n-    /// [weak]: struct.Weak.html\n+    /// Gets the number of [`Weak`] pointers to this allocation.\n     ///\n     /// # Safety\n     ///\n@@ -861,7 +844,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n+    /// [`ptr::eq`]: core::ptr::eq\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -1098,7 +1081,7 @@ impl<T: ?Sized> Receiver for Arc<T> {}\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n-    /// If there are other `Arc` or [`Weak`][weak] pointers to the same allocation,\n+    /// If there are other `Arc` or [`Weak`] pointers to the same allocation,\n     /// then `make_mut` will create a new allocation and invoke [`clone`][clone] on the inner value\n     /// to ensure unique ownership. This is also referred to as clone-on-write.\n     ///\n@@ -1107,10 +1090,9 @@ impl<T: Clone> Arc<T> {\n     ///\n     /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    /// [get_mut]: struct.Arc.html#method.get_mut\n-    /// [`Rc::make_mut`]: ../rc/struct.Rc.html#method.make_mut\n+    /// [clone]: Clone::clone\n+    /// [get_mut]: Arc::get_mut\n+    /// [`Rc::make_mut`]: super::rc::Rc::make_mut\n     ///\n     /// # Examples\n     ///\n@@ -1184,18 +1166,16 @@ impl<T: Clone> Arc<T> {\n \n impl<T: ?Sized> Arc<T> {\n     /// Returns a mutable reference into the given `Arc`, if there are\n-    /// no other `Arc` or [`Weak`][weak] pointers to the same allocation.\n+    /// no other `Arc` or [`Weak`] pointers to the same allocation.\n     ///\n-    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n     /// the inner value when there are other pointers.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [option]: ../../std/option/enum.Option.html\n-    /// [make_mut]: struct.Arc.html#method.make_mut\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [make_mut]: Arc::make_mut\n+    /// [clone]: Clone::clone\n     ///\n     /// # Examples\n     ///\n@@ -1229,7 +1209,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n     ///\n-    /// [`get_mut`]: struct.Arc.html#method.get_mut\n+    /// [`get_mut`]: Arc::get_mut\n     ///\n     /// # Safety\n     ///\n@@ -1315,8 +1295,6 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n-    ///\n-    /// [`Weak`]: ../../std/sync/struct.Weak.html\n     #[inline]\n     fn drop(&mut self) {\n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n@@ -1401,8 +1379,7 @@ impl<T> Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating any memory.\n     /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n-    /// [`upgrade`]: struct.Weak.html#method.upgrade\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples\n     ///\n@@ -1441,7 +1418,7 @@ impl<T> Weak<T> {\n     /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n-    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`null`]: core::ptr::null\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(self.ptr);\n@@ -1483,8 +1460,8 @@ impl<T> Weak<T> {\n     /// assert_eq!(0, Arc::weak_count(&strong));\n     /// ```\n     ///\n-    /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n+    /// [`from_raw`]: Weak::from_raw\n+    /// [`as_ptr`]: Weak::as_ptr\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n@@ -1530,12 +1507,10 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`new`]: struct.Weak.html#method.new\n-    /// [`into_raw`]: struct.Weak.html#method.into_raw\n-    /// [`upgrade`]: struct.Weak.html#method.upgrade\n-    /// [`Weak`]: struct.Weak.html\n-    /// [`Arc`]: struct.Arc.html\n-    /// [`forget`]: ../../std/mem/fn.forget.html\n+    /// [`new`]: Weak::new\n+    /// [`into_raw`]: Weak::into_raw\n+    /// [`upgrade`]: Weak::upgrade\n+    /// [`forget`]: std::mem::forget\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n@@ -1565,9 +1540,6 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// Returns [`None`] if the inner value has since been dropped.\n     ///\n-    /// [`Arc`]: struct.Arc.html\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1619,8 +1591,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n-    ///\n-    /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() { inner.strong.load(SeqCst) } else { 0 }\n@@ -1637,8 +1607,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n     /// `Weak`s pointing to the same allocation.\n-    ///\n-    /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn weak_count(&self) -> usize {\n         self.inner()\n@@ -1716,7 +1684,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n-    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n+    /// [`ptr::eq`]: core::ptr::eq\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1765,8 +1733,7 @@ impl<T> Default for Weak<T> {\n     /// Calling [`upgrade`] on the return value always\n     /// gives [`None`].\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`upgrade`]: ../../std/sync/struct.Weak.html#method.upgrade\n+    /// [`upgrade`]: Weak::upgrade\n     ///\n     /// # Examples\n     ///"}, {"sha": "9acf43931c6bacfb59616385108d702bf59e1568", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 235, "deletions": 466, "changes": 701, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -57,6 +57,10 @@\n use crate::marker::DiscriminantKind;\n use crate::mem;\n \n+// These imports are used for simplifying intra-doc links\n+#[cfg(doc)]\n+use crate::sync::atomic::{self, AtomicBool, AtomicI32, AtomicIsize, AtomicU32, Ordering};\n+\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n #[rustc_deprecated(\n     reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n@@ -71,710 +75,510 @@ extern \"rust-intrinsic\" {\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange`][compare_exchange].\n-    ///\n-    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n     pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as both the `success` and `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `success` and\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `failure` parameters. For example,\n-    /// [`AtomicBool::compare_exchange_weak`][cew].\n-    ///\n-    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n+    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n     pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `load` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n+    /// [`atomic`] types via the `load` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n     pub fn atomic_load<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `load` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n+    /// [`atomic`] types via the `load` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n     pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `load` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n+    /// [`atomic`] types via the `load` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::load`].\n     pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n     pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `store` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n+    /// [`atomic`] types via the `store` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n     pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `store` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n+    /// [`atomic`] types via the `store` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n     pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `store` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n+    /// [`atomic`] types via the `store` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::store`].\n     pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n     pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `swap` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n+    /// [`atomic`] types via the `swap` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::swap`].\n     pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_add` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n+    /// [`atomic`] types via the `fetch_add` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n     pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n+    /// [`atomic`] types via the `fetch_sub` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n     pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_and` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n+    /// [`atomic`] types via the `fetch_and` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_and`].\n     pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n+    /// [`AtomicBool`] type via the `fetch_nand` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n     pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_or` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n+    /// [`atomic`] types via the `fetch_or` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_or`].\n     pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n-    /// as the `order`. For example,\n-    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n+    /// [`atomic`] types via the `fetch_xor` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n     pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_max`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_max).\n+    /// [`atomic`] signed integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_max`].\n     pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` signed integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n-    /// as the `order`. For example,\n-    /// [`AtomicI32::fetch_min`](../../std/sync/atomic/struct.AtomicI32.html#method.fetch_min).\n+    /// [`atomic`] signed integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_min`].\n     pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_min` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_min`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_min).\n+    /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_min`].\n     pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n-    /// `std::sync::atomic` unsigned integer types via the `fetch_max` method by passing\n-    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html#variant.Relaxed)\n-    /// as the `order`. For example,\n-    /// [`AtomicU32::fetch_max`](../../std/sync/atomic/struct.AtomicU32.html#method.fetch_max).\n+    /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n+    /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n@@ -823,33 +627,25 @@ extern \"rust-intrinsic\" {\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n-    /// by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n     pub fn atomic_fence();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n-    /// by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n     pub fn atomic_fence_acq();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n-    /// by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// [`atomic::fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n     pub fn atomic_fence_rel();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::fence`](../../std/sync/atomic/fn.fence.html)\n-    /// by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// [`atomic::fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n     pub fn atomic_fence_acqrel();\n \n@@ -861,9 +657,7 @@ extern \"rust-intrinsic\" {\n     /// such as when interacting with signal handlers.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n-    /// by passing\n-    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html#variant.SeqCst)\n+    /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence();\n     /// A compiler-only memory barrier.\n@@ -874,9 +668,7 @@ extern \"rust-intrinsic\" {\n     /// such as when interacting with signal handlers.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n-    /// by passing\n-    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html#variant.Acquire)\n+    /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence_acq();\n     /// A compiler-only memory barrier.\n@@ -887,9 +679,7 @@ extern \"rust-intrinsic\" {\n     /// such as when interacting with signal handlers.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n-    /// by passing\n-    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html#variant.Release)\n+    /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence_rel();\n     /// A compiler-only memory barrier.\n@@ -900,9 +690,7 @@ extern \"rust-intrinsic\" {\n     /// such as when interacting with signal handlers.\n     ///\n     /// The stabilized version of this intrinsic is available in\n-    /// [`std::sync::atomic::compiler_fence`](../../std/sync/atomic/fn.compiler_fence.html)\n-    /// by passing\n-    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html#variant.AcqRel)\n+    /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence_acqrel();\n \n@@ -930,8 +718,7 @@ extern \"rust-intrinsic\" {\n     /// macro, which panics when it is executed, it is *undefined behavior* to\n     /// reach code marked with this function.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::hint::unreachable_unchecked`](../../std/hint/fn.unreachable_unchecked.html).\n+    /// The stabilized version of this intrinsic is [`crate::hint::unreachable_unchecked`].\n     #[rustc_const_unstable(feature = \"const_unreachable_unchecked\", issue = \"53188\")]\n     pub fn unreachable() -> !;\n \n@@ -975,23 +762,20 @@ extern \"rust-intrinsic\" {\n     /// More specifically, this is the offset in bytes between successive\n     /// items of the same type, including alignment padding.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::size_of`](../../std/mem/fn.size_of.html).\n+    /// The stabilized version of this intrinsic is [`size_of`].\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     pub fn size_of<T>() -> usize;\n \n     /// Moves a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::ptr::write`](../../std/ptr/fn.write.html).\n+    /// The stabilized version of this intrinsic is [`crate::ptr::write`].\n     pub fn move_val_init<T>(dst: *mut T, src: T);\n \n     /// The minimum alignment of a type.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::align_of`](../../std/mem/fn.align_of.html).\n+    /// The stabilized version of this intrinsic is [`crate::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     pub fn min_align_of<T>() -> usize;\n     /// The preferred alignment of a type.\n@@ -1002,30 +786,26 @@ extern \"rust-intrinsic\" {\n \n     /// The size of the referenced value in bytes.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::size_of_val`](../../std/mem/fn.size_of_val.html).\n+    /// The stabilized version of this intrinsic is [`size_of_val`].\n     #[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n     /// The required alignment of the referenced value.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::align_of_val`](../../std/mem/fn.align_of_val.html).\n+    /// The stabilized version of this intrinsic is [`crate::mem::align_of_val`].\n     #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::any::type_name`](../../std/any/fn.type_name.html)\n+    /// The stabilized version of this intrinsic is [`crate::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::any::TypeId::of`](../../std/any/struct.TypeId.html#method.of)\n+    /// The stabilized version of this intrinsic is [`crate::any::TypeId::of`].\n     #[rustc_const_stable(feature = \"const_type_id\", since = \"1.46.0\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n@@ -1049,15 +829,14 @@ extern \"rust-intrinsic\" {\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n     ///\n-    /// Consider using [`std::panic::Location::caller`](../../std/panic/struct.Location.html#method.caller)\n-    /// instead.\n+    /// Consider using [`crate::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"47809\")]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n     ///\n-    /// This exists solely for [`mem::forget_unsized`](../../std/mem/fn.forget_unsized.html);\n-    /// normal `forget` uses `ManuallyDrop` instead.\n+    /// This exists solely for [`mem::forget_unsized`]; normal `forget` uses\n+    /// `ManuallyDrop` instead.\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1300,8 +1079,7 @@ extern \"rust-intrinsic\" {\n     /// If the actual type neither requires drop glue nor implements\n     /// `Copy`, then the return value of this function is unspecified.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::needs_drop`](../../std/mem/fn.needs_drop.html).\n+    /// The stabilized version of this intrinsic is [`needs_drop`].\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     pub fn needs_drop<T>() -> bool;\n \n@@ -1371,13 +1149,11 @@ extern \"rust-intrinsic\" {\n \n     /// Performs a volatile load from the `src` pointer.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n+    /// The stabilized version of this intrinsic is [`crate::ptr::read_volatile`].\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n+    /// The stabilized version of this intrinsic is [`crate::ptr::write_volatile`].\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Performs a volatile load from the `src` pointer\n@@ -1526,22 +1302,22 @@ extern \"rust-intrinsic\" {\n     /// Returns the minimum of two `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::f32::min`](../../std/primitive.f32.html#method.min)\n+    /// [`f32::min`]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::f64::min`](../../std/primitive.f64.html#method.min)\n+    /// [`f64::min`]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::f32::max`](../../std/primitive.f32.html#method.max)\n+    /// [`f32::max`]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n-    /// [`std::f64::max`](../../std/primitive.f64.html#method.max)\n+    /// [`f64::max`]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n \n     /// Copies the sign from `y` to `x` for `f32` values.\n@@ -1648,23 +1424,22 @@ extern \"rust-intrinsic\" {\n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     ///\n-    /// Stabilized as [`f32::to_int_unchecked`](../../std/primitive.f32.html#method.to_int_unchecked)\n-    /// and [`f64::to_int_unchecked`](../../std/primitive.f64.html#method.to_int_unchecked).\n+    /// Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].\n     pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `count_ones` method. For example,\n-    /// [`std::u32::count_ones`](../../std/primitive.u32.html#method.count_ones)\n+    /// [`u32::count_ones`]\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n     pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `leading_zeros` method. For example,\n-    /// [`std::u32::leading_zeros`](../../std/primitive.u32.html#method.leading_zeros)\n+    /// [`u32::leading_zeros`]\n     ///\n     /// # Examples\n     ///\n@@ -1715,7 +1490,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `trailing_zeros` method. For example,\n-    /// [`std::u32::trailing_zeros`](../../std/primitive.u32.html#method.trailing_zeros)\n+    /// [`u32::trailing_zeros`]\n     ///\n     /// # Examples\n     ///\n@@ -1766,39 +1541,39 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `swap_bytes` method. For example,\n-    /// [`std::u32::swap_bytes`](../../std/primitive.u32.html#method.swap_bytes)\n+    /// [`u32::swap_bytes`]\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n     pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `reverse_bits` method. For example,\n-    /// [`std::u32::reverse_bits`](../../std/primitive.u32.html#method.reverse_bits)\n+    /// [`u32::reverse_bits`]\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n     pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,\n-    /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n+    /// [`u32::overflowing_add`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_sub` method. For example,\n-    /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n+    /// [`u32::overflowing_sub`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_mul` method. For example,\n-    /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n+    /// [`u32::overflowing_mul`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n@@ -1813,15 +1588,15 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_div` method. For example,\n-    /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n+    /// [`u32::checked_div`]\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior where y = 0 or x = `T::MIN` and y = -1\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n-    /// [`std::u32::checked_rem`](../../std/primitive.u32.html#method.checked_rem)\n+    /// [`u32::checked_rem`]\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n@@ -1830,15 +1605,15 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_shl` method. For example,\n-    /// [`std::u32::checked_shl`](../../std/primitive.u32.html#method.checked_shl)\n+    /// [`u32::checked_shl`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// y < 0 or y >= N, where N is the width of T in bits.\n     ///\n     /// Safe wrappers for this intrinsic are available on the integer\n     /// primitives via the `checked_shr` method. For example,\n-    /// [`std::u32::checked_shr`](../../std/primitive.u32.html#method.checked_shr)\n+    /// [`u32::checked_shr`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n@@ -1867,68 +1642,66 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n-    /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n+    /// [`u32::rotate_left`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n-    /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n+    /// [`u32::rotate_right`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_add` method. For example,\n-    /// [`std::u32::checked_add`](../../std/primitive.u32.html#method.checked_add)\n+    /// [`u32::checked_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_sub` method. For example,\n-    /// [`std::u32::checked_sub`](../../std/primitive.u32.html#method.checked_sub)\n+    /// [`u32::checked_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_mul` method. For example,\n-    /// [`std::u32::checked_mul`](../../std/primitive.u32.html#method.checked_mul)\n+    /// [`u32::checked_mul`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, while saturating at numeric bounds.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_add` method. For example,\n-    /// [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n+    /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, while saturating at numeric bounds.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `saturating_sub` method. For example,\n-    /// [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n+    /// [`u32::saturating_sub`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v',\n     /// cast to a `u64`; if `T` has no discriminant, returns 0.\n     ///\n-    /// The stabilized version of this intrinsic is\n-    /// [`std::mem::discriminant`](../../std/mem/fn.discriminant.html)\n+    /// The stabilized version of this intrinsic is [`crate::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n     /// if `T` has no variants, returns 0. Uninhabited variants will be counted.\n     ///\n-    /// The to-be-stabilized version of this intrinsic is\n-    /// [`std::mem::variant_count`](../../std/mem/fn.variant_count.html)\n+    /// The to-be-stabilized version of this intrinsic is [`variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n     pub fn variant_count<T>() -> usize;\n \n@@ -1989,7 +1762,6 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n /// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n /// with the argument order swapped.\n ///\n-/// [`copy`]: ./fn.copy.html\n /// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n ///\n /// # Safety\n@@ -2014,10 +1786,9 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n /// `0`, the pointers must be non-NULL and properly aligned.\n ///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ../ptr/fn.read.html\n-/// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n-/// [valid]: ../ptr/index.html#safety\n+/// [`read`]: crate::ptr::read\n+/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+/// [valid]: crate::ptr#safety\n ///\n /// # Examples\n ///\n@@ -2096,7 +1867,6 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n /// order swapped. Copying takes place as if the bytes were copied from `src`\n /// to a temporary array and then copied from the array to `dst`.\n ///\n-/// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n /// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n ///\n /// # Safety\n@@ -2117,10 +1887,9 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n /// `0`, the pointers must be non-NULL and properly aligned.\n ///\n-/// [`Copy`]: ../marker/trait.Copy.html\n-/// [`read`]: ../ptr/fn.read.html\n-/// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n-/// [valid]: ../ptr/index.html#safety\n+/// [`read`]: crate::ptr::read\n+/// [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n+/// [valid]: crate::ptr#safety\n ///\n /// # Examples\n ///\n@@ -2178,7 +1947,7 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n /// `0`, the pointer must be non-NULL and properly aligned.\n ///\n-/// [valid]: ../ptr/index.html#safety\n+/// [valid]: crate::ptr#safety\n ///\n /// # Examples\n ///"}, {"sha": "d6c097eee17bf96ff18540667972043d8b1e86c8", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -28,7 +28,6 @@\n /// [method resolution] and [type coercions].\n ///\n /// [book]: ../../book/ch15-02-deref.html\n-/// [`DerefMut`]: trait.DerefMut.html\n /// [more]: #more-on-deref-coercion\n /// [ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n /// [method resolution]: ../../reference/expressions/method-call-expr.html\n@@ -125,7 +124,6 @@ impl<T: ?Sized> Deref for &mut T {\n /// [method resolution] and [type coercions].\n ///\n /// [book]: ../../book/ch15-02-deref.html\n-/// [`Deref`]: trait.Deref.html\n /// [more]: #more-on-deref-coercion\n /// [ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n /// [method resolution]: ../../reference/expressions/method-call-expr.html"}, {"sha": "ce7d1c3d06ddc5dea1dfb68a152a7551c4d7e4af", "filename": "library/core/src/ops/drop.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -78,9 +78,9 @@\n ///\n /// In other words, if you tried to explicitly call `Drop::drop` in the above example, you'd get a compiler error.\n ///\n-/// If you'd like explicitly call the destructor of a value, [`std::mem::drop`] can be used instead.\n+/// If you'd like explicitly call the destructor of a value, [`mem::drop`] can be used instead.\n ///\n-/// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n+/// [`mem::drop`]: drop\n ///\n /// ## Drop order\n ///\n@@ -132,16 +132,14 @@\n /// are `Copy` get implicitly duplicated by the compiler, making it very\n /// hard to predict when, and how often destructors will be executed. As such,\n /// these types cannot have destructors.\n-///\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n #[lang = \"drop\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {\n     /// Executes the destructor for this type.\n     ///\n     /// This method is called implicitly when the value goes out of scope,\n     /// and cannot be called explicitly (this is compiler error [E0040]).\n-    /// However, the [`std::mem::drop`] function in the prelude can be\n+    /// However, the [`mem::drop`] function in the prelude can be\n     /// used to call the argument's `Drop` implementation.\n     ///\n     /// When this method has been called, `self` has not yet been deallocated.\n@@ -156,12 +154,12 @@ pub trait Drop {\n     /// Note that even if this panics, the value is considered to be dropped;\n     /// you must not cause `drop` to be called again. This is normally automatically\n     /// handled by the compiler, but when using unsafe code, can sometimes occur\n-    /// unintentionally, particularly when using [`std::ptr::drop_in_place`].\n+    /// unintentionally, particularly when using [`ptr::drop_in_place`].\n     ///\n     /// [E0040]: ../../error-index.html#E0040\n-    /// [`panic!`]: ../macro.panic.html\n-    /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n-    /// [`std::ptr::drop_in_place`]: ../../std/ptr/fn.drop_in_place.html\n+    /// [`panic!`]: crate::panic!\n+    /// [`mem::drop`]: drop\n+    /// [`ptr::drop_in_place`]: crate::ptr::drop_in_place\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn drop(&mut self);\n }"}, {"sha": "bfdec43f7d80b3c211669655f1f54ae9f5ad6d48", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -28,8 +28,6 @@\n /// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n ///\n /// [book]: ../../book/ch13-01-closures.html\n-/// [`FnMut`]: trait.FnMut.html\n-/// [`FnOnce`]: trait.FnOnce.html\n /// [function pointers]: ../../std/primitive.fn.html\n /// [nomicon]: ../../nomicon/hrtb.html\n ///\n@@ -99,8 +97,6 @@ pub trait Fn<Args>: FnMut<Args> {\n /// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n ///\n /// [book]: ../../book/ch13-01-closures.html\n-/// [`Fn`]: trait.Fn.html\n-/// [`FnOnce`]: trait.FnOnce.html\n /// [function pointers]: ../../std/primitive.fn.html\n /// [nomicon]: ../../nomicon/hrtb.html\n ///\n@@ -180,8 +176,6 @@ pub trait FnMut<Args>: FnOnce<Args> {\n /// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n ///\n /// [book]: ../../book/ch13-01-closures.html\n-/// [`Fn`]: trait.Fn.html\n-/// [`FnMut`]: trait.FnMut.html\n /// [function pointers]: ../../std/primitive.fn.html\n /// [nomicon]: ../../nomicon/hrtb.html\n ///"}, {"sha": "3c2ada57612337e0d865168bc7dc8b4d07af634b", "filename": "library/core/src/ops/index.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -5,9 +5,6 @@\n /// [`IndexMut`] is used instead. This allows nice things such as\n /// `let value = v[index]` if the type of `value` implements [`Copy`].\n ///\n-/// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n-///\n /// # Examples\n ///\n /// The following example implements `Index` on a read-only `NucleotideCount`\n@@ -76,8 +73,6 @@ pub trait Index<Idx: ?Sized> {\n /// an immutable value is requested, the [`Index`] trait is used instead. This\n /// allows nice things such as `v[index] = value`.\n ///\n-/// [`Index`]: ../../std/ops/trait.Index.html\n-///\n /// # Examples\n ///\n /// A very simple implementation of a `Balance` struct that has two sides, where"}, {"sha": "c19bd6e441e695950f5d258eabe83a816cdd9be3", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -133,13 +133,7 @@\n //! // `consume_and_return_x` can no longer be invoked at this point\n //! ```\n //!\n-//! [`Fn`]: trait.Fn.html\n-//! [`FnMut`]: trait.FnMut.html\n-//! [`FnOnce`]: trait.FnOnce.html\n-//! [`Add`]: trait.Add.html\n-//! [`Sub`]: trait.Sub.html\n-//! [`Mul`]: trait.Mul.html\n-//! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n+//! [`clone`]: Clone::clone\n //! [operator precedence]: ../../reference/expressions.html#expression-precedence\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ccabd66aaf6ebd738c13b9770dce99f299f84d91", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -35,9 +35,7 @@ use crate::hash::Hash;\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n-/// [`IntoIterator`]: ../iter/trait.Iterator.html\n-/// [`Iterator`]: ../iter/trait.IntoIterator.html\n-/// [slicing index]: ../slice/trait.SliceIndex.html\n+/// [slicing index]: crate::slice::SliceIndex\n #[cfg_attr(not(bootstrap), lang = \"RangeFull\")]\n #[doc(alias = \"..\")]\n #[derive(Copy, Clone, Default, PartialEq, Eq, Hash)]\n@@ -178,8 +176,6 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n /// assert_eq!(arr[1.. 3], [  1,2    ]);\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n-///\n-/// [`Iterator`]: ../iter/trait.IntoIterator.html\n #[cfg_attr(not(bootstrap), lang = \"RangeFrom\")]\n #[doc(alias = \"..\")]\n #[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n@@ -260,9 +256,7 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n-/// [`IntoIterator`]: ../iter/trait.Iterator.html\n-/// [`Iterator`]: ../iter/trait.IntoIterator.html\n-/// [slicing index]: ../slice/trait.SliceIndex.html\n+/// [slicing index]: crate::slice::SliceIndex\n #[cfg_attr(not(bootstrap), lang = \"RangeTo\")]\n #[doc(alias = \"..\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -315,8 +309,8 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// iteration has finished are **unspecified** other than that [`.is_empty()`]\n /// will return `true` once no more values will be produced.\n ///\n-/// [fused]: ../iter/trait.FusedIterator.html\n-/// [`.is_empty()`]: #method.is_empty\n+/// [fused]: crate::iter::FusedIterator\n+/// [`.is_empty()`]: RangeInclusive::is_empty\n ///\n /// # Examples\n ///\n@@ -383,8 +377,8 @@ impl<Idx> RangeInclusive<Idx> {\n     /// Note: the value returned by this method is unspecified after the range\n     /// has been iterated to exhaustion.\n     ///\n-    /// [`end()`]: #method.end\n-    /// [`is_empty()`]: #method.is_empty\n+    /// [`end()`]: RangeInclusive::end\n+    /// [`is_empty()`]: RangeInclusive::is_empty\n     ///\n     /// # Examples\n     ///\n@@ -408,8 +402,8 @@ impl<Idx> RangeInclusive<Idx> {\n     /// Note: the value returned by this method is unspecified after the range\n     /// has been iterated to exhaustion.\n     ///\n-    /// [`start()`]: #method.start\n-    /// [`is_empty()`]: #method.is_empty\n+    /// [`start()`]: RangeInclusive::start\n+    /// [`is_empty()`]: RangeInclusive::is_empty\n     ///\n     /// # Examples\n     ///\n@@ -558,9 +552,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// assert_eq!(arr[1..=3], [  1,2,3  ]);\n /// ```\n ///\n-/// [`IntoIterator`]: ../iter/trait.Iterator.html\n-/// [`Iterator`]: ../iter/trait.IntoIterator.html\n-/// [slicing index]: ../slice/trait.SliceIndex.html\n+/// [slicing index]: crate::slice::SliceIndex\n #[cfg_attr(not(bootstrap), lang = \"RangeToInclusive\")]\n #[doc(alias = \"..=\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "483362023b22c77bc5f340260804f825c2766080", "filename": "library/core/src/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Funsize.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -29,7 +29,7 @@ use crate::marker::Unsize;\n /// pointers. It is implemented automatically by the compiler.\n ///\n /// [dst-coerce]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n-/// [unsize]: ../marker/trait.Unsize.html\n+/// [unsize]: crate::marker::Unsize\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n #[lang = \"coerce_unsized\"]"}, {"sha": "1cc2de5b8756a8bdc8cc06e2fd26374aa1c45f90", "filename": "library/core/src/str/pattern.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -12,7 +12,7 @@\n //! # Examples\n //!\n //! [`Pattern`] is [implemented][pattern-impls] in the stable API for\n-//! [`&str`], [`char`], slices of [`char`], and functions and closures\n+//! [`&str`][`str`], [`char`], slices of [`char`], and functions and closures\n //! implementing `FnMut(char) -> bool`.\n //!\n //! ```\n@@ -28,13 +28,6 @@\n //! assert_eq!(s.find(|c: char| c.is_ascii_punctuation()), Some(35));\n //! ```\n //!\n-//! [`&str`]: ../../../std/primitive.str.html\n-//! [`char`]: ../../../std/primitive.char.html\n-//! [`str`]: ../../../std/primitive.str.html\n-//! [`DoubleEndedSearcher`]: trait.DoubleEndedSearcher.html\n-//! [`Pattern`]: trait.Pattern.html\n-//! [`ReverseSearcher`]: trait.ReverseSearcher.html\n-//! [`Searcher`]: trait.Searcher.html\n //! [pattern-impls]: trait.Pattern.html#implementors\n \n #![unstable(\n@@ -52,13 +45,13 @@ use crate::slice::memchr;\n /// A string pattern.\n ///\n /// A `Pattern<'a>` expresses that the implementing type\n-/// can be used as a string pattern for searching in a `&'a str`.\n+/// can be used as a string pattern for searching in a [`&'a str`][str].\n ///\n /// For example, both `'a'` and `\"aa\"` are patterns that\n /// would match at index `1` in the string `\"baaaab\"`.\n ///\n /// The trait itself acts as a builder for an associated\n-/// `Searcher` type, which does the actual work of finding\n+/// [`Searcher`] type, which does the actual work of finding\n /// occurrences of the pattern in a string.\n ///\n /// Depending on the type of the pattern, the behaviour of methods like\n@@ -75,6 +68,7 @@ use crate::slice::memchr;\n /// | `&String`                | is substring                              |\n ///\n /// # Examples\n+///\n /// ```\n /// // &str\n /// assert_eq!(\"abaaa\".find(\"ba\"), Some(1));\n@@ -94,9 +88,6 @@ use crate::slice::memchr;\n /// assert_eq!(\"abcdef_z\".find(|ch| ch > 'd' && ch < 'y'), Some(4));\n /// assert_eq!(\"abcddd_z\".find(|ch| ch > 'd' && ch < 'y'), None);\n /// ```\n-///\n-/// [`str::find`]: ../../../std/primitive.str.html#method.find\n-/// [`str::contains`]: ../../../std/primitive.str.html#method.contains\n pub trait Pattern<'a>: Sized {\n     /// Associated searcher for this pattern\n     type Searcher: Searcher<'a>;\n@@ -165,7 +156,7 @@ pub trait Pattern<'a>: Sized {\n \n // Searcher\n \n-/// Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.\n+/// Result of calling [`Searcher::next()`] or [`ReverseSearcher::next_back()`].\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n pub enum SearchStep {\n     /// Expresses that a match of the pattern has been found at\n@@ -188,44 +179,47 @@ pub enum SearchStep {\n /// matches of a pattern starting from the front (left) of a string.\n ///\n /// It will be implemented by associated `Searcher`\n-/// types of the `Pattern` trait.\n+/// types of the [`Pattern`] trait.\n ///\n /// The trait is marked unsafe because the indices returned by the\n-/// `next()` methods are required to lie on valid utf8 boundaries in\n-/// the haystack. This enables consumers of this trait to\n+/// [`next()`][Searcher::next] methods are required to lie on valid utf8\n+/// boundaries in the haystack. This enables consumers of this trait to\n /// slice the haystack without additional runtime checks.\n pub unsafe trait Searcher<'a> {\n     /// Getter for the underlying string to be searched in\n     ///\n-    /// Will always return the same `&str`\n+    /// Will always return the same [`&str`][str].\n     fn haystack(&self) -> &'a str;\n \n     /// Performs the next search step starting from the front.\n     ///\n-    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n-    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n-    ///   pattern, even partially.\n-    /// - Returns `Done` if every byte of the haystack has been visited\n+    /// - Returns [`Match(a, b)`][SearchStep::Match] if `haystack[a..b]` matches\n+    ///   the pattern.\n+    /// - Returns [`Reject(a, b)`][SearchStep::Reject] if `haystack[a..b]` can\n+    ///   not match the pattern, even partially.\n+    /// - Returns [`Done`][SearchStep::Done] if every byte of the haystack has\n+    ///   been visited.\n     ///\n-    /// The stream of `Match` and `Reject` values up to a `Done`\n+    /// The stream of [`Match`][SearchStep::Match] and\n+    /// [`Reject`][SearchStep::Reject] values up to a [`Done`][SearchStep::Done]\n     /// will contain index ranges that are adjacent, non-overlapping,\n     /// covering the whole haystack, and laying on utf8 boundaries.\n     ///\n-    /// A `Match` result needs to contain the whole matched pattern,\n-    /// however `Reject` results may be split up into arbitrary\n-    /// many adjacent fragments. Both ranges may have zero length.\n+    /// A [`Match`][SearchStep::Match] result needs to contain the whole matched\n+    /// pattern, however [`Reject`][SearchStep::Reject] results may be split up\n+    /// into arbitrary many adjacent fragments. Both ranges may have zero length.\n     ///\n     /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n     /// might produce the stream\n     /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n     fn next(&mut self) -> SearchStep;\n \n-    /// Finds the next `Match` result. See `next()`\n+    /// Finds the next [`Match`][SearchStep::Match] result. See [`next()`][Searcher::next].\n     ///\n-    /// Unlike next(), there is no guarantee that the returned ranges\n-    /// of this and next_reject will overlap. This will return (start_match, end_match),\n-    /// where start_match is the index of where the match begins, and end_match is\n-    /// the index after the end of the match.\n+    /// Unlike [`next()`][Searcher::next], there is no guarantee that the returned ranges\n+    /// of this and [`next_reject`][Searcher::next_reject] will overlap. This will return\n+    /// `(start_match, end_match)`, where start_match is the index of where\n+    /// the match begins, and end_match is the index after the end of the match.\n     #[inline]\n     fn next_match(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -237,10 +231,11 @@ pub unsafe trait Searcher<'a> {\n         }\n     }\n \n-    /// Finds the next `Reject` result. See `next()` and `next_match()`\n+    /// Finds the next [`Reject`][SearchStep::Reject] result. See [`next()`][Searcher::next]\n+    /// and [`next_match()`][Searcher::next_match].\n     ///\n-    /// Unlike next(), there is no guarantee that the returned ranges\n-    /// of this and next_match will overlap.\n+    /// Unlike [`next()`][Searcher::next], there is no guarantee that the returned ranges\n+    /// of this and [`next_match`][Searcher::next_match] will overlap.\n     #[inline]\n     fn next_reject(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -258,37 +253,41 @@ pub unsafe trait Searcher<'a> {\n /// This trait provides methods for searching for non-overlapping\n /// matches of a pattern starting from the back (right) of a string.\n ///\n-/// It will be implemented by associated `Searcher`\n-/// types of the `Pattern` trait if the pattern supports searching\n+/// It will be implemented by associated [`Searcher`]\n+/// types of the [`Pattern`] trait if the pattern supports searching\n /// for it from the back.\n ///\n /// The index ranges returned by this trait are not required\n /// to exactly match those of the forward search in reverse.\n ///\n /// For the reason why this trait is marked unsafe, see them\n-/// parent trait `Searcher`.\n+/// parent trait [`Searcher`].\n pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     /// Performs the next search step starting from the back.\n     ///\n-    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n-    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n-    ///   pattern, even partially.\n-    /// - Returns `Done` if every byte of the haystack has been visited\n+    /// - Returns [`Match(a, b)`][SearchStep::Match] if `haystack[a..b]`\n+    ///   matches the pattern.\n+    /// - Returns [`Reject(a, b)`][SearchStep::Reject] if `haystack[a..b]`\n+    ///   can not match the pattern, even partially.\n+    /// - Returns [`Done`][SearchStep::Done] if every byte of the haystack\n+    ///   has been visited\n     ///\n-    /// The stream of `Match` and `Reject` values up to a `Done`\n+    /// The stream of [`Match`][SearchStep::Match] and\n+    /// [`Reject`][SearchStep::Reject] values up to a [`Done`][SearchStep::Done]\n     /// will contain index ranges that are adjacent, non-overlapping,\n     /// covering the whole haystack, and laying on utf8 boundaries.\n     ///\n-    /// A `Match` result needs to contain the whole matched pattern,\n-    /// however `Reject` results may be split up into arbitrary\n-    /// many adjacent fragments. Both ranges may have zero length.\n+    /// A [`Match`][SearchStep::Match] result needs to contain the whole matched\n+    /// pattern, however [`Reject`][SearchStep::Reject] results may be split up\n+    /// into arbitrary many adjacent fragments. Both ranges may have zero length.\n     ///\n     /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n     /// might produce the stream\n-    /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n+    /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`.\n     fn next_back(&mut self) -> SearchStep;\n \n-    /// Finds the next `Match` result. See `next_back()`\n+    /// Finds the next [`Match`][SearchStep::Match] result.\n+    /// See [`next_back()`][ReverseSearcher::next_back].\n     #[inline]\n     fn next_match_back(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -300,7 +299,8 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n         }\n     }\n \n-    /// Finds the next `Reject` result. See `next_back()`\n+    /// Finds the next [`Reject`][SearchStep::Reject] result.\n+    /// See [`next_back()`][ReverseSearcher::next_back].\n     #[inline]\n     fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -313,10 +313,10 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     }\n }\n \n-/// A marker trait to express that a `ReverseSearcher`\n-/// can be used for a `DoubleEndedIterator` implementation.\n+/// A marker trait to express that a [`ReverseSearcher`]\n+/// can be used for a [`DoubleEndedIterator`] implementation.\n ///\n-/// For this, the impl of `Searcher` and `ReverseSearcher` need\n+/// For this, the impl of [`Searcher`] and [`ReverseSearcher`] need\n /// to follow these conditions:\n ///\n /// - All results of `next()` need to be identical\n@@ -328,7 +328,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n /// # Examples\n ///\n /// `char::Searcher` is a `DoubleEndedSearcher` because searching for a\n-/// `char` only requires looking at one at a time, which behaves the same\n+/// [`char`] only requires looking at one at a time, which behaves the same\n /// from both ends.\n ///\n /// `(&str)::Searcher` is not a `DoubleEndedSearcher` because\n@@ -355,13 +355,13 @@ pub struct CharSearcher<'a> {\n     /// `finger_back` is the current byte index of the reverse search.\n     /// Imagine that it exists after the byte at its index, i.e.\n     /// haystack[finger_back - 1] is the last byte of the slice we must inspect during\n-    /// forward searching (and thus the first byte to be inspected when calling next_back())\n+    /// forward searching (and thus the first byte to be inspected when calling next_back()).\n     finger_back: usize,\n     /// The character being searched for\n     needle: char,\n \n     // safety invariant: `utf8_size` must be less than 5\n-    /// The number of bytes `needle` takes up when encoded in utf8\n+    /// The number of bytes `needle` takes up when encoded in utf8.\n     utf8_size: usize,\n     /// A utf8 encoded copy of the `needle`\n     utf8_encoded: [u8; 4],\n@@ -521,7 +521,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n \n impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n \n-/// Searches for chars that are equal to a given `char`.\n+/// Searches for chars that are equal to a given [`char`].\n ///\n /// # Examples\n ///\n@@ -772,7 +772,7 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n \n impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n \n-/// Searches for chars that are equal to any of the chars in the slice.\n+/// Searches for chars that are equal to any of the [`char`]s in the slice.\n ///\n /// # Examples\n ///\n@@ -821,7 +821,7 @@ where\n \n impl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F> where F: FnMut(char) -> bool {}\n \n-/// Searches for chars that match the given predicate.\n+/// Searches for [`char`]s that match the given predicate.\n ///\n /// # Examples\n ///"}, {"sha": "f45e22950643826ae87425146aceb7e597b92f8d", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -467,3 +467,36 @@ $ rustdoc src/lib.rs -Z unstable-options --runtool valgrind\n ```\n \n Another use case would be to run a test inside an emulator, or through a Virtual Machine.\n+\n+### `--show-coverage`: get statistics about code documentation coverage\n+\n+This option allows you to get a nice overview over your code documentation coverage, including both\n+doc-comments and code examples in the doc-comments. Example:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --show-coverage\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| lib.rs                              |          4 |     100.0% |          1 |      25.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          4 |     100.0% |          1 |      25.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+```\n+\n+You can also use this option with the `--output-format` one:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --show-coverage --output-format json\n+{\"lib.rs\":{\"total\":4,\"with_docs\":4,\"total_examples\":4,\"with_examples\":1}}\n+```\n+\n+Calculating code examples follows these rules:\n+\n+1. These items aren't accounted by default:\n+  * struct/union field\n+  * enum variant\n+  * constant\n+  * static\n+  * typedef\n+2. If one of the previously listed items has a code example, then it'll be counted."}, {"sha": "c43d91bf070edd97a878a9acdec8039fe954d4b1", "filename": "src/doc/unstable-book/src/compiler-flags/control-flow-guard.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcontrol-flow-guard.md?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -6,7 +6,7 @@ The tracking issue for this feature is: [#68793](https://github.com/rust-lang/ru\n \n The rustc flag `-Z control-flow-guard` enables the Windows [Control Flow Guard](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard) (CFG) platform security feature.\n \n-CFG is an exploit mitigation designed to enforce control-flow integrity for software running on supported Windows platforms (Windows 8.1 onwards). Specifically, CFG uses runtime checks to validate the target address of every indirect call/jump before allowing the call to complete. \n+CFG is an exploit mitigation designed to enforce control-flow integrity for software running on supported [Windows platforms (Windows 8.1 onwards)](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard). Specifically, CFG uses runtime checks to validate the target address of every indirect call/jump before allowing the call to complete. \n \n During compilation, the compiler identifies all indirect calls/jumps and adds CFG checks. It also emits metadata containing the relative addresses of all address-taken functions. At runtime, if the binary is run on a CFG-aware operating system, the loader uses the CFG metadata to generate a bitmap of the address space and marks those addresses that contain valid targets. On each indirect call, the inserted check determines whether the target address is marked in this bitmap. If the target is not valid, the process is terminated.\n \n@@ -19,8 +19,9 @@ CFG functionality is completely implemented in the LLVM backend and is supported\n \n ## When to use Control Flow Guard\n \n-The primary motivation for enabling CFG in Rust is to enhance security when linking against non-Rust code, especially C/C++ code. To achieve full CFG protection, all indirect calls (including any from Rust code) must have the appropriate CFG checks, as added by this flag. CFG can also improve security for Rust code that uses the `unsafe` keyword\n+The primary motivation for enabling CFG in Rust is to enhance security when linking against non-Rust code, especially C/C++ code. To achieve full CFG protection, all indirect calls (including any from Rust code) must have the appropriate CFG checks, as added by this flag. CFG can also improve security for Rust code that uses the `unsafe` keyword.\n \n+Another motivation behind CFG is to harden programs against [return-oriented programming (ROP)](https://en.wikipedia.org/wiki/Return-oriented_programming) attacks. CFG disallows an attacker from taking advantage of the program's own instructions while redirecting control flow in unexpected ways.\n \n ## Overhead of Control Flow Guard\n "}, {"sha": "4fef94dde5f7a3f41dc60a31cceff88262bd3172", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -479,10 +479,13 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n                         _ => unreachable!(),\n                     }\n                 } else {\n-                    // We use i32 as the type for discarded outputs\n-                    's'\n+                    // We use i64x2 as the type for discarded outputs\n+                    'q'\n                 };\n                 format!(\"{{{}{}}}\", class, idx)\n+            } else if reg == InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) {\n+                // LLVM doesn't recognize x30\n+                \"lr\".to_string()\n             } else {\n                 format!(\"{{{}}}\", reg.name())\n             }"}, {"sha": "b0209ac2899d616fd7e0fab082ea4b2915e5ed1c", "filename": "src/librustc_lexer/src/tests.rs", "status": "modified", "additions": 121, "deletions": 136, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,137 +1,122 @@\n-#[cfg(test)]\n-mod tests {\n-    use crate::*;\n-\n-    fn check_raw_str(s: &str, expected_hashes: u16, expected_err: Option<RawStrError>) {\n-        let s = &format!(\"r{}\", s);\n-        let mut cursor = Cursor::new(s);\n-        cursor.bump();\n-        let (n_hashes, err) = cursor.raw_double_quoted_string(0);\n-        assert_eq!(n_hashes, expected_hashes);\n-        assert_eq!(err, expected_err);\n-    }\n-\n-    #[test]\n-    fn test_naked_raw_str() {\n-        check_raw_str(r#\"\"abc\"\"#, 0, None);\n-    }\n-\n-    #[test]\n-    fn test_raw_no_start() {\n-        check_raw_str(r##\"\"abc\"#\"##, 0, None);\n-    }\n-\n-    #[test]\n-    fn test_too_many_terminators() {\n-        // this error is handled in the parser later\n-        check_raw_str(r###\"#\"abc\"##\"###, 1, None);\n-    }\n-\n-    #[test]\n-    fn test_unterminated() {\n-        check_raw_str(\n-            r#\"#\"abc\"#,\n-            1,\n-            Some(RawStrError::NoTerminator {\n-                expected: 1,\n-                found: 0,\n-                possible_terminator_offset: None,\n-            }),\n-        );\n-        check_raw_str(\n-            r###\"##\"abc\"#\"###,\n-            2,\n-            Some(RawStrError::NoTerminator {\n-                expected: 2,\n-                found: 1,\n-                possible_terminator_offset: Some(7),\n-            }),\n-        );\n-        // We're looking for \"# not just any #\n-        check_raw_str(\n-            r###\"##\"abc#\"###,\n-            2,\n-            Some(RawStrError::NoTerminator {\n-                expected: 2,\n-                found: 0,\n-                possible_terminator_offset: None,\n-            }),\n-        )\n-    }\n-\n-    #[test]\n-    fn test_invalid_start() {\n-        check_raw_str(r##\"#~\"abc\"#\"##, 1, Some(RawStrError::InvalidStarter { bad_char: '~' }));\n-    }\n-\n-    #[test]\n-    fn test_unterminated_no_pound() {\n-        // https://github.com/rust-lang/rust/issues/70677\n-        check_raw_str(\n-            r#\"\"\"#,\n-            0,\n-            Some(RawStrError::NoTerminator {\n-                expected: 0,\n-                found: 0,\n-                possible_terminator_offset: None,\n-            }),\n-        );\n-    }\n-\n-    #[test]\n-    fn test_valid_shebang() {\n-        // https://github.com/rust-lang/rust/issues/70528\n-        let input = \"#!/usr/bin/rustrun\\nlet x = 5;\";\n-        assert_eq!(strip_shebang(input), Some(18));\n-    }\n-\n-    #[test]\n-    fn test_invalid_shebang_valid_rust_syntax() {\n-        // https://github.com/rust-lang/rust/issues/70528\n-        let input = \"#!    [bad_attribute]\";\n-        assert_eq!(strip_shebang(input), None);\n-    }\n-\n-    #[test]\n-    fn test_shebang_second_line() {\n-        // Because shebangs are interpreted by the kernel, they must be on the first line\n-        let input = \"\\n#!/bin/bash\";\n-        assert_eq!(strip_shebang(input), None);\n-    }\n-\n-    #[test]\n-    fn test_shebang_space() {\n-        let input = \"#!    /bin/bash\";\n-        assert_eq!(strip_shebang(input), Some(input.len()));\n-    }\n-\n-    #[test]\n-    fn test_shebang_empty_shebang() {\n-        let input = \"#!    \\n[attribute(foo)]\";\n-        assert_eq!(strip_shebang(input), None);\n-    }\n-\n-    #[test]\n-    fn test_invalid_shebang_comment() {\n-        let input = \"#!//bin/ami/a/comment\\n[\";\n-        assert_eq!(strip_shebang(input), None)\n-    }\n-\n-    #[test]\n-    fn test_invalid_shebang_another_comment() {\n-        let input = \"#!/*bin/ami/a/comment*/\\n[attribute\";\n-        assert_eq!(strip_shebang(input), None)\n-    }\n-\n-    #[test]\n-    fn test_shebang_valid_rust_after() {\n-        let input = \"#!/*bin/ami/a/comment*/\\npub fn main() {}\";\n-        assert_eq!(strip_shebang(input), Some(23))\n-    }\n-\n-    #[test]\n-    fn test_shebang_followed_by_attrib() {\n-        let input = \"#!/bin/rust-scripts\\n#![allow_unused(true)]\";\n-        assert_eq!(strip_shebang(input), Some(19));\n-    }\n+use super::*;\n+\n+fn check_raw_str(s: &str, expected_hashes: u16, expected_err: Option<RawStrError>) {\n+    let s = &format!(\"r{}\", s);\n+    let mut cursor = Cursor::new(s);\n+    cursor.bump();\n+    let (n_hashes, err) = cursor.raw_double_quoted_string(0);\n+    assert_eq!(n_hashes, expected_hashes);\n+    assert_eq!(err, expected_err);\n+}\n+\n+#[test]\n+fn test_naked_raw_str() {\n+    check_raw_str(r#\"\"abc\"\"#, 0, None);\n+}\n+\n+#[test]\n+fn test_raw_no_start() {\n+    check_raw_str(r##\"\"abc\"#\"##, 0, None);\n+}\n+\n+#[test]\n+fn test_too_many_terminators() {\n+    // this error is handled in the parser later\n+    check_raw_str(r###\"#\"abc\"##\"###, 1, None);\n+}\n+\n+#[test]\n+fn test_unterminated() {\n+    check_raw_str(\n+        r#\"#\"abc\"#,\n+        1,\n+        Some(RawStrError::NoTerminator { expected: 1, found: 0, possible_terminator_offset: None }),\n+    );\n+    check_raw_str(\n+        r###\"##\"abc\"#\"###,\n+        2,\n+        Some(RawStrError::NoTerminator {\n+            expected: 2,\n+            found: 1,\n+            possible_terminator_offset: Some(7),\n+        }),\n+    );\n+    // We're looking for \"# not just any #\n+    check_raw_str(\n+        r###\"##\"abc#\"###,\n+        2,\n+        Some(RawStrError::NoTerminator { expected: 2, found: 0, possible_terminator_offset: None }),\n+    )\n+}\n+\n+#[test]\n+fn test_invalid_start() {\n+    check_raw_str(r##\"#~\"abc\"#\"##, 1, Some(RawStrError::InvalidStarter { bad_char: '~' }));\n+}\n+\n+#[test]\n+fn test_unterminated_no_pound() {\n+    // https://github.com/rust-lang/rust/issues/70677\n+    check_raw_str(\n+        r#\"\"\"#,\n+        0,\n+        Some(RawStrError::NoTerminator { expected: 0, found: 0, possible_terminator_offset: None }),\n+    );\n+}\n+\n+#[test]\n+fn test_valid_shebang() {\n+    // https://github.com/rust-lang/rust/issues/70528\n+    let input = \"#!/usr/bin/rustrun\\nlet x = 5;\";\n+    assert_eq!(strip_shebang(input), Some(18));\n+}\n+\n+#[test]\n+fn test_invalid_shebang_valid_rust_syntax() {\n+    // https://github.com/rust-lang/rust/issues/70528\n+    let input = \"#!    [bad_attribute]\";\n+    assert_eq!(strip_shebang(input), None);\n+}\n+\n+#[test]\n+fn test_shebang_second_line() {\n+    // Because shebangs are interpreted by the kernel, they must be on the first line\n+    let input = \"\\n#!/bin/bash\";\n+    assert_eq!(strip_shebang(input), None);\n+}\n+\n+#[test]\n+fn test_shebang_space() {\n+    let input = \"#!    /bin/bash\";\n+    assert_eq!(strip_shebang(input), Some(input.len()));\n+}\n+\n+#[test]\n+fn test_shebang_empty_shebang() {\n+    let input = \"#!    \\n[attribute(foo)]\";\n+    assert_eq!(strip_shebang(input), None);\n+}\n+\n+#[test]\n+fn test_invalid_shebang_comment() {\n+    let input = \"#!//bin/ami/a/comment\\n[\";\n+    assert_eq!(strip_shebang(input), None)\n+}\n+\n+#[test]\n+fn test_invalid_shebang_another_comment() {\n+    let input = \"#!/*bin/ami/a/comment*/\\n[attribute\";\n+    assert_eq!(strip_shebang(input), None)\n+}\n+\n+#[test]\n+fn test_shebang_valid_rust_after() {\n+    let input = \"#!/*bin/ami/a/comment*/\\npub fn main() {}\";\n+    assert_eq!(strip_shebang(input), Some(23))\n+}\n+\n+#[test]\n+fn test_shebang_followed_by_attrib() {\n+    let input = \"#!/bin/rust-scripts\\n#![allow_unused(true)]\";\n+    assert_eq!(strip_shebang(input), Some(19));\n }"}, {"sha": "fcfd648c2b7aaaa97a182e2639715c05ed513bba", "filename": "src/librustc_middle/mir/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -103,7 +103,7 @@ pub enum TerminatorKind<'tcx> {\n         unwind: Option<BasicBlock>,\n     },\n \n-    /// Block ends with a call of a converging function.\n+    /// Block ends with a call of a function.\n     Call {\n         /// The function that\u2019s being called.\n         func: Operand<'tcx>,"}, {"sha": "685243f54cb903b35069fac7c876255b0a404caf", "filename": "src/librustc_typeck/astconv/errors.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv%2Ferrors.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -0,0 +1,388 @@\n+use crate::astconv::AstConv;\n+use rustc_ast::util::lev_distance::find_best_match_for_name;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{pluralize, struct_span_err, Applicability};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty;\n+use rustc_session::parse::feature_err;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::collections::BTreeSet;\n+\n+impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n+    /// On missing type parameters, emit an E0393 error and provide a structured suggestion using\n+    /// the type parameter's name as a placeholder.\n+    pub(crate) fn complain_about_missing_type_params(\n+        &self,\n+        missing_type_params: Vec<String>,\n+        def_id: DefId,\n+        span: Span,\n+        empty_generic_args: bool,\n+    ) {\n+        if missing_type_params.is_empty() {\n+            return;\n+        }\n+        let display =\n+            missing_type_params.iter().map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            span,\n+            E0393,\n+            \"the type parameter{} {} must be explicitly specified\",\n+            pluralize!(missing_type_params.len()),\n+            display,\n+        );\n+        err.span_label(\n+            self.tcx().def_span(def_id),\n+            &format!(\n+                \"type parameter{} {} must be specified for this\",\n+                pluralize!(missing_type_params.len()),\n+                display,\n+            ),\n+        );\n+        let mut suggested = false;\n+        if let (Ok(snippet), true) = (\n+            self.tcx().sess.source_map().span_to_snippet(span),\n+            // Don't suggest setting the type params if there are some already: the order is\n+            // tricky to get right and the user will already know what the syntax is.\n+            empty_generic_args,\n+        ) {\n+            if snippet.ends_with('>') {\n+                // The user wrote `Trait<'a, T>` or similar. To provide an accurate suggestion\n+                // we would have to preserve the right order. For now, as clearly the user is\n+                // aware of the syntax, we do nothing.\n+            } else {\n+                // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n+                // least we can clue them to the correct syntax `Iterator<Type>`.\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\n+                        \"set the type parameter{plural} to the desired type{plural}\",\n+                        plural = pluralize!(missing_type_params.len()),\n+                    ),\n+                    format!(\"{}<{}>\", snippet, missing_type_params.join(\", \")),\n+                    Applicability::HasPlaceholders,\n+                );\n+                suggested = true;\n+            }\n+        }\n+        if !suggested {\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"missing reference{} to {}\",\n+                    pluralize!(missing_type_params.len()),\n+                    display,\n+                ),\n+            );\n+        }\n+        err.note(\n+            \"because of the default `Self` reference, type parameters must be \\\n+                  specified on object types\",\n+        );\n+        err.emit();\n+    }\n+\n+    /// When the code is using the `Fn` traits directly, instead of the `Fn(A) -> B` syntax, emit\n+    /// an error and attempt to build a reasonable structured suggestion.\n+    pub(crate) fn complain_about_internal_fn_trait(\n+        &self,\n+        span: Span,\n+        trait_def_id: DefId,\n+        trait_segment: &'a hir::PathSegment<'a>,\n+    ) {\n+        let trait_def = self.tcx().trait_def(trait_def_id);\n+\n+        if !self.tcx().features().unboxed_closures\n+            && trait_segment.generic_args().parenthesized != trait_def.paren_sugar\n+        {\n+            let sess = &self.tcx().sess.parse_sess;\n+            // For now, require that parenthetical notation be used only with `Fn()` etc.\n+            let (msg, sugg) = if trait_def.paren_sugar {\n+                (\n+                    \"the precise format of `Fn`-family traits' type parameters is subject to \\\n+                     change\",\n+                    Some(format!(\n+                        \"{}{} -> {}\",\n+                        trait_segment.ident,\n+                        trait_segment\n+                            .args\n+                            .as_ref()\n+                            .and_then(|args| args.args.get(0))\n+                            .and_then(|arg| match arg {\n+                                hir::GenericArg::Type(ty) => match ty.kind {\n+                                    hir::TyKind::Tup(t) => t\n+                                        .iter()\n+                                        .map(|e| sess.source_map().span_to_snippet(e.span))\n+                                        .collect::<Result<Vec<_>, _>>()\n+                                        .map(|a| a.join(\", \")),\n+                                    _ => sess.source_map().span_to_snippet(ty.span),\n+                                }\n+                                .map(|s| format!(\"({})\", s))\n+                                .ok(),\n+                                _ => None,\n+                            })\n+                            .unwrap_or_else(|| \"()\".to_string()),\n+                        trait_segment\n+                            .generic_args()\n+                            .bindings\n+                            .iter()\n+                            .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n+                                (true, hir::TypeBindingKind::Equality { ty }) => {\n+                                    sess.source_map().span_to_snippet(ty.span).ok()\n+                                }\n+                                _ => None,\n+                            })\n+                            .unwrap_or_else(|| \"()\".to_string()),\n+                    )),\n+                )\n+            } else {\n+                (\"parenthetical notation is only stable when used with `Fn`-family traits\", None)\n+            };\n+            let mut err = feature_err(sess, sym::unboxed_closures, span, msg);\n+            if let Some(sugg) = sugg {\n+                let msg = \"use parenthetical notation instead\";\n+                err.span_suggestion(span, msg, sugg, Applicability::MaybeIncorrect);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    pub(crate) fn complain_about_assoc_type_not_found<I>(\n+        &self,\n+        all_candidates: impl Fn() -> I,\n+        ty_param_name: &str,\n+        assoc_name: Ident,\n+        span: Span,\n+    ) where\n+        I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+    {\n+        // The fallback span is needed because `assoc_name` might be an `Fn()`'s `Output` without a\n+        // valid span, so we point at the whole path segment instead.\n+        let span = if assoc_name.span != DUMMY_SP { assoc_name.span } else { span };\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            span,\n+            E0220,\n+            \"associated type `{}` not found for `{}`\",\n+            assoc_name,\n+            ty_param_name\n+        );\n+\n+        let all_candidate_names: Vec<_> = all_candidates()\n+            .map(|r| self.tcx().associated_items(r.def_id()).in_definition_order())\n+            .flatten()\n+            .filter_map(\n+                |item| if item.kind == ty::AssocKind::Type { Some(item.ident.name) } else { None },\n+            )\n+            .collect();\n+\n+        if let (Some(suggested_name), true) = (\n+            find_best_match_for_name(all_candidate_names.iter(), assoc_name.name, None),\n+            assoc_name.span != DUMMY_SP,\n+        ) {\n+            err.span_suggestion(\n+                assoc_name.span,\n+                \"there is an associated type with a similar name\",\n+                suggested_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(span, format!(\"associated type `{}` not found\", assoc_name));\n+        }\n+\n+        err.emit();\n+    }\n+\n+    /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n+    /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n+    /// same trait bound have the same name (as they come from different super-traits), we instead\n+    /// emit a generic note suggesting using a `where` clause to constraint instead.\n+    pub(crate) fn complain_about_missing_associated_types(\n+        &self,\n+        associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n+        potential_assoc_types: Vec<Span>,\n+        trait_bounds: &[hir::PolyTraitRef<'_>],\n+    ) {\n+        if associated_types.values().all(|v| v.is_empty()) {\n+            return;\n+        }\n+        let tcx = self.tcx();\n+        // FIXME: Marked `mut` so that we can replace the spans further below with a more\n+        // appropriate one, but this should be handled earlier in the span assignment.\n+        let mut associated_types: FxHashMap<Span, Vec<_>> = associated_types\n+            .into_iter()\n+            .map(|(span, def_ids)| {\n+                (span, def_ids.into_iter().map(|did| tcx.associated_item(did)).collect())\n+            })\n+            .collect();\n+        let mut names = vec![];\n+\n+        // Account for things like `dyn Foo + 'a`, like in tests `issue-22434.rs` and\n+        // `issue-22560.rs`.\n+        let mut trait_bound_spans: Vec<Span> = vec![];\n+        for (span, items) in &associated_types {\n+            if !items.is_empty() {\n+                trait_bound_spans.push(*span);\n+            }\n+            for assoc_item in items {\n+                let trait_def_id = assoc_item.container.id();\n+                names.push(format!(\n+                    \"`{}` (from trait `{}`)\",\n+                    assoc_item.ident,\n+                    tcx.def_path_str(trait_def_id),\n+                ));\n+            }\n+        }\n+        if let ([], [bound]) = (&potential_assoc_types[..], &trait_bounds) {\n+            match &bound.trait_ref.path.segments[..] {\n+                // FIXME: `trait_ref.path.span` can point to a full path with multiple\n+                // segments, even though `trait_ref.path.segments` is of length `1`. Work\n+                // around that bug here, even though it should be fixed elsewhere.\n+                // This would otherwise cause an invalid suggestion. For an example, look at\n+                // `src/test/ui/issues/issue-28344.rs` where instead of the following:\n+                //\n+                //   error[E0191]: the value of the associated type `Output`\n+                //                 (from trait `std::ops::BitXor`) must be specified\n+                //   --> $DIR/issue-28344.rs:4:17\n+                //    |\n+                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n+                //    |                 ^^^^^^ help: specify the associated type:\n+                //    |                              `BitXor<Output = Type>`\n+                //\n+                // we would output:\n+                //\n+                //   error[E0191]: the value of the associated type `Output`\n+                //                 (from trait `std::ops::BitXor`) must be specified\n+                //   --> $DIR/issue-28344.rs:4:17\n+                //    |\n+                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n+                //    |                 ^^^^^^^^^^^^^ help: specify the associated type:\n+                //    |                                     `BitXor::bitor<Output = Type>`\n+                [segment] if segment.args.is_none() => {\n+                    trait_bound_spans = vec![segment.ident.span];\n+                    associated_types = associated_types\n+                        .into_iter()\n+                        .map(|(_, items)| (segment.ident.span, items))\n+                        .collect();\n+                }\n+                _ => {}\n+            }\n+        }\n+        names.sort();\n+        trait_bound_spans.sort();\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            trait_bound_spans,\n+            E0191,\n+            \"the value of the associated type{} {} must be specified\",\n+            pluralize!(names.len()),\n+            names.join(\", \"),\n+        );\n+        let mut suggestions = vec![];\n+        let mut types_count = 0;\n+        let mut where_constraints = vec![];\n+        for (span, assoc_items) in &associated_types {\n+            let mut names: FxHashMap<_, usize> = FxHashMap::default();\n+            for item in assoc_items {\n+                types_count += 1;\n+                *names.entry(item.ident.name).or_insert(0) += 1;\n+            }\n+            let mut dupes = false;\n+            for item in assoc_items {\n+                let prefix = if names[&item.ident.name] > 1 {\n+                    let trait_def_id = item.container.id();\n+                    dupes = true;\n+                    format!(\"{}::\", tcx.def_path_str(trait_def_id))\n+                } else {\n+                    String::new()\n+                };\n+                if let Some(sp) = tcx.hir().span_if_local(item.def_id) {\n+                    err.span_label(sp, format!(\"`{}{}` defined here\", prefix, item.ident));\n+                }\n+            }\n+            if potential_assoc_types.len() == assoc_items.len() {\n+                // Only suggest when the amount of missing associated types equals the number of\n+                // extra type arguments present, as that gives us a relatively high confidence\n+                // that the user forgot to give the associtated type's name. The canonical\n+                // example would be trying to use `Iterator<isize>` instead of\n+                // `Iterator<Item = isize>`.\n+                for (potential, item) in potential_assoc_types.iter().zip(assoc_items.iter()) {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*potential) {\n+                        suggestions.push((*potential, format!(\"{} = {}\", item.ident, snippet)));\n+                    }\n+                }\n+            } else if let (Ok(snippet), false) =\n+                (tcx.sess.source_map().span_to_snippet(*span), dupes)\n+            {\n+                let types: Vec<_> =\n+                    assoc_items.iter().map(|item| format!(\"{} = Type\", item.ident)).collect();\n+                let code = if snippet.ends_with('>') {\n+                    // The user wrote `Trait<'a>` or similar and we don't have a type we can\n+                    // suggest, but at least we can clue them to the correct syntax\n+                    // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the\n+                    // suggestion.\n+                    format!(\"{}, {}>\", &snippet[..snippet.len() - 1], types.join(\", \"))\n+                } else {\n+                    // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n+                    // least we can clue them to the correct syntax `Iterator<Item = Type>`.\n+                    format!(\"{}<{}>\", snippet, types.join(\", \"))\n+                };\n+                suggestions.push((*span, code));\n+            } else if dupes {\n+                where_constraints.push(*span);\n+            }\n+        }\n+        let where_msg = \"consider introducing a new type parameter, adding `where` constraints \\\n+                         using the fully-qualified path to the associated types\";\n+        if !where_constraints.is_empty() && suggestions.is_empty() {\n+            // If there are duplicates associated type names and a single trait bound do not\n+            // use structured suggestion, it means that there are multiple super-traits with\n+            // the same associated type name.\n+            err.help(where_msg);\n+        }\n+        if suggestions.len() != 1 {\n+            // We don't need this label if there's an inline suggestion, show otherwise.\n+            for (span, assoc_items) in &associated_types {\n+                let mut names: FxHashMap<_, usize> = FxHashMap::default();\n+                for item in assoc_items {\n+                    types_count += 1;\n+                    *names.entry(item.ident.name).or_insert(0) += 1;\n+                }\n+                let mut label = vec![];\n+                for item in assoc_items {\n+                    let postfix = if names[&item.ident.name] > 1 {\n+                        let trait_def_id = item.container.id();\n+                        format!(\" (from trait `{}`)\", tcx.def_path_str(trait_def_id))\n+                    } else {\n+                        String::new()\n+                    };\n+                    label.push(format!(\"`{}`{}\", item.ident, postfix));\n+                }\n+                if !label.is_empty() {\n+                    err.span_label(\n+                        *span,\n+                        format!(\n+                            \"associated type{} {} must be specified\",\n+                            pluralize!(label.len()),\n+                            label.join(\", \"),\n+                        ),\n+                    );\n+                }\n+            }\n+        }\n+        if !suggestions.is_empty() {\n+            err.multipart_suggestion(\n+                &format!(\"specify the associated type{}\", pluralize!(types_count)),\n+                suggestions,\n+                Applicability::HasPlaceholders,\n+            );\n+            if !where_constraints.is_empty() {\n+                err.span_help(where_constraints, where_msg);\n+            }\n+        }\n+        err.emit();\n+    }\n+}"}, {"sha": "84dab6de9581981094f2ce20de383e4a2a3fcf78", "filename": "src/librustc_typeck/astconv/generics.rs", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv%2Fgenerics.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -0,0 +1,596 @@\n+use crate::astconv::{\n+    AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, GenericArgPosition,\n+};\n+use rustc_ast::ast::ParamKindOrd;\n+use rustc_errors::{pluralize, struct_span_err, DiagnosticId, ErrorReported};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{GenericArg, GenericArgs};\n+use rustc_middle::ty::{\n+    self, subst, subst::SubstsRef, GenericParamDef, GenericParamDefKind, Ty, TyCtxt,\n+};\n+use rustc_session::{lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS, Session};\n+use rustc_span::{symbol::kw, MultiSpan, Span};\n+\n+use smallvec::SmallVec;\n+\n+impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n+    /// Report an error that a generic argument did not match the generic parameter that was\n+    /// expected.\n+    fn generic_arg_mismatch_err(\n+        sess: &Session,\n+        arg: &GenericArg<'_>,\n+        kind: &'static str,\n+        help: Option<&str>,\n+    ) {\n+        let mut err = struct_span_err!(\n+            sess,\n+            arg.span(),\n+            E0747,\n+            \"{} provided when a {} was expected\",\n+            arg.descr(),\n+            kind,\n+        );\n+\n+        let unordered = sess.features_untracked().const_generics;\n+        let kind_ord = match kind {\n+            \"lifetime\" => ParamKindOrd::Lifetime,\n+            \"type\" => ParamKindOrd::Type,\n+            \"constant\" => ParamKindOrd::Const { unordered },\n+            // It's more concise to match on the string representation, though it means\n+            // the match is non-exhaustive.\n+            _ => bug!(\"invalid generic parameter kind {}\", kind),\n+        };\n+        let arg_ord = match arg {\n+            GenericArg::Lifetime(_) => ParamKindOrd::Lifetime,\n+            GenericArg::Type(_) => ParamKindOrd::Type,\n+            GenericArg::Const(_) => ParamKindOrd::Const { unordered },\n+        };\n+\n+        // This note is only true when generic parameters are strictly ordered by their kind.\n+        if kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n+            let (first, last) =\n+                if kind_ord < arg_ord { (kind, arg.descr()) } else { (arg.descr(), kind) };\n+            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+            if let Some(help) = help {\n+                err.help(help);\n+            }\n+        }\n+\n+        err.emit();\n+    }\n+\n+    /// Creates the relevant generic argument substitutions\n+    /// corresponding to a set of generic parameters. This is a\n+    /// rather complex function. Let us try to explain the role\n+    /// of each of its parameters:\n+    ///\n+    /// To start, we are given the `def_id` of the thing we are\n+    /// creating the substitutions for, and a partial set of\n+    /// substitutions `parent_substs`. In general, the substitutions\n+    /// for an item begin with substitutions for all the \"parents\" of\n+    /// that item -- e.g., for a method it might include the\n+    /// parameters from the impl.\n+    ///\n+    /// Therefore, the method begins by walking down these parents,\n+    /// starting with the outermost parent and proceed inwards until\n+    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n+    /// first to see if the parent's substitutions are listed in there. If so,\n+    /// we can append those and move on. Otherwise, it invokes the\n+    /// three callback functions:\n+    ///\n+    /// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n+    ///   generic arguments that were given to that parent from within\n+    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n+    ///   might refer to the trait `Foo`, and the arguments might be\n+    ///   `[T]`. The boolean value indicates whether to infer values\n+    ///   for arguments whose values were not explicitly provided.\n+    /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n+    ///   instantiate a `GenericArg`.\n+    /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n+    ///   creates a suitable inference variable.\n+    pub fn create_substs_for_generic_args<'b>(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        parent_substs: &[subst::GenericArg<'tcx>],\n+        has_self: bool,\n+        self_ty: Option<Ty<'tcx>>,\n+        arg_count: GenericArgCountResult,\n+        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n+        mut provided_kind: impl FnMut(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n+        mut inferred_kind: impl FnMut(\n+            Option<&[subst::GenericArg<'tcx>]>,\n+            &GenericParamDef,\n+            bool,\n+        ) -> subst::GenericArg<'tcx>,\n+    ) -> SubstsRef<'tcx> {\n+        // Collect the segments of the path; we need to substitute arguments\n+        // for parameters throughout the entire path (wherever there are\n+        // generic parameters).\n+        let mut parent_defs = tcx.generics_of(def_id);\n+        let count = parent_defs.count();\n+        let mut stack = vec![(def_id, parent_defs)];\n+        while let Some(def_id) = parent_defs.parent {\n+            parent_defs = tcx.generics_of(def_id);\n+            stack.push((def_id, parent_defs));\n+        }\n+\n+        // We manually build up the substitution, rather than using convenience\n+        // methods in `subst.rs`, so that we can iterate over the arguments and\n+        // parameters in lock-step linearly, instead of trying to match each pair.\n+        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n+        // Iterate over each segment of the path.\n+        while let Some((def_id, defs)) = stack.pop() {\n+            let mut params = defs.params.iter().peekable();\n+\n+            // If we have already computed substitutions for parents, we can use those directly.\n+            while let Some(&param) = params.peek() {\n+                if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                    substs.push(kind);\n+                    params.next();\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            // `Self` is handled first, unless it's been handled in `parent_substs`.\n+            if has_self {\n+                if let Some(&param) = params.peek() {\n+                    if param.index == 0 {\n+                        if let GenericParamDefKind::Type { .. } = param.kind {\n+                            substs.push(\n+                                self_ty\n+                                    .map(|ty| ty.into())\n+                                    .unwrap_or_else(|| inferred_kind(None, param, true)),\n+                            );\n+                            params.next();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Check whether this segment takes generic arguments and the user has provided any.\n+            let (generic_args, infer_args) = args_for_def_id(def_id);\n+\n+            let mut args =\n+                generic_args.iter().flat_map(|generic_args| generic_args.args.iter()).peekable();\n+\n+            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n+            // If we later encounter a lifetime, we know that the arguments were provided in the\n+            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n+            // inferred, so we can use it for diagnostics later.\n+            let mut force_infer_lt = None;\n+\n+            loop {\n+                // We're going to iterate through the generic arguments that the user\n+                // provided, matching them with the generic parameters we expect.\n+                // Mismatches can occur as a result of elided lifetimes, or for malformed\n+                // input. We try to handle both sensibly.\n+                match (args.peek(), params.peek()) {\n+                    (Some(&arg), Some(&param)) => {\n+                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n+                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n+                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }, _)\n+                            | (GenericArg::Const(_), GenericParamDefKind::Const, _) => {\n+                                substs.push(provided_kind(param, arg));\n+                                args.next();\n+                                params.next();\n+                            }\n+                            (\n+                                GenericArg::Type(_) | GenericArg::Const(_),\n+                                GenericParamDefKind::Lifetime,\n+                                _,\n+                            ) => {\n+                                // We expected a lifetime argument, but got a type or const\n+                                // argument. That means we're inferring the lifetimes.\n+                                substs.push(inferred_kind(None, param, infer_args));\n+                                force_infer_lt = Some(arg);\n+                                params.next();\n+                            }\n+                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n+                                // We've come across a lifetime when we expected something else in\n+                                // the presence of explicit late bounds. This is most likely\n+                                // due to the presence of the explicit bound so we're just going to\n+                                // ignore it.\n+                                args.next();\n+                            }\n+                            (_, kind, _) => {\n+                                // We expected one kind of parameter, but the user provided\n+                                // another. This is an error. However, if we already know that\n+                                // the arguments don't match up with the parameters, we won't issue\n+                                // an additional error, as the user already knows what's wrong.\n+                                if arg_count.correct.is_ok()\n+                                    && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                                {\n+                                    // We're going to iterate over the parameters to sort them out, and\n+                                    // show that order to the user as a possible order for the parameters\n+                                    let mut param_types_present = defs\n+                                        .params\n+                                        .clone()\n+                                        .into_iter()\n+                                        .map(|param| {\n+                                            (\n+                                                match param.kind {\n+                                                    GenericParamDefKind::Lifetime => {\n+                                                        ParamKindOrd::Lifetime\n+                                                    }\n+                                                    GenericParamDefKind::Type { .. } => {\n+                                                        ParamKindOrd::Type\n+                                                    }\n+                                                    GenericParamDefKind::Const => {\n+                                                        ParamKindOrd::Const {\n+                                                            unordered: tcx\n+                                                                .sess\n+                                                                .features_untracked()\n+                                                                .const_generics,\n+                                                        }\n+                                                    }\n+                                                },\n+                                                param,\n+                                            )\n+                                        })\n+                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n+                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n+                                    let (mut param_types_present, ordered_params): (\n+                                        Vec<ParamKindOrd>,\n+                                        Vec<GenericParamDef>,\n+                                    ) = param_types_present.into_iter().unzip();\n+                                    param_types_present.dedup();\n+\n+                                    Self::generic_arg_mismatch_err(\n+                                        tcx.sess,\n+                                        arg,\n+                                        kind.descr(),\n+                                        Some(&format!(\n+                                            \"reorder the arguments: {}: `<{}>`\",\n+                                            param_types_present\n+                                                .into_iter()\n+                                                .map(|ord| format!(\"{}s\", ord.to_string()))\n+                                                .collect::<Vec<String>>()\n+                                                .join(\", then \"),\n+                                            ordered_params\n+                                                .into_iter()\n+                                                .filter_map(|param| {\n+                                                    if param.name == kw::SelfUpper {\n+                                                        None\n+                                                    } else {\n+                                                        Some(param.name.to_string())\n+                                                    }\n+                                                })\n+                                                .collect::<Vec<String>>()\n+                                                .join(\", \")\n+                                        )),\n+                                    );\n+                                }\n+\n+                                // We've reported the error, but we want to make sure that this\n+                                // problem doesn't bubble down and create additional, irrelevant\n+                                // errors. In this case, we're simply going to ignore the argument\n+                                // and any following arguments. The rest of the parameters will be\n+                                // inferred.\n+                                while args.next().is_some() {}\n+                            }\n+                        }\n+                    }\n+\n+                    (Some(&arg), None) => {\n+                        // We should never be able to reach this point with well-formed input.\n+                        // There are three situations in which we can encounter this issue.\n+                        //\n+                        //  1.  The number of arguments is incorrect. In this case, an error\n+                        //      will already have been emitted, and we can ignore it.\n+                        //  2.  There are late-bound lifetime parameters present, yet the\n+                        //      lifetime arguments have also been explicitly specified by the\n+                        //      user.\n+                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n+                        //      after a type or const). We want to throw an error in this case.\n+\n+                        if arg_count.correct.is_ok()\n+                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                        {\n+                            let kind = arg.descr();\n+                            assert_eq!(kind, \"lifetime\");\n+                            let provided =\n+                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n+                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind, None);\n+                        }\n+\n+                        break;\n+                    }\n+\n+                    (None, Some(&param)) => {\n+                        // If there are fewer arguments than parameters, it means\n+                        // we're inferring the remaining arguments.\n+                        substs.push(inferred_kind(Some(&substs), param, infer_args));\n+                        params.next();\n+                    }\n+\n+                    (None, None) => break,\n+                }\n+            }\n+        }\n+\n+        tcx.intern_substs(&substs)\n+    }\n+\n+    /// Checks that the correct number of generic arguments have been provided.\n+    /// Used specifically for function calls.\n+    pub fn check_generic_arg_count_for_call(\n+        tcx: TyCtxt<'_>,\n+        span: Span,\n+        def: &ty::Generics,\n+        seg: &hir::PathSegment<'_>,\n+        is_method_call: bool,\n+    ) -> GenericArgCountResult {\n+        let empty_args = hir::GenericArgs::none();\n+        let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n+        Self::check_generic_arg_count(\n+            tcx,\n+            span,\n+            def,\n+            if let Some(ref args) = seg.args { args } else { &empty_args },\n+            if is_method_call { GenericArgPosition::MethodCall } else { GenericArgPosition::Value },\n+            def.parent.is_none() && def.has_self, // `has_self`\n+            seg.infer_args || suppress_mismatch,  // `infer_args`\n+        )\n+    }\n+\n+    /// Checks that the correct number of generic arguments have been provided.\n+    /// This is used both for datatypes and function calls.\n+    pub(crate) fn check_generic_arg_count(\n+        tcx: TyCtxt<'_>,\n+        span: Span,\n+        def: &ty::Generics,\n+        args: &hir::GenericArgs<'_>,\n+        position: GenericArgPosition,\n+        has_self: bool,\n+        infer_args: bool,\n+    ) -> GenericArgCountResult {\n+        // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n+        // that lifetimes will proceed types. So it suffices to check the number of each generic\n+        // arguments in order to validate them with respect to the generic parameters.\n+        let param_counts = def.own_counts();\n+        let arg_counts = args.own_counts();\n+        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+\n+        let mut defaults: ty::GenericParamCount = Default::default();\n+        for param in &def.params {\n+            match param.kind {\n+                GenericParamDefKind::Lifetime => {}\n+                GenericParamDefKind::Type { has_default, .. } => {\n+                    defaults.types += has_default as usize\n+                }\n+                GenericParamDefKind::Const => {\n+                    // FIXME(const_generics:defaults)\n+                }\n+            };\n+        }\n+\n+        if position != GenericArgPosition::Type && !args.bindings.is_empty() {\n+            Self::prohibit_assoc_ty_binding(tcx, args.bindings[0].span);\n+        }\n+\n+        let explicit_late_bound =\n+            Self::prohibit_explicit_late_bound_lifetimes(tcx, def, args, position);\n+\n+        let check_kind_count = |kind,\n+                                required,\n+                                permitted,\n+                                provided,\n+                                offset,\n+                                unexpected_spans: &mut Vec<Span>,\n+                                silent| {\n+            debug!(\n+                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n+                kind, required, permitted, provided, offset\n+            );\n+            // We enforce the following: `required` <= `provided` <= `permitted`.\n+            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n+            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n+            if required <= provided && provided <= permitted {\n+                return Ok(());\n+            }\n+\n+            if silent {\n+                return Err(true);\n+            }\n+\n+            // Unfortunately lifetime and type parameter mismatches are typically styled\n+            // differently in diagnostics, which means we have a few cases to consider here.\n+            let (bound, quantifier) = if required != permitted {\n+                if provided < required {\n+                    (required, \"at least \")\n+                } else {\n+                    // provided > permitted\n+                    (permitted, \"at most \")\n+                }\n+            } else {\n+                (required, \"\")\n+            };\n+\n+            let (spans, label) = if required == permitted && provided > permitted {\n+                // In the case when the user has provided too many arguments,\n+                // we want to point to the unexpected arguments.\n+                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n+                    .iter()\n+                    .map(|arg| arg.span())\n+                    .collect();\n+                unexpected_spans.extend(spans.clone());\n+                (spans, format!(\"unexpected {} argument\", kind))\n+            } else {\n+                (\n+                    vec![span],\n+                    format!(\n+                        \"expected {}{} {} argument{}\",\n+                        quantifier,\n+                        bound,\n+                        kind,\n+                        pluralize!(bound),\n+                    ),\n+                )\n+            };\n+\n+            let mut err = tcx.sess.struct_span_err_with_code(\n+                spans.clone(),\n+                &format!(\n+                    \"wrong number of {} arguments: expected {}{}, found {}\",\n+                    kind, quantifier, bound, provided,\n+                ),\n+                DiagnosticId::Error(\"E0107\".into()),\n+            );\n+            for span in spans {\n+                err.span_label(span, label.as_str());\n+            }\n+            err.emit();\n+\n+            Err(true)\n+        };\n+\n+        let mut arg_count_correct = Ok(());\n+        let mut unexpected_spans = vec![];\n+\n+        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n+            arg_count_correct = check_kind_count(\n+                \"lifetime\",\n+                param_counts.lifetimes,\n+                param_counts.lifetimes,\n+                arg_counts.lifetimes,\n+                0,\n+                &mut unexpected_spans,\n+                explicit_late_bound == ExplicitLateBound::Yes,\n+            )\n+            .and(arg_count_correct);\n+        }\n+        // FIXME(const_generics:defaults)\n+        if !infer_args || arg_counts.consts > param_counts.consts {\n+            arg_count_correct = check_kind_count(\n+                \"const\",\n+                param_counts.consts,\n+                param_counts.consts,\n+                arg_counts.consts,\n+                arg_counts.lifetimes + arg_counts.types,\n+                &mut unexpected_spans,\n+                false,\n+            )\n+            .and(arg_count_correct);\n+        }\n+        // Note that type errors are currently be emitted *after* const errors.\n+        if !infer_args || arg_counts.types > param_counts.types - defaults.types - has_self as usize\n+        {\n+            arg_count_correct = check_kind_count(\n+                \"type\",\n+                param_counts.types - defaults.types - has_self as usize,\n+                param_counts.types - has_self as usize,\n+                arg_counts.types,\n+                arg_counts.lifetimes,\n+                &mut unexpected_spans,\n+                false,\n+            )\n+            .and(arg_count_correct);\n+        }\n+\n+        GenericArgCountResult {\n+            explicit_late_bound,\n+            correct: arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n+                reported: if reported_err { Some(ErrorReported) } else { None },\n+                invalid_args: unexpected_spans,\n+            }),\n+        }\n+    }\n+\n+    /// Report error if there is an explicit type parameter when using `impl Trait`.\n+    pub(crate) fn check_impl_trait(\n+        tcx: TyCtxt<'_>,\n+        seg: &hir::PathSegment<'_>,\n+        generics: &ty::Generics,\n+    ) -> bool {\n+        let explicit = !seg.infer_args;\n+        let impl_trait = generics.params.iter().any(|param| match param.kind {\n+            ty::GenericParamDefKind::Type {\n+                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                ..\n+            } => true,\n+            _ => false,\n+        });\n+\n+        if explicit && impl_trait {\n+            let spans = seg\n+                .generic_args()\n+                .args\n+                .iter()\n+                .filter_map(|arg| match arg {\n+                    GenericArg::Type(_) => Some(arg.span()),\n+                    _ => None,\n+                })\n+                .collect::<Vec<_>>();\n+\n+            let mut err = struct_span_err! {\n+                tcx.sess,\n+                spans.clone(),\n+                E0632,\n+                \"cannot provide explicit generic arguments when `impl Trait` is \\\n+                used in argument position\"\n+            };\n+\n+            for span in spans {\n+                err.span_label(span, \"explicit generic argument not allowed\");\n+            }\n+\n+            err.emit();\n+        }\n+\n+        impl_trait\n+    }\n+\n+    /// Emits an error regarding forbidden type binding associations\n+    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0229,\n+            \"associated type bindings are not allowed here\"\n+        );\n+        err.span_label(span, \"associated type not allowed here\").emit();\n+    }\n+\n+    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n+    /// are present. This is used both for datatypes and function calls.\n+    pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n+        tcx: TyCtxt<'_>,\n+        def: &ty::Generics,\n+        args: &hir::GenericArgs<'_>,\n+        position: GenericArgPosition,\n+    ) -> ExplicitLateBound {\n+        let param_counts = def.own_counts();\n+        let arg_counts = args.own_counts();\n+        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n+\n+        if infer_lifetimes {\n+            ExplicitLateBound::No\n+        } else if let Some(span_late) = def.has_late_bound_regions {\n+            let msg = \"cannot specify lifetime arguments explicitly \\\n+                       if late bound lifetime parameters are present\";\n+            let note = \"the late bound lifetime parameter is introduced here\";\n+            let span = args.args[0].span();\n+            if position == GenericArgPosition::Value\n+                && arg_counts.lifetimes != param_counts.lifetimes\n+            {\n+                let mut err = tcx.sess.struct_span_err(span, msg);\n+                err.span_note(span_late, note);\n+                err.emit();\n+            } else {\n+                let mut multispan = MultiSpan::from_span(span);\n+                multispan.push_span_label(span_late, note.to_string());\n+                tcx.struct_span_lint_hir(\n+                    LATE_BOUND_LIFETIME_ARGUMENTS,\n+                    args.args[0].id(),\n+                    multispan,\n+                    |lint| lint.build(msg).emit(),\n+                );\n+            }\n+            ExplicitLateBound::Yes\n+        } else {\n+            ExplicitLateBound::No\n+        }\n+    }\n+}"}, {"sha": "15c19afdb4a207e2a8765d653a930aa3120fd81a", "filename": "src/librustc_typeck/astconv/mod.rs", "status": "renamed", "additions": 14, "deletions": 1057, "changes": 1071, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv%2Fmod.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,33 +1,29 @@\n-// ignore-tidy-filelength FIXME(#67418) Split up this file.\n //! Conversion from AST representation of types to the `ty.rs` representation.\n //! The main routine here is `ast_ty_to_ty()`; each use is parameterized by an\n //! instance of `AstConv`.\n \n-// ignore-tidy-filelength\n+mod errors;\n+mod generics;\n \n+use crate::bounds::Bounds;\n use crate::collect::PlaceholderHirTyCollector;\n use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n-use rustc_ast::{util::lev_distance::find_best_match_for_name, ParamKindOrd};\n+use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::ErrorReported;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, FatalError};\n+use rustc_errors::{struct_span_err, Applicability, ErrorReported, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::lang_items::SizedTraitLangItem;\n use rustc_hir::{Constness, GenericArg, GenericArgs};\n use rustc_middle::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{\n-    self, Const, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n-};\n-use rustc_middle::ty::{GenericParamDef, GenericParamDefKind};\n-use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, LATE_BOUND_LIFETIME_ARGUMENTS};\n-use rustc_session::parse::feature_err;\n-use rustc_session::Session;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_middle::ty::GenericParamDefKind;\n+use rustc_middle::ty::{self, Const, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_session::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -138,8 +134,10 @@ pub enum ExplicitLateBound {\n     No,\n }\n \n+/// Denotes the \"position\" of a generic argument, indicating if it is a generic type,\n+/// generic function or generic method call.\n #[derive(Copy, Clone, PartialEq)]\n-enum GenericArgPosition {\n+pub(crate) enum GenericArgPosition {\n     Type,\n     Value, // e.g., functions\n     MethodCall,\n@@ -243,533 +241,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         substs\n     }\n \n-    /// Report error if there is an explicit type parameter when using `impl Trait`.\n-    fn check_impl_trait(\n-        tcx: TyCtxt<'_>,\n-        seg: &hir::PathSegment<'_>,\n-        generics: &ty::Generics,\n-    ) -> bool {\n-        let explicit = !seg.infer_args;\n-        let impl_trait = generics.params.iter().any(|param| match param.kind {\n-            ty::GenericParamDefKind::Type {\n-                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                ..\n-            } => true,\n-            _ => false,\n-        });\n-\n-        if explicit && impl_trait {\n-            let spans = seg\n-                .generic_args()\n-                .args\n-                .iter()\n-                .filter_map(|arg| match arg {\n-                    GenericArg::Type(_) => Some(arg.span()),\n-                    _ => None,\n-                })\n-                .collect::<Vec<_>>();\n-\n-            let mut err = struct_span_err! {\n-                tcx.sess,\n-                spans.clone(),\n-                E0632,\n-                \"cannot provide explicit generic arguments when `impl Trait` is \\\n-                used in argument position\"\n-            };\n-\n-            for span in spans {\n-                err.span_label(span, \"explicit generic argument not allowed\");\n-            }\n-\n-            err.emit();\n-        }\n-\n-        impl_trait\n-    }\n-\n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// Used specifically for function calls.\n-    pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def: &ty::Generics,\n-        seg: &hir::PathSegment<'_>,\n-        is_method_call: bool,\n-    ) -> GenericArgCountResult {\n-        let empty_args = hir::GenericArgs::none();\n-        let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n-        Self::check_generic_arg_count(\n-            tcx,\n-            span,\n-            def,\n-            if let Some(ref args) = seg.args { args } else { &empty_args },\n-            if is_method_call { GenericArgPosition::MethodCall } else { GenericArgPosition::Value },\n-            def.parent.is_none() && def.has_self, // `has_self`\n-            seg.infer_args || suppress_mismatch,  // `infer_args`\n-        )\n-    }\n-\n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// This is used both for datatypes and function calls.\n-    fn check_generic_arg_count(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def: &ty::Generics,\n-        args: &hir::GenericArgs<'_>,\n-        position: GenericArgPosition,\n-        has_self: bool,\n-        infer_args: bool,\n-    ) -> GenericArgCountResult {\n-        // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n-        // that lifetimes will proceed types. So it suffices to check the number of each generic\n-        // arguments in order to validate them with respect to the generic parameters.\n-        let param_counts = def.own_counts();\n-        let arg_counts = args.own_counts();\n-        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n-\n-        let mut defaults: ty::GenericParamCount = Default::default();\n-        for param in &def.params {\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => {}\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    defaults.types += has_default as usize\n-                }\n-                GenericParamDefKind::Const => {\n-                    // FIXME(const_generics:defaults)\n-                }\n-            };\n-        }\n-\n-        if position != GenericArgPosition::Type && !args.bindings.is_empty() {\n-            AstConv::prohibit_assoc_ty_binding(tcx, args.bindings[0].span);\n-        }\n-\n-        let explicit_late_bound =\n-            Self::prohibit_explicit_late_bound_lifetimes(tcx, def, args, position);\n-\n-        let check_kind_count = |kind,\n-                                required,\n-                                permitted,\n-                                provided,\n-                                offset,\n-                                unexpected_spans: &mut Vec<Span>,\n-                                silent| {\n-            debug!(\n-                \"check_kind_count: kind: {} required: {} permitted: {} provided: {} offset: {}\",\n-                kind, required, permitted, provided, offset\n-            );\n-            // We enforce the following: `required` <= `provided` <= `permitted`.\n-            // For kinds without defaults (e.g.., lifetimes), `required == permitted`.\n-            // For other kinds (i.e., types), `permitted` may be greater than `required`.\n-            if required <= provided && provided <= permitted {\n-                return Ok(());\n-            }\n-\n-            if silent {\n-                return Err(true);\n-            }\n-\n-            // Unfortunately lifetime and type parameter mismatches are typically styled\n-            // differently in diagnostics, which means we have a few cases to consider here.\n-            let (bound, quantifier) = if required != permitted {\n-                if provided < required {\n-                    (required, \"at least \")\n-                } else {\n-                    // provided > permitted\n-                    (permitted, \"at most \")\n-                }\n-            } else {\n-                (required, \"\")\n-            };\n-\n-            let (spans, label) = if required == permitted && provided > permitted {\n-                // In the case when the user has provided too many arguments,\n-                // we want to point to the unexpected arguments.\n-                let spans: Vec<Span> = args.args[offset + permitted..offset + provided]\n-                    .iter()\n-                    .map(|arg| arg.span())\n-                    .collect();\n-                unexpected_spans.extend(spans.clone());\n-                (spans, format!(\"unexpected {} argument\", kind))\n-            } else {\n-                (\n-                    vec![span],\n-                    format!(\n-                        \"expected {}{} {} argument{}\",\n-                        quantifier,\n-                        bound,\n-                        kind,\n-                        pluralize!(bound),\n-                    ),\n-                )\n-            };\n-\n-            let mut err = tcx.sess.struct_span_err_with_code(\n-                spans.clone(),\n-                &format!(\n-                    \"wrong number of {} arguments: expected {}{}, found {}\",\n-                    kind, quantifier, bound, provided,\n-                ),\n-                DiagnosticId::Error(\"E0107\".into()),\n-            );\n-            for span in spans {\n-                err.span_label(span, label.as_str());\n-            }\n-            err.emit();\n-\n-            Err(true)\n-        };\n-\n-        let mut arg_count_correct = Ok(());\n-        let mut unexpected_spans = vec![];\n-\n-        if !infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes {\n-            arg_count_correct = check_kind_count(\n-                \"lifetime\",\n-                param_counts.lifetimes,\n-                param_counts.lifetimes,\n-                arg_counts.lifetimes,\n-                0,\n-                &mut unexpected_spans,\n-                explicit_late_bound == ExplicitLateBound::Yes,\n-            )\n-            .and(arg_count_correct);\n-        }\n-        // FIXME(const_generics:defaults)\n-        if !infer_args || arg_counts.consts > param_counts.consts {\n-            arg_count_correct = check_kind_count(\n-                \"const\",\n-                param_counts.consts,\n-                param_counts.consts,\n-                arg_counts.consts,\n-                arg_counts.lifetimes + arg_counts.types,\n-                &mut unexpected_spans,\n-                false,\n-            )\n-            .and(arg_count_correct);\n-        }\n-        // Note that type errors are currently be emitted *after* const errors.\n-        if !infer_args || arg_counts.types > param_counts.types - defaults.types - has_self as usize\n-        {\n-            arg_count_correct = check_kind_count(\n-                \"type\",\n-                param_counts.types - defaults.types - has_self as usize,\n-                param_counts.types - has_self as usize,\n-                arg_counts.types,\n-                arg_counts.lifetimes,\n-                &mut unexpected_spans,\n-                false,\n-            )\n-            .and(arg_count_correct);\n-        }\n-\n-        GenericArgCountResult {\n-            explicit_late_bound,\n-            correct: arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n-                reported: if reported_err { Some(ErrorReported) } else { None },\n-                invalid_args: unexpected_spans,\n-            }),\n-        }\n-    }\n-\n-    /// Report an error that a generic argument did not match the generic parameter that was\n-    /// expected.\n-    fn generic_arg_mismatch_err(\n-        sess: &Session,\n-        arg: &GenericArg<'_>,\n-        kind: &'static str,\n-        help: Option<&str>,\n-    ) {\n-        let mut err = struct_span_err!(\n-            sess,\n-            arg.span(),\n-            E0747,\n-            \"{} provided when a {} was expected\",\n-            arg.descr(),\n-            kind,\n-        );\n-\n-        let unordered = sess.features_untracked().const_generics;\n-        let kind_ord = match kind {\n-            \"lifetime\" => ParamKindOrd::Lifetime,\n-            \"type\" => ParamKindOrd::Type,\n-            \"constant\" => ParamKindOrd::Const { unordered },\n-            // It's more concise to match on the string representation, though it means\n-            // the match is non-exhaustive.\n-            _ => bug!(\"invalid generic parameter kind {}\", kind),\n-        };\n-        let arg_ord = match arg {\n-            GenericArg::Lifetime(_) => ParamKindOrd::Lifetime,\n-            GenericArg::Type(_) => ParamKindOrd::Type,\n-            GenericArg::Const(_) => ParamKindOrd::Const { unordered },\n-        };\n-\n-        // This note is only true when generic parameters are strictly ordered by their kind.\n-        if kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n-            let (first, last) =\n-                if kind_ord < arg_ord { (kind, arg.descr()) } else { (arg.descr(), kind) };\n-            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n-            if let Some(help) = help {\n-                err.help(help);\n-            }\n-        }\n-\n-        err.emit();\n-    }\n-\n-    /// Creates the relevant generic argument substitutions\n-    /// corresponding to a set of generic parameters. This is a\n-    /// rather complex function. Let us try to explain the role\n-    /// of each of its parameters:\n-    ///\n-    /// To start, we are given the `def_id` of the thing we are\n-    /// creating the substitutions for, and a partial set of\n-    /// substitutions `parent_substs`. In general, the substitutions\n-    /// for an item begin with substitutions for all the \"parents\" of\n-    /// that item -- e.g., for a method it might include the\n-    /// parameters from the impl.\n-    ///\n-    /// Therefore, the method begins by walking down these parents,\n-    /// starting with the outermost parent and proceed inwards until\n-    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n-    /// first to see if the parent's substitutions are listed in there. If so,\n-    /// we can append those and move on. Otherwise, it invokes the\n-    /// three callback functions:\n-    ///\n-    /// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n-    ///   generic arguments that were given to that parent from within\n-    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n-    ///   might refer to the trait `Foo`, and the arguments might be\n-    ///   `[T]`. The boolean value indicates whether to infer values\n-    ///   for arguments whose values were not explicitly provided.\n-    /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n-    ///   instantiate a `GenericArg`.\n-    /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n-    ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'b>(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        parent_substs: &[subst::GenericArg<'tcx>],\n-        has_self: bool,\n-        self_ty: Option<Ty<'tcx>>,\n-        arg_count: GenericArgCountResult,\n-        args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n-        mut provided_kind: impl FnMut(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n-        mut inferred_kind: impl FnMut(\n-            Option<&[subst::GenericArg<'tcx>]>,\n-            &GenericParamDef,\n-            bool,\n-        ) -> subst::GenericArg<'tcx>,\n-    ) -> SubstsRef<'tcx> {\n-        // Collect the segments of the path; we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n-        let mut parent_defs = tcx.generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = tcx.generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n-        }\n-\n-        // We manually build up the substitution, rather than using convenience\n-        // methods in `subst.rs`, so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, instead of trying to match each pair.\n-        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n-        // Iterate over each segment of the path.\n-        while let Some((def_id, defs)) = stack.pop() {\n-            let mut params = defs.params.iter().peekable();\n-\n-            // If we have already computed substitutions for parents, we can use those directly.\n-            while let Some(&param) = params.peek() {\n-                if let Some(&kind) = parent_substs.get(param.index as usize) {\n-                    substs.push(kind);\n-                    params.next();\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            // `Self` is handled first, unless it's been handled in `parent_substs`.\n-            if has_self {\n-                if let Some(&param) = params.peek() {\n-                    if param.index == 0 {\n-                        if let GenericParamDefKind::Type { .. } = param.kind {\n-                            substs.push(\n-                                self_ty\n-                                    .map(|ty| ty.into())\n-                                    .unwrap_or_else(|| inferred_kind(None, param, true)),\n-                            );\n-                            params.next();\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_args) = args_for_def_id(def_id);\n-\n-            let mut args =\n-                generic_args.iter().flat_map(|generic_args| generic_args.args.iter()).peekable();\n-\n-            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n-            // If we later encounter a lifetime, we know that the arguments were provided in the\n-            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n-            // inferred, so we can use it for diagnostics later.\n-            let mut force_infer_lt = None;\n-\n-            loop {\n-                // We're going to iterate through the generic arguments that the user\n-                // provided, matching them with the generic parameters we expect.\n-                // Mismatches can occur as a result of elided lifetimes, or for malformed\n-                // input. We try to handle both sensibly.\n-                match (args.peek(), params.peek()) {\n-                    (Some(&arg), Some(&param)) => {\n-                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n-                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n-                            | (GenericArg::Type(_), GenericParamDefKind::Type { .. }, _)\n-                            | (GenericArg::Const(_), GenericParamDefKind::Const, _) => {\n-                                substs.push(provided_kind(param, arg));\n-                                args.next();\n-                                params.next();\n-                            }\n-                            (\n-                                GenericArg::Type(_) | GenericArg::Const(_),\n-                                GenericParamDefKind::Lifetime,\n-                                _,\n-                            ) => {\n-                                // We expected a lifetime argument, but got a type or const\n-                                // argument. That means we're inferring the lifetimes.\n-                                substs.push(inferred_kind(None, param, infer_args));\n-                                force_infer_lt = Some(arg);\n-                                params.next();\n-                            }\n-                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n-                                // We've come across a lifetime when we expected something else in\n-                                // the presence of explicit late bounds. This is most likely\n-                                // due to the presence of the explicit bound so we're just going to\n-                                // ignore it.\n-                                args.next();\n-                            }\n-                            (_, kind, _) => {\n-                                // We expected one kind of parameter, but the user provided\n-                                // another. This is an error. However, if we already know that\n-                                // the arguments don't match up with the parameters, we won't issue\n-                                // an additional error, as the user already knows what's wrong.\n-                                if arg_count.correct.is_ok()\n-                                    && arg_count.explicit_late_bound == ExplicitLateBound::No\n-                                {\n-                                    // We're going to iterate over the parameters to sort them out, and\n-                                    // show that order to the user as a possible order for the parameters\n-                                    let mut param_types_present = defs\n-                                        .params\n-                                        .clone()\n-                                        .into_iter()\n-                                        .map(|param| {\n-                                            (\n-                                                match param.kind {\n-                                                    GenericParamDefKind::Lifetime => {\n-                                                        ParamKindOrd::Lifetime\n-                                                    }\n-                                                    GenericParamDefKind::Type { .. } => {\n-                                                        ParamKindOrd::Type\n-                                                    }\n-                                                    GenericParamDefKind::Const => {\n-                                                        ParamKindOrd::Const {\n-                                                            unordered: tcx\n-                                                                .sess\n-                                                                .features_untracked()\n-                                                                .const_generics,\n-                                                        }\n-                                                    }\n-                                                },\n-                                                param,\n-                                            )\n-                                        })\n-                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n-                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n-                                    let (mut param_types_present, ordered_params): (\n-                                        Vec<ParamKindOrd>,\n-                                        Vec<GenericParamDef>,\n-                                    ) = param_types_present.into_iter().unzip();\n-                                    param_types_present.dedup();\n-\n-                                    Self::generic_arg_mismatch_err(\n-                                        tcx.sess,\n-                                        arg,\n-                                        kind.descr(),\n-                                        Some(&format!(\n-                                            \"reorder the arguments: {}: `<{}>`\",\n-                                            param_types_present\n-                                                .into_iter()\n-                                                .map(|ord| format!(\"{}s\", ord.to_string()))\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", then \"),\n-                                            ordered_params\n-                                                .into_iter()\n-                                                .filter_map(|param| {\n-                                                    if param.name == kw::SelfUpper {\n-                                                        None\n-                                                    } else {\n-                                                        Some(param.name.to_string())\n-                                                    }\n-                                                })\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", \")\n-                                        )),\n-                                    );\n-                                }\n-\n-                                // We've reported the error, but we want to make sure that this\n-                                // problem doesn't bubble down and create additional, irrelevant\n-                                // errors. In this case, we're simply going to ignore the argument\n-                                // and any following arguments. The rest of the parameters will be\n-                                // inferred.\n-                                while args.next().is_some() {}\n-                            }\n-                        }\n-                    }\n-\n-                    (Some(&arg), None) => {\n-                        // We should never be able to reach this point with well-formed input.\n-                        // There are three situations in which we can encounter this issue.\n-                        //\n-                        //  1.  The number of arguments is incorrect. In this case, an error\n-                        //      will already have been emitted, and we can ignore it.\n-                        //  2.  There are late-bound lifetime parameters present, yet the\n-                        //      lifetime arguments have also been explicitly specified by the\n-                        //      user.\n-                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n-                        //      after a type or const). We want to throw an error in this case.\n-\n-                        if arg_count.correct.is_ok()\n-                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n-                        {\n-                            let kind = arg.descr();\n-                            assert_eq!(kind, \"lifetime\");\n-                            let provided =\n-                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n-                            Self::generic_arg_mismatch_err(tcx.sess, provided, kind, None);\n-                        }\n-\n-                        break;\n-                    }\n-\n-                    (None, Some(&param)) => {\n-                        // If there are fewer arguments than parameters, it means\n-                        // we're inferring the remaining arguments.\n-                        substs.push(inferred_kind(Some(&substs), param, infer_args));\n-                        params.next();\n-                    }\n-\n-                    (None, None) => break,\n-                }\n-            }\n-        }\n-\n-        tcx.intern_substs(&substs)\n-    }\n-\n     /// Given the type/lifetime/const arguments provided to some path (along with\n     /// an implicit `Self`, if this is a trait reference), returns the complete\n     /// set of substitutions. This may involve applying defaulted type parameters.\n@@ -1023,79 +494,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n-    /// On missing type parameters, emit an E0393 error and provide a structured suggestion using\n-    /// the type parameter's name as a placeholder.\n-    fn complain_about_missing_type_params(\n-        &self,\n-        missing_type_params: Vec<String>,\n-        def_id: DefId,\n-        span: Span,\n-        empty_generic_args: bool,\n-    ) {\n-        if missing_type_params.is_empty() {\n-            return;\n-        }\n-        let display =\n-            missing_type_params.iter().map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n-        let mut err = struct_span_err!(\n-            self.tcx().sess,\n-            span,\n-            E0393,\n-            \"the type parameter{} {} must be explicitly specified\",\n-            pluralize!(missing_type_params.len()),\n-            display,\n-        );\n-        err.span_label(\n-            self.tcx().def_span(def_id),\n-            &format!(\n-                \"type parameter{} {} must be specified for this\",\n-                pluralize!(missing_type_params.len()),\n-                display,\n-            ),\n-        );\n-        let mut suggested = false;\n-        if let (Ok(snippet), true) = (\n-            self.tcx().sess.source_map().span_to_snippet(span),\n-            // Don't suggest setting the type params if there are some already: the order is\n-            // tricky to get right and the user will already know what the syntax is.\n-            empty_generic_args,\n-        ) {\n-            if snippet.ends_with('>') {\n-                // The user wrote `Trait<'a, T>` or similar. To provide an accurate suggestion\n-                // we would have to preserve the right order. For now, as clearly the user is\n-                // aware of the syntax, we do nothing.\n-            } else {\n-                // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n-                // least we can clue them to the correct syntax `Iterator<Type>`.\n-                err.span_suggestion(\n-                    span,\n-                    &format!(\n-                        \"set the type parameter{plural} to the desired type{plural}\",\n-                        plural = pluralize!(missing_type_params.len()),\n-                    ),\n-                    format!(\"{}<{}>\", snippet, missing_type_params.join(\", \")),\n-                    Applicability::HasPlaceholders,\n-                );\n-                suggested = true;\n-            }\n-        }\n-        if !suggested {\n-            err.span_label(\n-                span,\n-                format!(\n-                    \"missing reference{} to {}\",\n-                    pluralize!(missing_type_params.len()),\n-                    display,\n-                ),\n-            );\n-        }\n-        err.note(\n-            \"because of the default `Self` reference, type parameters must be \\\n-                  specified on object types\",\n-        );\n-        err.emit();\n-    }\n-\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the `DefId` of the defining trait.\n     /// The type _cannot_ be a type other than a trait type.\n@@ -1242,76 +640,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (substs, assoc_bindings, _) =\n             self.create_substs_for_ast_trait_ref(span, trait_def_id, self_ty, trait_segment);\n         if let Some(b) = assoc_bindings.first() {\n-            AstConv::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n-    /// When the code is using the `Fn` traits directly, instead of the `Fn(A) -> B` syntax, emit\n-    /// an error and attempt to build a reasonable structured suggestion.\n-    fn complain_about_internal_fn_trait(\n-        &self,\n-        span: Span,\n-        trait_def_id: DefId,\n-        trait_segment: &'a hir::PathSegment<'a>,\n-    ) {\n-        let trait_def = self.tcx().trait_def(trait_def_id);\n-\n-        if !self.tcx().features().unboxed_closures\n-            && trait_segment.generic_args().parenthesized != trait_def.paren_sugar\n-        {\n-            let sess = &self.tcx().sess.parse_sess;\n-            // For now, require that parenthetical notation be used only with `Fn()` etc.\n-            let (msg, sugg) = if trait_def.paren_sugar {\n-                (\n-                    \"the precise format of `Fn`-family traits' type parameters is subject to \\\n-                     change\",\n-                    Some(format!(\n-                        \"{}{} -> {}\",\n-                        trait_segment.ident,\n-                        trait_segment\n-                            .args\n-                            .as_ref()\n-                            .and_then(|args| args.args.get(0))\n-                            .and_then(|arg| match arg {\n-                                hir::GenericArg::Type(ty) => match ty.kind {\n-                                    hir::TyKind::Tup(t) => t\n-                                        .iter()\n-                                        .map(|e| sess.source_map().span_to_snippet(e.span))\n-                                        .collect::<Result<Vec<_>, _>>()\n-                                        .map(|a| a.join(\", \")),\n-                                    _ => sess.source_map().span_to_snippet(ty.span),\n-                                }\n-                                .map(|s| format!(\"({})\", s))\n-                                .ok(),\n-                                _ => None,\n-                            })\n-                            .unwrap_or_else(|| \"()\".to_string()),\n-                        trait_segment\n-                            .generic_args()\n-                            .bindings\n-                            .iter()\n-                            .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n-                                (true, hir::TypeBindingKind::Equality { ty }) => {\n-                                    sess.source_map().span_to_snippet(ty.span).ok()\n-                                }\n-                                _ => None,\n-                            })\n-                            .unwrap_or_else(|| \"()\".to_string()),\n-                    )),\n-                )\n-            } else {\n-                (\"parenthetical notation is only stable when used with `Fn`-family traits\", None)\n-            };\n-            let mut err = feature_err(sess, sym::unboxed_closures, span, msg);\n-            if let Some(sugg) = sugg {\n-                let msg = \"use parenthetical notation instead\";\n-                err.span_suggestion(span, msg, sugg, Applicability::MaybeIncorrect);\n-            }\n-            err.emit();\n-        }\n-    }\n-\n     fn create_substs_for_ast_trait_ref<'a>(\n         &self,\n         span: Span,\n@@ -1912,196 +1245,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty\n     }\n \n-    /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n-    /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n-    /// same trait bound have the same name (as they come from different super-traits), we instead\n-    /// emit a generic note suggesting using a `where` clause to constraint instead.\n-    fn complain_about_missing_associated_types(\n-        &self,\n-        associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n-        potential_assoc_types: Vec<Span>,\n-        trait_bounds: &[hir::PolyTraitRef<'_>],\n-    ) {\n-        if associated_types.values().all(|v| v.is_empty()) {\n-            return;\n-        }\n-        let tcx = self.tcx();\n-        // FIXME: Marked `mut` so that we can replace the spans further below with a more\n-        // appropriate one, but this should be handled earlier in the span assignment.\n-        let mut associated_types: FxHashMap<Span, Vec<_>> = associated_types\n-            .into_iter()\n-            .map(|(span, def_ids)| {\n-                (span, def_ids.into_iter().map(|did| tcx.associated_item(did)).collect())\n-            })\n-            .collect();\n-        let mut names = vec![];\n-\n-        // Account for things like `dyn Foo + 'a`, like in tests `issue-22434.rs` and\n-        // `issue-22560.rs`.\n-        let mut trait_bound_spans: Vec<Span> = vec![];\n-        for (span, items) in &associated_types {\n-            if !items.is_empty() {\n-                trait_bound_spans.push(*span);\n-            }\n-            for assoc_item in items {\n-                let trait_def_id = assoc_item.container.id();\n-                names.push(format!(\n-                    \"`{}` (from trait `{}`)\",\n-                    assoc_item.ident,\n-                    tcx.def_path_str(trait_def_id),\n-                ));\n-            }\n-        }\n-        if let ([], [bound]) = (&potential_assoc_types[..], &trait_bounds) {\n-            match &bound.trait_ref.path.segments[..] {\n-                // FIXME: `trait_ref.path.span` can point to a full path with multiple\n-                // segments, even though `trait_ref.path.segments` is of length `1`. Work\n-                // around that bug here, even though it should be fixed elsewhere.\n-                // This would otherwise cause an invalid suggestion. For an example, look at\n-                // `src/test/ui/issues/issue-28344.rs` where instead of the following:\n-                //\n-                //   error[E0191]: the value of the associated type `Output`\n-                //                 (from trait `std::ops::BitXor`) must be specified\n-                //   --> $DIR/issue-28344.rs:4:17\n-                //    |\n-                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n-                //    |                 ^^^^^^ help: specify the associated type:\n-                //    |                              `BitXor<Output = Type>`\n-                //\n-                // we would output:\n-                //\n-                //   error[E0191]: the value of the associated type `Output`\n-                //                 (from trait `std::ops::BitXor`) must be specified\n-                //   --> $DIR/issue-28344.rs:4:17\n-                //    |\n-                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n-                //    |                 ^^^^^^^^^^^^^ help: specify the associated type:\n-                //    |                                     `BitXor::bitor<Output = Type>`\n-                [segment] if segment.args.is_none() => {\n-                    trait_bound_spans = vec![segment.ident.span];\n-                    associated_types = associated_types\n-                        .into_iter()\n-                        .map(|(_, items)| (segment.ident.span, items))\n-                        .collect();\n-                }\n-                _ => {}\n-            }\n-        }\n-        names.sort();\n-        trait_bound_spans.sort();\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            trait_bound_spans,\n-            E0191,\n-            \"the value of the associated type{} {} must be specified\",\n-            pluralize!(names.len()),\n-            names.join(\", \"),\n-        );\n-        let mut suggestions = vec![];\n-        let mut types_count = 0;\n-        let mut where_constraints = vec![];\n-        for (span, assoc_items) in &associated_types {\n-            let mut names: FxHashMap<_, usize> = FxHashMap::default();\n-            for item in assoc_items {\n-                types_count += 1;\n-                *names.entry(item.ident.name).or_insert(0) += 1;\n-            }\n-            let mut dupes = false;\n-            for item in assoc_items {\n-                let prefix = if names[&item.ident.name] > 1 {\n-                    let trait_def_id = item.container.id();\n-                    dupes = true;\n-                    format!(\"{}::\", tcx.def_path_str(trait_def_id))\n-                } else {\n-                    String::new()\n-                };\n-                if let Some(sp) = tcx.hir().span_if_local(item.def_id) {\n-                    err.span_label(sp, format!(\"`{}{}` defined here\", prefix, item.ident));\n-                }\n-            }\n-            if potential_assoc_types.len() == assoc_items.len() {\n-                // Only suggest when the amount of missing associated types equals the number of\n-                // extra type arguments present, as that gives us a relatively high confidence\n-                // that the user forgot to give the associtated type's name. The canonical\n-                // example would be trying to use `Iterator<isize>` instead of\n-                // `Iterator<Item = isize>`.\n-                for (potential, item) in potential_assoc_types.iter().zip(assoc_items.iter()) {\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*potential) {\n-                        suggestions.push((*potential, format!(\"{} = {}\", item.ident, snippet)));\n-                    }\n-                }\n-            } else if let (Ok(snippet), false) =\n-                (tcx.sess.source_map().span_to_snippet(*span), dupes)\n-            {\n-                let types: Vec<_> =\n-                    assoc_items.iter().map(|item| format!(\"{} = Type\", item.ident)).collect();\n-                let code = if snippet.ends_with('>') {\n-                    // The user wrote `Trait<'a>` or similar and we don't have a type we can\n-                    // suggest, but at least we can clue them to the correct syntax\n-                    // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the\n-                    // suggestion.\n-                    format!(\"{}, {}>\", &snippet[..snippet.len() - 1], types.join(\", \"))\n-                } else {\n-                    // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n-                    // least we can clue them to the correct syntax `Iterator<Item = Type>`.\n-                    format!(\"{}<{}>\", snippet, types.join(\", \"))\n-                };\n-                suggestions.push((*span, code));\n-            } else if dupes {\n-                where_constraints.push(*span);\n-            }\n-        }\n-        let where_msg = \"consider introducing a new type parameter, adding `where` constraints \\\n-                         using the fully-qualified path to the associated types\";\n-        if !where_constraints.is_empty() && suggestions.is_empty() {\n-            // If there are duplicates associated type names and a single trait bound do not\n-            // use structured suggestion, it means that there are multiple super-traits with\n-            // the same associated type name.\n-            err.help(where_msg);\n-        }\n-        if suggestions.len() != 1 {\n-            // We don't need this label if there's an inline suggestion, show otherwise.\n-            for (span, assoc_items) in &associated_types {\n-                let mut names: FxHashMap<_, usize> = FxHashMap::default();\n-                for item in assoc_items {\n-                    types_count += 1;\n-                    *names.entry(item.ident.name).or_insert(0) += 1;\n-                }\n-                let mut label = vec![];\n-                for item in assoc_items {\n-                    let postfix = if names[&item.ident.name] > 1 {\n-                        let trait_def_id = item.container.id();\n-                        format!(\" (from trait `{}`)\", tcx.def_path_str(trait_def_id))\n-                    } else {\n-                        String::new()\n-                    };\n-                    label.push(format!(\"`{}`{}\", item.ident, postfix));\n-                }\n-                if !label.is_empty() {\n-                    err.span_label(\n-                        *span,\n-                        format!(\n-                            \"associated type{} {} must be specified\",\n-                            pluralize!(label.len()),\n-                            label.join(\", \"),\n-                        ),\n-                    );\n-                }\n-            }\n-        }\n-        if !suggestions.is_empty() {\n-            err.multipart_suggestion(\n-                &format!(\"specify the associated type{}\", pluralize!(types_count)),\n-                suggestions,\n-                Applicability::HasPlaceholders,\n-            );\n-            if !where_constraints.is_empty() {\n-                err.span_help(where_constraints, where_msg);\n-            }\n-        }\n-        err.emit();\n-    }\n-\n     fn report_ambiguous_associated_type(\n         &self,\n         span: Span,\n@@ -2289,52 +1432,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(bound)\n     }\n \n-    fn complain_about_assoc_type_not_found<I>(\n-        &self,\n-        all_candidates: impl Fn() -> I,\n-        ty_param_name: &str,\n-        assoc_name: Ident,\n-        span: Span,\n-    ) where\n-        I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-    {\n-        // The fallback span is needed because `assoc_name` might be an `Fn()`'s `Output` without a\n-        // valid span, so we point at the whole path segment instead.\n-        let span = if assoc_name.span != DUMMY_SP { assoc_name.span } else { span };\n-        let mut err = struct_span_err!(\n-            self.tcx().sess,\n-            span,\n-            E0220,\n-            \"associated type `{}` not found for `{}`\",\n-            assoc_name,\n-            ty_param_name\n-        );\n-\n-        let all_candidate_names: Vec<_> = all_candidates()\n-            .map(|r| self.tcx().associated_items(r.def_id()).in_definition_order())\n-            .flatten()\n-            .filter_map(\n-                |item| if item.kind == ty::AssocKind::Type { Some(item.ident.name) } else { None },\n-            )\n-            .collect();\n-\n-        if let (Some(suggested_name), true) = (\n-            find_best_match_for_name(all_candidate_names.iter(), assoc_name.name, None),\n-            assoc_name.span != DUMMY_SP,\n-        ) {\n-            err.span_suggestion(\n-                assoc_name.span,\n-                \"there is an associated type with a similar name\",\n-                suggested_name.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            err.span_label(span, format!(\"associated type `{}` not found\", assoc_name));\n-        }\n-\n-        err.emit();\n-    }\n-\n     // Create a type from a path to an associated type.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for\n@@ -2637,57 +1734,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         has_err\n     }\n \n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0229,\n-            \"associated type bindings are not allowed here\"\n-        );\n-        err.span_label(span, \"associated type not allowed here\").emit();\n-    }\n-\n-    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n-    /// are present. This is used both for datatypes and function calls.\n-    fn prohibit_explicit_late_bound_lifetimes(\n-        tcx: TyCtxt<'_>,\n-        def: &ty::Generics,\n-        args: &hir::GenericArgs<'_>,\n-        position: GenericArgPosition,\n-    ) -> ExplicitLateBound {\n-        let param_counts = def.own_counts();\n-        let arg_counts = args.own_counts();\n-        let infer_lifetimes = position != GenericArgPosition::Type && arg_counts.lifetimes == 0;\n-\n-        if infer_lifetimes {\n-            ExplicitLateBound::No\n-        } else if let Some(span_late) = def.has_late_bound_regions {\n-            let msg = \"cannot specify lifetime arguments explicitly \\\n-                       if late bound lifetime parameters are present\";\n-            let note = \"the late bound lifetime parameter is introduced here\";\n-            let span = args.args[0].span();\n-            if position == GenericArgPosition::Value\n-                && arg_counts.lifetimes != param_counts.lifetimes\n-            {\n-                let mut err = tcx.sess.struct_span_err(span, msg);\n-                err.span_note(span_late, note);\n-                err.emit();\n-            } else {\n-                let mut multispan = MultiSpan::from_span(span);\n-                multispan.push_span_label(span_late, note.to_string());\n-                tcx.struct_span_lint_hir(\n-                    LATE_BOUND_LIFETIME_ARGUMENTS,\n-                    args.args[0].id(),\n-                    multispan,\n-                    |lint| lint.build(msg).emit(),\n-                );\n-            }\n-            ExplicitLateBound::Yes\n-        } else {\n-            ExplicitLateBound::No\n-        }\n-    }\n-\n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n     pub fn def_ids_for_value_path_segments(\n         &self,\n@@ -3248,92 +2294,3 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Some(r)\n     }\n }\n-\n-/// Collects together a list of bounds that are applied to some type,\n-/// after they've been converted into `ty` form (from the HIR\n-/// representations). These lists of bounds occur in many places in\n-/// Rust's syntax:\n-///\n-/// ```text\n-/// trait Foo: Bar + Baz { }\n-///            ^^^^^^^^^ supertrait list bounding the `Self` type parameter\n-///\n-/// fn foo<T: Bar + Baz>() { }\n-///           ^^^^^^^^^ bounding the type parameter `T`\n-///\n-/// impl dyn Bar + Baz\n-///          ^^^^^^^^^ bounding the forgotten dynamic type\n-/// ```\n-///\n-/// Our representation is a bit mixed here -- in some cases, we\n-/// include the self type (e.g., `trait_bounds`) but in others we do\n-#[derive(Default, PartialEq, Eq, Clone, Debug)]\n-pub struct Bounds<'tcx> {\n-    /// A list of region bounds on the (implicit) self type. So if you\n-    /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n-    /// the `T` is not explicitly included).\n-    pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n-\n-    /// A list of trait bounds. So if you had `T: Debug` this would be\n-    /// `T: Debug`. Note that the self-type is explicit here.\n-    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span, Constness)>,\n-\n-    /// A list of projection equality bounds. So if you had `T:\n-    /// Iterator<Item = u32>` this would include `<T as\n-    /// Iterator>::Item => u32`. Note that the self-type is explicit\n-    /// here.\n-    pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n-\n-    /// `Some` if there is *no* `?Sized` predicate. The `span`\n-    /// is the location in the source of the `T` declaration which can\n-    /// be cited as the source of the `T: Sized` requirement.\n-    pub implicitly_sized: Option<Span>,\n-}\n-\n-impl<'tcx> Bounds<'tcx> {\n-    /// Converts a bounds list into a flat set of predicates (like\n-    /// where-clauses). Because some of our bounds listings (e.g.,\n-    /// regions) don't include the self-type, you must supply the\n-    /// self-type here (the `param_ty` parameter).\n-    pub fn predicates(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        param_ty: Ty<'tcx>,\n-    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-        // If it could be sized, and is, add the `Sized` predicate.\n-        let sized_predicate = self.implicitly_sized.and_then(|span| {\n-            tcx.lang_items().sized_trait().map(|sized| {\n-                let trait_ref = ty::Binder::bind(ty::TraitRef {\n-                    def_id: sized,\n-                    substs: tcx.mk_substs_trait(param_ty, &[]),\n-                });\n-                (trait_ref.without_const().to_predicate(tcx), span)\n-            })\n-        });\n-\n-        sized_predicate\n-            .into_iter()\n-            .chain(\n-                self.region_bounds\n-                    .iter()\n-                    .map(|&(region_bound, span)| {\n-                        // Account for the binder being introduced below; no need to shift `param_ty`\n-                        // because, at present at least, it either only refers to early-bound regions,\n-                        // or it's a generic associated type that deliberately has escaping bound vars.\n-                        let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n-                        let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n-                        (ty::Binder::bind(outlives).to_predicate(tcx), span)\n-                    })\n-                    .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n-                        let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n-                        (predicate, span)\n-                    }))\n-                    .chain(\n-                        self.projection_bounds\n-                            .iter()\n-                            .map(|&(projection, span)| (projection.to_predicate(tcx), span)),\n-                    ),\n-            )\n-            .collect()\n-    }\n-}", "previous_filename": "src/librustc_typeck/astconv.rs"}, {"sha": "63295f5faacc9c8b4d6aea95025c1ea17de1be56", "filename": "src/librustc_typeck/bounds.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fbounds.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -0,0 +1,93 @@\n+//! Bounds are restrictions applied to some types after they've been converted into the\n+//! `ty` form from the HIR.\n+\n+use rustc_hir::Constness;\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_span::Span;\n+\n+/// Collects together a list of type bounds. These lists of bounds occur in many places\n+/// in Rust's syntax:\n+///\n+/// ```text\n+/// trait Foo: Bar + Baz { }\n+///            ^^^^^^^^^ supertrait list bounding the `Self` type parameter\n+///\n+/// fn foo<T: Bar + Baz>() { }\n+///           ^^^^^^^^^ bounding the type parameter `T`\n+///\n+/// impl dyn Bar + Baz\n+///          ^^^^^^^^^ bounding the forgotten dynamic type\n+/// ```\n+///\n+/// Our representation is a bit mixed here -- in some cases, we\n+/// include the self type (e.g., `trait_bounds`) but in others we do not\n+#[derive(Default, PartialEq, Eq, Clone, Debug)]\n+pub struct Bounds<'tcx> {\n+    /// A list of region bounds on the (implicit) self type. So if you\n+    /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n+    /// the `T` is not explicitly included).\n+    pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n+\n+    /// A list of trait bounds. So if you had `T: Debug` this would be\n+    /// `T: Debug`. Note that the self-type is explicit here.\n+    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span, Constness)>,\n+\n+    /// A list of projection equality bounds. So if you had `T:\n+    /// Iterator<Item = u32>` this would include `<T as\n+    /// Iterator>::Item => u32`. Note that the self-type is explicit\n+    /// here.\n+    pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n+\n+    /// `Some` if there is *no* `?Sized` predicate. The `span`\n+    /// is the location in the source of the `T` declaration which can\n+    /// be cited as the source of the `T: Sized` requirement.\n+    pub implicitly_sized: Option<Span>,\n+}\n+\n+impl<'tcx> Bounds<'tcx> {\n+    /// Converts a bounds list into a flat set of predicates (like\n+    /// where-clauses). Because some of our bounds listings (e.g.,\n+    /// regions) don't include the self-type, you must supply the\n+    /// self-type here (the `param_ty` parameter).\n+    pub fn predicates(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_ty: Ty<'tcx>,\n+    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n+        // If it could be sized, and is, add the `Sized` predicate.\n+        let sized_predicate = self.implicitly_sized.and_then(|span| {\n+            tcx.lang_items().sized_trait().map(|sized| {\n+                let trait_ref = ty::Binder::bind(ty::TraitRef {\n+                    def_id: sized,\n+                    substs: tcx.mk_substs_trait(param_ty, &[]),\n+                });\n+                (trait_ref.without_const().to_predicate(tcx), span)\n+            })\n+        });\n+\n+        sized_predicate\n+            .into_iter()\n+            .chain(\n+                self.region_bounds\n+                    .iter()\n+                    .map(|&(region_bound, span)| {\n+                        // Account for the binder being introduced below; no need to shift `param_ty`\n+                        // because, at present at least, it either only refers to early-bound regions,\n+                        // or it's a generic associated type that deliberately has escaping bound vars.\n+                        let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n+                        let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n+                        (ty::Binder::bind(outlives).to_predicate(tcx), span)\n+                    })\n+                    .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n+                        let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n+                        (predicate, span)\n+                    }))\n+                    .chain(\n+                        self.projection_bounds\n+                            .iter()\n+                            .map(|&(projection, span)| (projection.to_predicate(tcx), span)),\n+                    ),\n+            )\n+            .collect()\n+    }\n+}"}, {"sha": "9afac60bb5bb78b669b15f989408d476212a9dc0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -14,7 +14,8 @@\n //! At present, however, we do run collection across all items in the\n //! crate as a kind of pass. This should eventually be factored away.\n \n-use crate::astconv::{AstConv, Bounds, SizedByDefault};\n+use crate::astconv::{AstConv, SizedByDefault};\n+use crate::bounds::Bounds;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n use crate::middle::resolve_lifetime as rl;"}, {"sha": "62f92fe7ffa484859e2699610230ba8ae827740a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -79,6 +79,7 @@ pub mod check;\n pub mod expr_use_visitor;\n \n mod astconv;\n+mod bounds;\n mod check_unused;\n mod coherence;\n mod collect;\n@@ -109,7 +110,8 @@ use rustc_trait_selection::traits::{\n \n use std::iter;\n \n-use astconv::{AstConv, Bounds};\n+use astconv::AstConv;\n+use bounds::Bounds;\n \n fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n     if decl.c_variadic && !(abi == Abi::C || abi == Abi::Cdecl) {"}, {"sha": "457359e7a3806f20746823b7dcd02011929f9c7a", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -27,20 +27,29 @@ fn calculate_doc_coverage(krate: clean::Crate, ctx: &DocContext<'_>) -> clean::C\n     krate\n }\n \n-#[derive(Default, Copy, Clone, Serialize)]\n+#[derive(Default, Copy, Clone, Serialize, Debug)]\n struct ItemCount {\n     total: u64,\n     with_docs: u64,\n+    total_examples: u64,\n     with_examples: u64,\n }\n \n impl ItemCount {\n-    fn count_item(&mut self, has_docs: bool, has_doc_example: bool) {\n+    fn count_item(\n+        &mut self,\n+        has_docs: bool,\n+        has_doc_example: bool,\n+        should_have_doc_examples: bool,\n+    ) {\n         self.total += 1;\n \n         if has_docs {\n             self.with_docs += 1;\n         }\n+        if should_have_doc_examples || has_doc_example {\n+            self.total_examples += 1;\n+        }\n         if has_doc_example {\n             self.with_examples += 1;\n         }\n@@ -55,8 +64,8 @@ impl ItemCount {\n     }\n \n     fn examples_percentage(&self) -> Option<f64> {\n-        if self.total > 0 {\n-            Some((self.with_examples as f64 * 100.0) / self.total as f64)\n+        if self.total_examples > 0 {\n+            Some((self.with_examples as f64 * 100.0) / self.total_examples as f64)\n         } else {\n             None\n         }\n@@ -70,6 +79,7 @@ impl ops::Sub for ItemCount {\n         ItemCount {\n             total: self.total - rhs.total,\n             with_docs: self.with_docs - rhs.with_docs,\n+            total_examples: self.total_examples - rhs.total_examples,\n             with_examples: self.with_examples - rhs.with_examples,\n         }\n     }\n@@ -79,6 +89,7 @@ impl ops::AddAssign for ItemCount {\n     fn add_assign(&mut self, rhs: Self) {\n         self.total += rhs.total;\n         self.with_docs += rhs.with_docs;\n+        self.total_examples += rhs.total_examples;\n         self.with_examples += rhs.with_examples;\n     }\n }\n@@ -121,7 +132,7 @@ impl CoverageCalculator {\n         let mut total = ItemCount::default();\n \n         fn print_table_line() {\n-            println!(\"+-{0:->35}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n+            println!(\"+-{0:->35}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+-{0:->10}-+\", \"\");\n         }\n \n         fn print_table_record(\n@@ -131,32 +142,25 @@ impl CoverageCalculator {\n             examples_percentage: f64,\n         ) {\n             println!(\n-                \"| {:<35} | {:>10} | {:>10} | {:>9.1}% | {:>10} | {:>9.1}% |\",\n-                name,\n-                count.with_docs,\n-                count.total,\n-                percentage,\n-                count.with_examples,\n-                examples_percentage,\n+                \"| {:<35} | {:>10} | {:>9.1}% | {:>10} | {:>9.1}% |\",\n+                name, count.with_docs, percentage, count.with_examples, examples_percentage,\n             );\n         }\n \n         print_table_line();\n         println!(\n-            \"| {:<35} | {:>10} | {:>10} | {:>10} | {:>10} | {:>10} |\",\n-            \"File\", \"Documented\", \"Total\", \"Percentage\", \"Examples\", \"Percentage\",\n+            \"| {:<35} | {:>10} | {:>10} | {:>10} | {:>10} |\",\n+            \"File\", \"Documented\", \"Percentage\", \"Examples\", \"Percentage\",\n         );\n         print_table_line();\n \n         for (file, &count) in &self.items {\n-            if let (Some(percentage), Some(examples_percentage)) =\n-                (count.percentage(), count.examples_percentage())\n-            {\n+            if let Some(percentage) = count.percentage() {\n                 print_table_record(\n                     &limit_filename_len(file.to_string()),\n                     count,\n                     percentage,\n-                    examples_percentage,\n+                    count.examples_percentage().unwrap_or(0.),\n                 );\n \n                 total += count;\n@@ -176,19 +180,6 @@ impl CoverageCalculator {\n \n impl fold::DocFolder for CoverageCalculator {\n     fn fold_item(&mut self, i: clean::Item) -> Option<clean::Item> {\n-        let has_docs = !i.attrs.doc_strings.is_empty();\n-        let mut tests = Tests { found_tests: 0 };\n-\n-        find_testable_code(\n-            &i.attrs.doc_strings.iter().map(|d| d.as_str()).collect::<Vec<_>>().join(\"\\n\"),\n-            &mut tests,\n-            ErrorCodes::No,\n-            false,\n-            None,\n-        );\n-\n-        let has_doc_example = tests.found_tests != 0;\n-\n         match i.inner {\n             _ if !i.def_id.is_local() => {\n                 // non-local items are skipped because they can be out of the users control,\n@@ -237,11 +228,37 @@ impl fold::DocFolder for CoverageCalculator {\n                 }\n             }\n             _ => {\n+                let has_docs = !i.attrs.doc_strings.is_empty();\n+                let mut tests = Tests { found_tests: 0 };\n+\n+                let should_have_doc_examples = !matches!(i.inner,\n+                    clean::StructFieldItem(_)\n+                    | clean::VariantItem(_)\n+                    | clean::AssocConstItem(_, _)\n+                    | clean::AssocTypeItem(_, _)\n+                    | clean::TypedefItem(_, _)\n+                    | clean::StaticItem(_)\n+                    | clean::ConstantItem(_)\n+                    | clean::ExternCrateItem(_, _)\n+                    | clean::ImportItem(_)\n+                    | clean::PrimitiveItem(_)\n+                    | clean::KeywordItem(_)\n+                );\n+                find_testable_code(\n+                    &i.attrs.doc_strings.iter().map(|d| d.as_str()).collect::<Vec<_>>().join(\"\\n\"),\n+                    &mut tests,\n+                    ErrorCodes::No,\n+                    false,\n+                    None,\n+                );\n+\n+                let has_doc_example = tests.found_tests != 0;\n                 debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, i.source.filename);\n-                self.items\n-                    .entry(i.source.filename.clone())\n-                    .or_default()\n-                    .count_item(has_docs, has_doc_example);\n+                self.items.entry(i.source.filename.clone()).or_default().count_item(\n+                    has_docs,\n+                    has_doc_example,\n+                    should_have_doc_examples,\n+                );\n             }\n         }\n "}, {"sha": "9c57435a8c01613c8927c67ce7847b6b18b9ed69", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -636,7 +636,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 }\n \n                 match disambiguator.map(Disambiguator::ns) {\n-                    Some(ns @ ValueNS) => {\n+                    Some(ns @ (ValueNS | TypeNS)) => {\n                         match self.resolve(\n                             path_str,\n                             disambiguator,\n@@ -660,28 +660,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    Some(ns @ TypeNS) => {\n-                        match self.resolve(\n-                            path_str,\n-                            disambiguator,\n-                            ns,\n-                            &current_item,\n-                            base_node,\n-                            &extra_fragment,\n-                            Some(&item),\n-                        ) {\n-                            Ok(res) => res,\n-                            Err(ErrorKind::ResolutionFailure) => {\n-                                resolution_failure(cx, &item, path_str, &dox, link_range);\n-                                // This could just be a normal link.\n-                                continue;\n-                            }\n-                            Err(ErrorKind::AnchorFailure(msg)) => {\n-                                anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n-                                continue;\n-                            }\n-                        }\n-                    }\n                     None => {\n                         // Try everything!\n                         let mut candidates = PerNS {"}, {"sha": "e39f74c916c4ad4a7a233a10c701b2ba1ec39621", "filename": "src/test/assembly/asm/aarch64-types.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Faarch64-types.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -553,3 +553,8 @@ check_reg!(v0_f32x4 f32x4 \"s0\" \"fmov\");\n // CHECK: fmov s0, s0\n // CHECK: //NO_APP\n check_reg!(v0_f64x2 f64x2 \"s0\" \"fmov\");\n+\n+// Regression test for #75761\n+pub unsafe fn issue_75761() {\n+    asm!(\"\", out(\"v0\") _, out(\"x30\") _);\n+}"}, {"sha": "3c602b3da4c7c8952347566f6acb16fbcf7ebea4", "filename": "src/test/rustdoc-ui/coverage/basic.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fbasic.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,7 +1,7 @@\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| File                                | Documented |      Total | Percentage |   Examples | Percentage |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| ...est/rustdoc-ui/coverage/basic.rs |          7 |         14 |      50.0% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| Total                               |          7 |         14 |      50.0% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| ...est/rustdoc-ui/coverage/basic.rs |          7 |      50.0% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          7 |      50.0% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+"}, {"sha": "1da1813790e860b81e35edb871117ef7e9da98fe", "filename": "src/test/rustdoc-ui/coverage/doc-examples-json.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples-json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples-json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples-json.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+// compile-flags:-Z unstable-options --output-format json --show-coverage\n+\n+// This check ensures that only one doc example is counted since they're \"optional\" on\n+// certain items.\n+\n+/// ```\n+/// let x = 12;\n+/// ```\n+pub const Foo: u32 = 0;\n+\n+/// doc\n+pub const Bar: u32 = 0;"}, {"sha": "92f58556975ae89b97c11a0a5a4d91d547032cfa", "filename": "src/test/rustdoc-ui/coverage/doc-examples-json.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples-json.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples-json.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples-json.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -0,0 +1 @@\n+{\"$DIR/doc-examples-json.rs\":{\"total\":3,\"with_docs\":2,\"total_examples\":2,\"with_examples\":1}}"}, {"sha": "10ed13c9ff566c76d169649cc58949d7031dd442", "filename": "src/test/rustdoc-ui/coverage/doc-examples.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fdoc-examples.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,7 +1,7 @@\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| File                                | Documented |      Total | Percentage |   Examples | Percentage |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| ...tdoc-ui/coverage/doc-examples.rs |          4 |          4 |     100.0% |          2 |      50.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| Total                               |          4 |          4 |     100.0% |          2 |      50.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| ...tdoc-ui/coverage/doc-examples.rs |          4 |     100.0% |          2 |      50.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          4 |     100.0% |          2 |      50.0% |\n++-------------------------------------+------------+------------+------------+------------+"}, {"sha": "890a7d56e162d09bb8e0cc933a75d261cc634a26", "filename": "src/test/rustdoc-ui/coverage/empty.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fempty.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,7 +1,7 @@\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| File                                | Documented |      Total | Percentage |   Examples | Percentage |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| ...est/rustdoc-ui/coverage/empty.rs |          0 |          1 |       0.0% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| Total                               |          0 |          1 |       0.0% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| ...est/rustdoc-ui/coverage/empty.rs |          0 |       0.0% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          0 |       0.0% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+"}, {"sha": "64c012c1f66e3dfea1eea7a743511b78a08e0f5f", "filename": "src/test/rustdoc-ui/coverage/enums.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fenums.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,7 +1,7 @@\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| File                                | Documented |      Total | Percentage |   Examples | Percentage |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| ...est/rustdoc-ui/coverage/enums.rs |          6 |          8 |      75.0% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| Total                               |          6 |          8 |      75.0% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| ...est/rustdoc-ui/coverage/enums.rs |          6 |      75.0% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          6 |      75.0% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+"}, {"sha": "e282ff128437513e3a88564d4c564db7ce263d8c", "filename": "src/test/rustdoc-ui/coverage/exotic.stdout", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fexotic.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,8 +1,8 @@\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| File                                | Documented |      Total | Percentage |   Examples | Percentage |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| ...st/rustdoc-ui/coverage/exotic.rs |          1 |          1 |     100.0% |          0 |       0.0% |\n-| <anon>                              |          2 |          2 |     100.0% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| Total                               |          3 |          3 |     100.0% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| ...st/rustdoc-ui/coverage/exotic.rs |          1 |     100.0% |          0 |       0.0% |\n+| <anon>                              |          2 |     100.0% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          3 |     100.0% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+"}, {"sha": "a591cd5dba406ec1a0a29f72b163d9e6dab3eaae", "filename": "src/test/rustdoc-ui/coverage/json.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -12,16 +12,54 @@ pub mod foo {\n pub struct X;\n \n /// Bar\n+///\n+/// ```\n+/// let x = 12;\n+/// ```\n pub mod bar {\n     /// bar\n     pub struct Bar;\n     /// X\n-    pub enum X { Y }\n+    pub enum X {\n+        /// ```\n+        /// let x = \"should be ignored!\";\n+        /// ```\n+        Y\n+    }\n }\n \n /// yolo\n+///\n+/// ```text\n+/// should not be counted as a code example!\n+/// ```\n pub enum Yolo { X }\n \n+impl Yolo {\n+    /// ```\n+    /// let x = \"should be ignored!\";\n+    /// ```\n+    pub const Const: u32 = 0;\n+}\n+\n pub struct Xo<T: Clone> {\n+    /// ```\n+    /// let x = \"should be ignored!\";\n+    /// ```\n     x: T,\n }\n+\n+/// ```\n+/// let x = \"should be ignored!\";\n+/// ```\n+pub static StaticFoo: u32 = 0;\n+\n+/// ```\n+/// let x = \"should be ignored!\";\n+/// ```\n+pub const ConstFoo: u32 = 0;\n+\n+/// ```\n+/// let x = \"should be ignored!\";\n+/// ```\n+pub type TypeFoo = u32;"}, {"sha": "c2be73ce3edd7c14b99a46e3445948ed27187041", "filename": "src/test/rustdoc-ui/coverage/json.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fjson.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1 +1 @@\n-{\"$DIR/json.rs\":{\"total\":13,\"with_docs\":7,\"with_examples\":0}}\n+{\"$DIR/json.rs\":{\"total\":17,\"with_docs\":12,\"total_examples\":15,\"with_examples\":6}}"}, {"sha": "37a0f5187b5122fc745e20f6a195db081dd36a43", "filename": "src/test/rustdoc-ui/coverage/private.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fprivate.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,7 +1,7 @@\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| File                                | Documented |      Total | Percentage |   Examples | Percentage |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| ...t/rustdoc-ui/coverage/private.rs |          4 |          7 |      57.1% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| Total                               |          4 |          7 |      57.1% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| ...t/rustdoc-ui/coverage/private.rs |          4 |      57.1% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          4 |      57.1% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+"}, {"sha": "dbea3a3ea23cf5f98a59f1611d89ed805545b647", "filename": "src/test/rustdoc-ui/coverage/statics-consts.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Fstatics-consts.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,7 +1,7 @@\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| File                                | Documented |      Total | Percentage |   Examples | Percentage |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| ...oc-ui/coverage/statics-consts.rs |          6 |          7 |      85.7% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| Total                               |          6 |          7 |      85.7% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| ...oc-ui/coverage/statics-consts.rs |          6 |      85.7% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          6 |      85.7% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+"}, {"sha": "e04d48b4980c4c299859b70d16bee676c0745c4e", "filename": "src/test/rustdoc-ui/coverage/traits.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcoverage%2Ftraits.stdout?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,7 +1,7 @@\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| File                                | Documented |      Total | Percentage |   Examples | Percentage |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| ...st/rustdoc-ui/coverage/traits.rs |          6 |          7 |      85.7% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n-| Total                               |          6 |          7 |      85.7% |          0 |       0.0% |\n-+-------------------------------------+------------+------------+------------+------------+------------+\n++-------------------------------------+------------+------------+------------+------------+\n+| File                                | Documented | Percentage |   Examples | Percentage |\n++-------------------------------------+------------+------------+------------+------------+\n+| ...st/rustdoc-ui/coverage/traits.rs |          6 |      85.7% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+\n+| Total                               |          6 |      85.7% |          0 |       0.0% |\n++-------------------------------------+------------+------------+------------+------------+"}, {"sha": "8a6f7de1c9fbd3562990e8b592b7828a1f14656d", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -9,7 +9,8 @@\n // normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"thread.*panicked.*\\n\" -> \"\"\n // normalize-stderr-test \"stack backtrace:\\n\" -> \"\"\n-// normalize-stderr-test \"  \\d{1,}: .*\\n\" -> \"\"\n+// normalize-stderr-test \"\\s\\d{1,}: .*\\n\" -> \"\"\n+// normalize-stderr-test \"\\s at .*\\n\" -> \"\"\n // normalize-stderr-test \".*note: Some details.*\\n\" -> \"\"\n \n #![allow(unconditional_panic)]"}, {"sha": "dc2661ee796856816b8865c3361dccf17717a507", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e674422f8611b204dff48eb3e51b13f96ebcee32/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr?ref=e674422f8611b204dff48eb3e51b13f96ebcee32", "patch": "@@ -1,5 +1,5 @@\n error: reaching this expression at runtime will panic or abort\n-  --> $DIR/const-eval-query-stack.rs:18:28\n+  --> $DIR/const-eval-query-stack.rs:19:28\n    |\n LL |     let x: &'static i32 = &(1 / 0);\n    |                           -^^^^^^^"}]}