{"sha": "60259b9d90d977659c19644260f729adc3e43d75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMjU5YjlkOTBkOTc3NjU5YzE5NjQ0MjYwZjcyOWFkYzNlNDNkNzU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-05T18:24:41Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-09T20:17:00Z"}, "message": "Make trans::collector item printing methods independent of CrateContext.", "tree": {"sha": "22642760411b25377080e6eced2f7d590e029df6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22642760411b25377080e6eced2f7d590e029df6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60259b9d90d977659c19644260f729adc3e43d75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60259b9d90d977659c19644260f729adc3e43d75", "html_url": "https://github.com/rust-lang/rust/commit/60259b9d90d977659c19644260f729adc3e43d75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60259b9d90d977659c19644260f729adc3e43d75/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2ea54d2c6277f90312ae6a5de5f9165def99ffe", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ea54d2c6277f90312ae6a5de5f9165def99ffe", "html_url": "https://github.com/rust-lang/rust/commit/b2ea54d2c6277f90312ae6a5de5f9165def99ffe"}], "stats": {"total": 130, "additions": 65, "deletions": 65}, "files": [{"sha": "bb5b1e5c77522de02e0d8b5926ca45bae378b826", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60259b9d90d977659c19644260f729adc3e43d75/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60259b9d90d977659c19644260f729adc3e43d75/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=60259b9d90d977659c19644260f729adc3e43d75", "patch": "@@ -2964,7 +2964,7 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         let mut item_keys: Vec<_> = items\n             .iter()\n             .map(|i| {\n-                let mut output = i.to_string(ccx);\n+                let mut output = i.to_string(ccx.tcx());\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);"}, {"sha": "cb94c2a2cce84b47cc23f421c17bf1a6832bef0b", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/60259b9d90d977659c19644260f729adc3e43d75/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60259b9d90d977659c19644260f729adc3e43d75/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=60259b9d90d977659c19644260f729adc3e43d75", "patch": "@@ -378,7 +378,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(ccx));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(ccx.tcx()));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n@@ -430,7 +430,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx));\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx.tcx()));\n }\n \n fn record_references<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -657,7 +657,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(ccx, ty));\n+    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(ccx.tcx(), ty));\n \n     // Make sure the exchange_free_fn() lang-item gets translated if\n     // there is a boxed value.\n@@ -786,7 +786,7 @@ fn do_static_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> Option<(DefId, &'tcx Substs<'tcx>)> {\n     debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n-           def_id_to_string(ccx, fn_def_id),\n+           def_id_to_string(ccx.tcx(), fn_def_id),\n            fn_substs,\n            param_substs);\n \n@@ -834,8 +834,8 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                             trait_id={}, \\\n                                             callee_substs={:?}, \\\n                                             param_substs={:?}\",\n-           def_id_to_string(ccx, trait_method.def_id),\n-           def_id_to_string(ccx, trait_id),\n+           def_id_to_string(ccx.tcx(), trait_method.def_id),\n+           def_id_to_string(ccx.tcx(), trait_id),\n            callee_substs,\n            param_substs);\n \n@@ -968,7 +968,7 @@ fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   -> TransItem<'tcx>\n {\n     debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n-            def_id_to_string(ccx, def_id),\n+            def_id_to_string(ccx.tcx(), def_id),\n             fn_substs,\n             param_substs);\n \n@@ -1079,7 +1079,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n \n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n-                               def_id_to_string(self.ccx,\n+                               def_id_to_string(self.ccx.tcx(),\n                                                 self.ccx.tcx().map.local_def_id(item.id)));\n \n                         let ty = glue::get_drop_glue_type(self.ccx, ty);\n@@ -1089,7 +1089,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             }\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n-                       def_id_to_string(self.ccx,\n+                       def_id_to_string(self.ccx.tcx(),\n                                         self.ccx.tcx().map.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n@@ -1099,7 +1099,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     let def_id = self.ccx.tcx().map.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n-                           def_id_to_string(self.ccx, def_id));\n+                           def_id_to_string(self.ccx.tcx(), def_id));\n \n                     let instance = Instance::mono(self.ccx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n@@ -1136,7 +1136,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     let def_id = self.ccx.tcx().map.local_def_id(ii.id);\n \n                     debug!(\"RootCollector: MethodImplItem({})\",\n-                           def_id_to_string(self.ccx, def_id));\n+                           def_id_to_string(self.ccx.tcx(), def_id));\n \n                     let instance = Instance::mono(self.ccx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n@@ -1167,7 +1167,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let impl_def_id = tcx.map.local_def_id(item.id);\n \n             debug!(\"create_trans_items_for_default_impls(item={})\",\n-                   def_id_to_string(ccx, impl_def_id));\n+                   def_id_to_string(ccx.tcx(), impl_def_id));\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n@@ -1229,9 +1229,9 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n-pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                       t: ty::Ty<'tcx>,\n-                                       output: &mut String) {\n+pub fn push_unique_type_name<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                   t: ty::Ty<'tcx>,\n+                                   output: &mut String) {\n     match t.sty {\n         ty::TyBool              => output.push_str(\"bool\"),\n         ty::TyChar              => output.push_str(\"char\"),\n@@ -1250,13 +1250,13 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n         ty::TyStruct(adt_def, substs) |\n         ty::TyEnum(adt_def, substs) => {\n-            push_item_name(cx, adt_def.did, output);\n-            push_type_params(cx, &substs.types, &[], output);\n+            push_item_name(tcx, adt_def.did, output);\n+            push_type_params(tcx, &substs.types, &[], output);\n         },\n         ty::TyTuple(ref component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n-                push_unique_type_name(cx, component_type, output);\n+                push_unique_type_name(tcx, component_type, output);\n                 output.push_str(\", \");\n             }\n             if !component_types.is_empty() {\n@@ -1267,7 +1267,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         ty::TyBox(inner_type) => {\n             output.push_str(\"Box<\");\n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n             output.push('>');\n         },\n         ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n@@ -1277,30 +1277,30 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 hir::MutMutable => output.push_str(\"mut \"),\n             }\n \n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n         },\n         ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n             output.push('&');\n             if mutbl == hir::MutMutable {\n                 output.push_str(\"mut \");\n             }\n \n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n         },\n         ty::TyArray(inner_type, len) => {\n             output.push('[');\n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n             output.push_str(&format!(\"; {}\", len));\n             output.push(']');\n         },\n         ty::TySlice(inner_type) => {\n             output.push('[');\n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n             output.push(']');\n         },\n         ty::TyTrait(ref trait_data) => {\n-            push_item_name(cx, trait_data.principal.skip_binder().def_id, output);\n-            push_type_params(cx,\n+            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n+            push_type_params(tcx,\n                              &trait_data.principal.skip_binder().substs.types,\n                              &trait_data.bounds.projection_bounds,\n                              output);\n@@ -1319,10 +1319,10 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            let sig = cx.tcx().erase_late_bound_regions(sig);\n+            let sig = tcx.erase_late_bound_regions(sig);\n             if !sig.inputs.is_empty() {\n                 for &parameter_type in &sig.inputs {\n-                    push_unique_type_name(cx, parameter_type, output);\n+                    push_unique_type_name(tcx, parameter_type, output);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n@@ -1343,19 +1343,19 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 ty::FnConverging(result_type) if result_type.is_nil() => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");\n-                    push_unique_type_name(cx, result_type, output);\n+                    push_unique_type_name(tcx, result_type, output);\n                 }\n                 ty::FnDiverging => {\n                     output.push_str(\" -> !\");\n                 }\n             }\n         },\n         ty::TyClosure(def_id, ref closure_substs) => {\n-            push_item_name(cx, def_id, output);\n+            push_item_name(tcx, def_id, output);\n             output.push_str(\"{\");\n             output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n             output.push_str(\"}\");\n-            push_type_params(cx, &closure_substs.func_substs.types, &[], output);\n+            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n         }\n         ty::TyError |\n         ty::TyInfer(_) |\n@@ -1367,17 +1367,17 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn push_item_name(ccx: &CrateContext,\n+fn push_item_name(tcx: &TyCtxt,\n                   def_id: DefId,\n                   output: &mut String) {\n-    let def_path = ccx.tcx().def_path(def_id);\n+    let def_path = tcx.def_path(def_id);\n \n     // some_crate::\n-    output.push_str(&ccx.tcx().crate_name(def_path.krate));\n+    output.push_str(&tcx.crate_name(def_path.krate));\n     output.push_str(\"::\");\n \n     // foo::bar::ItemName::\n-    for part in ccx.tcx().def_path(def_id).data {\n+    for part in tcx.def_path(def_id).data {\n         output.push_str(&format!(\"{}[{}]::\",\n                         part.data.as_interned_str(),\n                         part.disambiguator));\n@@ -1388,18 +1388,18 @@ fn push_item_name(ccx: &CrateContext,\n     output.pop();\n }\n \n-fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n-                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n-                              output: &mut String) {\n+fn push_type_params<'tcx>(tcx: &TyCtxt<'tcx>,\n+                          types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n+                          projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                          output: &mut String) {\n     if types.is_empty() && projections.is_empty() {\n         return;\n     }\n \n     output.push('<');\n \n     for &type_parameter in types {\n-        push_unique_type_name(cx, type_parameter, output);\n+        push_unique_type_name(tcx, type_parameter, output);\n         output.push_str(\", \");\n     }\n \n@@ -1408,7 +1408,7 @@ fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n         output.push_str(&name[..]);\n         output.push_str(\"=\");\n-        push_unique_type_name(cx, projection.ty, output);\n+        push_unique_type_name(tcx, projection.ty, output);\n         output.push_str(\", \");\n     }\n \n@@ -1418,24 +1418,24 @@ fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     output.push('>');\n }\n \n-fn push_instance_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     instance: Instance<'tcx>,\n-                                     output: &mut String) {\n-    push_item_name(ccx, instance.def, output);\n-    push_type_params(ccx, &instance.substs.types, &[], output);\n+fn push_instance_as_string<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                 instance: Instance<'tcx>,\n+                                 output: &mut String) {\n+    push_item_name(tcx, instance.def, output);\n+    push_type_params(tcx, &instance.substs.types, &[], output);\n }\n \n-pub fn def_id_to_string(ccx: &CrateContext, def_id: DefId) -> String {\n+pub fn def_id_to_string(tcx: &TyCtxt, def_id: DefId) -> String {\n     let mut output = String::new();\n-    push_item_name(ccx, def_id, &mut output);\n+    push_item_name(tcx, def_id, &mut output);\n     output\n }\n \n-fn type_to_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            ty: ty::Ty<'tcx>)\n-                            -> String {\n+fn type_to_string<'tcx>(tcx: &TyCtxt<'tcx>,\n+                        ty: ty::Ty<'tcx>)\n+                        -> String {\n     let mut output = String::new();\n-    push_unique_type_name(ccx, ty, &mut output);\n+    push_unique_type_name(tcx, ty, &mut output);\n     output\n }\n \n@@ -1492,8 +1492,8 @@ impl<'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        let hir_map = &ccx.tcx().map;\n+    pub fn to_string(&self, tcx: &TyCtxt<'tcx>) -> String {\n+        let hir_map = &tcx.map;\n \n         return match *self {\n             TransItem::DropGlue(dg) => {\n@@ -1502,26 +1502,26 @@ impl<'tcx> TransItem<'tcx> {\n                     DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n                     DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n                 };\n-                push_unique_type_name(ccx, dg.ty(), &mut s);\n+                push_unique_type_name(tcx, dg.ty(), &mut s);\n                 s\n             }\n             TransItem::Fn(instance) => {\n-                to_string_internal(ccx, \"fn \", instance)\n+                to_string_internal(tcx, \"fn \", instance)\n             },\n             TransItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::mono(ccx.tcx(), def_id);\n-                to_string_internal(ccx, \"static \", instance)\n+                let instance = Instance::mono(tcx, def_id);\n+                to_string_internal(tcx, \"static \", instance)\n             },\n         };\n \n-        fn to_string_internal<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>)\n-                                        -> String {\n+        fn to_string_internal<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                    prefix: &str,\n+                                    instance: Instance<'tcx>)\n+                                    -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n-            push_instance_as_string(ccx, instance, &mut result);\n+            push_instance_as_string(tcx, instance, &mut result);\n             result\n         }\n     }\n@@ -1575,7 +1575,7 @@ pub fn print_collection_results<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         let mut item_keys = FnvHashMap();\n \n         for (item, item_state) in trans_items.iter() {\n-            let k = item.to_string(&ccx);\n+            let k = item.to_string(ccx.tcx());\n \n             if item_keys.contains_key(&k) {\n                 let prev: (TransItem, TransItemState) = item_keys[&k];\n@@ -1603,7 +1603,7 @@ pub fn print_collection_results<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n     let mut generated = FnvHashSet();\n \n     for (item, item_state) in trans_items.iter() {\n-        let item_key = item.to_string(&ccx);\n+        let item_key = item.to_string(ccx.tcx());\n \n         match *item_state {\n             TransItemState::PredictedAndGenerated => {"}]}