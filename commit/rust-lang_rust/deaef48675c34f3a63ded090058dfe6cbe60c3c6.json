{"sha": "deaef48675c34f3a63ded090058dfe6cbe60c3c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlYWVmNDg2NzVjMzRmM2E2M2RlZDA5MDA1OGRmZTZjYmU2MGMzYzY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T22:34:07Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-07T22:35:05Z"}, "message": "rustc: Split out struct bodies into a separate \"struct_def\" type in the AST", "tree": {"sha": "e4b3f23226443637b19d5fb0c30a4f84232e5383", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4b3f23226443637b19d5fb0c30a4f84232e5383"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deaef48675c34f3a63ded090058dfe6cbe60c3c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deaef48675c34f3a63ded090058dfe6cbe60c3c6", "html_url": "https://github.com/rust-lang/rust/commit/deaef48675c34f3a63ded090058dfe6cbe60c3c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deaef48675c34f3a63ded090058dfe6cbe60c3c6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a6dadad5bc7a0bb85f67ddaa9d38d9d4f741057", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a6dadad5bc7a0bb85f67ddaa9d38d9d4f741057", "html_url": "https://github.com/rust-lang/rust/commit/1a6dadad5bc7a0bb85f67ddaa9d38d9d4f741057"}], "stats": {"total": 211, "additions": 115, "deletions": 96}, "files": [{"sha": "78b1fa0a46900db375ecff2d764e8532dbd58ccf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -710,6 +710,17 @@ type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n #[auto_serialize]\n enum visibility { public, private, inherited }\n \n+#[auto_serialize]\n+type struct_def = {\n+    traits: ~[@trait_ref],   /* traits this class implements */\n+    members: ~[@class_member], /* methods, etc. */\n+    /* (not including ctor or dtor) */\n+    /* ctor is optional, and will soon go away */\n+    ctor: option<class_ctor>,\n+    /* dtor is optional */\n+    dtor: option<class_dtor>\n+};\n+\n #[auto_serialize]\n type item = {ident: ident, attrs: ~[attribute],\n              id: node_id, node: item_,\n@@ -723,15 +734,7 @@ enum item_ {\n     item_foreign_mod(foreign_mod),\n     item_ty(@ty, ~[ty_param]),\n     item_enum(~[variant], ~[ty_param]),\n-    item_class(~[ty_param], /* ty params for class */\n-               ~[@trait_ref],   /* traits this class implements */\n-               ~[@class_member], /* methods, etc. */\n-                               /* (not including ctor or dtor) */\n-               /* ctor is optional, and will soon go away */\n-               option<class_ctor>,\n-               /* dtor is optional */\n-               option<class_dtor>\n-               ),\n+    item_class(struct_def, ~[ty_param]),\n     item_trait(~[ty_param], ~[@trait_ref], ~[trait_method]),\n     item_impl(~[ty_param],\n               ~[@trait_ref], /* traits this impl implements */"}, {"sha": "0c3e99a379401e1bb4fc37cf31c83f3613d0ff5d", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -216,11 +216,11 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n                                            extend(cx, i.ident)));\n         }\n       }\n-      item_class(tps, traits, items, ctor, dtor) => {\n-          let (_, ms) = ast_util::split_class_items(items);\n+      item_class(struct_def, _) => {\n+          let (_, ms) = ast_util::split_class_items(struct_def.members);\n           // Map trait refs to their parent classes. This is\n           // so we can find the self_ty\n-          for traits.each |p| {\n+          for struct_def.traits.each |p| {\n               cx.map.insert(p.ref_id, node_item(i, item_path));\n               // This is so we can look up the right things when\n               // encoding/decoding"}, {"sha": "05f74a9c8994edc94b3dea9bee5a5037d8def591", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -242,9 +242,9 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             item_enum(vec::map(variants, |x| fld.fold_variant(x)),\n                       fold_ty_params(typms, fld))\n           }\n-          item_class(typms, traits, items, m_ctor, m_dtor) => {\n+          item_class(struct_def, typms) => {\n             let resulting_optional_constructor;\n-            match m_ctor {\n+            match struct_def.ctor {\n                 none => {\n                     resulting_optional_constructor = none;\n                 }\n@@ -260,18 +260,20 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                     });\n                 }\n             }\n-            let dtor = do option::map(m_dtor) |dtor| {\n+            let dtor = do option::map(struct_def.dtor) |dtor| {\n                 let dtor_body = fld.fold_block(dtor.node.body);\n                 let dtor_id   = fld.new_id(dtor.node.id);\n                 {node: {body: dtor_body,\n                         id: dtor_id with dtor.node}\n                     with dtor}};\n-              item_class(\n-                  /* FIXME (#2543) */ copy typms,\n-                  vec::map(traits, |p| fold_trait_ref(p, fld)),\n-                  vec::map(items, |x| fld.fold_class_item(x)),\n-                  resulting_optional_constructor,\n-                  dtor)\n+              item_class({\n+                  traits: vec::map(struct_def.traits,\n+                                   |p| fold_trait_ref(p, fld)),\n+                  members: vec::map(struct_def.members,\n+                                    |x| fld.fold_class_item(x)),\n+                  ctor: resulting_optional_constructor,\n+                  dtor: dtor},\n+                  /* FIXME (#2543) */ copy typms)\n           }\n           item_impl(tps, ifce, ty, methods) => {\n               item_impl(fold_ty_params(tps, fld),"}, {"sha": "52a93a6036129b00c50060295485b57e761db997", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -2581,18 +2581,28 @@ class parser {\n         match the_ctor {\n           some((ct_d, ct_attrs, ct_b, ct_s)) => {\n             (class_name,\n-             item_class(ty_params, traits, ms, some({\n+             item_class({\n+                traits: traits,\n+                members: ms,\n+                ctor: some({\n                  node: {id: ctor_id,\n                         attrs: ct_attrs,\n                         self_id: self.get_id(),\n                         dec: ct_d,\n                         body: ct_b},\n-                 span: ct_s}), actual_dtor),\n+                 span: ct_s}),\n+                dtor: actual_dtor\n+             }, ty_params),\n              none)\n           }\n           none => {\n             (class_name,\n-             item_class(ty_params, traits, ms, none, actual_dtor),\n+             item_class({\n+                    traits: traits,\n+                    members: ms,\n+                    ctor: none,\n+                    dtor: actual_dtor\n+             }, ty_params),\n              none)\n           }\n         }"}, {"sha": "c4bb680c220a1240230641d8515bdfbaf5e23ad7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -530,18 +530,18 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_class(tps, traits, items, m_ctor, m_dtor) => {\n+      ast::item_class(struct_def, tps) => {\n           head(s, ~\"class\");\n           word_nbsp(s, *item.ident);\n           print_type_params(s, tps);\n-          if vec::len(traits) != 0u {\n+          if vec::len(struct_def.traits) != 0u {\n               word_space(s, ~\":\");\n-              commasep(s, inconsistent, traits, |s, p|\n+              commasep(s, inconsistent, struct_def.traits, |s, p|\n                   print_path(s, p.path, false));\n           }\n           bopen(s);\n           hardbreak_if_not_bol(s);\n-          do option::iter(m_ctor) |ctor| {\n+          do option::iter(struct_def.ctor) |ctor| {\n             maybe_print_comment(s, ctor.span.lo);\n             print_outer_attributes(s, ctor.node.attrs);\n             // Doesn't call head because there shouldn't be a space after new.\n@@ -553,14 +553,14 @@ fn print_item(s: ps, &&item: @ast::item) {\n             space(s.s);\n             print_block(s, ctor.node.body);\n           }\n-          do option::iter(m_dtor) |dtor| {\n+          do option::iter(struct_def.dtor) |dtor| {\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, dtor.span.lo);\n             print_outer_attributes(s, dtor.node.attrs);\n             head(s, ~\"drop\");\n             print_block(s, dtor.node.body);\n           }\n-          for items.each |ci| {\n+          for struct_def.members.each |ci| {\n                   /*\n                      FIXME (#1893): collect all private items and print\n                      them in a single \"priv\" section"}, {"sha": "282f9abe6dcf3daa47f8f349aaf9cd3ea8261b8b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -152,17 +152,17 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             visit_method_helper(m, e, v)\n         }\n       }\n-      item_class(tps, traits, members, m_ctor, m_dtor) => {\n+      item_class(struct_def, tps) => {\n           v.visit_ty_params(tps, e, v);\n-          for members.each |m| {\n+          for struct_def.members.each |m| {\n              v.visit_class_item(m, e, v);\n           }\n-          for traits.each |p| { visit_path(p.path, e, v); }\n-          do option::iter(m_ctor) |ctor| {\n+          for struct_def.traits.each |p| { visit_path(p.path, e, v); }\n+          do option::iter(struct_def.ctor) |ctor| {\n             visit_class_ctor_helper(ctor, i.ident, tps,\n                                     ast_util::local_def(i.id), e, v);\n           };\n-          do option::iter(m_dtor) |dtor| {\n+          do option::iter(struct_def.dtor) |dtor| {\n             visit_class_dtor_helper(dtor, tps,\n                                     ast_util::local_def(i.id), e, v)\n           };"}, {"sha": "8d31bd333a14624a3f3a3196fa61b65d6cf6579e", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -196,7 +196,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n           }\n-          item_class(_, _, items, m_ctor, m_dtor) => {\n+          item_class(struct_def, _) => {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n                 encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n@@ -205,7 +205,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                 // class and for its ctor\n                 add_to_index(ebml_w, path, index, it.ident);\n \n-                match m_ctor {\n+                match struct_def.ctor {\n                     none => {\n                         // Nothing to do.\n                     }\n@@ -215,7 +215,8 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                     }\n                 }\n \n-                encode_class_item_paths(ebml_w, items,\n+                encode_class_item_paths(ebml_w,\n+                                        struct_def.members,\n                                         vec::append_one(path, it.ident),\n                                         index);\n             }\n@@ -700,15 +701,15 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps, traits, items, ctor, m_dtor) => {\n+      item_class(struct_def, tps) => {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n         let idx = encode_info_for_class(ecx, ebml_w, item.id, path, tps,\n-                                          items, index);\n+                                        struct_def.members, index);\n         /* Encode the dtor */\n-        do option::iter(m_dtor) |dtor| {\n+        do option::iter(struct_def.dtor) |dtor| {\n             vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_fn(ecx, ebml_w, dtor.node.id, @(*item.ident\n                              + ~\"_dtor\"), path, if tps.len() > 0u {\n@@ -723,7 +724,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n \n-        match ctor {\n+        match struct_def.ctor {\n             none => encode_family(ebml_w, 'S'),\n             some(_) => encode_family(ebml_w, 'C')\n         }\n@@ -733,12 +734,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n-        for traits.each |t| {\n+        for struct_def.traits.each |t| {\n            encode_trait_ref(ebml_w, ecx, t);\n         }\n         /* Encode the dtor */\n         /* Encode id for dtor */\n-        do option::iter(m_dtor) |dtor| {\n+        do option::iter(struct_def.dtor) |dtor| {\n             do ebml_w.wr_tag(tag_item_dtor) {\n                 encode_def_id(ebml_w, local_def(dtor.node.id));\n             }\n@@ -747,7 +748,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        let (fs,ms) = ast_util::split_class_items(items);\n+        let (fs,ms) = ast_util::split_class_items(struct_def.members);\n         for fs.each |f| {\n            ebml_w.start_tag(tag_item_field);\n            encode_visibility(ebml_w, f.vis);\n@@ -783,7 +784,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.end_tag();\n \n         /* Encode the constructor */\n-        for ctor.each |ctor| {\n+        for struct_def.ctor.each |ctor| {\n             debug!{\"encoding info for ctor %s %d\", *item.ident,\n                    ctor.node.id};\n             vec::push(*index, {"}, {"sha": "a2bd128002120113c19bf20755c73b43b2f9f2e1", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -984,13 +984,13 @@ class Resolver {\n                                                          visitor);\n                 }\n             }\n-            item_class(_, _, class_members, optional_ctor, _) => {\n+            item_class(struct_definition, _) => {\n               let (name_bindings, new_parent) = self.add_child(atom, parent,\n                                               ~[ValueNS, TypeNS], sp);\n \n                 (*name_bindings).define_type(def_ty(local_def(item.id)), sp);\n \n-                match optional_ctor {\n+                match struct_definition.ctor {\n                     none => {\n                         // Nothing to do.\n                     }\n@@ -1008,7 +1008,7 @@ class Resolver {\n                 // bindings.\n \n                 let mut method_infos = ~[];\n-                for class_members.each |class_member| {\n+                for struct_definition.members.each |class_member| {\n                     match class_member.node {\n                         class_method(method) => {\n                             // XXX: Combine with impl method code below.\n@@ -1037,7 +1037,7 @@ class Resolver {\n \n                 // Record the def ID of this struct.\n                 self.structs.insert(local_def(item.id),\n-                                    is_some(optional_ctor));\n+                                    is_some(struct_definition.ctor));\n \n                 visit_item(item, new_parent, visitor);\n             }\n@@ -3249,15 +3249,13 @@ class Resolver {\n                 (*self.type_ribs).pop();\n             }\n \n-            item_class(ty_params, traits, class_members,\n-                       optional_constructor, optional_destructor) => {\n-\n+            item_class(struct_def, ty_params) => {\n                 self.resolve_class(item.id,\n                                    @copy ty_params,\n-                                   traits,\n-                                   class_members,\n-                                   optional_constructor,\n-                                   optional_destructor,\n+                                   struct_def.traits,\n+                                   struct_def.members,\n+                                   struct_def.ctor,\n+                                   struct_def.dtor,\n                                    visitor);\n             }\n "}, {"sha": "e5a3a8e4e13900c76164a1dca3070f8b53a0c85d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -4899,25 +4899,25 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n-      ast::item_class(tps, _traits, items, m_ctor, m_dtor) => {\n+      ast::item_class(struct_def, tps) => {\n         if tps.len() == 0u {\n           let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n                          vtables: none,\n                          bounds: @~[]};\n-          do option::iter(m_ctor) |ctor| {\n+          do option::iter(struct_def.ctor) |ctor| {\n             trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n                              get_item_val(ccx, ctor.node.id), psubsts,\n                              ctor.node.id, local_def(item.id), ctor.span);\n           }\n-          do option::iter(m_dtor) |dtor| {\n+          do option::iter(struct_def.dtor) |dtor| {\n              trans_class_dtor(ccx, *path, dtor.node.body,\n                dtor.node.id, none, none, local_def(item.id));\n           };\n         }\n         // If there are ty params, the ctor will get monomorphized\n \n         // Translate methods\n-        let (_, ms) = ast_util::split_class_items(items);\n+        let (_, ms) = ast_util::split_class_items(struct_def.members);\n         impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n       _ => {/* fall through */ }"}, {"sha": "7bac09e37069895c30553b9c7377e53470e03267", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -94,8 +94,8 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n             method_from_methods(ms, name)\n           }\n           ast_map::node_item(@{node:\n-              ast::item_class(_, _, items, _, _), _}, _) => {\n-            let (_,ms) = split_class_items(items);\n+              ast::item_class(struct_def, _), _}, _) => {\n+            let (_,ms) = split_class_items(struct_def.members);\n             method_from_methods(ms, name)\n           }\n         }"}, {"sha": "8cf4bde575d07a55aa50804820ece221fb9914c2", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -111,22 +111,22 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_class(tps, _traits, items, m_ctor, m_dtor) => {\n-        do option::iter(m_ctor) |ctor| {\n+      item_class(struct_def, tps) => {\n+        do option::iter(struct_def.ctor) |ctor| {\n             cx.rmap.insert(ctor.node.id, ());\n             if tps.len() > 0u || attr::find_inline_attr(ctor.node.attrs)\n                      != attr::ia_none {\n                 traverse_inline_body(cx, ctor.node.body);\n             }\n         }\n-        do option::iter(m_dtor) |dtor| {\n+        do option::iter(struct_def.dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n             if tps.len() > 0u || attr::find_inline_attr(dtor.node.attrs)\n                      != attr::ia_none {\n                 traverse_inline_body(cx, dtor.node.body);\n             }\n         }\n-        for vec::each(items) |item| {\n+        for vec::each(struct_def.members) |item| {\n             match item.node {\n               class_method(m) => {\n                 cx.rmap.insert(m.id, ());\n@@ -214,7 +214,7 @@ fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n         visit_item: |i, cx, v| {\n             visit::visit_item(i, cx, v);\n             match i.node {\n-              item_class(_, _, _, _, some(_)) => {\n+              item_class(struct_def, _) if struct_def.dtor.is_some() => {\n                 traverse_public_item(cx, i);\n               }\n               item_impl(*) => {"}, {"sha": "285e0068f66ee488ff9287d9ecff2764590b1ccf", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -2741,10 +2741,13 @@ fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n fn ty_dtor(cx: ctxt, class_id: def_id) -> option<def_id> {\n     if is_local(class_id) {\n        match cx.items.find(class_id.node) {\n-         some(ast_map::node_item(@{node: ast::item_class(_, _, _, _,\n-                                     some(dtor)), _}, _))\n-             => some(local_def(dtor.node.id)),\n-         _  => none\n+           some(ast_map::node_item(@{\n+               node: ast::item_class({ dtor: some(dtor), _ }, _),\n+               _\n+           }, _)) =>\n+               some(local_def(dtor.node.id)),\n+           _ =>\n+               none\n        }\n     }\n     else {\n@@ -2936,8 +2939,8 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n     match cx.items.find(did.node) {\n        some(ast_map::node_item(i,_)) => {\n          match i.node {\n-                 ast::item_class(_, _, items, _, _) => {\n-               class_field_tys(items)\n+                 ast::item_class(struct_def, _) => {\n+               class_field_tys(struct_def.members)\n            }\n            _ => cx.sess.bug(~\"class ID bound to non-class\")\n          }\n@@ -2990,9 +2993,9 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n         assert is_local(did);\n         match cx.items.find(did.node) {\n           some(ast_map::node_item(@{\n-            node: item_class(_,_,items,_,_), _\n+            node: item_class(struct_def, _), _\n           }, _)) => {\n-            let (_,ms) = split_class_items(items);\n+            let (_,ms) = split_class_items(struct_def.members);\n             vec::map(ms, |m| {name: m.ident, id: m.id,\n                               vis: m.vis})\n           }"}, {"sha": "9dac176c5644cd9dc127875e6b20bcd94faf3a7a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -432,12 +432,12 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n             }\n         }\n       }\n-      ast::item_class(tps, _, members, m_ctor, m_dtor) => {\n+      ast::item_class(struct_def, _) => {\n         let tcx = ccx.tcx;\n         let class_t = {self_ty: ty::node_id_to_type(tcx, it.id),\n                        node_id: it.id};\n \n-        do option::iter(m_ctor) |ctor| {\n+        do option::iter(struct_def.ctor) |ctor| {\n             // typecheck the ctor\n             check_bare_fn(ccx, ctor.node.dec,\n                           ctor.node.body, ctor.node.id,\n@@ -446,7 +446,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n             write_ty_to_tcx(tcx, ctor.node.self_id, class_t.self_ty);\n         }\n \n-        do option::iter(m_dtor) |dtor| {\n+        do option::iter(struct_def.dtor) |dtor| {\n             // typecheck the dtor\n             check_bare_fn(ccx, ast_util::dtor_dec(),\n                           dtor.node.body, dtor.node.id,\n@@ -456,9 +456,11 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         };\n \n         // typecheck the members\n-        for members.each |m| { check_class_member(ccx, class_t, m); }\n+        for struct_def.members.each |m| {\n+            check_class_member(ccx, class_t, m);\n+        }\n         // Check that there's at least one field\n-        let (fields,_) = split_class_items(members);\n+        let (fields,_) = split_class_items(struct_def.members);\n         if fields.len() < 1u {\n             ccx.tcx.sess.span_err(\n                 it.span,\n@@ -747,8 +749,8 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n              rp: rp,\n              raw_ty: fcx.ccx.to_ty(rscope::type_rscope(rp), st)}\n           }\n-          some(ast_map::node_item(@{node: ast::item_class(ts,\n-                                 _,_,_,_), id: class_id, _},_)) => {\n+          some(ast_map::node_item(@{node: ast::item_class(_, ts),\n+                                    id: class_id, _},_)) => {\n               /* If the impl is a class, the self ty is just the class ty\n                  (doing a no-op subst for the ty params; in the next step,\n                  we substitute in fresh vars for them)\n@@ -1720,7 +1722,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 tcx.region_paramd_items.contains_key(class_id.node);\n             match tcx.items.find(class_id.node) {\n                 some(ast_map::node_item(@{\n-                        node: ast::item_class(type_parameters, _, _, _, _),\n+                        node: ast::item_class(_, type_parameters),\n                         _\n                     }, _)) => {\n "}, {"sha": "798c3a2af17ae66eae09f30a6066bd2e58906657", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -163,8 +163,8 @@ class CoherenceChecker {\n                     item_impl(_, associated_traits, _, _) => {\n                         self.check_implementation(item, associated_traits);\n                     }\n-                    item_class(_, associated_traits, _, _, _) => {\n-                        self.check_implementation(item, associated_traits);\n+                    item_class(struct_def, _) => {\n+                        self.check_implementation(item, struct_def.traits);\n                     }\n                     _ => {\n                         // Nothing to do.\n@@ -505,9 +505,9 @@ class CoherenceChecker {\n                     methods: methods\n                 };\n             }\n-            item_class(ty_params, _, class_members, _, _) => {\n+            item_class(struct_def, ty_params) => {\n                 let mut methods = ~[];\n-                for class_members.each |class_member| {\n+                for struct_def.members.each |class_member| {\n                     match class_member.node {\n                         instance_var(*) => {\n                             // Nothing to do."}, {"sha": "c9da4db053136f188f7447b67fb5542889dbf1dd", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deaef48675c34f3a63ded090058dfe6cbe60c3c6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=deaef48675c34f3a63ded090058dfe6cbe60c3c6", "patch": "@@ -162,8 +162,8 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id) {\n             }\n         });\n       }\n-      ast_map::node_item(@{node: ast::item_class(_,_,its,_,_), _}, _) => {\n-        let (_,ms) = split_class_items(its);\n+      ast_map::node_item(@{node: ast::item_class(struct_def, _), _}, _) => {\n+        let (_,ms) = split_class_items(struct_def.members);\n         // All methods need to be stored, since lookup_method\n         // relies on the same method cache for self-calls\n         store_methods::<@ast::method>(ccx, id, ms, |m| {\n@@ -382,13 +382,13 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         // check_methods_against_trait(ccx, tps, rp, selfty, t, cms);\n         // }\n       }\n-      ast::item_class(tps, trait_refs, members, m_ctor, m_dtor) => {\n+      ast::item_class(struct_def, tps) => {\n         // Write the class type\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n \n-        do option::iter(m_ctor) |ctor| {\n+        do option::iter(struct_def.ctor) |ctor| {\n             // Write the ctor type\n             let t_args = ctor.node.dec.inputs.map(\n                 |a| ty_of_arg(ccx, type_rscope(rp), a, none) );\n@@ -411,7 +411,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                                ty: t_ctor});\n         }\n \n-        do option::iter(m_dtor) |dtor| {\n+        do option::iter(struct_def.dtor) |dtor| {\n             // Write the dtor type\n             let t_dtor = ty::mk_fn(\n                 tcx,\n@@ -426,14 +426,14 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         ensure_trait_methods(ccx, it.id);\n \n         // Write the type of each of the members\n-        let (fields, methods) = split_class_items(members);\n+        let (fields, methods) = split_class_items(struct_def.members);\n         for fields.each |f| {\n            convert_field(ccx, rp, tpt.bounds, f);\n         }\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n         let cms = convert_methods(ccx, methods, rp, bounds, selfty);\n-        for trait_refs.each |trait_ref| {\n+        for struct_def.traits.each |trait_ref| {\n             check_methods_against_trait(ccx, tps, rp, selfty, trait_ref, cms);\n             // trait_ref.impl_id represents (class, trait) pair\n             write_ty_to_tcx(tcx, trait_ref.impl_id, tpt.ty);\n@@ -583,7 +583,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_class(tps, _, _, _, _) => {\n+      ast::item_class(_, tps) => {\n           let {bounds,substs} = mk_substs(ccx, tps, rp);\n           let t = ty::mk_class(tcx, local_def(it.id), substs);\n           let tpt = {bounds: bounds, rp: rp, ty: t};"}]}