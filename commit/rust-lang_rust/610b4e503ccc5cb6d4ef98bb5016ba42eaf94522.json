{"sha": "610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "node_id": "C_kwDOAAsO6NoAKDYxMGI0ZTUwM2NjYzVjYjZkNGVmOThiYjUwMTZiYTQyZWFmOTQ1MjI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-11-09T18:00:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-09T18:00:41Z"}, "message": "Rollup merge of #90035 - SparrowLii:rfc2528, r=jackh726\n\nimplement rfc-2528 type_changing-struct-update\n\nThis PR implement rfc2528-type_changing-struct-update.\nThe main change process is as follows:\n1. Move the processing part of `base_expr` into `check_expr_struct_fields` to avoid returning `remaining_fields` (a relatively complex hash table)\n2. Before performing the type consistency check(`check_expr_has_type_or_error`), if the `type_changing_struct_update` feature is set, enter a different processing flow, otherwise keep the original flow\n3. In the case of the same structure definition, check each field in `remaining_fields`. If the field in `base_expr` is not the suptype of the field in `adt_ty`, an error(`FeildMisMatch`) will be reported.\n\nThe MIR part does not need to be changed, because only the items contained in `remaining_fields` will be extracted from `base_expr` when MIR is generated. This means that fields with different types in `base_expr` will not be used\nUpdates #86618\ncc `@nikomatsakis`", "tree": {"sha": "c8db226e573691cc2ffcd379127dc226d48bd564", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8db226e573691cc2ffcd379127dc226d48bd564"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhirdJCRBK7hj4Ov3rIwAA+QgIAALVh0CbJ3o/K5cjSs4Jyc2X\niwiBcGOzF8Q93gVdzsD3/4spQiuKtB/nHKItqKJ6oE48SwS8MvUJDePoTCpehXkO\nL5PE8ya51Oop7EfnkWrNaTLVa06uJQAh7CQHw13SdheSXRKDNJKgChj4cF0qo9s+\nZRmLhA0B1g0+p3xJjpcEL1xYMYISrfadrq2sAvjPhRJ091CDXcBBOt3vlmqgs9iD\nJAXWtNcxTQPkryhU4B/4He77QxaLRstTgW94o5wd+DJl6gMHYbQtg00JGJEDzyA7\n5lTMU7DccfzqZOy8wJipHdVitrSKe8aP/iPsPyOUCs9EodhUhrikOjOx+J2lYnQ=\n=tG3n\n-----END PGP SIGNATURE-----\n", "payload": "tree c8db226e573691cc2ffcd379127dc226d48bd564\nparent fd74c93403c455187c343f3828274824addc9881\nparent 926892ddc0b75b50f5d0a3483d829e501aa8e895\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1636480841 +0100\ncommitter GitHub <noreply@github.com> 1636480841 +0100\n\nRollup merge of #90035 - SparrowLii:rfc2528, r=jackh726\n\nimplement rfc-2528 type_changing-struct-update\n\nThis PR implement rfc2528-type_changing-struct-update.\nThe main change process is as follows:\n1. Move the processing part of `base_expr` into `check_expr_struct_fields` to avoid returning `remaining_fields` (a relatively complex hash table)\n2. Before performing the type consistency check(`check_expr_has_type_or_error`), if the `type_changing_struct_update` feature is set, enter a different processing flow, otherwise keep the original flow\n3. In the case of the same structure definition, check each field in `remaining_fields`. If the field in `base_expr` is not the suptype of the field in `adt_ty`, an error(`FeildMisMatch`) will be reported.\n\nThe MIR part does not need to be changed, because only the items contained in `remaining_fields` will be extracted from `base_expr` when MIR is generated. This means that fields with different types in `base_expr` will not be used\nUpdates #86618\ncc `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "html_url": "https://github.com/rust-lang/rust/commit/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd74c93403c455187c343f3828274824addc9881", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd74c93403c455187c343f3828274824addc9881", "html_url": "https://github.com/rust-lang/rust/commit/fd74c93403c455187c343f3828274824addc9881"}, {"sha": "926892ddc0b75b50f5d0a3483d829e501aa8e895", "url": "https://api.github.com/repos/rust-lang/rust/commits/926892ddc0b75b50f5d0a3483d829e501aa8e895", "html_url": "https://github.com/rust-lang/rust/commit/926892ddc0b75b50f5d0a3483d829e501aa8e895"}], "stats": {"total": 382, "additions": 328, "deletions": 54}, "files": [{"sha": "b14a69892657bcb7bce9c32efc9c9314f5df4b73", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -42,6 +42,7 @@ pub enum TypeError<'tcx> {\n     TupleSize(ExpectedFound<usize>),\n     FixedArraySize(ExpectedFound<u64>),\n     ArgCount,\n+    FieldMisMatch(Symbol, Symbol),\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n     RegionsInsufficientlyPolymorphic(BoundRegionKind, Region<'tcx>),\n@@ -134,6 +135,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 pluralize!(values.found)\n             ),\n             ArgCount => write!(f, \"incorrect number of function parameters\"),\n+            FieldMisMatch(adt, field) => write!(f, \"field type mismatch: {}.{}\", adt, field),\n             RegionsDoesNotOutlive(..) => write!(f, \"lifetime mismatch\"),\n             RegionsInsufficientlyPolymorphic(br, _) => write!(\n                 f,\n@@ -224,6 +226,7 @@ impl<'tcx> TypeError<'tcx> {\n             | ArgumentMutability(_)\n             | TupleSize(_)\n             | ArgCount\n+            | FieldMisMatch(..)\n             | RegionsDoesNotOutlive(..)\n             | RegionsInsufficientlyPolymorphic(..)\n             | RegionsOverlyPolymorphic(..)"}, {"sha": "0f8e80806e31e430edc9dc4ff13fc80fb94b4489", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -602,6 +602,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             TupleSize(x) => TupleSize(x),\n             FixedArraySize(x) => FixedArraySize(x),\n             ArgCount => ArgCount,\n+            FieldMisMatch(x, y) => FieldMisMatch(x, y),\n             RegionsDoesNotOutlive(a, b) => {\n                 return tcx.lift((a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b));\n             }"}, {"sha": "a9c0b65a0981ee5f26372aef342ceb82dbd634e4", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 119, "deletions": 40, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -34,12 +34,16 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n+use rustc_middle::ty::error::TypeError::{FieldMisMatch, Sorts};\n+use rustc_middle::ty::relate::expected_found_bool;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n+use rustc_session::parse::feature_err;\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -1283,49 +1287,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .emit_err(StructExprNonExhaustive { span: expr.span, what: adt.variant_descr() });\n         }\n \n-        let error_happened = self.check_expr_struct_fields(\n+        self.check_expr_struct_fields(\n             adt_ty,\n             expected,\n             expr.hir_id,\n             qpath.span(),\n             variant,\n             fields,\n-            base_expr.is_none(),\n+            base_expr,\n             expr.span,\n         );\n-        if let Some(base_expr) = base_expr {\n-            // If check_expr_struct_fields hit an error, do not attempt to populate\n-            // the fields with the base_expr. This could cause us to hit errors later\n-            // when certain fields are assumed to exist that in fact do not.\n-            if !error_happened {\n-                self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {});\n-                match adt_ty.kind() {\n-                    ty::Adt(adt, substs) if adt.is_struct() => {\n-                        let fru_field_types = adt\n-                            .non_enum_variant()\n-                            .fields\n-                            .iter()\n-                            .map(|f| {\n-                                self.normalize_associated_types_in(\n-                                    expr.span,\n-                                    f.ty(self.tcx, substs),\n-                                )\n-                            })\n-                            .collect();\n-\n-                        self.typeck_results\n-                            .borrow_mut()\n-                            .fru_field_types_mut()\n-                            .insert(expr.hir_id, fru_field_types);\n-                    }\n-                    _ => {\n-                        self.tcx\n-                            .sess\n-                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n-                    }\n-                }\n-            }\n-        }\n+\n         self.require_type_is_sized(adt_ty, expr.span, traits::StructInitializerSized);\n         adt_ty\n     }\n@@ -1338,9 +1310,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         variant: &'tcx ty::VariantDef,\n         ast_fields: &'tcx [hir::ExprField<'tcx>],\n-        check_completeness: bool,\n+        base_expr: &'tcx Option<&'tcx hir::Expr<'tcx>>,\n         expr_span: Span,\n-    ) -> bool {\n+    ) {\n         let tcx = self.tcx;\n \n         let adt_ty_hint = self\n@@ -1415,7 +1387,116 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 )\n                 .emit();\n             }\n-        } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n+        }\n+\n+        // If check_expr_struct_fields hit an error, do not attempt to populate\n+        // the fields with the base_expr. This could cause us to hit errors later\n+        // when certain fields are assumed to exist that in fact do not.\n+        if error_happened {\n+            return;\n+        }\n+\n+        if let Some(base_expr) = base_expr {\n+            // FIXME: We are currently creating two branches here in order to maintain\n+            // consistency. But they should be merged as much as possible.\n+            let fru_tys = if self.tcx.features().type_changing_struct_update {\n+                let base_ty = self.check_expr(base_expr);\n+                match adt_ty.kind() {\n+                    ty::Adt(adt, substs) if adt.is_struct() => {\n+                        match base_ty.kind() {\n+                            ty::Adt(base_adt, base_subs) if adt == base_adt => {\n+                                variant\n+                                    .fields\n+                                    .iter()\n+                                    .map(|f| {\n+                                        let fru_ty = self.normalize_associated_types_in(\n+                                            expr_span,\n+                                            self.field_ty(base_expr.span, f, base_subs),\n+                                        );\n+                                        let ident = self.tcx.adjust_ident(f.ident, variant.def_id);\n+                                        if let Some(_) = remaining_fields.remove(&ident) {\n+                                            let target_ty =\n+                                                self.field_ty(base_expr.span, f, substs);\n+                                            let cause = self.misc(base_expr.span);\n+                                            match self\n+                                                .at(&cause, self.param_env)\n+                                                .sup(target_ty, fru_ty)\n+                                            {\n+                                                Ok(InferOk { obligations, value: () }) => {\n+                                                    self.register_predicates(obligations)\n+                                                }\n+                                                // FIXME: Need better diagnostics for `FieldMisMatch` error\n+                                                Err(_) => self\n+                                                    .report_mismatched_types(\n+                                                        &cause,\n+                                                        target_ty,\n+                                                        fru_ty,\n+                                                        FieldMisMatch(\n+                                                            variant.ident.name,\n+                                                            ident.name,\n+                                                        ),\n+                                                    )\n+                                                    .emit(),\n+                                            }\n+                                        }\n+                                        fru_ty\n+                                    })\n+                                    .collect()\n+                            }\n+                            _ => {\n+                                return self\n+                                    .report_mismatched_types(\n+                                        &self.misc(base_expr.span),\n+                                        adt_ty,\n+                                        base_ty,\n+                                        Sorts(expected_found_bool(true, adt_ty, base_ty)),\n+                                    )\n+                                    .emit();\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        return self\n+                            .tcx\n+                            .sess\n+                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n+                    }\n+                }\n+            } else {\n+                self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {\n+                    let base_ty = self.check_expr(base_expr);\n+                    let same_adt = match (adt_ty.kind(), base_ty.kind()) {\n+                        (ty::Adt(adt, _), ty::Adt(base_adt, _)) if adt == base_adt => true,\n+                        _ => false,\n+                    };\n+                    if self.tcx.sess.is_nightly_build() && same_adt {\n+                        feature_err(\n+                            &self.tcx.sess.parse_sess,\n+                            sym::type_changing_struct_update,\n+                            base_expr.span,\n+                            \"type changing struct updating is experimental\",\n+                        )\n+                        .emit();\n+                    }\n+                });\n+                match adt_ty.kind() {\n+                    ty::Adt(adt, substs) if adt.is_struct() => variant\n+                        .fields\n+                        .iter()\n+                        .map(|f| {\n+                            self.normalize_associated_types_in(expr_span, f.ty(self.tcx, substs))\n+                        })\n+                        .collect(),\n+                    _ => {\n+                        return self\n+                            .tcx\n+                            .sess\n+                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n+                    }\n+                }\n+            };\n+            self.typeck_results.borrow_mut().fru_field_types_mut().insert(expr_id, fru_tys);\n+        } else if kind_name != \"union\" && !remaining_fields.is_empty() {\n             let inaccessible_remaining_fields = remaining_fields.iter().any(|(_, (_, field))| {\n                 !field.vis.is_accessible_from(tcx.parent_module(expr_id).to_def_id(), tcx)\n             });\n@@ -1426,8 +1507,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.report_missing_fields(adt_ty, span, remaining_fields);\n             }\n         }\n-\n-        error_happened\n     }\n \n     fn check_struct_fields_on_error("}, {"sha": "9909cf35b5b51215b64f389a1239025cdc7283db", "filename": "src/doc/unstable-book/src/language-features/type-changing-struct-update.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-changing-struct-update.md", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-changing-struct-update.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-changing-struct-update.md?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -0,0 +1,33 @@\n+# `type_changing_struct_update`\n+\n+The tracking issue for this feature is: [#86555]\n+\n+[#86555]: https://github.com/rust-lang/rust/issues/86555\n+\n+------------------------\n+\n+This implements [RFC2528]. When turned on, you can create instances of the same struct\n+that have different generic type or lifetime parameters.\n+\n+[RFC2528]: https://github.com/rust-lang/rfcs/blob/master/text/2528-type-changing-struct-update-syntax.md\n+\n+```rust\n+#![allow(unused_variables, dead_code)]\n+#![feature(type_changing_struct_update)]\n+\n+fn main () {\n+    struct Foo<T, U> {\n+        field1: T,\n+        field2: U,\n+    }\n+\n+    let base: Foo<String, i32> = Foo {\n+        field1: String::from(\"hello\"),\n+        field2: 1234,\n+    };\n+    let updated: Foo<f64, i32> = Foo {\n+        field1: 3.14,\n+        ..base\n+    };\n+}\n+```"}, {"sha": "9934fe6816430e4d64403efe9459f14a291575ce", "filename": "src/test/ui/feature-gates/feature-gate-type_changing_struct_update.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd74c93403c455187c343f3828274824addc9881/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_changing_struct_update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd74c93403c455187c343f3828274824addc9881/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_changing_struct_update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_changing_struct_update.stderr?ref=fd74c93403c455187c343f3828274824addc9881", "patch": "@@ -1,12 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_changing_struct_update.rs:20:11\n-   |\n-LL |         ..m1\n-   |           ^^ expected struct `State2`, found struct `State1`\n-   |\n-   = note: expected struct `Machine<State2>`\n-              found struct `Machine<State1>`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "1e8b99ba5647a1bcedbed27fc508a0ed0f17d64f", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/feature-gate.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.rs?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -1,3 +1,5 @@\n+// gate-test-type_changing_struct_update\n+\n #[derive(Debug)]\n struct Machine<S> {\n     state: S,\n@@ -17,9 +19,10 @@ fn update_to_state2() {\n     };\n     let m2: Machine<State2> = Machine {\n         state: State2,\n-        ..m1 //~ ERROR mismatched types\n+        ..m1\n+        //~^ ERROR type changing struct updating is experimental [E0658]\n+        //~| ERROR mismatched types [E0308]\n     };\n-    // FIXME: this should trigger feature gate\n     assert_eq!(State2, m2.state);\n }\n ", "previous_filename": "src/test/ui/feature-gates/feature-gate-type_changing_struct_update.rs"}, {"sha": "2217b8c049863e1c00389f75911005aca059e461", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/feature-gate.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ffeature-gate.stderr?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -0,0 +1,22 @@\n+error[E0658]: type changing struct updating is experimental\n+  --> $DIR/feature-gate.rs:22:11\n+   |\n+LL |         ..m1\n+   |           ^^\n+   |\n+   = note: see issue #86555 <https://github.com/rust-lang/rust/issues/86555> for more information\n+   = help: add `#![feature(type_changing_struct_update)]` to the crate attributes to enable\n+\n+error[E0308]: mismatched types\n+  --> $DIR/feature-gate.rs:22:11\n+   |\n+LL |         ..m1\n+   |           ^^ expected struct `State2`, found struct `State1`\n+   |\n+   = note: expected struct `Machine<State2>`\n+              found struct `Machine<State1>`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0658.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "df2fef55dd2d869a920df2e0d7630b0b9e74cd4b", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/lifetime-update.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Flifetime-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Flifetime-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Flifetime-update.rs?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -0,0 +1,43 @@\n+#![feature(type_changing_struct_update)]\n+#![allow(incomplete_features)]\n+\n+#[derive(Clone)]\n+struct Machine<'a, S> {\n+    state: S,\n+    lt_str: &'a str,\n+    common_field: i32,\n+}\n+\n+#[derive(Clone)]\n+struct State1;\n+#[derive(Clone)]\n+struct State2;\n+\n+fn update_to_state2() {\n+    let s = String::from(\"hello\");\n+    let m1: Machine<State1> = Machine {\n+        state: State1,\n+        lt_str: &s,\n+                //~^ ERROR `s` does not live long enough [E0597]\n+                // FIXME: The error here actually comes from line 34. The\n+                // span of the error message should be corrected to line 34\n+        common_field: 2,\n+    };\n+    // update lifetime\n+    let m3: Machine<'static, State1> = Machine {\n+        lt_str: \"hello, too\",\n+        ..m1.clone()\n+    };\n+    // update lifetime and type\n+    let m4: Machine<'static, State2> = Machine {\n+        state: State2,\n+        lt_str: \"hello, again\",\n+        ..m1.clone()\n+    };\n+    // updating to `static should fail.\n+    let m2: Machine<'static, State1> = Machine {\n+        ..m1\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "5f93ad6e0279e969d569f7ae4ce6c7ac8815f98b", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/lifetime-update.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Flifetime-update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Flifetime-update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Flifetime-update.stderr?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `s` does not live long enough\n+  --> $DIR/lifetime-update.rs:20:17\n+   |\n+LL |         lt_str: &s,\n+   |                 ^^ borrowed value does not live long enough\n+...\n+LL |     let m2: Machine<'static, State1> = Machine {\n+   |             ------------------------ type annotation requires that `s` is borrowed for `'static`\n+...\n+LL | }\n+   | - `s` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "d8b1396a692a7c6b338357b1a12ee4df55363ef9", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/type-generic-update.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -0,0 +1,57 @@\n+#![feature(type_changing_struct_update)]\n+#![allow(incomplete_features)]\n+\n+struct Machine<'a, S, M> {\n+    state: S,\n+    message: M,\n+    lt_str: &'a str,\n+    common_field: i32,\n+}\n+\n+struct State1;\n+struct State2;\n+\n+struct Message1;\n+struct Message2;\n+\n+fn update() {\n+    let m1: Machine<State1, Message1> = Machine {\n+        state: State1,\n+        message: Message1,\n+        lt_str: \"hello\",\n+        common_field: 2,\n+    };\n+    // single type update\n+    let m2: Machine<State2, Message1> = Machine {\n+        state: State2,\n+        ..m1\n+    };\n+    // multiple type update\n+    let m3: Machine<State2, Message2> = Machine {\n+        state: State2,\n+        message: Message2,\n+        ..m1\n+    };\n+}\n+\n+fn fail_update() {\n+    let m1: Machine<f64, f64> = Machine {\n+        state: 3.2,\n+        message: 6.4,\n+        lt_str: \"hello\",\n+        common_field: 2,\n+    };\n+    // single type update fail\n+    let m2: Machine<i32, f64> = Machine {\n+        ..m1\n+        //~^ ERROR mismatched types [E0308]\n+    };\n+    // multiple type update fail\n+    let m3 = Machine::<i32, i32> {\n+        ..m1\n+        //~^ ERROR mismatched types [E0308]\n+        //~| ERROR mismatched types [E0308]\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "fa8d6ee23d5ec86198e4976ee238b8518aa59b49", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/type-generic-update.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/610b4e503ccc5cb6d4ef98bb5016ba42eaf94522/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr?ref=610b4e503ccc5cb6d4ef98bb5016ba42eaf94522", "patch": "@@ -0,0 +1,30 @@\n+error[E0308]: mismatched types\n+  --> $DIR/type-generic-update.rs:46:11\n+   |\n+LL |         ..m1\n+   |           ^^ field type mismatch: Machine.state\n+   |\n+   = note: expected type `i32`\n+              found type `f64`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-generic-update.rs:51:11\n+   |\n+LL |         ..m1\n+   |           ^^ field type mismatch: Machine.state\n+   |\n+   = note: expected type `i32`\n+              found type `f64`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-generic-update.rs:51:11\n+   |\n+LL |         ..m1\n+   |           ^^ field type mismatch: Machine.message\n+   |\n+   = note: expected type `i32`\n+              found type `f64`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}