{"sha": "627486af15d222bcba336b12ea92a05237cc9ab1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNzQ4NmFmMTVkMjIyYmNiYTMzNmIxMmVhOTJhMDUyMzdjYzlhYjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-02T17:25:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-02T17:25:58Z"}, "message": "Auto merge of #61278 - RalfJung:miri-tag-allocations, r=oli-obk\n\nMiri: give machine the chance to tag all allocations\n\nr? @oli-obk\n\nThe Miri side of this is at https://github.com/rust-lang/rust/pull/61278.", "tree": {"sha": "1db4ce378bb5e4c850fcf5fa2a608208b30359b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1db4ce378bb5e4c850fcf5fa2a608208b30359b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/627486af15d222bcba336b12ea92a05237cc9ab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/627486af15d222bcba336b12ea92a05237cc9ab1", "html_url": "https://github.com/rust-lang/rust/commit/627486af15d222bcba336b12ea92a05237cc9ab1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/627486af15d222bcba336b12ea92a05237cc9ab1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d461555e443a07bc75564b8322dc461efe7cea7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d461555e443a07bc75564b8322dc461efe7cea7c", "html_url": "https://github.com/rust-lang/rust/commit/d461555e443a07bc75564b8322dc461efe7cea7c"}, {"sha": "823ffaa834bde2fb0daabd010c369aae561fb765", "url": "https://api.github.com/repos/rust-lang/rust/commits/823ffaa834bde2fb0daabd010c369aae561fb765", "html_url": "https://github.com/rust-lang/rust/commit/823ffaa834bde2fb0daabd010c369aae561fb765"}], "stats": {"total": 454, "additions": 218, "deletions": 236}, "files": [{"sha": "215d4295e44e1ed523bfe00a07aff0b8a9c215ad", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -111,9 +111,10 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n // For Tag=() and no extra state, we have is a trivial implementation.\n impl AllocationExtra<()> for () { }\n \n-impl<Tag, Extra> Allocation<Tag, Extra> {\n+// The constructors are all without extra; the extra gets added by a machine hook later.\n+impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n-    pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align, extra: Extra) -> Self {\n+    pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n         let undef_mask = UndefMask::new(Size::from_bytes(bytes.len() as u64), true);\n         Self {\n@@ -122,23 +123,23 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n             undef_mask,\n             align,\n             mutability: Mutability::Immutable,\n-            extra,\n+            extra: (),\n         }\n     }\n \n-    pub fn from_byte_aligned_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, extra: Extra) -> Self {\n-        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap(), extra)\n+    pub fn from_byte_aligned_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>) -> Self {\n+        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap())\n     }\n \n-    pub fn undef(size: Size, align: Align, extra: Extra) -> Self {\n+    pub fn undef(size: Size, align: Align) -> Self {\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n             align,\n             mutability: Mutability::Mutable,\n-            extra,\n+            extra: (),\n         }\n     }\n }"}, {"sha": "4aa83a79d52b8bef5a187e14679eefde153417a2", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -116,13 +116,6 @@ impl<'tcx> Pointer<()> {\n     {\n         Pointer::new_with_tag(self.alloc_id, self.offset, tag)\n     }\n-\n-    #[inline(always)]\n-    pub fn with_default_tag<Tag>(self) -> Pointer<Tag>\n-        where Tag: Default\n-    {\n-        self.with_tag(Tag::default())\n-    }\n }\n \n impl<'tcx, Tag> Pointer<Tag> {"}, {"sha": "b8d6c1224463128f861704503c083f0756c4de99", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -138,23 +138,22 @@ impl<'tcx> Scalar<()> {\n                          \"Scalar value {:#x} exceeds size of {} bytes\", data, size);\n     }\n \n+    /// Tag this scalar with `new_tag` if it is a pointer, leave it unchanged otherwise.\n+    ///\n+    /// Used by `MemPlace::replace_tag`.\n     #[inline]\n     pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n             Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         }\n     }\n-\n-    #[inline(always)]\n-    pub fn with_default_tag<Tag>(self) -> Scalar<Tag>\n-        where Tag: Default\n-    {\n-        self.with_tag(Tag::default())\n-    }\n }\n \n impl<'tcx, Tag> Scalar<Tag> {\n+    /// Erase the tag from the scalar, if any.\n+    ///\n+    /// Used by error reporting code to avoid having the error type depend on `Tag`.\n     #[inline]\n     pub fn erase_tag(self) -> Scalar {\n         match self {\n@@ -476,24 +475,10 @@ impl<Tag> fmt::Display for ScalarMaybeUndef<Tag> {\n     }\n }\n \n-impl<'tcx> ScalarMaybeUndef<()> {\n-    #[inline]\n-    pub fn with_tag<Tag>(self, new_tag: Tag) -> ScalarMaybeUndef<Tag> {\n-        match self {\n-            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.with_tag(new_tag)),\n-            ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn with_default_tag<Tag>(self) -> ScalarMaybeUndef<Tag>\n-        where Tag: Default\n-    {\n-        self.with_tag(Tag::default())\n-    }\n-}\n-\n impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n+    /// Erase the tag from the scalar, if any.\n+    ///\n+    /// Used by error reporting code to avoid having the error type depend on `Tag`.\n     #[inline]\n     pub fn erase_tag(self) -> ScalarMaybeUndef\n     {"}, {"sha": "85a02220a71068245fa2fd21b0e0988bd4b9a486", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -1149,7 +1149,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Allocates a byte or string literal for `mir::interpret`, read-only\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // create an allocation that just contains these bytes\n-        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes, ());\n+        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n         self.alloc_map.lock().create_memory_alloc(alloc)\n     }"}, {"sha": "dc7aa0f17e88cd20c85f02f8f5bf85716430e589", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, VariantIdx, Size};\n+use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n@@ -117,7 +117,7 @@ fn op_to_const<'tcx>(\n                 ),\n                 Scalar::Raw { .. } => (\n                     ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(\n-                        b\"\" as &[u8], (),\n+                        b\"\" as &[u8],\n                     )),\n                     0,\n                 ),\n@@ -397,27 +397,27 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     fn find_foreign_static(\n         _def_id: DefId,\n         _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-        _memory_extra: &(),\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n \n     #[inline(always)]\n-    fn adjust_static_allocation<'b>(\n-        alloc: &'b Allocation,\n+    fn tag_allocation<'b>(\n+        _id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        _kind: Option<MemoryKind<!>>,\n         _memory_extra: &(),\n-    ) -> Cow<'b, Allocation<Self::PointerTag>> {\n-        // We do not use a tag so we can just cheaply forward the reference\n-        Cow::Borrowed(alloc)\n+    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+        // We do not use a tag so we can just cheaply forward the allocation\n+        (alloc, ())\n     }\n \n     #[inline(always)]\n-    fn new_allocation(\n-        _size: Size,\n-        _extra: &Self::MemoryExtra,\n-        _kind: MemoryKind<!>,\n-    ) -> (Self::AllocExtra, Self::PointerTag) {\n-        ((), ())\n+    fn tag_static_base_pointer(\n+        _id: AllocId,\n+        _memory_extra: &(),\n+    ) -> Self::PointerTag {\n+        ()\n     }\n \n     fn box_alloc("}, {"sha": "a5be55d16d488b7049ce0c5239d2804988b3db99", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -30,13 +30,13 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n     let lit = match *lit {\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n-            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes(), ());\n+            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes());\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n         },\n         LitKind::Err(ref s) => {\n             let s = s.as_str();\n-            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes(), ());\n+            let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes());\n             let allocation = tcx.intern_const_alloc(allocation);\n             return Ok(tcx.mk_const(ty::Const {\n                 val: ConstValue::Slice{ data: allocation, start: 0, end: s.len() },"}, {"sha": "f1e23655741fc2ae80394720f59190d5fef29e8e", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                             def_id,\n                             substs,\n                         ).ok_or_else(|| InterpError::TooGeneric.into());\n-                        let fn_ptr = self.memory.create_fn_alloc(instance?).with_default_tag();\n+                        let fn_ptr = self.memory.create_fn_alloc(instance?);\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     _ => bug!(\"reify fn pointer on {:?}\", src.layout.ty),\n@@ -115,7 +115,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                             substs,\n                             ty::ClosureKind::FnOnce,\n                         );\n-                        let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n+                        let fn_ptr = self.memory.create_fn_alloc(instance);\n                         let val = Immediate::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n                         self.write_immediate(val, dest)?;\n                     }"}, {"sha": "a6153bf055d600a5223ae3c0cf2e6551d0afe6e8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -15,7 +15,7 @@ use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n     ErrorHandled,\n-    GlobalId, Scalar, FrameInfo, AllocId,\n+    GlobalId, Scalar, Pointer, FrameInfo, AllocId,\n     EvalResult, InterpError,\n     truncate, sign_extend,\n };\n@@ -43,7 +43,10 @@ pub struct InterpretCx<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>>,\n \n     /// A cache for deduplicating vtables\n-    pub(super) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), AllocId>,\n+    pub(super) vtables: FxHashMap<\n+        (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n+        Pointer<M::PointerTag>\n+    >,\n }\n \n /// A stack frame.\n@@ -222,6 +225,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         &mut self.memory\n     }\n \n+    #[inline(always)]\n+    pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n+        self.memory.tag_static_base_pointer(ptr)\n+    }\n+\n     #[inline(always)]\n     pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n         &self.stack\n@@ -360,11 +368,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         }\n     }\n \n-    pub fn str_to_immediate(&mut self, s: &str) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n-        let ptr = self.memory.allocate_static_bytes(s.as_bytes()).with_default_tag();\n-        Ok(Immediate::new_slice(Scalar::Ptr(ptr), s.len() as u64, self))\n-    }\n-\n     /// Returns the actual dynamic size and alignment of the place at the given type.\n     /// Only the \"meta\" (metadata) part of the place matters.\n     /// This can fail to provide an answer for extern types."}, {"sha": "456fc70fc0d1dc9c5df12861943d0081301f3cb4", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -215,7 +215,7 @@ impl Write for AbsolutePathPrinter<'_, '_> {\n pub fn type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let len = path.len();\n-    let alloc = Allocation::from_byte_aligned_bytes(path.into_bytes(), ());\n+    let alloc = Allocation::from_byte_aligned_bytes(path.into_bytes());\n     let alloc = tcx.intern_const_alloc(alloc);\n     tcx.mk_const(ty::Const {\n         val: ConstValue::Slice {"}, {"sha": "fa0750fa82aa98a988207883546634e85b4c7200", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -5,13 +5,13 @@\n use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n-use rustc::hir::{self, def_id::DefId};\n+use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, query::TyCtxtAt, layout::Size};\n+use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    InterpretCx, PlaceTy, MPlaceTy, OpTy, ImmTy, MemoryKind,\n+    InterpretCx, PlaceTy, OpTy, ImmTy, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -65,7 +65,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n-    type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n+    type PointerTag: ::std::fmt::Debug + Copy + Eq + Hash + 'static;\n \n     /// Extra data stored in every call frame.\n     type FrameExtra;\n@@ -90,7 +90,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// The memory kind to use for copied statics -- or None if statics should not be mutated\n     /// and thus any such attempt will cause a `ModifiedStatic` error to be raised.\n     /// Statics are copied under two circumstances: When they are mutated, and when\n-    /// `static_with_default_tag` or `find_foreign_static` (see below) returns an owned allocation\n+    /// `tag_allocation` or `find_foreign_static` (see below) returns an owned allocation\n     /// that is added to the memory so that the work is not done twice.\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n@@ -133,11 +133,12 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// This will only be called once per static and machine; the result is cached in\n     /// the machine memory. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n+    ///\n+    /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n     fn find_foreign_static(\n         def_id: DefId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-        memory_extra: &Self::MemoryExtra,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n@@ -156,36 +157,38 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n-    /// Called to turn an allocation obtained from the `tcx` into one that has\n-    /// the right type for this machine.\n+    /// Called to initialize the \"extra\" state of an allocation and make the pointers\n+    /// it contains (in relocations) tagged.  The way we construct allocations is\n+    /// to always first construct it without extra and then add the extra.\n+    /// This keeps uniform code paths for handling both allocations created by CTFE\n+    /// for statics, and allocations ceated by Miri during evaluation.\n+    ///\n+    /// `kind` is the kind of the allocation being tagged; it can be `None` when\n+    /// it's a static and `STATIC_KIND` is `None`.\n     ///\n     /// This should avoid copying if no work has to be done! If this returns an owned\n     /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n-    fn adjust_static_allocation<'b>(\n-        alloc: &'b Allocation,\n+    ///\n+    /// For static allocations, the tag returned must be the same as the one returned by\n+    /// `tag_static_base_pointer`.\n+    fn tag_allocation<'b>(\n+        id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        kind: Option<MemoryKind<Self::MemoryKinds>>,\n         memory_extra: &Self::MemoryExtra,\n-    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n-\n-    /// Computes the extra state and the tag for a new allocation.\n-    fn new_allocation(\n-        size: Size,\n-        extra: &Self::MemoryExtra,\n-        kind: MemoryKind<Self::MemoryKinds>,\n-    ) -> (Self::AllocExtra, Self::PointerTag);\n-\n-    /// Executed when evaluating the `*` operator: Following a reference.\n-    /// This has the chance to adjust the tag. It should not change anything else!\n-    /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n-    #[inline]\n-    fn tag_dereference(\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n-        place: MPlaceTy<'tcx, Self::PointerTag>,\n-        _mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Scalar<Self::PointerTag>> {\n-        Ok(place.ptr)\n-    }\n+    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n+\n+    /// Return the \"base\" tag for the given static allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation.\n+    ///\n+    /// Be aware that requesting the `Allocation` for that `id` will lead to cycles\n+    /// for cyclic statics!\n+    fn tag_static_base_pointer(\n+        id: AllocId,\n+        memory_extra: &Self::MemoryExtra,\n+    ) -> Self::PointerTag;\n \n     /// Executes a retagging operation\n     #[inline]"}, {"sha": "7db963a89aaef94531433be4dd34fd7816f0ea3c", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 80, "deletions": 53, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -108,32 +108,44 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer {\n-        Pointer::from(self.tcx.alloc_map.lock().create_fn_alloc(instance))\n+    #[inline]\n+    pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n+        ptr.with_tag(M::tag_static_base_pointer(ptr.alloc_id, &self.extra))\n     }\n \n-    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer {\n-        Pointer::from(self.tcx.allocate_bytes(bytes))\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n+        let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n+        self.tag_static_base_pointer(Pointer::from(id))\n     }\n \n-    pub fn allocate_with(\n+    pub fn allocate(\n         &mut self,\n-        alloc: Allocation<M::PointerTag, M::AllocExtra>,\n+        size: Size,\n+        align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> AllocId {\n-        let id = self.tcx.alloc_map.lock().reserve();\n-        self.alloc_map.insert(id, (kind, alloc));\n-        id\n+    ) -> Pointer<M::PointerTag> {\n+        let alloc = Allocation::undef(size, align);\n+        self.allocate_with(alloc, kind)\n     }\n \n-    pub fn allocate(\n+    pub fn allocate_static_bytes(\n         &mut self,\n-        size: Size,\n-        align: Align,\n+        bytes: &[u8],\n+        kind: MemoryKind<M::MemoryKinds>,\n+    ) -> Pointer<M::PointerTag> {\n+        let alloc = Allocation::from_byte_aligned_bytes(bytes);\n+        self.allocate_with(alloc, kind)\n+    }\n+\n+    pub fn allocate_with(\n+        &mut self,\n+        alloc: Allocation,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> Pointer<M::PointerTag> {\n-        let (extra, tag) = M::new_allocation(size, &self.extra, kind);\n-        Pointer::from(self.allocate_with(Allocation::undef(size, align, extra), kind)).with_tag(tag)\n+        let id = self.tcx.alloc_map.lock().reserve();\n+        let (alloc, tag) = M::tag_allocation(id, Cow::Owned(alloc), Some(kind), &self.extra);\n+        self.alloc_map.insert(id, (kind, alloc.into_owned()));\n+        Pointer::from(id).with_tag(tag)\n     }\n \n     pub fn reallocate(\n@@ -305,53 +317,68 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n     /// this machine use the same pointer tag, so it is indirected through\n-    /// `M::static_with_default_tag`.\n+    /// `M::tag_allocation`.\n+    ///\n+    /// Notice that every static has two `AllocId` that will resolve to the same\n+    /// thing here: one maps to `GlobalAlloc::Static`, this is the \"lazy\" ID,\n+    /// and the other one is maps to `GlobalAlloc::Memory`, this is returned by\n+    /// `const_eval_raw` and it is the \"resolved\" ID.\n+    /// The resolved ID is never used by the interpreted progrma, it is hidden.\n+    /// The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n+    /// contains a reference to memory that was created during its evaluation (i.e., not to\n+    /// another static), those inner references only exist in \"resolved\" form.\n     fn get_static_alloc(\n         id: AllocId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         memory_extra: &M::MemoryExtra,\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n-        let def_id = match alloc {\n-            Some(GlobalAlloc::Memory(mem)) => {\n-                // We got tcx memory. Let the machine figure out whether and how to\n-                // turn that into memory with the right pointer tag.\n-                return Ok(M::adjust_static_allocation(mem, memory_extra))\n-            }\n-            Some(GlobalAlloc::Function(..)) => {\n-                return err!(DerefFunctionPointer)\n-            }\n-            Some(GlobalAlloc::Static(did)) => {\n-                did\n-            }\n+        let alloc = match alloc {\n+            Some(GlobalAlloc::Memory(mem)) =>\n+                Cow::Borrowed(mem),\n+            Some(GlobalAlloc::Function(..)) =>\n+                return err!(DerefFunctionPointer),\n             None =>\n                 return err!(DanglingPointerDeref),\n-        };\n-        // We got a \"lazy\" static that has not been computed yet, do some work\n-        trace!(\"static_alloc: Need to compute {:?}\", def_id);\n-        if tcx.is_foreign_item(def_id) {\n-            return M::find_foreign_static(def_id, tcx, memory_extra);\n-        }\n-        let instance = Instance::mono(tcx.tcx, def_id);\n-        let gid = GlobalId {\n-            instance,\n-            promoted: None,\n-        };\n-        // use the raw query here to break validation cycles. Later uses of the static will call the\n-        // full query anyway\n-        tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-            // no need to report anything, the const_eval call takes care of that for statics\n-            assert!(tcx.is_static(def_id));\n-            match err {\n-                ErrorHandled::Reported => InterpError::ReferencedConstant.into(),\n-                ErrorHandled::TooGeneric => InterpError::TooGeneric.into(),\n+            Some(GlobalAlloc::Static(def_id)) => {\n+                // We got a \"lazy\" static that has not been computed yet.\n+                if tcx.is_foreign_item(def_id) {\n+                    trace!(\"static_alloc: foreign item {:?}\", def_id);\n+                    M::find_foreign_static(def_id, tcx)?\n+                } else {\n+                    trace!(\"static_alloc: Need to compute {:?}\", def_id);\n+                    let instance = Instance::mono(tcx.tcx, def_id);\n+                    let gid = GlobalId {\n+                        instance,\n+                        promoted: None,\n+                    };\n+                    // use the raw query here to break validation cycles. Later uses of the static\n+                    // will call the full query anyway\n+                    let raw_const = tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid))\n+                        .map_err(|err| {\n+                            // no need to report anything, the const_eval call takes care of that\n+                            // for statics\n+                            assert!(tcx.is_static(def_id));\n+                            match err {\n+                                ErrorHandled::Reported => InterpError::ReferencedConstant,\n+                                ErrorHandled::TooGeneric => InterpError::TooGeneric,\n+                            }\n+                        })?;\n+                    // Make sure we use the ID of the resolved memory, not the lazy one!\n+                    let id = raw_const.alloc_id;\n+                    let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n+                    Cow::Borrowed(allocation)\n+                }\n             }\n-        }).map(|raw_const| {\n-            let allocation = tcx.alloc_map.lock().unwrap_memory(raw_const.alloc_id);\n-            // We got tcx memory. Let the machine figure out whether and how to\n-            // turn that into memory with the right pointer tag.\n-            M::adjust_static_allocation(allocation, memory_extra)\n-        })\n+        };\n+        // We got tcx memory. Let the machine figure out whether and how to\n+        // turn that into memory with the right pointer tag.\n+        Ok(M::tag_allocation(\n+            id, // always use the ID we got as input, not the \"hidden\" one.\n+            alloc,\n+            M::STATIC_KIND.map(MemoryKind::Machine),\n+            memory_extra\n+        ).0)\n     }\n \n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {"}, {"sha": "899cc40dc32065f3f4078657e9138bf1ab8a43fe", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 40, "deletions": 60, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -37,16 +37,6 @@ impl<'tcx, Tag> Immediate<Tag> {\n         Immediate::Scalar(ScalarMaybeUndef::Scalar(val))\n     }\n \n-    #[inline]\n-    pub fn erase_tag(self) -> Immediate\n-    {\n-        match self {\n-            Immediate::Scalar(x) => Immediate::Scalar(x.erase_tag()),\n-            Immediate::ScalarPair(x, y) =>\n-                Immediate::ScalarPair(x.erase_tag(), y.erase_tag()),\n-        }\n-    }\n-\n     pub fn new_slice(\n         val: Scalar<Tag>,\n         len: u64,\n@@ -130,15 +120,6 @@ pub enum Operand<Tag=(), Id=AllocId> {\n }\n \n impl<Tag> Operand<Tag> {\n-    #[inline]\n-    pub fn erase_tag(self) -> Operand\n-    {\n-        match self {\n-            Operand::Immediate(x) => Operand::Immediate(x.erase_tag()),\n-            Operand::Indirect(x) => Operand::Indirect(x.erase_tag()),\n-        }\n-    }\n-\n     #[inline]\n     pub fn to_mem_place(self) -> MemPlace<Tag>\n         where Tag: ::std::fmt::Debug\n@@ -209,18 +190,6 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n     }\n }\n \n-impl<'tcx, Tag> OpTy<'tcx, Tag>\n-{\n-    #[inline]\n-    pub fn erase_tag(self) -> OpTy<'tcx>\n-    {\n-        OpTy {\n-            op: self.op.erase_tag(),\n-            layout: self.layout,\n-        }\n-    }\n-}\n-\n // Use the existing layout if given (but sanity check in debug mode),\n // or compute the layout.\n #[inline(always)]\n@@ -537,44 +506,55 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         val: &'tcx ty::Const<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = match val.val {\n-            ConstValue::Param(_) => return err!(TooGeneric),\n-            ConstValue::Infer(_) | ConstValue::Placeholder(_) => bug!(),\n-            ConstValue::ByRef(ptr, alloc) => {\n-                // We rely on mutability being set correctly in that allocation to prevent writes\n-                // where none should happen -- and for `static mut`, we copy on demand anyway.\n-                Operand::Indirect(\n-                    MemPlace::from_ptr(ptr.with_default_tag(), alloc.align)\n-                )\n-            },\n-            ConstValue::Slice { data, start, end } =>\n-                Operand::Immediate(Immediate::ScalarPair(\n-                    Scalar::from(Pointer::new(\n-                        self.tcx.alloc_map.lock().create_memory_alloc(data),\n-                        Size::from_bytes(start as u64),\n-                    )).with_default_tag().into(),\n-                    Scalar::from_uint(\n-                        (end - start) as u64,\n-                        self.tcx.data_layout.pointer_size,\n-                    ).with_default_tag().into(),\n-                )),\n-            ConstValue::Scalar(x) =>\n-                Operand::Immediate(Immediate::Scalar(x.with_default_tag().into())),\n+        let tag_scalar = |scalar| match scalar {\n+            Scalar::Ptr(ptr) => Scalar::Ptr(self.tag_static_base_pointer(ptr)),\n+            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+        };\n+        // Early-return cases.\n+        match val.val {\n+            ConstValue::Param(_) => return err!(TooGeneric), // FIXME(oli-obk): try to monomorphize\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: None,\n                 })?));\n-            },\n-        };\n+            }\n+            _ => {}\n+        }\n+        // Other cases need layout.\n         let layout = from_known_layout(layout, || {\n             self.layout_of(self.monomorphize(val.ty)?)\n         })?;\n-        Ok(OpTy {\n-            op,\n-            layout,\n-        })\n+        let op = match val.val {\n+            ConstValue::ByRef(ptr, _alloc) => {\n+                // We rely on mutability being set correctly in that allocation to prevent writes\n+                // where none should happen.\n+                let ptr = self.tag_static_base_pointer(ptr);\n+                Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n+            },\n+            ConstValue::Scalar(x) =>\n+                Operand::Immediate(Immediate::Scalar(tag_scalar(x).into())),\n+            ConstValue::Slice { data, start, end } => {\n+                // We rely on mutability being set correctly in `data` to prevent writes\n+                // where none should happen.\n+                let ptr = Pointer::new(\n+                    self.tcx.alloc_map.lock().create_memory_alloc(data),\n+                    Size::from_bytes(start as u64), // offset: `start`\n+                );\n+                Operand::Immediate(Immediate::new_slice(\n+                    self.tag_static_base_pointer(ptr).into(),\n+                    (end - start) as u64, // len: `end - start`\n+                    self,\n+                ))\n+            }\n+            ConstValue::Param(..) |\n+            ConstValue::Infer(..) |\n+            ConstValue::Placeholder(..) |\n+            ConstValue::Unevaluated(..) =>\n+                bug!(\"eval_const_to_op: Unexpected ConstValue {:?}\", val),\n+        };\n+        Ok(OpTy { op, layout })\n     }\n \n     /// Read discriminant, return the runtime value as well as the variant index."}, {"sha": "fac9665d968e2a9b7e21d6119ca56c4ca2e081e7", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -5,7 +5,6 @@\n use std::convert::TryFrom;\n use std::hash::Hash;\n \n-use rustc::hir;\n use rustc::mir;\n use rustc::mir::interpret::truncate;\n use rustc::ty::{self, Ty};\n@@ -294,7 +293,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n impl<'a, 'mir, 'tcx, Tag, M> InterpretCx<'a, 'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n-    Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n+    Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n     M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n@@ -325,25 +324,13 @@ where\n \n     // Take an operand, representing a pointer, and dereference it to a place -- that\n     // will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n-    // This calls the \"deref\" machine hook, and counts as a deref as far as\n-    // Stacked Borrows is concerned.\n     pub fn deref_operand(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        let mut place = self.ref_to_mplace(val)?;\n-        // Pointer tag tracking might want to adjust the tag.\n-        let mutbl = match val.layout.ty.sty {\n-            // `builtin_deref` considers boxes immutable, that's useless for our purposes\n-            ty::Ref(_, _, mutbl) => Some(mutbl),\n-            ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n-            ty::RawPtr(_) => None,\n-            _ => bug!(\"Unexpected pointer type {}\", val.layout.ty),\n-        };\n-        place.mplace.ptr = M::tag_dereference(self, place, mutbl)?;\n-        Ok(place)\n+        self.ref_to_mplace(val)\n     }\n \n     /// Offset a pointer to project to a field. Unlike `place_field`, this is always\n@@ -587,18 +574,23 @@ where\n                     promoted: None\n                 };\n                 // Just create a lazy reference, so we can support recursive statics.\n-                // tcx takes are of assigning every static one and only one unique AllocId.\n+                // tcx takes care of assigning every static one and only one unique AllocId.\n                 // When the data here is ever actually used, memory will notice,\n                 // and it knows how to deal with alloc_id that are present in the\n                 // global table but not in its local memory: It calls back into tcx through\n                 // a query, triggering the CTFE machinery to actually turn this lazy reference\n                 // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n                 // this InterpretCx uses another Machine (e.g., in miri).  This is what we\n-                // want!  This way, computing statics works concistently between codegen\n+                // want!  This way, computing statics works consistently between codegen\n                 // and miri: They use the same query to eventually obtain a `ty::Const`\n                 // and use that for further computation.\n-                let alloc = self.tcx.alloc_map.lock().create_static_alloc(cid.instance.def_id());\n-                MPlaceTy::from_aligned_ptr(Pointer::from(alloc).with_default_tag(), layout)\n+                //\n+                // Notice that statics have *two* AllocIds: the lazy one, and the resolved\n+                // one.  Here we make sure that the interpreted program never sees the\n+                // resolved ID.  Also see the doc comment of `Memory::get_static_alloc`.\n+                let alloc_id = self.tcx.alloc_map.lock().create_static_alloc(cid.instance.def_id());\n+                let ptr = self.tag_static_base_pointer(Pointer::from(alloc_id));\n+                MPlaceTy::from_aligned_ptr(ptr, layout)\n             }\n         })\n     }\n@@ -1032,11 +1024,9 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n         assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n+        let ptr = self.tag_static_base_pointer(Pointer::from(raw.alloc_id));\n         let layout = self.layout_of(raw.ty)?;\n-        Ok(MPlaceTy::from_aligned_ptr(\n-            Pointer::new(raw.alloc_id, Size::ZERO).with_default_tag(),\n-            layout,\n-        ))\n+        Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type."}, {"sha": "208bba60bf2f20c89b41fb5f5290761038d1d5dc", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627486af15d222bcba336b12ea92a05237cc9ab1/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=627486af15d222bcba336b12ea92a05237cc9ab1", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             // always use the same vtable for the same (Type, Trait) combination.\n             // That's not what happens in rustc, but emulating per-crate deduplication\n             // does not sound like it actually makes anything any better.\n-            return Ok(Pointer::from(vtable).with_default_tag());\n+            return Ok(vtable);\n         }\n \n         let methods = if let Some(poly_trait_ref) = poly_trait_ref {\n@@ -56,7 +56,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         let tcx = &*self.tcx;\n \n         let drop = crate::monomorphize::resolve_drop_in_place(*tcx, ty);\n-        let drop = self.memory.create_fn_alloc(drop).with_default_tag();\n+        let drop = self.memory.create_fn_alloc(drop);\n         // no need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n@@ -83,7 +83,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     def_id,\n                     substs,\n                 ).ok_or_else(|| InterpError::TooGeneric)?;\n-                let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n+                let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory\n                     .get_mut(method_ptr.alloc_id)?\n@@ -92,7 +92,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         }\n \n         self.memory.mark_immutable(vtable.alloc_id)?;\n-        assert!(self.vtables.insert((ty, poly_trait_ref), vtable.alloc_id).is_none());\n+        assert!(self.vtables.insert((ty, poly_trait_ref), vtable).is_none());\n \n         Ok(vtable)\n     }"}]}