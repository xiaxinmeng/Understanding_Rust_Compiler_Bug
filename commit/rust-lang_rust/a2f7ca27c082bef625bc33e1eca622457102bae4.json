{"sha": "a2f7ca27c082bef625bc33e1eca622457102bae4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZjdjYTI3YzA4MmJlZjYyNWJjMzNlMWVjYTYyMjQ1NzEwMmJhZTQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-23T13:06:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-23T13:06:40Z"}, "message": "Merge pull request #3678 from edwin0cheng/refactor-rename\n\nFix rename argument in macro call", "tree": {"sha": "bff240491d11d1bd3ceb011ef9a8606d7a41aa63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bff240491d11d1bd3ceb011ef9a8606d7a41aa63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2f7ca27c082bef625bc33e1eca622457102bae4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeLRgCRBK7hj4Ov3rIwAAdHIIAApxWTI5pw1O3p4hIXY7sZDP\nnovpGBBdIfCObIazh1/mRIGkohosEiKKVSvVS3cG3lCVxWeu8HRL9VNVOjOYNIRG\n8ro9wKt13MOrvUOoxJv42lzRd0nthqg8Hy0Lpo7WRXXJC2oPbi65MLd1wOEiT7H2\nnsFaEui5lGxZrDChF8sOGafmFLhSFsYWgl3i/MWvRilzJWumkxfYFB1VD5v3iqkO\nCaXG+IBquBRfVdk7TghzBDkOAFN3MJx6uohoLbFxKFlUD4nCPCELuB/g5+SjFUSy\nSIb+OBIdg6c9a6HnB/HK5GvHaQ0tn+mV0vZtPUh7C1/6FWtNwnKTw+Y7+skc+lQ=\n=oFvW\n-----END PGP SIGNATURE-----\n", "payload": "tree bff240491d11d1bd3ceb011ef9a8606d7a41aa63\nparent 851a03492e5fa0a4fc6c7c94a6904078297b1ab9\nparent af8c37cb57fcde849ef333100b8057c427bfa9a9\nauthor Aleksey Kladov <aleksey.kladov@gmail.com> 1584968800 +0100\ncommitter GitHub <noreply@github.com> 1584968800 +0100\n\nMerge pull request #3678 from edwin0cheng/refactor-rename\n\nFix rename argument in macro call "}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f7ca27c082bef625bc33e1eca622457102bae4", "html_url": "https://github.com/rust-lang/rust/commit/a2f7ca27c082bef625bc33e1eca622457102bae4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2f7ca27c082bef625bc33e1eca622457102bae4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "851a03492e5fa0a4fc6c7c94a6904078297b1ab9", "url": "https://api.github.com/repos/rust-lang/rust/commits/851a03492e5fa0a4fc6c7c94a6904078297b1ab9", "html_url": "https://github.com/rust-lang/rust/commit/851a03492e5fa0a4fc6c7c94a6904078297b1ab9"}, {"sha": "af8c37cb57fcde849ef333100b8057c427bfa9a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/af8c37cb57fcde849ef333100b8057c427bfa9a9", "html_url": "https://github.com/rust-lang/rust/commit/af8c37cb57fcde849ef333100b8057c427bfa9a9"}], "stats": {"total": 138, "additions": 112, "deletions": 26}, "files": [{"sha": "d982f6ffa60edd11118f8696e417a987c78d3607", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a2f7ca27c082bef625bc33e1eca622457102bae4/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f7ca27c082bef625bc33e1eca622457102bae4/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=a2f7ca27c082bef625bc33e1eca622457102bae4", "patch": "@@ -12,7 +12,8 @@ use hir_expand::ExpansionInfo;\n use ra_db::{FileId, FileRange};\n use ra_prof::profile;\n use ra_syntax::{\n-    algo::skip_trivia_token, ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n+    algo::{find_node_at_offset, skip_trivia_token},\n+    ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextUnit,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -108,6 +109,17 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         token.value\n     }\n \n+    pub fn descend_node_at_offset<N: ast::AstNode>(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextUnit,\n+    ) -> Option<N> {\n+        // Handle macro token cases\n+        node.token_at_offset(offset)\n+            .map(|token| self.descend_into_macros(token))\n+            .find_map(|it| self.ancestors_with_macros(it.parent()).find_map(N::cast))\n+    }\n+\n     pub fn original_range(&self, node: &SyntaxNode) -> FileRange {\n         let node = self.find_file(node.clone());\n         original_range(self.db, node.as_ref())\n@@ -129,6 +141,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n             .kmerge_by(|node1, node2| node1.text_range().len() < node2.text_range().len())\n     }\n \n+    /// Find a AstNode by offset inside SyntaxNode, if it is inside *Macrofile*,\n+    /// search up until it is of the target AstNode type\n     pub fn find_node_at_offset_with_macros<N: AstNode>(\n         &self,\n         node: &SyntaxNode,\n@@ -137,6 +151,19 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.ancestors_at_offset_with_macros(node, offset).find_map(N::cast)\n     }\n \n+    /// Find a AstNode by offset inside SyntaxNode, if it is inside *MacroCall*,\n+    /// descend it and find again\n+    pub fn find_node_at_offset_with_descend<N: AstNode>(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: TextUnit,\n+    ) -> Option<N> {\n+        if let Some(it) = find_node_at_offset(&node, offset) {\n+            return Some(it);\n+        }\n+        self.descend_node_at_offset(&node, offset)\n+    }\n+\n     pub fn type_of_expr(&self, expr: &ast::Expr) -> Option<Type> {\n         self.analyze(expr.syntax()).type_of(self.db, &expr)\n     }"}, {"sha": "746cc86ba6b0e6558e79d9184680e6e388c9a3a0", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a2f7ca27c082bef625bc33e1eca622457102bae4/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f7ca27c082bef625bc33e1eca622457102bae4/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=a2f7ca27c082bef625bc33e1eca622457102bae4", "patch": "@@ -94,12 +94,16 @@ pub(crate) fn find_all_refs(\n     let sema = Semantics::new(db);\n     let syntax = sema.parse(position.file_id).syntax().clone();\n \n-    let (opt_name, search_kind) =\n-        if let Some(name) = get_struct_def_name_for_struct_literal_search(&syntax, position) {\n-            (Some(name), ReferenceKind::StructLiteral)\n-        } else {\n-            (find_node_at_offset::<ast::Name>(&syntax, position.offset), ReferenceKind::Other)\n-        };\n+    let (opt_name, search_kind) = if let Some(name) =\n+        get_struct_def_name_for_struct_literal_search(&sema, &syntax, position)\n+    {\n+        (Some(name), ReferenceKind::StructLiteral)\n+    } else {\n+        (\n+            sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, position.offset),\n+            ReferenceKind::Other,\n+        )\n+    };\n \n     let RangeInfo { range, info: def } = find_name(&sema, &syntax, position, opt_name)?;\n \n@@ -131,7 +135,8 @@ fn find_name(\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, def));\n     }\n-    let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n+    let name_ref =\n+        sema.find_node_at_offset_with_descend::<ast::NameRef>(&syntax, position.offset)?;\n     let def = classify_name_ref(sema, &name_ref)?.definition();\n     let range = name_ref.syntax().text_range();\n     Some(RangeInfo::new(range, def))\n@@ -157,17 +162,26 @@ fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Optio\n }\n \n fn get_struct_def_name_for_struct_literal_search(\n+    sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n ) -> Option<ast::Name> {\n     if let TokenAtOffset::Between(ref left, ref right) = syntax.token_at_offset(position.offset) {\n         if right.kind() != SyntaxKind::L_CURLY && right.kind() != SyntaxKind::L_PAREN {\n             return None;\n         }\n-        if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, left.text_range().start()) {\n+        if let Some(name) =\n+            sema.find_node_at_offset_with_descend::<ast::Name>(&syntax, left.text_range().start())\n+        {\n             return name.syntax().ancestors().find_map(ast::StructDef::cast).and_then(|l| l.name());\n         }\n-        if find_node_at_offset::<ast::TypeParamList>(&syntax, left.text_range().start()).is_some() {\n+        if sema\n+            .find_node_at_offset_with_descend::<ast::TypeParamList>(\n+                &syntax,\n+                left.text_range().start(),\n+            )\n+            .is_some()\n+        {\n             return left.ancestors().find_map(ast::StructDef::cast).and_then(|l| l.name());\n         }\n     }"}, {"sha": "9acc6158a47f5b6cb636489aaf066363d79241b2", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a2f7ca27c082bef625bc33e1eca622457102bae4/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f7ca27c082bef625bc33e1eca622457102bae4/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=a2f7ca27c082bef625bc33e1eca622457102bae4", "patch": "@@ -249,6 +249,63 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_for_macro_args_rev() {\n+        test_rename(\n+            r#\"\n+    macro_rules! foo {($i:ident) => {$i} }\n+    fn main() {\n+        let a = \"test\";\n+        foo!(a<|>);\n+    }\"#,\n+            \"b\",\n+            r#\"\n+    macro_rules! foo {($i:ident) => {$i} }\n+    fn main() {\n+        let b = \"test\";\n+        foo!(b);\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_for_macro_define_fn() {\n+        test_rename(\n+            r#\"\n+    macro_rules! define_fn {($id:ident) => { fn $id{} }}\n+    define_fn!(foo);\n+    fn main() {\n+        fo<|>o();\n+    }\"#,\n+            \"bar\",\n+            r#\"\n+    macro_rules! define_fn {($id:ident) => { fn $id{} }}\n+    define_fn!(bar);\n+    fn main() {\n+        bar();\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_for_macro_define_fn_rev() {\n+        test_rename(\n+            r#\"\n+    macro_rules! define_fn {($id:ident) => { fn $id{} }}\n+    define_fn!(fo<|>o);\n+    fn main() {\n+        foo();\n+    }\"#,\n+            \"bar\",\n+            r#\"\n+    macro_rules! define_fn {($id:ident) => { fn $id{} }}\n+    define_fn!(bar);\n+    fn main() {\n+        bar();\n+    }\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_for_param_inside() {\n         test_rename("}, {"sha": "11745469595766eed7330f48a4fb82eba1484c3a", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2f7ca27c082bef625bc33e1eca622457102bae4/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f7ca27c082bef625bc33e1eca622457102bae4/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=a2f7ca27c082bef625bc33e1eca622457102bae4", "patch": "@@ -10,9 +10,7 @@ use hir::{DefWithBody, HasSource, ModuleSource, Semantics};\n use once_cell::unsync::Lazy;\n use ra_db::{FileId, FileRange, SourceDatabaseExt};\n use ra_prof::profile;\n-use ra_syntax::{\n-    algo::find_node_at_offset, ast, match_ast, AstNode, TextRange, TextUnit, TokenAtOffset,\n-};\n+use ra_syntax::{ast, match_ast, AstNode, TextRange, TextUnit};\n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n@@ -219,21 +217,11 @@ impl Definition {\n                     continue;\n                 }\n \n-                let name_ref =\n-                    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&tree, offset) {\n+                let name_ref: ast::NameRef =\n+                    if let Some(name_ref) = sema.find_node_at_offset_with_descend(&tree, offset) {\n                         name_ref\n                     } else {\n-                        // Handle macro token cases\n-                        let token = match tree.token_at_offset(offset) {\n-                            TokenAtOffset::None => continue,\n-                            TokenAtOffset::Single(t) => t,\n-                            TokenAtOffset::Between(_, t) => t,\n-                        };\n-                        let expanded = sema.descend_into_macros(token);\n-                        match ast::NameRef::cast(expanded.parent()) {\n-                            Some(name_ref) => name_ref,\n-                            _ => continue,\n-                        }\n+                        continue;\n                     };\n \n                 // FIXME: reuse sb"}]}