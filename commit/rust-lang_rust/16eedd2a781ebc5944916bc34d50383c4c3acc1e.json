{"sha": "16eedd2a781ebc5944916bc34d50383c4c3acc1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZWVkZDJhNzgxZWJjNTk0NDkxNmJjMzRkNTAzODNjNGMzYWNjMWU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2016-11-01T17:57:13Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2016-11-29T12:04:27Z"}, "message": "Save bodies of functions for inlining into other crates\n\nThis is quite hacky and I hope to refactor it a bit, but at least it\nseems to work.", "tree": {"sha": "2581d8bef174a619e0783cb70cfb2362b53defed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2581d8bef174a619e0783cb70cfb2362b53defed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16eedd2a781ebc5944916bc34d50383c4c3acc1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16eedd2a781ebc5944916bc34d50383c4c3acc1e", "html_url": "https://github.com/rust-lang/rust/commit/16eedd2a781ebc5944916bc34d50383c4c3acc1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16eedd2a781ebc5944916bc34d50383c4c3acc1e/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ac338c2a78aa73182916e9425398359ccaf103a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac338c2a78aa73182916e9425398359ccaf103a", "html_url": "https://github.com/rust-lang/rust/commit/1ac338c2a78aa73182916e9425398359ccaf103a"}], "stats": {"total": 321, "additions": 178, "deletions": 143}, "files": [{"sha": "e4c5fd27b918aa772a8395aa28282318a55e023a", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -25,6 +25,7 @@ use hir as ast;\n use hir::map::{self, Node};\n use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n+use middle::cstore::{InlinedItem, InlinedItemKind};\n use syntax::abi;\n use syntax::ast::{Attribute, Name, NodeId};\n use syntax_pos::Span;\n@@ -151,6 +152,7 @@ impl<'a> FnLikeNode<'a> {\n             map::NodeTraitItem(tm) => tm.is_fn_like(),\n             map::NodeImplItem(_) => true,\n             map::NodeExpr(e) => e.is_fn_like(),\n+            map::NodeInlinedItem(ii) => ii.is_fn(),\n             _ => false\n         };\n         if fn_like {\n@@ -173,12 +175,18 @@ impl<'a> FnLikeNode<'a> {\n     }\n \n     pub fn body(self) -> ast::ExprId {\n+        if let map::NodeInlinedItem(ii) = self.node {\n+            return ast::ExprId(ii.body.id);\n+        }\n         self.handle(|i: ItemFnParts<'a>|  i.body,\n                     |_, _, _: &'a ast::MethodSig, _, body: ast::ExprId, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n     pub fn decl(self) -> &'a FnDecl {\n+        if let map::NodeInlinedItem(&InlinedItem { kind: InlinedItemKind::Fn(ref decl), .. }) = self.node {\n+            return &decl;\n+        }\n         self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n                     |_, _, sig: &'a ast::MethodSig, _, _, _, _|  &sig.decl,\n                     |c: ClosureParts<'a>| c.decl)\n@@ -196,6 +204,21 @@ impl<'a> FnLikeNode<'a> {\n                     |c: ClosureParts|    c.id)\n     }\n \n+    pub fn constness(self) -> ast::Constness {\n+        if let map::NodeInlinedItem(..) = self.node {\n+            return ast::Constness::Const;\n+        }\n+        match self.kind() {\n+            FnKind::ItemFn(_, _, _, constness, ..) => {\n+                constness\n+            }\n+            FnKind::Method(_, m, ..) => {\n+                m.constness\n+            }\n+            _ => ast::Constness::NotConst\n+        }\n+    }\n+\n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n             FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis, p.attrs)\n@@ -254,7 +277,7 @@ impl<'a> FnLikeNode<'a> {\n                         bug!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }\n-            }\n+            },\n             map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, ref decl, block, _fn_decl_span) =>\n                     closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),"}, {"sha": "33cdb428220871142b5fed9aa49f7650cc1302a7", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -18,7 +18,6 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n use dep_graph::{DepGraph, DepNode};\n \n use middle::cstore::InlinedItem;\n-use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n@@ -61,6 +60,8 @@ pub enum Node<'ast> {\n     NodeLifetime(&'ast Lifetime),\n     NodeTyParam(&'ast TyParam),\n     NodeVisibility(&'ast Visibility),\n+\n+    NodeInlinedItem(&'ast InlinedItem),\n }\n \n /// Represents an entry and its parent NodeID.\n@@ -120,6 +121,8 @@ impl<'ast> MapEntry<'ast> {\n             NodeLifetime(n) => EntryLifetime(p, n),\n             NodeTyParam(n) => EntryTyParam(p, n),\n             NodeVisibility(n) => EntryVisibility(p, n),\n+\n+            NodeInlinedItem(n) => RootInlinedParent(n),\n         }\n     }\n \n@@ -168,6 +171,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryLifetime(_, n) => NodeLifetime(n),\n             EntryTyParam(_, n) => NodeTyParam(n),\n             EntryVisibility(_, n) => NodeVisibility(n),\n+            RootInlinedParent(n) => NodeInlinedItem(n),\n             _ => return None\n         })\n     }\n@@ -328,12 +332,8 @@ impl<'ast> Map<'ast> {\n                     EntryVisibility(p, _) =>\n                         id = p,\n \n-                    RootInlinedParent(parent) => match *parent {\n-                        InlinedItem::Item(def_id, _) |\n-                        InlinedItem::TraitItem(def_id, _) |\n-                        InlinedItem::ImplItem(def_id, _) =>\n-                            return DepNode::MetaData(def_id)\n-                    },\n+                    RootInlinedParent(parent) =>\n+                        return DepNode::MetaData(parent.def_id),\n \n                     RootCrate =>\n                         bug!(\"node {} has crate ancestor but is inlined\", id0),\n@@ -556,8 +556,7 @@ impl<'ast> Map<'ast> {\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n-            Some(RootInlinedParent(&II::TraitItem(did, _))) |\n-            Some(RootInlinedParent(&II::ImplItem(did, _))) => did,\n+            Some(RootInlinedParent(ii)) => ii.def_id, // TODO: is this wrong for items?\n             _ => self.local_def_id(parent)\n         }\n     }\n@@ -962,6 +961,8 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             // printing.\n             NodeLocal(_)       => bug!(\"cannot print isolated Local\"),\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n+\n+            NodeInlinedItem(_) => bug!(\"cannot print inlined item\"),\n         }\n     }\n }\n@@ -1075,6 +1076,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n+        Some(NodeInlinedItem(_)) => {\n+            format!(\"inlined item {}\", id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "17085e31bfe5a55e4db140587d4c337ae06b6fec", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 92, "deletions": 22, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -43,7 +43,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n-use hir::intravisit::Visitor;\n+use hir::intravisit::{self, Visitor};\n use rustc_back::PanicStrategy;\n \n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n@@ -137,18 +137,100 @@ pub struct NativeLibrary {\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum InlinedItem {\n-    Item(DefId /* def-id in source crate */, P<hir::Item>),\n-    TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n-    ImplItem(DefId /* impl id */, P<hir::ImplItem>)\n+pub struct InlinedItem {\n+    pub def_id: DefId,\n+    pub body: P<hir::Expr>,\n+    pub kind: InlinedItemKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum InlinedItemKind {\n+    Const(P<hir::Ty>),\n+    Fn(P<hir::FnDecl>)\n+}\n+\n+/// A borrowed version of `hir::InlinedItem`. This is what's encoded when saving\n+/// a crate; it then gets read as an InlinedItem.\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n+pub struct InlinedItemRef<'a> {\n+    pub def_id: DefId,\n+    pub body: &'a hir::Expr,\n+    pub kind: InlinedItemKindRef<'a>,\n }\n \n-/// A borrowed version of `hir::InlinedItem`.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n-pub enum InlinedItemRef<'a> {\n-    Item(DefId, &'a hir::Item),\n-    TraitItem(DefId, &'a hir::TraitItem),\n-    ImplItem(DefId, &'a hir::ImplItem)\n+pub enum InlinedItemKindRef<'a> {\n+    Const(&'a hir::Ty),\n+    Fn(&'a hir::FnDecl)\n+}\n+\n+impl<'a> InlinedItemRef<'a> {\n+    pub fn from_item<'ast: 'a>(def_id: DefId, item: &'a hir::Item, map: &hir_map::Map<'ast>) -> InlinedItemRef<'a> {\n+        let (body, kind) = match item.node {\n+            hir::ItemFn(ref decl, _, _, _, _, body_id) => (map.expr(body_id), InlinedItemKindRef::Fn(&decl)),\n+            hir::ItemConst(ref ty, ref body) => (&**body, InlinedItemKindRef::Const(ty)),\n+            _ => bug!(\"InlinedItemRef::from_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            kind: kind\n+        }\n+    }\n+\n+    pub fn from_trait_item(def_id: DefId, item: &'a hir::TraitItem, _map: &hir_map::Map) -> InlinedItemRef<'a> {\n+        let (body, kind) = match item.node {\n+            hir::ConstTraitItem(ref ty, Some(ref body)) => (&**body, InlinedItemKindRef::Const(ty)),\n+            _ => bug!(\"InlinedItemRef::from_trait_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            kind: kind\n+        }\n+    }\n+\n+    pub fn from_impl_item<'ast: 'a>(def_id: DefId, item: &'a hir::ImplItem, map: &hir_map::Map<'ast>) -> InlinedItemRef<'a> {\n+        let (body, kind) = match item.node {\n+            hir::ImplItemKind::Method(ref sig, body_id) => (map.expr(body_id), InlinedItemKindRef::Fn(&sig.decl)),\n+            hir::ImplItemKind::Const(ref ty, ref body) => (&**body, InlinedItemKindRef::Const(ty)),\n+            _ => bug!(\"InlinedItemRef::from_impl_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            kind: kind\n+        }\n+    }\n+\n+    pub fn visit<V>(&self, visitor: &mut V)\n+        where V: Visitor<'a>\n+    {\n+        visitor.visit_expr(&self.body);\n+        match self.kind {\n+            InlinedItemKindRef::Const(ty) => visitor.visit_ty(ty),\n+            InlinedItemKindRef::Fn(decl) => intravisit::walk_fn_decl(visitor, decl)\n+        }\n+    }\n+}\n+\n+impl InlinedItem {\n+    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n+        where V: Visitor<'ast>\n+    {\n+        visitor.visit_expr(&self.body);\n+        match self.kind {\n+            InlinedItemKind::Const(ref ty) => visitor.visit_ty(ty),\n+            InlinedItemKind::Fn(ref decl) => intravisit::walk_fn_decl(visitor, decl)\n+        }\n+    }\n+\n+    pub fn is_fn(&self) -> bool {\n+        match self.kind {\n+            InlinedItemKind::Const(_) => false,\n+            InlinedItemKind::Fn(_) => true\n+        }\n+    }\n }\n \n pub enum LoadedMacro {\n@@ -292,18 +374,6 @@ pub trait CrateStore<'tcx> {\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n-impl InlinedItem {\n-    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n-        where V: Visitor<'ast>\n-    {\n-        match *self {\n-            InlinedItem::Item(_, ref i) => visitor.visit_item(&i),\n-            InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-            InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n-        }\n-    }\n-}\n-\n // FIXME: find a better place for this?\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     let mut err_count = 0;"}, {"sha": "96faf97d609f63dd52d9c4dbfe31dbdc5c93284a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -30,7 +30,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Expr;\n use rustc::hir::intravisit;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::intravisit::{Visitor, NestedVisitMode};\n \n use self::restrictions::RestrictionResult;\n \n@@ -520,8 +520,12 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n     item_id: ast::NodeId\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n+    fn nested_visit_map(&mut self) -> Option<(&hir::map::Map<'tcx>, NestedVisitMode)> {\n+        Some((&self.bccx.tcx.map, NestedVisitMode::OnlyBodies))\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n             let param_env = ty::ParameterEnvironment::for_item(self.bccx.tcx,\n                                                                self.item_id);\n@@ -542,9 +546,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt,\n-                                          item_id: ast::NodeId,\n-                                          expr: &hir::Expr) {\n+pub fn gather_loans_in_static_initializer<'a, 'tcx>(bccx: &mut BorrowckCtxt<'a, 'tcx>,\n+                                                    item_id: ast::NodeId,\n+                                                    expr: &'tcx hir::Expr) {\n \n     debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n "}, {"sha": "fb5cff5695072a8558e21208cd450ea9494f4a9b", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -17,7 +17,7 @@ use self::EvalHint::*;\n \n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::middle::cstore::InlinedItem;\n+use rustc::middle::cstore::{InlinedItem, InlinedItemKind};\n use rustc::traits;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n@@ -141,33 +141,9 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem::Item(_, ref item), _)) => match item.node {\n-                hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n-                },\n-                _ => None\n-            },\n-            Some((&InlinedItem::TraitItem(trait_id, ref ti), _)) => match ti.node {\n-                hir::ConstTraitItem(..) => {\n-                    used_substs = true;\n-                    if let Some(substs) = substs {\n-                        // As mentioned in the comments above for in-crate\n-                        // constants, we only try to find the expression for\n-                        // a trait-associated const if the caller gives us\n-                        // the substitutions for the reference to it.\n-                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None\n-            },\n-            Some((&InlinedItem::ImplItem(_, ref ii), _)) => match ii.node {\n-                hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&**expr, tcx.ast_ty_to_prim_ty(ty)))\n-                },\n-                _ => None\n-            },\n+            Some((&InlinedItem { body: ref const_expr, kind: InlinedItemKind::Const(ref ty), .. }, _)) => {\n+                Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n+            }\n             _ => None\n         };\n         // If we used the substitutions, particularly to choose an impl\n@@ -197,8 +173,7 @@ fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-        Some((&InlinedItem::Item(_, ref item), _)) => Some(item.id),\n-        Some((&InlinedItem::ImplItem(_, ref item), _)) => Some(item.id),\n+        Some((&InlinedItem { kind: InlinedItemKind::Fn(_), .. }, node_id)) => Some(node_id),\n         _ => None\n     };\n     tcx.extern_const_fns.borrow_mut().insert(def_id,\n@@ -224,18 +199,10 @@ pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n         None => return None\n     };\n \n-    match fn_like.kind() {\n-        FnKind::ItemFn(_, _, _, hir::Constness::Const, ..) => {\n-            Some(fn_like)\n-        }\n-        FnKind::Method(_, m, ..) => {\n-            if m.constness == hir::Constness::Const {\n-                Some(fn_like)\n-            } else {\n-                None\n-            }\n-        }\n-        _ => None\n+    if fn_like.constness() == hir::Constness::Const {\n+        Some(fn_like)\n+    } else {\n+        None\n     }\n }\n "}, {"sha": "8a24062f8f35da9d74418f10b8f2d1edbab789c9", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -46,11 +46,7 @@ enum TableEntry<'tcx> {\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     pub fn encode_inlined_item(&mut self, ii: InlinedItemRef<'tcx>) -> Lazy<Ast<'tcx>> {\n         let mut id_visitor = IdRangeComputingVisitor::new(&self.tcx.map);\n-        match ii {\n-            InlinedItemRef::Item(_, i) => id_visitor.visit_item(i),\n-            InlinedItemRef::TraitItem(_, ti) => id_visitor.visit_trait_item(ti),\n-            InlinedItemRef::ImplItem(_, ii) => id_visitor.visit_impl_item(ii),\n-        }\n+        ii.visit(&mut id_visitor);\n \n         let ii_pos = self.position();\n         ii.encode(self).unwrap();\n@@ -61,11 +57,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 ecx: self,\n                 count: 0,\n             };\n-            match ii {\n-                InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n-                InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n-                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii),\n-            }\n+            ii.visit(&mut visitor);\n             visitor.count\n         };\n \n@@ -127,17 +119,13 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n                      }];\n \n     let ii = ast.item.decode((cdata, tcx, id_ranges));\n+    let item_node_id = tcx.sess.next_node_id();\n     let ii = ast_map::map_decoded_item(&tcx.map,\n                                        parent_def_path,\n                                        parent_did,\n                                        ii,\n-                                       tcx.sess.next_node_id());\n+                                       item_node_id);\n \n-    let item_node_id = match ii {\n-        &InlinedItem::Item(_, ref i) => i.id,\n-        &InlinedItem::TraitItem(_, ref ti) => ti.id,\n-        &InlinedItem::ImplItem(_, ref ii) => ii.id,\n-    };\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n     let ty = tcx.item_type(orig_did);\n     let generics = tcx.item_generics(orig_did);"}, {"sha": "573b2f6d2a60cd9c500ecc820f9954dd3fc6785d", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -443,12 +443,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n         let find_inlined_item_root = |inlined_item_id| {\n             let mut node = inlined_item_id;\n-            let mut path = Vec::with_capacity(10);\n \n             // If we can't find the inline root after a thousand hops, we can\n             // be pretty sure there's something wrong with the HIR map.\n             for _ in 0 .. 1000 {\n-                path.push(node);\n                 let parent_node = tcx.map.get_parent_node(node);\n                 if parent_node == node {\n                     return node;\n@@ -464,27 +462,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                     .borrow_mut()\n                     .insert(def_id, None);\n             }\n-            Some(&InlinedItem::Item(d, ref item)) => {\n-                assert_eq!(d, def_id);\n-                let inlined_root_node_id = find_inlined_item_root(item.id);\n-                cache_inlined_item(def_id, item.id, inlined_root_node_id);\n-            }\n-            Some(&InlinedItem::TraitItem(_, ref trait_item)) => {\n-                let inlined_root_node_id = find_inlined_item_root(trait_item.id);\n-                cache_inlined_item(def_id, trait_item.id, inlined_root_node_id);\n-\n-                // Associated consts already have to be evaluated in `typeck`, so\n-                // the logic to do that already exists in `middle`. In order to\n-                // reuse that code, it needs to be able to look up the traits for\n-                // inlined items.\n-                let ty_trait_item = tcx.associated_item(def_id).clone();\n-                let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n-                tcx.associated_items.borrow_mut()\n-                   .insert(trait_item_def_id, ty_trait_item);\n-            }\n-            Some(&InlinedItem::ImplItem(_, ref impl_item)) => {\n-                let inlined_root_node_id = find_inlined_item_root(impl_item.id);\n-                cache_inlined_item(def_id, impl_item.id, inlined_root_node_id);\n+            Some(&InlinedItem { ref body, .. }) => {\n+                let inlined_root_node_id = find_inlined_item_root(body.id);\n+                cache_inlined_item(def_id, inlined_root_node_id, inlined_root_node_id);\n             }\n         }\n "}, {"sha": "afb88cf3ddfd0b50aec80dee22995218527291e3", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -518,7 +518,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ast: if trait_item.kind == ty::AssociatedKind::Const {\n                 let trait_def_id = trait_item.container.id();\n-                Some(self.encode_inlined_item(InlinedItemRef::TraitItem(trait_def_id, ast_item)))\n+                Some(self.encode_inlined_item(InlinedItemRef::from_trait_item(trait_def_id, ast_item, &tcx.map)))\n             } else {\n                 None\n             },\n@@ -527,6 +527,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        let tcx = self.tcx;\n+\n         let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.map.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n@@ -587,7 +589,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: if ast {\n-                Some(self.encode_inlined_item(InlinedItemRef::ImplItem(impl_def_id, ast_item)))\n+                Some(self.encode_inlined_item(InlinedItemRef::from_impl_item(impl_def_id, ast_item, &tcx.map)))\n             } else {\n                 None\n             },\n@@ -817,7 +819,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ast: match item.node {\n                 hir::ItemConst(..) |\n                 hir::ItemFn(_, _, hir::Constness::Const, ..) => {\n-                    Some(self.encode_inlined_item(InlinedItemRef::Item(def_id, item)))\n+                    Some(self.encode_inlined_item(InlinedItemRef::from_item(def_id, item, &tcx.map)))\n                 }\n                 _ => None,\n             },"}, {"sha": "32639cc3f86965a50350356ba67410e9faa365c3", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -23,7 +23,6 @@ use rustc_const_eval as const_eval;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n@@ -51,11 +50,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Static(..) => hir::Constness::Const,\n             MirSource::Fn(id) => {\n                 let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n-                match fn_like.map(|f| f.kind()) {\n-                    Some(FnKind::ItemFn(_, _, _, c, ..)) => c,\n-                    Some(FnKind::Method(_, m, ..)) => m.constness,\n-                    _ => hir::Constness::NotConst\n-                }\n+                fn_like.map_or(hir::Constness::NotConst, |f| f.constness())\n             }\n             MirSource::Promoted(..) => bug!()\n         };"}, {"sha": "57929879f94025752ce00801351760880240cda1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt, Ty};\n@@ -116,15 +115,10 @@ impl fmt::Display for Mode {\n \n pub fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        let fn_like = FnLikeNode::from_node(tcx.map.get(node_id));\n-        match fn_like.map(|f| f.kind()) {\n-            Some(FnKind::ItemFn(_, _, _, c, ..)) => {\n-                c == hir::Constness::Const\n-            }\n-            Some(FnKind::Method(_, m, ..)) => {\n-                m.constness == hir::Constness::Const\n-            }\n-            _ => false\n+        if let Some(fn_like) = FnLikeNode::from_node(tcx.map.get(node_id)) {\n+            fn_like.constness() == hir::Constness::Const\n+        } else {\n+            false\n         }\n     } else {\n         tcx.sess.cstore.is_const_fn(def_id)"}, {"sha": "729cc77356854c2fe3c0ae88302289d32440a85e", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16eedd2a781ebc5944916bc34d50383c4c3acc1e/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=16eedd2a781ebc5944916bc34d50383c4c3acc1e", "patch": "@@ -181,11 +181,19 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     /// Returns true if the call is to a const fn or method.\n     fn handle_const_fn_call(&mut self, _expr: &hir::Expr, def_id: DefId, ret_ty: Ty<'gcx>) -> bool {\n         if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n-            let qualif = self.fn_like(fn_like.kind(),\n-                                      fn_like.decl(),\n-                                      fn_like.body(),\n-                                      fn_like.span(),\n-                                      fn_like.id());\n+            let qualif = match self.tcx.const_qualif_map.borrow_mut().entry(fn_like.body().node_id()) {\n+                Entry::Occupied(entry) => Some(*entry.get()),\n+                _ => None\n+            };\n+\n+            let qualif = qualif.unwrap_or_else(|| {\n+                self.fn_like(fn_like.kind(),\n+                             fn_like.decl(),\n+                             fn_like.body(),\n+                             fn_like.span(),\n+                             fn_like.id())\n+            });\n+\n             self.add_qualif(qualif);\n \n             if ret_ty.type_contents(self.tcx).interior_unsafe() {"}]}