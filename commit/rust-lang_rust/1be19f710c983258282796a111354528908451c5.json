{"sha": "1be19f710c983258282796a111354528908451c5", "node_id": "C_kwDOAAsO6NoAKDFiZTE5ZjcxMGM5ODMyNTgyODI3OTZhMTExMzU0NTI4OTA4NDUxYzU", "commit": {"author": {"name": "Andrew Xie", "email": "ndrew.xie@gmail.com", "date": "2023-05-07T23:52:19Z"}, "committer": {"name": "Andrew Xie", "email": "ndrew.xie@gmail.com", "date": "2023-06-05T01:55:30Z"}, "message": "Switched some uses to UnordMap", "tree": {"sha": "e566ad96153a270f8a39fca8de04ff77bc0313ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e566ad96153a270f8a39fca8de04ff77bc0313ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be19f710c983258282796a111354528908451c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be19f710c983258282796a111354528908451c5", "html_url": "https://github.com/rust-lang/rust/commit/1be19f710c983258282796a111354528908451c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be19f710c983258282796a111354528908451c5/comments", "author": {"login": "ndrewxie", "id": 32971598, "node_id": "MDQ6VXNlcjMyOTcxNTk4", "avatar_url": "https://avatars.githubusercontent.com/u/32971598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ndrewxie", "html_url": "https://github.com/ndrewxie", "followers_url": "https://api.github.com/users/ndrewxie/followers", "following_url": "https://api.github.com/users/ndrewxie/following{/other_user}", "gists_url": "https://api.github.com/users/ndrewxie/gists{/gist_id}", "starred_url": "https://api.github.com/users/ndrewxie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ndrewxie/subscriptions", "organizations_url": "https://api.github.com/users/ndrewxie/orgs", "repos_url": "https://api.github.com/users/ndrewxie/repos", "events_url": "https://api.github.com/users/ndrewxie/events{/privacy}", "received_events_url": "https://api.github.com/users/ndrewxie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ndrewxie", "id": 32971598, "node_id": "MDQ6VXNlcjMyOTcxNTk4", "avatar_url": "https://avatars.githubusercontent.com/u/32971598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ndrewxie", "html_url": "https://github.com/ndrewxie", "followers_url": "https://api.github.com/users/ndrewxie/followers", "following_url": "https://api.github.com/users/ndrewxie/following{/other_user}", "gists_url": "https://api.github.com/users/ndrewxie/gists{/gist_id}", "starred_url": "https://api.github.com/users/ndrewxie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ndrewxie/subscriptions", "organizations_url": "https://api.github.com/users/ndrewxie/orgs", "repos_url": "https://api.github.com/users/ndrewxie/repos", "events_url": "https://api.github.com/users/ndrewxie/events{/privacy}", "received_events_url": "https://api.github.com/users/ndrewxie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a96c6e5171e5aa9e5e70639989e7cdb99dc5efc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a96c6e5171e5aa9e5e70639989e7cdb99dc5efc", "html_url": "https://github.com/rust-lang/rust/commit/2a96c6e5171e5aa9e5e70639989e7cdb99dc5efc"}], "stats": {"total": 286, "additions": 150, "deletions": 136}, "files": [{"sha": "3e12c9b5016beb9a980da1957c7eb04b2a0c1ff3", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=1be19f710c983258282796a111354528908451c5", "patch": "@@ -24,7 +24,7 @@\n \n use crate::errors;\n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::mir::mono::CodegenUnitNameBuilder;\n use rustc_middle::ty::TyCtxt;\n@@ -52,7 +52,7 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n \n struct AssertModuleSource<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    available_cgus: FxIndexSet<Symbol>,\n+    available_cgus: UnordSet<Symbol>,\n }\n \n impl<'tcx> AssertModuleSource<'tcx> {\n@@ -118,9 +118,8 @@ impl<'tcx> AssertModuleSource<'tcx> {\n         debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, sym::module), cgu_name);\n \n         if !self.available_cgus.contains(&cgu_name) {\n-            let mut cgu_names: Vec<&str> =\n-                self.available_cgus.iter().map(|cgu| cgu.as_str()).collect();\n-            cgu_names.sort();\n+            let cgu_names: Vec<String> =\n+                self.available_cgus.items().map(|cgu| cgu.as_str().to_owned()).into_sorted(&());\n             self.tcx.sess.emit_err(errors::NoModuleNamed {\n                 span: attr.span,\n                 user_path,"}, {"sha": "51bdcf8e92b521123a6e0dd72f733f2502b59709", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=1be19f710c983258282796a111354528908451c5", "patch": "@@ -21,7 +21,8 @@\n \n use crate::errors;\n use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n-use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit;\n use rustc_hir::Node as HirNode;\n@@ -125,7 +126,7 @@ const LABELS_ADT: &[&[&str]] = &[BASE_HIR, BASE_STRUCT];\n //\n //     type_of for these.\n \n-type Labels = FxIndexSet<String>;\n+type Labels = UnordSet<String>;\n \n /// Represents the requested configuration by rustc_clean/dirty\n struct Assertion {\n@@ -197,7 +198,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n         let (name, mut auto) = self.auto_labels(item_id, attr);\n         let except = self.except(attr);\n         let loaded_from_disk = self.loaded_from_disk(attr);\n-        for e in except.iter() {\n+        for e in except.to_sorted(&(), false) {\n             if !auto.remove(e) {\n                 self.tcx.sess.emit_fatal(errors::AssertionAuto { span: attr.span, name, e });\n             }\n@@ -376,18 +377,21 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n                 continue;\n             };\n             self.checked_attrs.insert(attr.id);\n-            for label in assertion.clean {\n+            assertion.clean.items().all(|label| {\n                 let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n                 self.assert_clean(item_span, dep_node);\n-            }\n-            for label in assertion.dirty {\n+                true\n+            });\n+            assertion.dirty.items().all(|label| {\n                 let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n                 self.assert_dirty(item_span, dep_node);\n-            }\n-            for label in assertion.loaded_from_disk {\n+                true\n+            });\n+            assertion.loaded_from_disk.items().all(|label| {\n                 let dep_node = DepNode::from_label_string(self.tcx, &label, def_path_hash).unwrap();\n                 self.assert_loaded_from_disk(item_span, dep_node);\n-            }\n+                true\n+            });\n         }\n     }\n }"}, {"sha": "b44fb37fd7a932b86a154e9a02c0de16ddbba06c", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 104, "deletions": 102, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=1be19f710c983258282796a111354528908451c5", "patch": "@@ -104,8 +104,9 @@\n //! implemented.\n \n use crate::errors;\n-use rustc_data_structures::fx::{FxHashSet, FxIndexMap, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::unord::{UnordMap, UnordSet};\n use rustc_data_structures::{base_n, flock};\n use rustc_errors::ErrorGuaranteed;\n use rustc_fs_util::{link_or_copy, try_canonicalize, LinkOrCopy};\n@@ -636,7 +637,7 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     // First do a pass over the crate directory, collecting lock files and\n     // session directories\n     let mut session_directories = FxIndexSet::default();\n-    let mut lock_files = FxIndexSet::default();\n+    let mut lock_files = UnordSet::default();\n \n     for dir_entry in crate_directory.read_dir()? {\n         let Ok(dir_entry) = dir_entry else {\n@@ -659,30 +660,28 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     }\n \n     // Now map from lock files to session directories\n-    let lock_file_to_session_dir: FxIndexMap<String, Option<String>> = lock_files\n-        .into_iter()\n-        .map(|lock_file_name| {\n+    let lock_file_to_session_dir: UnordMap<String, Option<String>> =\n+        UnordMap::from(lock_files.into_items().map(|lock_file_name| {\n             assert!(lock_file_name.ends_with(LOCK_FILE_EXT));\n             let dir_prefix_end = lock_file_name.len() - LOCK_FILE_EXT.len();\n             let session_dir = {\n                 let dir_prefix = &lock_file_name[0..dir_prefix_end];\n                 session_directories.iter().find(|dir_name| dir_name.starts_with(dir_prefix))\n             };\n             (lock_file_name, session_dir.map(String::clone))\n-        })\n-        .collect();\n+        }));\n \n     // Delete all lock files, that don't have an associated directory. They must\n     // be some kind of leftover\n-    for (lock_file_name, directory_name) in &lock_file_to_session_dir {\n+    lock_file_to_session_dir.items().all(|(lock_file_name, directory_name)| {\n         if directory_name.is_none() {\n             let Ok(timestamp) = extract_timestamp_from_session_dir(lock_file_name) else {\n                 debug!(\n                     \"found lock-file with malformed timestamp: {}\",\n                     crate_directory.join(&lock_file_name).display()\n                 );\n                 // Ignore it\n-                continue;\n+                return true;\n             };\n \n             let lock_file_path = crate_directory.join(&**lock_file_name);\n@@ -702,17 +701,18 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n                 );\n             }\n         }\n-    }\n+        true\n+    });\n \n     // Filter out `None` directories\n-    let lock_file_to_session_dir: FxIndexMap<String, String> = lock_file_to_session_dir\n-        .into_iter()\n-        .filter_map(|(lock_file_name, directory_name)| directory_name.map(|n| (lock_file_name, n)))\n-        .collect();\n+    let lock_file_to_session_dir: UnordMap<String, String> =\n+        UnordMap::from(lock_file_to_session_dir.into_items().filter_map(\n+            |(lock_file_name, directory_name)| directory_name.map(|n| (lock_file_name, n)),\n+        ));\n \n     // Delete all session directories that don't have a lock file.\n     for directory_name in session_directories {\n-        if !lock_file_to_session_dir.values().any(|dir| *dir == directory_name) {\n+        if !lock_file_to_session_dir.items().any(|(_, dir)| *dir == directory_name) {\n             let path = crate_directory.join(directory_name);\n             if let Err(err) = safe_remove_dir_all(&path) {\n                 sess.emit_warning(errors::InvalidGcFailed { path: &path, err });\n@@ -721,103 +721,103 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     }\n \n     // Now garbage collect the valid session directories.\n-    let mut deletion_candidates = vec![];\n-\n-    for (lock_file_name, directory_name) in &lock_file_to_session_dir {\n-        debug!(\"garbage_collect_session_directories() - inspecting: {}\", directory_name);\n+    let deletion_candidates =\n+        lock_file_to_session_dir.items().filter_map(|(lock_file_name, directory_name)| {\n+            debug!(\"garbage_collect_session_directories() - inspecting: {}\", directory_name);\n \n-        let Ok(timestamp) = extract_timestamp_from_session_dir(directory_name) else {\n+            let Ok(timestamp) = extract_timestamp_from_session_dir(directory_name) else {\n             debug!(\n                 \"found session-dir with malformed timestamp: {}\",\n                 crate_directory.join(directory_name).display()\n             );\n             // Ignore it\n-            continue;\n+            return None;\n         };\n \n-        if is_finalized(directory_name) {\n-            let lock_file_path = crate_directory.join(lock_file_name);\n-            match flock::Lock::new(\n-                &lock_file_path,\n-                false, // don't wait\n-                false, // don't create the lock-file\n-                true,\n-            ) {\n-                // get an exclusive lock\n-                Ok(lock) => {\n-                    debug!(\n-                        \"garbage_collect_session_directories() - \\\n+            if is_finalized(directory_name) {\n+                let lock_file_path = crate_directory.join(lock_file_name);\n+                match flock::Lock::new(\n+                    &lock_file_path,\n+                    false, // don't wait\n+                    false, // don't create the lock-file\n+                    true,\n+                ) {\n+                    // get an exclusive lock\n+                    Ok(lock) => {\n+                        debug!(\n+                            \"garbage_collect_session_directories() - \\\n                             successfully acquired lock\"\n-                    );\n-                    debug!(\n-                        \"garbage_collect_session_directories() - adding \\\n+                        );\n+                        debug!(\n+                            \"garbage_collect_session_directories() - adding \\\n                             deletion candidate: {}\",\n-                        directory_name\n-                    );\n-\n-                    // Note that we are holding on to the lock\n-                    deletion_candidates.push((\n-                        timestamp,\n-                        crate_directory.join(directory_name),\n-                        Some(lock),\n-                    ));\n-                }\n-                Err(_) => {\n-                    debug!(\n-                        \"garbage_collect_session_directories() - \\\n+                            directory_name\n+                        );\n+\n+                        // Note that we are holding on to the lock\n+                        return Some((\n+                            (timestamp, crate_directory.join(directory_name)),\n+                            Some(lock),\n+                        ));\n+                    }\n+                    Err(_) => {\n+                        debug!(\n+                            \"garbage_collect_session_directories() - \\\n                             not collecting, still in use\"\n-                    );\n+                        );\n+                    }\n                 }\n-            }\n-        } else if is_old_enough_to_be_collected(timestamp) {\n-            // When cleaning out \"-working\" session directories, i.e.\n-            // session directories that might still be in use by another\n-            // compiler instance, we only look a directories that are\n-            // at least ten seconds old. This is supposed to reduce the\n-            // chance of deleting a directory in the time window where\n-            // the process has allocated the directory but has not yet\n-            // acquired the file-lock on it.\n-\n-            // Try to acquire the directory lock. If we can't, it\n-            // means that the owning process is still alive and we\n-            // leave this directory alone.\n-            let lock_file_path = crate_directory.join(lock_file_name);\n-            match flock::Lock::new(\n-                &lock_file_path,\n-                false, // don't wait\n-                false, // don't create the lock-file\n-                true,\n-            ) {\n-                // get an exclusive lock\n-                Ok(lock) => {\n-                    debug!(\n-                        \"garbage_collect_session_directories() - \\\n+            } else if is_old_enough_to_be_collected(timestamp) {\n+                // When cleaning out \"-working\" session directories, i.e.\n+                // session directories that might still be in use by another\n+                // compiler instance, we only look a directories that are\n+                // at least ten seconds old. This is supposed to reduce the\n+                // chance of deleting a directory in the time window where\n+                // the process has allocated the directory but has not yet\n+                // acquired the file-lock on it.\n+\n+                // Try to acquire the directory lock. If we can't, it\n+                // means that the owning process is still alive and we\n+                // leave this directory alone.\n+                let lock_file_path = crate_directory.join(lock_file_name);\n+                match flock::Lock::new(\n+                    &lock_file_path,\n+                    false, // don't wait\n+                    false, // don't create the lock-file\n+                    true,\n+                ) {\n+                    // get an exclusive lock\n+                    Ok(lock) => {\n+                        debug!(\n+                            \"garbage_collect_session_directories() - \\\n                             successfully acquired lock\"\n-                    );\n+                        );\n \n-                    delete_old(sess, &crate_directory.join(directory_name));\n+                        delete_old(sess, &crate_directory.join(directory_name));\n \n-                    // Let's make it explicit that the file lock is released at this point,\n-                    // or rather, that we held on to it until here\n-                    drop(lock);\n-                }\n-                Err(_) => {\n-                    debug!(\n-                        \"garbage_collect_session_directories() - \\\n+                        // Let's make it explicit that the file lock is released at this point,\n+                        // or rather, that we held on to it until here\n+                        drop(lock);\n+                    }\n+                    Err(_) => {\n+                        debug!(\n+                            \"garbage_collect_session_directories() - \\\n                             not collecting, still in use\"\n-                    );\n+                        );\n+                    }\n                 }\n-            }\n-        } else {\n-            debug!(\n-                \"garbage_collect_session_directories() - not finalized, not \\\n+            } else {\n+                debug!(\n+                    \"garbage_collect_session_directories() - not finalized, not \\\n                     old enough\"\n-            );\n-        }\n-    }\n+                );\n+            }\n+            None\n+        });\n+    let deletion_candidates = UnordMap::from(deletion_candidates);\n \n     // Delete all but the most recent of the candidates\n-    for (path, lock) in all_except_most_recent(deletion_candidates) {\n+    all_except_most_recent(deletion_candidates).into_items().all(|(path, lock)| {\n         debug!(\"garbage_collect_session_directories() - deleting `{}`\", path.display());\n \n         if let Err(err) = safe_remove_dir_all(&path) {\n@@ -829,7 +829,8 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n         // Let's make it explicit that the file lock is released at this point,\n         // or rather, that we held on to it until here\n         drop(lock);\n-    }\n+        true\n+    });\n \n     Ok(())\n }\n@@ -845,18 +846,19 @@ fn delete_old(sess: &Session, path: &Path) {\n }\n \n fn all_except_most_recent(\n-    deletion_candidates: Vec<(SystemTime, PathBuf, Option<flock::Lock>)>,\n-) -> FxIndexMap<PathBuf, Option<flock::Lock>> {\n-    let most_recent = deletion_candidates.iter().map(|&(timestamp, ..)| timestamp).max();\n+    deletion_candidates: UnordMap<(SystemTime, PathBuf), Option<flock::Lock>>,\n+) -> UnordMap<PathBuf, Option<flock::Lock>> {\n+    let most_recent = deletion_candidates.items().map(|(&(timestamp, _), _)| timestamp).max();\n \n     if let Some(most_recent) = most_recent {\n-        deletion_candidates\n-            .into_iter()\n-            .filter(|&(timestamp, ..)| timestamp != most_recent)\n-            .map(|(_, path, lock)| (path, lock))\n-            .collect()\n+        UnordMap::from(\n+            deletion_candidates\n+                .into_items()\n+                .filter(|&((timestamp, _), _)| timestamp != most_recent)\n+                .map(|((_, path), lock)| (path, lock)),\n+        )\n     } else {\n-        FxIndexMap::default()\n+        UnordMap::default()\n     }\n }\n "}, {"sha": "90d8a72de07d5b5873b5a29847e96a76ffd55ff9", "filename": "compiler/rustc_incremental/src/persist/fs/tests.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs%2Ftests.rs?ref=1be19f710c983258282796a111354528908451c5", "patch": "@@ -2,26 +2,26 @@ use super::*;\n \n #[test]\n fn test_all_except_most_recent() {\n+    let computed: UnordMap<_, Option<flock::Lock>> = UnordMap::from_iter([\n+        ((UNIX_EPOCH + Duration::new(4, 0), PathBuf::from(\"4\")), None),\n+        ((UNIX_EPOCH + Duration::new(1, 0), PathBuf::from(\"1\")), None),\n+        ((UNIX_EPOCH + Duration::new(5, 0), PathBuf::from(\"5\")), None),\n+        ((UNIX_EPOCH + Duration::new(3, 0), PathBuf::from(\"3\")), None),\n+        ((UNIX_EPOCH + Duration::new(2, 0), PathBuf::from(\"2\")), None),\n+    ]);\n+    let mut paths = UnordSet::default();\n+    UnordSet::extend_unord(&mut paths, computed.into_items().map(|((_, path), _)| path));\n     assert_eq!(\n-        all_except_most_recent(vec![\n-            (UNIX_EPOCH + Duration::new(4, 0), PathBuf::from(\"4\"), None),\n-            (UNIX_EPOCH + Duration::new(1, 0), PathBuf::from(\"1\"), None),\n-            (UNIX_EPOCH + Duration::new(5, 0), PathBuf::from(\"5\"), None),\n-            (UNIX_EPOCH + Duration::new(3, 0), PathBuf::from(\"3\"), None),\n-            (UNIX_EPOCH + Duration::new(2, 0), PathBuf::from(\"2\"), None),\n+        UnordSet::from(paths),\n+        UnordSet::from_iter([\n+            PathBuf::from(\"1\"),\n+            PathBuf::from(\"2\"),\n+            PathBuf::from(\"3\"),\n+            PathBuf::from(\"4\")\n         ])\n-        .keys()\n-        .cloned()\n-        .collect::<FxHashSet<PathBuf>>(),\n-        [PathBuf::from(\"1\"), PathBuf::from(\"2\"), PathBuf::from(\"3\"), PathBuf::from(\"4\"),]\n-            .into_iter()\n-            .collect::<FxHashSet<PathBuf>>()\n     );\n \n-    assert_eq!(\n-        all_except_most_recent(vec![]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n-        FxHashSet::default()\n-    );\n+    assert!(all_except_most_recent(UnordMap::default()).is_empty());\n }\n \n #[test]"}, {"sha": "b718bed819b2f15205ec89175127b60d250f838c", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=1be19f710c983258282796a111354528908451c5", "patch": "@@ -1,8 +1,8 @@\n //! Code to save/load the dep-graph from files.\n \n use crate::errors;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::memmap::Mmap;\n+use rustc_data_structures::unord::UnordMap;\n use rustc_middle::dep_graph::{SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::query::on_disk_cache::OnDiskCache;\n use rustc_serialize::opaque::MemDecoder;\n@@ -16,7 +16,7 @@ use super::file_format;\n use super::fs::*;\n use super::work_product;\n \n-type WorkProductMap = FxIndexMap<WorkProductId, WorkProduct>;\n+type WorkProductMap = UnordMap<WorkProductId, WorkProduct>;\n \n #[derive(Debug)]\n /// Represents the result of an attempt to load incremental compilation data."}, {"sha": "6975fbd917a4fae25b67de37dcc1456b05debff8", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=1be19f710c983258282796a111354528908451c5", "patch": "@@ -5,6 +5,7 @@ use crate::passes;\n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{AppendOnlyIndexVec, Lrc, OnceCell, RwLock, WorkerLocal};\n@@ -195,7 +196,8 @@ impl<'tcx> Queries<'tcx> {\n                 .and_then(|future| {\n                     let (prev_graph, prev_work_products) =\n                         sess.time(\"blocked_on_dep_graph_loading\", || future.open().open(sess));\n-\n+                    let prev_work_products =\n+                        FxIndexMap::from_iter(prev_work_products.into_sorted(&(), false));\n                     rustc_incremental::build_dep_graph(sess, prev_graph, prev_work_products)\n                 })\n                 .unwrap_or_else(DepGraph::new_disabled);"}, {"sha": "e0089f28615472b59cf3adf3fc7513801a2ca983", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be19f710c983258282796a111354528908451c5/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=1be19f710c983258282796a111354528908451c5", "patch": "@@ -46,7 +46,7 @@ use super::{DepContext, DepKind, FingerprintStyle};\n use crate::ich::StableHashingContext;\n \n use rustc_data_structures::fingerprint::{Fingerprint, PackedFingerprint};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_hir::definitions::DefPathHash;\n use std::fmt;\n use std::hash::Hash;\n@@ -247,3 +247,10 @@ impl<HCX> HashStable<HCX> for WorkProductId {\n         self.hash.hash_stable(hcx, hasher)\n     }\n }\n+impl<HCX> ToStableHashKey<HCX> for WorkProductId {\n+    type KeyType = Fingerprint;\n+    #[inline]\n+    fn to_stable_hash_key(&self, _: &HCX) -> Self::KeyType {\n+        self.hash\n+    }\n+}"}]}