{"sha": "8332fe81d888aaa081bf85e5695eaabd2624ea73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMzJmZTgxZDg4OGFhYTA4MWJmODVlNTY5NWVhYWJkMjYyNGVhNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T21:56:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T21:56:37Z"}, "message": "Auto merge of #5894 - tmiasko:self-assignment, r=Manishearth\n\nWarn about explicit self-assignment\n\nWarn about assignments where left-hand side place expression is the same\nas right-hand side value expression. For example, warn about assignment in:\n\n```rust\npub struct Event {\n    id: usize,\n    x: i32,\n    y: i32,\n}\n\npub fn copy_position(a: &mut Event, b: &Event) {\n    a.x = b.x;\n    a.y = a.y;\n}\n```\n\nchangelog: New lint `self_assignment`, checks for explicit self-assignments.", "tree": {"sha": "d44d58b8093ea749dd64d37f188c41a9bc7a9e1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44d58b8093ea749dd64d37f188c41a9bc7a9e1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8332fe81d888aaa081bf85e5695eaabd2624ea73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8332fe81d888aaa081bf85e5695eaabd2624ea73", "html_url": "https://github.com/rust-lang/rust/commit/8332fe81d888aaa081bf85e5695eaabd2624ea73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8332fe81d888aaa081bf85e5695eaabd2624ea73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7", "html_url": "https://github.com/rust-lang/rust/commit/8d0d89adc81be1fa7766ff17aa4f2c6d5e8c69f7"}, {"sha": "4f4abf4e0640edbb1614f3dcb8ff62e8afc54801", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4abf4e0640edbb1614f3dcb8ff62e8afc54801", "html_url": "https://github.com/rust-lang/rust/commit/4f4abf4e0640edbb1614f3dcb8ff62e8afc54801"}], "stats": {"total": 318, "additions": 257, "deletions": 61}, "files": [{"sha": "5ce63c0a1574351c9b6de943086eda36a9374eb9", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -1690,6 +1690,7 @@ Released 2018-09-13\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n [`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n+[`self_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#self_assignment\n [`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n [`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse\n [`shadow_same`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_same"}, {"sha": "b3185b88840142253648eb1eb033dca657d20aa6", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method, SpanlessEq,\n+    eq_expr_value, get_trait_def_id, implements_trait, snippet_opt, span_lint_and_then, trait_ref_of_method,\n };\n use crate::utils::{higher, sugg};\n use if_chain::if_chain;\n@@ -70,11 +70,11 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n                         return;\n                     }\n                     // lhs op= l op r\n-                    if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, l) {\n+                    if eq_expr_value(cx, lhs, l) {\n                         lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n                     }\n                     // lhs op= l commutative_op r\n-                    if is_commutative(op.node) && SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, r) {\n+                    if is_commutative(op.node) && eq_expr_value(cx, lhs, r) {\n                         lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n                     }\n                 }\n@@ -161,14 +161,12 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n \n                     if visitor.counter == 1 {\n                         // a = a op b\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, l) {\n+                        if eq_expr_value(cx, assignee, l) {\n                             lint(assignee, r);\n                         }\n                         // a = b commutative_op a\n                         // Limited to primitive type as these ops are know to be commutative\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r)\n-                            && cx.typeck_results().expr_ty(assignee).is_primitive_ty()\n-                        {\n+                        if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n                             match op.node {\n                                 hir::BinOpKind::Add\n                                 | hir::BinOpKind::Mul\n@@ -253,7 +251,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if SpanlessEq::new(self.cx).ignore_fn().eq_expr(self.assignee, expr) {\n+        if eq_expr_value(self.cx, self.assignee, expr) {\n             self.counter += 1;\n         }\n "}, {"sha": "280a2c7fe6770c68987354a8c7bfc7f8c527ef02", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt, span_lint_and_sugg,\n-    span_lint_and_then, SpanlessEq,\n+    eq_expr_value, get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt,\n+    span_lint_and_sugg, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n             }\n         }\n         for (n, expr) in self.terminals.iter().enumerate() {\n-            if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e, expr) {\n+            if eq_expr_value(self.cx, e, expr) {\n                 #[allow(clippy::cast_possible_truncation)]\n                 return Ok(Bool::Term(n as u8));\n             }\n@@ -138,8 +138,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 if implements_ord(self.cx, e_lhs);\n                 if let ExprKind::Binary(expr_binop, expr_lhs, expr_rhs) = &expr.kind;\n                 if negate(e_binop.node) == Some(expr_binop.node);\n-                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_lhs, expr_lhs);\n-                if SpanlessEq::new(self.cx).ignore_fn().eq_expr(e_rhs, expr_rhs);\n+                if eq_expr_value(self.cx, e_lhs, expr_lhs);\n+                if eq_expr_value(self.cx, e_rhs, expr_rhs);\n                 then {\n                     #[allow(clippy::cast_possible_truncation)]\n                     return Ok(Bool::Not(Box::new(Bool::Term(n as u8))));"}, {"sha": "10a64769585e543bdbfd46ae8cd59287080bfd5f", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -1,5 +1,5 @@\n+use crate::utils::{eq_expr_value, SpanlessEq, SpanlessHash};\n use crate::utils::{get_parent_expr, higher, if_sequence, snippet, span_lint_and_note, span_lint_and_then};\n-use crate::utils::{SpanlessEq, SpanlessHash};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -197,8 +197,7 @@ fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n         h.finish()\n     };\n \n-    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool =\n-        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n+    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool { eq_expr_value(cx, lhs, rhs) };\n \n     for (i, j) in search_same(conds, hash, eq) {\n         span_lint_and_note(\n@@ -222,7 +221,7 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n \n     let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n         // Do not spawn warning if `IFS_SAME_COND` already produced it.\n-        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) {\n+        if eq_expr_value(cx, lhs, rhs) {\n             return false;\n         }\n         SpanlessEq::new(cx).eq_expr(lhs, rhs)"}, {"sha": "19f56195ec1b483d693c8e20d6464ca4864c0fa9", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -6,7 +6,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n \n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{eq_expr_value, snippet_with_applicability, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for double comparisons that could be simplified to a single expression.\n@@ -46,8 +46,7 @@ impl<'tcx> DoubleComparisons {\n             },\n             _ => return,\n         };\n-        let mut spanless_eq = SpanlessEq::new(cx).ignore_fn();\n-        if !(spanless_eq.eq_expr(&llhs, &rlhs) && spanless_eq.eq_expr(&lrhs, &rrhs)) {\n+        if !(eq_expr_value(cx, &llhs, &rlhs) && eq_expr_value(cx, &lrhs, &rrhs)) {\n             return;\n         }\n         macro_rules! lint_double_comparison {"}, {"sha": "e16ec783fab79c6c6744bcfaa958786ca7e912e5", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq,\n+    eq_expr_value, implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then,\n };\n use rustc_errors::Applicability;\n use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind};\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n             if macro_with_not_op(&left.kind) || macro_with_not_op(&right.kind) {\n                 return;\n             }\n-            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n+            if is_valid_operator(op) && eq_expr_value(cx, left, right) {\n                 span_lint(\n                     cx,\n                     EQ_OP,"}, {"sha": "1b02cee126d03b71af78ed69cba56e3cddbd9905", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -2,7 +2,7 @@ use crate::consts::{\n     constant, constant_simple, Constant,\n     Constant::{Int, F32, F64},\n };\n-use crate::utils::{get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n+use crate::utils::{eq_expr_value, get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -363,8 +363,8 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lmul_lhs, ref lmul_rhs) = add_lhs.kind;\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref rmul_lhs, ref rmul_rhs) = add_rhs.kind;\n-            if are_exprs_equal(cx, lmul_lhs, lmul_rhs);\n-            if are_exprs_equal(cx, rmul_lhs, rmul_rhs);\n+            if eq_expr_value(cx, lmul_lhs, lmul_rhs);\n+            if eq_expr_value(cx, rmul_lhs, rmul_rhs);\n             then {\n                 return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &lmul_lhs, \"..\"), Sugg::hir(cx, &rmul_lhs, \"..\")));\n             }\n@@ -502,8 +502,8 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n-            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n-            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, right) && eq_expr_value(cx, left, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, left) && eq_expr_value(cx, right, test),\n             _ => false,\n         }\n     } else {\n@@ -515,19 +515,15 @@ fn is_testing_positive(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -\n fn is_testing_negative(cx: &LateContext<'_>, expr: &Expr<'_>, test: &Expr<'_>) -> bool {\n     if let ExprKind::Binary(Spanned { node: op, .. }, left, right) = expr.kind {\n         match op {\n-            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && are_exprs_equal(cx, right, test),\n-            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && are_exprs_equal(cx, left, test),\n+            BinOpKind::Gt | BinOpKind::Ge => is_zero(cx, left) && eq_expr_value(cx, right, test),\n+            BinOpKind::Lt | BinOpKind::Le => is_zero(cx, right) && eq_expr_value(cx, left, test),\n             _ => false,\n         }\n     } else {\n         false\n     }\n }\n \n-fn are_exprs_equal(cx: &LateContext<'_>, expr1: &Expr<'_>, expr2: &Expr<'_>) -> bool {\n-    SpanlessEq::new(cx).ignore_fn().eq_expr(expr1, expr2)\n-}\n-\n /// Returns true iff expr is some zero literal\n fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match constant_simple(cx, cx.typeck_results(), expr) {\n@@ -546,12 +542,12 @@ fn is_zero(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n /// returns None.\n fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a>) -> Option<(bool, &'a Expr<'a>)> {\n     if let ExprKind::Unary(UnOp::UnNeg, expr1_negated) = &expr1.kind {\n-        if are_exprs_equal(cx, expr1_negated, expr2) {\n+        if eq_expr_value(cx, expr1_negated, expr2) {\n             return Some((false, expr2));\n         }\n     }\n     if let ExprKind::Unary(UnOp::UnNeg, expr2_negated) = &expr2.kind {\n-        if are_exprs_equal(cx, expr1, expr2_negated) {\n+        if eq_expr_value(cx, expr1, expr2_negated) {\n             return Some((true, expr1));\n         }\n     }\n@@ -614,7 +610,7 @@ fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>\n                 args_a.len() == args_b.len() &&\n                 (\n                     [\"ln\", \"log2\", \"log10\"].contains(&&*method_name_a.as_str()) ||\n-                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && are_exprs_equal(cx, &args_a[1], &args_b[1])\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && eq_expr_value(cx, &args_a[1], &args_b[1])\n                 );\n         }\n     }"}, {"sha": "87c297e72eb0ba71c8d850ea507e89af5e2c19e1", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -284,6 +284,7 @@ mod reference;\n mod regex;\n mod repeat_once;\n mod returns;\n+mod self_assignment;\n mod serde_api;\n mod shadow;\n mod single_component_path_imports;\n@@ -773,6 +774,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &repeat_once::REPEAT_ONCE,\n         &returns::LET_AND_RETURN,\n         &returns::NEEDLESS_RETURN,\n+        &self_assignment::SELF_ASSIGNMENT,\n         &serde_api::SERDE_API_MISUSE,\n         &shadow::SHADOW_REUSE,\n         &shadow::SHADOW_SAME,\n@@ -1090,6 +1092,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n     store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n+    store.register_late_pass(|| box self_assignment::SelfAssignment);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1421,6 +1424,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&repeat_once::REPEAT_ONCE),\n         LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n+        LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n@@ -1714,6 +1718,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::MUT_FROM_REF),\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&regex::INVALID_REGEX),\n+        LintId::of(&self_assignment::SELF_ASSIGNMENT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),"}, {"sha": "dbc676ae22408b139172a742361ca9ac7e511003", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -7,8 +7,8 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n-    span_lint_and_sugg, SpanlessEq,\n+    eq_expr_value, higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n+    span_lint_and_sugg,\n };\n \n declare_clippy_lint! {\n@@ -65,7 +65,7 @@ impl QuestionMark {\n                         if let ExprKind::Block(block, None) = &else_.kind;\n                         if block.stmts.is_empty();\n                         if let Some(block_expr) = &block.expr;\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(subject, block_expr);\n+                        if eq_expr_value(cx, subject, block_expr);\n                         then {\n                             replacement = Some(format!(\"Some({}?)\", receiver_str));\n                         }"}, {"sha": "e096c9aebc122fe8b7a53ef15d446fce2512d442", "filename": "clippy_lints/src/self_assignment.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fself_assignment.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -0,0 +1,51 @@\n+use crate::utils::{eq_expr_value, snippet, span_lint};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit self-assignments.\n+    ///\n+    /// **Why is this bad?** Self-assignments are redundant and unlikely to be\n+    /// intentional.\n+    ///\n+    /// **Known problems:** If expression contains any deref coercions or\n+    /// indexing operations they are assumed not to have any side effects.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct Event {\n+    ///     id: usize,\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    ///\n+    /// fn copy_position(a: &mut Event, b: &Event) {\n+    ///     a.x = b.x;\n+    ///     a.y = a.y;\n+    /// }\n+    /// ```\n+    pub SELF_ASSIGNMENT,\n+    correctness,\n+    \"explicit self-assignment\"\n+}\n+\n+declare_lint_pass!(SelfAssignment => [SELF_ASSIGNMENT]);\n+\n+impl<'tcx> LateLintPass<'tcx> for SelfAssignment {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Assign(lhs, rhs, _) = &expr.kind {\n+            if eq_expr_value(cx, lhs, rhs) {\n+                let lhs = snippet(cx, lhs.span, \"<lhs>\");\n+                let rhs = snippet(cx, rhs.span, \"<rhs>\");\n+                span_lint(\n+                    cx,\n+                    SELF_ASSIGNMENT,\n+                    expr.span,\n+                    &format!(\"self-assignment of `{}` to `{}`\", rhs, lhs),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "cc39f060fc7f3929a69ed1860ca789a6dfbc6e54", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    differing_macro_contexts, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then, walk_ptrs_ty,\n-    SpanlessEq,\n+    differing_macro_contexts, eq_expr_value, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_then,\n+    walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -92,8 +92,8 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if rhs2.segments.len() == 1;\n \n             if ident.as_str() == rhs2.segments[0].ident.as_str();\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1);\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n+            if eq_expr_value(cx, tmp_init, lhs1);\n+            if eq_expr_value(cx, rhs1, lhs2);\n             then {\n                 if let ExprKind::Field(ref lhs1, _) = lhs1.kind {\n                     if let ExprKind::Field(ref lhs2, _) = lhs2.kind {\n@@ -193,7 +193,7 @@ enum Slice<'a> {\n fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n+            if eq_expr_value(cx, lhs1, lhs2) {\n                 let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n \n                 if matches!(ty.kind, ty::Slice(_))\n@@ -221,8 +221,8 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n             if !differing_macro_contexts(first.span, second.span);\n             if let ExprKind::Assign(ref lhs0, ref rhs0, _) = first.kind;\n             if let ExprKind::Assign(ref lhs1, ref rhs1, _) = second.kind;\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n+            if eq_expr_value(cx, lhs0, rhs1);\n+            if eq_expr_value(cx, lhs1, rhs0);\n             then {\n                 let lhs0 = Sugg::hir_opt(cx, lhs0);\n                 let rhs0 = Sugg::hir_opt(cx, rhs0);"}, {"sha": "cacc9f8d6f2724420cd0d69ace868403580dc61b", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -23,23 +23,22 @@ pub struct SpanlessEq<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n     maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n-    /// If is true, never consider as equal expressions containing function\n-    /// calls.\n-    ignore_fn: bool,\n+    allow_side_effects: bool,\n }\n \n impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             maybe_typeck_results: cx.maybe_typeck_results(),\n-            ignore_fn: false,\n+            allow_side_effects: true,\n         }\n     }\n \n-    pub fn ignore_fn(self) -> Self {\n+    /// Consider expressions containing potential side effects as not equal.\n+    pub fn deny_side_effects(self) -> Self {\n         Self {\n-            ignore_fn: true,\n+            allow_side_effects: false,\n             ..self\n         }\n     }\n@@ -67,7 +66,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     #[allow(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if self.ignore_fn && differing_macro_contexts(left.span, right.span) {\n+        if !self.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n \n@@ -90,10 +89,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n-                self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n-                lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n             (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n@@ -108,7 +107,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n             (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n-                !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n+                self.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n             | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n@@ -134,7 +133,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                     })\n             },\n             (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n-                !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+                self.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n@@ -340,6 +339,11 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n+/// Checks if two expressions evaluate to the same value, and don't contain any side effects.\n+pub fn eq_expr_value(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+    SpanlessEq::new(cx).deny_side_effects().eq_expr(left, right)\n+}\n+\n /// Type used to hash an ast element. This is different from the `Hash` trait\n /// on ast types as this\n /// trait would consider IDs and spans."}, {"sha": "8fa5d22210a3691f585b16256dc54e5464827d85", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -1,7 +1,6 @@\n-use crate::utils::SpanlessEq;\n use crate::utils::{\n     is_expn_of, match_def_path, match_qpath, match_type, method_calls, paths, run_lints, snippet, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty,\n+    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};\n@@ -493,7 +492,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n             if let ExprKind::MethodCall(ref ps, _, ref span_call_args, _) = &only_expr.kind;\n             let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n-            let mut sle = SpanlessEq::new(cx).ignore_fn();\n+            let mut sle = SpanlessEq::new(cx).deny_side_effects();\n             then {\n                 match &*ps.ident.as_str() {\n                     \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {"}, {"sha": "530552f79405c8acefd4a0bf945fbb89bf615feb", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -21,7 +21,7 @@ pub mod sugg;\n pub mod usage;\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n-pub use self::hir_utils::{both, over, SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n \n use std::borrow::Cow;\n use std::mem;"}, {"sha": "bf58c117aaaa95c24a5a9154f1673fdbf577fc5e", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -1956,6 +1956,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"self_assignment\",\n+        group: \"correctness\",\n+        desc: \"explicit self-assignment\",\n+        deprecation: None,\n+        module: \"self_assignment\",\n+    },\n     Lint {\n         name: \"serde_api_misuse\",\n         group: \"correctness\","}, {"sha": "a7cbb9cd78b151cb82b9f415c59a170be1541e2e", "filename": "tests/ui/self_assignment.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/tests%2Fui%2Fself_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/tests%2Fui%2Fself_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself_assignment.rs?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -0,0 +1,67 @@\n+#![warn(clippy::self_assignment)]\n+\n+pub struct S<'a> {\n+    a: i32,\n+    b: [i32; 10],\n+    c: Vec<Vec<i32>>,\n+    e: &'a mut i32,\n+    f: &'a mut i32,\n+}\n+\n+pub fn positives(mut a: usize, b: &mut u32, mut s: S) {\n+    a = a;\n+    *b = *b;\n+    s = s;\n+    s.a = s.a;\n+    s.b[10] = s.b[5 + 5];\n+    s.c[0][1] = s.c[0][1];\n+    s.b[a] = s.b[a];\n+    *s.e = *s.e;\n+    s.b[a + 10] = s.b[10 + a];\n+\n+    let mut t = (0, 1);\n+    t.1 = t.1;\n+    t.0 = (t.0);\n+}\n+\n+pub fn negatives_not_equal(mut a: usize, b: &mut usize, mut s: S) {\n+    dbg!(&a);\n+    a = *b;\n+    dbg!(&a);\n+    s.b[1] += s.b[1];\n+    s.b[1] = s.b[2];\n+    s.c[1][0] = s.c[0][1];\n+    s.b[a] = s.b[*b];\n+    s.b[a + 10] = s.b[a + 11];\n+    *s.e = *s.f;\n+\n+    let mut t = (0, 1);\n+    t.0 = t.1;\n+}\n+\n+#[allow(clippy::eval_order_dependence)]\n+pub fn negatives_side_effects() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let mut i = 0;\n+    v[{\n+        i += 1;\n+        i\n+    }] = v[{\n+        i += 1;\n+        i\n+    }];\n+\n+    fn next(n: &mut usize) -> usize {\n+        let v = *n;\n+        *n += 1;\n+        v\n+    }\n+\n+    let mut w = vec![1, 2, 3, 4, 5];\n+    let mut i = 0;\n+    let i = &mut i;\n+    w[next(i)] = w[next(i)];\n+    w[next(i)] = w[next(i)];\n+}\n+\n+fn main() {}"}, {"sha": "826e0d0ba888dacda4a21b006fed23157c67f22f", "filename": "tests/ui/self_assignment.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8332fe81d888aaa081bf85e5695eaabd2624ea73/tests%2Fui%2Fself_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8332fe81d888aaa081bf85e5695eaabd2624ea73/tests%2Fui%2Fself_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself_assignment.stderr?ref=8332fe81d888aaa081bf85e5695eaabd2624ea73", "patch": "@@ -0,0 +1,70 @@\n+error: self-assignment of `a` to `a`\n+  --> $DIR/self_assignment.rs:12:5\n+   |\n+LL |     a = a;\n+   |     ^^^^^\n+   |\n+   = note: `-D clippy::self-assignment` implied by `-D warnings`\n+\n+error: self-assignment of `*b` to `*b`\n+  --> $DIR/self_assignment.rs:13:5\n+   |\n+LL |     *b = *b;\n+   |     ^^^^^^^\n+\n+error: self-assignment of `s` to `s`\n+  --> $DIR/self_assignment.rs:14:5\n+   |\n+LL |     s = s;\n+   |     ^^^^^\n+\n+error: self-assignment of `s.a` to `s.a`\n+  --> $DIR/self_assignment.rs:15:5\n+   |\n+LL |     s.a = s.a;\n+   |     ^^^^^^^^^\n+\n+error: self-assignment of `s.b[5 + 5]` to `s.b[10]`\n+  --> $DIR/self_assignment.rs:16:5\n+   |\n+LL |     s.b[10] = s.b[5 + 5];\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `s.c[0][1]` to `s.c[0][1]`\n+  --> $DIR/self_assignment.rs:17:5\n+   |\n+LL |     s.c[0][1] = s.c[0][1];\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `s.b[a]` to `s.b[a]`\n+  --> $DIR/self_assignment.rs:18:5\n+   |\n+LL |     s.b[a] = s.b[a];\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `*s.e` to `*s.e`\n+  --> $DIR/self_assignment.rs:19:5\n+   |\n+LL |     *s.e = *s.e;\n+   |     ^^^^^^^^^^^\n+\n+error: self-assignment of `s.b[10 + a]` to `s.b[a + 10]`\n+  --> $DIR/self_assignment.rs:20:5\n+   |\n+LL |     s.b[a + 10] = s.b[10 + a];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: self-assignment of `t.1` to `t.1`\n+  --> $DIR/self_assignment.rs:23:5\n+   |\n+LL |     t.1 = t.1;\n+   |     ^^^^^^^^^\n+\n+error: self-assignment of `(t.0)` to `t.0`\n+  --> $DIR/self_assignment.rs:24:5\n+   |\n+LL |     t.0 = (t.0);\n+   |     ^^^^^^^^^^^\n+\n+error: aborting due to 11 previous errors\n+"}]}