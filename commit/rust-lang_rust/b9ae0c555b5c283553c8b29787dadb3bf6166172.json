{"sha": "b9ae0c555b5c283553c8b29787dadb3bf6166172", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YWUwYzU1NWI1YzI4MzU1M2M4YjI5Nzg3ZGFkYjNiZjYxNjYxNzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-19T23:44:24Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-19T23:59:28Z"}, "message": "syntax: Funnel all words through a single keyword table", "tree": {"sha": "8c624ee8e031de007341ebeb93ddf5c9cf73ca88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c624ee8e031de007341ebeb93ddf5c9cf73ca88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9ae0c555b5c283553c8b29787dadb3bf6166172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9ae0c555b5c283553c8b29787dadb3bf6166172", "html_url": "https://github.com/rust-lang/rust/commit/b9ae0c555b5c283553c8b29787dadb3bf6166172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9ae0c555b5c283553c8b29787dadb3bf6166172/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f641dce852a66417a5fa6b2c7ccf252a2ea590d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f641dce852a66417a5fa6b2c7ccf252a2ea590d7", "html_url": "https://github.com/rust-lang/rust/commit/f641dce852a66417a5fa6b2c7ccf252a2ea590d7"}], "stats": {"total": 63, "additions": 53, "deletions": 10}, "files": [{"sha": "dd8caa9a5ccfdf9d11befa67a9b5829ba96a2e4d", "filename": "src/librustsyntax/parse.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9ae0c555b5c283553c8b29787dadb3bf6166172/src%2Flibrustsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ae0c555b5c283553c8b29787dadb3bf6166172/src%2Flibrustsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse.rs?ref=b9ae0c555b5c283553c8b29787dadb3bf6166172", "patch": "@@ -77,6 +77,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n       mut restriction: parser::UNRESTRICTED,\n       reader: rdr,\n       binop_precs: prec::binop_prec_table(),\n+      keywords: token::keyword_table(),\n       bad_expr_words: token::bad_expr_word_table()}\n }\n "}, {"sha": "52f9bc2989650f27b1ed2b135240dae87c289cd0", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b9ae0c555b5c283553c8b29787dadb3bf6166172/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ae0c555b5c283553c8b29787dadb3bf6166172/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=b9ae0c555b5c283553c8b29787dadb3bf6166172", "patch": "@@ -49,6 +49,7 @@ type parser = @{\n     mut restriction: restriction,\n     reader: reader,\n     binop_precs: @[op_spec],\n+    keywords: hashmap<str, ()>,\n     bad_expr_words: hashmap<str, ()>\n };\n \n@@ -83,6 +84,9 @@ impl parser for parser {\n     fn span_fatal(sp: span, m: str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n+    fn bug(m: str) -> ! {\n+        self.sess.span_diagnostic.span_bug(self.span, m)\n+    }\n     fn warn(m: str) {\n         self.sess.span_diagnostic.span_warn(self.span, m)\n     }\n@@ -161,14 +165,23 @@ fn eat(p: parser, tok: token::token) -> bool {\n     ret if p.token == tok { p.bump(); true } else { false };\n }\n \n+// A sanity check that the word we are asking for is a known keyword\n+fn require_keyword(p: parser, word: str) {\n+    if !p.keywords.contains_key(word) {\n+        p.bug(#fmt(\"unknown keyword: %s\", word));\n+    }\n+}\n+\n fn is_word(p: parser, word: str) -> bool {\n+    require_keyword(p, word);\n     ret alt p.token {\n           token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n           _ { false }\n         };\n }\n \n fn eat_word(p: parser, word: str) -> bool {\n+    require_keyword(p, word);\n     alt p.token {\n       token::IDENT(sid, false) {\n         if str::eq(word, p.get_str(sid)) {\n@@ -181,6 +194,7 @@ fn eat_word(p: parser, word: str) -> bool {\n }\n \n fn expect_word(p: parser, word: str) {\n+    require_keyword(p, word);\n     if !eat_word(p, word) {\n         p.fatal(\"expecting \" + word + \", found \" +\n                     token_to_str(p.reader, p.token));\n@@ -386,6 +400,9 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n fn region_from_name(p: parser, s: option<str>) -> ast::region {\n     let r = alt s {\n       some (string) {\n+        // FIXME: To be consistent with our type resolution the\n+        // static region should probably be resolved during type\n+        // checking, not in the parser.\n         if string == \"static\" {\n             ast::re_static\n         } else {\n@@ -2578,14 +2595,7 @@ fn parse_view_item(p: parser) -> @ast::view_item {\n }\n \n fn is_view_item(p: parser) -> bool {\n-    alt p.token {\n-      token::IDENT(sid, false) {\n-        let st = p.get_str(sid);\n-        ret str::eq(st, \"use\") || str::eq(st, \"import\") ||\n-                str::eq(st, \"export\");\n-      }\n-      _ { ret false; }\n-    }\n+    is_word(p, \"use\") || is_word(p, \"import\") || is_word(p, \"export\")\n }\n \n fn maybe_parse_view("}, {"sha": "f60e2f2638114229b3f78dfdf195f14e47c9dd52", "filename": "src/librustsyntax/parse/token.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b9ae0c555b5c283553c8b29787dadb3bf6166172/src%2Flibrustsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9ae0c555b5c283553c8b29787dadb3bf6166172/src%2Flibrustsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Ftoken.rs?ref=b9ae0c555b5c283553c8b29787dadb3bf6166172", "patch": "@@ -217,6 +217,38 @@ fn is_bad_expr_word(t: token,\n     }\n }\n \n+#[doc = \"\n+All the valid words that have meaning in the Rust language. Some of these are\n+nonetheless valid as identifiers becasue they are unambiguous.\n+\"]\n+fn keyword_table() -> hashmap<str, ()> {\n+    let keywords = str_hash();\n+    bad_expr_word_table().keys() {|word|\n+        keywords.insert(word, ());\n+    }\n+    let other_keywords = [\n+        \"as\",\n+        \"bind\",\n+        \"else\",\n+        \"false\",\n+        \"implements\",\n+        \"move\",\n+        \"of\",\n+        \"priv\",\n+        \"self\",\n+        \"send\",\n+        \"static\",\n+        \"to\",\n+        \"true\",\n+        \"use\",\n+        \"with\"\n+    ];\n+    for other_keywords.each {|word|\n+        keywords.insert(word, ());\n+    }\n+    ret keywords;\n+}\n+\n #[doc = \"\n These are the words that shouldn't be allowed as value identifiers,\n because, if used at the start of a line, they will cause the line to be\n@@ -228,8 +260,8 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                 \"class\", \"const\", \"cont\", \"copy\", \"crust\", \"do\", \"else\",\n                 \"enum\", \"export\", \"fail\", \"fn\", \"for\", \"if\",  \"iface\",\n                 \"impl\", \"import\", \"let\", \"log\", \"loop\", \"mod\",\n-                \"mut\", \"native\", \"pure\", \"resource\", \"ret\", \"trait\",\n-                \"type\", \"unchecked\", \"unsafe\", \"while\", \"new\"];\n+                \"mut\", \"mutable\", \"native\", \"new\", \"pure\", \"resource\",\n+                \"ret\", \"trait\", \"type\", \"unchecked\", \"unsafe\", \"while\"];\n     for keys.each {|word|\n         words.insert(word, ());\n     }"}]}