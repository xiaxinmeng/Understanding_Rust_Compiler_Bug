{"sha": "2acf32d9adff836a3111c039e4e10a48ee5c79b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhY2YzMmQ5YWRmZjgzNmEzMTExYzAzOWU0ZTEwYTQ4ZWU1Yzc5YjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-28T00:36:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-28T00:36:57Z"}, "message": "Auto merge of #70483 - Centril:rollup-slli4yf, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #70345 (Remove `no_integrated_as` mode.)\n - #70434 (suggest `;` on expr `mac!()` which is good as stmt `mac!()`)\n - #70457 (non-exhastive diagnostic: add note re. scrutinee type)\n - #70478 (Refactor type_of for constants)\n - #70480 (clarify hir_id <-> node_id method names)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "54bf628dc56409a7273de8a463eb89f9842e3296", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54bf628dc56409a7273de8a463eb89f9842e3296"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2acf32d9adff836a3111c039e4e10a48ee5c79b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2acf32d9adff836a3111c039e4e10a48ee5c79b5", "html_url": "https://github.com/rust-lang/rust/commit/2acf32d9adff836a3111c039e4e10a48ee5c79b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2acf32d9adff836a3111c039e4e10a48ee5c79b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4", "html_url": "https://github.com/rust-lang/rust/commit/0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4"}, {"sha": "a023e6121f4310f259378588bc60a4cf8b339fb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a023e6121f4310f259378588bc60a4cf8b339fb0", "html_url": "https://github.com/rust-lang/rust/commit/a023e6121f4310f259378588bc60a4cf8b339fb0"}], "stats": {"total": 738, "additions": 485, "deletions": 253}, "files": [{"sha": "70ea856498de4def00c12ea80b1e381f7e1df649", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -241,8 +241,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-            let node_id = self.definitions.hir_to_node_id(hir_id);\n-            assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n+            let node_id = self.definitions.hir_id_to_node_id(hir_id);\n+            assert_eq!(self.definitions.node_id_to_hir_id(node_id), hir_id);\n \n             if hir_id.owner != self.current_dep_node_owner {\n                 let node_str = match self.definitions.opt_local_def_id(node_id) {\n@@ -342,7 +342,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(\n             i.hir_id.owner,\n-            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(i.hir_id)).unwrap()\n+            self.definitions\n+                .opt_local_def_id(self.definitions.hir_id_to_node_id(i.hir_id))\n+                .unwrap()\n         );\n         self.with_dep_node_owner(i.hir_id.owner, i, |this, hash| {\n             this.insert_with_hash(i.span, i.hir_id, Node::Item(i), hash);\n@@ -374,7 +376,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n         debug_assert_eq!(\n             ti.hir_id.owner,\n-            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(ti.hir_id)).unwrap()\n+            self.definitions\n+                .opt_local_def_id(self.definitions.hir_id_to_node_id(ti.hir_id))\n+                .unwrap()\n         );\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this, hash| {\n             this.insert_with_hash(ti.span, ti.hir_id, Node::TraitItem(ti), hash);\n@@ -388,7 +392,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n         debug_assert_eq!(\n             ii.hir_id.owner,\n-            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(ii.hir_id)).unwrap()\n+            self.definitions\n+                .opt_local_def_id(self.definitions.hir_id_to_node_id(ii.hir_id))\n+                .unwrap()\n         );\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this, hash| {\n             this.insert_with_hash(ii.span, ii.hir_id, Node::ImplItem(ii), hash);"}, {"sha": "e8ce13e06e9f55b62a36e666d14a7ac56d4d2fd3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -161,7 +161,7 @@ impl<'hir> Map<'hir> {\n     #[inline]\n     pub fn local_def_id_from_node_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id_from_node_id(node).unwrap_or_else(|| {\n-            let hir_id = self.node_to_hir_id(node);\n+            let hir_id = self.node_id_to_hir_id(node);\n             bug!(\n                 \"local_def_id_from_node_id: no entry for `{}`, which has a map of `{:?}`\",\n                 node,\n@@ -184,7 +184,7 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<DefId> {\n-        let node_id = self.hir_to_node_id(hir_id);\n+        let node_id = self.hir_id_to_node_id(hir_id);\n         self.opt_local_def_id_from_node_id(node_id)\n     }\n \n@@ -204,13 +204,13 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn hir_to_node_id(&self, hir_id: HirId) -> NodeId {\n-        self.tcx.definitions.hir_to_node_id(hir_id)\n+    pub fn hir_id_to_node_id(&self, hir_id: HirId) -> NodeId {\n+        self.tcx.definitions.hir_id_to_node_id(hir_id)\n     }\n \n     #[inline]\n-    pub fn node_to_hir_id(&self, node_id: NodeId) -> HirId {\n-        self.tcx.definitions.node_to_hir_id(node_id)\n+    pub fn node_id_to_hir_id(&self, node_id: NodeId) -> HirId {\n+        self.tcx.definitions.node_id_to_hir_id(node_id)\n     }\n \n     #[inline]"}, {"sha": "d58aa383667e45afc1846953cc6f8934f2839434", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -137,7 +137,7 @@ impl<'a> StableHashingContext<'a> {\n \n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n-        self.definitions.node_to_hir_id(node_id)\n+        self.definitions.node_id_to_hir_id(node_id)\n     }\n \n     #[inline]"}, {"sha": "0ab91d7e1127d618013c652407e99b233c58a9a5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -1126,11 +1126,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (k, v) in resolutions.trait_map {\n-            let hir_id = definitions.node_to_hir_id(k);\n+            let hir_id = definitions.node_id_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n             let v = v\n                 .into_iter()\n-                .map(|tc| tc.map_import_ids(|id| definitions.node_to_hir_id(id)))\n+                .map(|tc| tc.map_import_ids(|id| definitions.node_id_to_hir_id(id)))\n                 .collect();\n             map.insert(hir_id.local_id, StableVec::new(v));\n         }\n@@ -1154,7 +1154,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .map(|(k, v)| {\n                     let exports: Vec<_> = v\n                         .into_iter()\n-                        .map(|e| e.map_id(|id| definitions.node_to_hir_id(id)))\n+                        .map(|e| e.map_id(|id| definitions.node_id_to_hir_id(id)))\n                         .collect();\n                     (k, exports)\n                 })"}, {"sha": "77cae038fe52ab8f24d0050bdf3fff1ca7f42fa6", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -16,9 +16,7 @@ use crate::ModuleLlvm;\n use log::debug;\n use rustc::bug;\n use rustc::ty::TyCtxt;\n-use rustc_codegen_ssa::back::write::{\n-    run_assembler, BitcodeSection, CodegenContext, EmitObj, ModuleConfig,\n-};\n+use rustc_codegen_ssa::back::write::{BitcodeSection, CodegenContext, EmitObj, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen, RLIB_BYTECODE_EXTENSION};\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -734,53 +732,41 @@ pub(crate) unsafe fn codegen(\n             })?;\n         }\n \n-        let config_emit_object_code = matches!(config.emit_obj, EmitObj::ObjectCode(_));\n-\n-        if config.emit_asm || (config_emit_object_code && config.no_integrated_as) {\n+        if config.emit_asm {\n             let _timer = cgcx\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n             let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n-            // We can't use the same module for asm and binary output, because that triggers\n-            // various errors like invalid IR or broken binaries, so we might have to clone the\n-            // module to produce the asm output\n-            let llmod = if config_emit_object_code { llvm::LLVMCloneModule(llmod) } else { llmod };\n+            // We can't use the same module for asm and object code output,\n+            // because that triggers various errors like invalid IR or broken\n+            // binaries. So we must clone the module to produce the asm output\n+            // if we are also producing object code.\n+            let llmod = if let EmitObj::ObjectCode(_) = config.emit_obj {\n+                llvm::LLVMCloneModule(llmod)\n+            } else {\n+                llmod\n+            };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(diag_handler, tm, cpm, llmod, &path, llvm::FileType::AssemblyFile)\n             })?;\n         }\n \n         match config.emit_obj {\n             EmitObj::ObjectCode(_) => {\n-                if !config.no_integrated_as {\n-                    let _timer = cgcx.prof.generic_activity_with_arg(\n-                        \"LLVM_module_codegen_emit_obj\",\n-                        &module.name[..],\n-                    );\n-                    with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                        write_output_file(\n-                            diag_handler,\n-                            tm,\n-                            cpm,\n-                            llmod,\n-                            &obj_out,\n-                            llvm::FileType::ObjectFile,\n-                        )\n-                    })?;\n-                } else {\n-                    let _timer = cgcx.prof.generic_activity_with_arg(\n-                        \"LLVM_module_codegen_asm_to_obj\",\n-                        &module.name[..],\n-                    );\n-                    let assembly =\n-                        cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-                    run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n-\n-                    if !config.emit_asm && !cgcx.save_temps {\n-                        drop(fs::remove_file(&assembly));\n-                    }\n-                }\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(\n+                        diag_handler,\n+                        tm,\n+                        cpm,\n+                        llmod,\n+                        &obj_out,\n+                        llvm::FileType::ObjectFile,\n+                    )\n+                })?;\n             }\n \n             EmitObj::Bitcode => {\n@@ -802,6 +788,7 @@ pub(crate) unsafe fn codegen(\n \n         drop(handlers);\n     }\n+\n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n         config.emit_bc,"}, {"sha": "7833f22097c641e8570cf1b431874d5044b6d4f1", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 65, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -1,5 +1,4 @@\n-use super::command::Command;\n-use super::link::{self, get_linker, remove};\n+use super::link::{self, remove};\n use super::linker::LinkerInfo;\n use super::lto::{self, SerializedModule};\n use super::symbol_export::symbol_name_for_instance_in_crate;\n@@ -116,7 +115,6 @@ pub struct ModuleConfig {\n     pub merge_functions: bool,\n     pub inline_threshold: Option<usize>,\n     pub new_llvm_pass_manager: Option<bool>,\n-    pub no_integrated_as: bool,\n }\n \n impl ModuleConfig {\n@@ -140,7 +138,6 @@ impl ModuleConfig {\n             emit_ir: false,\n             emit_asm: false,\n             emit_obj: EmitObj::None,\n-            no_integrated_as: false,\n \n             verify_llvm_ir: false,\n             no_prepopulate_passes: false,\n@@ -202,12 +199,6 @@ impl ModuleConfig {\n     }\n }\n \n-/// Assembler name and command used by codegen when no_integrated_as is enabled\n-pub struct AssemblerCommand {\n-    name: PathBuf,\n-    cmd: Command,\n-}\n-\n // HACK(eddyb) work around `#[derive]` producing wrong bounds for `Clone`.\n pub struct TargetMachineFactory<B: WriteBackendMethods>(\n     pub Arc<dyn Fn() -> Result<B::TargetMachine, String> + Send + Sync>,\n@@ -260,8 +251,6 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub cgu_reuse_tracker: CguReuseTracker,\n     // Channel back to the main control thread to send messages to\n     pub coordinator_send: Sender<Box<dyn Any + Send>>,\n-    // The assembler command if no_integrated_as option is enabled, None otherwise\n-    pub assembler_cmd: Option<Arc<AssemblerCommand>>,\n }\n \n impl<B: WriteBackendMethods> CodegenContext<B> {\n@@ -415,9 +404,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n \n     modules_config.emit_pre_lto_bc = need_pre_lto_bitcode_for_incr_comp(sess);\n \n-    modules_config.no_integrated_as =\n-        tcx.sess.opts.cg.no_integrated_as || tcx.sess.target.target.options.no_integrated_as;\n-\n     for output_type in sess.opts.output_types.keys() {\n         match *output_type {\n             OutputType::Bitcode => {\n@@ -1030,17 +1016,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n     }));\n \n-    let assembler_cmd = if modules_config.no_integrated_as {\n-        // HACK: currently we use linker (gcc) as our assembler\n-        let (linker, flavor) = link::linker_and_flavor(sess);\n-\n-        let (name, mut cmd) = get_linker(sess, &linker, flavor);\n-        cmd.args(&sess.target.target.options.asm_args);\n-        Some(Arc::new(AssemblerCommand { name, cmd }))\n-    } else {\n-        None\n-    };\n-\n     let ol = if tcx.sess.opts.debugging_opts.no_codegen\n         || !tcx.sess.opts.output_types.should_codegen()\n     {\n@@ -1076,7 +1051,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n         target_arch: tcx.sess.target.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n-        assembler_cmd,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -1610,44 +1584,6 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n     });\n }\n \n-pub fn run_assembler<B: ExtraBackendMethods>(\n-    cgcx: &CodegenContext<B>,\n-    handler: &Handler,\n-    assembly: &Path,\n-    object: &Path,\n-) {\n-    let assembler = cgcx.assembler_cmd.as_ref().expect(\"cgcx.assembler_cmd is missing?\");\n-\n-    let pname = &assembler.name;\n-    let mut cmd = assembler.cmd.clone();\n-    cmd.arg(\"-c\").arg(\"-o\").arg(object).arg(assembly);\n-    debug!(\"{:?}\", cmd);\n-\n-    match cmd.output() {\n-        Ok(prog) => {\n-            if !prog.status.success() {\n-                let mut note = prog.stderr.clone();\n-                note.extend_from_slice(&prog.stdout);\n-\n-                handler\n-                    .struct_err(&format!(\n-                        \"linking with `{}` failed: {}\",\n-                        pname.display(),\n-                        prog.status\n-                    ))\n-                    .note(&format!(\"{:?}\", &cmd))\n-                    .note(str::from_utf8(&note[..]).unwrap())\n-                    .emit();\n-                handler.abort_if_errors();\n-            }\n-        }\n-        Err(e) => {\n-            handler.err(&format!(\"could not exec the linker `{}`: {}\", pname.display(), e));\n-            handler.abort_if_errors();\n-        }\n-    }\n-}\n-\n enum SharedEmitterMessage {\n     Diagnostic(Diagnostic),\n     InlineAsmError(u32, String),"}, {"sha": "0e70fdbd9c146f1657a3c05190b53d0b611d9e96", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -86,6 +86,7 @@ fn suggest_slice_pat(e: &mut DiagnosticBuilder<'_>, site_span: Span, parser: &Pa\n fn emit_frag_parse_err(\n     mut e: DiagnosticBuilder<'_>,\n     parser: &Parser<'_>,\n+    orig_parser: &mut Parser<'_>,\n     site_span: Span,\n     macro_ident: ast::Ident,\n     arm_span: Span,\n@@ -118,6 +119,21 @@ fn emit_frag_parse_err(\n         AstFragmentKind::Pat if macro_ident.name == sym::vec => {\n             suggest_slice_pat(&mut e, site_span, parser);\n         }\n+        // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n+        AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n+            Err(mut err) => err.cancel(),\n+            Ok(_) => {\n+                e.note(\n+                    \"the macro call doesn't expand to an expression, but it can expand to a statement\",\n+                );\n+                e.span_suggestion_verbose(\n+                    site_span.shrink_to_hi(),\n+                    \"add `;` to interpret the expansion as a statement\",\n+                    \";\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        },\n         _ => annotate_err_with_kind(&mut e, kind, site_span),\n     };\n     e.emit();\n@@ -126,10 +142,11 @@ fn emit_frag_parse_err(\n impl<'a> ParserAnyMacro<'a> {\n     crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro { site_span, macro_ident, ref mut parser, arm_span } = *self;\n+        let snapshot = &mut parser.clone();\n         let fragment = match parse_ast_fragment(parser, kind) {\n             Ok(f) => f,\n             Err(err) => {\n-                emit_frag_parse_err(err, parser, site_span, macro_ident, arm_span, kind);\n+                emit_frag_parse_err(err, parser, snapshot, site_span, macro_ident, arm_span, kind);\n                 return kind.dummy(site_span);\n             }\n         };"}, {"sha": "314af77f2ca1681779b3426dd43ba95404337622", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -353,15 +353,13 @@ impl Definitions {\n         }\n     }\n \n-    // FIXME(eddyb) rename to `hir_id_to_node_id`.\n     #[inline]\n-    pub fn hir_to_node_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n+    pub fn hir_id_to_node_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n         self.hir_id_to_node_id[&hir_id]\n     }\n \n-    // FIXME(eddyb) rename to `node_id_to_hir_id`.\n     #[inline]\n-    pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n+    pub fn node_id_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n         self.node_id_to_hir_id[node_id]\n     }\n "}, {"sha": "8a8ba8a96f7289edfa63204601fa4170acbbdb52", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -451,10 +451,6 @@ fn test_codegen_options_tracking_hash() {\n     opts.cg.prefer_dynamic = true;\n     assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n-    opts = reference.clone();\n-    opts.cg.no_integrated_as = true;\n-    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n     opts = reference.clone();\n     opts.cg.no_redzone = Some(true);\n     assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());"}, {"sha": "d241cc5d8a33368cdd54f81e2944671680c9d51c", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -644,7 +644,7 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n     }\n \n     let mut unsafe_blocks: Vec<_> = unsafe_blocks.iter().collect();\n-    unsafe_blocks.sort_by_cached_key(|(hir_id, _)| tcx.hir().hir_to_node_id(*hir_id));\n+    unsafe_blocks.sort_by_cached_key(|(hir_id, _)| tcx.hir().hir_id_to_node_id(*hir_id));\n     let used_unsafe: FxHashSet<_> =\n         unsafe_blocks.iter().flat_map(|&&(id, used)| used.then_some(id)).collect();\n     for &(block_id, is_used) in unsafe_blocks {"}, {"sha": "e29bbf8fa6eb13d740d135476cc5242fe39d9435", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -241,6 +241,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             }\n \n             adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n+            err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n             err.emit();\n         });\n     }\n@@ -483,6 +484,7 @@ fn check_exhaustive<'p, 'tcx>(\n         \"ensure that all possible cases are being handled, \\\n          possibly by adding wildcards or more match arms\",\n     );\n+    err.note(&format!(\"the matched value is of type `{}`\", scrut_ty));\n     err.emit();\n }\n "}, {"sha": "c0ac9e7f6b61ff1b62540960a16705a84aad9733", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -225,7 +225,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             collector.visit_pat(&arg.pat);\n \n             for (id, ident, ..) in collector.collected_idents {\n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n@@ -268,7 +268,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n         self.nest_tables(id, |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(id, ident, span) {\n                 v.process_formals(&sig.decl.inputs, &method_data.qualname);\n@@ -308,7 +308,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            let hir_id = self.tcx.hir().node_to_hir_id(field.id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(field.id);\n             self.dumper.dump_def(&access_from!(self.save_ctxt, field, hir_id), field_data);\n         }\n     }\n@@ -360,7 +360,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         ty_params: &'l ast::Generics,\n         body: Option<&'l ast::Block>,\n     ) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n         self.nest_tables(item.id, |v| {\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n@@ -402,7 +402,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         typ: &'l ast::Ty,\n         expr: Option<&'l ast::Expr>,\n     ) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n         self.nest_tables(item.id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n@@ -429,7 +429,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n-            let hir_id = self.tcx.hir().node_to_hir_id(id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n \n             self.dumper.dump_def(\n                 &access_from_vis!(self.save_ctxt, vis, hir_id),\n@@ -503,7 +503,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n-            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n@@ -546,7 +546,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n         for variant in &enum_definition.variants {\n@@ -699,7 +699,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             let id = id_from_node_id(item.id, &self.save_ctxt);\n             let span = self.span_from_span(item.ident.span);\n             let children = methods.iter().map(|i| id_from_node_id(i.id, &self.save_ctxt)).collect();\n-            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n@@ -759,7 +759,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(&access_from!(self.save_ctxt, item, hir_id), mod_data);\n         }\n     }\n@@ -864,7 +864,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         match p.kind {\n             PatKind::Struct(ref _path, ref fields, _) => {\n                 // FIXME do something with _path?\n-                let hir_id = self.tcx.hir().node_to_hir_id(p.id);\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(p.id);\n                 let adt = match self.save_ctxt.tables.node_type_opt(hir_id) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n@@ -903,7 +903,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         for (id, ident, _) in collector.collected_idents {\n             match self.save_ctxt.get_path_res(id) {\n                 Res::Local(hir_id) => {\n-                    let id = self.tcx.hir().hir_to_node_id(hir_id);\n+                    let id = self.tcx.hir().hir_id_to_node_id(hir_id);\n                     let typ = self\n                         .save_ctxt\n                         .tables\n@@ -1126,7 +1126,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n         // The access is calculated using the current tree ID, but with the root tree's visibility\n         // (since nested trees don't have their own visibility).\n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n         let access = access_from!(self.save_ctxt, root_item, hir_id);\n \n         // The parent `DefId` of a given use tree is always the enclosing item.\n@@ -1321,7 +1321,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n                     let id = id_from_node_id(item.id, &self.save_ctxt);\n-                    let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+                    let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n \n                     self.dumper.dump_def(\n                         &access_from!(self.save_ctxt, item, hir_id),\n@@ -1420,7 +1420,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n         self.process_macro_use(ex.span);\n         match ex.kind {\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-                let expr_hir_id = self.save_ctxt.tcx.hir().node_to_hir_id(ex.id);\n+                let expr_hir_id = self.save_ctxt.tcx.hir().node_id_to_hir_id(ex.id);\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(expr_hir_id);\n                 let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n@@ -1429,7 +1429,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                         return;\n                     }\n                 };\n-                let node_id = self.save_ctxt.tcx.hir().hir_to_node_id(hir_expr.hir_id);\n+                let node_id = self.save_ctxt.tcx.hir().hir_id_to_node_id(hir_expr.hir_id);\n                 let res = self.save_ctxt.get_path_res(node_id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), base)\n             }\n@@ -1514,7 +1514,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'l ast::ForeignItem) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n         match item.kind {"}, {"sha": "c737c6257a2ec49b90e27358d361940337d4b49b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -412,7 +412,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                         let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n-                        if let Some(Node::ImplItem(item)) = hir.find(hir.node_to_hir_id(id)) {\n+                        if let Some(Node::ImplItem(item)) = hir.find(hir.node_id_to_hir_id(id)) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }\n@@ -452,7 +452,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 Some(def_id) => {\n                     let mut docs = String::new();\n                     let mut attrs = vec![];\n-                    let hir_id = self.tcx.hir().node_to_hir_id(id);\n+                    let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n \n                     if let Some(Node::TraitItem(item)) = self.tcx.hir().find(hir_id) {\n                         docs = self.docs_for_attrs(&item.attrs);\n@@ -511,15 +511,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n-        let expr_hir_id = self.tcx.hir().node_to_hir_id(expr.id);\n+        let expr_hir_id = self.tcx.hir().node_id_to_hir_id(expr.id);\n         let hir_node = self.tcx.hir().expect_expr(expr_hir_id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().kind == ty::Error {\n             return None;\n         }\n         match expr.kind {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n-                let sub_ex_hir_id = self.tcx.hir().node_to_hir_id(sub_ex.id);\n+                let sub_ex_hir_id = self.tcx.hir().node_id_to_hir_id(sub_ex.id);\n                 let hir_node = match self.tcx.hir().find(sub_ex_hir_id) {\n                     Some(Node::Expr(expr)) => expr,\n                     _ => {\n@@ -573,7 +573,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(ref seg, ..) => {\n-                let expr_hir_id = self.tcx.hir().definitions().node_to_hir_id(expr.id);\n+                let expr_hir_id = self.tcx.hir().definitions().node_id_to_hir_id(expr.id);\n                 let method_id = match self.tables.type_dependent_def_id(expr_hir_id) {\n                     Some(id) => id,\n                     None => {\n@@ -605,7 +605,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_res(&self, id: NodeId) -> Res {\n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n         match self.tcx.hir().get(hir_id) {\n             Node::TraitRef(tr) => tr.path.res,\n \n@@ -619,7 +619,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 Some(res) if res != Res::Err => res,\n                 _ => {\n                     let parent_node = self.tcx.hir().get_parent_node(hir_id);\n-                    self.get_path_res(self.tcx.hir().hir_to_node_id(parent_node))\n+                    self.get_path_res(self.tcx.hir().hir_id_to_node_id(parent_node))\n                 }\n             },\n \n@@ -681,7 +681,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Local(id) => Some(Ref {\n                 kind: RefKind::Variable,\n                 span,\n-                ref_id: id_from_node_id(self.tcx.hir().hir_to_node_id(id), self),\n+                ref_id: id_from_node_id(self.tcx.hir().hir_id_to_node_id(id), self),\n             }),\n             Res::Def(HirDefKind::Trait, def_id) if fn_type(path_seg) => {\n                 Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) })"}, {"sha": "9d49075ebbc8e81043d23dcb926038cf298af9b8", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -665,8 +665,6 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"use soft float ABI (*eabihf targets only)\"),\n     prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n         \"prefer dynamic linking to static linking\"),\n-    no_integrated_as: bool = (false, parse_bool, [TRACKED],\n-        \"use an external assembler rather than LLVM's integrated one\"),\n     no_redzone: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"disable the use of the redzone\"),\n     relocation_model: Option<String> = (None, parse_opt_string, [TRACKED],"}, {"sha": "1bc2bf12fad9e39b796186bf2b2568ecc7dd2ce1", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -712,11 +712,6 @@ pub struct TargetOptions {\n     // will 'just work'.\n     pub obj_is_bitcode: bool,\n \n-    // LLVM can't produce object files for this target. Instead, we'll make LLVM\n-    // emit assembly and then use `gcc` to turn that assembly into an object\n-    // file\n-    pub no_integrated_as: bool,\n-\n     /// Don't use this field; instead use the `.min_atomic_width()` method.\n     pub min_atomic_width: Option<u64>,\n \n@@ -872,7 +867,6 @@ impl Default for TargetOptions {\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n-            no_integrated_as: false,\n             min_atomic_width: None,\n             max_atomic_width: None,\n             atomic_cas: true,\n@@ -1187,7 +1181,6 @@ impl Target {\n         key!(main_needs_argc_argv, bool);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n-        key!(no_integrated_as, bool);\n         key!(max_atomic_width, Option<u64>);\n         key!(min_atomic_width, Option<u64>);\n         key!(atomic_cas, bool);\n@@ -1415,7 +1408,6 @@ impl ToJson for Target {\n         target_option_val!(main_needs_argc_argv);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n-        target_option_val!(no_integrated_as);\n         target_option_val!(min_atomic_width);\n         target_option_val!(max_atomic_width);\n         target_option_val!(atomic_cas);"}, {"sha": "9a90ac7ccecea2a4044f82d9db9522de18dd599a", "filename": "src/librustc_target/spec/msp430_none_elf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmsp430_none_elf.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -22,7 +22,6 @@ pub fn target() -> TargetResult {\n             // dependency on this specific gcc.\n             asm_args: vec![\"-mcpu=msp430\".to_string()],\n             linker: Some(\"msp430-elf-gcc\".to_string()),\n-            no_integrated_as: true,\n \n             // There are no atomic CAS instructions available in the MSP430\n             // instruction set, and the LLVM backend doesn't currently support"}, {"sha": "23613caa99322121b10b18d98e7f9a9550463599", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 71, "deletions": 77, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -216,93 +216,87 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 | Node::Expr(&Expr { kind: ExprKind::Path(_), .. })\n                 | Node::TraitRef(..) => {\n                     let path = match parent_node {\n-                        Node::Ty(&Ty {\n-                            kind: TyKind::Path(QPath::Resolved(_, ref path)), ..\n-                        })\n+                        Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n                         | Node::Expr(&Expr {\n-                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            kind:\n+                                ExprKind::Path(QPath::Resolved(_, path))\n+                                | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n                             ..\n-                        }) => Some(&**path),\n-                        Node::Expr(&Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n-                            if let QPath::Resolved(_, ref path) = **path {\n-                                Some(&**path)\n-                            } else {\n-                                None\n-                            }\n+                        })\n+                        | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n+                        _ => {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\"unexpected const parent path {:?}\", parent_node),\n+                            );\n+                            return tcx.types.err;\n                         }\n-                        Node::TraitRef(&TraitRef { ref path, .. }) => Some(&**path),\n-                        _ => None,\n                     };\n \n-                    if let Some(path) = path {\n-                        // We've encountered an `AnonConst` in some path, so we need to\n-                        // figure out which generic parameter it corresponds to and return\n-                        // the relevant type.\n-\n-                        let (arg_index, segment) = path\n-                            .segments\n-                            .iter()\n-                            .filter_map(|seg| seg.args.as_ref().map(|args| (args.args, seg)))\n-                            .find_map(|(args, seg)| {\n-                                args.iter()\n-                                    .filter(|arg| arg.is_const())\n-                                    .enumerate()\n-                                    .filter(|(_, arg)| arg.id() == hir_id)\n-                                    .map(|(index, _)| (index, seg))\n-                                    .next()\n-                            })\n-                            .unwrap_or_else(|| {\n-                                bug!(\"no arg matching AnonConst in path\");\n-                            });\n-\n-                        // Try to use the segment resolution if it is valid, otherwise we\n-                        // default to the path resolution.\n-                        let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-                        let generics = match res {\n-                            Res::Def(DefKind::Ctor(..), def_id) => {\n-                                tcx.generics_of(tcx.parent(def_id).unwrap())\n-                            }\n-                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            res => {\n-                                tcx.sess.delay_span_bug(\n-                                    DUMMY_SP,\n-                                    &format!(\n-                                        \"unexpected anon const res {:?} in path: {:?}\",\n-                                        res, path,\n-                                    ),\n-                                );\n-                                return tcx.types.err;\n+                    // We've encountered an `AnonConst` in some path, so we need to\n+                    // figure out which generic parameter it corresponds to and return\n+                    // the relevant type.\n+\n+                    let (arg_index, segment) = path\n+                        .segments\n+                        .iter()\n+                        .filter_map(|seg| seg.args.as_ref().map(|args| (args.args, seg)))\n+                        .find_map(|(args, seg)| {\n+                            args.iter()\n+                                .filter(|arg| arg.is_const())\n+                                .enumerate()\n+                                .filter(|(_, arg)| arg.id() == hir_id)\n+                                .map(|(index, _)| (index, seg))\n+                                .next()\n+                        })\n+                        .unwrap_or_else(|| {\n+                            bug!(\"no arg matching AnonConst in path\");\n+                        });\n+\n+                    // Try to use the segment resolution if it is valid, otherwise we\n+                    // default to the path resolution.\n+                    let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n+                    let generics = match res {\n+                        Res::Def(DefKind::Ctor(..), def_id) => {\n+                            tcx.generics_of(tcx.parent(def_id).unwrap())\n+                        }\n+                        Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                        res => {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\n+                                    \"unexpected anon const res {:?} in path: {:?}\",\n+                                    res, path,\n+                                ),\n+                            );\n+                            return tcx.types.err;\n+                        }\n+                    };\n+\n+                    let ty = generics\n+                        .params\n+                        .iter()\n+                        .filter(|param| {\n+                            if let ty::GenericParamDefKind::Const = param.kind {\n+                                true\n+                            } else {\n+                                false\n                             }\n-                        };\n+                        })\n+                        .nth(arg_index)\n+                        .map(|param| tcx.type_of(param.def_id));\n \n-                        generics\n-                            .params\n-                            .iter()\n-                            .filter(|param| {\n-                                if let ty::GenericParamDefKind::Const = param.kind {\n-                                    true\n-                                } else {\n-                                    false\n-                                }\n-                            })\n-                            .nth(arg_index)\n-                            .map(|param| tcx.type_of(param.def_id))\n-                            // This is no generic parameter associated with the arg. This is\n-                            // probably from an extra arg where one is not needed.\n-                            .unwrap_or_else(|| {\n-                                tcx.sess.delay_span_bug(\n-                                    DUMMY_SP,\n-                                    &format!(\n-                                        \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n-                                        parent_node, res\n-                                    ),\n-                                );\n-                                tcx.types.err\n-                            })\n+                    if let Some(ty) = ty {\n+                        ty\n                     } else {\n+                        // This is no generic parameter associated with the arg. This is\n+                        // probably from an extra arg where one is not needed.\n                         tcx.sess.delay_span_bug(\n                             DUMMY_SP,\n-                            &format!(\"unexpected const parent path {:?}\", parent_node,),\n+                            &format!(\n+                                \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n+                                parent_node, res\n+                            ),\n                         );\n                         tcx.types.err\n                     }"}, {"sha": "2525773f0ed711933ef95446cb1cce355d07aa90", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         // In case we're in a module, try to resolve the relative path.\n         if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n-            let module_id = cx.tcx.hir().hir_to_node_id(module_id);\n+            let module_id = cx.tcx.hir().hir_id_to_node_id(module_id);\n             let result = cx.enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n             });"}, {"sha": "1567b325d4fe19f3624692f79bf6efa7ebf9eec4", "filename": "src/test/run-make-fulldeps/no-integrated-as/Makefile", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2FMakefile?ref=0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4", "patch": "@@ -1,8 +0,0 @@\n--include ../tools.mk\n-\n-# only-linux\n-# only-x86_64\n-\n-all:\n-\t$(RUSTC) hello.rs -C no_integrated_as\n-\t$(call RUN,hello)"}, {"sha": "e7a11a969c037e00a796aafeff6258501ec15e9a", "filename": "src/test/run-make-fulldeps/no-integrated-as/hello.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fno-integrated-as%2Fhello.rs?ref=0bf7c2ad77fdcb18a65ae05996dc8e226fbaeab4", "patch": "@@ -1,3 +0,0 @@\n-fn main() {\n-    println!(\"Hello, world!\");\n-}"}, {"sha": "3850b1d82bf5b107a8ad41301090b6e117ff717d", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -6,6 +6,7 @@ LL |     A = { let 0 = 0; 0 },\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     A = { if let 0 = 0 { /* */ } 0 },"}, {"sha": "4e1d50f42d461dfc46b9531d831f88aa830caa5e", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -6,6 +6,7 @@ LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     let x: [i32; { if let 0 = 0 { /* */ } 0 }] = [];"}, {"sha": "2aabc0ca494cb62b945f12a650e3c004f3128704", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -6,6 +6,7 @@ LL | const X: i32 = { let 0 = 0; 0 };\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL | const X: i32 = { if let 0 = 0 { /* */ } 0 };\n@@ -19,6 +20,7 @@ LL | static Y: i32 = { let 0 = 0; 0 };\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL | static Y: i32 = { if let 0 = 0 { /* */ } 0 };\n@@ -32,6 +34,7 @@ LL |     const X: i32 = { let 0 = 0; 0 };\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n@@ -45,6 +48,7 @@ LL |     const X: i32 = { let 0 = 0; 0 };\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };"}, {"sha": "863e1372a9b8a328f688a2d1a96434d588e47a23", "filename": "src/test/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -9,6 +9,8 @@ LL |     let a = 4;\n    |         |\n    |         interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `a_var`\n+   |\n+   = note: the matched value is of type `u8`\n \n error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:13:9\n@@ -21,6 +23,8 @@ LL |     let c = 4;\n    |         |\n    |         interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `c_var`\n+   |\n+   = note: the matched value is of type `u8`\n \n error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:14:9\n@@ -33,6 +37,8 @@ LL |     let d = 4;\n    |         |\n    |         interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `d_var`\n+   |\n+   = note: the matched value is of type `u8`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "02296e6de75fcced3c8760c439f45a82ec7cde18", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -3,6 +3,8 @@ error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _,\n    |\n LL | const fn slice(&[a, b]: &[i32]) -> i32 {\n    |                ^^^^^^^ patterns `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n+   |\n+   = note: the matched value is of type `&[i32]`\n \n error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/const_let_refutable.rs:3:17"}, {"sha": "5477170fb1e4162cd9659629ff11ad0b13b5cc6c", "filename": "src/test/ui/consts/match_ice.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -14,6 +14,7 @@ LL |     match K {\n    |           ^ pattern `&T` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&T`\n \n error: to use a constant of type `S` in a pattern, `S` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/match_ice.rs:11:9"}, {"sha": "64d640c0e9dbcae0785a578de4ddd15ff8b514df", "filename": "src/test/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-never-array.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -14,6 +14,7 @@ LL |       let Helper::U(u) = Helper::T(t, []);\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `Helper<T, U>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let Helper::U(u) = Helper::T(t, []) { /* */ }"}, {"sha": "fcc44b7635c1ae034636023e93f7d5bd26425d44", "filename": "src/test/ui/error-codes/E0004-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -13,6 +13,7 @@ LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `std::option::Option<i32>`\n \n error: aborting due to previous error\n "}, {"sha": "5bf375a64843a2bb2c82b7ac291362c6c82ec512", "filename": "src/test/ui/error-codes/E0004.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -12,6 +12,7 @@ LL |       match x {\n    |             ^ pattern `HastaLaVistaBaby` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Terminator`\n \n error: aborting due to previous error\n "}, {"sha": "d43dc6fd6494e4db45b74b75f72173828825d5ea", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -11,6 +11,7 @@ LL |     None,\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `std::option::Option<i32>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let Some(y) = x { /* */ }"}, {"sha": "3ad841875e6917a6fba4c9ad73038b256526976c", "filename": "src/test/ui/error-codes/E0297.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -8,6 +8,8 @@ LL |     for Some(x) in xs {}\n    |\n LL |     None,\n    |     ---- not covered\n+   |\n+   = note: the matched value is of type `std::option::Option<i32>`\n \n error: aborting due to previous error\n "}, {"sha": "06c2e6e5192353083386837bbbff96faecb77957", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -11,6 +11,7 @@ LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `std::result::Result<u32, !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let Ok(_x) = foo() { /* */ }"}, {"sha": "6c5d0091c5addb2d8a55b49df2f676773620af71", "filename": "src/test/ui/feature-gates/feature-gate-precise_pointer_size_matching.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-precise_pointer_size_matching.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match 0usize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `usize`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/feature-gate-precise_pointer_size_matching.rs:10:11\n@@ -13,6 +14,7 @@ LL |     match 0isize {\n    |           ^^^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `isize`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ce12b7853b6c10fb1f773edf9fb0dc4cd0636535", "filename": "src/test/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -3,6 +3,8 @@ error[E0005]: refutable pattern in `for` loop binding: `&std::i32::MIN..=0i32` a\n    |\n LL |     for &1 in [1].iter() {}\n    |         ^^ patterns `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n+   |\n+   = note: the matched value is of type `&i32`\n \n error: aborting due to previous error\n "}, {"sha": "6c7a0cdb77adf680289a0e438be6cfa9a629f597", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-fail.stderr", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     m!(0f32, core::f32::NEG_INFINITY..);\n    |        ^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `f32`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:17:8\n@@ -13,6 +14,7 @@ LL |     m!(0f32, ..core::f32::INFINITY);\n    |        ^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `f32`\n \n error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:26:8\n@@ -21,6 +23,7 @@ LL |     m!('a', ..core::char::MAX);\n    |        ^^^ pattern `'\\u{10ffff}'` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `char`\n \n error[E0004]: non-exhaustive patterns: `'\\u{10fffe}'..='\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:27:8\n@@ -29,6 +32,7 @@ LL |     m!('a', ..ALMOST_MAX);\n    |        ^^^ pattern `'\\u{10fffe}'..='\\u{10ffff}'` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `char`\n \n error[E0004]: non-exhaustive patterns: `'\\u{0}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:28:8\n@@ -37,6 +41,7 @@ LL |     m!('a', ALMOST_MIN..);\n    |        ^^^ pattern `'\\u{0}'` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `char`\n \n error[E0004]: non-exhaustive patterns: `'\\u{10ffff}'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:29:8\n@@ -45,6 +50,7 @@ LL |     m!('a', ..=ALMOST_MAX);\n    |        ^^^ pattern `'\\u{10ffff}'` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `char`\n \n error[E0004]: non-exhaustive patterns: `'b'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:30:8\n@@ -53,6 +59,7 @@ LL |     m!('a', ..=VAL | VAL_2..);\n    |        ^^^ pattern `'b'` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `char`\n \n error[E0004]: non-exhaustive patterns: `'b'` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:31:8\n@@ -61,6 +68,7 @@ LL |     m!('a', ..VAL_1 | VAL_2..);\n    |        ^^^ pattern `'b'` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `char`\n \n error[E0004]: non-exhaustive patterns: `std::u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:41:12\n@@ -69,6 +77,7 @@ LL |         m!(0, ..core::u8::MAX);\n    |            ^ pattern `std::u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `254u8..=std::u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:42:12\n@@ -77,6 +86,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `254u8..=std::u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `0u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:43:12\n@@ -85,6 +95,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0u8` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `std::u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:44:12\n@@ -93,6 +104,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `43u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:45:12\n@@ -101,6 +113,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43u8` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `43u8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:46:12\n@@ -109,6 +122,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43u8` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `std::u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:54:12\n@@ -117,6 +131,7 @@ LL |         m!(0, ..core::u16::MAX);\n    |            ^ pattern `std::u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u16`\n \n error[E0004]: non-exhaustive patterns: `65534u16..=std::u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:55:12\n@@ -125,6 +140,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `65534u16..=std::u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u16`\n \n error[E0004]: non-exhaustive patterns: `0u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:56:12\n@@ -133,6 +149,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0u16` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u16`\n \n error[E0004]: non-exhaustive patterns: `std::u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:57:12\n@@ -141,6 +158,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u16`\n \n error[E0004]: non-exhaustive patterns: `43u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:58:12\n@@ -149,6 +167,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43u16` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u16`\n \n error[E0004]: non-exhaustive patterns: `43u16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:59:12\n@@ -157,6 +176,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43u16` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u16`\n \n error[E0004]: non-exhaustive patterns: `std::u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:67:12\n@@ -165,6 +185,7 @@ LL |         m!(0, ..core::u32::MAX);\n    |            ^ pattern `std::u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u32`\n \n error[E0004]: non-exhaustive patterns: `4294967294u32..=std::u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:68:12\n@@ -173,6 +194,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `4294967294u32..=std::u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u32`\n \n error[E0004]: non-exhaustive patterns: `0u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:69:12\n@@ -181,6 +203,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0u32` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u32`\n \n error[E0004]: non-exhaustive patterns: `std::u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:70:12\n@@ -189,6 +212,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u32`\n \n error[E0004]: non-exhaustive patterns: `43u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:71:12\n@@ -197,6 +221,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43u32` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u32`\n \n error[E0004]: non-exhaustive patterns: `43u32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:72:12\n@@ -205,6 +230,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43u32` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u32`\n \n error[E0004]: non-exhaustive patterns: `std::u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:80:12\n@@ -213,6 +239,7 @@ LL |         m!(0, ..core::u64::MAX);\n    |            ^ pattern `std::u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u64`\n \n error[E0004]: non-exhaustive patterns: `18446744073709551614u64..=std::u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:81:12\n@@ -221,6 +248,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `18446744073709551614u64..=std::u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u64`\n \n error[E0004]: non-exhaustive patterns: `0u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:82:12\n@@ -229,6 +257,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0u64` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u64`\n \n error[E0004]: non-exhaustive patterns: `std::u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:83:12\n@@ -237,6 +266,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u64`\n \n error[E0004]: non-exhaustive patterns: `43u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:84:12\n@@ -245,6 +275,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43u64` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u64`\n \n error[E0004]: non-exhaustive patterns: `43u64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:85:12\n@@ -253,6 +284,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43u64` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u64`\n \n error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:93:12\n@@ -261,6 +293,7 @@ LL |         m!(0, ..core::u128::MAX);\n    |            ^ pattern `std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454u128..=std::u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:94:12\n@@ -269,6 +302,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `340282366920938463463374607431768211454u128..=std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error[E0004]: non-exhaustive patterns: `0u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:95:12\n@@ -277,6 +311,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `0u128` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:96:12\n@@ -285,6 +320,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error[E0004]: non-exhaustive patterns: `43u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:97:12\n@@ -293,6 +329,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43u128` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error[E0004]: non-exhaustive patterns: `43u128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:98:12\n@@ -301,6 +338,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43u128` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error[E0004]: non-exhaustive patterns: `std::i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:109:12\n@@ -309,6 +347,7 @@ LL |         m!(0, ..core::i8::MAX);\n    |            ^ pattern `std::i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i8`\n \n error[E0004]: non-exhaustive patterns: `126i8..=std::i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:110:12\n@@ -317,6 +356,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `126i8..=std::i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i8`\n \n error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:111:12\n@@ -325,6 +365,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `std::i8::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i8`\n \n error[E0004]: non-exhaustive patterns: `std::i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:112:12\n@@ -333,6 +374,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i8`\n \n error[E0004]: non-exhaustive patterns: `43i8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:113:12\n@@ -341,6 +383,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43i8` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i8`\n \n error[E0004]: non-exhaustive patterns: `43i8` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:114:12\n@@ -349,6 +392,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43i8` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i8`\n \n error[E0004]: non-exhaustive patterns: `std::i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:122:12\n@@ -357,6 +401,7 @@ LL |         m!(0, ..core::i16::MAX);\n    |            ^ pattern `std::i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i16`\n \n error[E0004]: non-exhaustive patterns: `32766i16..=std::i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:123:12\n@@ -365,6 +410,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `32766i16..=std::i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i16`\n \n error[E0004]: non-exhaustive patterns: `std::i16::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:124:12\n@@ -373,6 +419,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `std::i16::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i16`\n \n error[E0004]: non-exhaustive patterns: `std::i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:125:12\n@@ -381,6 +428,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i16`\n \n error[E0004]: non-exhaustive patterns: `43i16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:126:12\n@@ -389,6 +437,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43i16` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i16`\n \n error[E0004]: non-exhaustive patterns: `43i16` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:127:12\n@@ -397,6 +446,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43i16` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i16`\n \n error[E0004]: non-exhaustive patterns: `std::i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:135:12\n@@ -405,6 +455,7 @@ LL |         m!(0, ..core::i32::MAX);\n    |            ^ pattern `std::i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error[E0004]: non-exhaustive patterns: `2147483646i32..=std::i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:136:12\n@@ -413,6 +464,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `2147483646i32..=std::i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error[E0004]: non-exhaustive patterns: `std::i32::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:137:12\n@@ -421,6 +473,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `std::i32::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error[E0004]: non-exhaustive patterns: `std::i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:138:12\n@@ -429,6 +482,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error[E0004]: non-exhaustive patterns: `43i32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:139:12\n@@ -437,6 +491,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43i32` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error[E0004]: non-exhaustive patterns: `43i32` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:140:12\n@@ -445,6 +500,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43i32` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error[E0004]: non-exhaustive patterns: `std::i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:148:12\n@@ -453,6 +509,7 @@ LL |         m!(0, ..core::i64::MAX);\n    |            ^ pattern `std::i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i64`\n \n error[E0004]: non-exhaustive patterns: `9223372036854775806i64..=std::i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:149:12\n@@ -461,6 +518,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `9223372036854775806i64..=std::i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i64`\n \n error[E0004]: non-exhaustive patterns: `std::i64::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:150:12\n@@ -469,6 +527,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `std::i64::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i64`\n \n error[E0004]: non-exhaustive patterns: `std::i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:151:12\n@@ -477,6 +536,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i64`\n \n error[E0004]: non-exhaustive patterns: `43i64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:152:12\n@@ -485,6 +545,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43i64` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i64`\n \n error[E0004]: non-exhaustive patterns: `43i64` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:153:12\n@@ -493,6 +554,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43i64` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i64`\n \n error[E0004]: non-exhaustive patterns: `std::i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:161:12\n@@ -501,6 +563,7 @@ LL |         m!(0, ..core::i128::MAX);\n    |            ^ pattern `std::i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i128`\n \n error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726i128..=std::i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:162:12\n@@ -509,6 +572,7 @@ LL |         m!(0, ..ALMOST_MAX);\n    |            ^ pattern `170141183460469231731687303715884105726i128..=std::i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i128`\n \n error[E0004]: non-exhaustive patterns: `std::i128::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:163:12\n@@ -517,6 +581,7 @@ LL |         m!(0, ALMOST_MIN..);\n    |            ^ pattern `std::i128::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i128`\n \n error[E0004]: non-exhaustive patterns: `std::i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:164:12\n@@ -525,6 +590,7 @@ LL |         m!(0, ..=ALMOST_MAX);\n    |            ^ pattern `std::i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i128`\n \n error[E0004]: non-exhaustive patterns: `43i128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:165:12\n@@ -533,6 +599,7 @@ LL |         m!(0, ..=VAL | VAL_2..);\n    |            ^ pattern `43i128` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i128`\n \n error[E0004]: non-exhaustive patterns: `43i128` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:166:12\n@@ -541,6 +608,7 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    |            ^ pattern `43i128` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i128`\n \n error: aborting due to 68 previous errors\n "}, {"sha": "aa4434e72b5c7d0328c9b2e9e41b7faf85156785", "filename": "src/test/ui/issues/issue-15129.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-15129.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-15129.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15129.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match (T::T1(()), V::V2(true)) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `(T1(()), V2(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(T, V)`\n \n error: aborting due to previous error\n "}, {"sha": "c4667ce1c8ba1b53828960f18f3e574779bb4eb4", "filename": "src/test/ui/issues/issue-15381.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15381.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -3,6 +3,8 @@ error[E0005]: refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]`\n    |\n LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n    |         ^^^^^^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n+   |\n+   = note: the matched value is of type `&[u8]`\n \n error: aborting due to previous error\n "}, {"sha": "aab2559a155ae4289581e4d15a79daba37abe063", "filename": "src/test/ui/issues/issue-2111.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-2111.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-2111.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2111.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |   match (a,b) {\n    |         ^^^^^ pattern `(None, None)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(std::option::Option<usize>, std::option::Option<usize>)`\n \n error: aborting due to previous error\n "}, {"sha": "a2c58d6e051b54214ddd332fa42edf8feca04d2e", "filename": "src/test/ui/issues/issue-30240.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match \"world\" {\n    |           ^^^^^^^ pattern `&_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&str`\n \n error[E0004]: non-exhaustive patterns: `&_` not covered\n   --> $DIR/issue-30240.rs:6:11\n@@ -13,6 +14,7 @@ LL |     match \"world\" {\n    |           ^^^^^^^ pattern `&_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&str`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "97c34755189de9115a62fcaad0267619ae3d06fb", "filename": "src/test/ui/issues/issue-3096-1.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-3096-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-3096-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3096-1.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match () { }\n    |           ^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `()`\n \n error: aborting due to previous error\n "}, {"sha": "472d1a91e6a15835c94e5b936c43119ed0543c84", "filename": "src/test/ui/issues/issue-3096-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-3096-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-3096-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3096-2.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match x { }\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `*const Bottom`\n \n error: aborting due to previous error\n "}, {"sha": "2f562b23692deffc3128c6a612eb893d436977b5", "filename": "src/test/ui/issues/issue-31561.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31561.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -15,6 +15,7 @@ LL |       let Thing::Foo(y) = Thing::Foo(1);\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `Thing`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let Thing::Foo(y) = Thing::Foo(1) { /* */ }"}, {"sha": "6b2a5d76243d80812781564cc159181f1e0bf754", "filename": "src/test/ui/issues/issue-3601.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |         box NodeKind::Element(ed) => match ed.kind {\n    |                                            ^^^^^^^ pattern `Box(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `std::boxed::Box<ElementKind>`\n \n error: aborting due to previous error\n "}, {"sha": "8c162e55619e005b5e6aac41e9970f510d64c9ba", "filename": "src/test/ui/issues/issue-39362.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-39362.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-39362.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39362.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -10,6 +10,7 @@ LL |       match f {\n    |             ^ patterns `Bar { bar: C, .. }`, `Bar { bar: D, .. }`, `Bar { bar: E, .. }` and 1 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "1e8852556b161690c46dfb8ba5fdff3346c278d4", "filename": "src/test/ui/issues/issue-4321.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-4321.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fissues%2Fissue-4321.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4321.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     println!(\"foo {:}\", match tup {\n    |                               ^^^ pattern `(true, false)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(bool, bool)`\n \n error: aborting due to previous error\n "}, {"sha": "d78139365549a546b5093dff80615b87e1dea043", "filename": "src/test/ui/macros/issue-34421-mac-expr-bad-stmt-good-add-semi.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmacros%2Fissue-34421-mac-expr-bad-stmt-good-add-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmacros%2Fissue-34421-mac-expr-bad-stmt-good-add-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-34421-mac-expr-bad-stmt-good-add-semi.rs?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -0,0 +1,15 @@\n+macro_rules! make_item {\n+    ($a:ident) => {\n+        struct $a;\n+    }; //~^ ERROR expected expression\n+       //~| ERROR expected expression\n+}\n+\n+fn a() {\n+    make_item!(A)\n+}\n+fn b() {\n+    make_item!(B)\n+}\n+\n+fn main() {}"}, {"sha": "c8d69640071c686dfefb088ad76cfb3be05cf824", "filename": "src/test/ui/macros/issue-34421-mac-expr-bad-stmt-good-add-semi.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmacros%2Fissue-34421-mac-expr-bad-stmt-good-add-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmacros%2Fissue-34421-mac-expr-bad-stmt-good-add-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-34421-mac-expr-bad-stmt-good-add-semi.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -0,0 +1,34 @@\n+error: expected expression, found keyword `struct`\n+  --> $DIR/issue-34421-mac-expr-bad-stmt-good-add-semi.rs:3:9\n+   |\n+LL |         struct $a;\n+   |         ^^^^^^ expected expression\n+...\n+LL |     make_item!(A)\n+   |     ------------- in this macro invocation\n+   |\n+   = note: the macro call doesn't expand to an expression, but it can expand to a statement\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: add `;` to interpret the expansion as a statement\n+   |\n+LL |     make_item!(A);\n+   |                  ^\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/issue-34421-mac-expr-bad-stmt-good-add-semi.rs:3:9\n+   |\n+LL |         struct $a;\n+   |         ^^^^^^ expected expression\n+...\n+LL |     make_item!(B)\n+   |     ------------- in this macro invocation\n+   |\n+   = note: the macro call doesn't expand to an expression, but it can expand to a statement\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: add `;` to interpret the expansion as a statement\n+   |\n+LL |     make_item!(B);\n+   |                  ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "8f9660963937f9cb2a795cf8d6bdcf7f00514493", "filename": "src/test/ui/macros/macro-in-expression-context-2.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-in-expression-context-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmacros%2Fmacro-in-expression-context-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-in-expression-context-2.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -6,6 +6,12 @@ LL | macro_rules! empty { () => () }\n ...\n LL |         _ => { empty!() }\n    |                ^^^^^^^^ expected expression\n+   |\n+   = note: the macro call doesn't expand to an expression, but it can expand to a statement\n+help: add `;` to interpret the expansion as a statement\n+   |\n+LL |         _ => { empty!(); }\n+   |                        ^\n \n error: aborting due to previous error\n "}, {"sha": "d378b6e8efe370a84ac92491ae3ceb4853ad9b55", "filename": "src/test/ui/match/issue-50900.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmatch%2Fissue-50900.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmatch%2Fissue-50900.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-50900.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -8,6 +8,7 @@ LL |     match Tag::ExifIFDPointer {\n    |           ^^^^^^^^^^^^^^^^^^^ pattern `Tag(Exif, _)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Tag`\n \n error: aborting due to previous error\n "}, {"sha": "98efe805a0b3491fde73c71445fa608e9119296a", "filename": "src/test/ui/missing/missing-items/issue-40221.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fissue-40221.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fissue-40221.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fissue-40221.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -11,6 +11,7 @@ LL |       match proto {\n    |             ^^^^^ pattern `C(QA)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `P`\n \n error: aborting due to previous error\n "}, {"sha": "b45e947f3ea3743babde9ab01fef094cc47eaf24", "filename": "src/test/ui/or-patterns/exhaustiveness-non-exhaustive.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match (0u8, 0u8) {\n    |           ^^^^^^^^^^ pattern `(2u8..=std::u8::MAX, _)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(u8, u8)`\n \n error[E0004]: non-exhaustive patterns: `((4u8..=std::u8::MAX))` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:10:11\n@@ -13,6 +14,7 @@ LL |     match ((0u8,),) {\n    |           ^^^^^^^^^ pattern `((4u8..=std::u8::MAX))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `((u8,),)`\n \n error[E0004]: non-exhaustive patterns: `(Some(2u8..=std::u8::MAX))` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:14:11\n@@ -21,6 +23,7 @@ LL |     match (Some(0u8),) {\n    |           ^^^^^^^^^^^^ pattern `(Some(2u8..=std::u8::MAX))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(std::option::Option<u8>,)`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "351700a6aa52983ac9aec7a4a7ec86dc7ab77326", "filename": "src/test/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -6,6 +6,7 @@ LL |     let 0 | (1 | 2) = 0;\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `i32`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let 0 | (1 | 2) = 0 { /* */ }\n@@ -18,6 +19,7 @@ LL |     match 0 {\n    |           ^ patterns `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0fa77fb73da1fa570683cd531ca5f167281a2770", "filename": "src/test/ui/pattern/usefulness/always-inhabited-union-ref.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match uninhab_ref() {\n    |           ^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&!`\n \n error[E0004]: non-exhaustive patterns: type `Foo` is non-empty\n   --> $DIR/always-inhabited-union-ref.rs:27:11\n@@ -18,6 +19,7 @@ LL |       match uninhab_union() {\n    |             ^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Foo`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "edc5ece558a700719ddc2e3bcb850a5930b7e060", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -17,6 +17,7 @@ LL |     match x {\n    |           ^ pattern `128u8..=std::u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `11u8..=19u8`, `31u8..=34u8`, `36u8..=69u8` and 1 more not covered\n   --> $DIR/exhaustive_integer_patterns.rs:33:11\n@@ -25,6 +26,7 @@ LL |     match x {\n    |           ^ patterns `11u8..=19u8`, `31u8..=34u8`, `36u8..=69u8` and 1 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error: unreachable pattern\n   --> $DIR/exhaustive_integer_patterns.rs:44:9\n@@ -39,6 +41,7 @@ LL |     match x {\n    |           ^ patterns `std::i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i8`\n \n error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:83:11\n@@ -47,6 +50,7 @@ LL |     match 0i8 {\n    |           ^^^ pattern `std::i8::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i8`\n \n error[E0004]: non-exhaustive patterns: `0i16` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:91:11\n@@ -55,6 +59,7 @@ LL |     match 0i16 {\n    |           ^^^^ pattern `0i16` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i16`\n \n error[E0004]: non-exhaustive patterns: `128u8..=std::u8::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:109:11\n@@ -63,6 +68,7 @@ LL |     match 0u8 {\n    |           ^^^ pattern `128u8..=std::u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:121:11\n@@ -71,6 +77,7 @@ LL |     match (0u8, Some(())) {\n    |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(u8, std::option::Option<()>)`\n \n error[E0004]: non-exhaustive patterns: `(126u8..=127u8, false)` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:126:11\n@@ -79,6 +86,7 @@ LL |     match (0u8, true) {\n    |           ^^^^^^^^^^^ pattern `(126u8..=127u8, false)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(u8, bool)`\n \n error: multiple patterns covering the same range\n   --> $DIR/exhaustive_integer_patterns.rs:141:9\n@@ -101,6 +109,7 @@ LL |     match 0u128 {\n    |           ^^^^^ pattern `std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error[E0004]: non-exhaustive patterns: `5u128..=std::u128::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:150:11\n@@ -109,6 +118,7 @@ LL |     match 0u128 {\n    |           ^^^^^ pattern `5u128..=std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error[E0004]: non-exhaustive patterns: `0u128..=3u128` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:154:11\n@@ -117,6 +127,7 @@ LL |     match 0u128 {\n    |           ^^^^^ pattern `0u128..=3u128` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u128`\n \n error: unreachable pattern\n   --> $DIR/exhaustive_integer_patterns.rs:162:9"}, {"sha": "66f904aced11ba5bfa24bbf3b02745e13c347c54", "filename": "src/test/ui/pattern/usefulness/issue-35609.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-35609.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match (A, ()) {\n    |           ^^^^^^^ patterns `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(Enum, ())`\n \n error[E0004]: non-exhaustive patterns: `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n   --> $DIR/issue-35609.rs:14:11\n@@ -13,6 +14,7 @@ LL |     match (A, A) {\n    |           ^^^^^^ patterns `(_, B)`, `(_, C)`, `(_, D)` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(Enum, Enum)`\n \n error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:18:11\n@@ -21,6 +23,7 @@ LL |     match ((A, ()), ()) {\n    |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `((Enum, ()), ())`\n \n error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:22:11\n@@ -29,6 +32,7 @@ LL |     match ((A, ()), A) {\n    |           ^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `((Enum, ()), Enum)`\n \n error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:26:11\n@@ -37,6 +41,7 @@ LL |     match ((A, ()), ()) {\n    |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `((Enum, ()), ())`\n \n error[E0004]: non-exhaustive patterns: `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n   --> $DIR/issue-35609.rs:31:11\n@@ -48,6 +53,7 @@ LL |     match S(A, ()) {\n    |           ^^^^^^^^ patterns `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `S`\n \n error[E0004]: non-exhaustive patterns: `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n   --> $DIR/issue-35609.rs:35:11\n@@ -59,6 +65,7 @@ LL |     match (Sd { x: A, y: () }) {\n    |           ^^^^^^^^^^^^^^^^^^^^ patterns `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Sd`\n \n error[E0004]: non-exhaustive patterns: `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n   --> $DIR/issue-35609.rs:39:11\n@@ -67,6 +74,7 @@ LL |     match Some(A) {\n    |           ^^^^^^^ patterns `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `std::option::Option<Enum>`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "09b92fc92f32ae34311bb0510fde51bc7e3f5f5a", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match (true, false) {\n    |           ^^^^^^^^^^^^^ pattern `(true, false)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(bool, bool)`\n \n error[E0004]: non-exhaustive patterns: `Some(Some(West))` not covered\n   --> $DIR/match-arm-statics-2.rs:34:11\n@@ -21,6 +22,7 @@ LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `std::option::Option<std::option::Option<Direction>>`\n \n error[E0004]: non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n   --> $DIR/match-arm-statics-2.rs:53:11\n@@ -35,6 +37,7 @@ LL |       match (Foo { bar: Some(North), baz: NewBool(true) }) {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Foo`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "323449eebc5409649f5ed11a9471fe8767493903", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match buf {\n    |           ^^^ patterns `&[0u8..=64u8, _, _, _]` and `&[66u8..=std::u8::MAX, _, _, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[u8; 4]`\n \n error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n@@ -13,6 +14,7 @@ LL |     match buf {\n    |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[u8]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1f6503e3e9c719975afa9ef0a089717e617c7a04", "filename": "src/test/ui/pattern/usefulness/match-empty-exhaustive_patterns.stderr", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -35,6 +35,7 @@ LL |     match_empty!(0u8);\n    |                  ^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n   --> $DIR/match-empty-exhaustive_patterns.rs:66:18\n@@ -46,6 +47,7 @@ LL |     match_empty!(NonEmptyStruct(true));\n    |                  ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n   --> $DIR/match-empty-exhaustive_patterns.rs:68:18\n@@ -59,6 +61,7 @@ LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n   --> $DIR/match-empty-exhaustive_patterns.rs:70:18\n@@ -73,6 +76,7 @@ LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:72:18\n@@ -89,6 +93,7 @@ LL |       match_empty!(NonEmptyEnum1::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:74:18\n@@ -109,6 +114,7 @@ LL |       match_empty!(NonEmptyEnum2::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:76:18\n@@ -122,6 +128,7 @@ LL |       match_empty!(NonEmptyEnum5::V1);\n    |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:79:18\n@@ -130,6 +137,7 @@ LL |     match_false!(0u8);\n    |                  ^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:81:18\n@@ -141,6 +149,7 @@ LL |     match_false!(NonEmptyStruct(true));\n    |                  ^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:83:18\n@@ -154,6 +163,7 @@ LL |       match_false!((NonEmptyUnion1 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:85:18\n@@ -168,6 +178,7 @@ LL |       match_false!((NonEmptyUnion2 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:87:18\n@@ -184,6 +195,7 @@ LL |       match_false!(NonEmptyEnum1::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:89:18\n@@ -204,6 +216,7 @@ LL |       match_false!(NonEmptyEnum2::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/match-empty-exhaustive_patterns.rs:91:18\n@@ -217,6 +230,7 @@ LL |       match_false!(NonEmptyEnum5::V1);\n    |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum5`\n \n error: aborting due to 18 previous errors\n "}, {"sha": "08095f6e7fb12f4ceafdc419897da3f34e52343a", "filename": "src/test/ui/pattern/usefulness/match-empty.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -8,6 +8,7 @@ LL |     match_false!(x); // Not detected as unreachable nor exhaustive.\n    |                  ^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Foo`\n \n error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n   --> $DIR/match-empty.rs:63:18\n@@ -16,6 +17,7 @@ LL |     match_empty!(0u8);\n    |                  ^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n   --> $DIR/match-empty.rs:65:18\n@@ -27,6 +29,7 @@ LL |     match_empty!(NonEmptyStruct(true));\n    |                  ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n   --> $DIR/match-empty.rs:67:18\n@@ -40,6 +43,7 @@ LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n   --> $DIR/match-empty.rs:69:18\n@@ -54,6 +58,7 @@ LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/match-empty.rs:71:18\n@@ -70,6 +75,7 @@ LL |       match_empty!(NonEmptyEnum1::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/match-empty.rs:73:18\n@@ -90,6 +96,7 @@ LL |       match_empty!(NonEmptyEnum2::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/match-empty.rs:75:18\n@@ -103,6 +110,7 @@ LL |       match_empty!(NonEmptyEnum5::V1);\n    |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/match-empty.rs:78:18\n@@ -111,6 +119,7 @@ LL |     match_false!(0u8);\n    |                  ^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n   --> $DIR/match-empty.rs:80:18\n@@ -122,6 +131,7 @@ LL |     match_false!(NonEmptyStruct(true));\n    |                  ^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n   --> $DIR/match-empty.rs:82:18\n@@ -135,6 +145,7 @@ LL |       match_false!((NonEmptyUnion1 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n   --> $DIR/match-empty.rs:84:18\n@@ -149,6 +160,7 @@ LL |       match_false!((NonEmptyUnion2 { foo: () }));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n   --> $DIR/match-empty.rs:86:18\n@@ -165,6 +177,7 @@ LL |       match_false!(NonEmptyEnum1::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n   --> $DIR/match-empty.rs:88:18\n@@ -185,6 +198,7 @@ LL |       match_false!(NonEmptyEnum2::Foo(true));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n   --> $DIR/match-empty.rs:90:18\n@@ -198,6 +212,7 @@ LL |       match_false!(NonEmptyEnum5::V1);\n    |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyEnum5`\n \n error: aborting due to 15 previous errors\n "}, {"sha": "84cfe1da315dab35d2b89977e523141f64afe7f2", "filename": "src/test/ui/pattern/usefulness/match-non-exhaustive.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match 0 { 1 => () }\n    |           ^ patterns `std::i32::MIN..=0i32` and `2i32..=std::i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/match-non-exhaustive.rs:3:11\n@@ -13,6 +14,7 @@ LL |     match 0 { 0 if false => () }\n    |           ^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `i32`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "62e6e662fa7fae45d5667c1d2cf8d71f63e95837", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -10,6 +10,7 @@ LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `std::option::Option<private::Private>`\n \n error: aborting due to previous error\n "}, {"sha": "ba5312d213590d6690d53ebfb99309ff99916613", "filename": "src/test/ui/pattern/usefulness/match-slice-patterns.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match list {\n    |           ^^^^ pattern `&[_, Some(_), .., None, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[std::option::Option<()>]`\n \n error: aborting due to previous error\n "}, {"sha": "29aa0c1c92670e04dc8b401094b067da7857f8d9", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -20,6 +20,7 @@ LL |       match e1 {\n    |             ^^ patterns `B` and `C` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `E`\n \n error[E0005]: refutable pattern in local binding: `B` and `C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:36:9\n@@ -44,6 +45,7 @@ LL |       let E::A = e;\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n@@ -71,6 +73,7 @@ LL |       match e {\n    |             ^ patterns `&B` and `&C` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&E`\n \n error[E0005]: refutable pattern in local binding: `&B` and `&C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:44:9\n@@ -95,6 +98,7 @@ LL |       let E::A = e;\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `&E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n@@ -122,6 +126,7 @@ LL |       match e {\n    |             ^ patterns `&&mut &B` and `&&mut &C` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&&mut &E`\n \n error[E0005]: refutable pattern in local binding: `&&mut &B` and `&&mut &C` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:52:9\n@@ -146,6 +151,7 @@ LL |       let E::A = e;\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `&&mut &E`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let E::A = e { /* */ }\n@@ -168,6 +174,7 @@ LL |       match e {\n    |             ^ pattern `None` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Opt`\n \n error[E0005]: refutable pattern in local binding: `None` not covered\n   --> $DIR/non-exhaustive-defined-here.rs:69:9\n@@ -187,6 +194,7 @@ LL |       let Opt::Some(ref _x) = e;\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `Opt`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let Opt::Some(ref _x) = e { /* */ }"}, {"sha": "4835fa86cc0eeef5cc8c16956d9bbefbea7b84e3", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-float-range-match.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-float-range-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-float-range-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-float-range-match.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match 0.0 {\n    |           ^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `f64`\n \n error: aborting due to previous error\n "}, {"sha": "c9f26db6f1f8dcd3bcaba1c956930bcd0f48cb90", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match-nested.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match-nested.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match (l1, l2) {\n    |           ^^^^^^^^ pattern `(Some(&[]), Err(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(std::option::Option<&[T]>, std::result::Result<&[T], ()>)`\n \n error[E0004]: non-exhaustive patterns: `A(C)` not covered\n   --> $DIR/non-exhaustive-match-nested.rs:15:11\n@@ -19,6 +20,7 @@ LL |     match x {\n    |           ^ pattern `A(C)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `T`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "358ecf2f2d09321b33dde858ad255025140907f8", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -11,6 +11,7 @@ LL |     match x { T::B => { } }\n    |           ^ pattern `A` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `T`\n \n error[E0004]: non-exhaustive patterns: `false` not covered\n   --> $DIR/non-exhaustive-match.rs:13:11\n@@ -19,6 +20,7 @@ LL |     match true {\n    |           ^^^^ pattern `false` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `bool`\n \n error[E0004]: non-exhaustive patterns: `Some(_)` not covered\n   --> $DIR/non-exhaustive-match.rs:16:11\n@@ -32,6 +34,7 @@ LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `std::option::Option<i32>`\n \n error[E0004]: non-exhaustive patterns: `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n   --> $DIR/non-exhaustive-match.rs:19:11\n@@ -40,6 +43,7 @@ LL |     match (2, 3, 4) {\n    |           ^^^^^^^^^ patterns `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(i32, i32, i32)`\n \n error[E0004]: non-exhaustive patterns: `(A, A)` not covered\n   --> $DIR/non-exhaustive-match.rs:23:11\n@@ -48,6 +52,7 @@ LL |     match (T::A, T::A) {\n    |           ^^^^^^^^^^^^ pattern `(A, A)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(T, T)`\n \n error[E0004]: non-exhaustive patterns: `B` not covered\n   --> $DIR/non-exhaustive-match.rs:27:11\n@@ -62,6 +67,7 @@ LL |     match T::A {\n    |           ^^^^ pattern `B` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `T`\n \n error[E0004]: non-exhaustive patterns: `[]` not covered\n   --> $DIR/non-exhaustive-match.rs:38:11\n@@ -70,6 +76,7 @@ LL |     match *vec {\n    |           ^^^^ pattern `[]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `[std::option::Option<isize>]`\n \n error[E0004]: non-exhaustive patterns: `[_, _, _, _, ..]` not covered\n   --> $DIR/non-exhaustive-match.rs:51:11\n@@ -78,6 +85,7 @@ LL |     match *vec {\n    |           ^^^^ pattern `[_, _, _, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `[f32]`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "c9ed12aae5fbc128c202799fe0c14d6950f30f6e", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-pattern-witness.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-pattern-witness.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -11,6 +11,7 @@ LL |       match (Foo { first: true, second: None }) {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Foo`\n \n error[E0004]: non-exhaustive patterns: `Red` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:23:11\n@@ -27,6 +28,7 @@ LL |       match Color::Red {\n    |             ^^^^^^^^^^ pattern `Red` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Color`\n \n error[E0004]: non-exhaustive patterns: `East`, `South` and `West` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:35:11\n@@ -44,6 +46,7 @@ LL |       match Direction::North {\n    |             ^^^^^^^^^^^^^^^^ patterns `East`, `South` and `West` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Direction`\n \n error[E0004]: non-exhaustive patterns: `Second`, `Third`, `Fourth` and 8 more not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:46:11\n@@ -57,6 +60,7 @@ LL |       match ExcessiveEnum::First {\n    |             ^^^^^^^^^^^^^^^^^^^^ patterns `Second`, `Third`, `Fourth` and 8 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `ExcessiveEnum`\n \n error[E0004]: non-exhaustive patterns: `CustomRGBA { a: true, .. }` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:54:11\n@@ -73,6 +77,7 @@ LL |       match Color::Red {\n    |             ^^^^^^^^^^ pattern `CustomRGBA { a: true, .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Color`\n \n error[E0004]: non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:70:11\n@@ -81,6 +86,7 @@ LL |     match *x {\n    |           ^^ pattern `[Second(true), Second(false)]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `[Enum]`\n \n error[E0004]: non-exhaustive patterns: `((), false)` not covered\n   --> $DIR/non-exhaustive-pattern-witness.rs:83:11\n@@ -89,6 +95,7 @@ LL |     match ((), false) {\n    |           ^^^^^^^^^^^ pattern `((), false)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `((), bool)`\n \n error: aborting due to 7 previous errors\n "}, {"sha": "f5895c01599d7286bce21d18d639fcbe91483171", "filename": "src/test/ui/pattern/usefulness/refutable-pattern-errors.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -3,6 +3,8 @@ error[E0005]: refutable pattern in function argument: `(_, _)` not covered\n    |\n LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n+   |\n+   = note: the matched value is of type `(isize, (std::option::Option<isize>, isize))`\n \n error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n   --> $DIR/refutable-pattern-errors.rs:7:9\n@@ -12,6 +14,7 @@ LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `(i32, (std::option::Option<i32>, i32))`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let (1, (Some(1), 2..=3)) = (1, (None, 2)) { /* */ }"}, {"sha": "c9d8cf43f95fdb1fd0ae4176d4633f76e9b8d980", "filename": "src/test/ui/pattern/usefulness/refutable-pattern-in-fn-arg.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -3,6 +3,8 @@ error[E0005]: refutable pattern in function argument: `_` not covered\n    |\n LL |     let f = |3: isize| println!(\"hello\");\n    |              ^ pattern `_` not covered\n+   |\n+   = note: the matched value is of type `isize`\n \n error: aborting due to previous error\n "}, {"sha": "8b85eaeda0acf0cc5f51f83cc7ff6d3279931773", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match s2 {\n    |           ^^ pattern `&[false, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool; 2]`\n \n error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:12:11\n@@ -13,6 +14,7 @@ LL |     match s3 {\n    |           ^^ pattern `&[false, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool; 3]`\n \n error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:16:11\n@@ -21,6 +23,7 @@ LL |     match s10 {\n    |           ^^^ pattern `&[false, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool; 10]`\n \n error[E0004]: non-exhaustive patterns: `&[false, true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:25:11\n@@ -29,6 +32,7 @@ LL |     match s2 {\n    |           ^^ pattern `&[false, true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool; 2]`\n \n error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:30:11\n@@ -37,6 +41,7 @@ LL |     match s3 {\n    |           ^^ pattern `&[false, .., true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool; 3]`\n \n error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:35:11\n@@ -45,6 +50,7 @@ LL |     match s {\n    |           ^ pattern `&[false, .., true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:42:11\n@@ -53,6 +59,7 @@ LL |     match s {\n    |           ^ pattern `&[_, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:46:11\n@@ -61,6 +68,7 @@ LL |     match s {\n    |           ^ pattern `&[_, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:51:11\n@@ -69,6 +77,7 @@ LL |     match s {\n    |           ^ pattern `&[false, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[false, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:56:11\n@@ -77,6 +86,7 @@ LL |     match s {\n    |           ^ pattern `&[false, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[_, .., false]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:62:11\n@@ -85,6 +95,7 @@ LL |     match s {\n    |           ^ pattern `&[_, .., false]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[_, _, .., true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:69:11\n@@ -93,6 +104,7 @@ LL |     match s {\n    |           ^ pattern `&[_, _, .., true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[true, _, .., _]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:76:11\n@@ -101,6 +113,7 @@ LL |     match s {\n    |           ^ pattern `&[true, _, .., _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:85:11\n@@ -109,6 +122,7 @@ LL |     match s {\n    |           ^ pattern `&[..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[true]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:89:11\n@@ -117,6 +131,7 @@ LL |     match s {\n    |           ^ pattern `&[true]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[false]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:97:11\n@@ -125,6 +140,7 @@ LL |     match s1 {\n    |           ^^ pattern `&[false]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool; 1]`\n \n error: aborting due to 16 previous errors\n "}, {"sha": "23ff6c626f759c63e078f810a4b0dfb1040de1b0", "filename": "src/test/ui/pattern/usefulness/struct-like-enum-nonexhaustive.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fstruct-like-enum-nonexhaustive.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -12,6 +12,7 @@ LL |       match x {\n    |             ^ pattern `B { x: Some(_) }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `A`\n \n error: aborting due to previous error\n "}, {"sha": "ca8f67f3c8df2d88c0de7448da6b4207dc035bdd", "filename": "src/test/ui/pattern/usefulness/tuple-struct-nonexhaustive.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Ftuple-struct-nonexhaustive.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -8,6 +8,7 @@ LL |     match x {\n    |           ^ pattern `Foo(_, _)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "91ea323f07bb297eff237ff53012553634f296f8", "filename": "src/test/ui/precise_pointer_size_matching.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match 0isize {\n    |           ^^^^^^ patterns `std::isize::MIN..=-6isize` and `21isize..=std::isize::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `isize`\n \n error[E0004]: non-exhaustive patterns: `0usize` and `21usize..=std::usize::MAX` not covered\n   --> $DIR/precise_pointer_size_matching.rs:29:11\n@@ -13,6 +14,7 @@ LL |     match 0usize {\n    |           ^^^^^^ patterns `0usize` and `21usize..=std::usize::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `usize`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d3e05498a4a015b5b1d5009d6419c8ec2a7dd80a", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -11,6 +11,7 @@ LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `std::result::Result<u32, &R>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let Ok(x) = res { /* */ }"}, {"sha": "18d8f5481c9fbf39aa7274b2587e524488ae71bc", "filename": "src/test/ui/rfc-2005-default-binding-mode/slice.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match sl {\n    |           ^^ pattern `&[]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[u8]`\n \n error: aborting due to previous error\n "}, {"sha": "28e450336f58d8d033be8b0c15ad1b0df5ee3094", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `enums::EmptyNonExhaustiveEnum`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/enum.rs:16:11\n@@ -13,6 +14,7 @@ LL |     match enum_unit {\n    |           ^^^^^^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `enums::NonExhaustiveEnum`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/enum.rs:23:11\n@@ -21,6 +23,7 @@ LL |     match enum_unit {};\n    |           ^^^^^^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `enums::NonExhaustiveEnum`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "752b08b2b65f1f10712b321c5e6a88056d997df2", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -18,6 +18,7 @@ LL |       match NonExhaustiveEnum::Unit {}\n    |             ^^^^^^^^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonExhaustiveEnum`\n \n error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/enum_same_crate_empty_match.rs:35:11\n@@ -39,6 +40,7 @@ LL |       match NormalEnum::Unit {}\n    |             ^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NormalEnum`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "bd136333b761d17895fdf81ef9a4f4fecf190c9f", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::IndirectUninhabitedEnum`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match.rs:23:11\n@@ -13,6 +14,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::IndirectUninhabitedStruct`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match.rs:27:11\n@@ -21,6 +23,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::IndirectUninhabitedTupleStruct`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match.rs:33:11\n@@ -29,6 +32,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::IndirectUninhabitedVariants`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "42bf67c0a45dfd06b8f63f7df373528074791033", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_same_crate.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -8,6 +8,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `IndirectUninhabitedEnum`\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:38:11\n@@ -19,6 +20,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `IndirectUninhabitedStruct`\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:42:11\n@@ -30,6 +32,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `IndirectUninhabitedTupleStruct`\n \n error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:48:11\n@@ -41,6 +44,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `IndirectUninhabitedVariants`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "5211b5772642828edebd778b9a0195ba03542d48", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::IndirectUninhabitedEnum`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match_with_exhaustive_patterns.rs:27:11\n@@ -13,6 +14,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::IndirectUninhabitedStruct`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match_with_exhaustive_patterns.rs:31:11\n@@ -21,6 +23,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::IndirectUninhabitedTupleStruct`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match_with_exhaustive_patterns.rs:37:11\n@@ -29,6 +32,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::IndirectUninhabitedVariants`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "961b3e567325f3684354518359e2ce8618ee93a5", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::UninhabitedEnum`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedStruct` is non-empty\n   --> $DIR/match.rs:23:11\n@@ -13,6 +14,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::UninhabitedStruct`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedTupleStruct` is non-empty\n   --> $DIR/match.rs:27:11\n@@ -21,6 +23,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::UninhabitedTupleStruct`\n \n error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match.rs:31:11\n@@ -36,6 +39,7 @@ LL |     #[non_exhaustive] Struct { x: ! }\n    |                       ------ not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::UninhabitedVariants`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e4d0c7022f3b41c9a86d9bec898cb2e65e1c6d7a", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -10,6 +10,7 @@ LL |       match x {}\n    |             ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `UninhabitedStruct`\n \n error[E0004]: non-exhaustive patterns: type `UninhabitedTupleStruct` is non-empty\n   --> $DIR/match_same_crate.rs:34:11\n@@ -21,6 +22,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `UninhabitedTupleStruct`\n \n error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match_same_crate.rs:38:11\n@@ -37,6 +39,7 @@ LL |       match x {}\n    |             ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `UninhabitedVariants`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c489edeb699d8573287791c05c70e9d395d9da20", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -5,6 +5,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::UninhabitedEnum`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedStruct` is non-empty\n   --> $DIR/match_with_exhaustive_patterns.rs:26:11\n@@ -13,6 +14,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::UninhabitedStruct`\n \n error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedTupleStruct` is non-empty\n   --> $DIR/match_with_exhaustive_patterns.rs:30:11\n@@ -21,6 +23,7 @@ LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::UninhabitedTupleStruct`\n \n error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match_with_exhaustive_patterns.rs:34:11\n@@ -36,6 +39,7 @@ LL |     #[non_exhaustive] Struct { x: ! }\n    |                       ------ not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `uninhabited::UninhabitedVariants`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "1512eac76670d761731493be53ba22354c92b8ba", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -9,6 +9,8 @@ LL |     let A = 3;\n ...\n LL |     const A: i32 = 2;\n    |     ----------------- constant defined here\n+   |\n+   = note: the matched value is of type `i32`\n \n error: aborting due to previous error\n "}, {"sha": "e1ff38f3057f142e2052511b5fe47253edd7d99c", "filename": "src/test/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -15,6 +15,7 @@ LL |       let Foo::D(_y) = x;\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `Foo`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let Foo::D(_y) = x { /* */ }"}, {"sha": "bfe37b5029c6e0852cda4075bb81c0c8dc85db97", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2acf32d9adff836a3111c039e4e10a48ee5c79b5/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=2acf32d9adff836a3111c039e4e10a48ee5c79b5", "patch": "@@ -10,6 +10,7 @@ LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n    |     --- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `std::result::Result<u32, &Void>`\n \n error[E0004]: non-exhaustive patterns: type `&Void` is non-empty\n   --> $DIR/uninhabited-matches-feature-gated.rs:20:19\n@@ -21,6 +22,7 @@ LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&Void`\n \n error[E0004]: non-exhaustive patterns: type `(Void,)` is non-empty\n   --> $DIR/uninhabited-matches-feature-gated.rs:23:19\n@@ -29,6 +31,7 @@ LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `(Void,)`\n \n error[E0004]: non-exhaustive patterns: type `[Void; 1]` is non-empty\n   --> $DIR/uninhabited-matches-feature-gated.rs:26:19\n@@ -37,6 +40,7 @@ LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `[Void; 1]`\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n   --> $DIR/uninhabited-matches-feature-gated.rs:29:19\n@@ -45,6 +49,7 @@ LL |     let _ = match x {\n    |                   ^ pattern `&[_, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[Void]`\n \n error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n   --> $DIR/uninhabited-matches-feature-gated.rs:37:19\n@@ -58,6 +63,7 @@ LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n    |     --- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `std::result::Result<u32, Void>`\n \n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n   --> $DIR/uninhabited-matches-feature-gated.rs:42:9\n@@ -72,6 +78,7 @@ LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `std::result::Result<u32, Void>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     if let Ok(x) = x { /* */ }"}]}