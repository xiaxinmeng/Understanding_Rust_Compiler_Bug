{"sha": "6e0611a48707a1f5d90aee32a02b2b15957ef25b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMDYxMWE0ODcwN2ExZjVkOTBhZWUzMmEwMmIyYjE1OTU3ZWYyNWI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-09-30T02:34:27Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-10-02T01:50:22Z"}, "message": "Review and rebasing changes", "tree": {"sha": "343d4bb719d8472b78b33e35ea34cd959ab4e742", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/343d4bb719d8472b78b33e35ea34cd959ab4e742"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e0611a48707a1f5d90aee32a02b2b15957ef25b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e0611a48707a1f5d90aee32a02b2b15957ef25b", "html_url": "https://github.com/rust-lang/rust/commit/6e0611a48707a1f5d90aee32a02b2b15957ef25b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e0611a48707a1f5d90aee32a02b2b15957ef25b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95cfc35607ccf5f02f02de56a35a9ef50fa23a82", "url": "https://api.github.com/repos/rust-lang/rust/commits/95cfc35607ccf5f02f02de56a35a9ef50fa23a82", "html_url": "https://github.com/rust-lang/rust/commit/95cfc35607ccf5f02f02de56a35a9ef50fa23a82"}], "stats": {"total": 145, "additions": 103, "deletions": 42}, "files": [{"sha": "253375aabe8a4c78f4b7ce90d33c165e9266f504", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=6e0611a48707a1f5d90aee32a02b2b15957ef25b", "patch": "@@ -44,7 +44,8 @@\n //!\n //! A number of traits add methods that allow you to accomplish tasks with slices.\n //! These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n-//! and `MutableSlice`, defined for `&mut [T]` types.\n+//! `MutableSlice`, defined for `&mut [T]` types, and `Slice` and `SliceMut`\n+//! which are defined for `[T]`.\n //!\n //! An example is the `slice` method which enables slicing syntax `[a..b]` that\n //! returns an immutable \"view\" into a `Vec` or another slice from the index"}, {"sha": "1032a504330c60b6d772de40ac256a79bab7ff88", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=6e0611a48707a1f5d90aee32a02b2b15957ef25b", "patch": "@@ -927,6 +927,7 @@ impl<S: Str> Add<S, String> for String {\n     }\n }\n \n+#[cfg(stage0)]\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -949,6 +950,34 @@ impl ops::Slice<uint, str> for String {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[inline]\n+fn str_to_slice<'a, U: Str>(this: &'a U) -> &'a str {\n+    this.as_slice()\n+}\n+#[cfg(not(stage0))]\n+impl ops::Slice<uint, str> for String {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        str_to_slice(self)\n+    }\n+\n+    #[inline]\n+    fn slice_from<'a>(&'a self, from: &uint) -> &'a str {\n+        self[][*from..]\n+    }\n+\n+    #[inline]\n+    fn slice_to<'a>(&'a self, to: &uint) -> &'a str {\n+        self[][..*to]\n+    }\n+\n+    #[inline]\n+    fn slice<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n+        self[][*from..*to]\n+    }\n+}\n+\n /// Unsafe operations\n #[unstable = \"waiting on raw module conventions\"]\n pub mod raw {"}, {"sha": "307ad383c2c6d9db2a90f09cae839210f88f6728", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6e0611a48707a1f5d90aee32a02b2b15957ef25b", "patch": "@@ -462,6 +462,7 @@ impl<T> Index<uint,T> for Vec<T> {\n \n // Annoying helper function because there are two Slice::as_slice functions in\n // scope.\n+#[cfg(not(stage0))]\n #[inline]\n fn slice_to_slice<'a, T, U: Slice<T>>(this: &'a U) -> &'a [T] {\n     this.as_slice()\n@@ -983,7 +984,6 @@ impl<T> Vec<T> {\n     /// assert!(vec[0..2] == [1, 2]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n         self[start..end]\n     }\n@@ -1019,7 +1019,7 @@ impl<T> Vec<T> {\n     /// assert!(vec.tailn(2) == [3, 4]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_from\"]\n     pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n         self[n..]\n     }\n@@ -1229,7 +1229,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_from\"]\n     pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n         self[mut start..end]\n@@ -1249,14 +1249,13 @@ impl<T> Vec<T> {\n     /// assert!(vec[mut 0..2] == [1, 2]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n         self[mut start..end]\n     }\n \n     /// Deprecated: use \"slice_from_mut\".\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_from_mut\"]\n     pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n         self[mut start..]\n     }\n@@ -1274,13 +1273,12 @@ impl<T> Vec<T> {\n     /// assert!(vec[mut 2..] == [3, 4]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n         self[mut start..]\n     }\n \n     /// Deprecated: use `slice_to_mut`.\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_to_mut\"]\n     pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n         self[mut ..end]\n     }\n@@ -1298,7 +1296,6 @@ impl<T> Vec<T> {\n     /// assert!(vec[mut ..2] == [1, 2]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n         self[mut ..end]\n     }\n@@ -1375,7 +1372,6 @@ impl<T> Vec<T> {\n     /// assert!(vec[1..] == [2, 3]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n         self[start..]\n     }\n@@ -1393,7 +1389,6 @@ impl<T> Vec<T> {\n     /// assert!(vec[..2] == [1, 2]);\n     /// ```\n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n     pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n         self[..end]\n     }"}, {"sha": "a8becb315b201fd8cd5cc00d82aec401d193d1bd", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6e0611a48707a1f5d90aee32a02b2b15957ef25b", "patch": "@@ -152,7 +152,7 @@ pub trait ImmutableSlice<'a, T> {\n     fn tail(&self) -> &'a [T];\n \n     /// Returns all but the first `n' elements of a slice.\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_from\"]\n     fn tailn(&self, n: uint) -> &'a [T];\n \n     /// Returns all but the last element of a slice.\n@@ -161,7 +161,6 @@ pub trait ImmutableSlice<'a, T> {\n \n     /// Returns all but the last `n' elements of a slice.\n     #[deprecated = \"use slice_to but note the arguments are different\"]\n-    #[deprecated = \"use slicing syntax, but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n@@ -321,7 +320,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     fn tail(&self) -> &'a [T] { (*self)[1..] }\n \n     #[inline]\n-    #[deprecated = \"use slicing syntax\"]\n+    #[deprecated = \"use slice_from\"]\n     fn tailn(&self, n: uint) -> &'a [T] { (*self)[n..] }\n \n     #[inline]\n@@ -330,7 +329,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    #[deprecated = \"use slicing syntax but note the arguments are different\"]\n+    #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T] {\n         (*self)[..self.len() - n]\n     }\n@@ -543,7 +542,6 @@ pub trait MutableSlice<'a, T> {\n     fn get_mut(self, index: uint) -> Option<&'a mut T>;\n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    #[deprecated = \"use slicing syntax\"]\n     fn as_mut_slice(self) -> &'a mut [T];\n \n     /// Deprecated: use `iter_mut`."}, {"sha": "1c20d364bf86353b8c04d3d6a258f1f7ced7cbef", "filename": "src/libcore/str.rs", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=6e0611a48707a1f5d90aee32a02b2b15957ef25b", "patch": "@@ -1164,6 +1164,7 @@ pub mod traits {\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n+    #[cfg(stage0)]\n     impl ops::Slice<uint, str> for str {\n         #[inline]\n         fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -1172,17 +1173,39 @@ pub mod traits {\n \n         #[inline]\n         fn slice_from_<'a>(&'a self, from: &uint) -> &'a str {\n-            self.slice_from(*from)\n+            super::slice_from_impl(&self, *from)\n         }\n \n         #[inline]\n         fn slice_to_<'a>(&'a self, to: &uint) -> &'a str {\n-            self.slice_to(*to)\n+            super::slice_to_impl(&self, *to)\n         }\n \n         #[inline]\n         fn slice_<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            self.slice(*from, *to)\n+            super::slice_impl(&self, *from, *to)\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl ops::Slice<uint, str> for str {\n+        #[inline]\n+        fn as_slice<'a>(&'a self) -> &'a str {\n+            self\n+        }\n+\n+        #[inline]\n+        fn slice_from<'a>(&'a self, from: &uint) -> &'a str {\n+            super::slice_from_impl(&self, *from)\n+        }\n+\n+        #[inline]\n+        fn slice_to<'a>(&'a self, to: &uint) -> &'a str {\n+            super::slice_to_impl(&self, *to)\n+        }\n+\n+        #[inline]\n+        fn slice<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n+            super::slice_impl(&self, *from, *to)\n         }\n     }\n }\n@@ -1835,6 +1858,38 @@ fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n           begin, end, s);\n }\n \n+#[inline]\n+fn slice_impl<'a>(this: &&'a str, begin: uint, end: uint) -> &'a str {\n+    // is_char_boundary checks that the index is in [0, .len()]\n+    if begin <= end &&\n+       this.is_char_boundary(begin) &&\n+       this.is_char_boundary(end) {\n+        unsafe { raw::slice_unchecked(*this, begin, end) }\n+    } else {\n+        slice_error_fail(*this, begin, end)\n+    }\n+}\n+\n+#[inline]\n+fn slice_from_impl<'a>(this: &&'a str, begin: uint) -> &'a str {\n+    // is_char_boundary checks that the index is in [0, .len()]\n+    if this.is_char_boundary(begin) {\n+        unsafe { raw::slice_unchecked(*this, begin, this.len()) }\n+    } else {\n+        slice_error_fail(*this, begin, this.len())\n+    }\n+}\n+\n+#[inline]\n+fn slice_to_impl<'a>(this: &&'a str, end: uint) -> &'a str {\n+    // is_char_boundary checks that the index is in [0, .len()]\n+    if this.is_char_boundary(end) {\n+        unsafe { raw::slice_unchecked(*this, 0, end) }\n+    } else {\n+        slice_error_fail(*this, 0, end)\n+    }\n+}\n+\n impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n@@ -1938,34 +1993,17 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'a str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if begin <= end &&\n-           self.is_char_boundary(begin) &&\n-           self.is_char_boundary(end) {\n-            unsafe { raw::slice_unchecked(*self, begin, end) }\n-        } else {\n-            slice_error_fail(*self, begin, end)\n-        }\n+        slice_impl(self, begin, end)\n     }\n \n     #[inline]\n     fn slice_from(&self, begin: uint) -> &'a str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(begin) {\n-            unsafe { raw::slice_unchecked(*self, begin, self.len()) }\n-        } else {\n-            slice_error_fail(*self, begin, self.len())\n-        }\n+        slice_from_impl(self, begin)\n     }\n \n     #[inline]\n     fn slice_to(&self, end: uint) -> &'a str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(end) {\n-            unsafe { raw::slice_unchecked(*self, 0, end) }\n-        } else {\n-            slice_error_fail(*self, 0, end)\n-        }\n+        slice_to_impl(self, end)\n     }\n \n     fn slice_chars(&self, begin: uint, end: uint) -> &'a str {"}, {"sha": "5475de6d7e1cc4158a7d4d8ed45070c7a240349c", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=6e0611a48707a1f5d90aee32a02b2b15957ef25b", "patch": "@@ -448,7 +448,7 @@ impl rtio::RtioPipe for UnixStream {\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n-                                buf.slice_from(offset).as_ptr() as libc::LPVOID,\n+                                buf[offset..].as_ptr() as libc::LPVOID,\n                                 (buf.len() - offset) as libc::DWORD,\n                                 &mut bytes_written,\n                                 &mut overlapped)"}, {"sha": "c6948cccafec8b468808669b7c533653f849567a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=6e0611a48707a1f5d90aee32a02b2b15957ef25b", "patch": "@@ -144,7 +144,7 @@ pub mod windows {\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::{MutableSlice, ImmutableSlice};\n+    use slice::MutableSlice;\n     use string::String;\n     use str::StrSlice;\n     use vec::Vec;"}, {"sha": "e1925fc79d0dc1e8ed0c10c31f3e2ca70d33e548", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0611a48707a1f5d90aee32a02b2b15957ef25b/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=6e0611a48707a1f5d90aee32a02b2b15957ef25b", "patch": "@@ -999,7 +999,7 @@ mod imp {\n                 let bytes = cstr.as_bytes();\n                 match cstr.as_str() {\n                     Some(s) => try!(super::demangle(w, s)),\n-                    None => try!(w.write(bytes.slice_to(bytes.len() - 1))),\n+                    None => try!(w.write(bytes[..bytes.len()-1])),\n                 }\n             }\n             try!(w.write(['\\n' as u8]));"}]}