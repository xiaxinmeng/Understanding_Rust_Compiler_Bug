{"sha": "0677c204ca9482f12a7ee6b5ef9e64957dfee343", "node_id": "C_kwDOAAsO6NoAKDA2NzdjMjA0Y2E5NDgyZjEyYTdlZTZiNWVmOWU2NDk1N2RmZWUzNDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-02T10:18:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-02T10:18:36Z"}, "message": "Auto merge of #14947 - HKalbasi:render-const, r=HKalbasi\n\nAdd enum, reference, array and slice to `render_const_scalar`", "tree": {"sha": "7665738443378b8be0768d8ced6b4e2153ba328d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7665738443378b8be0768d8ced6b4e2153ba328d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0677c204ca9482f12a7ee6b5ef9e64957dfee343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0677c204ca9482f12a7ee6b5ef9e64957dfee343", "html_url": "https://github.com/rust-lang/rust/commit/0677c204ca9482f12a7ee6b5ef9e64957dfee343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0677c204ca9482f12a7ee6b5ef9e64957dfee343/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b4c09b1d2d3e6be0499f2683743716661821bf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4c09b1d2d3e6be0499f2683743716661821bf2", "html_url": "https://github.com/rust-lang/rust/commit/0b4c09b1d2d3e6be0499f2683743716661821bf2"}, {"sha": "f9e3b180b7cbee429c465408bbe0e8dbfc104cd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e3b180b7cbee429c465408bbe0e8dbfc104cd7", "html_url": "https://github.com/rust-lang/rust/commit/f9e3b180b7cbee429c465408bbe0e8dbfc104cd7"}], "stats": {"total": 676, "additions": 561, "deletions": 115}, "files": [{"sha": "d3dba52d5f07ccf6b761d609a6b2dbedbf513a04", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 185, "deletions": 68, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -17,21 +17,26 @@ use hir_def::{\n     path::{Path, PathKind},\n     type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n-    HasModule, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    EnumVariantId, HasModule, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, ModuleId,\n+    TraitId,\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use intern::{Internable, Interned};\n use itertools::Itertools;\n+use la_arena::ArenaMap;\n use smallvec::SmallVec;\n use stdx::never;\n \n use crate::{\n+    consteval::try_const_usize,\n     db::HirDatabase,\n-    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n+    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx,\n+    layout::Layout,\n+    lt_from_placeholder_idx,\n     mapping::from_chalk,\n     mir::pad16,\n     primitive, to_assoc_type_id,\n-    utils::{self, generics, ClosureSubst},\n+    utils::{self, detect_variant_from_bytes, generics, ClosureSubst},\n     AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstScalar, ConstValue,\n     DomainGoal, GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives,\n     MemoryMap, Mutability, OpaqueTy, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar,\n@@ -470,7 +475,7 @@ fn render_const_scalar(\n     // infrastructure and have it here as a field on `f`.\n     let krate = *f.db.crate_graph().crates_in_topological_order().last().unwrap();\n     match ty.kind(Interner) {\n-        chalk_ir::TyKind::Scalar(s) => match s {\n+        TyKind::Scalar(s) => match s {\n             Scalar::Bool => write!(f, \"{}\", if b[0] == 0 { false } else { true }),\n             Scalar::Char => {\n                 let x = u128::from_le_bytes(pad16(b, false)) as u32;\n@@ -498,17 +503,54 @@ fn render_const_scalar(\n                 }\n             },\n         },\n-        chalk_ir::TyKind::Ref(_, _, t) => match t.kind(Interner) {\n-            chalk_ir::TyKind::Str => {\n+        TyKind::Ref(_, _, t) => match t.kind(Interner) {\n+            TyKind::Str => {\n                 let addr = usize::from_le_bytes(b[0..b.len() / 2].try_into().unwrap());\n-                let bytes = memory_map.memory.get(&addr).map(|x| &**x).unwrap_or(&[]);\n-                let s = std::str::from_utf8(bytes).unwrap_or(\"<utf8-error>\");\n+                let size = usize::from_le_bytes(b[b.len() / 2..].try_into().unwrap());\n+                let Some(bytes) = memory_map.get(addr, size) else {\n+                    return f.write_str(\"<ref-data-not-available>\");\n+                };\n+                let s = std::str::from_utf8(&bytes).unwrap_or(\"<utf8-error>\");\n                 write!(f, \"{s:?}\")\n             }\n-            _ => f.write_str(\"<ref-not-supported>\"),\n+            TyKind::Slice(ty) => {\n+                let addr = usize::from_le_bytes(b[0..b.len() / 2].try_into().unwrap());\n+                let count = usize::from_le_bytes(b[b.len() / 2..].try_into().unwrap());\n+                let Ok(layout) = f.db.layout_of_ty(ty.clone(), krate) else {\n+                    return f.write_str(\"<layout-error>\");\n+                };\n+                let size_one = layout.size.bytes_usize();\n+                let Some(bytes) = memory_map.get(addr, size_one * count) else {\n+                    return f.write_str(\"<ref-data-not-available>\");\n+                };\n+                f.write_str(\"&[\")?;\n+                let mut first = true;\n+                for i in 0..count {\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        f.write_str(\", \")?;\n+                    }\n+                    let offset = size_one * i;\n+                    render_const_scalar(f, &bytes[offset..offset + size_one], memory_map, &ty)?;\n+                }\n+                f.write_str(\"]\")\n+            }\n+            _ => {\n+                let addr = usize::from_le_bytes(b.try_into().unwrap());\n+                let Ok(layout) = f.db.layout_of_ty(t.clone(), krate) else {\n+                    return f.write_str(\"<layout-error>\");\n+                };\n+                let size = layout.size.bytes_usize();\n+                let Some(bytes) = memory_map.get(addr, size) else {\n+                    return f.write_str(\"<ref-data-not-available>\");\n+                };\n+                f.write_str(\"&\")?;\n+                render_const_scalar(f, bytes, memory_map, t)\n+            }\n         },\n-        chalk_ir::TyKind::Tuple(_, subst) => {\n-            let Ok(layout) = f.db.layout_of_ty( ty.clone(), krate) else {\n+        TyKind::Tuple(_, subst) => {\n+            let Ok(layout) = f.db.layout_of_ty(ty.clone(), krate) else {\n                 return f.write_str(\"<layout-error>\");\n             };\n             f.write_str(\"(\")?;\n@@ -530,69 +572,144 @@ fn render_const_scalar(\n             }\n             f.write_str(\")\")\n         }\n-        chalk_ir::TyKind::Adt(adt, subst) => match adt.0 {\n-            hir_def::AdtId::StructId(s) => {\n-                let data = f.db.struct_data(s);\n-                let Ok(layout) = f.db.layout_of_adt(adt.0, subst.clone(), krate) else {\n-                    return f.write_str(\"<layout-error>\");\n-                };\n-                match data.variant_data.as_ref() {\n-                    VariantData::Record(fields) | VariantData::Tuple(fields) => {\n-                        let field_types = f.db.field_types(s.into());\n-                        let krate = adt.0.module(f.db.upcast()).krate();\n-                        let render_field = |f: &mut HirFormatter<'_>, id: LocalFieldId| {\n-                            let offset = layout\n-                                .fields\n-                                .offset(u32::from(id.into_raw()) as usize)\n-                                .bytes_usize();\n-                            let ty = field_types[id].clone().substitute(Interner, subst);\n-                            let Ok(layout) = f.db.layout_of_ty(ty.clone(), krate) else {\n-                                return f.write_str(\"<layout-error>\");\n-                            };\n-                            let size = layout.size.bytes_usize();\n-                            render_const_scalar(f, &b[offset..offset + size], memory_map, &ty)\n-                        };\n-                        let mut it = fields.iter();\n-                        if matches!(data.variant_data.as_ref(), VariantData::Record(_)) {\n-                            write!(f, \"{} {{\", data.name.display(f.db.upcast()))?;\n-                            if let Some((id, data)) = it.next() {\n-                                write!(f, \" {}: \", data.name.display(f.db.upcast()))?;\n-                                render_field(f, id)?;\n-                            }\n-                            for (id, data) in it {\n-                                write!(f, \", {}: \", data.name.display(f.db.upcast()))?;\n-                                render_field(f, id)?;\n-                            }\n-                            write!(f, \" }}\")?;\n-                        } else {\n-                            let mut it = it.map(|x| x.0);\n-                            write!(f, \"{}(\", data.name.display(f.db.upcast()))?;\n-                            if let Some(id) = it.next() {\n-                                render_field(f, id)?;\n-                            }\n-                            for id in it {\n-                                write!(f, \", \")?;\n-                                render_field(f, id)?;\n-                            }\n-                            write!(f, \")\")?;\n-                        }\n-                        return Ok(());\n-                    }\n-                    VariantData::Unit => write!(f, \"{}\", data.name.display(f.db.upcast())),\n+        TyKind::Adt(adt, subst) => {\n+            let Ok(layout) = f.db.layout_of_adt(adt.0, subst.clone(), krate) else {\n+                return f.write_str(\"<layout-error>\");\n+            };\n+            match adt.0 {\n+                hir_def::AdtId::StructId(s) => {\n+                    let data = f.db.struct_data(s);\n+                    write!(f, \"{}\", data.name.display(f.db.upcast()))?;\n+                    let field_types = f.db.field_types(s.into());\n+                    render_variant_after_name(\n+                        &data.variant_data,\n+                        f,\n+                        &field_types,\n+                        adt.0.module(f.db.upcast()).krate(),\n+                        &layout,\n+                        subst,\n+                        b,\n+                        memory_map,\n+                    )\n+                }\n+                hir_def::AdtId::UnionId(u) => {\n+                    write!(f, \"{}\", f.db.union_data(u).name.display(f.db.upcast()))\n+                }\n+                hir_def::AdtId::EnumId(e) => {\n+                    let Some((var_id, var_layout)) =\n+                            detect_variant_from_bytes(&layout, f.db, krate, b, e) else {\n+                        return f.write_str(\"<failed-to-detect-variant>\");\n+                    };\n+                    let data = &f.db.enum_data(e).variants[var_id];\n+                    write!(f, \"{}\", data.name.display(f.db.upcast()))?;\n+                    let field_types =\n+                        f.db.field_types(EnumVariantId { parent: e, local_id: var_id }.into());\n+                    render_variant_after_name(\n+                        &data.variant_data,\n+                        f,\n+                        &field_types,\n+                        adt.0.module(f.db.upcast()).krate(),\n+                        &var_layout,\n+                        subst,\n+                        b,\n+                        memory_map,\n+                    )\n                 }\n             }\n-            hir_def::AdtId::UnionId(u) => {\n-                write!(f, \"{}\", f.db.union_data(u).name.display(f.db.upcast()))\n-            }\n-            hir_def::AdtId::EnumId(_) => f.write_str(\"<enum-not-supported>\"),\n-        },\n-        chalk_ir::TyKind::FnDef(..) => ty.hir_fmt(f),\n-        chalk_ir::TyKind::Raw(_, _) => {\n+        }\n+        TyKind::FnDef(..) => ty.hir_fmt(f),\n+        TyKind::Function(_) | TyKind::Raw(_, _) => {\n             let x = u128::from_le_bytes(pad16(b, false));\n             write!(f, \"{:#X} as \", x)?;\n             ty.hir_fmt(f)\n         }\n-        _ => f.write_str(\"<not-supported>\"),\n+        TyKind::Array(ty, len) => {\n+            let Some(len) = try_const_usize(f.db, len) else {\n+                return f.write_str(\"<unknown-array-len>\");\n+            };\n+            let Ok(layout) = f.db.layout_of_ty(ty.clone(), krate) else {\n+                return f.write_str(\"<layout-error>\");\n+            };\n+            let size_one = layout.size.bytes_usize();\n+            f.write_str(\"[\")?;\n+            let mut first = true;\n+            for i in 0..len as usize {\n+                if first {\n+                    first = false;\n+                } else {\n+                    f.write_str(\", \")?;\n+                }\n+                let offset = size_one * i;\n+                render_const_scalar(f, &b[offset..offset + size_one], memory_map, &ty)?;\n+            }\n+            f.write_str(\"]\")\n+        }\n+        TyKind::Never => f.write_str(\"!\"),\n+        TyKind::Closure(_, _) => f.write_str(\"<closure>\"),\n+        TyKind::Generator(_, _) => f.write_str(\"<generator>\"),\n+        TyKind::GeneratorWitness(_, _) => f.write_str(\"<generator-witness>\"),\n+        // The below arms are unreachable, since const eval will bail out before here.\n+        TyKind::Foreign(_) => f.write_str(\"<extern-type>\"),\n+        TyKind::Error\n+        | TyKind::Placeholder(_)\n+        | TyKind::Alias(_)\n+        | TyKind::AssociatedType(_, _)\n+        | TyKind::OpaqueType(_, _)\n+        | TyKind::BoundVar(_)\n+        | TyKind::InferenceVar(_, _) => f.write_str(\"<placeholder-or-unknown-type>\"),\n+        // The below arms are unreachable, since we handled them in ref case.\n+        TyKind::Slice(_) | TyKind::Str | TyKind::Dyn(_) => f.write_str(\"<unsized-value>\"),\n+    }\n+}\n+\n+fn render_variant_after_name(\n+    data: &VariantData,\n+    f: &mut HirFormatter<'_>,\n+    field_types: &ArenaMap<LocalFieldId, Binders<Ty>>,\n+    krate: CrateId,\n+    layout: &Layout,\n+    subst: &Substitution,\n+    b: &[u8],\n+    memory_map: &MemoryMap,\n+) -> Result<(), HirDisplayError> {\n+    match data {\n+        VariantData::Record(fields) | VariantData::Tuple(fields) => {\n+            let render_field = |f: &mut HirFormatter<'_>, id: LocalFieldId| {\n+                let offset = layout.fields.offset(u32::from(id.into_raw()) as usize).bytes_usize();\n+                let ty = field_types[id].clone().substitute(Interner, subst);\n+                let Ok(layout) = f.db.layout_of_ty(ty.clone(), krate) else {\n+                    return f.write_str(\"<layout-error>\");\n+                };\n+                let size = layout.size.bytes_usize();\n+                render_const_scalar(f, &b[offset..offset + size], memory_map, &ty)\n+            };\n+            let mut it = fields.iter();\n+            if matches!(data, VariantData::Record(_)) {\n+                write!(f, \" {{\")?;\n+                if let Some((id, data)) = it.next() {\n+                    write!(f, \" {}: \", data.name.display(f.db.upcast()))?;\n+                    render_field(f, id)?;\n+                }\n+                for (id, data) in it {\n+                    write!(f, \", {}: \", data.name.display(f.db.upcast()))?;\n+                    render_field(f, id)?;\n+                }\n+                write!(f, \" }}\")?;\n+            } else {\n+                let mut it = it.map(|x| x.0);\n+                write!(f, \"(\")?;\n+                if let Some(id) = it.next() {\n+                    render_field(f, id)?;\n+                }\n+                for id in it {\n+                    write!(f, \", \")?;\n+                    render_field(f, id)?;\n+                }\n+                write!(f, \")\")?;\n+            }\n+            return Ok(());\n+        }\n+        VariantData::Unit => Ok(()),\n     }\n }\n "}, {"sha": "1a4d003bf5e993a48688c06e80267b9cbb456c73", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -35,7 +35,10 @@ mod tests;\n #[cfg(test)]\n mod test_db;\n \n-use std::{collections::HashMap, hash::Hash};\n+use std::{\n+    collections::{hash_map::Entry, HashMap},\n+    hash::Hash,\n+};\n \n use chalk_ir::{\n     fold::{Shift, TypeFoldable},\n@@ -160,7 +163,16 @@ pub struct MemoryMap {\n \n impl MemoryMap {\n     fn insert(&mut self, addr: usize, x: Vec<u8>) {\n-        self.memory.insert(addr, x);\n+        match self.memory.entry(addr) {\n+            Entry::Occupied(mut e) => {\n+                if e.get().len() < x.len() {\n+                    e.insert(x);\n+                }\n+            }\n+            Entry::Vacant(e) => {\n+                e.insert(x);\n+            }\n+        }\n     }\n \n     /// This functions convert each address by a function `f` which gets the byte intervals and assign an address\n@@ -172,6 +184,14 @@ impl MemoryMap {\n     ) -> Result<HashMap<usize, usize>, MirEvalError> {\n         self.memory.iter().map(|x| Ok((*x.0, f(x.1)?))).collect()\n     }\n+\n+    fn get<'a>(&'a self, addr: usize, size: usize) -> Option<&'a [u8]> {\n+        if size == 0 {\n+            Some(&[])\n+        } else {\n+            self.memory.get(&addr)?.get(0..size)\n+        }\n+    }\n }\n \n /// A concrete constant value"}, {"sha": "6e26d1f22aaddd4bd9f2bd743244783461364836", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 89, "deletions": 26, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -30,7 +30,7 @@ use crate::{\n     method_resolution::{is_dyn_method, lookup_impl_method},\n     name, static_lifetime,\n     traits::FnTrait,\n-    utils::ClosureSubst,\n+    utils::{detect_variant_from_bytes, ClosureSubst},\n     CallableDefId, ClosureId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap,\n     Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind,\n };\n@@ -1536,36 +1536,99 @@ impl Evaluator<'_> {\n     }\n \n     fn create_memory_map(&self, bytes: &[u8], ty: &Ty, locals: &Locals<'_>) -> Result<MemoryMap> {\n-        // FIXME: support indirect references\n-        let mut mm = MemoryMap::default();\n-        match ty.kind(Interner) {\n-            TyKind::Ref(_, _, t) => {\n-                let size = self.size_align_of(t, locals)?;\n-                match size {\n-                    Some((size, _)) => {\n-                        let addr_usize = from_bytes!(usize, bytes);\n-                        mm.insert(\n-                            addr_usize,\n-                            self.read_memory(Address::from_usize(addr_usize), size)?.to_vec(),\n-                        )\n-                    }\n-                    None => {\n-                        let element_size = match t.kind(Interner) {\n-                            TyKind::Str => 1,\n-                            TyKind::Slice(t) => {\n-                                self.size_of_sized(t, locals, \"slice inner type\")?\n+        fn rec(\n+            this: &Evaluator<'_>,\n+            bytes: &[u8],\n+            ty: &Ty,\n+            locals: &Locals<'_>,\n+            mm: &mut MemoryMap,\n+        ) -> Result<()> {\n+            match ty.kind(Interner) {\n+                TyKind::Ref(_, _, t) => {\n+                    let size = this.size_align_of(t, locals)?;\n+                    match size {\n+                        Some((size, _)) => {\n+                            let addr_usize = from_bytes!(usize, bytes);\n+                            mm.insert(\n+                                addr_usize,\n+                                this.read_memory(Address::from_usize(addr_usize), size)?.to_vec(),\n+                            )\n+                        }\n+                        None => {\n+                            let mut check_inner = None;\n+                            let element_size = match t.kind(Interner) {\n+                                TyKind::Str => 1,\n+                                TyKind::Slice(t) => {\n+                                    check_inner = Some(t);\n+                                    this.size_of_sized(t, locals, \"slice inner type\")?\n+                                }\n+                                _ => return Ok(()), // FIXME: support other kind of unsized types\n+                            };\n+                            let (addr, meta) = bytes.split_at(bytes.len() / 2);\n+                            let count = from_bytes!(usize, meta);\n+                            let size = element_size * count;\n+                            let addr = Address::from_bytes(addr)?;\n+                            let b = this.read_memory(addr, size)?;\n+                            mm.insert(addr.to_usize(), b.to_vec());\n+                            if let Some(ty) = check_inner {\n+                                for i in 0..count {\n+                                    let offset = element_size * i;\n+                                    rec(this, &b[offset..offset + element_size], ty, locals, mm)?;\n+                                }\n                             }\n-                            _ => return Ok(mm), // FIXME: support other kind of unsized types\n-                        };\n-                        let (addr, meta) = bytes.split_at(bytes.len() / 2);\n-                        let size = element_size * from_bytes!(usize, meta);\n-                        let addr = Address::from_bytes(addr)?;\n-                        mm.insert(addr.to_usize(), self.read_memory(addr, size)?.to_vec());\n+                        }\n+                    }\n+                }\n+                chalk_ir::TyKind::Tuple(_, subst) => {\n+                    let layout = this.layout(ty)?;\n+                    for (id, ty) in subst.iter(Interner).enumerate() {\n+                        let ty = ty.assert_ty_ref(Interner); // Tuple only has type argument\n+                        let offset = layout.fields.offset(id).bytes_usize();\n+                        let size = this.layout(ty)?.size.bytes_usize();\n+                        rec(this, &bytes[offset..offset + size], ty, locals, mm)?;\n                     }\n                 }\n+                chalk_ir::TyKind::Adt(adt, subst) => match adt.0 {\n+                    AdtId::StructId(s) => {\n+                        let data = this.db.struct_data(s);\n+                        let layout = this.layout(ty)?;\n+                        let field_types = this.db.field_types(s.into());\n+                        for (f, _) in data.variant_data.fields().iter() {\n+                            let offset = layout\n+                                .fields\n+                                .offset(u32::from(f.into_raw()) as usize)\n+                                .bytes_usize();\n+                            let ty = &field_types[f].clone().substitute(Interner, subst);\n+                            let size = this.layout(ty)?.size.bytes_usize();\n+                            rec(this, &bytes[offset..offset + size], ty, locals, mm)?;\n+                        }\n+                    }\n+                    AdtId::EnumId(e) => {\n+                        let layout = this.layout(ty)?;\n+                        if let Some((v, l)) =\n+                            detect_variant_from_bytes(&layout, this.db, this.crate_id, bytes, e)\n+                        {\n+                            let data = &this.db.enum_data(e).variants[v].variant_data;\n+                            let field_types = this\n+                                .db\n+                                .field_types(EnumVariantId { parent: e, local_id: v }.into());\n+                            for (f, _) in data.fields().iter() {\n+                                let offset =\n+                                    l.fields.offset(u32::from(f.into_raw()) as usize).bytes_usize();\n+                                let ty = &field_types[f].clone().substitute(Interner, subst);\n+                                let size = this.layout(ty)?.size.bytes_usize();\n+                                rec(this, &bytes[offset..offset + size], ty, locals, mm)?;\n+                            }\n+                        }\n+                    }\n+                    AdtId::UnionId(_) => (),\n+                },\n+                _ => (),\n             }\n-            _ => (),\n+            Ok(())\n         }\n+        let mut mm = MemoryMap::default();\n+        rec(self, bytes, ty, locals, &mut mm)?;\n         Ok(mm)\n     }\n "}, {"sha": "5ed95133356cd06336f9f9a0e5227bbc8bfb332e", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -1855,7 +1855,7 @@ pub fn lower_to_mir(\n     }\n     let mut ctx = MirLowerCtx::new(db, owner, body, infer);\n     // 0 is return local\n-    ctx.result.locals.alloc(Local { ty: infer[root_expr].clone() });\n+    ctx.result.locals.alloc(Local { ty: ctx.expr_ty_after_adjustments(root_expr) });\n     let binding_picker = |b: BindingId| {\n         if root_expr == body.body_expr {\n             body[b].owner.is_none()"}, {"sha": "8f36188b78a3d112c69924557794125651ed5c1b", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -20,8 +20,8 @@ use hir_def::{\n     lang_item::LangItem,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n-    ConstParamId, FunctionId, GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId,\n-    TypeOrConstParamId, TypeParamId,\n+    ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId, ItemContainerId,\n+    LocalEnumVariantId, Lookup, TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId,\n };\n use hir_expand::name::Name;\n use intern::Interned;\n@@ -30,8 +30,12 @@ use smallvec::{smallvec, SmallVec};\n use stdx::never;\n \n use crate::{\n-    consteval::unknown_const, db::HirDatabase, ChalkTraitId, Const, ConstScalar, GenericArg,\n-    Interner, Substitution, TraitRef, TraitRefExt, Ty, TyExt, WhereClause,\n+    consteval::unknown_const,\n+    db::HirDatabase,\n+    layout::{Layout, TagEncoding},\n+    mir::pad16,\n+    ChalkTraitId, Const, ConstScalar, GenericArg, Interner, Substitution, TraitRef, TraitRefExt,\n+    Ty, TyExt, WhereClause,\n };\n \n pub(crate) fn fn_traits(\n@@ -440,3 +444,41 @@ impl FallibleTypeFolder<Interner> for UnevaluatedConstEvaluatorFolder<'_> {\n         Ok(constant)\n     }\n }\n+\n+pub(crate) fn detect_variant_from_bytes<'a>(\n+    layout: &'a Layout,\n+    db: &dyn HirDatabase,\n+    krate: CrateId,\n+    b: &[u8],\n+    e: EnumId,\n+) -> Option<(LocalEnumVariantId, &'a Layout)> {\n+    let (var_id, var_layout) = match &layout.variants {\n+        hir_def::layout::Variants::Single { index } => (index.0, &*layout),\n+        hir_def::layout::Variants::Multiple { tag, tag_encoding, variants, .. } => {\n+            let target_data_layout = db.target_data_layout(krate)?;\n+            let size = tag.size(&*target_data_layout).bytes_usize();\n+            let offset = layout.fields.offset(0).bytes_usize(); // The only field on enum variants is the tag field\n+            let tag = i128::from_le_bytes(pad16(&b[offset..offset + size], false));\n+            match tag_encoding {\n+                TagEncoding::Direct => {\n+                    let x = variants.iter_enumerated().find(|x| {\n+                        db.const_eval_discriminant(EnumVariantId { parent: e, local_id: x.0 .0 })\n+                            == Ok(tag)\n+                    })?;\n+                    (x.0 .0, x.1)\n+                }\n+                TagEncoding::Niche { untagged_variant, niche_start, .. } => {\n+                    let candidate_tag = tag.wrapping_sub(*niche_start as i128) as usize;\n+                    let variant = variants\n+                        .iter_enumerated()\n+                        .map(|(x, _)| x)\n+                        .filter(|x| x != untagged_variant)\n+                        .nth(candidate_tag)\n+                        .unwrap_or(*untagged_variant);\n+                    (variant.0, &variants[variant])\n+                }\n+            }\n+        }\n+    };\n+    Some((var_id, var_layout))\n+}"}, {"sha": "2db4b483b69d444e4505bfab6cae272106feacac", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -2106,14 +2106,6 @@ impl Const {\n     pub fn render_eval(self, db: &dyn HirDatabase) -> Result<String, ConstEvalError> {\n         let c = db.const_eval(self.id.into(), Substitution::empty(Interner))?;\n         let r = format!(\"{}\", HexifiedConst(c).display(db));\n-        // We want to see things like `<utf8-error>` and `<layout-error>` as they are probably bug in our\n-        // implementation, but there is no need to show things like `<enum-not-supported>` or `<ref-not-supported>` to\n-        // the user.\n-        if r.contains(\"not-supported>\") {\n-            return Err(ConstEvalError::MirEvalError(MirEvalError::NotSupported(\n-                \"rendering complex constants\".to_string(),\n-            )));\n-        }\n         return Ok(r);\n     }\n }"}, {"sha": "d2c035c471e43838d69399c2b70fe1031ed67e21", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -4337,6 +4337,211 @@ const FOO$0: f64 = 1.0f64;\n     );\n }\n \n+#[test]\n+fn hover_const_eval_enum() {\n+    check(\n+        r#\"\n+enum Enum {\n+    V1,\n+    V2,\n+}\n+\n+const VX: Enum = Enum::V1;\n+\n+const FOO$0: Enum = VX;\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: Enum = V1\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+//- minicore: option\n+const FOO$0: Option<i32> = Some(2);\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: Option<i32> = Some(2)\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+//- minicore: option\n+const FOO$0: Option<&i32> = Some(2).as_ref();\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: Option<&i32> = Some(&2)\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn hover_const_eval_slice() {\n+    check(\n+        r#\"\n+//- minicore: slice, index, coerce_unsized\n+const FOO$0: &[i32] = &[1, 2, 3 + 4];\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: &[i32] = &[1, 2, 7]\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+//- minicore: slice, index, coerce_unsized\n+const FOO$0: &[i32; 5] = &[12; 5];\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: &[i32; 5] = &[12, 12, 12, 12, 12]\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+//- minicore: slice, index, coerce_unsized\n+\n+const FOO$0: (&i32, &[i32], &i32) = {\n+    let a: &[i32] = &[1, 2, 3];\n+    (&a[0], a, &a[0])\n+}\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: (&i32, &[i32], &i32) = (&1, &[1, 2, 3], &1)\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+//- minicore: slice, index, coerce_unsized\n+\n+struct Tree(&[Tree]);\n+\n+const FOO$0: Tree = {\n+    let x = &[Tree(&[]), Tree(&[Tree(&[])])];\n+    Tree(&[Tree(x), Tree(x)])\n+}\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: Tree = Tree(&[Tree(&[Tree(&[]), Tree(&[Tree(&[])])]), Tree(&[Tree(&[]), Tree(&[Tree(&[])])])])\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn hover_const_eval_str() {\n+    check(\n+        r#\"\n+const FOO$0: &str = \"foo\";\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: &str = \"foo\"\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+struct X {\n+    a: &'static str,\n+    b: &'static str,\n+}\n+const FOO$0: X = X {\n+    a: \"axiom\",\n+    b: \"buy N large\",\n+};\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: X = X { a: \"axiom\", b: \"buy N large\" }\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+const FOO$0: (&str, &str) = {\n+    let x = \"foo\";\n+    (x, x)\n+};\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: (&str, &str) = (\"foo\", \"foo\")\n+            ```\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_const_eval_in_generic_trait() {\n     // Doesn't compile, but we shouldn't crash."}, {"sha": "ce1e03a069b2455588e9511cc32186085c895b67", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -474,7 +474,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 9165..9173,\n+                                        range: 9332..9340,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -487,7 +487,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 9197..9201,\n+                                        range: 9364..9368,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -511,7 +511,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 9165..9173,\n+                                        range: 9332..9340,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -524,7 +524,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 9197..9201,\n+                                        range: 9364..9368,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -548,7 +548,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 9165..9173,\n+                                        range: 9332..9340,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -561,7 +561,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 9197..9201,\n+                                        range: 9364..9368,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "c9e85e36870f9f0dca016eec4ccb030a844fed22", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677c204ca9482f12a7ee6b5ef9e64957dfee343/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=0677c204ca9482f12a7ee6b5ef9e64957dfee343", "patch": "@@ -941,6 +941,13 @@ pub mod option {\n             }\n         }\n \n+        pub const fn as_ref(&self) -> Option<&T> {\n+            match self {\n+                Some(x) => Some(x),\n+                None => None,\n+            }\n+        }\n+\n         pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n             loop {}\n         }"}]}