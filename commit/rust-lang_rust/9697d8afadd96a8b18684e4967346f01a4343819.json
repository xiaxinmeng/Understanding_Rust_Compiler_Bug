{"sha": "9697d8afadd96a8b18684e4967346f01a4343819", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2OTdkOGFmYWRkOTZhOGIxODY4NGU0OTY3MzQ2ZjAxYTQzNDM4MTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-31T17:42:53Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-31T17:42:53Z"}, "message": "cleanup", "tree": {"sha": "1341ba63d4f461dc9e3f93f6ad1b7a0d8962f6fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1341ba63d4f461dc9e3f93f6ad1b7a0d8962f6fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9697d8afadd96a8b18684e4967346f01a4343819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9697d8afadd96a8b18684e4967346f01a4343819", "html_url": "https://github.com/rust-lang/rust/commit/9697d8afadd96a8b18684e4967346f01a4343819", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9697d8afadd96a8b18684e4967346f01a4343819/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15efd58274855b755c99e5c088102920b70f3d80", "url": "https://api.github.com/repos/rust-lang/rust/commits/15efd58274855b755c99e5c088102920b70f3d80", "html_url": "https://github.com/rust-lang/rust/commit/15efd58274855b755c99e5c088102920b70f3d80"}], "stats": {"total": 81, "additions": 42, "deletions": 39}, "files": [{"sha": "8f41937dc42edd5c7608a2c04a9ad94853b0b740", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9697d8afadd96a8b18684e4967346f01a4343819/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9697d8afadd96a8b18684e4967346f01a4343819/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=9697d8afadd96a8b18684e4967346f01a4343819", "patch": "@@ -225,27 +225,15 @@ fn main_loop_inner(\n                             let resp = RawResponse::ok::<req::CollectGarbage>(id, &());\n                             msg_sender.send(resp.into()).unwrap()\n                         }\n-                        Err(req) => {\n-                            match on_request(\n-                                state,\n-                                pending_requests,\n-                                pool,\n-                                &task_sender,\n-                                loop_start,\n-                                req,\n-                            )? {\n-                                None => (),\n-                                Some(req) => {\n-                                    log::error!(\"unknown request: {:?}\", req);\n-                                    let resp = RawResponse::err(\n-                                        req.id,\n-                                        ErrorCode::MethodNotFound as i32,\n-                                        \"unknown request\".to_string(),\n-                                    );\n-                                    msg_sender.send(resp.into()).unwrap()\n-                                }\n-                            }\n-                        }\n+                        Err(req) => on_request(\n+                            state,\n+                            pending_requests,\n+                            pool,\n+                            &task_sender,\n+                            msg_sender,\n+                            loop_start,\n+                            req,\n+                        )?,\n                     }\n                 }\n                 RawMessage::Notification(not) => {\n@@ -320,12 +308,20 @@ fn on_request(\n     pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n+    msg_sender: &Sender<RawMessage>,\n     request_received: Instant,\n     req: RawRequest,\n-) -> Result<Option<RawRequest>> {\n-    let method = req.method.clone();\n-    let mut pool_dispatcher = PoolDispatcher { req: Some(req), res: None, pool, world, sender };\n-    let req = pool_dispatcher\n+) -> Result<()> {\n+    let mut pool_dispatcher = PoolDispatcher {\n+        req: Some(req),\n+        pool,\n+        world,\n+        sender,\n+        msg_sender,\n+        pending_requests,\n+        request_received,\n+    };\n+    pool_dispatcher\n         .on::<req::AnalyzerStatus>(handlers::handle_analyzer_status)?\n         .on::<req::SyntaxTree>(handlers::handle_syntax_tree)?\n         .on::<req::ExtendSelection>(handlers::handle_extend_selection)?\n@@ -355,13 +351,7 @@ fn on_request(\n         .on::<req::Formatting>(handlers::handle_formatting)?\n         .on::<req::DocumentHighlightRequest>(handlers::handle_document_highlight)?\n         .finish();\n-    match req {\n-        Ok(id) => {\n-            pending_requests.start(PendingRequest { id, method, received: request_received });\n-            Ok(None)\n-        }\n-        Err(req) => Ok(Some(req)),\n-    }\n+    Ok(())\n }\n \n fn on_notification(\n@@ -435,10 +425,12 @@ fn on_notification(\n \n struct PoolDispatcher<'a> {\n     req: Option<RawRequest>,\n-    res: Option<u64>,\n     pool: &'a ThreadPool,\n     world: &'a mut ServerWorldState,\n+    pending_requests: &'a mut PendingRequests,\n+    msg_sender: &'a Sender<RawMessage>,\n     sender: &'a Sender<Task>,\n+    request_received: Instant,\n }\n \n impl<'a> PoolDispatcher<'a> {\n@@ -459,7 +451,11 @@ impl<'a> PoolDispatcher<'a> {\n                 return Ok(self);\n             }\n         };\n-        self.res = Some(id);\n+        self.pending_requests.start(PendingRequest {\n+            id,\n+            method: R::METHOD.to_string(),\n+            received: self.request_received,\n+        });\n \n         // Real time requests block user typing, so we should react quickly to them.\n         // Currently this means that we try to cancel background jobs if we don't have\n@@ -483,11 +479,18 @@ impl<'a> PoolDispatcher<'a> {\n         Ok(self)\n     }\n \n-    fn finish(&mut self) -> std::result::Result<u64, RawRequest> {\n-        match (self.res.take(), self.req.take()) {\n-            (Some(res), None) => Ok(res),\n-            (None, Some(req)) => Err(req),\n-            _ => unreachable!(),\n+    fn finish(&mut self) {\n+        match self.req.take() {\n+            None => (),\n+            Some(req) => {\n+                log::error!(\"unknown request: {:?}\", req);\n+                let resp = RawResponse::err(\n+                    req.id,\n+                    ErrorCode::MethodNotFound as i32,\n+                    \"unknown request\".to_string(),\n+                );\n+                self.msg_sender.send(resp.into()).unwrap();\n+            }\n         }\n     }\n }"}]}