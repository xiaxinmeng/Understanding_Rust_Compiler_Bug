{"sha": "2b2d1e14c97b7692debf62dd2739049f1f377a5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMmQxZTE0Yzk3Yjc2OTJkZWJmNjJkZDI3MzkwNDlmMWYzNzdhNWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-22T05:21:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-23T17:03:43Z"}, "message": "std: Change CharEq to take `&mut self`\n\nThis is similar to the previous commits to allow invocation of a closure through\na `&mut self` pointer because `&self` is disallowed. One of the primary\nimplementors of the CharEq trait is a closure type, which would not work if the\nmethod continued to have `&self`.\n\nIn addition to changing mutability of the `matches` method, this modifies the\nfollowing methods from &CharEq to take a type which implements CharEq by value.\n\n* trim_chars\n* trim_left_chars\n* trim_right_chars\n\nWhere these methods were previously invoked via\n\n    s.trim_chars(&'a')\n\nit would now be invoked through\n\n    s.trim_chars('a')\n\n[breaking-change]", "tree": {"sha": "a7bfb98bc1e31c71e1a1fadfd4896b3dda9a52a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7bfb98bc1e31c71e1a1fadfd4896b3dda9a52a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b2d1e14c97b7692debf62dd2739049f1f377a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b2d1e14c97b7692debf62dd2739049f1f377a5e", "html_url": "https://github.com/rust-lang/rust/commit/2b2d1e14c97b7692debf62dd2739049f1f377a5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b2d1e14c97b7692debf62dd2739049f1f377a5e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4083a22451692b9ae360f3d12bfb8cb52b096e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4083a22451692b9ae360f3d12bfb8cb52b096e4", "html_url": "https://github.com/rust-lang/rust/commit/f4083a22451692b9ae360f3d12bfb8cb52b096e4"}], "stats": {"total": 110, "additions": 60, "deletions": 50}, "files": [{"sha": "64d2007ad1573d2d042394856d14c5cfe0b1a69a", "filename": "src/libstd/str.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2b2d1e14c97b7692debf62dd2739049f1f377a5e/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b2d1e14c97b7692debf62dd2739049f1f377a5e/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=2b2d1e14c97b7692debf62dd2739049f1f377a5e", "patch": "@@ -217,37 +217,37 @@ impl<'a, S: Str> StrVector for Vec<S> {\n /// Something that can be used to compare against a character\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n-    fn matches(&self, char) -> bool;\n+    fn matches(&mut self, char) -> bool;\n     /// Indicate if this is only concerned about ASCII characters,\n     /// which can allow for a faster implementation.\n     fn only_ascii(&self) -> bool;\n }\n \n impl CharEq for char {\n     #[inline]\n-    fn matches(&self, c: char) -> bool { *self == c }\n+    fn matches(&mut self, c: char) -> bool { *self == c }\n \n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n \n impl<'a> CharEq for |char|: 'a -> bool {\n     #[inline]\n-    fn matches(&self, c: char) -> bool { (*self)(c) }\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n \n     fn only_ascii(&self) -> bool { false }\n }\n \n impl CharEq for extern \"Rust\" fn(char) -> bool {\n     #[inline]\n-    fn matches(&self, c: char) -> bool { (*self)(c) }\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n \n     fn only_ascii(&self) -> bool { false }\n }\n \n-impl<'a, C: CharEq> CharEq for &'a [C] {\n+impl<'a> CharEq for &'a [char] {\n     #[inline]\n-    fn matches(&self, c: char) -> bool {\n-        self.iter().any(|m| m.matches(c))\n+    fn matches(&mut self, c: char) -> bool {\n+        self.iter().any(|&mut m| m.matches(c))\n     }\n \n     fn only_ascii(&self) -> bool {\n@@ -1977,11 +1977,11 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n+    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n     /// ```\n-    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n+    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n \n     /// Returns a string with leading `chars_to_trim` removed.\n     ///\n@@ -1992,11 +1992,11 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n     /// ```\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n \n     /// Returns a string with trailing `chars_to_trim` removed.\n     ///\n@@ -2007,11 +2007,11 @@ pub trait StrSlice<'a> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n     /// ```\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n \n     /// Replace all occurrences of one string with another.\n     ///\n@@ -2487,29 +2487,39 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn trim_left(&self) -> &'a str {\n-        self.trim_left_chars(&char::is_whitespace)\n+        self.trim_left_chars(char::is_whitespace)\n     }\n \n     #[inline]\n     fn trim_right(&self) -> &'a str {\n-        self.trim_right_chars(&char::is_whitespace)\n+        self.trim_right_chars(char::is_whitespace)\n     }\n \n     #[inline]\n-    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n-        self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n+    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+        let cur = match self.find(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(i) => unsafe { raw::slice_bytes(*self, i, self.len()) }\n+        };\n+        match cur.rfind(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(i) => {\n+                let right = cur.char_range_at(i).next;\n+                unsafe { raw::slice_bytes(cur, 0, right) }\n+            }\n+        }\n     }\n \n     #[inline]\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n+    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n         match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n         }\n     }\n \n     #[inline]\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n+    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n         match self.rfind(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(last) => {\n@@ -2627,7 +2637,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         unsafe { cast::transmute(*self) }\n     }\n \n-    fn find<C: CharEq>(&self, search: C) -> Option<uint> {\n+    fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {\n         if search.only_ascii() {\n             self.bytes().position(|b| search.matches(b as char))\n         } else {\n@@ -2638,7 +2648,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         }\n     }\n \n-    fn rfind<C: CharEq>(&self, search: C) -> Option<uint> {\n+    fn rfind<C: CharEq>(&self, mut search: C) -> Option<uint> {\n         if search.only_ascii() {\n             self.bytes().rposition(|b| search.matches(b as char))\n         } else {\n@@ -3156,40 +3166,40 @@ mod tests {\n     #[test]\n     fn test_trim_left_chars() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_left_chars(&v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_left_chars(& &['*', ' ']), \"foo *** \");\n-        assert_eq!(\" ***  *** \".trim_left_chars(& &['*', ' ']), \"\");\n-        assert_eq!(\"foo *** \".trim_left_chars(& &['*', ' ']), \"foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_left_chars(&['*', ' ']), \"foo *** \");\n+        assert_eq!(\" ***  *** \".trim_left_chars(&['*', ' ']), \"\");\n+        assert_eq!(\"foo *** \".trim_left_chars(&['*', ' ']), \"foo *** \");\n \n-        assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\");\n-        assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\");\n-        assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\");\n+        assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n+        assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\");\n+        assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_right_chars(&v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_right_chars(& &['*', ' ']), \" *** foo\");\n-        assert_eq!(\" ***  *** \".trim_right_chars(& &['*', ' ']), \"\");\n-        assert_eq!(\" *** foo\".trim_right_chars(& &['*', ' ']), \" *** foo\");\n+        assert_eq!(\" *** foo *** \".trim_right_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_right_chars(&['*', ' ']), \" *** foo\");\n+        assert_eq!(\" ***  *** \".trim_right_chars(&['*', ' ']), \"\");\n+        assert_eq!(\" *** foo\".trim_right_chars(&['*', ' ']), \" *** foo\");\n \n-        assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\");\n-        assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\");\n+        assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n         let v: &[char] = &[];\n-        assert_eq!(\" *** foo *** \".trim_chars(&v), \" *** foo *** \");\n-        assert_eq!(\" *** foo *** \".trim_chars(& &['*', ' ']), \"foo\");\n-        assert_eq!(\" ***  *** \".trim_chars(& &['*', ' ']), \"\");\n-        assert_eq!(\"foo\".trim_chars(& &['*', ' ']), \"foo\");\n+        assert_eq!(\" *** foo *** \".trim_chars(v), \" *** foo *** \");\n+        assert_eq!(\" *** foo *** \".trim_chars(&['*', ' ']), \"foo\");\n+        assert_eq!(\" ***  *** \".trim_chars(&['*', ' ']), \"\");\n+        assert_eq!(\"foo\".trim_chars(&['*', ' ']), \"foo\");\n \n-        assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\");\n-        assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\");\n-        assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\");\n+        assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n+        assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\");\n+        assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\");\n     }\n \n     #[test]\n@@ -4119,7 +4129,7 @@ mod bench {\n     fn split_unicode_not_ascii(b: &mut Bencher) {\n         struct NotAscii(char);\n         impl CharEq for NotAscii {\n-            fn matches(&self, c: char) -> bool {\n+            fn matches(&mut self, c: char) -> bool {\n                 let NotAscii(cc) = *self;\n                 cc == c\n             }\n@@ -4144,7 +4154,7 @@ mod bench {\n         struct NotAscii(char);\n         impl CharEq for NotAscii {\n             #[inline]\n-            fn matches(&self, c: char) -> bool {\n+            fn matches(&mut self, c: char) -> bool {\n                 let NotAscii(cc) = *self;\n                 cc == c\n             }"}]}