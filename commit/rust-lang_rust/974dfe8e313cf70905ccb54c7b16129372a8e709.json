{"sha": "974dfe8e313cf70905ccb54c7b16129372a8e709", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NGRmZThlMzEzY2Y3MDkwNWNjYjU0YzdiMTYxMjkzNzJhOGU3MDk=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2015-09-15T22:58:19Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2015-09-19T21:35:18Z"}, "message": "Split out the UNUSED_* lints into a new module\n\nPart of #22206", "tree": {"sha": "2c7b093fc69bde07019ff7203ddb61e0aeaa06c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c7b093fc69bde07019ff7203ddb61e0aeaa06c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/974dfe8e313cf70905ccb54c7b16129372a8e709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/974dfe8e313cf70905ccb54c7b16129372a8e709", "html_url": "https://github.com/rust-lang/rust/commit/974dfe8e313cf70905ccb54c7b16129372a8e709", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/974dfe8e313cf70905ccb54c7b16129372a8e709/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "html_url": "https://github.com/rust-lang/rust/commit/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3"}], "stats": {"total": 922, "additions": 477, "deletions": 445}, "files": [{"sha": "febf8ef6e472520629964ec4a8ec91e6144595da", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 445, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/974dfe8e313cf70905ccb54c7b16129372a8e709/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974dfe8e313cf70905ccb54c7b16129372a8e709/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=974dfe8e313cf70905ccb54c7b16129372a8e709", "patch": "@@ -28,30 +28,28 @@\n //! Use the former for unit-like structs and the latter for structs with\n //! a `pub fn new()`.\n \n-use metadata::{csearch, decoder};\n-use middle::{cfg, def, infer, pat_util, stability, traits};\n+use metadata::decoder;\n+use middle::{cfg, def, infer, stability, traits};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::ty::adjustment;\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::front::map as hir_map;\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n-use lint::{Level, LateContext, EarlyContext, LintContext, LintArray, Lint};\n-use lint::{LintPass, EarlyLintPass, LateLintPass};\n+use util::nodemap::{FnvHashSet, NodeSet};\n+use lint::{Level, LateContext, LintContext, LintArray, Lint};\n+use lint::{LintPass, LateLintPass};\n \n use std::collections::HashSet;\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::{cmp, slice};\n+use std::cmp;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n-use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType, emit_feature_err, GateIssue};\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n-use syntax::ptr::P;\n \n use rustc_front::hir;\n use rustc_front::visit::{self, FnKind, Visitor};\n@@ -883,302 +881,6 @@ impl LateLintPass for RawPointerDerive {\n     }\n }\n \n-declare_lint! {\n-    UNUSED_ATTRIBUTES,\n-    Warn,\n-    \"detects attributes that were not used by the compiler\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedAttributes;\n-\n-impl LintPass for UnusedAttributes {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ATTRIBUTES)\n-    }\n-}\n-\n-impl LateLintPass for UnusedAttributes {\n-    fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n-        // Note that check_name() marks the attribute as used if it matches.\n-        for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n-            match ty {\n-                AttributeType::Whitelisted if attr.check_name(name) => {\n-                    break;\n-                },\n-                _ => ()\n-            }\n-        }\n-\n-        let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n-        for &(ref name, ty) in plugin_attributes.iter() {\n-            if ty == AttributeType::Whitelisted && attr.check_name(&*name) {\n-                break;\n-            }\n-        }\n-\n-        if !attr::is_used(attr) {\n-            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n-            // Is it a builtin attribute that must be used at the crate level?\n-            let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n-                attr.name() == name &&\n-                ty == AttributeType::CrateLevel\n-            }).is_some();\n-\n-            // Has a plugin registered this attribute as one which must be used at\n-            // the crate level?\n-            let plugin_crate = plugin_attributes.iter()\n-                                                .find(|&&(ref x, t)| {\n-                                                        &*attr.name() == &*x &&\n-                                                        AttributeType::CrateLevel == t\n-                                                    }).is_some();\n-            if  known_crate || plugin_crate {\n-                let msg = match attr.node.style {\n-                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n-                                       attribute: add an exclamation mark: #![foo]\",\n-                    ast::AttrInner => \"crate-level attribute should be in the \\\n-                                       root module\",\n-                };\n-                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub PATH_STATEMENTS,\n-    Warn,\n-    \"path statements with no effect\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct PathStatements;\n-\n-impl LintPass for PathStatements {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(PATH_STATEMENTS)\n-    }\n-}\n-\n-impl LateLintPass for PathStatements {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        match s.node {\n-            hir::StmtSemi(ref expr, _) => {\n-                match expr.node {\n-                    hir::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n-                                                      \"path statement with no effect\"),\n-                    _ => ()\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub UNUSED_MUST_USE,\n-    Warn,\n-    \"unused result of a type flagged as #[must_use]\"\n-}\n-\n-declare_lint! {\n-    pub UNUSED_RESULTS,\n-    Allow,\n-    \"unused result of an expression in a statement\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedResults;\n-\n-impl LintPass for UnusedResults {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n-    }\n-}\n-\n-impl LateLintPass for UnusedResults {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        let expr = match s.node {\n-            hir::StmtSemi(ref expr, _) => &**expr,\n-            _ => return\n-        };\n-\n-        if let hir::ExprRet(..) = expr.node {\n-            return;\n-        }\n-\n-        let t = cx.tcx.expr_ty(&expr);\n-        let warned = match t.sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => return,\n-            ty::TyBool => return,\n-            ty::TyStruct(def, _) |\n-            ty::TyEnum(def, _) => {\n-                if def.did.is_local() {\n-                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n-                        check_must_use(cx, &it.attrs, s.span)\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, def.did);\n-                    check_must_use(cx, &attrs[..], s.span)\n-                }\n-            }\n-            _ => false,\n-        };\n-        if !warned {\n-            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n-        }\n-\n-        fn check_must_use(cx: &LateContext, attrs: &[ast::Attribute], sp: Span) -> bool {\n-            for attr in attrs {\n-                if attr.check_name(\"must_use\") {\n-                    let mut msg = \"unused result which must be used\".to_string();\n-                    // check for #[must_use=\"...\"]\n-                    match attr.value_str() {\n-                        None => {}\n-                        Some(s) => {\n-                            msg.push_str(\": \");\n-                            msg.push_str(&s);\n-                        }\n-                    }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n-                    return true;\n-                }\n-            }\n-            false\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_PARENS,\n-    Warn,\n-    \"`if`, `match`, `while` and `return` do not need parentheses\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedParens;\n-\n-impl UnusedParens {\n-    fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n-                                struct_lit_needs_parens: bool) {\n-        if let ast::ExprParen(ref inner) = value.node {\n-            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n-            if !necessary {\n-                cx.span_lint(UNUSED_PARENS, value.span,\n-                             &format!(\"unnecessary parentheses around {}\", msg))\n-            }\n-        }\n-\n-        /// Expressions that syntactically contain an \"exterior\" struct\n-        /// literal i.e. not surrounded by any parens or other\n-        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n-        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n-        /// y: 1 }) == foo` does not.\n-        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-            match value.node {\n-                ast::ExprStruct(..) => true,\n-\n-                ast::ExprAssign(ref lhs, ref rhs) |\n-                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprBinary(_, ref lhs, ref rhs) => {\n-                    // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&**lhs) ||\n-                        contains_exterior_struct_lit(&**rhs)\n-                }\n-                ast::ExprUnary(_, ref x) |\n-                ast::ExprCast(ref x, _) |\n-                ast::ExprField(ref x, _) |\n-                ast::ExprTupField(ref x, _) |\n-                ast::ExprIndex(ref x, _) => {\n-                    // &X { y: 1 }, X { y: 1 }.y\n-                    contains_exterior_struct_lit(&**x)\n-                }\n-\n-                ast::ExprMethodCall(_, _, ref exprs) => {\n-                    // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&*exprs[0])\n-                }\n-\n-                _ => false\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for UnusedParens {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_PARENS)\n-    }\n-}\n-\n-impl EarlyLintPass for UnusedParens {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n-        let (value, msg, struct_lit_needs_parens) = match e.node {\n-            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n-            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(ref head, _, source) => match source {\n-                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n-                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n-                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n-                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n-            },\n-            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n-            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n-            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n-            _ => return\n-        };\n-        self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n-    }\n-\n-    fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n-        let (value, msg) = match s.node {\n-            ast::StmtDecl(ref decl, _) => match decl.node {\n-                ast::DeclLocal(ref local) => match local.init {\n-                    Some(ref value) => (value, \"assigned value\"),\n-                    None => return\n-                },\n-                _ => return\n-            },\n-            _ => return\n-        };\n-        self.check_unused_parens_core(cx, &**value, msg, false);\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_IMPORT_BRACES,\n-    Allow,\n-    \"unnecessary braces around an imported item\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedImportBraces;\n-\n-impl LintPass for UnusedImportBraces {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_IMPORT_BRACES)\n-    }\n-}\n-\n-impl LateLintPass for UnusedImportBraces {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        if let hir::ItemUse(ref view_path) = item.node {\n-            if let hir::ViewPathList(_, ref items) = view_path.node {\n-                if items.len() == 1 {\n-                    if let hir::PathListIdent {ref name, ..} = items[0].node {\n-                        let m = format!(\"braces around {} is unnecessary\",\n-                                        name);\n-                        cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n-                                     &m[..]);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     NON_SHORTHAND_FIELD_PATTERNS,\n     Warn,\n@@ -1220,33 +922,6 @@ impl LateLintPass for NonShorthandFieldPatterns {\n     }\n }\n \n-declare_lint! {\n-    pub UNUSED_UNSAFE,\n-    Warn,\n-    \"unnecessary use of an `unsafe` block\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedUnsafe;\n-\n-impl LintPass for UnusedUnsafe {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_UNSAFE)\n-    }\n-}\n-\n-impl LateLintPass for UnusedUnsafe {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprBlock(ref blk) = e.node {\n-            // Don't warn about generated blocks, that'll just pollute the output.\n-            if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n-                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     UNSAFE_CODE,\n     Allow,\n@@ -1310,119 +985,6 @@ impl LateLintPass for UnsafeCode {\n     }\n }\n \n-declare_lint! {\n-    pub UNUSED_MUT,\n-    Warn,\n-    \"detect mut variables which don't need to be mutable\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedMut;\n-\n-impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &LateContext, pats: &[P<hir::Pat>]) {\n-        // collect all mutable pattern and group their NodeIDs by their Identifier to\n-        // avoid false warnings in match arms with multiple patterns\n-\n-        let mut mutables = FnvHashMap();\n-        for p in pats {\n-            pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path1| {\n-                let ident = path1.node;\n-                if let hir::BindByValue(hir::MutMutable) = mode {\n-                    if !ident.name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(ident.name.usize()) {\n-                            Vacant(entry) => { entry.insert(vec![id]); },\n-                            Occupied(mut entry) => { entry.get_mut().push(id); },\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-        for (_, v) in &mutables {\n-            if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n-                             \"variable does not need to be mutable\");\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for UnusedMut {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUT)\n-    }\n-}\n-\n-impl LateLintPass for UnusedMut {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprMatch(_, ref arms, _) = e.node {\n-            for a in arms {\n-                self.check_unused_mut_pat(cx, &a.pats)\n-            }\n-        }\n-    }\n-\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        if let hir::StmtDecl(ref d, _) = s.node {\n-            if let hir::DeclLocal(ref l) = d.node {\n-                self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n-            }\n-        }\n-    }\n-\n-    fn check_fn(&mut self, cx: &LateContext,\n-                _: FnKind, decl: &hir::FnDecl,\n-                _: &hir::Block, _: Span, _: ast::NodeId) {\n-        for a in &decl.inputs {\n-            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_ALLOCATION,\n-    Warn,\n-    \"detects unnecessary allocations that can be eliminated\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedAllocation;\n-\n-impl LintPass for UnusedAllocation {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ALLOCATION)\n-    }\n-}\n-\n-impl LateLintPass for UnusedAllocation {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        match e.node {\n-            hir::ExprUnary(hir::UnUniq, _) => (),\n-            _ => return\n-        }\n-\n-        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                ref autoref, ..\n-            }) = *adjustment {\n-                match autoref {\n-                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n-                                     \"unnecessary allocation, use & instead\");\n-                    }\n-                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n-                                     \"unnecessary allocation, use &mut instead\");\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     MISSING_DOCS,\n     Allow,"}, {"sha": "674631cd3a5ee3dcbe3977cbccd9b154240685dc", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/974dfe8e313cf70905ccb54c7b16129372a8e709/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974dfe8e313cf70905ccb54c7b16129372a8e709/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=974dfe8e313cf70905ccb54c7b16129372a8e709", "patch": "@@ -60,9 +60,11 @@ use lint::LintId;\n \n mod bad_style;\n mod builtin;\n+mod unused;\n \n use bad_style::*;\n use builtin::*;\n+use unused::*;\n \n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in"}, {"sha": "6df32f53d81307267a89904e5ae2ae6f2c05b0e2", "filename": "src/librustc_lint/unused.rs", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/974dfe8e313cf70905ccb54c7b16129372a8e709/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974dfe8e313cf70905ccb54c7b16129372a8e709/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=974dfe8e313cf70905ccb54c7b16129372a8e709", "patch": "@@ -0,0 +1,468 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use metadata::csearch;\n+use middle::pat_util;\n+use middle::ty;\n+use middle::ty::adjustment;\n+use rustc::front::map as hir_map;\n+use util::nodemap::FnvHashMap;\n+use lint::{LateContext, EarlyContext, LintContext, LintArray};\n+use lint::{LintPass, EarlyLintPass, LateLintPass};\n+\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::slice;\n+\n+use syntax::ast;\n+use syntax::attr::{self, AttrMetaMethods};\n+use syntax::codemap::Span;\n+use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n+use syntax::ptr::P;\n+\n+use rustc_front::hir;\n+\n+use rustc_front::visit::FnKind;\n+\n+declare_lint! {\n+    pub UNUSED_MUT,\n+    Warn,\n+    \"detect mut variables which don't need to be mutable\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedMut;\n+\n+impl UnusedMut {\n+    fn check_unused_mut_pat(&self, cx: &LateContext, pats: &[P<hir::Pat>]) {\n+        // collect all mutable pattern and group their NodeIDs by their Identifier to\n+        // avoid false warnings in match arms with multiple patterns\n+\n+        let mut mutables = FnvHashMap();\n+        for p in pats {\n+            pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path1| {\n+                let ident = path1.node;\n+                if let hir::BindByValue(hir::MutMutable) = mode {\n+                    if !ident.name.as_str().starts_with(\"_\") {\n+                        match mutables.entry(ident.name.usize()) {\n+                            Vacant(entry) => { entry.insert(vec![id]); },\n+                            Occupied(mut entry) => { entry.get_mut().push(id); },\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+\n+        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n+        for (_, v) in &mutables {\n+            if !v.iter().any(|e| used_mutables.contains(e)) {\n+                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n+                             \"variable does not need to be mutable\");\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for UnusedMut {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_MUT)\n+    }\n+}\n+\n+impl LateLintPass for UnusedMut {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+        if let hir::ExprMatch(_, ref arms, _) = e.node {\n+            for a in arms {\n+                self.check_unused_mut_pat(cx, &a.pats)\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+        if let hir::StmtDecl(ref d, _) = s.node {\n+            if let hir::DeclLocal(ref l) = d.node {\n+                self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n+            }\n+        }\n+    }\n+\n+    fn check_fn(&mut self, cx: &LateContext,\n+                _: FnKind, decl: &hir::FnDecl,\n+                _: &hir::Block, _: Span, _: ast::NodeId) {\n+        for a in &decl.inputs {\n+            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub UNUSED_MUST_USE,\n+    Warn,\n+    \"unused result of a type flagged as #[must_use]\"\n+}\n+\n+declare_lint! {\n+    pub UNUSED_RESULTS,\n+    Allow,\n+    \"unused result of an expression in a statement\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedResults;\n+\n+impl LintPass for UnusedResults {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n+    }\n+}\n+\n+impl LateLintPass for UnusedResults {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+        let expr = match s.node {\n+            hir::StmtSemi(ref expr, _) => &**expr,\n+            _ => return\n+        };\n+\n+        if let hir::ExprRet(..) = expr.node {\n+            return;\n+        }\n+\n+        let t = cx.tcx.expr_ty(&expr);\n+        let warned = match t.sty {\n+            ty::TyTuple(ref tys) if tys.is_empty() => return,\n+            ty::TyBool => return,\n+            ty::TyStruct(def, _) |\n+            ty::TyEnum(def, _) => {\n+                if def.did.is_local() {\n+                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n+                        check_must_use(cx, &it.attrs, s.span)\n+                    } else {\n+                        false\n+                    }\n+                } else {\n+                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, def.did);\n+                    check_must_use(cx, &attrs[..], s.span)\n+                }\n+            }\n+            _ => false,\n+        };\n+        if !warned {\n+            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n+        }\n+\n+        fn check_must_use(cx: &LateContext, attrs: &[ast::Attribute], sp: Span) -> bool {\n+            for attr in attrs {\n+                if attr.check_name(\"must_use\") {\n+                    let mut msg = \"unused result which must be used\".to_string();\n+                    // check for #[must_use=\"...\"]\n+                    match attr.value_str() {\n+                        None => {}\n+                        Some(s) => {\n+                            msg.push_str(\": \");\n+                            msg.push_str(&s);\n+                        }\n+                    }\n+                    cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n+                    return true;\n+                }\n+            }\n+            false\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub UNUSED_UNSAFE,\n+    Warn,\n+    \"unnecessary use of an `unsafe` block\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedUnsafe;\n+\n+impl LintPass for UnusedUnsafe {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_UNSAFE)\n+    }\n+}\n+\n+impl LateLintPass for UnusedUnsafe {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+        if let hir::ExprBlock(ref blk) = e.node {\n+            // Don't warn about generated blocks, that'll just pollute the output.\n+            if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n+                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub PATH_STATEMENTS,\n+    Warn,\n+    \"path statements with no effect\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PathStatements;\n+\n+impl LintPass for PathStatements {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(PATH_STATEMENTS)\n+    }\n+}\n+\n+impl LateLintPass for PathStatements {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+        match s.node {\n+            hir::StmtSemi(ref expr, _) => {\n+                match expr.node {\n+                    hir::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n+                                                      \"path statement with no effect\"),\n+                    _ => ()\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_ATTRIBUTES,\n+    Warn,\n+    \"detects attributes that were not used by the compiler\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedAttributes;\n+\n+impl LintPass for UnusedAttributes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_ATTRIBUTES)\n+    }\n+}\n+\n+impl LateLintPass for UnusedAttributes {\n+    fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n+        // Note that check_name() marks the attribute as used if it matches.\n+        for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n+            match ty {\n+                AttributeType::Whitelisted if attr.check_name(name) => {\n+                    break;\n+                },\n+                _ => ()\n+            }\n+        }\n+\n+        let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n+        for &(ref name, ty) in plugin_attributes.iter() {\n+            if ty == AttributeType::Whitelisted && attr.check_name(&*name) {\n+                break;\n+            }\n+        }\n+\n+        if !attr::is_used(attr) {\n+            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n+            // Is it a builtin attribute that must be used at the crate level?\n+            let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n+                attr.name() == name &&\n+                ty == AttributeType::CrateLevel\n+            }).is_some();\n+\n+            // Has a plugin registered this attribute as one which must be used at\n+            // the crate level?\n+            let plugin_crate = plugin_attributes.iter()\n+                                                .find(|&&(ref x, t)| {\n+                                                        &*attr.name() == &*x &&\n+                                                        AttributeType::CrateLevel == t\n+                                                    }).is_some();\n+            if  known_crate || plugin_crate {\n+                let msg = match attr.node.style {\n+                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n+                                       attribute: add an exclamation mark: #![foo]\",\n+                    ast::AttrInner => \"crate-level attribute should be in the \\\n+                                       root module\",\n+                };\n+                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_PARENS,\n+    Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedParens;\n+\n+impl UnusedParens {\n+    fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n+                                struct_lit_needs_parens: bool) {\n+        if let ast::ExprParen(ref inner) = value.node {\n+            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n+            if !necessary {\n+                cx.span_lint(UNUSED_PARENS, value.span,\n+                             &format!(\"unnecessary parentheses around {}\", msg))\n+            }\n+        }\n+\n+        /// Expressions that syntactically contain an \"exterior\" struct\n+        /// literal i.e. not surrounded by any parens or other\n+        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n+        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n+        /// y: 1 }) == foo` does not.\n+        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n+            match value.node {\n+                ast::ExprStruct(..) => true,\n+\n+                ast::ExprAssign(ref lhs, ref rhs) |\n+                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+                ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                    // X { y: 1 } + X { y: 2 }\n+                    contains_exterior_struct_lit(&**lhs) ||\n+                        contains_exterior_struct_lit(&**rhs)\n+                }\n+                ast::ExprUnary(_, ref x) |\n+                ast::ExprCast(ref x, _) |\n+                ast::ExprField(ref x, _) |\n+                ast::ExprTupField(ref x, _) |\n+                ast::ExprIndex(ref x, _) => {\n+                    // &X { y: 1 }, X { y: 1 }.y\n+                    contains_exterior_struct_lit(&**x)\n+                }\n+\n+                ast::ExprMethodCall(_, _, ref exprs) => {\n+                    // X { y: 1 }.bar(...)\n+                    contains_exterior_struct_lit(&*exprs[0])\n+                }\n+\n+                _ => false\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for UnusedParens {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_PARENS)\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedParens {\n+    fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n+        let (value, msg, struct_lit_needs_parens) = match e.node {\n+            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            ast::ExprMatch(ref head, _, source) => match source {\n+                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n+                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n+                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n+                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n+            },\n+            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n+            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n+            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n+            _ => return\n+        };\n+        self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n+        let (value, msg) = match s.node {\n+            ast::StmtDecl(ref decl, _) => match decl.node {\n+                ast::DeclLocal(ref local) => match local.init {\n+                    Some(ref value) => (value, \"assigned value\"),\n+                    None => return\n+                },\n+                _ => return\n+            },\n+            _ => return\n+        };\n+        self.check_unused_parens_core(cx, &**value, msg, false);\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_IMPORT_BRACES,\n+    Allow,\n+    \"unnecessary braces around an imported item\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedImportBraces;\n+\n+impl LintPass for UnusedImportBraces {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_IMPORT_BRACES)\n+    }\n+}\n+\n+impl LateLintPass for UnusedImportBraces {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+        if let hir::ItemUse(ref view_path) = item.node {\n+            if let hir::ViewPathList(_, ref items) = view_path.node {\n+                if items.len() == 1 {\n+                    if let hir::PathListIdent {ref name, ..} = items[0].node {\n+                        let m = format!(\"braces around {} is unnecessary\",\n+                                        name);\n+                        cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n+                                     &m[..]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_ALLOCATION,\n+    Warn,\n+    \"detects unnecessary allocations that can be eliminated\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedAllocation;\n+\n+impl LintPass for UnusedAllocation {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_ALLOCATION)\n+    }\n+}\n+\n+impl LateLintPass for UnusedAllocation {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+        match e.node {\n+            hir::ExprUnary(hir::UnUniq, _) => (),\n+            _ => return\n+        }\n+\n+        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n+            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                ref autoref, ..\n+            }) = *adjustment {\n+                match autoref {\n+                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n+                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                                     \"unnecessary allocation, use & instead\");\n+                    }\n+                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n+                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                                     \"unnecessary allocation, use &mut instead\");\n+                    }\n+                    _ => ()\n+                }\n+            }\n+        }\n+    }\n+}\n+"}]}