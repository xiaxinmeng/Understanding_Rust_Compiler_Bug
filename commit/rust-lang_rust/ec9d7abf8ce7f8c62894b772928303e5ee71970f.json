{"sha": "ec9d7abf8ce7f8c62894b772928303e5ee71970f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjOWQ3YWJmOGNlN2Y4YzYyODk0Yjc3MjkyODMwM2U1ZWU3MTk3MGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-01T18:36:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-01T18:37:31Z"}, "message": "rustc: Have tag_variants() return a new variant_info structure instead of an AST node", "tree": {"sha": "5901bdff33fb27923b7defa247d5414f10236d7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5901bdff33fb27923b7defa247d5414f10236d7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec9d7abf8ce7f8c62894b772928303e5ee71970f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec9d7abf8ce7f8c62894b772928303e5ee71970f", "html_url": "https://github.com/rust-lang/rust/commit/ec9d7abf8ce7f8c62894b772928303e5ee71970f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec9d7abf8ce7f8c62894b772928303e5ee71970f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b211f4782b83a5855c5c203c8cb6dbba7d277c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b211f4782b83a5855c5c203c8cb6dbba7d277c4", "html_url": "https://github.com/rust-lang/rust/commit/8b211f4782b83a5855c5c203c8cb6dbba7d277c4"}], "stats": {"total": 77, "additions": 40, "deletions": 37}, "files": [{"sha": "263ac94010494b94f7d15551c4f05019407b3654", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ec9d7abf8ce7f8c62894b772928303e5ee71970f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec9d7abf8ce7f8c62894b772928303e5ee71970f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ec9d7abf8ce7f8c62894b772928303e5ee71970f", "patch": "@@ -1120,8 +1120,8 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     // Compute max(variant sizes).\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n-    for (ast.variant variant in variants) {\n-        auto tup_ty = ty.plain_tup_ty(variant_types(cx, variant));\n+    for (variant_info variant in variants) {\n+        auto tup_ty = ty.plain_tup_ty(variant.args);\n \n         // Perform any type parameter substitutions.\n         tup_ty = ty.substitute_ty_params(ty_params, subtys, tup_ty);\n@@ -1192,9 +1192,9 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n \n             auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n             auto variants = tag_variants(bcx.fcx.ccx, tid);\n-            for (ast.variant variant in variants) {\n-                // Perform type substitution on the raw variant types.\n-                let vec[@ty.t] raw_tys = variant_types(bcx.fcx.ccx, variant);\n+            for (variant_info variant in variants) {\n+                // Perform type substitution on the raw argument types.\n+                let vec[@ty.t] raw_tys = variant.args;\n                 let vec[@ty.t] tys = vec();\n                 for (@ty.t raw_ty in raw_tys) {\n                     auto t = ty.substitute_ty_params(ty_params, tps, raw_ty);\n@@ -1367,12 +1367,12 @@ fn GEP_tag(@block_ctxt cx,\n \n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n     // Separately, store the type of the element we're interested in.\n-    auto arg_tys = arg_tys_of_fn(variant.node.ann);\n+    auto arg_tys = variant.args;\n     auto elem_ty = ty.plain_ty(ty.ty_nil);  // typestate infelicity\n     auto i = 0;\n     let vec[@ty.t] true_arg_tys = vec();\n-    for (ty.arg a in arg_tys) {\n-        auto arg_ty = ty.substitute_ty_params(ty_params, ty_substs, a.ty);\n+    for (@ty.t aty in arg_tys) {\n+        auto arg_ty = ty.substitute_ty_params(ty_params, ty_substs, aty);\n         true_arg_tys += vec(arg_ty);\n         if (i == ix) {\n             elem_ty = arg_ty;\n@@ -1902,44 +1902,47 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n \n // Tag information\n \n-fn variant_types(@crate_ctxt cx, &ast.variant v) -> vec[@ty.t] {\n-    let vec[@ty.t] tys = vec();\n-    alt (ty.ann_to_type(v.node.ann).struct) {\n-        case (ty.ty_fn(_, ?args, _)) {\n-            for (ty.arg arg in args) {\n-                tys += vec(arg.ty);\n-            }\n-        }\n-        case (ty.ty_tag(_, _)) { /* nothing */ }\n-        case (_) { fail; }\n-    }\n-    ret tys;\n-}\n-\n // Returns the type parameters of a tag.\n fn tag_ty_params(@crate_ctxt cx, ast.def_id id) -> vec[ast.def_id] {\n     ret ty.lookup_generic_item_type(cx.sess, cx.type_cache, id)._0;\n }\n \n-// Returns the variants in a tag.\n-fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[ast.variant] {\n+type variant_info = rec(vec[@ty.t] args, @ty.t ctor_ty, ast.def_id id);\n+\n+// Returns information about the variants in a tag.\n+fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n+    // FIXME: This doesn't work for external variants.\n     check (cx.items.contains_key(id));\n     alt (cx.items.get(id).node) {\n-        case (ast.item_tag(_, ?variants, _, _, _)) { ret variants; }\n+        case (ast.item_tag(_, ?variants, _, _, _)) {\n+            let vec[variant_info] result = vec();\n+            for (ast.variant variant in variants) {\n+                auto ctor_ty = node_ann_type(cx, variant.node.ann);\n+                let vec[@ty.t] arg_tys = vec();\n+                if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n+                    for (ty.arg a in ty.ty_fn_args(ctor_ty)) {\n+                        arg_tys += vec(a.ty);\n+                    }\n+                }\n+                auto did = variant.node.id;\n+                result += vec(rec(args=arg_tys, ctor_ty=ctor_ty, id=did));\n+            }\n+            ret result;\n+        }\n     }\n     fail;   // not reached\n }\n \n-// Returns the tag variant with the given ID.\n+// Returns information about the tag variant with the given ID.\n fn tag_variant_with_id(@crate_ctxt cx,\n                        &ast.def_id tag_id,\n-                       &ast.def_id variant_id) -> ast.variant {\n+                       &ast.def_id variant_id) -> variant_info {\n     auto variants = tag_variants(cx, tag_id);\n \n     auto i = 0u;\n-    while (i < _vec.len[ast.variant](variants)) {\n+    while (i < _vec.len[variant_info](variants)) {\n         auto variant = variants.(i);\n-        if (common.def_eq(variant.node.id, variant_id)) {\n+        if (common.def_eq(variant.id, variant_id)) {\n             ret variant;\n         }\n         i += 1u;\n@@ -2040,7 +2043,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n         }\n         case (ty.ty_tag(?tid, ?tps)) {\n             auto variants = tag_variants(cx.fcx.ccx, tid);\n-            auto n_variants = _vec.len[ast.variant](variants);\n+            auto n_variants = _vec.len[variant_info](variants);\n \n             // Cast the tags to types we can GEP into.\n             auto lltagty = T_opaque_tag_ptr(cx.fcx.ccx.tn);\n@@ -2076,28 +2079,28 @@ fn iter_structural_ty_full(@block_ctxt cx,\n             auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n \n             auto i = 0u;\n-            for (ast.variant variant in variants) {\n+            for (variant_info variant in variants) {\n                 auto variant_cx = new_sub_block_ctxt(bcx,\n                                                      \"tag-iter-variant-\" +\n                                                      _uint.to_str(i, 10u));\n                 llvm.LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n \n-                if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n+                if (_vec.len[@ty.t](variant.args) > 0u) {\n                     // N-ary variant.\n-                    auto fn_ty = ty.ann_to_type(variants.(i).node.ann);\n+                    auto fn_ty = variant.ctor_ty;\n                     alt (fn_ty.struct) {\n                         case (ty.ty_fn(_, ?args, _)) {\n                             auto j = 0;\n                             for (ty.arg a in args) {\n                                 auto v = vec(C_int(0), C_int(j as int));\n \n                                 auto rslt = GEP_tag(variant_cx, llunion_a_ptr,\n-                                    tid, variants.(i).node.id, tps, j);\n+                                    tid, variant.id, tps, j);\n                                 auto llfldp_a = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n                                 rslt = GEP_tag(variant_cx, llunion_b_ptr, tid,\n-                                    variants.(i).node.id, tps, j);\n+                                    variant.id, tps, j);\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n@@ -3454,8 +3457,8 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n             auto variants = tag_variants(cx.fcx.ccx, vdef._0);\n             auto i = 0;\n-            for (ast.variant v in variants) {\n-                auto this_variant_id = v.node.id;\n+            for (variant_info v in variants) {\n+                auto this_variant_id = v.id;\n                 if (variant_id._0 == this_variant_id._0 &&\n                     variant_id._1 == this_variant_id._1) {\n                     variant_tag = i;"}]}