{"sha": "700fd35fb9d448c5e1658c3cec9c1153c57cc802", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMGZkMzVmYjlkNDQ4YzVlMTY1OGMzY2VjOWMxMTUzYzU3Y2M4MDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T02:51:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T02:51:53Z"}, "message": "auto merge of #11979 : FlaPer87/rust/static, r=nikomatsakis\n\nThis pull request partially addresses the 2 issues listed before. As part of the work required for this PR, `NonCopyable` was completely removed.\r\n\r\nThis PR also replaces the content of `type_is_pod` with `TypeContents::is_pod`, although `type_is_content` is currently not being used anywhere. I kept it for consistency with the other functions that exist in this module.\r\n\r\ncc #10834\r\ncc #10577\r\n\r\nProposed static restrictions\r\n=====================\r\n\r\nTaken from [this](https://github.com/mozilla/rust/pull/11979#issuecomment-35768249) comment.\r\n\r\nI expect some code that, at a high-level, works like this:\r\n\r\n- For each *mutable* static item, check that the **type**:\r\n    - cannot own any value whose type has a dtor\r\n    - cannot own any values whose type is an owned pointer\r\n- For each *immutable* static item, check that the **value**:\r\n      - does not contain any ~ or box expressions (including ~[1, 2, 3] sort of things, for now)\r\n      - does not contain a struct literal or call to an enum variant / struct constructor where\r\n          - the type of the struct/enum is freeze\r\n          - the type of the struct/enum has a dtor", "tree": {"sha": "2a2487273a51dda7ce9e917802986588e8bbaa45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a2487273a51dda7ce9e917802986588e8bbaa45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/700fd35fb9d448c5e1658c3cec9c1153c57cc802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/700fd35fb9d448c5e1658c3cec9c1153c57cc802", "html_url": "https://github.com/rust-lang/rust/commit/700fd35fb9d448c5e1658c3cec9c1153c57cc802", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/700fd35fb9d448c5e1658c3cec9c1153c57cc802/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f01a9a8d02f6c09b89a3cecadaa5b62073381180", "url": "https://api.github.com/repos/rust-lang/rust/commits/f01a9a8d02f6c09b89a3cecadaa5b62073381180", "html_url": "https://github.com/rust-lang/rust/commit/f01a9a8d02f6c09b89a3cecadaa5b62073381180"}, {"sha": "59a04f5b122793134cd3e9b98d2b361cbafae482", "url": "https://api.github.com/repos/rust-lang/rust/commits/59a04f5b122793134cd3e9b98d2b361cbafae482", "html_url": "https://github.com/rust-lang/rust/commit/59a04f5b122793134cd3e9b98d2b361cbafae482"}], "stats": {"total": 551, "additions": 458, "deletions": 93}, "files": [{"sha": "4c552acc936922eed6535bd364b9aff18c2c5a47", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -301,6 +301,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     // passes are timed inside typeck\n     let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map, krate);\n \n+    time(time_passes, \"check static items\", (), |_|\n+         middle::check_static::check_crate(ty_cx, krate));\n+\n     // These next two const passes can probably be merged\n     time(time_passes, \"const marking\", (), |_|\n          middle::const_eval::process_crate(krate, ty_cx));"}, {"sha": "97718849e631f259351af09ea17340470ebf7c3b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -69,6 +69,7 @@ pub mod middle {\n     pub mod check_loop;\n     pub mod check_match;\n     pub mod check_const;\n+    pub mod check_static;\n     pub mod lint;\n     pub mod borrowck;\n     pub mod dataflow;"}, {"sha": "7ec9f1f8f47953f986362921c711cc9177fdb6ac", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -104,7 +104,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::GcPtr) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-        mc::cat_upvar(..) |\n+        mc::cat_upvar(..) | mc::cat_static_item |\n         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n             bccx.span_err(\n                 cmt0.span,\n@@ -120,19 +120,6 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n             true\n         }\n \n-        // It seems strange to allow a move out of a static item,\n-        // but what happens in practice is that you have a\n-        // reference to a constant with a type that should be\n-        // moved, like `None::<~int>`.  The type of this constant\n-        // is technically `Option<~int>`, which moves, but we know\n-        // that the content of static items will never actually\n-        // contain allocated pointers, so we can just memcpy it.\n-        // Since static items can never have allocated memory,\n-        // this is ok. For now anyhow.\n-        mc::cat_static_item => {\n-            true\n-        }\n-\n         mc::cat_rvalue(..) |\n         mc::cat_local(..) |\n         mc::cat_arg(..) => {"}, {"sha": "ebf1904d3cb2a5efb8854e2b1ddc98e0d4249aaa", "filename": "src/librustc/middle/check_static.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Verifies that the types and values of static items\n+// are safe. The rules enforced by this module are:\n+//\n+// - For each *mutable* static item, it checks that its **type**:\n+//     - doesn't have a destructor\n+//     - doesn't own an owned pointer\n+//\n+// - For each *immutable* static item, it checks that its **value**:\n+//       - doesn't own owned, managed pointers\n+//       - doesn't contain a struct literal or a call to an enum variant / struct constructor where\n+//           - the type of the struct/enum is not freeze\n+//           - the type of the struct/enum has a dtor\n+\n+use middle::ty;\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+use syntax::print::pprust;\n+\n+\n+fn safe_type_for_static_mut(cx: ty::ctxt, e: &ast::Expr) -> Option<~str> {\n+    let node_ty = ty::node_id_to_type(cx, e.id);\n+    let tcontents = ty::type_contents(cx, node_ty);\n+    debug!(\"safe_type_for_static_mut(dtor={}, managed={}, owned={})\",\n+           tcontents.has_dtor(), tcontents.owns_managed(), tcontents.owns_owned())\n+\n+    let suffix = if tcontents.has_dtor() {\n+        \"destructors\"\n+    } else if tcontents.owns_managed() {\n+        \"managed pointers\"\n+    } else if tcontents.owns_owned() {\n+        \"owned pointers\"\n+    } else {\n+        return None;\n+    };\n+\n+    Some(format!(\"mutable static items are not allowed to have {}\", suffix))\n+}\n+\n+struct CheckStaticVisitor {\n+    tcx: ty::ctxt,\n+}\n+\n+pub fn check_crate(tcx: ty::ctxt, krate: &ast::Crate) {\n+    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx }, krate, false)\n+}\n+\n+impl CheckStaticVisitor {\n+\n+    fn report_error(&self, span: Span, result: Option<~str>) -> bool {\n+        match result {\n+            None => { false }\n+            Some(msg) => {\n+                self.tcx.sess.span_err(span, msg);\n+                true\n+            }\n+        }\n+    }\n+}\n+\n+impl Visitor<bool> for CheckStaticVisitor {\n+\n+    fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n+        debug!(\"visit_item(item={})\", pprust::item_to_str(i));\n+        match i.node {\n+            ast::ItemStatic(_, mutability, expr) => {\n+                match mutability {\n+                    ast::MutImmutable => {\n+                        self.visit_expr(expr, true);\n+                    }\n+                    ast::MutMutable => {\n+                        self.report_error(expr.span, safe_type_for_static_mut(self.tcx, expr));\n+                    }\n+                }\n+            }\n+            _ => { visit::walk_item(self, i, false) }\n+        }\n+    }\n+\n+    /// This method is used to enforce the constraints on\n+    /// immutable static items. It walks through the *value*\n+    /// of the item walking down the expression and evaluating\n+    /// every nested expression. if the expression is not part\n+    /// of a static item, this method does nothing but walking\n+    /// down through it.\n+    fn visit_expr(&mut self, e: &ast::Expr, is_const: bool) {\n+        debug!(\"visit_expr(expr={})\", pprust::expr_to_str(e));\n+\n+        if !is_const {\n+            return visit::walk_expr(self, e, is_const);\n+        }\n+\n+        match e.node {\n+            ast::ExprField(..) | ast::ExprVec(..) |\n+            ast::ExprBlock(..) | ast::ExprTup(..) |\n+            ast::ExprVstore(_, ast::ExprVstoreSlice) => {\n+                visit::walk_expr(self, e, is_const);\n+            }\n+            ast::ExprUnary(ast::UnBox, _) => {\n+                self.tcx.sess.span_err(e.span,\n+                                   \"static items are not allowed to have managed pointers\");\n+            }\n+            ast::ExprBox(..) |\n+            ast::ExprUnary(ast::UnUniq, _) |\n+            ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n+                self.tcx.sess.span_err(e.span,\n+                                   \"static items are not allowed to have owned pointers\");\n+            }\n+            ast::ExprProc(..) => {\n+                self.report_error(e.span,\n+                                  Some(~\"immutable static items must be `Freeze`\"));\n+                return;\n+            }\n+            ast::ExprAddrOf(mutability, _) => {\n+                match mutability {\n+                    ast::MutMutable => {\n+                        self.report_error(e.span,\n+                                  Some(~\"immutable static items must be `Freeze`\"));\n+                        return;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {\n+                let node_ty = ty::node_id_to_type(self.tcx, e.id);\n+\n+                match ty::get(node_ty).sty {\n+                    ty::ty_struct(did, _) |\n+                    ty::ty_enum(did, _) => {\n+                        if ty::has_dtor(self.tcx, did) {\n+                            self.report_error(e.span,\n+                                     Some(~\"static items are not allowed to have destructors\"));\n+                            return;\n+                        }\n+                        if Some(did) == self.tcx.lang_items.no_freeze_bound() {\n+                            self.report_error(e.span,\n+                                              Some(~\"immutable static items must be `Freeze`\"));\n+                            return;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                visit::walk_expr(self, e, is_const);\n+            }\n+        }\n+    }\n+}"}, {"sha": "8ea7f75d2b44e9d0c38d5ff12698871901a6be8d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 55, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -1950,6 +1950,10 @@ impl TypeContents {\n         self.intersects(TC::OwnsManaged)\n     }\n \n+    pub fn owns_owned(&self) -> bool {\n+        self.intersects(TC::OwnsOwned)\n+    }\n+\n     pub fn is_freezable(&self, _: ctxt) -> bool {\n         !self.intersects(TC::Nonfreezable)\n     }\n@@ -2012,6 +2016,10 @@ impl TypeContents {\n     pub fn inverse(&self) -> TypeContents {\n         TypeContents { bits: !self.bits }\n     }\n+\n+    pub fn has_dtor(&self) -> bool {\n+        self.intersects(TC::OwnsDtor)\n+    }\n }\n \n impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n@@ -2038,6 +2046,10 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n+pub fn type_has_dtor(cx: ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).has_dtor()\n+}\n+\n pub fn type_is_static(cx: ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_static(cx)\n }\n@@ -2624,61 +2636,6 @@ pub fn type_is_machine(ty: t) -> bool {\n     }\n }\n \n-// Whether a type is Plain Old Data -- meaning it does not contain pointers\n-// that the cycle collector might care about.\n-pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n-    let mut result = true;\n-    match get(ty).sty {\n-      // Scalar types\n-      ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_ptr(_) | ty_bare_fn(_) => result = true,\n-      // Boxed types\n-      ty_box(_) | ty_uniq(_) | ty_closure(_) |\n-      ty_str(vstore_uniq) |\n-      ty_vec(_, vstore_uniq) |\n-      ty_trait(_, _, _, _, _) | ty_rptr(_,_) => result = false,\n-      // Structural types\n-      ty_enum(did, ref substs) => {\n-        let variants = enum_variants(cx, did);\n-        for variant in (*variants).iter() {\n-            // FIXME(pcwalton): This is an inefficient way to do this. Don't\n-            // synthesize a tuple!\n-            //\n-            // Perform any type parameter substitutions.\n-            let tup_ty = mk_tup(cx, variant.args.clone());\n-            let tup_ty = subst(cx, substs, tup_ty);\n-            if !type_is_pod(cx, tup_ty) { result = false; }\n-        }\n-      }\n-      ty_tup(ref elts) => {\n-        for elt in elts.iter() { if !type_is_pod(cx, *elt) { result = false; } }\n-      }\n-      ty_str(vstore_fixed(_)) => result = true,\n-      ty_vec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n-        result = type_is_pod(cx, mt.ty);\n-      }\n-      ty_param(_) => result = false,\n-      ty_struct(did, ref substs) => {\n-        let fields = lookup_struct_fields(cx, did);\n-        result = fields.iter().all(|f| {\n-            let fty = ty::lookup_item_type(cx, f.id);\n-            let sty = subst(cx, substs, fty.ty);\n-            type_is_pod(cx, sty)\n-        });\n-      }\n-\n-      ty_str(vstore_slice(..)) | ty_vec(_, vstore_slice(..)) => {\n-        result = false;\n-      }\n-\n-      ty_infer(..) | ty_self(..) | ty_err => {\n-        cx.sess.bug(\"non concrete type in type_is_pod\");\n-      }\n-    }\n-\n-    return result;\n-}\n-\n pub fn type_is_enum(ty: t) -> bool {\n     match get(ty).sty {\n       ty_enum(_, _) => return true,"}, {"sha": "37929957ae6baf2417de9fc75e494f9dacea3539", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -725,6 +725,7 @@ impl CoherenceChecker {\n \n             let self_type = self.get_self_type_for_implementation(*impl_info);\n             match ty::get(self_type.ty).sty {\n+                ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) => {\n                     let mut destructor_for_type = tcx.destructor_for_type\n                                                      .borrow_mut();"}, {"sha": "a7e5573ccfc6666b1221584ac392c18df478b43e", "filename": "src/test/compile-fail/borrowck-move-out-of-static-item.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-static-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-static-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-static-item.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that moves out of static items is forbidden\n+\n+use std::kinds::marker;\n+\n+struct Foo {\n+    foo: int,\n+    nopod: marker::NoPod\n+}\n+\n+static BAR: Foo = Foo{foo: 5, nopod: marker::NoPod};\n+\n+\n+fn test(f: Foo) {\n+    let _f = Foo{foo: 4, ..f};\n+}\n+\n+fn main() {\n+    test(BAR); //~ ERROR cannot move out of static item\n+}"}, {"sha": "852b06d00a64e765a242fa99d6bb6f0c6ab31647", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#[feature(managed_boxes)];\n+\n+// Verifies all possible restrictions for static items values.\n+\n+use std::kinds::marker;\n+\n+struct WithDtor;\n+\n+impl Drop for WithDtor {\n+    fn drop(&mut self) {}\n+}\n+\n+// This enum will be used to test the following rules:\n+// 1. Variants are safe for static\n+// 2. Expr calls are allowed as long as they arguments are safe\n+// 3. Expr calls with unsafe arguments for static items are rejected\n+enum SafeEnum {\n+    Variant1,\n+    Variant2(int),\n+    Variant3(WithDtor),\n+    Variant4(~str)\n+}\n+\n+// These should be ok\n+static STATIC1: SafeEnum = Variant1;\n+static STATIC2: SafeEnum = Variant2(0);\n+\n+// This one should fail\n+static STATIC3: SafeEnum = Variant3(WithDtor);\n+//~^ ERROR static items are not allowed to have destructors\n+\n+\n+// This enum will be used to test that variants\n+// are considered unsafe if their enum type implements\n+// a destructor.\n+enum UnsafeEnum {\n+    Variant5,\n+    Variant6(int)\n+}\n+\n+impl Drop for UnsafeEnum {\n+    fn drop(&mut self) {}\n+}\n+\n+\n+static STATIC4: UnsafeEnum = Variant5;\n+//~^ ERROR static items are not allowed to have destructors\n+static STATIC5: UnsafeEnum = Variant6(0);\n+//~^ ERROR static items are not allowed to have destructors\n+\n+\n+struct SafeStruct {\n+    field1: SafeEnum,\n+    field2: SafeEnum,\n+}\n+\n+\n+// Struct fields are safe, hence this static should be safe\n+static STATIC6: SafeStruct = SafeStruct{field1: Variant1, field2: Variant2(0)};\n+\n+// field2 has an unsafe value, hence this should fail\n+static STATIC7: SafeStruct = SafeStruct{field1: Variant1, field2: Variant3(WithDtor)};\n+//~^ ERROR static items are not allowed to have destructors\n+\n+// Test variadic constructor for structs. The base struct should be examined\n+// as well as every field persent in the constructor.\n+// This example shouldn't fail because all the fields are safe.\n+static STATIC8: SafeStruct = SafeStruct{field1: Variant1,\n+                                        ..SafeStruct{field1: Variant1, field2: Variant1}};\n+\n+// This example should fail because field1 in the base struct is not safe\n+static STATIC9: SafeStruct = SafeStruct{field1: Variant1,\n+                                        ..SafeStruct{field1: Variant3(WithDtor), field2: Variant1}};\n+//~^ ERROR static items are not allowed to have destructors\n+\n+struct UnsafeStruct;\n+\n+impl Drop for UnsafeStruct {\n+    fn drop(&mut self) {}\n+}\n+\n+// Types with destructors are not allowed for statics\n+static STATIC10: UnsafeStruct = UnsafeStruct;\n+//~^ ERROR static items are not allowed to have destructor\n+\n+static STATIC11: ~str = ~\"Owned pointers are not allowed either\";\n+//~^ ERROR static items are not allowed to have owned pointers\n+\n+// The following examples test that mutable structs are just forbidden\n+// to have types with destructors\n+// These should fail\n+static mut STATIC12: UnsafeStruct = UnsafeStruct;\n+//~^ ERROR mutable static items are not allowed to have destructors\n+\n+static mut STATIC13: SafeStruct = SafeStruct{field1: Variant1, field2: Variant3(WithDtor)};\n+//~^ ERROR mutable static items are not allowed to have destructors\n+\n+static mut STATIC14: SafeStruct = SafeStruct{field1: Variant1, field2: Variant4(~\"str\")};\n+//~^ ERROR mutable static items are not allowed to have destructors\n+\n+static STATIC15: &'static [~str] = &'static [~\"str\", ~\"str\"];\n+//~^ ERROR static items are not allowed to have owned pointers\n+//~^^ ERROR static items are not allowed to have owned pointers\n+\n+static STATIC16: (~str, ~str) = (~\"str\", ~\"str\");\n+//~^ ERROR static items are not allowed to have owned pointers\n+//~^^ ERROR static items are not allowed to have owned pointers\n+\n+static mut STATIC17: SafeEnum = Variant1;\n+//~^ ERROR mutable static items are not allowed to have destructors\n+\n+static STATIC18: @SafeStruct = @SafeStruct{field1: Variant1, field2: Variant2(0)};\n+//~^ ERROR static items are not allowed to have managed pointers\n+\n+static STATIC19: ~int = box 3;\n+//~^ ERROR static items are not allowed to have owned pointers\n+\n+\n+struct StructNoFreeze<'a> {\n+    nf: &'a int\n+}\n+\n+enum EnumNoFreeze<'a> {\n+    FreezableVariant,\n+    NonFreezableVariant(StructNoFreeze<'a>)\n+}\n+\n+static STATIC20: StructNoFreeze<'static> = StructNoFreeze{nf: &'static mut 4};\n+//~^ ERROR immutable static items must be `Freeze`\n+\n+static STATIC21: EnumNoFreeze<'static> = FreezableVariant;\n+static STATIC22: EnumNoFreeze<'static> = NonFreezableVariant(StructNoFreeze{nf: &'static mut 4});\n+//~^ ERROR immutable static items must be `Freeze`\n+\n+struct NFMarker {\n+    nf: marker::NoFreeze\n+}\n+\n+static STATIC23: NFMarker = NFMarker{nf: marker::NoFreeze};\n+//~^ ERROR immutable static items must be `Freeze`\n+\n+pub fn main() {\n+    let y = { static x: ~int = ~3; x };\n+    //~^ ERROR static items are not allowed to have owned pointers\n+}"}, {"sha": "01fb2ea9427370af28d396471b98094259758e4e", "filename": "src/test/compile-fail/issue-10487.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10487.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -10,6 +10,6 @@\n \n #[feature(managed_boxes)];\n \n-static x: ~[int] = ~[123, 456]; //~ ERROR: cannot allocate vectors in constant expressions\n+static x: ~[int] = ~[123, 456]; //~ ERROR: static items are not allowed to have owned pointers\n \n fn main() {}"}, {"sha": "541a103330252595ebb6a760011c1d6984b65b4f", "filename": "src/test/compile-fail/issue-7364.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(managed_boxes)];\n+\n+use std::cell::RefCell;\n+\n+// Regresion test for issue 7364\n+static managed: @RefCell<int> = @RefCell::new(0);\n+//~^ ERROR static items are not allowed to have managed pointers\n+\n+fn main() { }"}, {"sha": "f1400c06ca23af1b5b5945e9a5882d254f8de259", "filename": "src/test/compile-fail/issue-9243.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regresion test for issue 9243\n+\n+struct Test {\n+    mem: int,\n+}\n+\n+pub static g_test: Test = Test {mem: 0}; //~ ERROR static items are not allowed to have destructors\n+\n+impl Drop for Test {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "f089904dd91497552f99552e89fca3d5b8f64d66", "filename": "src/test/compile-fail/static-items-cant-move.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fstatic-items-cant-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fstatic-items-cant-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-items-cant-move.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Verifies that static items can't be moved\n+\n+use std::kinds::marker;\n+\n+struct Foo {\n+    foo: int,\n+    nopod: marker::NoPod\n+}\n+\n+static BAR: Foo = Foo{foo: 5, nopod: marker::NoPod};\n+\n+\n+fn test(f: Foo) {\n+    let _f = Foo{foo: 4, ..f};\n+}\n+\n+fn main() {\n+    test(BAR); //~ ERROR cannot move out of static item\n+}"}, {"sha": "90dabb7e3a271d8dc18cc90e7e265eb372b5fe74", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static mut a: ~int = ~3; //~ ERROR: cannot do allocations in constant expressions\n+static mut a: ~int = ~3; //~ ERROR: mutable static items are not allowed to have owned pointers\n \n fn main() {}"}, {"sha": "5c0e7e90aa932eedf90aadff44b7cfe29203cb00", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -16,13 +16,13 @@ use std::sync::atomics::*;\n use std::ptr;\n \n fn main() {\n-    let x = INIT_ATOMIC_FLAG;\n+    let x = INIT_ATOMIC_FLAG; //~ ERROR cannot move out of static item\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_BOOL;\n+    let x = INIT_ATOMIC_BOOL; //~ ERROR cannot move out of static item\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_INT;\n+    let x = INIT_ATOMIC_INT; //~ ERROR cannot move out of static item\n     let x = *&x; //~ ERROR: cannot move out of dereference\n-    let x = INIT_ATOMIC_UINT;\n+    let x = INIT_ATOMIC_UINT; //~ ERROR cannot move out of static item\n     let x = *&x; //~ ERROR: cannot move out of dereference\n     let x: AtomicPtr<uint> = AtomicPtr::new(ptr::mut_null());\n     let x = *&x; //~ ERROR: cannot move out of dereference"}, {"sha": "18638ab68776ee545f40177a2dd59988d760ad79", "filename": "src/test/run-pass/const-fn-val.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -14,8 +14,8 @@ fn foo() -> int {\n \n struct Bar<'a> { f: 'a || -> int }\n \n-static b : Bar<'static> = Bar { f: foo };\n+static mut b : Bar<'static> = Bar { f: foo };\n \n pub fn main() {\n-    assert_eq!((b.f)(), 0xca7f000d);\n+    unsafe { assert_eq!((b.f)(), 0xca7f000d); }\n }"}, {"sha": "9a93fcb5f89121d4c4d832add8af3e1169f8b7bc", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -18,12 +18,14 @@\n fn f() { }\n static bare_fns: &'static [fn()] = &[f, f];\n struct S<'a>('a ||);\n-static closures: &'static [S<'static>] = &[S(f), S(f)];\n+static mut closures: &'static [S<'static>] = &[S(f), S(f)];\n \n pub fn main() {\n-    for &bare_fn in bare_fns.iter() { bare_fn() }\n-    for closure in closures.iter() {\n-        let S(ref closure) = *closure;\n-        (*closure)()\n+    unsafe {\n+        for &bare_fn in bare_fns.iter() { bare_fn() }\n+        for closure in closures.iter() {\n+            let S(ref closure) = *closure;\n+            (*closure)()\n+        }\n     }\n }"}, {"sha": "db7b2803c71163913f6d7a7fbceae0ab6a4765dc", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -23,22 +23,23 @@ use std::io::process::{Process, ProcessOutput};\n #[test]\n fn test_destroy_once() {\n     #[cfg(not(target_os=\"android\"))]\n-    static PROG: &'static str = \"echo\";\n+    static mut PROG: &'static str = \"echo\";\n+\n     #[cfg(target_os=\"android\")]\n-    static PROG: &'static str = \"ls\"; // android don't have echo binary\n+    static mut PROG: &'static str = \"ls\"; // android don't have echo binary\n \n-    let mut p = Process::new(PROG, []).unwrap();\n+    let mut p = unsafe {Process::new(PROG, []).unwrap()};\n     p.signal_exit().unwrap(); // this shouldn't crash (and nor should the destructor)\n }\n \n #[test]\n fn test_destroy_twice() {\n     #[cfg(not(target_os=\"android\"))]\n-    static PROG: &'static str = \"echo\";\n+    static mut PROG: &'static str = \"echo\";\n     #[cfg(target_os=\"android\")]\n-    static PROG: &'static str = \"ls\"; // android don't have echo binary\n+    static mut PROG: &'static str = \"ls\"; // android don't have echo binary\n \n-    let mut p = match Process::new(PROG, []) {\n+    let mut p = match unsafe{Process::new(PROG, [])} {\n         Ok(p) => p,\n         Err(e) => fail!(\"wut: {}\", e),\n     };\n@@ -49,13 +50,13 @@ fn test_destroy_twice() {\n fn test_destroy_actually_kills(force: bool) {\n \n     #[cfg(unix,not(target_os=\"android\"))]\n-    static BLOCK_COMMAND: &'static str = \"cat\";\n+    static mut BLOCK_COMMAND: &'static str = \"cat\";\n \n     #[cfg(unix,target_os=\"android\")]\n-    static BLOCK_COMMAND: &'static str = \"/system/bin/cat\";\n+    static mut BLOCK_COMMAND: &'static str = \"/system/bin/cat\";\n \n     #[cfg(windows)]\n-    static BLOCK_COMMAND: &'static str = \"cmd\";\n+    static mut BLOCK_COMMAND: &'static str = \"cmd\";\n \n     #[cfg(unix,not(target_os=\"android\"))]\n     fn process_exists(pid: libc::pid_t) -> bool {\n@@ -91,7 +92,7 @@ fn test_destroy_actually_kills(force: bool) {\n     }\n \n     // this process will stay alive indefinitely trying to read from stdin\n-    let mut p = Process::new(BLOCK_COMMAND, []).unwrap();\n+    let mut p = unsafe {Process::new(BLOCK_COMMAND, []).unwrap()};\n \n     assert!(process_exists(p.id()));\n "}, {"sha": "5afffb3d029f71cb04f94a66fc1a0ba264b0a7f7", "filename": "src/test/run-pass/issue-6919.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Frun-pass%2Fissue-6919.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700fd35fb9d448c5e1658c3cec9c1153c57cc802/src%2Ftest%2Frun-pass%2Fissue-6919.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6919.rs?ref=700fd35fb9d448c5e1658c3cec9c1153c57cc802", "patch": "@@ -15,6 +15,6 @@\n extern crate issue6919_3;\n \n pub fn main() {\n-    issue6919_3::D.k;\n+    let _ = issue6919_3::D.k;\n }\n "}]}