{"sha": "3119d18e55fd393641cd744545f350807c4ee7b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMTlkMThlNTVmZDM5MzY0MWNkNzQ0NTQ1ZjM1MDgwN2M0ZWU3Yjg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-01-06T12:00:46Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-01-06T12:00:46Z"}, "message": "Disowned the Visitor.", "tree": {"sha": "5b7313e2a6dae8ac968c6c2bd642586bd4e19da5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b7313e2a6dae8ac968c6c2bd642586bd4e19da5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3119d18e55fd393641cd744545f350807c4ee7b8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3119d18e55fd393641cd744545f350807c4ee7b8", "html_url": "https://github.com/rust-lang/rust/commit/3119d18e55fd393641cd744545f350807c4ee7b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3119d18e55fd393641cd744545f350807c4ee7b8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e622becdc5fb4e07f95550c3a59fd909b97e5bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e622becdc5fb4e07f95550c3a59fd909b97e5bb", "html_url": "https://github.com/rust-lang/rust/commit/4e622becdc5fb4e07f95550c3a59fd909b97e5bb"}], "stats": {"total": 2179, "additions": 1038, "deletions": 1141}, "files": [{"sha": "0fccf50e009f4f90bbfb5561dbce1f1a5413321c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -163,7 +163,8 @@ pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &input)\n /// standard library and prelude.\n pub fn phase_2_configure_and_expand(sess: Session,\n                                     cfg: ast::CrateConfig,\n-                                    mut crate: ast::Crate) -> ast::Crate {\n+                                    mut crate: ast::Crate)\n+                                    -> (ast::Crate, syntax::ast_map::map) {\n     let time_passes = sess.time_passes();\n \n     sess.building_library.set(session::building_library(sess.opts, &crate));\n@@ -201,10 +202,8 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     crate = time(time_passes, \"std injection\", crate, |crate|\n                  front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n-    crate = time(time_passes, \"assigning node ids\", crate, |crate|\n-                 front::assign_node_ids::assign_node_ids(sess, crate));\n-\n-    return crate;\n+    time(time_passes, \"assinging node ids and indexing ast\", crate, |crate|\n+         front::assign_node_ids_and_map::assign_node_ids_and_map(sess, crate))\n }\n \n pub struct CrateAnalysis {\n@@ -219,13 +218,11 @@ pub struct CrateAnalysis {\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes(sess: Session,\n-                                   crate: &ast::Crate) -> CrateAnalysis {\n+                                   crate: &ast::Crate,\n+                                   ast_map: syntax::ast_map::map) -> CrateAnalysis {\n \n     let time_passes = sess.time_passes();\n \n-    let ast_map = time(time_passes, \"ast indexing\", (), |_|\n-                       syntax::ast_map::map_crate(sess.diagnostic(), crate));\n-\n     time(time_passes, \"external crate/lib resolution\", (), |_|\n          creader::read_crates(sess, crate,\n                               session::sess_os_to_meta_os(sess.targ_cfg.os),\n@@ -260,8 +257,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                             region_map, lang_items);\n \n     // passes are timed inside typeck\n-    let (method_map, vtable_map) = typeck::check_crate(\n-        ty_cx, trait_map, crate);\n+    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map, crate);\n \n     // These next two const passes can probably be merged\n     time(time_passes, \"const marking\", (), |_|\n@@ -489,7 +485,7 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans) = {\n-        let expanded_crate = {\n+        let (expanded_crate, ast_map) = {\n             let crate = phase_1_parse_input(sess, cfg.clone(), input);\n             if stop_after_phase_1(sess) { return; }\n             phase_2_configure_and_expand(sess, cfg, crate)\n@@ -501,7 +497,7 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n \n         if stop_after_phase_2(sess) { return; }\n \n-        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate);\n+        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n         if stop_after_phase_3(sess) { return; }\n         let trans = phase_4_translate_to_llvm(sess, expanded_crate,\n                                               &analysis, outputs);\n@@ -578,11 +574,12 @@ pub fn pretty_print_input(sess: Session,\n                           ppm: PpMode) {\n     let crate = phase_1_parse_input(sess, cfg.clone(), input);\n \n-    let (crate, is_expanded) = match ppm {\n+    let (crate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped => {\n-            (phase_2_configure_and_expand(sess, cfg, crate), true)\n+            let (crate, ast_map) = phase_2_configure_and_expand(sess, cfg, crate);\n+            (crate, Some(ast_map), true)\n         }\n-        _ => (crate, false)\n+        _ => (crate, None, false)\n     };\n \n     let annotation = match ppm {\n@@ -592,7 +589,8 @@ pub fn pretty_print_input(sess: Session,\n             } as @pprust::pp_ann\n         }\n         PpmTyped => {\n-            let analysis = phase_3_run_analysis_passes(sess, &crate);\n+            let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n+            let analysis = phase_3_run_analysis_passes(sess, &crate, ast_map);\n             @TypedAnnotation {\n                 analysis: analysis\n             } as @pprust::pp_ann"}, {"sha": "bf950f1d686940f7b8fa185fd7f799e1e1ec0dff", "filename": "src/librustc/front/assign_node_ids_and_map.rs", "status": "renamed", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,22 +11,19 @@\n use driver::session::Session;\n \n use syntax::ast;\n-use syntax::fold::ast_fold;\n+use syntax::ast_map;\n \n struct NodeIdAssigner {\n-    sess: Session,\n+    sess: Session\n }\n \n-impl ast_fold for NodeIdAssigner {\n-    fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n+impl ast_map::FoldOps for NodeIdAssigner {\n+    fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n         assert_eq!(old_id, ast::DUMMY_NODE_ID);\n         self.sess.next_node_id()\n     }\n }\n \n-pub fn assign_node_ids(sess: Session, crate: ast::Crate) -> ast::Crate {\n-    let mut fold = NodeIdAssigner {\n-        sess: sess,\n-    };\n-    fold.fold_crate(crate)\n+pub fn assign_node_ids_and_map(sess: Session, crate: ast::Crate) -> (ast::Crate, ast_map::map) {\n+    ast_map::map_crate(sess.diagnostic(), crate, NodeIdAssigner { sess: sess })\n }", "previous_filename": "src/librustc/front/assign_node_ids.rs"}, {"sha": "9f9d931cc133bb9c77eb8f8227f53a0ca024ab60", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -119,7 +119,7 @@ impl Visitor<()> for Context {\n         visit::walk_view_item(self, i, ())\n     }\n \n-    fn visit_item(&mut self, i: @ast::item, _:()) {\n+    fn visit_item(&mut self, i: &ast::item, _:()) {\n         for attr in i.attrs.iter() {\n             if \"thread_local\" == attr.name() {\n                 self.gate_feature(\"thread_local\", i.span,\n@@ -187,7 +187,7 @@ impl Visitor<()> for Context {\n         visit::walk_ty(self, t, ());\n     }\n \n-    fn visit_expr(&mut self, e: @ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         match e.node {\n             ast::ExprUnary(_, ast::UnBox, _) |\n             ast::ExprVstore(_, ast::ExprVstoreBox) => {"}, {"sha": "b3a2bb5b72c515532155739809d87e9062057bb7", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -81,7 +81,7 @@ pub mod front {\n     pub mod config;\n     pub mod test;\n     pub mod std_inject;\n-    pub mod assign_node_ids;\n+    pub mod assign_node_ids_and_map;\n     pub mod feature_gate;\n }\n "}, {"sha": "7f4e5b5d9ab41192178768c4f1fd9f1f1b917052", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -58,11 +58,11 @@ struct ReadCrateVisitor<'a> {\n }\n \n impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n-    fn visit_view_item(&mut self, a:&ast::view_item, _:()) {\n+    fn visit_view_item(&mut self, a: &ast::view_item, _: ()) {\n         visit_view_item(self.e, a);\n         visit::walk_view_item(self, a, ());\n     }\n-    fn visit_item(&mut self, a:@ast::item, _:()) {\n+    fn visit_item(&mut self, a: &ast::item, _: ()) {\n         visit_item(self.e, a);\n         visit::walk_item(self, a, ());\n     }\n@@ -164,7 +164,7 @@ fn visit_view_item(e: &mut Env, i: &ast::view_item) {\n   }\n }\n \n-fn visit_item(e: &Env, i: @ast::item) {\n+fn visit_item(e: &Env, i: &ast::item) {\n     match i.node {\n         ast::item_foreign_mod(ref fm) => {\n             if fm.abis.is_rust() || fm.abis.is_intrinsic() {"}, {"sha": "33a34c3f5ba62ded8466e6b86399cd70786d7fd0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -50,10 +50,17 @@ use writer = extra::ebml::writer;\n // used by astencode:\n type abbrev_map = @RefCell<HashMap<ty::t, tyencode::ty_abbrev>>;\n \n+/// A borrowed version of ast::inlined_item.\n+pub enum InlinedItemRef<'a> {\n+    ii_item_ref(&'a ast::item),\n+    ii_method_ref(ast::DefId, bool, &'a ast::method),\n+    ii_foreign_ref(&'a ast::foreign_item)\n+}\n+\n pub type encode_inlined_item<'a> = 'a |ecx: &EncodeContext,\n-                                             ebml_w: &mut writer::Encoder,\n-                                             path: &[ast_map::path_elt],\n-                                             ii: ast::inlined_item|;\n+                                       ebml_w: &mut writer::Encoder,\n+                                       path: &[ast_map::path_elt],\n+                                       ii: InlinedItemRef|;\n \n pub struct EncodeParams<'a> {\n     diag: @SpanHandler,\n@@ -837,13 +844,13 @@ fn encode_info_for_method(ecx: &EncodeContext,\n         None => ()\n     }\n \n-    for ast_method in ast_method_opt.iter() {\n+    for &ast_method in ast_method_opt.iter() {\n         let num_params = tpt.generics.type_param_defs.len();\n         if num_params > 0u || is_default_impl\n             || should_inline(ast_method.attrs) {\n             (ecx.encode_inlined_item)(\n                 ecx, ebml_w, impl_path,\n-                ii_method(local_def(parent_id), false, *ast_method));\n+                ii_method_ref(local_def(parent_id), false, ast_method));\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n@@ -915,13 +922,13 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n \n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n-                        item: @item,\n+                        item: &item,\n                         index: @RefCell<~[entry<i64>]>,\n                         path: &[ast_map::path_elt],\n                         vis: ast::visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: @item, ebml_w: &writer::Encoder,\n+    fn add_to_index(item: &item, ebml_w: &writer::Encoder,\n                      index: @RefCell<~[entry<i64>]>) {\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n@@ -958,7 +965,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n \n         if !non_inlineable {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item_ref(item));\n         }\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n@@ -974,7 +981,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n         if tps_len > 0u || should_inline(item.attrs) {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item_ref(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n@@ -1032,7 +1039,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n-        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item_ref(item));\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n \n         // Encode inherent implementations for this enumeration.\n@@ -1077,7 +1084,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         needs to know*/\n         encode_struct_fields(ecx, ebml_w, struct_def);\n \n-        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item_ref(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1272,7 +1279,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_method_sort(ebml_w, 'p');\n                     (ecx.encode_inlined_item)(\n                         ecx, ebml_w, path,\n-                        ii_method(def_id, true, m));\n+                        ii_method_ref(def_id, true, m));\n                 }\n             }\n \n@@ -1288,7 +1295,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n-                                nitem: @foreign_item,\n+                                nitem: &foreign_item,\n                                 index: @RefCell<~[entry<i64>]>,\n                                 path: &ast_map::path,\n                                 abi: AbiSet) {\n@@ -1309,7 +1316,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ecx, ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, *path, ii_foreign(nitem));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, *path, ii_foreign_ref(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n@@ -1331,9 +1338,9 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn my_visit_expr(_e:@Expr) { }\n+fn my_visit_expr(_e: &Expr) { }\n \n-fn my_visit_item(i: @item,\n+fn my_visit_item(i: &item,\n                  items: ast_map::map,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n@@ -1352,7 +1359,7 @@ fn my_visit_item(i: @item,\n     }\n }\n \n-fn my_visit_foreign_item(ni: @foreign_item,\n+fn my_visit_foreign_item(ni: &foreign_item,\n                          items: ast_map::map,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n@@ -1391,19 +1398,19 @@ struct EncodeVisitor<'a,'b> {\n }\n \n impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n-    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         visit::walk_expr(self, ex, ());\n         my_visit_expr(ex);\n     }\n-    fn visit_item(&mut self, i:@item, _:()) {\n+    fn visit_item(&mut self, i: &item, _: ()) {\n         visit::walk_item(self, i, ());\n         my_visit_item(i,\n                       self.items,\n                       self.ebml_w_for_visit_item,\n                       self.ecx_ptr,\n                       self.index);\n     }\n-    fn visit_foreign_item(&mut self, ni:@foreign_item, _:()) {\n+    fn visit_foreign_item(&mut self, ni: &foreign_item, _: ()) {\n         visit::walk_foreign_item(self, ni, ());\n         my_visit_foreign_item(ni,\n                               self.items,\n@@ -1692,7 +1699,7 @@ struct ImplVisitor<'a,'b> {\n }\n \n impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n-    fn visit_item(&mut self, item: @item, _: ()) {\n+    fn visit_item(&mut self, item: &item, _: ()) {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = self.ecx.tcx.def_map;"}, {"sha": "640d69432fce56f5c14c2a66b5f43fcbf40dba20", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 58, "deletions": 51, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -24,14 +24,10 @@ use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n-use syntax::ast;\n-use syntax::ast_map;\n-use syntax::ast_util::inlined_item_utils;\n-use syntax::ast_util;\n+use syntax::{ast, ast_map, ast_util, codemap, fold};\n use syntax::codemap::Span;\n-use syntax::codemap;\n-use syntax::fold::*;\n-use syntax::fold;\n+use syntax::diagnostic::SpanHandler;\n+use syntax::fold::ast_fold;\n use syntax::parse::token;\n use syntax;\n \n@@ -84,24 +80,30 @@ trait tr_intern {\n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            path: &[ast_map::path_elt],\n-                           ii: ast::inlined_item,\n+                           ii: e::InlinedItemRef,\n                            maps: Maps) {\n+    let ident = match ii {\n+        e::ii_item_ref(i) => i.ident,\n+        e::ii_foreign_ref(i) => i.ident,\n+        e::ii_method_ref(_, _, m) => m.ident,\n+    };\n     debug!(\"> Encoding inlined item: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n-           ecx.tcx.sess.str_of(ii.ident()),\n+           ecx.tcx.sess.str_of(ident),\n            ebml_w.writer.tell());\n \n+    let ii = simplify_ast(ii);\n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n \n     ebml_w.start_tag(c::tag_ast as uint);\n     id_range.encode(ebml_w);\n-    encode_ast(ebml_w, simplify_ast(&ii));\n+    encode_ast(ebml_w, ii);\n     encode_side_tables_for_ii(ecx, maps, ebml_w, &ii);\n     ebml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n-           ecx.tcx.sess.str_of(ii.ident()),\n+           ecx.tcx.sess.str_of(ident),\n            ebml_w.writer.tell());\n }\n \n@@ -130,15 +132,20 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n             to_id_range: to_id_range\n         };\n         let raw_ii = decode_ast(ast_doc);\n-        let ii = renumber_ast(xcx, raw_ii);\n-        debug!(\"Fn named: {}\", tcx.sess.str_of(ii.ident()));\n+        let ii = renumber_and_map_ast(xcx,\n+                                      tcx.sess.diagnostic(),\n+                                      dcx.tcx.items,\n+                                      path.to_owned(),\n+                                      raw_ii);\n+        let ident = match ii {\n+            ast::ii_item(i) => i.ident,\n+            ast::ii_foreign(i) => i.ident,\n+            ast::ii_method(_, _, m) => m.ident,\n+        };\n+        debug!(\"Fn named: {}\", tcx.sess.str_of(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                ast_map::path_to_str(path, token::get_ident_interner()),\n-               tcx.sess.str_of(ii.ident()));\n-        ast_map::map_decoded_item(tcx.sess.diagnostic(),\n-                                  dcx.tcx.items,\n-                                  path.to_owned(),\n-                                  &ii);\n+               tcx.sess.str_of(ident));\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::ii_item(i) => {\n@@ -295,11 +302,9 @@ fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n     ebml_w.end_tag();\n }\n \n-struct NestedItemsDropper {\n-    contents: (),\n-}\n+struct NestedItemsDropper;\n \n-impl fold::ast_fold for NestedItemsDropper {\n+impl ast_fold for NestedItemsDropper {\n     fn fold_block(&mut self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n             match stmt.node {\n@@ -338,18 +343,15 @@ impl fold::ast_fold for NestedItemsDropper {\n // As it happens, trans relies on the fact that we do not export\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n-fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n-    let mut fld = NestedItemsDropper {\n-        contents: (),\n-    };\n+fn simplify_ast(ii: e::InlinedItemRef) -> ast::inlined_item {\n+    let mut fld = NestedItemsDropper;\n \n-    match *ii {\n-        //hack: we're not dropping items\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i)\n-                                        .expect_one(\"expected one item\")),\n-        ast::ii_method(d, is_provided, m) =>\n-          ast::ii_method(d, is_provided, fld.fold_method(m)),\n-        ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n+    match ii {\n+        // HACK we're not dropping items.\n+        e::ii_item_ref(i) => ast::ii_item(fold::noop_fold_item(i, &mut fld)\n+                                          .expect_one(\"expected one item\")),\n+        e::ii_method_ref(d, p, m) => ast::ii_method(d, p, fold::noop_fold_method(m, &mut fld)),\n+        e::ii_foreign_ref(i) => ast::ii_foreign(fold::noop_fold_foreign_item(i, &mut fld))\n     }\n }\n \n@@ -363,27 +365,31 @@ struct AstRenumberer {\n     xcx: @ExtendedDecodeContext,\n }\n \n-impl fold::ast_fold for AstRenumberer {\n-    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n+impl ast_map::FoldOps for AstRenumberer {\n+    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n         self.xcx.tr_id(id)\n     }\n-    fn new_span(&mut self, span: Span) -> Span {\n+    fn new_span(&self, span: Span) -> Span {\n         self.xcx.tr_span(span)\n     }\n }\n \n-fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n-    -> ast::inlined_item {\n-    let mut fld = AstRenumberer {\n-        xcx: xcx,\n-    };\n-    match ii {\n-        ast::ii_item(i) => ast::ii_item(fld.fold_item(i)\n-                                        .expect_one(\"expected one item\")),\n-        ast::ii_method(d, is_provided, m) =>\n-          ast::ii_method(xcx.tr_def_id(d), is_provided, fld.fold_method(m)),\n-        ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i)),\n-    }\n+fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n+                        diag: @SpanHandler,\n+                        map: ast_map::map,\n+                        path: ast_map::path,\n+                        ii: ast::inlined_item) -> ast::inlined_item {\n+    ast_map::map_decoded_item(diag, map, path, AstRenumberer { xcx: xcx }, |fld| {\n+        match ii {\n+            ast::ii_item(i) => {\n+                ast::ii_item(fld.fold_item(i).expect_one(\"expected one item\"))\n+            }\n+            ast::ii_method(d, is_provided, m) => {\n+                ast::ii_method(xcx.tr_def_id(d), is_provided, fld.fold_method(m))\n+            }\n+            ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n+        }\n+    })\n }\n \n // ______________________________________________________________________\n@@ -1504,13 +1510,14 @@ fn test_more() {\n #[test]\n fn test_simplification() {\n     let cx = mk_ctxt();\n-    let item_in = ast::ii_item(quote_item!(cx,\n+    let item = quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             fn eq_int(a: int, b: int) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n-    ).unwrap());\n-    let item_out = simplify_ast(&item_in);\n+    ).unwrap();\n+    let item_in = e::ii_item_ref(item);\n+    let item_out = simplify_ast(item_in);\n     let item_exp = ast::ii_item(quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             return alist {eq_fn: eq_int, data: ~[]};"}, {"sha": "cf5a02d48e0892e0a4746defdba3a53a647d1a7b", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -30,30 +30,29 @@ use syntax::visit::Visitor;\n use syntax::visit;\n use util::ppaux::Repr;\n \n-#[deriving(Clone)]\n struct CheckLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt,\n     dfcx_loans: &'a LoanDataFlow,\n-    move_data: @move_data::FlowedMoveData,\n+    move_data: move_data::FlowedMoveData,\n     all_loans: &'a [Loan],\n }\n \n impl<'a> Visitor<()> for CheckLoanCtxt<'a> {\n \n-    fn visit_expr(&mut self, ex:@ast::Expr, _:()) {\n+    fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n         check_loans_in_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l:@ast::Local, _:()) {\n+    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n         check_loans_in_local(self, l);\n     }\n-    fn visit_block(&mut self, b:ast::P<ast::Block>, _:()) {\n+    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n         check_loans_in_block(self, b);\n     }\n-    fn visit_pat(&mut self, p:&ast::Pat, _:()) {\n+    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n         check_loans_in_pat(self, p);\n     }\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                b:ast::P<ast::Block>, s:Span, n:ast::NodeId, _:()) {\n+    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n+                b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n         check_loans_in_fn(self, fk, fd, b, s, n);\n     }\n \n@@ -65,13 +64,13 @@ pub fn check_loans(bccx: &BorrowckCtxt,\n                    dfcx_loans: &LoanDataFlow,\n                    move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n-                   body: ast::P<ast::Block>) {\n+                   body: &ast::Block) {\n     debug!(\"check_loans(body id={:?})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n         dfcx_loans: dfcx_loans,\n-        move_data: @move_data,\n+        move_data: move_data,\n         all_loans: all_loans,\n     };\n \n@@ -107,9 +106,9 @@ impl<'a> CheckLoanCtxt<'a> {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n-        let region_maps = self.tcx().region_maps;\n+        let tcx = self.tcx();\n         self.each_issued_loan(scope_id, |loan| {\n-            if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n+            if tcx.region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n                 op(loan)\n             } else {\n                 true\n@@ -190,9 +189,8 @@ impl<'a> CheckLoanCtxt<'a> {\n                new_loan.repr(self.tcx()));\n \n         // Should only be called for loans that are in scope at the same time.\n-        let region_maps = self.tcx().region_maps;\n-        assert!(region_maps.scopes_intersect(old_loan.kill_scope,\n-                                             new_loan.kill_scope));\n+        assert!(self.tcx().region_maps.scopes_intersect(old_loan.kill_scope,\n+                                                        new_loan.kill_scope));\n \n         self.report_error_if_loan_conflicts_with_restriction(\n             old_loan, new_loan, old_loan, new_loan) &&\n@@ -290,7 +288,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         });\n     }\n \n-    pub fn check_assignment(&self, expr: @ast::Expr) {\n+    pub fn check_assignment(&self, expr: &ast::Expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n         let adj = {\n@@ -401,7 +399,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         fn check_for_aliasable_mutable_writes(this: &CheckLoanCtxt,\n-                                              expr: @ast::Expr,\n+                                              expr: &ast::Expr,\n                                               cmt: mc::cmt) -> bool {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n@@ -422,7 +420,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n-                                            expr: @ast::Expr,\n+                                            expr: &ast::Expr,\n                                             cmt: mc::cmt) -> bool {\n             let mut cmt = cmt;\n \n@@ -467,7 +465,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         fn check_for_assignment_to_restricted_or_frozen_location(\n             this: &CheckLoanCtxt,\n-            expr: @ast::Expr,\n+            expr: &ast::Expr,\n             cmt: mc::cmt) -> bool\n         {\n             //! Check for assignments that violate the terms of an\n@@ -601,7 +599,7 @@ impl<'a> CheckLoanCtxt<'a> {\n     }\n \n     pub fn report_illegal_mutation(&self,\n-                                   expr: @ast::Expr,\n+                                   expr: &ast::Expr,\n                                    loan_path: &LoanPath,\n                                    loan: &Loan) {\n         self.bccx.span_err(\n@@ -614,7 +612,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                  self.bccx.loan_path_to_str(loan_path)));\n     }\n \n-    fn check_move_out_from_expr(&self, expr: @ast::Expr) {\n+    fn check_move_out_from_expr(&self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n                 // moves due to capture clauses are checked\n@@ -668,7 +666,7 @@ impl<'a> CheckLoanCtxt<'a> {\n     }\n \n     pub fn check_call(&self,\n-                      _expr: @ast::Expr,\n+                      _expr: &ast::Expr,\n                       _callee: Option<@ast::Expr>,\n                       _callee_id: ast::NodeId,\n                       _callee_span: Span,\n@@ -686,7 +684,7 @@ impl<'a> CheckLoanCtxt<'a> {\n fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n                          fk: &visit::fn_kind,\n                          decl: &ast::fn_decl,\n-                         body: ast::P<ast::Block>,\n+                         body: &ast::Block,\n                          sp: Span,\n                          id: ast::NodeId) {\n     match *fk {\n@@ -746,12 +744,12 @@ fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n }\n \n fn check_loans_in_local<'a>(this: &mut CheckLoanCtxt<'a>,\n-                            local: @ast::Local) {\n+                            local: &ast::Local) {\n     visit::walk_local(this, local, ());\n }\n \n fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n-                           expr: @ast::Expr) {\n+                           expr: &ast::Expr) {\n     visit::walk_expr(this, expr, ());\n \n     debug!(\"check_loans_in_expr(expr={})\",\n@@ -818,7 +816,7 @@ fn check_loans_in_pat<'a>(this: &mut CheckLoanCtxt<'a>,\n }\n \n fn check_loans_in_block<'a>(this: &mut CheckLoanCtxt<'a>,\n-                            blk: ast::P<ast::Block>)\n+                            blk: &ast::Block)\n {\n     visit::walk_block(this, blk, ());\n     this.check_for_conflicting_loans(blk.id);"}, {"sha": "9ba8e00dc8ecbbbd9221148ffd81f2e9bc80b701", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -33,18 +33,16 @@ pub fn gather_decl(bccx: &BorrowckCtxt,\n \n pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n                              move_data: &MoveData,\n-                             move_expr: @ast::Expr,\n+                             move_expr: &ast::Expr,\n                              cmt: mc::cmt) {\n-    gather_move_from_expr_or_pat(bccx, move_data, move_expr.id,\n-                                 MoveExpr(move_expr), cmt);\n+    gather_move_from_expr_or_pat(bccx, move_data, move_expr.id, MoveExpr, cmt);\n }\n \n pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n                             move_data: &MoveData,\n-                            move_pat: @ast::Pat,\n+                            move_pat: &ast::Pat,\n                             cmt: mc::cmt) {\n-    gather_move_from_expr_or_pat(bccx, move_data, move_pat.id,\n-                                 MovePat(move_pat), cmt);\n+    gather_move_from_expr_or_pat(bccx, move_data, move_pat.id, MovePat, cmt);\n }\n \n fn gather_move_from_expr_or_pat(bccx: &BorrowckCtxt,\n@@ -68,7 +66,7 @@ fn gather_move_from_expr_or_pat(bccx: &BorrowckCtxt,\n \n pub fn gather_captures(bccx: &BorrowckCtxt,\n                        move_data: &MoveData,\n-                       closure_expr: @ast::Expr) {\n+                       closure_expr: &ast::Expr) {\n     let capture_map = bccx.capture_map.borrow();\n     let captured_vars = capture_map.get().get(&closure_expr.id);\n     for captured_var in captured_vars.iter() {\n@@ -77,7 +75,7 @@ pub fn gather_captures(bccx: &BorrowckCtxt,\n                 let fvar_id = ast_util::def_id_of_def(captured_var.def).node;\n                 let loan_path = @LpVar(fvar_id);\n                 move_data.add_move(bccx.tcx, loan_path, closure_expr.id,\n-                                   Captured(closure_expr));\n+                                   Captured);\n             }\n             moves::CapCopy | moves::CapRef => {}\n         }"}, {"sha": "accbd4d8ccb6af315acf564e63ba6750dc63fdf0", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -33,7 +33,7 @@ use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::visit;\n use syntax::visit::{Visitor, fn_kind};\n-use syntax::ast::{P, Expr, fn_decl, Block, NodeId, Stmt, Pat, Local};\n+use syntax::ast::{Expr, fn_decl, Block, NodeId, Stmt, Pat, Local};\n \n mod lifetime;\n mod restrictions;\n@@ -68,50 +68,50 @@ mod gather_moves;\n struct GatherLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt,\n     id_range: id_range,\n-    move_data: @move_data::MoveData,\n+    move_data: move_data::MoveData,\n     all_loans: @RefCell<~[Loan]>,\n     item_ub: ast::NodeId,\n     repeating_ids: ~[ast::NodeId]\n }\n \n impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n-    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         gather_loans_in_expr(self, ex);\n     }\n-    fn visit_block(&mut self, b:P<Block>, _:()) {\n+    fn visit_block(&mut self, b: &Block, _: ()) {\n         gather_loans_in_block(self, b);\n     }\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>,\n-                s:Span, n:NodeId, _:()) {\n+    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block,\n+                s: Span, n: NodeId, _: ()) {\n         gather_loans_in_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_stmt(&mut self, s:@Stmt, _:()) {\n+    fn visit_stmt(&mut self, s: &Stmt, _: ()) {\n         visit::walk_stmt(self, s, ());\n     }\n-    fn visit_pat(&mut self, p:&Pat, _:()) {\n+    fn visit_pat(&mut self, p: &Pat, _: ()) {\n         add_pat_to_id_range(self, p);\n     }\n-    fn visit_local(&mut self, l:@Local, _:()) {\n+    fn visit_local(&mut self, l: &Local, _: ()) {\n         gather_loans_in_local(self, l);\n     }\n \n     // #7740: Do not visit items here, not even fn items nor methods\n     // of impl items; the outer loop in borrowck/mod will visit them\n     // for us in turn.  Thus override visit_item's walk with a no-op.\n-    fn visit_item(&mut self, _:@ast::item, _:()) { }\n+    fn visit_item(&mut self, _: &ast::item, _: ()) { }\n }\n \n pub fn gather_loans(bccx: &BorrowckCtxt,\n                     decl: &ast::fn_decl,\n-                    body: ast::P<ast::Block>)\n-                    -> (id_range, @RefCell<~[Loan]>, @move_data::MoveData) {\n+                    body: &ast::Block)\n+                    -> (id_range, @RefCell<~[Loan]>, move_data::MoveData) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         id_range: id_range::max(),\n         all_loans: @RefCell::new(~[]),\n         item_ub: body.id,\n         repeating_ids: ~[body.id],\n-        move_data: @MoveData::new()\n+        move_data: MoveData::new()\n     };\n     glcx.gather_fn_arg_patterns(decl, body);\n \n@@ -132,7 +132,7 @@ fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n                       fk: &fn_kind,\n                       decl: &ast::fn_decl,\n-                      body: ast::P<ast::Block>,\n+                      body: &ast::Block,\n                       sp: Span,\n                       id: ast::NodeId) {\n     match fk {\n@@ -151,20 +151,20 @@ fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n }\n \n fn gather_loans_in_block(this: &mut GatherLoanCtxt,\n-                         blk: ast::P<ast::Block>) {\n+                         blk: &ast::Block) {\n     this.id_range.add(blk.id);\n     visit::walk_block(this, blk, ());\n }\n \n fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n-                         local: @ast::Local) {\n+                         local: &ast::Local) {\n     match local.init {\n         None => {\n             // Variable declarations without initializers are considered \"moves\":\n             let tcx = this.bccx.tcx;\n             pat_util::pat_bindings(tcx.def_map, local.pat, |_, id, span, _| {\n                 gather_moves::gather_decl(this.bccx,\n-                                          this.move_data,\n+                                          &this.move_data,\n                                           id,\n                                           span,\n                                           id);\n@@ -175,7 +175,7 @@ fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n             let tcx = this.bccx.tcx;\n             pat_util::pat_bindings(tcx.def_map, local.pat, |_, id, span, _| {\n                 gather_moves::gather_assignment(this.bccx,\n-                                                this.move_data,\n+                                                &this.move_data,\n                                                 id,\n                                                 span,\n                                                 @LpVar(id),\n@@ -191,7 +191,7 @@ fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n \n \n fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n-                        ex: @ast::Expr) {\n+                        ex: &ast::Expr) {\n     let bccx = this.bccx;\n     let tcx = bccx.tcx;\n \n@@ -220,7 +220,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     if this.bccx.is_move(ex.id) {\n         let cmt = this.bccx.cat_expr(ex);\n         gather_moves::gather_move_from_expr(\n-            this.bccx, this.move_data, ex, cmt);\n+            this.bccx, &this.move_data, ex, cmt);\n     }\n \n     // Special checks for various kinds of expressions:\n@@ -247,7 +247,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n           let l_cmt = this.bccx.cat_expr(l);\n           match opt_loan_path(l_cmt) {\n               Some(l_lp) => {\n-                  gather_moves::gather_assignment(this.bccx, this.move_data,\n+                  gather_moves::gather_assignment(this.bccx, &this.move_data,\n                                                   ex.id, ex.span,\n                                                   l_lp, l.id);\n               }\n@@ -309,7 +309,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n       }\n \n       ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-          gather_moves::gather_captures(this.bccx, this.move_data, ex);\n+          gather_moves::gather_captures(this.bccx, &this.move_data, ex);\n           visit::walk_expr(this, ex, ());\n       }\n \n@@ -318,7 +318,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n               let out_cmt = this.bccx.cat_expr(out);\n               match opt_loan_path(out_cmt) {\n                   Some(out_lp) => {\n-                      gather_moves::gather_assignment(this.bccx, this.move_data,\n+                      gather_moves::gather_assignment(this.bccx, &this.move_data,\n                                                       ex.id, ex.span,\n                                                       out_lp, out.id);\n                   }\n@@ -349,7 +349,7 @@ impl<'a> GatherLoanCtxt<'a> {\n     }\n \n     pub fn guarantee_adjustments(&mut self,\n-                                 expr: @ast::Expr,\n+                                 expr: &ast::Expr,\n                                  adjustment: &ty::AutoAdjustment) {\n         debug!(\"guarantee_adjustments(expr={}, adjustment={:?})\",\n                expr.repr(self.tcx()), adjustment);\n@@ -639,8 +639,7 @@ impl<'a> GatherLoanCtxt<'a> {\n         //! notably method arguments, the loan may be introduced only\n         //! later, once it comes into scope.\n \n-        let rm = self.bccx.tcx.region_maps;\n-        if rm.is_subscope_of(borrow_id, loan_scope) {\n+        if self.bccx.tcx.region_maps.is_subscope_of(borrow_id, loan_scope) {\n             borrow_id\n         } else {\n             loan_scope\n@@ -668,12 +667,11 @@ impl<'a> GatherLoanCtxt<'a> {\n         //! with immutable `&` pointers, because borrows of such pointers\n         //! do not require restrictions and hence do not cause a loan.\n \n-        let rm = self.bccx.tcx.region_maps;\n-        let lexical_scope = rm.encl_scope(lp.node_id());\n-        if rm.is_subscope_of(lexical_scope, loan_scope) {\n+        let lexical_scope = self.bccx.tcx.region_maps.encl_scope(lp.node_id());\n+        if self.bccx.tcx.region_maps.is_subscope_of(lexical_scope, loan_scope) {\n             lexical_scope\n         } else {\n-            assert!(rm.is_subscope_of(loan_scope, lexical_scope));\n+            assert!(self.bccx.tcx.region_maps.is_subscope_of(loan_scope, lexical_scope));\n             loan_scope\n         }\n     }\n@@ -704,7 +702,7 @@ impl<'a> GatherLoanCtxt<'a> {\n \n     fn gather_pat(&mut self,\n                   discr_cmt: mc::cmt,\n-                  root_pat: @ast::Pat,\n+                  root_pat: &ast::Pat,\n                   arm_match_ids: Option<(ast::NodeId, ast::NodeId)>) {\n         /*!\n          * Walks patterns, examining the bindings to determine if they\n@@ -755,7 +753,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                       // No borrows here, but there may be moves\n                       if self.bccx.is_move(pat.id) {\n                           gather_moves::gather_move_from_pat(\n-                              self.bccx, self.move_data, pat, cmt);\n+                              self.bccx, &self.move_data, pat, cmt);\n                       }\n                   }\n                 }\n@@ -804,7 +802,7 @@ impl<'a> GatherLoanCtxt<'a> {\n         })\n     }\n \n-    pub fn vec_slice_info(&self, pat: @ast::Pat, slice_ty: ty::t)\n+    pub fn vec_slice_info(&self, pat: &ast::Pat, slice_ty: ty::t)\n                           -> (ast::Mutability, ty::Region) {\n         /*!\n          *\n@@ -831,8 +829,7 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    pub fn pat_is_binding(&self, pat: @ast::Pat) -> bool {\n+    pub fn pat_is_binding(&self, pat: &ast::Pat) -> bool {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }\n }\n-"}, {"sha": "dc645bc9a6ff41a6f6d39c08952a33e3faf15104", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -29,7 +29,7 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{P,fn_decl,Block,NodeId};\n+use syntax::ast::{fn_decl,Block,NodeId};\n \n macro_rules! if_ok(\n     ($inp: expr) => (\n@@ -61,8 +61,8 @@ impl Clone for LoanDataFlowOperator {\n pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n impl Visitor<()> for BorrowckCtxt {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n-                b:P<Block>, s:Span, n:NodeId, _:()) {\n+    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl,\n+                b: &Block, s: Span, n: NodeId, _: ()) {\n         borrowck_fn(self, fk, fd, b, s, n);\n     }\n }\n@@ -116,7 +116,7 @@ pub fn check_crate(tcx: ty::ctxt,\n fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: &visit::fn_kind,\n                decl: &ast::fn_decl,\n-               body: ast::P<ast::Block>,\n+               body: &ast::Block,\n                sp: Span,\n                id: ast::NodeId) {\n     match fk {\n@@ -455,17 +455,17 @@ impl BorrowckCtxt {\n         moves_map.get().contains(&id)\n     }\n \n-    pub fn cat_expr(&self, expr: @ast::Expr) -> mc::cmt {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt {\n         mc::cat_expr(self.tcx, self.method_map, expr)\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: @ast::Expr) -> mc::cmt {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> mc::cmt {\n         mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n     }\n \n     pub fn cat_expr_autoderefd(&self,\n-                               expr: @ast::Expr,\n-                               adj: @ty::AutoAdjustment)\n+                               expr: &ast::Expr,\n+                               adj: &ty::AutoAdjustment)\n                                -> mc::cmt {\n         match *adj {\n             ty::AutoAddEnv(..) | ty::AutoObject(..) => {\n@@ -504,8 +504,8 @@ impl BorrowckCtxt {\n \n     pub fn cat_pattern(&self,\n                        cmt: mc::cmt,\n-                       pat: @ast::Pat,\n-                       op: |mc::cmt, @ast::Pat|) {\n+                       pat: &ast::Pat,\n+                       op: |mc::cmt, &ast::Pat|) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }\n@@ -550,34 +550,48 @@ impl BorrowckCtxt {\n         match move.kind {\n             move_data::Declared => {}\n \n-            move_data::MoveExpr(expr) => {\n-                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+            move_data::MoveExpr => {\n+                let items = self.tcx.items.borrow();\n+                let (expr_ty, expr_span) = match items.get().find(&move.id) {\n+                    Some(&ast_map::node_expr(expr)) => {\n+                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                    }\n+                    r => self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to {:?}, not Expr\",\n+                                                   move.id, r))\n+                };\n                 let suggestion = move_suggestion(self.tcx, expr_ty,\n                         \"moved by default (use `copy` to override)\");\n                 self.tcx.sess.span_note(\n-                    expr.span,\n+                    expr_span,\n                     format!(\"`{}` moved here because it has type `{}`, which is {}\",\n                          self.loan_path_to_str(moved_lp),\n                          expr_ty.user_string(self.tcx), suggestion));\n             }\n \n-            move_data::MovePat(pat) => {\n-                let pat_ty = ty::node_id_to_type(self.tcx, pat.id);\n+            move_data::MovePat => {\n+                let pat_ty = ty::node_id_to_type(self.tcx, move.id);\n                 self.tcx.sess.span_note(\n-                    pat.span,\n+                    ast_map::node_span(self.tcx.items, move.id),\n                     format!(\"`{}` moved here because it has type `{}`, \\\n                           which is moved by default (use `ref` to override)\",\n                          self.loan_path_to_str(moved_lp),\n                          pat_ty.user_string(self.tcx)));\n             }\n \n-            move_data::Captured(expr) => {\n-                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+            move_data::Captured => {\n+                let items = self.tcx.items.borrow();\n+                let (expr_ty, expr_span) = match items.get().find(&move.id) {\n+                    Some(&ast_map::node_expr(expr)) => {\n+                        (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n+                    }\n+                    r => self.tcx.sess.bug(format!(\"Captured({:?}) maps to {:?}, not Expr\",\n+                                                   move.id, r))\n+                };\n                 let suggestion = move_suggestion(self.tcx, expr_ty,\n                         \"moved by default (make a copy and \\\n                          capture that instead to override)\");\n                 self.tcx.sess.span_note(\n-                    expr.span,\n+                    expr_span,\n                     format!(\"`{}` moved into closure environment here because it \\\n                           has type `{}`, which is {}\",\n                          self.loan_path_to_str(moved_lp),\n@@ -757,7 +771,7 @@ impl BorrowckCtxt {\n             LpVar(id) => {\n                 let items = self.tcx.items.borrow();\n                 match items.get().find(&id) {\n-                    Some(&ast_map::node_local(ref ident)) => {\n+                    Some(&ast_map::node_local(ref ident, _)) => {\n                         out.push_str(token::ident_to_str(ident));\n                     }\n                     r => {"}, {"sha": "f6d1417d0de61133949cbfdfe4af8cf1b446d2fa", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -53,12 +53,7 @@ pub struct MoveData {\n }\n \n pub struct FlowedMoveData {\n-    move_data: @MoveData,\n-    //         ^~~~~~~~~\n-    // It makes me sad to use @ here, except that due to\n-    // the old visitor design, this is what gather_loans\n-    // used to have to produce, and this code hasn't been\n-    // updated.\n+    move_data: MoveData,\n \n     dfcx_moves: MoveDataFlow,\n \n@@ -120,10 +115,10 @@ pub struct MovePath {\n }\n \n pub enum MoveKind {\n-    Declared,               // When declared, variables start out \"moved\".\n-    MoveExpr(@ast::Expr),   // Expression or binding that moves a variable\n-    MovePat(@ast::Pat),     // By-move binding\n-    Captured(@ast::Expr),   // Closure creation that moves a value\n+    Declared,   // When declared, variables start out \"moved\".\n+    MoveExpr,   // Expression or binding that moves a variable\n+    MovePat,    // By-move binding\n+    Captured    // Closure creation that moves a value\n }\n \n pub struct Move {\n@@ -137,7 +132,7 @@ pub struct Move {\n     kind: MoveKind,\n \n     /// Next node in linked list of moves from `path`, or `InvalidMoveIndex`\n-    next_move: MoveIndex,\n+    next_move: MoveIndex\n }\n \n pub struct Assignment {\n@@ -568,7 +563,7 @@ impl MoveData {\n }\n \n impl FlowedMoveData {\n-    pub fn new(move_data: @MoveData,\n+    pub fn new(move_data: MoveData,\n                tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                id_range: ast_util::id_range,"}, {"sha": "1e373d1f82d3ed143e47c3b07883eed97524585f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -15,7 +15,6 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux;\n \n-use std::cell::RefCell;\n use syntax::ast::*;\n use syntax::codemap;\n use syntax::{ast_util, ast_map};\n@@ -31,13 +30,13 @@ struct CheckCrateVisitor {\n }\n \n impl Visitor<bool> for CheckCrateVisitor {\n-    fn visit_item(&mut self, i:@item, env:bool) {\n+    fn visit_item(&mut self, i: &item, env: bool) {\n         check_item(self, self.sess, self.ast_map, self.def_map, i, env);\n     }\n-    fn visit_pat(&mut self, p:&Pat, env:bool) {\n+    fn visit_pat(&mut self, p: &Pat, env: bool) {\n         check_pat(self, p, env);\n     }\n-    fn visit_expr(&mut self, ex:@Expr, env:bool) {\n+    fn visit_expr(&mut self, ex: &Expr, env: bool) {\n         check_expr(self, self.sess, self.def_map, self.method_map,\n                    self.tcx, ex, env);\n     }\n@@ -64,7 +63,7 @@ pub fn check_item(v: &mut CheckCrateVisitor,\n                   sess: Session,\n                   ast_map: ast_map::map,\n                   def_map: resolve::DefMap,\n-                  it: @item,\n+                  it: &item,\n                   _is_const: bool) {\n     match it.node {\n       item_static(_, _, ex) => {\n@@ -111,7 +110,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                   def_map: resolve::DefMap,\n                   method_map: typeck::method_map,\n                   tcx: ty::ctxt,\n-                  e: @Expr,\n+                  e: &Expr,\n                   is_const: bool) {\n     if is_const {\n         match e.node {\n@@ -211,62 +210,49 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n     visit::walk_expr(v, e, is_const);\n }\n \n-#[deriving(Clone)]\n-struct env {\n-    root_it: @item,\n+struct CheckItemRecursionVisitor<'a> {\n+    root_it: &'a item,\n     sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n-    idstack: @RefCell<~[NodeId]>,\n-}\n-\n-struct CheckItemRecursionVisitor {\n-    env: env,\n+    idstack: ~[NodeId]\n }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion(sess: Session,\n                             ast_map: ast_map::map,\n                             def_map: resolve::DefMap,\n-                            it: @item) {\n-    let env = env {\n+                            it: &item) {\n+\n+    let mut visitor = CheckItemRecursionVisitor {\n         root_it: it,\n         sess: sess,\n         ast_map: ast_map,\n         def_map: def_map,\n-        idstack: @RefCell::new(~[]),\n+        idstack: ~[]\n     };\n-\n-    let mut visitor = CheckItemRecursionVisitor { env: env };\n     visitor.visit_item(it, ());\n }\n \n-impl Visitor<()> for CheckItemRecursionVisitor {\n-    fn visit_item(&mut self, it: @item, _: ()) {\n-        {\n-            let mut idstack = self.env.idstack.borrow_mut();\n-            if idstack.get().iter().any(|x| x == &(it.id)) {\n-                self.env.sess.span_fatal(self.env.root_it.span,\n-                                         \"recursive constant\");\n-            }\n-            idstack.get().push(it.id);\n+impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n+    fn visit_item(&mut self, it: &item, _: ()) {\n+        if self.idstack.iter().any(|x| x == &(it.id)) {\n+            self.sess.span_fatal(self.root_it.span, \"recursive constant\");\n         }\n+        self.idstack.push(it.id);\n         visit::walk_item(self, it, ());\n-        {\n-            let mut idstack = self.env.idstack.borrow_mut();\n-            idstack.get().pop();\n-        }\n+        self.idstack.pop();\n     }\n \n-    fn visit_expr(&mut self, e: @Expr, _: ()) {\n+    fn visit_expr(&mut self, e: &Expr, _: ()) {\n         match e.node {\n             ExprPath(..) => {\n-                let def_map = self.env.def_map.borrow();\n+                let def_map = self.def_map.borrow();\n                 match def_map.get().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n                             ast_util::is_local(def_id) => {\n-                        let ast_map = self.env.ast_map.borrow();\n+                        let ast_map = self.ast_map.borrow();\n                         match ast_map.get().get_copy(&def_id.node) {\n                             ast_map::node_item(it, _) => {\n                                 self.visit_item(it, ());"}, {"sha": "456c93416541b1d94425f8e29b85461932f9ba87", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -29,11 +29,11 @@ pub fn check_crate(tcx: ty::ctxt, crate: &ast::Crate) {\n }\n \n impl Visitor<Context> for CheckLoopVisitor {\n-    fn visit_item(&mut self, i: @ast::item, _cx: Context) {\n+    fn visit_item(&mut self, i: &ast::item, _cx: Context) {\n         visit::walk_item(self, i, Normal);\n     }\n \n-    fn visit_expr(&mut self, e: @ast::Expr, cx:Context) {\n+    fn visit_expr(&mut self, e: &ast::Expr, cx:Context) {\n         match e.node {\n             ast::ExprWhile(e, b) => {\n                 self.visit_expr(e, cx);"}, {"sha": "4688760d6c1b9e2b4fb16792edf021b85d54756a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -38,14 +38,14 @@ struct CheckMatchVisitor {\n }\n \n impl Visitor<()> for CheckMatchVisitor {\n-    fn visit_expr(&mut self, ex:@Expr, e:()) {\n-        check_expr(self, self.cx, ex, e);\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n+        check_expr(self, self.cx, ex, ());\n     }\n-    fn visit_local(&mut self, l:@Local, e:()) {\n-        check_local(self, self.cx, l, e);\n+    fn visit_local(&mut self, l: &Local, _: ()) {\n+        check_local(self, self.cx, l, ());\n     }\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, e:()) {\n-        check_fn(self, self.cx, fk, fd, b, s, n, e);\n+    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block, s: Span, n: NodeId, _: ()) {\n+        check_fn(self, self.cx, fk, fd, b, s, n, ());\n     }\n }\n \n@@ -65,7 +65,7 @@ pub fn check_crate(tcx: ty::ctxt,\n \n fn check_expr(v: &mut CheckMatchVisitor,\n                   cx: @MatchCheckCtxt,\n-                  ex: @Expr,\n+                  ex: &Expr,\n                   s: ()) {\n     visit::walk_expr(v, ex, s);\n     match ex.node {\n@@ -830,7 +830,7 @@ fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<~[@Pat]> {\n \n fn check_local(v: &mut CheckMatchVisitor,\n                    cx: &MatchCheckCtxt,\n-                   loc: @Local,\n+                   loc: &Local,\n                    s: ()) {\n     visit::walk_local(v, loc, s);\n     if is_refutable(cx, loc.pat) {\n@@ -846,7 +846,7 @@ fn check_fn(v: &mut CheckMatchVisitor,\n                 cx: &MatchCheckCtxt,\n                 kind: &visit::fn_kind,\n                 decl: &fn_decl,\n-                body: P<Block>,\n+                body: &Block,\n                 sp: Span,\n                 id: NodeId,\n                 s: ()) {"}, {"sha": "bd27900e9cc3210aa7223c62ffd76673e98a645c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -296,7 +296,7 @@ impl ConstEvalVisitor {\n }\n \n impl Visitor<()> for ConstEvalVisitor {\n-    fn visit_expr_post(&mut self, e:@Expr, _:()) {\n+    fn visit_expr_post(&mut self, e: &Expr, _: ()) {\n         self.classify(e);\n     }\n }"}, {"sha": "ab19cdf627fcc106ff033b61ed3ccee3833cb6fd", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -753,7 +753,6 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n         //! concern items that are going out of scope).\n \n         let tcx = self.tcx();\n-        let region_maps = tcx.region_maps;\n \n         debug!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n                from_expr.repr(tcx), to_scope.loop_id,\n@@ -763,7 +762,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n         while id != to_scope.loop_id {\n             self.dfcx.apply_kill(id, in_out);\n \n-            match region_maps.opt_encl_scope(id) {\n+            match tcx.region_maps.opt_encl_scope(id) {\n                 Some(i) => { id = i; }\n                 None => {\n                     tcx.sess.span_bug("}, {"sha": "307eb57805c13ceb32c12a42255064804d464ae7", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -174,7 +174,7 @@ impl MarkSymbolVisitor {\n \n impl Visitor<()> for MarkSymbolVisitor {\n \n-    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n             ast::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(&expr.id, expr.span);\n@@ -190,7 +190,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n         visit::walk_path(self, path, ());\n     }\n \n-    fn visit_item(&mut self, _item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, _item: &ast::item, _: ()) {\n         // Do not recurse into items. These items will be added to the\n         // worklist and recursed into manually if necessary.\n     }\n@@ -204,7 +204,7 @@ struct TraitMethodSeeder {\n }\n \n impl Visitor<()> for TraitMethodSeeder {\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         match item.node {\n             ast::item_impl(_, Some(ref _trait_ref), _, ref methods) => {\n                 for method in methods.iter() {\n@@ -265,7 +265,7 @@ fn find_live(tcx: ty::ctxt,\n     symbol_visitor.live_symbols\n }\n \n-fn should_warn(item: @ast::item) -> bool {\n+fn should_warn(item: &ast::item) -> bool {\n     match item.node {\n         ast::item_static(..)\n         | ast::item_fn(..)\n@@ -335,23 +335,23 @@ impl DeadVisitor {\n }\n \n impl Visitor<()> for DeadVisitor {\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         let ctor_id = get_struct_ctor_id(item);\n         if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n             self.warn_dead_code(item.id, item.span, &item.ident);\n         }\n         visit::walk_item(self, item, ());\n     }\n \n-    fn visit_foreign_item(&mut self, fi: @ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, fi: &ast::foreign_item, _: ()) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, &fi.ident);\n         }\n         visit::walk_foreign_item(self, fi, ());\n     }\n \n     fn visit_fn(&mut self, fk: &visit::fn_kind,\n-                _: &ast::fn_decl, block: ast::P<ast::Block>,\n+                _: &ast::fn_decl, block: &ast::Block,\n                 span: codemap::Span, id: ast::NodeId, _: ()) {\n         // Have to warn method here because methods are not ast::item\n         match *fk {\n@@ -367,7 +367,7 @@ impl Visitor<()> for DeadVisitor {\n     }\n \n     // Overwrite so that we don't warn the trait method itself.\n-    fn visit_trait_method(&mut self, trait_method :&ast::trait_method, _: ()) {\n+    fn visit_trait_method(&mut self, trait_method: &ast::trait_method, _: ()) {\n         match *trait_method {\n             ast::provided(method) => visit::walk_block(self, method.body, ()),\n             ast::required(_) => ()"}, {"sha": "86e590d332697b40369ffb843feaf0c236227efc", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -82,7 +82,7 @@ impl EffectCheckVisitor {\n \n impl Visitor<()> for EffectCheckVisitor {\n     fn visit_fn(&mut self, fn_kind: &visit::fn_kind, fn_decl: &ast::fn_decl,\n-                block: ast::P<ast::Block>, span: Span, node_id: ast::NodeId, _:()) {\n+                block: &ast::Block, span: Span, node_id: ast::NodeId, _:()) {\n \n         let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n             visit::fk_item_fn(_, _, purity, _) =>\n@@ -104,7 +104,7 @@ impl Visitor<()> for EffectCheckVisitor {\n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_block(&mut self, block: ast::P<ast::Block>, _:()) {\n+    fn visit_block(&mut self, block: &ast::Block, _:()) {\n         let old_unsafe_context = self.unsafe_context;\n         let is_unsafe = match block.rules {\n             ast::UnsafeBlock(..) => true, ast::DefaultBlock => false\n@@ -118,7 +118,7 @@ impl Visitor<()> for EffectCheckVisitor {\n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_expr(&mut self, expr: @ast::Expr, _:()) {\n+    fn visit_expr(&mut self, expr: &ast::Expr, _:()) {\n         match expr.node {\n             ast::ExprMethodCall(callee_id, _, _, _, _, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, callee_id);"}, {"sha": "4688818c0555ab77f0e0b9600128898a4726605f", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -39,7 +39,7 @@ struct EntryContext {\n }\n \n impl Visitor<()> for EntryContext {\n-    fn visit_item(&mut self, item:@item, _:()) {\n+    fn visit_item(&mut self, item: &item, _:()) {\n         find_item(item, self);\n     }\n }\n@@ -70,7 +70,7 @@ pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map)\n     configure_main(&mut ctxt);\n }\n \n-fn find_item(item: @item, ctxt: &mut EntryContext) {\n+fn find_item(item: &item, ctxt: &mut EntryContext) {\n     match item.node {\n         item_fn(..) => {\n             if item.ident.name == special_idents::main.name {"}, {"sha": "de951193cda06b88a7139de23ad69cf58e0e8d52", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -40,45 +40,44 @@ struct CollectFreevarsVisitor {\n \n impl Visitor<int> for CollectFreevarsVisitor {\n \n-    fn visit_item(&mut self, _:@item, _:int) {\n+    fn visit_item(&mut self, _: &item, _: int) {\n         // ignore_item\n     }\n \n-    fn visit_expr(&mut self, expr:@ast::Expr, depth:int) {\n-\n-            match expr.node {\n-              ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n+    fn visit_expr(&mut self, expr: &ast::Expr, depth: int) {\n+        match expr.node {\n+            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n                 visit::walk_expr(self, expr, depth + 1)\n-              }\n-              ast::ExprPath(..) | ast::ExprSelf => {\n-                  let mut i = 0;\n-                  let def_map = self.def_map.borrow();\n-                  match def_map.get().find(&expr.id) {\n+            }\n+            ast::ExprPath(..) | ast::ExprSelf => {\n+                let mut i = 0;\n+                let def_map = self.def_map.borrow();\n+                match def_map.get().find(&expr.id) {\n                     None => fail!(\"path not found\"),\n                     Some(&df) => {\n-                      let mut def = df;\n-                      while i < depth {\n-                        match def {\n-                          ast::DefUpvar(_, inner, _, _) => { def = *inner; }\n-                          _ => break\n+                        let mut def = df;\n+                        while i < depth {\n+                            match def {\n+                                ast::DefUpvar(_, inner, _, _) => { def = *inner; }\n+                                _ => break\n+                            }\n+                            i += 1;\n                         }\n-                        i += 1;\n-                      }\n-                      if i == depth { // Made it to end of loop\n-                        let dnum = ast_util::def_id_of_def(def).node;\n-                        if !self.seen.contains_key(&dnum) {\n-                            self.refs.push(@freevar_entry {\n-                                def: def,\n-                                span: expr.span,\n-                            });\n-                            self.seen.insert(dnum, ());\n+                        if i == depth { // Made it to end of loop\n+                            let dnum = ast_util::def_id_of_def(def).node;\n+                            if !self.seen.contains_key(&dnum) {\n+                                self.refs.push(@freevar_entry {\n+                                    def: def,\n+                                    span: expr.span,\n+                                });\n+                                self.seen.insert(dnum, ());\n+                            }\n                         }\n-                      }\n                     }\n-                  }\n-              }\n-              _ => visit::walk_expr(self, expr, depth)\n+                }\n             }\n+            _ => visit::walk_expr(self, expr, depth)\n+        }\n     }\n \n \n@@ -89,8 +88,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: resolve::DefMap, blk: ast::P<ast::Block>)\n-    -> freevar_info {\n+fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block) -> freevar_info {\n     let seen = HashMap::new();\n     let refs = ~[];\n \n@@ -114,8 +112,8 @@ struct AnnotateFreevarsVisitor {\n }\n \n impl Visitor<()> for AnnotateFreevarsVisitor {\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n-                blk:ast::P<ast::Block>, s:Span, nid:ast::NodeId, _:()) {\n+    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n+                blk: &ast::Block, s: Span, nid: ast::NodeId, _: ()) {\n         let vars = collect_freevars(self.def_map, blk);\n         self.freevars.insert(nid, vars);\n         visit::walk_fn(self, fk, fd, blk, s, nid, ());"}, {"sha": "4b78fef699c255d2ea8e49d656f23e77db41d6ab", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -58,18 +58,19 @@ pub struct Context {\n \n impl Visitor<()> for Context {\n \n-    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n     }\n \n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, _:()) {\n+    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &fn_decl,\n+                b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n \n-    fn visit_ty(&mut self, t:&Ty, _:()) {\n+    fn visit_ty(&mut self, t: &Ty, _: ()) {\n         check_ty(self, t);\n     }\n-    fn visit_item(&mut self, i:@item, _:()) {\n+    fn visit_item(&mut self, i: &item, _: ()) {\n         check_item(self, i);\n     }\n }\n@@ -115,7 +116,7 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n     }\n }\n \n-fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_type: &Ty) {\n+fn check_impl_of_trait(cx: &mut Context, it: &item, trait_ref: &trait_ref, self_type: &Ty) {\n     let def_map = cx.tcx.def_map.borrow();\n     let ast_trait_def = def_map.get()\n                                .find(&trait_ref.ref_id)\n@@ -158,7 +159,7 @@ fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_\n     }\n }\n \n-fn check_item(cx: &mut Context, item: @item) {\n+fn check_item(cx: &mut Context, item: &item) {\n     if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), self_type, _) => {\n@@ -247,7 +248,7 @@ fn check_fn(\n     cx: &mut Context,\n     fk: &visit::fn_kind,\n     decl: &fn_decl,\n-    body: P<Block>,\n+    body: &Block,\n     sp: Span,\n     fn_id: NodeId) {\n \n@@ -262,7 +263,7 @@ fn check_fn(\n     visit::walk_fn(cx, fk, decl, body, sp, fn_id, ());\n }\n \n-pub fn check_expr(cx: &mut Context, e: @Expr) {\n+pub fn check_expr(cx: &mut Context, e: &Expr) {\n     debug!(\"kind::check_expr({})\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters"}, {"sha": "844a27668db96dfcd8de96f8347ec459130a8082", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -109,7 +109,7 @@ struct LanguageItemVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         match extract(item.attrs) {\n             Some(value) => {\n                 let item_index = self.this.item_refs.find_equiv(&value).map(|x| *x);"}, {"sha": "c5fdf3a135137c019d61dd0f802fd5ac3eefc5da", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -1303,7 +1303,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n }\n \n impl<'a> Visitor<()> for Context<'a> {\n-    fn visit_item(&mut self, it: @ast::item, _: ()) {\n+    fn visit_item(&mut self, it: &ast::item, _: ()) {\n         self.with_lint_attrs(it.attrs, |cx| {\n             check_item_ctypes(cx, it);\n             check_item_non_camel_case_types(cx, it);\n@@ -1318,7 +1318,7 @@ impl<'a> Visitor<()> for Context<'a> {\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: @ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, it: &ast::foreign_item, _: ()) {\n         self.with_lint_attrs(it.attrs, |cx| {\n             check_attrs_usage(cx, it.attrs);\n             visit::walk_foreign_item(cx, it, ());\n@@ -1339,7 +1339,7 @@ impl<'a> Visitor<()> for Context<'a> {\n         visit::walk_pat(self, p, ());\n     }\n \n-    fn visit_expr(&mut self, e: @ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         match e.node {\n             ast::ExprUnary(_, ast::UnNeg, expr) => {\n                 // propagate negation, if the negation itself isn't negated\n@@ -1365,14 +1365,14 @@ impl<'a> Visitor<()> for Context<'a> {\n         visit::walk_expr(self, e, ());\n     }\n \n-    fn visit_stmt(&mut self, s: @ast::Stmt, _: ()) {\n+    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n         check_path_statement(self, s);\n \n         visit::walk_stmt(self, s, ());\n     }\n \n     fn visit_fn(&mut self, fk: &visit::fn_kind, decl: &ast::fn_decl,\n-                body: ast::P<ast::Block>, span: Span, id: ast::NodeId, _: ()) {\n+                body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n         let recurse = |this: &mut Context| {\n             visit::walk_fn(this, fk, decl, body, span, id, ());\n         };\n@@ -1404,7 +1404,7 @@ impl<'a> Visitor<()> for Context<'a> {\n     }\n \n     fn visit_struct_def(&mut self,\n-                        s: @ast::struct_def,\n+                        s: &ast::struct_def,\n                         i: ast::Ident,\n                         g: &ast::Generics,\n                         id: ast::NodeId,"}, {"sha": "3f82974c8aa0bc3ff9ab417778dc76abc11e8aae", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -164,12 +164,12 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n struct LivenessVisitor;\n \n impl Visitor<@IrMaps> for LivenessVisitor {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, e:@IrMaps) {\n+    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block, s: Span, n: NodeId, e: @IrMaps) {\n         visit_fn(self, fk, fd, b, s, n, e);\n     }\n-    fn visit_local(&mut self, l:@Local, e:@IrMaps) { visit_local(self, l, e); }\n-    fn visit_expr(&mut self, ex:@Expr, e:@IrMaps) { visit_expr(self, ex, e); }\n-    fn visit_arm(&mut self, a:&Arm, e:@IrMaps) { visit_arm(self, a, e); }\n+    fn visit_local(&mut self, l: &Local, e: @IrMaps) { visit_local(self, l, e); }\n+    fn visit_expr(&mut self, ex: &Expr, e: @IrMaps) { visit_expr(self, ex, e); }\n+    fn visit_arm(&mut self, a: &Arm, e: @IrMaps) { visit_arm(self, a, e); }\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n@@ -364,24 +364,24 @@ impl IrMaps {\n }\n \n impl Visitor<()> for Liveness {\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, _:()) {\n+    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l:@Local, _:()) {\n+    fn visit_local(&mut self, l: &Local, _: ()) {\n         check_local(self, l);\n     }\n-    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a:&Arm, _:()) {\n+    fn visit_arm(&mut self, a: &Arm, _: ()) {\n         check_arm(self, a);\n     }\n }\n \n fn visit_fn(v: &mut LivenessVisitor,\n             fk: &visit::fn_kind,\n             decl: &fn_decl,\n-            body: P<Block>,\n+            body: &Block,\n             sp: Span,\n             id: NodeId,\n             this: @IrMaps) {\n@@ -443,7 +443,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @IrMaps) {\n+fn visit_local(v: &mut LivenessVisitor, local: &Local, this: @IrMaps) {\n     let def_map = this.tcx.def_map;\n     pat_util::pat_bindings(def_map, local.pat, |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n@@ -490,7 +490,7 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @IrMaps) {\n     visit::walk_arm(v, arm, this);\n }\n \n-fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @IrMaps) {\n+fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) | ExprSelf => {\n@@ -1472,7 +1472,7 @@ impl Liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(this: &mut Liveness, local: @Local) {\n+fn check_local(this: &mut Liveness, local: &Local) {\n     match local.init {\n       Some(_) => {\n         this.warn_about_unused_or_dead_vars_in_pat(local.pat);\n@@ -1508,7 +1508,7 @@ fn check_arm(this: &mut Liveness, arm: &Arm) {\n     visit::walk_arm(this, arm, ());\n }\n \n-fn check_expr(this: &mut Liveness, expr: @Expr) {\n+fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n       ExprAssign(l, r) => {\n         this.check_lvalue(l);"}, {"sha": "645c2e79a56e7769e2dd075b283dd8f73b9ca2a1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -216,7 +216,7 @@ pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n \n pub fn cat_expr(tcx: ty::ctxt,\n                 method_map: typeck::method_map,\n-                expr: @ast::Expr)\n+                expr: &ast::Expr)\n              -> cmt {\n     let mcx = &mem_categorization_ctxt {\n         tcx: tcx, method_map: method_map\n@@ -226,7 +226,7 @@ pub fn cat_expr(tcx: ty::ctxt,\n \n pub fn cat_expr_unadjusted(tcx: ty::ctxt,\n                            method_map: typeck::method_map,\n-                           expr: @ast::Expr)\n+                           expr: &ast::Expr)\n                         -> cmt {\n     let mcx = &mem_categorization_ctxt {\n         tcx: tcx, method_map: method_map\n@@ -237,7 +237,7 @@ pub fn cat_expr_unadjusted(tcx: ty::ctxt,\n pub fn cat_expr_autoderefd(\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    expr: @ast::Expr,\n+    expr: &ast::Expr,\n     autoderefs: uint) -> cmt\n {\n     let mcx = &mem_categorization_ctxt {\n@@ -265,12 +265,12 @@ pub trait ast_node {\n     fn span(&self) -> Span;\n }\n \n-impl ast_node for @ast::Expr {\n+impl ast_node for ast::Expr {\n     fn id(&self) -> ast::NodeId { self.id }\n     fn span(&self) -> Span { self.span }\n }\n \n-impl ast_node for @ast::Pat {\n+impl ast_node for ast::Pat {\n     fn id(&self) -> ast::NodeId { self.id }\n     fn span(&self) -> Span { self.span }\n }\n@@ -325,15 +325,15 @@ impl MutabilityCategory {\n }\n \n impl mem_categorization_ctxt {\n-    pub fn expr_ty(&self, expr: @ast::Expr) -> ty::t {\n+    pub fn expr_ty(&self, expr: &ast::Expr) -> ty::t {\n         ty::expr_ty(self.tcx, expr)\n     }\n \n-    pub fn pat_ty(&self, pat: @ast::Pat) -> ty::t {\n+    pub fn pat_ty(&self, pat: &ast::Pat) -> ty::t {\n         ty::node_id_to_type(self.tcx, pat.id)\n     }\n \n-    pub fn cat_expr(&self, expr: @ast::Expr) -> cmt {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> cmt {\n         let adjustments = self.tcx.adjustments.borrow();\n         match adjustments.get().find(&expr.id) {\n             None => {\n@@ -375,7 +375,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_expr_autoderefd(&self, expr: @ast::Expr, autoderefs: uint)\n+    pub fn cat_expr_autoderefd(&self, expr: &ast::Expr, autoderefs: uint)\n                                -> cmt {\n         let mut cmt = self.cat_expr_unadjusted(expr);\n         for deref in range(1u, autoderefs + 1) {\n@@ -384,7 +384,7 @@ impl mem_categorization_ctxt {\n         return cmt;\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: @ast::Expr) -> cmt {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> cmt {\n         debug!(\"cat_expr: id={} expr={}\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -577,7 +577,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_rvalue_node<N:ast_node>(&self,\n-                                       node: N,\n+                                       node: &N,\n                                        expr_ty: ty::t) -> cmt {\n         self.cat_rvalue(node.id(),\n                         node.span(),\n@@ -614,7 +614,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_field<N:ast_node>(&self,\n-                                 node: N,\n+                                 node: &N,\n                                  base_cmt: cmt,\n                                  f_name: ast::Ident,\n                                  f_ty: ty::t)\n@@ -629,7 +629,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_deref_fn_or_obj<N:ast_node>(&self,\n-                                           node: N,\n+                                           node: &N,\n                                            base_cmt: cmt,\n                                            deref_cnt: uint)\n                                            -> cmt {\n@@ -644,7 +644,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_deref<N:ast_node>(&self,\n-                                 node: N,\n+                                 node: &N,\n                                  base_cmt: cmt,\n                                  deref_cnt: uint)\n                                  -> cmt {\n@@ -662,7 +662,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_deref_common<N:ast_node>(&self,\n-                                        node: N,\n+                                        node: &N,\n                                         base_cmt: cmt,\n                                         deref_cnt: uint,\n                                         deref_ty: ty::t)\n@@ -706,7 +706,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n-                                 elt: N,\n+                                 elt: &N,\n                                  base_cmt: cmt,\n                                  derefs: uint)\n                                  -> cmt {\n@@ -786,7 +786,7 @@ impl mem_categorization_ctxt {\n           }\n         };\n \n-        fn interior<N: ast_node>(elt: N,\n+        fn interior<N: ast_node>(elt: &N,\n                                  of_cmt: cmt,\n                                  vec_ty: ty::t,\n                                  mutbl: MutabilityCategory,\n@@ -803,7 +803,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_imm_interior<N:ast_node>(&self,\n-                                        node: N,\n+                                        node: &N,\n                                         base_cmt: cmt,\n                                         interior_ty: ty::t,\n                                         interior: InteriorKind)\n@@ -818,7 +818,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn cat_downcast<N:ast_node>(&self,\n-                                    node: N,\n+                                    node: &N,\n                                     base_cmt: cmt,\n                                     downcast_ty: ty::t)\n                                     -> cmt {\n@@ -833,8 +833,8 @@ impl mem_categorization_ctxt {\n \n     pub fn cat_pattern(&self,\n                        cmt: cmt,\n-                       pat: @ast::Pat,\n-                       op: |cmt, @ast::Pat|) {\n+                       pat: &ast::Pat,\n+                       op: |cmt, &ast::Pat|) {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //"}, {"sha": "007a26b40ce01cf9cd0dbe480430c65a4435f8ac", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -193,14 +193,14 @@ enum UseMode {\n }\n \n impl visit::Visitor<()> for VisitContext {\n-    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&fn_decl,\n-                b:P<Block>, s:Span, n:NodeId, _:()) {\n+    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &fn_decl,\n+                b: &Block, s: Span, n: NodeId, _: ()) {\n         compute_modes_for_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_expr(&mut self, ex:@Expr, _:()) {\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         compute_modes_for_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l:@Local, _:()) {\n+    fn visit_local(&mut self, l: &Local, _: ()) {\n         compute_modes_for_local(self, l);\n     }\n     // FIXME(#10894) should continue recursing\n@@ -240,7 +240,7 @@ pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n // Expressions\n \n fn compute_modes_for_local<'a>(cx: &mut VisitContext,\n-                               local: @Local) {\n+                               local: &Local) {\n     cx.use_pat(local.pat);\n     for &init in local.init.iter() {\n         cx.use_expr(init, Read);\n@@ -250,7 +250,7 @@ fn compute_modes_for_local<'a>(cx: &mut VisitContext,\n fn compute_modes_for_fn(cx: &mut VisitContext,\n                         fk: &visit::fn_kind,\n                         decl: &fn_decl,\n-                        body: P<Block>,\n+                        body: &Block,\n                         span: Span,\n                         id: NodeId) {\n     for a in decl.inputs.iter() {\n@@ -260,7 +260,7 @@ fn compute_modes_for_fn(cx: &mut VisitContext,\n }\n \n fn compute_modes_for_expr(cx: &mut VisitContext,\n-                          expr: @Expr)\n+                          expr: &Expr)\n {\n     cx.consume_expr(expr);\n }\n@@ -272,7 +272,7 @@ impl VisitContext {\n         }\n     }\n \n-    pub fn consume_expr(&mut self, expr: @Expr) {\n+    pub fn consume_expr(&mut self, expr: &Expr) {\n         /*!\n          * Indicates that the value of `expr` will be consumed,\n          * meaning either copied or moved depending on its type.\n@@ -311,7 +311,7 @@ impl VisitContext {\n     }\n \n     pub fn use_expr(&mut self,\n-                    expr: @Expr,\n+                    expr: &Expr,\n                     expr_mode: UseMode) {\n         /*!\n          * Indicates that `expr` is used with a given mode.  This will"}, {"sha": "5e095061b42edc7bb871612da2939f751dd57778", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -45,7 +45,7 @@ struct ParentVisitor {\n }\n \n impl Visitor<()> for ParentVisitor {\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         self.parents.insert(item.id, self.curparent);\n \n         let prev = self.curparent;\n@@ -90,13 +90,13 @@ impl Visitor<()> for ParentVisitor {\n         self.curparent = prev;\n     }\n \n-    fn visit_foreign_item(&mut self, a: @ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, a: &ast::foreign_item, _: ()) {\n         self.parents.insert(a.id, self.curparent);\n         visit::walk_foreign_item(self, a, ());\n     }\n \n     fn visit_fn(&mut self, a: &visit::fn_kind, b: &ast::fn_decl,\n-                c: ast::P<ast::Block>, d: Span, id: ast::NodeId, _: ()) {\n+                c: &ast::Block, d: Span, id: ast::NodeId, _: ()) {\n         // We already took care of some trait methods above, otherwise things\n         // like impl methods and pub trait methods are parented to the\n         // containing module, not the containing trait.\n@@ -106,7 +106,7 @@ impl Visitor<()> for ParentVisitor {\n         visit::walk_fn(self, a, b, c, d, id, ());\n     }\n \n-    fn visit_struct_def(&mut self, s: @ast::struct_def, i: ast::Ident,\n+    fn visit_struct_def(&mut self, s: &ast::struct_def, i: ast::Ident,\n                         g: &ast::Generics, n: ast::NodeId, _: ()) {\n         // Struct constructors are parented to their struct definitions because\n         // they essentially are the struct definitions.\n@@ -185,7 +185,7 @@ impl<'a> EmbargoVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         let orig_all_pub = self.prev_exported;\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n@@ -307,7 +307,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n         self.prev_exported = orig_all_pub;\n     }\n \n-    fn visit_foreign_item(&mut self, a: @ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, a: &ast::foreign_item, _: ()) {\n         if self.prev_exported && a.vis == ast::public {\n             self.exported_items.insert(a.id);\n         }\n@@ -620,7 +620,7 @@ impl<'a> PrivacyVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         // Do not check privacy inside items with the resolve_unexported\n         // attribute. This is used for the test runner.\n         if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n@@ -632,7 +632,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n         self.curitem = orig_curitem;\n     }\n \n-    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n             ast::ExprField(base, ident, _) => {\n                 // Method calls are now a special syntactic form,\n@@ -778,7 +778,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n         visit::walk_pat(self, pattern, ());\n     }\n \n-    fn visit_foreign_item(&mut self, fi: @ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, fi: &ast::foreign_item, _: ()) {\n         self.in_foreign = true;\n         visit::walk_foreign_item(self, fi, ());\n         self.in_foreign = false;\n@@ -800,7 +800,7 @@ struct SanePrivacyVisitor {\n }\n \n impl Visitor<()> for SanePrivacyVisitor {\n-    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         if self.in_fn {\n             self.check_all_inherited(item);\n         } else {\n@@ -816,7 +816,7 @@ impl Visitor<()> for SanePrivacyVisitor {\n     }\n \n     fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n-                b: ast::P<ast::Block>, s: Span, n: ast::NodeId, _: ()) {\n+                b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n         // This catches both functions and methods\n         let orig_in_fn = util::replace(&mut self.in_fn, true);\n         visit::walk_fn(self, fk, fd, b, s, n, ());\n@@ -829,7 +829,7 @@ impl SanePrivacyVisitor {\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n     /// later on down the road...\n-    fn check_sane_privacy(&self, item: @ast::item) {\n+    fn check_sane_privacy(&self, item: &ast::item) {\n         let tcx = self.tcx;\n         let check_inherited = |sp: Span, vis: ast::visibility, note: &str| {\n             if vis != ast::inherited {\n@@ -941,7 +941,7 @@ impl SanePrivacyVisitor {\n \n     /// When inside of something like a function or a method, visibility has no\n     /// control over anything so this forbids any mention of any visibility\n-    fn check_all_inherited(&self, item: @ast::item) {\n+    fn check_all_inherited(&self, item: &ast::item) {\n         let tcx = self.tcx;\n         let check_inherited = |sp: Span, vis: ast::visibility| {\n             if vis != ast::inherited {"}, {"sha": "3165527b3263b1d10fc4a898d20cc17d2f817ef5", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -44,7 +44,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: @ast::item) -> bool {\n+fn item_might_be_inlined(item: &ast::item) -> bool {\n     if attributes_specify_inlining(item.attrs) {\n         return true\n     }\n@@ -105,7 +105,7 @@ struct MarkSymbolVisitor {\n \n impl Visitor<()> for MarkSymbolVisitor {\n \n-    fn visit_expr(&mut self, expr:@ast::Expr, _:()) {\n+    fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n \n         match expr.node {\n             ast::ExprPath(_) => {\n@@ -187,7 +187,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n         visit::walk_expr(self, expr, ())\n     }\n \n-    fn visit_item(&mut self, _item: @ast::item, _: ()) {\n+    fn visit_item(&mut self, _item: &ast::item, _: ()) {\n         // Do not recurse into items. These items will be added to the worklist\n         // and recursed into manually if necessary.\n     }"}, {"sha": "05d9ee42afa6e7bf5cb71a6d5d30bc1687919d94", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -30,7 +30,7 @@ use std::hashmap::{HashMap, HashSet};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{P,Block,item,fn_decl,NodeId,Arm,Pat,Stmt,Expr,Local};\n+use syntax::ast::{Block,item,fn_decl,NodeId,Arm,Pat,Stmt,Expr,Local};\n \n /**\n The region maps encode information about region relationships.\n@@ -69,7 +69,7 @@ struct RegionResolutionVisitor {\n     sess: Session,\n \n     // Generated maps:\n-    region_maps: @RegionMaps,\n+    region_maps: RegionMaps,\n }\n \n \n@@ -333,7 +333,7 @@ fn parent_to_expr(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_block(visitor: &mut RegionResolutionVisitor,\n-                 blk: ast::P<ast::Block>,\n+                 blk: &ast::Block,\n                  cx: Context) {\n     // Record the parent of this block.\n     parent_to_expr(visitor, cx, blk.id, blk.span);\n@@ -359,7 +359,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n-                stmt: @ast::Stmt,\n+                stmt: &ast::Stmt,\n                 cx: Context) {\n     match stmt.node {\n         ast::StmtDecl(..) => {\n@@ -376,7 +376,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n-                expr: @ast::Expr,\n+                expr: &ast::Expr,\n                 cx: Context) {\n     parent_to_expr(visitor, cx, expr.id, expr.span);\n \n@@ -417,15 +417,15 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_local(visitor: &mut RegionResolutionVisitor,\n-                 local: @ast::Local,\n+                 local: &ast::Local,\n                  cx: Context) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(visitor, cx, local.id, local.span);\n     visit::walk_local(visitor, local, cx);\n }\n \n fn resolve_item(visitor: &mut RegionResolutionVisitor,\n-                item: @ast::item,\n+                item: &ast::item,\n                 cx: Context) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx = Context {var_parent: None, parent: None, ..cx};\n@@ -435,7 +435,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor,\n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               fk: &visit::fn_kind,\n               decl: &ast::fn_decl,\n-              body: ast::P<ast::Block>,\n+              body: &ast::Block,\n               sp: Span,\n               id: ast::NodeId,\n               cx: Context) {\n@@ -476,47 +476,46 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n \n impl Visitor<Context> for RegionResolutionVisitor {\n \n-    fn visit_block(&mut self, b:P<Block>, cx:Context) {\n+    fn visit_block(&mut self, b: &Block, cx: Context) {\n         resolve_block(self, b, cx);\n     }\n \n-    fn visit_item(&mut self, i:@item, cx:Context) {\n+    fn visit_item(&mut self, i: &item, cx: Context) {\n         resolve_item(self, i, cx);\n     }\n \n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, cx:Context) {\n+    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl,\n+                b: &Block, s: Span, n: NodeId, cx: Context) {\n         resolve_fn(self, fk, fd, b, s, n, cx);\n     }\n-    fn visit_arm(&mut self, a:&Arm, cx:Context) {\n+    fn visit_arm(&mut self, a: &Arm, cx: Context) {\n         resolve_arm(self, a, cx);\n     }\n-    fn visit_pat(&mut self, p:&Pat, cx:Context) {\n+    fn visit_pat(&mut self, p: &Pat, cx: Context) {\n         resolve_pat(self, p, cx);\n     }\n-    fn visit_stmt(&mut self, s:@Stmt, cx:Context) {\n+    fn visit_stmt(&mut self, s: &Stmt, cx: Context) {\n         resolve_stmt(self, s, cx);\n     }\n-    fn visit_expr(&mut self, ex:@Expr, cx:Context) {\n+    fn visit_expr(&mut self, ex: &Expr, cx: Context) {\n         resolve_expr(self, ex, cx);\n     }\n-    fn visit_local(&mut self, l:@Local, cx:Context) {\n+    fn visit_local(&mut self, l: &Local, cx: Context) {\n         resolve_local(self, l, cx);\n     }\n }\n \n-pub fn resolve_crate(sess: Session, crate: &ast::Crate) -> @RegionMaps {\n-    let region_maps = @RegionMaps {\n-        scope_map: RefCell::new(HashMap::new()),\n-        free_region_map: RefCell::new(HashMap::new()),\n-        cleanup_scopes: RefCell::new(HashSet::new()),\n-    };\n-    let cx = Context {parent: None,\n-                      var_parent: None};\n+pub fn resolve_crate(sess: Session, crate: &ast::Crate) -> RegionMaps {\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n-        region_maps: region_maps,\n+        region_maps: RegionMaps {\n+            scope_map: RefCell::new(HashMap::new()),\n+            free_region_map: RefCell::new(HashMap::new()),\n+            cleanup_scopes: RefCell::new(HashSet::new())\n+        }\n     };\n+    let cx = Context { parent: None, var_parent: None };\n     visit::walk_crate(&mut visitor, crate, cx);\n-    return region_maps;\n+    return visitor.region_maps;\n }\n "}, {"sha": "fb0bdfe963e0f4d0b3ab0d3caec087b96e89b383", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -137,22 +137,22 @@ enum SelfBinding {\n }\n \n impl Visitor<()> for Resolver {\n-    fn visit_item(&mut self, item:@item, _:()) {\n+    fn visit_item(&mut self, item: &item, _: ()) {\n         self.resolve_item(item);\n     }\n-    fn visit_arm(&mut self, arm:&Arm, _:()) {\n+    fn visit_arm(&mut self, arm: &Arm, _: ()) {\n         self.resolve_arm(arm);\n     }\n-    fn visit_block(&mut self, block:P<Block>, _:()) {\n+    fn visit_block(&mut self, block: &Block, _: ()) {\n         self.resolve_block(block);\n     }\n-    fn visit_expr(&mut self, expr:@Expr, _:()) {\n+    fn visit_expr(&mut self, expr: &Expr, _: ()) {\n         self.resolve_expr(expr);\n     }\n-    fn visit_local(&mut self, local:@Local, _:()) {\n+    fn visit_local(&mut self, local: &Local, _: ()) {\n         self.resolve_local(local);\n     }\n-    fn visit_ty(&mut self, ty:&Ty, _:()) {\n+    fn visit_ty(&mut self, ty: &Ty, _: ()) {\n         self.resolve_type(ty);\n     }\n }\n@@ -898,13 +898,13 @@ struct BuildReducedGraphVisitor<'a> {\n \n impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n \n-    fn visit_item(&mut self, item:@item, context:ReducedGraphParent) {\n+    fn visit_item(&mut self, item: &item, context: ReducedGraphParent) {\n         let p = self.resolver.build_reduced_graph_for_item(item, context);\n         visit::walk_item(self, item, p);\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: @foreign_item,\n-                          context:ReducedGraphParent) {\n+    fn visit_foreign_item(&mut self, foreign_item: &foreign_item,\n+                          context: ReducedGraphParent) {\n         self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n                                                            context,\n                                                            |r, c| {\n@@ -913,11 +913,11 @@ impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, view_item:&view_item, context:ReducedGraphParent) {\n+    fn visit_view_item(&mut self, view_item: &view_item, context: ReducedGraphParent) {\n         self.resolver.build_reduced_graph_for_view_item(view_item, context);\n     }\n \n-    fn visit_block(&mut self, block:P<Block>, context:ReducedGraphParent) {\n+    fn visit_block(&mut self, block: &Block, context: ReducedGraphParent) {\n         let np = self.resolver.build_reduced_graph_for_block(block, context);\n         visit::walk_block(self, block, np);\n     }\n@@ -927,7 +927,7 @@ impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n struct UnusedImportCheckVisitor<'a> { resolver: &'a Resolver }\n \n impl<'a> Visitor<()> for UnusedImportCheckVisitor<'a> {\n-    fn visit_view_item(&mut self, vi:&view_item, _:()) {\n+    fn visit_view_item(&mut self, vi: &view_item, _: ()) {\n         self.resolver.check_for_item_unused_imports(vi);\n         visit::walk_view_item(self, vi, ());\n     }\n@@ -1141,7 +1141,7 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self,\n-                                        item: @item,\n+                                        item: &item,\n                                         parent: ReducedGraphParent)\n                                             -> ReducedGraphParent\n     {\n@@ -1550,7 +1550,7 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n-                                            foreign_item: @foreign_item,\n+                                            foreign_item: &foreign_item,\n                                             parent: ReducedGraphParent,\n                                             f: |&mut Resolver,\n                                                 ReducedGraphParent|) {\n@@ -3633,7 +3633,7 @@ impl Resolver {\n         visit::walk_crate(self, crate, ());\n     }\n \n-    fn resolve_item(&mut self, item: @item) {\n+    fn resolve_item(&mut self, item: &item) {\n         debug!(\"(resolving item) resolving {}\",\n                self.session.str_of(item.ident));\n \n@@ -4170,7 +4170,7 @@ impl Resolver {\n         visit::walk_mod(self, module_, ());\n     }\n \n-    fn resolve_local(&mut self, local: @Local) {\n+    fn resolve_local(&mut self, local: &Local) {\n         // Resolve the type.\n         self.resolve_type(local.ty);\n \n@@ -4268,7 +4268,7 @@ impl Resolver {\n         value_ribs.get().pop();\n     }\n \n-    fn resolve_block(&mut self, block: P<Block>) {\n+    fn resolve_block(&mut self, block: &Block) {\n         debug!(\"(resolving block) entering block\");\n         {\n             let mut value_ribs = self.value_ribs.borrow_mut();\n@@ -5152,7 +5152,7 @@ impl Resolver {\n         }\n     }\n \n-    fn resolve_expr(&mut self, expr: @Expr) {\n+    fn resolve_expr(&mut self, expr: &Expr) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -5324,8 +5324,7 @@ impl Resolver {\n         }\n     }\n \n-    fn record_candidate_traits_for_expr_if_necessary(&mut self,\n-                                                         expr: @Expr) {\n+    fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n         match expr.node {\n             ExprField(_, ident, _) => {\n                 // FIXME(#6890): Even though you can't treat a method like a"}, {"sha": "929661122abc05784b39fad3b525bd131546f8c1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -57,7 +57,7 @@ pub fn crate(sess: session::Session, crate: &ast::Crate)\n \n impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n     fn visit_item(&mut self,\n-                  item: @ast::item,\n+                  item: &ast::item,\n                   _: &'a ScopeChain<'a>) {\n         let scope = match item.node {\n             ast::item_fn(..) | // fn lifetimes get added in visit_fn below\n@@ -84,7 +84,7 @@ impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n     fn visit_fn(&mut self,\n                 fk: &visit::fn_kind,\n                 fd: &ast::fn_decl,\n-                b: ast::P<ast::Block>,\n+                b: &ast::Block,\n                 s: Span,\n                 n: ast::NodeId,\n                 scope: &'a ScopeChain<'a>) {\n@@ -132,7 +132,7 @@ impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n     }\n \n     fn visit_block(&mut self,\n-                   b: ast::P<ast::Block>,\n+                   b: &ast::Block,\n                    scope: &'a ScopeChain<'a>) {\n         let scope1 = BlockScope(b.id, scope);\n         debug!(\"pushing block scope {}\", b.id);"}, {"sha": "53abbba2e897e80ac97b5bfd9d643384ff60acb0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -2203,7 +2203,7 @@ pub struct TransItemVisitor {\n }\n \n impl Visitor<()> for TransItemVisitor {\n-    fn visit_item(&mut self, i: @ast::item, _:()) {\n+    fn visit_item(&mut self, i: &ast::item, _:()) {\n         trans_item(self.ccx, i);\n     }\n }"}, {"sha": "2deff5bc5eeb996b84c41be4718069f2d99fe732", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -331,7 +331,7 @@ pub fn create_captured_var_metadata(bcx: @Block,\n         None => {\n             cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n         }\n-        Some(ast_map::node_local(ident)) => ident,\n+        Some(ast_map::node_local(ident, _)) => ident,\n         Some(ast_map::node_arg(@ast::Pat { node: ast::PatIdent(_, ref path, _), .. })) => {\n             ast_util::path_to_ident(path)\n         }"}, {"sha": "5ab48a143ab755ced2f8a927c744f0927bee3a7f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -276,7 +276,7 @@ struct ctxt_ {\n \n     named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n \n-    region_maps: @middle::region::RegionMaps,\n+    region_maps: middle::region::RegionMaps,\n \n     // Stores the types for various nodes in the AST.  Note that this table\n     // is not guaranteed to be populated until after typeck.  See\n@@ -966,7 +966,7 @@ pub fn mk_ctxt(s: session::Session,\n                named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n                amap: ast_map::map,\n                freevars: freevars::freevar_map,\n-               region_maps: @middle::region::RegionMaps,\n+               region_maps: middle::region::RegionMaps,\n                lang_items: middle::lang_items::LanguageItems)\n             -> ctxt {\n     @ctxt_ {"}, {"sha": "1cb2a32741ee98b25302eeebe7b5824a0725f8f1", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -26,8 +26,8 @@ use syntax::codemap::Span;\n use syntax::print::pprust;\n \n pub fn check_match(fcx: @FnCtxt,\n-                   expr: @ast::Expr,\n-                   discrim: @ast::Expr,\n+                   expr: &ast::Expr,\n+                   discrim: &ast::Expr,\n                    arms: &[ast::Arm]) {\n     let tcx = fcx.ccx.tcx;\n \n@@ -106,7 +106,7 @@ pub struct pat_ctxt {\n     map: PatIdMap,\n }\n \n-pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::Pat, path: &ast::Path,\n+pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n                          subpats: &Option<~[@ast::Pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n@@ -418,7 +418,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n+pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -662,7 +662,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n // Helper function to check @, ~ and & patterns\n pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          pointer_kind: PointerKind,\n-                         inner: @ast::Pat,\n+                         inner: &ast::Pat,\n                          pat_id: ast::NodeId,\n                          span: Span,\n                          expected: ty::t) {"}, {"sha": "cf316ed284d933cd87cdc0d269f372d58b376c7f", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -56,7 +56,7 @@ pub fn eqtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: @FnCtxt, sp: Span, expected: ty::t, expr: @ast::Expr) {\n+pub fn coerce(fcx: @FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "3bd1f45a07191cf262668146d5a277cca62dcebe", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -122,8 +122,8 @@ pub fn lookup(\n         fcx: @FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: @ast::Expr,                   // The expression `a.b(...)`.\n-        self_expr: @ast::Expr,              // The expression `a`.\n+        expr: &ast::Expr,                   // The expression `a.b(...)`.\n+        self_expr: &ast::Expr,              // The expression `a`.\n         callee_id: NodeId,                  /* Where to store `a.b`'s type,\n                                              * also the scope of the call */\n         m_name: ast::Name,                  // The name `b`.\n@@ -170,8 +170,8 @@ pub fn lookup(\n \n pub struct LookupContext<'a> {\n     fcx: @FnCtxt,\n-    expr: @ast::Expr,\n-    self_expr: @ast::Expr,\n+    expr: &'a ast::Expr,\n+    self_expr: &'a ast::Expr,\n     callee_id: NodeId,\n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],"}, {"sha": "4ebf41b3d4dc13b722652e75eb0946901d51ef20", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -305,7 +305,7 @@ impl ExprTyProvider for FnCtxt {\n struct CheckItemTypesVisitor { ccx: @CrateCtxt }\n \n impl Visitor<()> for CheckItemTypesVisitor {\n-    fn visit_item(&mut self, i:@ast::item, _:()) {\n+    fn visit_item(&mut self, i: &ast::item, _: ()) {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n@@ -318,7 +318,7 @@ pub fn check_item_types(ccx: @CrateCtxt, crate: &ast::Crate) {\n \n pub fn check_bare_fn(ccx: @CrateCtxt,\n                      decl: &ast::fn_decl,\n-                     body: ast::P<ast::Block>,\n+                     body: &ast::Block,\n                      id: ast::NodeId,\n                      self_info: Option<SelfInfo>,\n                      fty: ty::t,\n@@ -365,7 +365,7 @@ impl GatherLocalsVisitor {\n \n impl Visitor<()> for GatherLocalsVisitor {\n         // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local:@ast::Local, _:()) {\n+    fn visit_local(&mut self, local: &ast::Local, _: ()) {\n             let o_ty = match local.ty.node {\n               ast::ty_infer => None,\n               _ => Some(self.fcx.to_ty(local.ty))\n@@ -382,7 +382,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n     }\n         // Add pattern bindings.\n-    fn visit_pat(&mut self, p:&ast::Pat, _:()) {\n+    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n             match p.node {\n               ast::PatIdent(_, ref path, _)\n                   if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n@@ -401,17 +401,17 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n     }\n \n-    fn visit_block(&mut self, b:ast::P<ast::Block>, _:()) {\n+    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n         // non-obvious: the `blk` variable maps to region lb, so\n         // we have to keep this up-to-date.  This\n         // is... unfortunate.  It'd be nice to not need this.\n         self.fcx.with_region_lb(b.id, || visit::walk_block(self, b, ()));\n     }\n \n-        // Don't descend into fns and items\n-    fn visit_fn(&mut self, _:&visit::fn_kind, _:&ast::fn_decl,\n-                _:ast::P<ast::Block>, _:Span, _:ast::NodeId, _:()) { }\n-    fn visit_item(&mut self, _:@ast::item, _:()) { }\n+    // Don't descend into fns and items\n+    fn visit_fn(&mut self, _: &visit::fn_kind, _: &ast::fn_decl,\n+                _: &ast::Block, _: Span, _: ast::NodeId, _: ()) { }\n+    fn visit_item(&mut self, _: &ast::item, _: ()) { }\n \n }\n \n@@ -421,7 +421,7 @@ pub fn check_fn(ccx: @CrateCtxt,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n                 id: ast::NodeId,\n-                body: ast::P<ast::Block>,\n+                body: &ast::Block,\n                 fn_kind: FnKind,\n                 inherited: @Inherited) -> @FnCtxt\n {\n@@ -507,7 +507,7 @@ pub fn check_fn(ccx: @CrateCtxt,\n \n     fn gather_locals(fcx: @FnCtxt,\n                      decl: &ast::fn_decl,\n-                     body: ast::P<ast::Block>,\n+                     body: &ast::Block,\n                      arg_tys: &[ty::t],\n                      opt_self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n@@ -576,7 +576,7 @@ pub fn check_struct(ccx: @CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item(ccx: @CrateCtxt, it: @ast::item) {\n+pub fn check_item(ccx: @CrateCtxt, it: &ast::item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n@@ -682,7 +682,7 @@ pub fn check_item(ccx: @CrateCtxt, it: @ast::item) {\n fn check_method_body(ccx: @CrateCtxt,\n                      item_generics: &ty::Generics,\n                      self_bound: Option<@ty::TraitRef>,\n-                     method: @ast::method) {\n+                     method: &ast::method) {\n     /*!\n      * Type checks a method body.\n      *\n@@ -1166,7 +1166,7 @@ impl FnCtxt {\n         ast_ty_to_ty(self, &self.infcx(), ast_t)\n     }\n \n-    pub fn pat_to_str(&self, pat: @ast::Pat) -> ~str {\n+    pub fn pat_to_str(&self, pat: &ast::Pat) -> ~str {\n         pat.repr(self.tcx())\n     }\n \n@@ -1236,13 +1236,13 @@ impl FnCtxt {\n     }\n \n     pub fn mk_assignty(&self,\n-                       expr: @ast::Expr,\n+                       expr: &ast::Expr,\n                        sub: ty::t,\n                        sup: ty::t)\n                        -> Result<(), ty::type_err> {\n         match infer::mk_coercety(self.infcx(),\n                                  false,\n-                                 infer::ExprAssignable(expr),\n+                                 infer::ExprAssignable(expr.span),\n                                  sub,\n                                  sup) {\n             Ok(None) => result::Ok(()),\n@@ -1378,7 +1378,7 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n }\n \n // AST fragment checking\n-pub fn check_lit(fcx: @FnCtxt, lit: @ast::lit) -> ty::t {\n+pub fn check_lit(fcx: @FnCtxt, lit: &ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n@@ -1407,8 +1407,8 @@ pub fn check_lit(fcx: @FnCtxt, lit: @ast::lit) -> ty::t {\n }\n \n pub fn valid_range_bounds(ccx: @CrateCtxt,\n-                          from: @ast::Expr,\n-                          to: @ast::Expr)\n+                          from: &ast::Expr,\n+                          to: &ast::Expr)\n                        -> Option<bool> {\n     match const_eval::compare_lit_exprs(ccx.tcx, from, to) {\n         Some(val) => Some(val <= 0),\n@@ -1417,34 +1417,34 @@ pub fn valid_range_bounds(ccx: @CrateCtxt,\n }\n \n pub fn check_expr_has_type(\n-    fcx: @FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: &ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     });\n }\n \n pub fn check_expr_coercable_to_type(\n-    fcx: @FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: &ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::coerce(fcx, expr.span, expected, expr)\n     });\n }\n \n pub fn check_expr_with_hint(\n-    fcx: @FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: &ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), || ())\n }\n \n pub fn check_expr_with_opt_hint(\n-    fcx: @FnCtxt, expr: @ast::Expr,\n+    fcx: @FnCtxt, expr: &ast::Expr,\n     expected: Option<ty::t>)  {\n     check_expr_with_unifier(fcx, expr, expected, || ())\n }\n \n-pub fn check_expr(fcx: @FnCtxt, expr: @ast::Expr)  {\n+pub fn check_expr(fcx: @FnCtxt, expr: &ast::Expr)  {\n     check_expr_with_unifier(fcx, expr, None, || ())\n }\n \n@@ -1651,7 +1651,7 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n /// that there are actually multiple representations for both `ty_err` and\n /// `ty_bot`, so avoid that when err and bot need to be handled differently.\n pub fn check_expr_with_unifier(fcx: @FnCtxt,\n-                               expr: @ast::Expr,\n+                               expr: &ast::Expr,\n                                expected: Option<ty::t>,\n                                unifier: ||) {\n     debug!(\">> typechecking\");\n@@ -1660,7 +1660,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx: @FnCtxt,\n         sp: Span,\n         method_fn_ty: ty::t,\n-        callee_expr: @ast::Expr,\n+        callee_expr: &ast::Expr,\n         args: &[@ast::Expr],\n         sugar: ast::CallSugar,\n         deref_args: DerefArgs) -> ty::t\n@@ -1689,7 +1689,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     fn check_argument_types(fcx: @FnCtxt,\n                             sp: Span,\n                             fn_inputs: &[ty::t],\n-                            callee_expr: @ast::Expr,\n+                            callee_expr: &ast::Expr,\n                             args: &[@ast::Expr],\n                             sugar: ast::CallSugar,\n                             deref_args: DerefArgs,\n@@ -1842,8 +1842,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     // A generic function for checking assignment expressions\n     fn check_assignment(fcx: @FnCtxt,\n-                        lhs: @ast::Expr,\n-                        rhs: @ast::Expr,\n+                        lhs: &ast::Expr,\n+                        rhs: &ast::Expr,\n                         id: ast::NodeId) {\n         check_expr(fcx, lhs);\n         let lhs_type = fcx.expr_ty(lhs);\n@@ -1853,7 +1853,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     fn write_call(fcx: @FnCtxt,\n-                  call_expr: @ast::Expr,\n+                  call_expr: &ast::Expr,\n                   output: ty::t,\n                   sugar: ast::CallSugar) {\n         let ret_ty = match sugar {\n@@ -1875,8 +1875,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @FnCtxt,\n                   callee_id: ast::NodeId,\n-                  call_expr: @ast::Expr,\n-                  f: @ast::Expr,\n+                  call_expr: &ast::Expr,\n+                  f: &ast::Expr,\n                   args: &[@ast::Expr],\n                   sugar: ast::CallSugar) {\n         // Index expressions need to be handled separately, to inform them\n@@ -1937,8 +1937,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     // Checks a method call.\n     fn check_method_call(fcx: @FnCtxt,\n                          callee_id: ast::NodeId,\n-                         expr: @ast::Expr,\n-                         rcvr: @ast::Expr,\n+                         expr: &ast::Expr,\n+                         rcvr: &ast::Expr,\n                          method_name: ast::Ident,\n                          args: &[@ast::Expr],\n                          tps: &[ast::P<ast::Ty>],\n@@ -1997,7 +1997,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: @FnCtxt,\n-                       cond_expr: @ast::Expr,\n+                       cond_expr: &ast::Expr,\n                        then_blk: &ast::Block,\n                        opt_else_expr: Option<@ast::Expr>,\n                        id: ast::NodeId,\n@@ -2037,11 +2037,11 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     fn lookup_op_method(fcx: @FnCtxt,\n                         callee_id: ast::NodeId,\n-                        op_ex: @ast::Expr,\n-                        self_ex: @ast::Expr,\n+                        op_ex: &ast::Expr,\n+                        self_ex: &ast::Expr,\n                         self_t: ty::t,\n                         opname: ast::Name,\n-                        args: ~[@ast::Expr],\n+                        args: &[@ast::Expr],\n                         deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n                         unbound_method: ||,\n@@ -2078,9 +2078,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     // could be either a expr_binop or an expr_assign_binop\n     fn check_binop(fcx: @FnCtxt,\n                    callee_id: ast::NodeId,\n-                   expr: @ast::Expr,\n+                   expr: &ast::Expr,\n                    op: ast::BinOp,\n-                   lhs: @ast::Expr,\n+                   lhs: &ast::Expr,\n                    rhs: @ast::Expr,\n                    // Used only in the error case\n                    expected_result: Option<ty::t>,\n@@ -2166,8 +2166,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     fn check_user_binop(fcx: @FnCtxt,\n                         callee_id: ast::NodeId,\n-                        ex: @ast::Expr,\n-                        lhs_expr: @ast::Expr,\n+                        ex: &ast::Expr,\n+                        lhs_expr: &ast::Expr,\n                         lhs_resolved_t: ty::t,\n                         op: ast::BinOp,\n                         rhs: @ast::Expr,\n@@ -2184,7 +2184,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 };\n                 return lookup_op_method(fcx, callee_id, ex, lhs_expr, lhs_resolved_t,\n                                        token::intern(*name),\n-                                       ~[rhs], DoDerefArgs, DontAutoderefReceiver, if_op_unbound,\n+                                       &[rhs], DoDerefArgs, DontAutoderefReceiver, if_op_unbound,\n                                        expected_result);\n             }\n             None => ()\n@@ -2210,14 +2210,14 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                        callee_id: ast::NodeId,\n                        op_str: &str,\n                        mname: &str,\n-                       ex: @ast::Expr,\n-                       rhs_expr: @ast::Expr,\n+                       ex: &ast::Expr,\n+                       rhs_expr: &ast::Expr,\n                        rhs_t: ty::t,\n                        expected_t: Option<ty::t>)\n                     -> ty::t {\n        lookup_op_method(\n             fcx, callee_id, ex, rhs_expr, rhs_t,\n-            token::intern(mname), ~[],\n+            token::intern(mname), &[],\n             DoDerefArgs, DontAutoderefReceiver,\n             || {\n                 fcx.type_error_message(ex.span, |actual| {\n@@ -2248,7 +2248,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     fn check_expr_fn(fcx: @FnCtxt,\n-                     expr: @ast::Expr,\n+                     expr: &ast::Expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n                      body: ast::P<ast::Block>,\n@@ -2354,8 +2354,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     // Check field access expressions\n     fn check_field(fcx: @FnCtxt,\n-                   expr: @ast::Expr,\n-                   base: @ast::Expr,\n+                   expr: &ast::Expr,\n+                   base: &ast::Expr,\n                    field: ast::Name,\n                    tys: &[ast::P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n@@ -3263,7 +3263,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                                     base,\n                                                     resolved,\n                                                     index_ident.name,\n-                                                    ~[idx],\n+                                                    &[idx],\n                                                     DoDerefArgs,\n                                                     AutoderefReceiver,\n                                                     error_message,\n@@ -3298,13 +3298,13 @@ pub fn require_integral(fcx: @FnCtxt, sp: Span, t: ty::t) {\n \n pub fn check_decl_initializer(fcx: @FnCtxt,\n                               nid: ast::NodeId,\n-                              init: @ast::Expr)\n+                              init: &ast::Expr)\n                             {\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }\n \n-pub fn check_decl_local(fcx: @FnCtxt, local: @ast::Local)  {\n+pub fn check_decl_local(fcx: @FnCtxt, local: &ast::Local)  {\n     let tcx = fcx.ccx.tcx;\n \n     let t = fcx.local_ty(local.span, local.id);\n@@ -3332,7 +3332,7 @@ pub fn check_decl_local(fcx: @FnCtxt, local: @ast::Local)  {\n     }\n }\n \n-pub fn check_stmt(fcx: @FnCtxt, stmt: @ast::Stmt)  {\n+pub fn check_stmt(fcx: @FnCtxt, stmt: &ast::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n@@ -3465,7 +3465,7 @@ pub fn check_block_with_expected(fcx: @FnCtxt,\n \n pub fn check_const(ccx: @CrateCtxt,\n                    sp: Span,\n-                   e: @ast::Expr,\n+                   e: &ast::Expr,\n                    id: ast::NodeId) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n@@ -3478,7 +3478,7 @@ pub fn check_const(ccx: @CrateCtxt,\n \n pub fn check_const_with_ty(fcx: @FnCtxt,\n                            _: Span,\n-                           e: @ast::Expr,\n+                           e: &ast::Expr,\n                            declty: ty::t) {\n     check_expr(fcx, e);\n     let cty = fcx.expr_ty(e);\n@@ -3907,7 +3907,7 @@ pub fn type_is_c_like_enum(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n }\n \n pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n-                                 e: @ast::Expr,\n+                                 e: &ast::Expr,\n                                  v: ast::ExprVstore)\n                               -> ty::vstore {\n     match v {\n@@ -3975,7 +3975,7 @@ pub fn check_bounds_are_used(ccx: @CrateCtxt,\n     }\n }\n \n-pub fn check_intrinsic_type(ccx: @CrateCtxt, it: @ast::foreign_item) {\n+pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::foreign_item) {\n     fn param(ccx: @CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }"}, {"sha": "fb914779cce394ff78c9f46a636ad4f888155724", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -128,7 +128,7 @@ impl Rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(&mut self, expr: @ast::Expr) -> ty::t {\n+    pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n             ty_unadjusted\n@@ -143,7 +143,7 @@ impl Rcx {\n     }\n }\n \n-pub fn regionck_expr(fcx: @FnCtxt, e: @ast::Expr) {\n+pub fn regionck_expr(fcx: @FnCtxt, e: &ast::Expr) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n     let rcx = &mut rcx;\n@@ -154,7 +154,7 @@ pub fn regionck_expr(fcx: @FnCtxt, e: @ast::Expr) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @FnCtxt, blk: ast::P<ast::Block>) {\n+pub fn regionck_fn(fcx: @FnCtxt, blk: &ast::Block) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: blk.id };\n     let rcx = &mut rcx;\n@@ -174,24 +174,24 @@ impl Visitor<()> for Rcx {\n     // hierarchy, and in particular the relationships between free\n     // regions, until regionck, as described in #3238.\n \n-    fn visit_item(&mut self, i:@ast::item, _:()) { visit_item(self, i); }\n+    fn visit_item(&mut self, i: &ast::item, _: ()) { visit_item(self, i); }\n \n-    fn visit_expr(&mut self, ex:@ast::Expr, _:()) { visit_expr(self, ex); }\n+    fn visit_expr(&mut self, ex: &ast::Expr, _: ()) { visit_expr(self, ex); }\n \n-        //visit_pat: visit_pat, // (..) see above\n+    //visit_pat: visit_pat, // (..) see above\n \n-    fn visit_arm(&mut self, a:&ast::Arm, _:()) { visit_arm(self, a); }\n+    fn visit_arm(&mut self, a: &ast::Arm, _: ()) { visit_arm(self, a); }\n \n-    fn visit_local(&mut self, l:@ast::Local, _:()) { visit_local(self, l); }\n+    fn visit_local(&mut self, l: &ast::Local, _: ()) { visit_local(self, l); }\n \n-    fn visit_block(&mut self, b:ast::P<ast::Block>, _:()) { visit_block(self, b); }\n+    fn visit_block(&mut self, b: &ast::Block, _: ()) { visit_block(self, b); }\n }\n \n-fn visit_item(_rcx: &mut Rcx, _item: @ast::item) {\n+fn visit_item(_rcx: &mut Rcx, _item: &ast::item) {\n     // Ignore items\n }\n \n-fn visit_block(rcx: &mut Rcx, b: ast::P<ast::Block>) {\n+fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n     rcx.fcx.tcx().region_maps.record_cleanup_scope(b.id);\n     visit::walk_block(rcx, b, ());\n }\n@@ -205,13 +205,13 @@ fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n     visit::walk_arm(rcx, arm, ());\n }\n \n-fn visit_local(rcx: &mut Rcx, l: @ast::Local) {\n+fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n     // see above\n     constrain_bindings_in_pat(l.pat, rcx);\n     visit::walk_local(rcx, l, ());\n }\n \n-fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n+fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n     debug!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n     pat_util::pat_bindings(tcx.def_map, pat, |_, id, span, _| {\n@@ -245,7 +245,7 @@ fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n     })\n }\n \n-fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n+fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     debug!(\"regionck::visit_expr(e={}, repeating_scope={:?})\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n@@ -479,7 +479,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n }\n \n fn check_expr_fn_block(rcx: &mut Rcx,\n-                       expr: @ast::Expr) {\n+                       expr: &ast::Expr) {\n     let tcx = rcx.fcx.tcx();\n     match expr.node {\n         ast::ExprFnBlock(_, ref body) | ast::ExprProc(_, ref body) => {\n@@ -522,8 +522,8 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n fn constrain_callee(rcx: &mut Rcx,\n                     callee_id: ast::NodeId,\n-                    call_expr: @ast::Expr,\n-                    callee_expr: @ast::Expr)\n+                    call_expr: &ast::Expr,\n+                    callee_expr: &ast::Expr)\n {\n     let call_region = ty::ReScope(call_expr.id);\n \n@@ -549,7 +549,7 @@ fn constrain_call(rcx: &mut Rcx,\n                   // might be expr_call, expr_method_call, or an overloaded\n                   // operator\n                   callee_id: ast::NodeId,\n-                  call_expr: @ast::Expr,\n+                  call_expr: &ast::Expr,\n                   receiver: Option<@ast::Expr>,\n                   arg_exprs: &[@ast::Expr],\n                   implicitly_ref_args: bool)\n@@ -618,7 +618,7 @@ fn constrain_call(rcx: &mut Rcx,\n }\n \n fn constrain_derefs(rcx: &mut Rcx,\n-                    deref_expr: @ast::Expr,\n+                    deref_expr: &ast::Expr,\n                     derefs: uint,\n                     mut derefd_ty: ty::t)\n {\n@@ -662,7 +662,7 @@ pub fn mk_subregion_due_to_derefence(rcx: &mut Rcx,\n \n \n fn constrain_index(rcx: &mut Rcx,\n-                   index_expr: @ast::Expr,\n+                   index_expr: &ast::Expr,\n                    indexed_ty: ty::t)\n {\n     /*!\n@@ -688,7 +688,7 @@ fn constrain_index(rcx: &mut Rcx,\n \n fn constrain_free_variables(rcx: &mut Rcx,\n                             region: ty::Region,\n-                            expr: @ast::Expr) {\n+                            expr: &ast::Expr) {\n     /*!\n      * Make sure that all free variables referenced inside the closure\n      * outlive the closure itself.\n@@ -842,7 +842,7 @@ pub mod guarantor {\n     use syntax::codemap::Span;\n     use util::ppaux::{ty_to_str};\n \n-    pub fn for_addr_of(rcx: &mut Rcx, expr: @ast::Expr, base: @ast::Expr) {\n+    pub fn for_addr_of(rcx: &mut Rcx, expr: &ast::Expr, base: &ast::Expr) {\n         /*!\n          * Computes the guarantor for an expression `&base` and then\n          * ensures that the lifetime of the resulting pointer is linked\n@@ -855,7 +855,7 @@ pub mod guarantor {\n         link(rcx, expr.span, expr.id, guarantor);\n     }\n \n-    pub fn for_match(rcx: &mut Rcx, discr: @ast::Expr, arms: &[ast::Arm]) {\n+    pub fn for_match(rcx: &mut Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n         /*!\n          * Computes the guarantors for any ref bindings in a match and\n          * then ensures that the lifetime of the resulting pointer is\n@@ -873,7 +873,7 @@ pub mod guarantor {\n     }\n \n     pub fn for_autoref(rcx: &mut Rcx,\n-                       expr: @ast::Expr,\n+                       expr: &ast::Expr,\n                        autoderefs: uint,\n                        autoref: &ty::AutoRef) {\n         /*!\n@@ -913,7 +913,7 @@ pub mod guarantor {\n \n         fn maybe_make_subregion(\n             rcx: &mut Rcx,\n-            expr: @ast::Expr,\n+            expr: &ast::Expr,\n             sub_region: ty::Region,\n             sup_region: Option<ty::Region>)\n         {\n@@ -925,7 +925,7 @@ pub mod guarantor {\n     }\n \n     pub fn for_by_ref(rcx: &mut Rcx,\n-                      expr: @ast::Expr,\n+                      expr: &ast::Expr,\n                       callee_scope: ast::NodeId) {\n         /*!\n          * Computes the guarantor for cases where the `expr` is\n@@ -1004,7 +1004,7 @@ pub mod guarantor {\n         ty: ty::t\n     }\n \n-    fn guarantor(rcx: &mut Rcx, expr: @ast::Expr) -> Option<ty::Region> {\n+    fn guarantor(rcx: &mut Rcx, expr: &ast::Expr) -> Option<ty::Region> {\n         /*!\n          *\n          * Computes the guarantor of `expr`, or None if `expr` is\n@@ -1076,7 +1076,7 @@ pub mod guarantor {\n         }\n     }\n \n-    fn categorize(rcx: &mut Rcx, expr: @ast::Expr) -> ExprCategorization {\n+    fn categorize(rcx: &mut Rcx, expr: &ast::Expr) -> ExprCategorization {\n         debug!(\"categorize()\");\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n@@ -1152,7 +1152,7 @@ pub mod guarantor {\n     }\n \n     fn categorize_unadjusted(rcx: &mut Rcx,\n-                             expr: @ast::Expr)\n+                             expr: &ast::Expr)\n                           -> ExprCategorizationType {\n         debug!(\"categorize_unadjusted()\");\n \n@@ -1177,7 +1177,7 @@ pub mod guarantor {\n \n     fn apply_autoderefs(\n         rcx: &mut Rcx,\n-        expr: @ast::Expr,\n+        expr: &ast::Expr,\n         autoderefs: uint,\n         ct: ExprCategorizationType)\n      -> ExprCategorizationType {\n@@ -1255,7 +1255,7 @@ pub mod guarantor {\n \n     fn link_ref_bindings_in_pat(\n         rcx: &mut Rcx,\n-        pat: @ast::Pat,\n+        pat: &ast::Pat,\n         guarantor: Option<ty::Region>) {\n         /*!\n          *"}, {"sha": "e0e163f5400274d4917ebceeb0e2ac1637b96ea0", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -544,28 +544,26 @@ fn insert_vtables(fcx: @FnCtxt,\n     vtable_map.get().insert(callee_id, vtables);\n }\n \n-pub fn location_info_for_expr(expr: @ast::Expr) -> LocationInfo {\n+pub fn location_info_for_expr(expr: &ast::Expr) -> LocationInfo {\n     LocationInfo {\n         span: expr.span,\n         id: expr.id\n     }\n }\n-pub fn location_info_for_item(item: @ast::item) -> LocationInfo {\n+pub fn location_info_for_item(item: &ast::item) -> LocationInfo {\n     LocationInfo {\n         span: item.span,\n         id: item.id\n     }\n }\n \n-pub fn early_resolve_expr(ex: @ast::Expr,\n-                          fcx: @FnCtxt,\n-                          is_early: bool) {\n+pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id {:?} (early: {}): {}\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n     let _indent = indenter();\n \n     let cx = fcx.ccx;\n-    let resolve_object_cast = |src: @ast::Expr, target_ty: ty::t| {\n+    let resolve_object_cast = |src: &ast::Expr, target_ty: ty::t| {\n       match ty::get(target_ty).sty {\n           // Bounds of type's contents are not checked here, but in kind.rs.\n           ty::ty_trait(target_def_id, ref target_substs, store,\n@@ -753,15 +751,14 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n     }\n }\n \n-fn resolve_expr(fcx: @FnCtxt,\n-                ex: @ast::Expr) {\n+fn resolve_expr(fcx: @FnCtxt, ex: &ast::Expr) {\n     let mut fcx = fcx;\n     early_resolve_expr(ex, fcx, false);\n     visit::walk_expr(&mut fcx, ex, ());\n }\n \n pub fn resolve_impl(ccx: @CrateCtxt,\n-                    impl_item: @ast::item,\n+                    impl_item: &ast::item,\n                     impl_generics: &ty::Generics,\n                     impl_trait_ref: &ty::TraitRef) {\n     let param_env = ty::construct_parameter_environment(\n@@ -817,17 +814,16 @@ pub fn resolve_impl(ccx: @CrateCtxt,\n }\n \n impl visit::Visitor<()> for @FnCtxt {\n-    fn visit_expr(&mut self, ex:@ast::Expr, _:()) {\n+    fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n         resolve_expr(*self, ex);\n     }\n-    fn visit_item(&mut self, _:@ast::item, _:()) {\n+    fn visit_item(&mut self, _: &ast::item, _: ()) {\n         // no-op\n     }\n }\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(fcx: @FnCtxt, bl: ast::P<ast::Block>) {\n-    let mut fcx = fcx;\n+pub fn resolve_in_block(mut fcx: @FnCtxt, bl: &ast::Block) {\n     visit::walk_block(&mut fcx, bl, ());\n }"}, {"sha": "ce9f8ba221228b61790e9d4cc54b57104f2d464b", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -242,13 +242,13 @@ struct WbCtxt {\n     success: bool,\n }\n \n-fn visit_stmt(s: @ast::Stmt, wbcx: &mut WbCtxt) {\n+fn visit_stmt(s: &ast::Stmt, wbcx: &mut WbCtxt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n     visit::walk_stmt(wbcx, s, ());\n }\n \n-fn visit_expr(e: @ast::Expr, wbcx: &mut WbCtxt) {\n+fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n     if !wbcx.success {\n         return;\n     }\n@@ -296,7 +296,7 @@ fn visit_expr(e: @ast::Expr, wbcx: &mut WbCtxt) {\n     visit::walk_expr(wbcx, e, ());\n }\n \n-fn visit_block(b: ast::P<ast::Block>, wbcx: &mut WbCtxt) {\n+fn visit_block(b: &ast::Block, wbcx: &mut WbCtxt) {\n     if !wbcx.success {\n         return;\n     }\n@@ -319,7 +319,7 @@ fn visit_pat(p: &ast::Pat, wbcx: &mut WbCtxt) {\n     visit::walk_pat(wbcx, p, ());\n }\n \n-fn visit_local(l: @ast::Local, wbcx: &mut WbCtxt) {\n+fn visit_local(l: &ast::Local, wbcx: &mut WbCtxt) {\n     if !wbcx.success { return; }\n     let var_ty = wbcx.fcx.local_ty(l.span, l.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n@@ -341,22 +341,22 @@ fn visit_local(l: @ast::Local, wbcx: &mut WbCtxt) {\n     }\n     visit::walk_local(wbcx, l, ());\n }\n-fn visit_item(_item: @ast::item, _wbcx: &mut WbCtxt) {\n+fn visit_item(_item: &ast::item, _wbcx: &mut WbCtxt) {\n     // Ignore items\n }\n \n impl Visitor<()> for WbCtxt {\n-    fn visit_item(&mut self, i:@ast::item, _:()) { visit_item(i, self); }\n-    fn visit_stmt(&mut self, s:@ast::Stmt, _:()) { visit_stmt(s, self); }\n-    fn visit_expr(&mut self, ex:@ast::Expr, _:()) { visit_expr(ex, self); }\n-    fn visit_block(&mut self, b:ast::P<ast::Block>, _:()) { visit_block(b, self); }\n-    fn visit_pat(&mut self, p:&ast::Pat, _:()) { visit_pat(p, self); }\n-    fn visit_local(&mut self, l:@ast::Local, _:()) { visit_local(l, self); }\n+    fn visit_item(&mut self, i: &ast::item, _: ()) { visit_item(i, self); }\n+    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) { visit_stmt(s, self); }\n+    fn visit_expr(&mut self, ex:&ast::Expr, _: ()) { visit_expr(ex, self); }\n+    fn visit_block(&mut self, b: &ast::Block, _: ()) { visit_block(b, self); }\n+    fn visit_pat(&mut self, p: &ast::Pat, _: ()) { visit_pat(p, self); }\n+    fn visit_local(&mut self, l: &ast::Local, _: ()) { visit_local(l, self); }\n     // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, _t: &ast::Ty, _:()) {}\n+    fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n }\n \n-pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: @ast::Expr) -> bool {\n+pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: &ast::Expr) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;\n     wbcx.visit_expr(e, ());\n@@ -365,7 +365,7 @@ pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: @ast::Expr) -> bool {\n \n pub fn resolve_type_vars_in_fn(fcx: @FnCtxt,\n                                decl: &ast::fn_decl,\n-                               blk: ast::P<ast::Block>,\n+                               blk: &ast::Block,\n                                self_info: Option<SelfInfo>) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;"}, {"sha": "39c483241cbaeaf32cdcff60024edd3c28d6f59c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -158,23 +158,24 @@ pub struct CoherenceChecker {\n struct CoherenceCheckVisitor { cc: CoherenceChecker }\n \n impl visit::Visitor<()> for CoherenceCheckVisitor {\n-    fn visit_item(&mut self, item:@item, _:()) {\n-\n-//                debug!(\"(checking coherence) item '{}'\",\n-//                       self.cc.crate_context.tcx.sess.str_of(item.ident));\n-\n-                match item.node {\n-                    item_impl(_, ref opt_trait, _, _) => {\n-                        let opt_trait : ~[trait_ref] =\n-                            opt_trait.iter()\n-                                     .map(|x| (*x).clone())\n-                                     .collect();\n-                        self.cc.check_implementation(item, opt_trait);\n-                    }\n-                    _ => {\n-                        // Nothing to do.\n+    fn visit_item(&mut self, item: &item, _: ()) {\n+\n+//      debug!(\"(checking coherence) item '{}'\",\n+//             self.cc.crate_context.tcx.sess.str_of(item.ident));\n+\n+        match item.node {\n+            item_impl(_, ref opt_trait, _, _) => {\n+                match opt_trait.clone() {\n+                    Some(opt_trait) => {\n+                        self.cc.check_implementation(item, [opt_trait]);\n                     }\n-                };\n+                    None => self.cc.check_implementation(item, [])\n+                }\n+            }\n+            _ => {\n+                // Nothing to do.\n+            }\n+        };\n \n         visit::walk_item(self, item, ());\n     }\n@@ -183,50 +184,50 @@ impl visit::Visitor<()> for CoherenceCheckVisitor {\n struct PrivilegedScopeVisitor { cc: CoherenceChecker }\n \n impl visit::Visitor<()> for PrivilegedScopeVisitor {\n-    fn visit_item(&mut self, item:@item, _:()) {\n-\n-                match item.node {\n-                    item_mod(ref module_) => {\n-                        // Then visit the module items.\n-                        visit::walk_mod(self, module_, ());\n-                    }\n-                    item_impl(_, None, ast_ty, _) => {\n-                        if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n-                            // This is an error.\n-                            let session = self.cc.crate_context.tcx.sess;\n-                            session.span_err(item.span,\n-                                             \"cannot associate methods with a type outside the \\\n-                                              crate the type is defined in; define and implement \\\n-                                              a trait or new type instead\");\n-                        }\n-                    }\n-                    item_impl(_, Some(ref trait_ref), _, _) => {\n-                        // `for_ty` is `Type` in `impl Trait for Type`\n-                        let for_ty =\n-                            ty::node_id_to_type(self.cc.crate_context.tcx,\n-                                                item.id);\n-                        if !type_is_defined_in_local_crate(for_ty) {\n-                            // This implementation is not in scope of its base\n-                            // type. This still might be OK if the trait is\n-                            // defined in the same crate.\n-\n-                            let trait_def_id =\n-                                self.cc.trait_ref_to_trait_def_id(trait_ref);\n-\n-                            if trait_def_id.crate != LOCAL_CRATE {\n-                                let session = self.cc.crate_context.tcx.sess;\n-                                session.span_err(item.span,\n-                                        \"cannot provide an extension implementation \\\n-                                        where both trait and type are not defined in this crate\");\n-                            }\n-                        }\n+    fn visit_item(&mut self, item: &item, _: ()) {\n \n-                        visit::walk_item(self, item, ());\n-                    }\n-                    _ => {\n-                        visit::walk_item(self, item, ());\n+        match item.node {\n+            item_mod(ref module_) => {\n+                // Then visit the module items.\n+                visit::walk_mod(self, module_, ());\n+            }\n+            item_impl(_, None, ast_ty, _) => {\n+                if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n+                    // This is an error.\n+                    let session = self.cc.crate_context.tcx.sess;\n+                    session.span_err(item.span,\n+                                     \"cannot associate methods with a type outside the \\\n+                                     crate the type is defined in; define and implement \\\n+                                     a trait or new type instead\");\n+                }\n+            }\n+            item_impl(_, Some(ref trait_ref), _, _) => {\n+                // `for_ty` is `Type` in `impl Trait for Type`\n+                let for_ty =\n+                    ty::node_id_to_type(self.cc.crate_context.tcx,\n+                                        item.id);\n+                if !type_is_defined_in_local_crate(for_ty) {\n+                    // This implementation is not in scope of its base\n+                    // type. This still might be OK if the trait is\n+                    // defined in the same crate.\n+\n+                    let trait_def_id =\n+                        self.cc.trait_ref_to_trait_def_id(trait_ref);\n+\n+                    if trait_def_id.crate != LOCAL_CRATE {\n+                        let session = self.cc.crate_context.tcx.sess;\n+                        session.span_err(item.span,\n+                                \"cannot provide an extension implementation \\\n+                                where both trait and type are not defined in this crate\");\n                     }\n                 }\n+\n+                visit::walk_item(self, item, ());\n+            }\n+            _ => {\n+                visit::walk_item(self, item, ());\n+            }\n+        }\n     }\n }\n \n@@ -257,7 +258,7 @@ impl CoherenceChecker {\n     }\n \n     pub fn check_implementation(&self,\n-                                item: @item,\n+                                item: &item,\n                                 associated_traits: &[trait_ref]) {\n         let tcx = self.crate_context.tcx;\n         let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n@@ -592,7 +593,7 @@ impl CoherenceChecker {\n     }\n \n     // Converts an implementation in the AST to an Impl structure.\n-    pub fn create_impl_from_item(&self, item: @item) -> @Impl {\n+    pub fn create_impl_from_item(&self, item: &item) -> @Impl {\n         let tcx = self.crate_context.tcx;\n         match item.node {\n             item_impl(_, ref trait_refs, _, ref ast_methods) => {"}, {"sha": "9a76a6b10c3bae4f8ef9be3450ef3732952121e9", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -61,11 +61,11 @@ struct CollectItemTypesVisitor {\n }\n \n impl visit::Visitor<()> for CollectItemTypesVisitor {\n-    fn visit_item(&mut self, i:@ast::item, _:()) {\n+    fn visit_item(&mut self, i: &ast::item, _: ()) {\n         convert(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n-    fn visit_foreign_item(&mut self, i:@ast::foreign_item, _:()) {\n+    fn visit_foreign_item(&mut self, i: &ast::foreign_item, _: ()) {\n         convert_foreign(self.ccx, i);\n         visit::walk_foreign_item(self, i, ());\n     }"}, {"sha": "a7bd65f862bed4457e78c466b8bcc84c026e8b95", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -109,7 +109,8 @@ pub enum TypeOrigin {\n     MethodCompatCheck(Span),\n \n     // Checking that this expression can be assigned where it needs to be\n-    ExprAssignable(@ast::Expr),\n+    // FIXME(eddyb) #11161 is the original Expr required?\n+    ExprAssignable(Span),\n \n     // Relating trait refs when resolving vtables\n     RelateTraitRefs(Span),\n@@ -845,7 +846,7 @@ impl TypeOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n             MethodCompatCheck(span) => span,\n-            ExprAssignable(expr) => expr.span,\n+            ExprAssignable(span) => span,\n             Misc(span) => span,\n             RelateTraitRefs(span) => span,\n             RelateSelfType(span) => span,"}, {"sha": "6a338c73e9bc006383cf087d05b62466fb35b737", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -534,8 +534,7 @@ impl RegionVarBindings {\n \n impl RegionVarBindings {\n     fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n-        let rm = self.tcx.region_maps;\n-        rm.is_subregion_of(sub, sup)\n+        self.tcx.region_maps.is_subregion_of(sub, sup)\n     }\n \n     fn lub_concrete_regions(&self, a: Region, b: Region) -> Region {\n@@ -571,8 +570,7 @@ impl RegionVarBindings {\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n-            let rm = self.tcx.region_maps;\n-            match rm.nearest_common_ancestor(fr.scope_id, s_id) {\n+            match self.tcx.region_maps.nearest_common_ancestor(fr.scope_id, s_id) {\n               // if the free region's scope `fr.scope_id` is bigger than\n               // the scope region `s_id`, then the LUB is the free\n               // region itself:\n@@ -588,8 +586,7 @@ impl RegionVarBindings {\n             // The region corresponding to an outer block is a\n             // subtype of the region corresponding to an inner\n             // block.\n-            let rm = self.tcx.region_maps;\n-            match rm.nearest_common_ancestor(a_id, b_id) {\n+            match self.tcx.region_maps.nearest_common_ancestor(a_id, b_id) {\n               Some(r_id) => ReScope(r_id),\n               _ => ReStatic\n             }\n@@ -628,10 +625,9 @@ impl RegionVarBindings {\n                   a: &FreeRegion,\n                   b: &FreeRegion) -> ty::Region\n         {\n-            let rm = this.tcx.region_maps;\n-            if rm.sub_free_region(*a, *b) {\n+            if this.tcx.region_maps.sub_free_region(*a, *b) {\n                 ty::ReFree(*b)\n-            } else if rm.sub_free_region(*b, *a) {\n+            } else if this.tcx.region_maps.sub_free_region(*b, *a) {\n                 ty::ReFree(*a)\n             } else {\n                 ty::ReStatic\n@@ -681,8 +677,7 @@ impl RegionVarBindings {\n                 // than the scope `s_id`, then we can say that the GLB\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n-                let rm = self.tcx.region_maps;\n-                match rm.nearest_common_ancestor(fr.scope_id, s_id) {\n+                match self.tcx.region_maps.nearest_common_ancestor(fr.scope_id, s_id) {\n                     Some(r_id) if r_id == fr.scope_id => Ok(s),\n                     _ => Err(ty::terr_regions_no_overlap(b, a))\n                 }\n@@ -729,10 +724,9 @@ impl RegionVarBindings {\n                   a: &FreeRegion,\n                   b: &FreeRegion) -> cres<ty::Region>\n         {\n-            let rm = this.tcx.region_maps;\n-            if rm.sub_free_region(*a, *b) {\n+            if this.tcx.region_maps.sub_free_region(*a, *b) {\n                 Ok(ty::ReFree(*a))\n-            } else if rm.sub_free_region(*b, *a) {\n+            } else if this.tcx.region_maps.sub_free_region(*b, *a) {\n                 Ok(ty::ReFree(*b))\n             } else {\n                 this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n@@ -753,8 +747,7 @@ impl RegionVarBindings {\n         // it.  Otherwise fail.\n         debug!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n                scope_a, scope_b, region_a, region_b);\n-        let rm = self.tcx.region_maps;\n-        match rm.nearest_common_ancestor(scope_a, scope_b) {\n+        match self.tcx.region_maps.nearest_common_ancestor(scope_a, scope_b) {\n             Some(r_id) if scope_a == r_id => Ok(ReScope(scope_b)),\n             Some(r_id) if scope_b == r_id => Ok(ReScope(scope_a)),\n             _ => Err(ty::terr_regions_no_overlap(region_a, region_b))"}, {"sha": "7f7bcf202ab466589b34b11bb0b4de4d669ce271", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -327,9 +327,7 @@ impl<'a> TermsContext<'a> {\n }\n \n impl<'a> Visitor<()> for TermsContext<'a> {\n-    fn visit_item(&mut self,\n-                  item: @ast::item,\n-                  (): ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n \n         let inferreds_on_entry = self.num_inferred();\n@@ -434,9 +432,7 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n }\n \n impl<'a> Visitor<()> for ConstraintContext<'a> {\n-    fn visit_item(&mut self,\n-                  item: @ast::item,\n-                  (): ()) {\n+    fn visit_item(&mut self, item: &ast::item, _: ()) {\n         let did = ast_util::local_def(item.id);\n         let tcx = self.terms_cx.tcx;\n "}, {"sha": "e17a42d349415a4a81648342e5542b35f94089b5", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -74,7 +74,7 @@ struct LoopQueryVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for LoopQueryVisitor<'a> {\n-    fn visit_expr(&mut self, e: @ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         self.flag |= (self.p)(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n@@ -87,7 +87,7 @@ impl<'a> Visitor<()> for LoopQueryVisitor<'a> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: ast::P<ast::Block>, p: |&ast::Expr_| -> bool) -> bool {\n+pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n     let mut v = LoopQueryVisitor {\n         p: p,\n         flag: false,\n@@ -97,20 +97,20 @@ pub fn loop_query(b: ast::P<ast::Block>, p: |&ast::Expr_| -> bool) -> bool {\n }\n \n struct BlockQueryVisitor<'a> {\n-    p: 'a |@ast::Expr| -> bool,\n+    p: 'a |&ast::Expr| -> bool,\n     flag: bool,\n }\n \n impl<'a> Visitor<()> for BlockQueryVisitor<'a> {\n-    fn visit_expr(&mut self, e: @ast::Expr, _:()) {\n+    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         self.flag |= (self.p)(e);\n         visit::walk_expr(self, e, ())\n     }\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: ast::P<ast::Block>, p: |@ast::Expr| -> bool) -> bool {\n+pub fn block_query(b: ast::P<ast::Block>, p: |&ast::Expr| -> bool) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,\n@@ -119,7 +119,7 @@ pub fn block_query(b: ast::P<ast::Block>, p: |@ast::Expr| -> bool) -> bool {\n     return v.flag;\n }\n \n-pub fn local_rhs_span(l: @ast::Local, def: Span) -> Span {\n+pub fn local_rhs_span(l: &ast::Local, def: Span) -> Span {\n     match l.init {\n       Some(i) => return i.span,\n       _ => return def"}, {"sha": "5762e8570dfc71bbbf978fc0073d23391665d25d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -72,11 +72,11 @@ fn get_ast_and_resolve(cpath: &Path,\n         cfg.push(@dummy_spanned(ast::MetaWord(cfg_.to_managed())));\n     }\n \n-    let mut crate = phase_1_parse_input(sess, cfg.clone(), &input);\n-    crate = phase_2_configure_and_expand(sess, cfg, crate);\n+    let crate = phase_1_parse_input(sess, cfg.clone(), &input);\n+    let (crate, ast_map) = phase_2_configure_and_expand(sess, cfg, crate);\n     let driver::driver::CrateAnalysis {\n         exported_items, ty_cx, ..\n-    } = phase_3_run_analysis_passes(sess, &crate);\n+    } = phase_3_run_analysis_passes(sess, &crate, ast_map);\n \n     debug!(\"crate: {:?}\", crate);\n     return (DocContext { crate: crate, tycx: Some(ty_cx), sess: sess },"}, {"sha": "a1ef5a629947d810e8bac5e7d8331e16c94e3ff2", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -57,8 +57,8 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n                                       span_diagnostic_handler);\n \n     let cfg = driver::build_configuration(sess);\n-    let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-    crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n+    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n+    let (crate, _) = driver::phase_2_configure_and_expand(sess, cfg, crate);\n \n     let ctx = @core::DocContext {\n         crate: crate,"}, {"sha": "1f6de70094017ca5d647a02400372c8c3988f97e", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -86,8 +86,8 @@ struct PkgScript<'a> {\n     sess: session::Session,\n     /// The config for compiling the custom build script\n     cfg: ast::CrateConfig,\n-    /// The crate for the custom build script\n-    crate: Option<ast::Crate>,\n+    /// The crate and ast_map for the custom build script\n+    crate_and_map: Option<(ast::Crate, syntax::ast_map::map)>,\n     /// Directory in which to store build output\n     build_dir: Path\n }\n@@ -117,7 +117,7 @@ impl<'a> PkgScript<'a> {\n                                             @diagnostic::Emitter);\n         let cfg = driver::build_configuration(sess);\n         let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-        let crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n+        let crate_and_map = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n         debug!(\"Returning package script with id {}\", id.to_str());\n@@ -127,7 +127,7 @@ impl<'a> PkgScript<'a> {\n             input: script,\n             sess: sess,\n             cfg: cfg,\n-            crate: Some(crate),\n+            crate_and_map: Some(crate_and_map),\n             build_dir: work_dir\n         }\n     }\n@@ -137,7 +137,8 @@ impl<'a> PkgScript<'a> {\n \n         debug!(\"Working directory = {}\", self.build_dir.display());\n         // Collect together any user-defined commands in the package script\n-        let crate = util::ready_crate(sess, self.crate.take_unwrap());\n+        let (crate, ast_map) = self.crate_and_map.take_unwrap();\n+        let crate = util::ready_crate(sess, crate);\n         debug!(\"Building output filenames with script name {}\",\n                driver::source_name(&driver::file_input(self.input.clone())));\n         let exe = self.build_dir.join(\"pkg\" + util::exe_suffix());\n@@ -147,6 +148,7 @@ impl<'a> PkgScript<'a> {\n                                        &self.build_dir,\n                                        sess,\n                                        crate,\n+                                       ast_map,\n                                        Main);\n         // Discover the output\n         // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "bda84cc8baa8d74ee4ec74f4e69aa55b8729f882", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -18,7 +18,7 @@ use std::io::fs;\n use extra::workcache;\n use rustc::driver::{driver, session};\n use extra::getopts::groups::getopts;\n-use syntax::ast_util::*;\n+use syntax;\n use syntax::codemap::{DUMMY_SP, Spanned};\n use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n@@ -283,8 +283,8 @@ pub fn compile_input(context: &BuildContext,\n     // Infer dependencies that rustpkg needs to build, by scanning for\n     // `extern mod` directives.\n     let cfg = driver::build_configuration(sess);\n-    let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-    crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n+    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n+    let (mut crate, ast_map) = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);\n \n     debug!(\"About to call find_and_install_dependencies...\");\n \n@@ -323,6 +323,7 @@ pub fn compile_input(context: &BuildContext,\n                                           &out_dir,\n                                           sess,\n                                           crate,\n+                                          ast_map,\n                                           what);\n     // Discover the output\n     let discovered_output = if what == Lib  {\n@@ -359,6 +360,7 @@ pub fn compile_crate_from_input(input: &Path,\n // Returns None if one of the flags that suppresses compilation output was\n // given\n                                 crate: ast::Crate,\n+                                ast_map: syntax::ast_map::map,\n                                 what: OutputType) -> Option<Path> {\n     debug!(\"Calling build_output_filenames with {}, building library? {:?}\",\n            out_dir.display(), sess.building_library);\n@@ -394,7 +396,7 @@ pub fn compile_crate_from_input(input: &Path,\n             debug!(\"an additional library: {}\", lib.display());\n         }\n     }\n-    let analysis = driver::phase_3_run_analysis_passes(sess, &crate);\n+    let analysis = driver::phase_3_run_analysis_passes(sess, &crate, ast_map);\n     if driver::stop_after_phase_3(sess) { return None; }\n     let translation = driver::phase_4_translate_to_llvm(sess, crate,\n                                                         &analysis,"}, {"sha": "a19b930be3e3d0dd282b921972c7b8cb7fc089a1", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 150, "deletions": 215, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -11,21 +11,19 @@\n use abi::AbiSet;\n use ast::*;\n use ast;\n-use ast_util::{inlined_item_utils, stmt_id};\n use ast_util;\n use codemap::Span;\n-use codemap;\n use diagnostic::SpanHandler;\n+use fold::ast_fold;\n+use fold;\n use parse::token::get_ident_interner;\n use parse::token::ident_interner;\n use parse::token::special_idents;\n use print::pprust;\n-use visit::{Visitor, fn_kind};\n-use visit;\n+use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n use std::hashmap::HashMap;\n-use std::vec;\n \n #[deriving(Clone, Eq)]\n pub enum path_elt {\n@@ -165,7 +163,10 @@ pub enum ast_node {\n     node_expr(@Expr),\n     node_stmt(@Stmt),\n     node_arg(@Pat),\n-    node_local(Ident),\n+    // HACK(eddyb) should always be a pattern, but `self` is not, and thus it\n+    // is identified only by an ident and no span is available. In all other\n+    // cases, node_span will return the proper span (required by borrowck).\n+    node_local(Ident, Option<@Pat>),\n     node_block(P<Block>),\n \n     /// node_struct_ctor represents a tuple struct.\n@@ -195,164 +196,75 @@ impl ast_node {\n \n pub type map = @RefCell<HashMap<NodeId, ast_node>>;\n \n-pub struct Ctx {\n+pub trait FoldOps {\n+    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n+        id\n+    }\n+    fn new_span(&self, span: Span) -> Span {\n+        span\n+    }\n+}\n+\n+pub struct Ctx<F> {\n     map: map,\n-    path: RefCell<path>,\n+    path: path,\n     diag: @SpanHandler,\n+    fold_ops: F\n }\n \n-impl Ctx {\n-    fn extend(&self, elt: path_elt) -> @path {\n-        @vec::append(self.path.get(), [elt])\n-    }\n-\n-    fn map_method(&mut self,\n-                  impl_did: DefId,\n-                  impl_path: @path,\n-                  m: @method,\n-                  is_provided: bool) {\n-        let entry = if is_provided {\n-            node_trait_method(@provided(m), impl_did, impl_path)\n-        } else {\n-            node_method(m, impl_did, impl_path)\n-        };\n-\n+impl<F> Ctx<F> {\n+    fn insert(&self, id: ast::NodeId, node: ast_node) {\n         let mut map = self.map.borrow_mut();\n-        map.get().insert(m.id, entry);\n-        map.get().insert(m.self_id, node_local(special_idents::self_));\n+        map.get().insert(id, node);\n     }\n \n-    fn map_struct_def(&mut self,\n-                      struct_def: @ast::struct_def,\n-                      parent_node: ast_node,\n-                      ident: ast::Ident) {\n-        let p = self.extend(path_name(ident));\n-\n-        // If this is a tuple-like struct, register the constructor.\n-        match struct_def.ctor_id {\n-            None => {}\n-            Some(ctor_id) => {\n-                match parent_node {\n-                    node_item(item, _) => {\n-                        let mut map = self.map.borrow_mut();\n-                        map.get().insert(ctor_id,\n-                                         node_struct_ctor(struct_def,\n-                                                          item,\n-                                                          p));\n-                    }\n-                    _ => fail!(\"struct def parent wasn't an item\")\n-                }\n-            }\n-        }\n+    fn map_self(&self, m: @method) {\n+        self.insert(m.self_id, node_local(special_idents::self_, None));\n     }\n+}\n \n-    fn map_expr(&mut self, ex: @Expr) {\n-        {\n-            let mut map = self.map.borrow_mut();\n-            map.get().insert(ex.id, node_expr(ex));\n-        }\n-\n-        // Expressions which are or might be calls:\n-        {\n-            let r = ex.get_callee_id();\n-            for callee_id in r.iter() {\n-                let mut map = self.map.borrow_mut();\n-                map.get().insert(*callee_id, node_callee_scope(ex));\n-            }\n-        }\n-\n-        visit::walk_expr(self, ex, ());\n-    }\n-\n-    fn map_fn(&mut self,\n-              fk: &visit::fn_kind,\n-              decl: &fn_decl,\n-              body: P<Block>,\n-              sp: codemap::Span,\n-              id: NodeId) {\n-        for a in decl.inputs.iter() {\n-            let mut map = self.map.borrow_mut();\n-            map.get().insert(a.id, node_arg(a.pat));\n-        }\n-        match *fk {\n-            visit::fk_method(name, _, _) => {\n-                let mut path = self.path.borrow_mut();\n-                path.get().push(path_name(name))\n-            }\n-            _ => {}\n-        }\n-        visit::walk_fn(self, fk, decl, body, sp, id, ());\n-        match *fk {\n-            visit::fk_method(..) => {\n-                let mut path = self.path.borrow_mut();\n-                path.get().pop();\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn map_stmt(&mut self, stmt: @Stmt) {\n-        {\n-            let mut map = self.map.borrow_mut();\n-            map.get().insert(stmt_id(stmt), node_stmt(stmt));\n-        }\n-        visit::walk_stmt(self, stmt, ());\n-    }\n-\n-    fn map_block(&mut self, b: P<Block>) {\n-        {\n-            let mut map = self.map.borrow_mut();\n-            map.get().insert(b.id, node_block(b));\n-        }\n-\n-        visit::walk_block(self, b, ());\n+impl<F: FoldOps> ast_fold for Ctx<F> {\n+    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n+        self.fold_ops.new_id(id)\n     }\n \n-    fn map_pat(&mut self, pat: &Pat) {\n-        match pat.node {\n-            PatIdent(_, ref path, _) => {\n-                // Note: this is at least *potentially* a pattern...\n-                let mut map = self.map.borrow_mut();\n-                map.get().insert(pat.id,\n-                                 node_local(ast_util::path_to_ident(path)));\n-            }\n-            _ => ()\n-        }\n-\n-        visit::walk_pat(self, pat, ());\n+    fn new_span(&mut self, span: Span) -> Span {\n+        self.fold_ops.new_span(span)\n     }\n-}\n \n-impl Visitor<()> for Ctx {\n-    fn visit_item(&mut self, i: @item, _: ()) {\n+    fn fold_item(&mut self, i: @item) -> SmallVector<@item> {\n         // clone is FIXME #2543\n-        let item_path = @self.path.get();\n-        {\n-            let mut map = self.map.borrow_mut();\n-            map.get().insert(i.id, node_item(i, item_path));\n-        }\n-        match i.node {\n-            item_impl(_, ref maybe_trait, ty, ref ms) => {\n+        let item_path = @self.path.clone();\n+        self.path.push(match i.node {\n+            item_impl(_, ref maybe_trait, ty, _) => {\n                 // Right now the ident on impls is __extensions__ which isn't\n                 // very pretty when debugging, so attempt to select a better\n                 // name to use.\n-                let elt = impl_pretty_name(maybe_trait, ty);\n+                impl_pretty_name(maybe_trait, ty)\n+            }\n+            item_mod(_) | item_foreign_mod(_) => path_mod(i.ident),\n+            _ => path_name(i.ident)\n+        });\n \n+        let i = fold::noop_fold_item(i, self).expect_one(\"expected one item\");\n+        self.insert(i.id, node_item(i, item_path));\n+\n+        match i.node {\n+            item_impl(_, _, _, ref ms) => {\n+                // clone is FIXME #2543\n+                let p = @self.path.clone();\n                 let impl_did = ast_util::local_def(i.id);\n-                for m in ms.iter() {\n-                    let extended = { self.extend(elt) };\n-                    self.map_method(impl_did, extended, *m, false)\n+                for &m in ms.iter() {\n+                    self.insert(m.id, node_method(m, impl_did, p));\n+                    self.map_self(m);\n                 }\n \n-                let mut path = self.path.borrow_mut();\n-                path.get().push(elt);\n             }\n             item_enum(ref enum_definition, _) => {\n+                // clone is FIXME #2543\n+                let p = @self.path.clone();\n                 for &v in enum_definition.variants.iter() {\n-                    let elt = path_name(i.ident);\n-                    let mut map = self.map.borrow_mut();\n-                    map.get().insert(v.node.id,\n-                                     node_variant(v, i, self.extend(elt)));\n+                    self.insert(v.node.id, node_variant(v, i, p));\n                 }\n             }\n             item_foreign_mod(ref nm) => {\n@@ -364,142 +276,162 @@ impl Visitor<()> for Ctx {\n                         inherited => i.vis\n                     };\n \n-                    let mut map = self.map.borrow_mut();\n-                    map.get().insert(nitem.id,\n-                                     node_foreign_item(*nitem,\n-                                                       nm.abis,\n-                                                       visibility,\n-                                                       // FIXME (#2543)\n-                                                        // Anonymous extern\n-                                                        // mods go in the\n-                                                        // parent scope.\n-                                                        @self.path.get()\n-                                                       ));\n+                    self.insert(nitem.id,\n+                                // Anonymous extern mods go in the parent scope.\n+                                node_foreign_item(*nitem, nm.abis, visibility, item_path));\n                 }\n             }\n             item_struct(struct_def, _) => {\n-                self.map_struct_def(struct_def,\n-                                    node_item(i, item_path),\n-                                    i.ident)\n+                // If this is a tuple-like struct, register the constructor.\n+                match struct_def.ctor_id {\n+                    None => {}\n+                    Some(ctor_id) => {\n+                        // clone is FIXME #2543\n+                        let p = @self.path.clone();\n+                        self.insert(ctor_id, node_struct_ctor(struct_def, i, p));\n+                    }\n+                }\n             }\n             item_trait(_, ref traits, ref methods) => {\n-                for p in traits.iter() {\n-                    let mut map = self.map.borrow_mut();\n-                    map.get().insert(p.ref_id, node_item(i, item_path));\n+                for t in traits.iter() {\n+                    self.insert(t.ref_id, node_item(i, item_path));\n                 }\n+\n+                // clone is FIXME #2543\n+                let p = @self.path.clone();\n                 for tm in methods.iter() {\n-                    let ext = { self.extend(path_name(i.ident)) };\n                     let d_id = ast_util::local_def(i.id);\n                     match *tm {\n                         required(ref m) => {\n-                            let entry =\n-                                node_trait_method(@(*tm).clone(), d_id, ext);\n-                            let mut map = self.map.borrow_mut();\n-                            map.get().insert(m.id, entry);\n+                            self.insert(m.id, node_trait_method(@(*tm).clone(), d_id, p));\n                         }\n                         provided(m) => {\n-                            self.map_method(d_id, ext, m, true);\n+                            self.insert(m.id, node_trait_method(@provided(m), d_id, p));\n+                            self.map_self(m);\n                         }\n                     }\n                 }\n             }\n             _ => {}\n         }\n \n-        match i.node {\n-            item_mod(_) | item_foreign_mod(_) => {\n-                let mut path = self.path.borrow_mut();\n-                path.get().push(path_mod(i.ident));\n-            }\n-            item_impl(..) => {} // this was guessed above.\n-            _ => {\n-                let mut path = self.path.borrow_mut();\n-                path.get().push(path_name(i.ident))\n+        self.path.pop();\n+\n+        SmallVector::one(i)\n+    }\n+\n+    fn fold_pat(&mut self, pat: @Pat) -> @Pat {\n+        let pat = fold::noop_fold_pat(pat, self);\n+        match pat.node {\n+            PatIdent(_, ref path, _) => {\n+                // Note: this is at least *potentially* a pattern...\n+                self.insert(pat.id, node_local(ast_util::path_to_ident(path), Some(pat)));\n             }\n+            _ => {}\n         }\n-        visit::walk_item(self, i, ());\n \n-        let mut path = self.path.borrow_mut();\n-        path.get().pop();\n+        pat\n     }\n \n-    fn visit_pat(&mut self, pat: &Pat, _: ()) {\n-        self.map_pat(pat);\n-        visit::walk_pat(self, pat, ())\n-    }\n+    fn fold_expr(&mut self, expr: @Expr) -> @Expr {\n+        let expr = fold::noop_fold_expr(expr, self);\n+\n+        self.insert(expr.id, node_expr(expr));\n \n-    fn visit_expr(&mut self, expr: @Expr, _: ()) {\n-        self.map_expr(expr)\n+        // Expressions which are or might be calls:\n+        {\n+            let r = expr.get_callee_id();\n+            for callee_id in r.iter() {\n+                self.insert(*callee_id, node_callee_scope(expr));\n+            }\n+        }\n+\n+        expr\n     }\n \n-    fn visit_stmt(&mut self, stmt: @Stmt, _: ()) {\n-        self.map_stmt(stmt)\n+    fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<@Stmt> {\n+        let stmt = fold::noop_fold_stmt(stmt, self).expect_one(\"expected one statement\");\n+        self.insert(ast_util::stmt_id(stmt), node_stmt(stmt));\n+        SmallVector::one(stmt)\n     }\n \n-    fn visit_fn(&mut self,\n-                function_kind: &fn_kind,\n-                function_declaration: &fn_decl,\n-                block: P<Block>,\n-                span: Span,\n-                node_id: NodeId,\n-                _: ()) {\n-        self.map_fn(function_kind, function_declaration, block, span, node_id)\n+    fn fold_method(&mut self, m: @method) -> @method {\n+        self.path.push(path_name(m.ident));\n+        let m = fold::noop_fold_method(m, self);\n+        self.path.pop();\n+        m\n     }\n \n-    fn visit_block(&mut self, block: P<Block>, _: ()) {\n-        self.map_block(block)\n+    fn fold_fn_decl(&mut self, decl: &fn_decl) -> P<fn_decl> {\n+        let decl = fold::noop_fold_fn_decl(decl, self);\n+        for a in decl.inputs.iter() {\n+            self.insert(a.id, node_arg(a.pat));\n+        }\n+        decl\n     }\n \n-    fn visit_ty(&mut self, typ: &Ty, _: ()) {\n-        visit::walk_ty(self, typ, ())\n+    fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n+        let block = fold::noop_fold_block(block, self);\n+        self.insert(block.id, node_block(block));\n+        block\n     }\n }\n \n-pub fn map_crate(diag: @SpanHandler, c: &Crate) -> map {\n+pub fn map_crate<F: 'static + FoldOps>(diag: @SpanHandler, c: Crate,\n+                                       fold_ops: F) -> (Crate, map) {\n     let mut cx = Ctx {\n         map: @RefCell::new(HashMap::new()),\n-        path: RefCell::new(~[]),\n+        path: ~[],\n         diag: diag,\n+        fold_ops: fold_ops\n     };\n-    visit::walk_crate(&mut cx, c, ());\n-    cx.map\n+    (cx.fold_crate(c), cx.map)\n }\n \n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-pub fn map_decoded_item(diag: @SpanHandler,\n-                        map: map,\n-                        path: path,\n-                        ii: &inlined_item) {\n+pub fn map_decoded_item<F: 'static + FoldOps>(diag: @SpanHandler,\n+                                              map: map,\n+                                              path: path,\n+                                              fold_ops: F,\n+                                              fold_ii: |&mut Ctx<F>| -> inlined_item)\n+                                              -> inlined_item {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.\n     let mut cx = Ctx {\n         map: map,\n-        path: RefCell::new(path.clone()),\n+        path: path.clone(),\n         diag: diag,\n+        fold_ops: fold_ops\n     };\n \n+    let ii = fold_ii(&mut cx);\n+\n     // Methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now. Likewise with foreign items.\n-    match *ii {\n+    match ii {\n         ii_item(..) => {} // fallthrough\n         ii_foreign(i) => {\n-            let mut map = cx.map.borrow_mut();\n-            map.get().insert(i.id, node_foreign_item(i,\n-                                                     AbiSet::Intrinsic(),\n-                                                     i.vis,    // Wrong but OK\n-                                                     @path));\n+            cx.insert(i.id, node_foreign_item(i,\n+                                              AbiSet::Intrinsic(),\n+                                              i.vis,    // Wrong but OK\n+                                              @path));\n         }\n         ii_method(impl_did, is_provided, m) => {\n-            cx.map_method(impl_did, @path, m, is_provided);\n+            let entry = if is_provided {\n+                node_trait_method(@provided(m), impl_did, @path)\n+            } else {\n+                node_method(m, impl_did, @path)\n+            };\n+            cx.insert(m.id, entry);\n+            cx.map_self(m);\n         }\n     }\n \n-    // visit the item / method contents and add those to the map:\n-    ii.accept((), &mut cx);\n+    ii\n }\n \n pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n@@ -554,7 +486,7 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n       Some(&node_arg(pat)) => {\n         format!(\"arg {} (id={})\", pprust::pat_to_str(pat, itr), id)\n       }\n-      Some(&node_local(ident)) => {\n+      Some(&node_local(ident, _)) => {\n         format!(\"local (id={}, name={})\", id, itr.get(ident.name))\n       }\n       Some(&node_block(block)) => {\n@@ -589,7 +521,10 @@ pub fn node_span(items: map,\n         Some(&node_expr(expr)) => expr.span,\n         Some(&node_stmt(stmt)) => stmt.span,\n         Some(&node_arg(pat)) => pat.span,\n-        Some(&node_local(_)) => fail!(\"node_span: cannot get span from node_local\"),\n+        Some(&node_local(_, pat)) => match pat {\n+            Some(pat) => pat.span,\n+            None => fail!(\"node_span: cannot get span from node_local (likely `self`)\")\n+        },\n         Some(&node_block(block)) => block.span,\n         Some(&node_struct_ctor(_, item, _)) => item.span,\n         Some(&node_callee_scope(expr)) => expr.span,"}, {"sha": "973d7f5aa9ec9e7a51fcd4593a3019ae9c1eae22", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 14, "deletions": 41, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -292,38 +292,6 @@ pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n     }\n }\n \n-pub trait inlined_item_utils {\n-    fn ident(&self) -> Ident;\n-    fn id(&self) -> ast::NodeId;\n-    fn accept<E: Clone, V:Visitor<E>>(&self, e: E, v: &mut V);\n-}\n-\n-impl inlined_item_utils for inlined_item {\n-    fn ident(&self) -> Ident {\n-        match *self {\n-            ii_item(i) => i.ident,\n-            ii_foreign(i) => i.ident,\n-            ii_method(_, _, m) => m.ident,\n-        }\n-    }\n-\n-    fn id(&self) -> ast::NodeId {\n-        match *self {\n-            ii_item(i) => i.id,\n-            ii_foreign(i) => i.id,\n-            ii_method(_, _, m) => m.id,\n-        }\n-    }\n-\n-    fn accept<E: Clone, V:Visitor<E>>(&self, e: E, v: &mut V) {\n-        match *self {\n-            ii_item(i) => v.visit_item(i, e),\n-            ii_foreign(i) => v.visit_foreign_item(i, e),\n-            ii_method(_, _, m) => visit::walk_method_helper(v, m, e),\n-        }\n-    }\n-}\n-\n /* True if d is either a def_self, or a chain of def_upvars\n  referring to a def_self */\n pub fn is_self(d: ast::Def) -> bool {\n@@ -443,12 +411,12 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n         visit::walk_view_item(self, view_item, env)\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: @foreign_item, env: ()) {\n+    fn visit_foreign_item(&mut self, foreign_item: &foreign_item, env: ()) {\n         self.operation.visit_id(foreign_item.id);\n         visit::walk_foreign_item(self, foreign_item, env)\n     }\n \n-    fn visit_item(&mut self, item: @item, env: ()) {\n+    fn visit_item(&mut self, item: &item, env: ()) {\n         if !self.pass_through_items {\n             if self.visited_outermost {\n                 return\n@@ -472,17 +440,17 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n         self.visited_outermost = false\n     }\n \n-    fn visit_local(&mut self, local: @Local, env: ()) {\n+    fn visit_local(&mut self, local: &Local, env: ()) {\n         self.operation.visit_id(local.id);\n         visit::walk_local(self, local, env)\n     }\n \n-    fn visit_block(&mut self, block: P<Block>, env: ()) {\n+    fn visit_block(&mut self, block: &Block, env: ()) {\n         self.operation.visit_id(block.id);\n         visit::walk_block(self, block, env)\n     }\n \n-    fn visit_stmt(&mut self, statement: @Stmt, env: ()) {\n+    fn visit_stmt(&mut self, statement: &Stmt, env: ()) {\n         self.operation.visit_id(ast_util::stmt_id(statement));\n         visit::walk_stmt(self, statement, env)\n     }\n@@ -493,7 +461,7 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n     }\n \n \n-    fn visit_expr(&mut self, expression: @Expr, env: ()) {\n+    fn visit_expr(&mut self, expression: &Expr, env: ()) {\n         {\n             let optional_callee_id = expression.get_callee_id();\n             for callee_id in optional_callee_id.iter() {\n@@ -521,7 +489,7 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n     fn visit_fn(&mut self,\n                 function_kind: &visit::fn_kind,\n                 function_declaration: &fn_decl,\n-                block: P<Block>,\n+                block: &Block,\n                 span: Span,\n                 node_id: NodeId,\n                 env: ()) {\n@@ -572,7 +540,7 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n     }\n \n     fn visit_struct_def(&mut self,\n-                        struct_def: @struct_def,\n+                        struct_def: &struct_def,\n                         ident: ast::Ident,\n                         generics: &ast::Generics,\n                         id: NodeId,\n@@ -598,7 +566,12 @@ pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &inlined_item,\n         pass_through_items: true,\n         visited_outermost: false,\n     };\n-    item.accept((), &mut id_visitor);\n+\n+    match *item {\n+        ii_item(i) => id_visitor.visit_item(i, ()),\n+        ii_foreign(i) => id_visitor.visit_foreign_item(i, ()),\n+        ii_method(_, _, m) => visit::walk_method_helper(&mut id_visitor, m, ()),\n+    }\n }\n \n struct IdRangeComputingVisitor {"}, {"sha": "29dd20d2bccc78b097455faeee110601c95c2fe5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -1128,7 +1128,7 @@ mod test {\n \n     impl Visitor<()> for NewPathExprFinderContext {\n \n-        fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+        fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n             match *expr {\n                 ast::Expr{id:_,span:_,node:ast::ExprPath(ref p)} => {\n                     self.path_accumulator.push(p.clone());"}, {"sha": "8fab2df7a5dabb388e93ba776fa86f2c9d2d9964", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 134, "deletions": 129, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -84,32 +84,7 @@ pub trait ast_fold {\n     }\n \n     fn fold_foreign_item(&mut self, ni: @foreign_item) -> @foreign_item {\n-        let fold_attribute = |x| fold_attribute_(x, self);\n-\n-        @ast::foreign_item {\n-            ident: self.fold_ident(ni.ident),\n-            attrs: ni.attrs.map(|x| fold_attribute(*x)),\n-            node:\n-                match ni.node {\n-                    foreign_item_fn(ref fdec, ref generics) => {\n-                        foreign_item_fn(\n-                            P(fn_decl {\n-                                inputs: fdec.inputs.map(|a| fold_arg_(a,\n-                                                                      self)),\n-                                output: self.fold_ty(fdec.output),\n-                                cf: fdec.cf,\n-                                variadic: fdec.variadic\n-                            }),\n-                            fold_generics(generics, self))\n-                    }\n-                    foreign_item_static(t, m) => {\n-                        foreign_item_static(self.fold_ty(t), m)\n-                    }\n-                },\n-            id: self.new_id(ni.id),\n-            span: self.new_span(ni.span),\n-            vis: ni.vis,\n-        }\n+        noop_fold_foreign_item(ni, self)\n     }\n \n     fn fold_item(&mut self, i: @item) -> SmallVector<@item> {\n@@ -134,24 +109,16 @@ pub trait ast_fold {\n         noop_fold_item_underscore(i, self)\n     }\n \n+    fn fold_fn_decl(&mut self, d: &fn_decl) -> P<fn_decl> {\n+        noop_fold_fn_decl(d, self)\n+    }\n+\n     fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n         noop_fold_type_method(m, self)\n     }\n \n     fn fold_method(&mut self, m: @method) -> @method {\n-        @ast::method {\n-            ident: self.fold_ident(m.ident),\n-            attrs: m.attrs.map(|a| fold_attribute_(*a, self)),\n-            generics: fold_generics(&m.generics, self),\n-            explicit_self: self.fold_explicit_self(&m.explicit_self),\n-            purity: m.purity,\n-            decl: fold_fn_decl(m.decl, self),\n-            body: self.fold_block(m.body),\n-            id: self.new_id(m.id),\n-            span: self.new_span(m.span),\n-            self_id: self.new_id(m.self_id),\n-            vis: m.vis,\n-        }\n+        noop_fold_method(m, self)\n     }\n \n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n@@ -171,48 +138,7 @@ pub trait ast_fold {\n     }\n \n     fn fold_pat(&mut self, p: @Pat) -> @Pat {\n-        let node = match p.node {\n-            PatWild => PatWild,\n-            PatWildMulti => PatWildMulti,\n-            PatIdent(binding_mode, ref pth, ref sub) => {\n-                PatIdent(binding_mode,\n-                         self.fold_path(pth),\n-                         sub.map(|x| self.fold_pat(x)))\n-            }\n-            PatLit(e) => PatLit(self.fold_expr(e)),\n-            PatEnum(ref pth, ref pats) => {\n-                PatEnum(self.fold_path(pth),\n-                        pats.as_ref().map(|pats| pats.map(|x| self.fold_pat(*x))))\n-            }\n-            PatStruct(ref pth, ref fields, etc) => {\n-                let pth_ = self.fold_path(pth);\n-                let fs = fields.map(|f| {\n-                    ast::FieldPat {\n-                        ident: f.ident,\n-                        pat: self.fold_pat(f.pat)\n-                    }\n-                });\n-                PatStruct(pth_, fs, etc)\n-            }\n-            PatTup(ref elts) => PatTup(elts.map(|x| self.fold_pat(*x))),\n-            PatBox(inner) => PatBox(self.fold_pat(inner)),\n-            PatUniq(inner) => PatUniq(self.fold_pat(inner)),\n-            PatRegion(inner) => PatRegion(self.fold_pat(inner)),\n-            PatRange(e1, e2) => {\n-                PatRange(self.fold_expr(e1), self.fold_expr(e2))\n-            },\n-            PatVec(ref before, ref slice, ref after) => {\n-                PatVec(before.map(|x| self.fold_pat(*x)),\n-                       slice.map(|x| self.fold_pat(x)),\n-                       after.map(|x| self.fold_pat(*x)))\n-            }\n-        };\n-\n-        @Pat {\n-            id: self.new_id(p.id),\n-            span: self.new_span(p.span),\n-            node: node,\n-        }\n+        noop_fold_pat(p, self)\n     }\n \n     fn fold_decl(&mut self, d: @Decl) -> SmallVector<@Decl> {\n@@ -252,7 +178,7 @@ pub trait ast_fold {\n                     region: fold_opt_lifetime(&f.region, self),\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n-                    decl: fold_fn_decl(f.decl, self),\n+                    decl: self.fold_fn_decl(f.decl),\n                     lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n                 })\n             }\n@@ -261,7 +187,7 @@ pub trait ast_fold {\n                     lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n                     purity: f.purity,\n                     abis: f.abis,\n-                    decl: fold_fn_decl(f.decl, self)\n+                    decl: self.fold_fn_decl(f.decl)\n                 })\n             }\n             ty_tup(ref tys) => ty_tup(tys.map(|&ty| self.fold_ty(ty))),\n@@ -410,7 +336,7 @@ pub trait ast_fold {\n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n+fn fold_meta_item_<T: ast_fold>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n     @Spanned {\n         node:\n             match mi.node {\n@@ -428,7 +354,7 @@ fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n }\n \n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &mut T) -> Attribute {\n+fn fold_attribute_<T: ast_fold>(at: Attribute, fld: &mut T) -> Attribute {\n     Spanned {\n         span: fld.new_span(at.span),\n         node: ast::Attribute_ {\n@@ -440,7 +366,7 @@ fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &mut T) -> Attribute {\n }\n \n //used in noop_fold_foreign_item and noop_fold_fn_decl\n-fn fold_arg_<T:ast_fold>(a: &arg, fld: &mut T) -> arg {\n+fn fold_arg_<T: ast_fold>(a: &arg, fld: &mut T) -> arg {\n     ast::arg {\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n@@ -450,7 +376,7 @@ fn fold_arg_<T:ast_fold>(a: &arg, fld: &mut T) -> arg {\n \n // build a new vector of tts by appling the ast_fold's fold_ident to\n // all of the identifiers in the token trees.\n-pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &mut T) -> ~[token_tree] {\n+pub fn fold_tts<T: ast_fold>(tts: &[token_tree], fld: &mut T) -> ~[token_tree] {\n     tts.map(|tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n@@ -468,7 +394,7 @@ pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &mut T) -> ~[token_tree] {\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &mut T) -> token::Token {\n+fn maybe_fold_ident<T: ast_fold>(t: &token::Token, fld: &mut T) -> token::Token {\n     match *t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n@@ -477,8 +403,8 @@ fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &mut T) -> token::Token {\n     }\n }\n \n-pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &mut T)\n-                                -> P<fn_decl> {\n+pub fn noop_fold_fn_decl<T: ast_fold>(decl: &fn_decl, fld: &mut T)\n+                                      -> P<fn_decl> {\n     P(fn_decl {\n         inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n         output: fld.fold_ty(decl.output),\n@@ -487,66 +413,65 @@ pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &mut T)\n     })\n }\n \n-fn fold_ty_param_bound<T:ast_fold>(tpb: &TyParamBound, fld: &mut T)\n-                                   -> TyParamBound {\n+fn fold_ty_param_bound<T: ast_fold>(tpb: &TyParamBound, fld: &mut T)\n+                                    -> TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n \n-pub fn fold_ty_param<T:ast_fold>(tp: &TyParam, fld: &mut T) -> TyParam {\n+pub fn fold_ty_param<T: ast_fold>(tp: &TyParam, fld: &mut T) -> TyParam {\n     TyParam {\n         ident: tp.ident,\n         id: fld.new_id(tp.id),\n         bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n     }\n }\n \n-pub fn fold_ty_params<T:ast_fold>(tps: &OptVec<TyParam>, fld: &mut T)\n-                                  -> OptVec<TyParam> {\n+pub fn fold_ty_params<T: ast_fold>(tps: &OptVec<TyParam>, fld: &mut T)\n+                                   -> OptVec<TyParam> {\n     tps.map(|tp| fold_ty_param(tp, fld))\n }\n \n-pub fn fold_lifetime<T:ast_fold>(l: &Lifetime, fld: &mut T) -> Lifetime {\n+pub fn fold_lifetime<T: ast_fold>(l: &Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n         span: fld.new_span(l.span),\n         ident: l.ident\n     }\n }\n \n-pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &mut T)\n-                                  -> OptVec<Lifetime> {\n+pub fn fold_lifetimes<T: ast_fold>(lts: &OptVec<Lifetime>, fld: &mut T)\n+                                   -> OptVec<Lifetime> {\n     lts.map(|l| fold_lifetime(l, fld))\n }\n \n-pub fn fold_opt_lifetime<T:ast_fold>(o_lt: &Option<Lifetime>, fld: &mut T)\n-                                     -> Option<Lifetime> {\n+pub fn fold_opt_lifetime<T: ast_fold>(o_lt: &Option<Lifetime>, fld: &mut T)\n+                                      -> Option<Lifetime> {\n     o_lt.as_ref().map(|lt| fold_lifetime(lt, fld))\n }\n \n-pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &mut T) -> Generics {\n+pub fn fold_generics<T: ast_fold>(generics: &Generics, fld: &mut T) -> Generics {\n     Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n-fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &mut T)\n-                               -> @ast::struct_def {\n+fn fold_struct_def<T: ast_fold>(struct_def: @struct_def, fld: &mut T) -> @struct_def {\n     @ast::struct_def {\n         fields: struct_def.fields.map(|f| fold_struct_field(f, fld)),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n     }\n }\n \n-fn fold_trait_ref<T:ast_fold>(p: &trait_ref, fld: &mut T) -> trait_ref {\n+fn fold_trait_ref<T: ast_fold>(p: &trait_ref, fld: &mut T) -> trait_ref {\n     ast::trait_ref {\n         path: fld.fold_path(&p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-fn fold_struct_field<T:ast_fold>(f: &struct_field, fld: &mut T) -> struct_field {\n+fn fold_struct_field<T: ast_fold>(f: &struct_field, fld: &mut T) -> struct_field {\n     Spanned {\n         node: ast::struct_field_ {\n             kind: f.node.kind,\n@@ -558,39 +483,38 @@ fn fold_struct_field<T:ast_fold>(f: &struct_field, fld: &mut T) -> struct_field\n     }\n }\n \n-fn fold_field_<T:ast_fold>(field: Field, folder: &mut T) -> Field {\n+fn fold_field_<T: ast_fold>(field: Field, folder: &mut T) -> Field {\n     ast::Field {\n         ident: respan(field.ident.span, folder.fold_ident(field.ident.node)),\n         expr: folder.fold_expr(field.expr),\n         span: folder.new_span(field.span),\n     }\n }\n \n-fn fold_mt<T:ast_fold>(mt: &mt, folder: &mut T) -> mt {\n+fn fold_mt<T: ast_fold>(mt: &mt, folder: &mut T) -> mt {\n     mt {\n         ty: folder.fold_ty(mt.ty),\n         mutbl: mt.mutbl,\n     }\n }\n \n-fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &mut T)\n-                               -> Option<OptVec<TyParamBound>> {\n+fn fold_opt_bounds<T: ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &mut T)\n+                                -> Option<OptVec<TyParamBound>> {\n     b.as_ref().map(|bounds| {\n         bounds.map(|bound| {\n             fold_ty_param_bound(bound, folder)\n         })\n     })\n }\n \n-fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &mut T)\n-                                 -> variant_arg {\n+fn fold_variant_arg_<T: ast_fold>(va: &variant_arg, folder: &mut T) -> variant_arg {\n     ast::variant_arg {\n         ty: folder.fold_ty(va.ty),\n         id: folder.new_id(va.id)\n     }\n }\n \n-pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &mut T) -> P<Block> {\n+pub fn noop_fold_block<T: ast_fold>(b: P<Block>, folder: &mut T) -> P<Block> {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     P(Block {\n@@ -603,14 +527,14 @@ pub fn noop_fold_block<T:ast_fold>(b: P<Block>, folder: &mut T) -> P<Block> {\n     })\n }\n \n-pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &mut T) -> item_ {\n+pub fn noop_fold_item_underscore<T: ast_fold>(i: &item_, folder: &mut T) -> item_ {\n     match *i {\n         item_static(t, m, e) => {\n             item_static(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n         item_fn(decl, purity, abi, ref generics, body) => {\n             item_fn(\n-                fold_fn_decl(decl, folder),\n+                folder.fold_fn_decl(decl),\n                 purity,\n                 abi,\n                 fold_generics(generics, folder),\n@@ -660,21 +584,20 @@ pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &mut T) -> item_\n     }\n }\n \n-pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &mut T)\n-                                         -> TypeMethod {\n+pub fn noop_fold_type_method<T: ast_fold>(m: &TypeMethod, fld: &mut T) -> TypeMethod {\n     TypeMethod {\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.map(|a| fold_attribute_(*a, fld)),\n         purity: m.purity,\n-        decl: fold_fn_decl(m.decl, fld),\n+        decl: fld.fold_fn_decl(m.decl),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: fld.fold_explicit_self(&m.explicit_self),\n         id: fld.new_id(m.id),\n         span: fld.new_span(m.span),\n     }\n }\n \n-pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &mut T) -> _mod {\n+pub fn noop_fold_mod<T: ast_fold>(m: &_mod, folder: &mut T) -> _mod {\n     ast::_mod {\n         view_items: m.view_items\n                      .iter()\n@@ -683,7 +606,7 @@ pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &mut T) -> _mod {\n     }\n }\n \n-pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &mut T) -> Crate {\n+pub fn noop_fold_crate<T: ast_fold>(c: Crate, folder: &mut T) -> Crate {\n     let fold_meta_item = |x| fold_meta_item_(x, folder);\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n@@ -695,11 +618,11 @@ pub fn noop_fold_crate<T:ast_fold>(c: Crate, folder: &mut T) -> Crate {\n     }\n }\n \n-pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &mut T)\n-                                  -> SmallVector<@ast::item> {\n+pub fn noop_fold_item<T: ast_fold>(i: &item, folder: &mut T)\n+                                   -> SmallVector<@item> {\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n-    SmallVector::one(@ast::item {\n+    SmallVector::one(@item {\n         ident: folder.fold_ident(i.ident),\n         attrs: i.attrs.map(|e| fold_attribute(*e)),\n         id: folder.new_id(i.id),\n@@ -709,7 +632,92 @@ pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &mut T)\n     })\n }\n \n-pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &mut T) -> @ast::Expr {\n+pub fn noop_fold_foreign_item<T: ast_fold>(ni: &foreign_item, folder: &mut T)\n+                                           -> @foreign_item {\n+    @foreign_item {\n+        ident: folder.fold_ident(ni.ident),\n+        attrs: ni.attrs.map(|x| fold_attribute_(*x, folder)),\n+        node: match ni.node {\n+            foreign_item_fn(ref fdec, ref generics) => {\n+                foreign_item_fn(P(fn_decl {\n+                    inputs: fdec.inputs.map(|a| fold_arg_(a, folder)),\n+                    output: folder.fold_ty(fdec.output),\n+                    cf: fdec.cf,\n+                    variadic: fdec.variadic\n+                }), fold_generics(generics, folder))\n+            }\n+            foreign_item_static(t, m) => {\n+                foreign_item_static(folder.fold_ty(t), m)\n+            }\n+        },\n+        id: folder.new_id(ni.id),\n+        span: folder.new_span(ni.span),\n+        vis: ni.vis,\n+    }\n+}\n+\n+pub fn noop_fold_method<T: ast_fold>(m: &method, folder: &mut T) -> @method {\n+    @method {\n+        ident: folder.fold_ident(m.ident),\n+        attrs: m.attrs.map(|a| fold_attribute_(*a, folder)),\n+        generics: fold_generics(&m.generics, folder),\n+        explicit_self: folder.fold_explicit_self(&m.explicit_self),\n+        purity: m.purity,\n+        decl: folder.fold_fn_decl(m.decl),\n+        body: folder.fold_block(m.body),\n+        id: folder.new_id(m.id),\n+        span: folder.new_span(m.span),\n+        self_id: folder.new_id(m.self_id),\n+        vis: m.vis\n+    }\n+}\n+\n+pub fn noop_fold_pat<T: ast_fold>(p: @Pat, folder: &mut T) -> @Pat {\n+    let node = match p.node {\n+        PatWild => PatWild,\n+        PatWildMulti => PatWildMulti,\n+        PatIdent(binding_mode, ref pth, ref sub) => {\n+            PatIdent(binding_mode,\n+                     folder.fold_path(pth),\n+                     sub.map(|x| folder.fold_pat(x)))\n+        }\n+        PatLit(e) => PatLit(folder.fold_expr(e)),\n+        PatEnum(ref pth, ref pats) => {\n+            PatEnum(folder.fold_path(pth),\n+                    pats.as_ref().map(|pats| pats.map(|x| folder.fold_pat(*x))))\n+        }\n+        PatStruct(ref pth, ref fields, etc) => {\n+            let pth_ = folder.fold_path(pth);\n+            let fs = fields.map(|f| {\n+                ast::FieldPat {\n+                    ident: f.ident,\n+                    pat: folder.fold_pat(f.pat)\n+                }\n+            });\n+            PatStruct(pth_, fs, etc)\n+        }\n+        PatTup(ref elts) => PatTup(elts.map(|x| folder.fold_pat(*x))),\n+        PatBox(inner) => PatBox(folder.fold_pat(inner)),\n+        PatUniq(inner) => PatUniq(folder.fold_pat(inner)),\n+        PatRegion(inner) => PatRegion(folder.fold_pat(inner)),\n+        PatRange(e1, e2) => {\n+            PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+        },\n+        PatVec(ref before, ref slice, ref after) => {\n+            PatVec(before.map(|x| folder.fold_pat(*x)),\n+                    slice.map(|x| folder.fold_pat(x)),\n+                    after.map(|x| folder.fold_pat(*x)))\n+        }\n+    };\n+\n+    @Pat {\n+        id: folder.new_id(p.id),\n+        span: folder.new_span(p.span),\n+        node: node,\n+    }\n+}\n+\n+pub fn noop_fold_expr<T: ast_fold>(e: @Expr, folder: &mut T) -> @Expr {\n     let fold_field = |x| fold_field_(x, folder);\n \n     let node = match e.node {\n@@ -776,13 +784,10 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &mut T) -> @ast::Expr {\n                       arms.map(|x| folder.fold_arm(x)))\n         }\n         ExprFnBlock(decl, body) => {\n-            ExprFnBlock(\n-                fold_fn_decl(decl, folder),\n-                folder.fold_block(body)\n-            )\n+            ExprFnBlock(folder.fold_fn_decl(decl), folder.fold_block(body))\n         }\n         ExprProc(decl, body) => {\n-            ExprProc(fold_fn_decl(decl, folder), folder.fold_block(body))\n+            ExprProc(folder.fold_fn_decl(decl), folder.fold_block(body))\n         }\n         ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n         ExprAssign(el, er) => {\n@@ -835,7 +840,7 @@ pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &mut T) -> @ast::Expr {\n     }\n }\n \n-pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n+pub fn noop_fold_stmt<T: ast_fold>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n     let nodes = match s.node {\n         StmtDecl(d, nid) => {\n             folder.fold_decl(d).move_iter()"}, {"sha": "6484855d9d9429e520a99e07f15c0dd0ec86202f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3119d18e55fd393641cd744545f350807c4ee7b8/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3119d18e55fd393641cd744545f350807c4ee7b8", "patch": "@@ -64,34 +64,34 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n     }\n }\n \n-pub trait Visitor<E:Clone> {\n+pub trait Visitor<E: Clone> {\n     fn visit_ident(&mut self, _sp: Span, _ident: Ident, _e: E) {\n         /*! Visit the idents */\n     }\n-    fn visit_mod(&mut self, m:&_mod, _s:Span, _n:NodeId, e:E) { walk_mod(self, m, e) }\n-    fn visit_view_item(&mut self, i:&view_item, e:E) { walk_view_item(self, i, e) }\n-    fn visit_foreign_item(&mut self, i:@foreign_item, e:E) { walk_foreign_item(self, i, e) }\n-    fn visit_item(&mut self, i:@item, e:E) { walk_item(self, i, e) }\n-    fn visit_local(&mut self, l:@Local, e:E) { walk_local(self, l, e) }\n-    fn visit_block(&mut self, b:P<Block>, e:E) { walk_block(self, b, e) }\n-    fn visit_stmt(&mut self, s:@Stmt, e:E) { walk_stmt(self, s, e) }\n-    fn visit_arm(&mut self, a:&Arm, e:E) { walk_arm(self, a, e) }\n-    fn visit_pat(&mut self, p:&Pat, e:E) { walk_pat(self, p, e) }\n-    fn visit_decl(&mut self, d:@Decl, e:E) { walk_decl(self, d, e) }\n-    fn visit_expr(&mut self, ex:@Expr, e:E) { walk_expr(self, ex, e) }\n-    fn visit_expr_post(&mut self, _ex:@Expr, _e:E) { }\n-    fn visit_ty(&mut self, t:&Ty, e:E) { walk_ty(self, t, e) }\n-    fn visit_generics(&mut self, g:&Generics, e:E) { walk_generics(self, g, e) }\n-    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:P<Block>, s:Span, n:NodeId, e:E) {\n+    fn visit_mod(&mut self, m: &_mod, _s: Span, _n: NodeId, e: E) { walk_mod(self, m, e) }\n+    fn visit_view_item(&mut self, i: &view_item, e: E) { walk_view_item(self, i, e) }\n+    fn visit_foreign_item(&mut self, i: &foreign_item, e: E) { walk_foreign_item(self, i, e) }\n+    fn visit_item(&mut self, i: &item, e: E) { walk_item(self, i, e) }\n+    fn visit_local(&mut self, l: &Local, e: E) { walk_local(self, l, e) }\n+    fn visit_block(&mut self, b: &Block, e: E) { walk_block(self, b, e) }\n+    fn visit_stmt(&mut self, s: &Stmt, e: E) { walk_stmt(self, s, e) }\n+    fn visit_arm(&mut self, a: &Arm, e: E) { walk_arm(self, a, e) }\n+    fn visit_pat(&mut self, p: &Pat, e: E) { walk_pat(self, p, e) }\n+    fn visit_decl(&mut self, d: &Decl, e: E) { walk_decl(self, d, e) }\n+    fn visit_expr(&mut self, ex: &Expr, e: E) { walk_expr(self, ex, e) }\n+    fn visit_expr_post(&mut self, _ex: &Expr, _e: E) { }\n+    fn visit_ty(&mut self, t: &Ty, e: E) { walk_ty(self, t, e) }\n+    fn visit_generics(&mut self, g: &Generics, e: E) { walk_generics(self, g, e) }\n+    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block, s: Span, n: NodeId, e: E) {\n         walk_fn(self, fk, fd, b, s, n , e)\n     }\n-    fn visit_ty_method(&mut self, t:&TypeMethod, e:E) { walk_ty_method(self, t, e) }\n-    fn visit_trait_method(&mut self, t:&trait_method, e:E) { walk_trait_method(self, t, e) }\n-    fn visit_struct_def(&mut self, s:@struct_def, i:Ident, g:&Generics, n:NodeId, e:E) {\n+    fn visit_ty_method(&mut self, t: &TypeMethod, e: E) { walk_ty_method(self, t, e) }\n+    fn visit_trait_method(&mut self, t: &trait_method, e: E) { walk_trait_method(self, t, e) }\n+    fn visit_struct_def(&mut self, s: &struct_def, i: Ident, g: &Generics, n: NodeId, e: E) {\n         walk_struct_def(self, s, i, g, n, e)\n     }\n-    fn visit_struct_field(&mut self, s:&struct_field, e:E) { walk_struct_field(self, s, e) }\n-    fn visit_variant(&mut self, v:&variant, g:&Generics, e:E) { walk_variant(self, v, g, e) }\n+    fn visit_struct_field(&mut self, s: &struct_field, e: E) { walk_struct_field(self, s, e) }\n+    fn visit_variant(&mut self, v: &variant, g: &Generics, e: E) { walk_variant(self, v, g, e) }\n     fn visit_opt_lifetime_ref(&mut self,\n                               _span: Span,\n                               opt_lifetime: &Option<Lifetime>,\n@@ -115,19 +115,19 @@ pub trait Visitor<E:Clone> {\n     fn visit_explicit_self(&mut self, es: &explicit_self, e: E) {\n         walk_explicit_self(self, es, e)\n     }\n-    fn visit_mac(&mut self, macro:&mac, e:E) {\n+    fn visit_mac(&mut self, macro: &mac, e: E) {\n         walk_mac(self, macro, e)\n     }\n     fn visit_path(&mut self, path: &Path, _id: ast::NodeId, e: E) {\n         walk_path(self, path, e)\n     }\n }\n \n-pub fn walk_crate<E:Clone, V:Visitor<E>>(visitor: &mut V, crate: &Crate, env: E) {\n+pub fn walk_crate<E: Clone, V: Visitor<E>>(visitor: &mut V, crate: &Crate, env: E) {\n     visitor.visit_mod(&crate.module, crate.span, CRATE_NODE_ID, env)\n }\n \n-pub fn walk_mod<E:Clone, V:Visitor<E>>(visitor: &mut V, module: &_mod, env: E) {\n+pub fn walk_mod<E: Clone, V: Visitor<E>>(visitor: &mut V, module: &_mod, env: E) {\n     for view_item in module.view_items.iter() {\n         visitor.visit_view_item(view_item, env.clone())\n     }\n@@ -137,7 +137,7 @@ pub fn walk_mod<E:Clone, V:Visitor<E>>(visitor: &mut V, module: &_mod, env: E) {\n     }\n }\n \n-pub fn walk_view_item<E:Clone, V:Visitor<E>>(visitor: &mut V, vi: &view_item, env: E) {\n+pub fn walk_view_item<E: Clone, V: Visitor<E>>(visitor: &mut V, vi: &view_item, env: E) {\n     match vi.node {\n         view_item_extern_mod(name, _, _) => {\n             visitor.visit_ident(vi.span, name, env)\n@@ -164,7 +164,7 @@ pub fn walk_view_item<E:Clone, V:Visitor<E>>(visitor: &mut V, vi: &view_item, en\n     }\n }\n \n-pub fn walk_local<E:Clone, V:Visitor<E>>(visitor: &mut V, local: &Local, env: E) {\n+pub fn walk_local<E: Clone, V: Visitor<E>>(visitor: &mut V, local: &Local, env: E) {\n     visitor.visit_pat(local.pat, env.clone());\n     visitor.visit_ty(local.ty, env.clone());\n     match local.init {\n@@ -173,9 +173,9 @@ pub fn walk_local<E:Clone, V:Visitor<E>>(visitor: &mut V, local: &Local, env: E)\n     }\n }\n \n-fn walk_explicit_self<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                             explicit_self: &explicit_self,\n-                                             env: E) {\n+fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                               explicit_self: &explicit_self,\n+                                               env: E) {\n     match explicit_self.node {\n         sty_static | sty_value(_) | sty_box(_) | sty_uniq(_) => {\n         }\n@@ -185,13 +185,13 @@ fn walk_explicit_self<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     }\n }\n \n-fn walk_trait_ref<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                            trait_ref: &ast::trait_ref,\n-                            env: E) {\n+fn walk_trait_ref<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                           trait_ref: &trait_ref,\n+                                           env: E) {\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id, env)\n }\n \n-pub fn walk_item<E:Clone, V:Visitor<E>>(visitor: &mut V, item: &item, env: E) {\n+pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &item, env: E) {\n     visitor.visit_ident(item.span, item.ident, env.clone());\n     match item.node {\n         item_static(typ, _, expr) => {\n@@ -261,19 +261,19 @@ pub fn walk_item<E:Clone, V:Visitor<E>>(visitor: &mut V, item: &item, env: E) {\n     }\n }\n \n-pub fn walk_enum_def<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                               enum_definition: &ast::enum_def,\n-                               generics: &Generics,\n-                               env: E) {\n+pub fn walk_enum_def<E: Clone, V:Visitor<E>>(visitor: &mut V,\n+                                             enum_definition: &enum_def,\n+                                             generics: &Generics,\n+                                             env: E) {\n     for &variant in enum_definition.variants.iter() {\n         visitor.visit_variant(variant, generics, env.clone());\n     }\n }\n \n-pub fn walk_variant<E:Clone, V:Visitor<E>>(visitor:&mut V,\n-                                           variant: &variant,\n-                                           generics: &Generics,\n-                                           env: E) {\n+pub fn walk_variant<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                             variant: &variant,\n+                                             generics: &Generics,\n+                                             env: E) {\n     visitor.visit_ident(variant.span, variant.node.name, env.clone());\n \n     match variant.node.kind {\n@@ -296,11 +296,11 @@ pub fn walk_variant<E:Clone, V:Visitor<E>>(visitor:&mut V,\n     }\n }\n \n-pub fn skip_ty<E, V:Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n+pub fn skip_ty<E, V: Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n     // Empty!\n }\n \n-pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n+pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     match typ.node {\n         ty_uniq(ty) | ty_vec(ty) | ty_box(ty) => {\n             visitor.visit_ty(ty, env)\n@@ -357,15 +357,15 @@ pub fn walk_ty<E:Clone, V:Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     }\n }\n \n-fn walk_lifetime_decls<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                              lifetimes: &OptVec<Lifetime>,\n-                                              env: E) {\n+fn walk_lifetime_decls<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                lifetimes: &OptVec<Lifetime>,\n+                                                env: E) {\n     for l in lifetimes.iter() {\n         visitor.visit_lifetime_decl(l, env.clone());\n     }\n }\n \n-pub fn walk_path<E:Clone, V:Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n+pub fn walk_path<E: Clone, V: Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n     for segment in path.segments.iter() {\n         visitor.visit_ident(path.span, segment.identifier, env.clone());\n \n@@ -378,7 +378,7 @@ pub fn walk_path<E:Clone, V:Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n     }\n }\n \n-pub fn walk_pat<E:Clone, V:Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E) {\n+pub fn walk_pat<E: Clone, V: Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E) {\n     match pattern.node {\n         PatEnum(ref path, ref children) => {\n             visitor.visit_path(path, pattern.id, env.clone());\n@@ -431,9 +431,9 @@ pub fn walk_pat<E:Clone, V:Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E) {\n     }\n }\n \n-pub fn walk_foreign_item<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                   foreign_item: &foreign_item,\n-                                   env: E) {\n+pub fn walk_foreign_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                  foreign_item: &foreign_item,\n+                                                  env: E) {\n     visitor.visit_ident(foreign_item.span, foreign_item.ident, env.clone());\n \n     match foreign_item.node {\n@@ -445,9 +445,9 @@ pub fn walk_foreign_item<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_ty_param_bounds<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                      bounds: &OptVec<TyParamBound>,\n-                                      env: E) {\n+pub fn walk_ty_param_bounds<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                     bounds: &OptVec<TyParamBound>,\n+                                                     env: E) {\n     for bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref typ) => {\n@@ -458,18 +458,18 @@ pub fn walk_ty_param_bounds<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_generics<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                               generics: &Generics,\n-                               env: E) {\n+pub fn walk_generics<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                              generics: &Generics,\n+                                              env: E) {\n     for type_parameter in generics.ty_params.iter() {\n         walk_ty_param_bounds(visitor, &type_parameter.bounds, env.clone())\n     }\n     walk_lifetime_decls(visitor, &generics.lifetimes, env);\n }\n \n-pub fn walk_fn_decl<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                              function_declaration: &fn_decl,\n-                              env: E) {\n+pub fn walk_fn_decl<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                             function_declaration: &fn_decl,\n+                                             env: E) {\n     for argument in function_declaration.inputs.iter() {\n         visitor.visit_pat(argument.pat, env.clone());\n         visitor.visit_ty(argument.ty, env.clone())\n@@ -481,9 +481,9 @@ pub fn walk_fn_decl<E:Clone, V:Visitor<E>>(visitor: &mut V,\n // visit_fn() and check for fk_method().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn walk_method_helper<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                    method: &method,\n-                                    env: E) {\n+pub fn walk_method_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                   method: &method,\n+                                                   env: E) {\n     visitor.visit_ident(method.span, method.ident, env.clone());\n     visitor.visit_fn(&fk_method(method.ident, &method.generics, method),\n                      method.decl,\n@@ -493,13 +493,13 @@ pub fn walk_method_helper<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                      env)\n }\n \n-pub fn walk_fn<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                         function_kind: &fn_kind,\n-                         function_declaration: &fn_decl,\n-                         function_body: P<Block>,\n-                         _span: Span,\n-                         _: NodeId,\n-                         env: E) {\n+pub fn walk_fn<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                        function_kind: &fn_kind,\n+                                        function_declaration: &fn_decl,\n+                                        function_body: &Block,\n+                                        _span: Span,\n+                                        _: NodeId,\n+                                        env: E) {\n     walk_fn_decl(visitor, function_declaration, env.clone());\n \n     match *function_kind {\n@@ -518,9 +518,9 @@ pub fn walk_fn<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     visitor.visit_block(function_body, env)\n }\n \n-pub fn walk_ty_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                             method_type: &TypeMethod,\n-                                             env: E) {\n+pub fn walk_ty_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                               method_type: &TypeMethod,\n+                                               env: E) {\n     visitor.visit_ident(method_type.span, method_type.ident, env.clone());\n     visitor.visit_explicit_self(&method_type.explicit_self, env.clone());\n     for argument_type in method_type.decl.inputs.iter() {\n@@ -530,9 +530,9 @@ pub fn walk_ty_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     visitor.visit_ty(method_type.decl.output, env);\n }\n \n-pub fn walk_trait_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                   trait_method: &trait_method,\n-                                   env: E) {\n+pub fn walk_trait_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                  trait_method: &trait_method,\n+                                                  env: E) {\n     match *trait_method {\n         required(ref method_type) => {\n             visitor.visit_ty_method(method_type, env)\n@@ -541,20 +541,20 @@ pub fn walk_trait_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_struct_def<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                 struct_definition: @struct_def,\n-                                 _: ast::Ident,\n-                                 _: &Generics,\n-                                 _: NodeId,\n-                                 env: E) {\n+pub fn walk_struct_def<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                struct_definition: &struct_def,\n+                                                _: Ident,\n+                                                _: &Generics,\n+                                                _: NodeId,\n+                                                env: E) {\n     for field in struct_definition.fields.iter() {\n         visitor.visit_struct_field(field, env.clone())\n     }\n }\n \n-pub fn walk_struct_field<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                                   struct_field: &struct_field,\n-                                   env: E) {\n+pub fn walk_struct_field<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                  struct_field: &struct_field,\n+                                                  env: E) {\n     match struct_field.node.kind {\n         named_field(name, _) => {\n             visitor.visit_ident(struct_field.span, name, env.clone())\n@@ -565,7 +565,7 @@ pub fn walk_struct_field<E:Clone, V:Visitor<E>>(visitor: &mut V,\n     visitor.visit_ty(struct_field.node.ty, env)\n }\n \n-pub fn walk_block<E:Clone, V:Visitor<E>>(visitor: &mut V, block: P<Block>, env: E) {\n+pub fn walk_block<E: Clone, V: Visitor<E>>(visitor: &mut V, block: &Block, env: E) {\n     for view_item in block.view_items.iter() {\n         visitor.visit_view_item(view_item, env.clone())\n     }\n@@ -575,7 +575,7 @@ pub fn walk_block<E:Clone, V:Visitor<E>>(visitor: &mut V, block: P<Block>, env:\n     walk_expr_opt(visitor, block.expr, env)\n }\n \n-pub fn walk_stmt<E:Clone, V:Visitor<E>>(visitor: &mut V, statement: &Stmt, env: E) {\n+pub fn walk_stmt<E: Clone, V: Visitor<E>>(visitor: &mut V, statement: &Stmt, env: E) {\n     match statement.node {\n         StmtDecl(declaration, _) => visitor.visit_decl(declaration, env),\n         StmtExpr(expression, _) | StmtSemi(expression, _) => {\n@@ -585,35 +585,35 @@ pub fn walk_stmt<E:Clone, V:Visitor<E>>(visitor: &mut V, statement: &Stmt, env:\n     }\n }\n \n-pub fn walk_decl<E:Clone, V:Visitor<E>>(visitor: &mut V, declaration: &Decl, env: E) {\n+pub fn walk_decl<E: Clone, V: Visitor<E>>(visitor: &mut V, declaration: &Decl, env: E) {\n     match declaration.node {\n         DeclLocal(ref local) => visitor.visit_local(*local, env),\n         DeclItem(item) => visitor.visit_item(item, env),\n     }\n }\n \n-pub fn walk_expr_opt<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                         optional_expression: Option<@Expr>,\n-                         env: E) {\n+pub fn walk_expr_opt<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                              optional_expression: Option<@Expr>,\n+                                              env: E) {\n     match optional_expression {\n         None => {}\n         Some(expression) => visitor.visit_expr(expression, env),\n     }\n }\n \n-pub fn walk_exprs<E:Clone, V:Visitor<E>>(visitor: &mut V,\n-                            expressions: &[@Expr],\n-                            env: E) {\n+pub fn walk_exprs<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                           expressions: &[@Expr],\n+                                           env: E) {\n     for expression in expressions.iter() {\n         visitor.visit_expr(*expression, env.clone())\n     }\n }\n \n-pub fn walk_mac<E, V:Visitor<E>>(_: &mut V, _: &mac, _: E) {\n+pub fn walk_mac<E, V: Visitor<E>>(_: &mut V, _: &mac, _: E) {\n     // Empty!\n }\n \n-pub fn walk_expr<E:Clone, V:Visitor<E>>(visitor: &mut V, expression: @Expr, env: E) {\n+pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, env: E) {\n     match expression.node {\n         ExprVstore(subexpression, _) => {\n             visitor.visit_expr(subexpression, env.clone())\n@@ -745,7 +745,7 @@ pub fn walk_expr<E:Clone, V:Visitor<E>>(visitor: &mut V, expression: @Expr, env:\n     visitor.visit_expr_post(expression, env.clone())\n }\n \n-pub fn walk_arm<E:Clone, V:Visitor<E>>(visitor: &mut V, arm: &Arm, env: E) {\n+pub fn walk_arm<E: Clone, V: Visitor<E>>(visitor: &mut V, arm: &Arm, env: E) {\n     for pattern in arm.pats.iter() {\n         visitor.visit_pat(*pattern, env.clone())\n     }"}]}