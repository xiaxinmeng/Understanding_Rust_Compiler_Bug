{"sha": "b0e02f02186ff6d5bc8a7654b645ee26135f7709", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZTAyZjAyMTg2ZmY2ZDViYzhhNzY1NGI2NDVlZTI2MTM1Zjc3MDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-03T12:36:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-03T12:36:03Z"}, "message": "Auto merge of #1568 - fusion-engineering-forks:futex, r=RalfJung\n\nImplement futex_wait and futex_wake.\n\nFixes https://github.com/rust-lang/rust/issues/77406 and fixes #1562.\n\nThis makes std's park(), park_timeout(), and unpark() work. That means std::sync::Once is usable again and the test pass again with the latest rustc.\n\nThis also makes parking_lot work.", "tree": {"sha": "c37fb481132308cadbb99750bfc216fb708c54c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c37fb481132308cadbb99750bfc216fb708c54c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0e02f02186ff6d5bc8a7654b645ee26135f7709", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e02f02186ff6d5bc8a7654b645ee26135f7709", "html_url": "https://github.com/rust-lang/rust/commit/b0e02f02186ff6d5bc8a7654b645ee26135f7709", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0e02f02186ff6d5bc8a7654b645ee26135f7709/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "266b75faecd11e6a0b63fb6526fac56cda22bebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/266b75faecd11e6a0b63fb6526fac56cda22bebc", "html_url": "https://github.com/rust-lang/rust/commit/266b75faecd11e6a0b63fb6526fac56cda22bebc"}, {"sha": "68776d292196f4e890f860c1464ecc83af80859f", "url": "https://api.github.com/repos/rust-lang/rust/commits/68776d292196f4e890f860c1464ecc83af80859f", "html_url": "https://github.com/rust-lang/rust/commit/68776d292196f4e890f860c1464ecc83af80859f"}], "stats": {"total": 367, "additions": 364, "deletions": 3}, "files": [{"sha": "23bc54e76bb07284444dbcfe2d77fffddad9282c", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -555,7 +555,7 @@ pub fn check_arg_count<'a, 'tcx, const N: usize>(args: &'a [OpTy<'tcx, Tag>]) ->\n \n pub fn isolation_error(name: &str) -> InterpResult<'static> {\n     throw_machine_stop!(TerminationInfo::UnsupportedInIsolation(format!(\n-        \"`{}` not available when isolation is enabled\",\n+        \"{} not available when isolation is enabled\",\n         name,\n     )))\n }"}, {"sha": "364cfde6c0721a96cef188cebe4cd2db07edfb95", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -3,6 +3,7 @@ use rustc_middle::mir;\n use crate::*;\n use crate::helpers::check_arg_count;\n use shims::posix::fs::EvalContextExt as _;\n+use shims::posix::linux::sync::futex;\n use shims::posix::sync::EvalContextExt as _;\n use shims::posix::thread::EvalContextExt as _;\n \n@@ -112,6 +113,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamically invoked syscalls\n             \"syscall\" => {\n+                // FIXME: The libc syscall() function is a variadic function.\n+                // It's valid to call it with more arguments than a syscall\n+                // needs, so none of these syscalls should use check_arg_count.\n+                // It's even valid to call it with the wrong type of arguments,\n+                // as long as they'd end up in the same place with the calling\n+                // convention used. (E.g. using a `usize` instead of a pointer.)\n+                // It's not directly clear which number, size, and type of arguments\n+                // are acceptable in which cases and which aren't. (E.g. some\n+                // types might take up the space of two registers.)\n+                // So this needs to be researched first.\n+\n                 let sys_getrandom = this\n                     .eval_libc(\"SYS_getrandom\")?\n                     .to_machine_usize(this)?;\n@@ -120,6 +132,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .eval_libc(\"SYS_statx\")?\n                     .to_machine_usize(this)?;\n \n+                let sys_futex = this\n+                    .eval_libc(\"SYS_futex\")?\n+                    .to_machine_usize(this)?;\n+\n                 if args.is_empty() {\n                     throw_ub_format!(\"incorrect number of arguments for syscall: got 0, expected at least 1\");\n                 }\n@@ -139,6 +155,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         let result = this.linux_statx(dirfd, pathname, flags, mask, statxbuf)?;\n                         this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n                     }\n+                    // `futex` is used by some synchonization primitives.\n+                    id if id == sys_futex => {\n+                        futex(this, args, dest)?;\n+                    }\n                     id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n                 }\n             }"}, {"sha": "eba4a517cf5dc5b0c07675b43704f5d19d10e411", "filename": "src/shims/posix/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fshims%2Fposix%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fshims%2Fposix%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fmod.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -1,2 +1,3 @@\n pub mod foreign_items;\n pub mod dlsym;\n+pub mod sync;"}, {"sha": "d7ecb45279debc5a452844b465a43016d502e3e9", "filename": "src/shims/posix/linux/sync.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -0,0 +1,133 @@\n+use crate::thread::Time;\n+use crate::*;\n+use rustc_target::abi::{Align, Size};\n+use std::time::{Instant, SystemTime};\n+\n+/// Implementation of the SYS_futex syscall.\n+pub fn futex<'tcx>(\n+    this: &mut MiriEvalContext<'_, 'tcx>,\n+    args: &[OpTy<'tcx, Tag>],\n+    dest: PlaceTy<'tcx, Tag>,\n+) -> InterpResult<'tcx> {\n+    // The amount of arguments used depends on the type of futex operation.\n+    // The full futex syscall takes six arguments (excluding the syscall\n+    // number), which is also the maximum amount of arguments a linux syscall\n+    // can take on most architectures.\n+    // However, not all futex operations use all six arguments. The unused ones\n+    // may or may not be left out from the `syscall()` call.\n+    // Therefore we don't use `check_arg_count` here, but only check for the\n+    // number of arguments to fall within a range.\n+    if !(4..=7).contains(&args.len()) {\n+        throw_ub_format!(\"incorrect number of arguments for futex syscall: got {}, expected between 4 and 7 (inclusive)\", args.len());\n+    }\n+\n+    // The first three arguments (after the syscall number itself) are the same to all futex operations:\n+    //     (int *addr, int op, int val).\n+    // We checked above that these definitely exist.\n+    let addr = this.read_immediate(args[1])?;\n+    let op = this.read_scalar(args[2])?.to_i32()?;\n+    let val = this.read_scalar(args[3])?.to_i32()?;\n+\n+    // The raw pointer value is used to identify the mutex.\n+    // Not all mutex operations actually read from this address or even require this address to exist.\n+    // This will make FUTEX_WAKE fail on an integer cast to a pointer. But FUTEX_WAIT on\n+    // such a pointer can never work anyway, so that seems fine.\n+    let futex_ptr = this.force_ptr(addr.to_scalar()?)?;\n+\n+    let thread = this.get_active_thread();\n+\n+    let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n+    let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n+    let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\")?;\n+    let futex_realtime = this.eval_libc_i32(\"FUTEX_CLOCK_REALTIME\")?;\n+\n+    // FUTEX_PRIVATE enables an optimization that stops it from working across processes.\n+    // Miri doesn't support that anyway, so we ignore that flag.\n+    match op & !futex_private {\n+        // FUTEX_WAIT: (int *addr, int op = FUTEX_WAIT, int val, const timespec *timeout)\n+        // Blocks the thread if *addr still equals val. Wakes up when FUTEX_WAKE is called on the same address,\n+        // or *timeout expires. `timeout == null` for an infinite timeout.\n+        op if op & !futex_realtime == futex_wait => {\n+            if args.len() < 5 {\n+                throw_ub_format!(\"incorrect number of arguments for FUTEX_WAIT syscall: got {}, expected at least 5\", args.len());\n+            }\n+            let timeout = args[4];\n+            let timeout_time = if this.is_null(this.read_scalar(timeout)?.check_init()?)? {\n+                None\n+            } else {\n+                let duration = match this.read_timespec(timeout)? {\n+                    Some(duration) => duration,\n+                    None => {\n+                        let einval = this.eval_libc(\"EINVAL\")?;\n+                        this.set_last_error(einval)?;\n+                        this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                        return Ok(());\n+                    }\n+                };\n+                this.check_no_isolation(\"FUTEX_WAIT with timeout\")?;\n+                Some(if op & futex_realtime != 0 {\n+                    Time::RealTime(SystemTime::now().checked_add(duration).unwrap())\n+                } else {\n+                    Time::Monotonic(Instant::now().checked_add(duration).unwrap())\n+                })\n+            };\n+            // Check the pointer for alignment and validity.\n+            // The API requires `addr` to be a 4-byte aligned pointer, and will\n+            // use the 4 bytes at the given address as an (atomic) i32.\n+            this.memory.check_ptr_access(addr.to_scalar()?, Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n+            // Read an `i32` through the pointer, regardless of any wrapper types.\n+            // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n+            // FIXME: this fails if `addr` is not a pointer type.\n+            let futex_val = this.read_scalar_at_offset(addr.into(), 0, this.machine.layouts.i32)?.to_i32()?;\n+            if val == futex_val {\n+                // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n+                this.block_thread(thread);\n+                this.futex_wait(futex_ptr, thread);\n+                // Succesfully waking up from FUTEX_WAIT always returns zero.\n+                this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n+                // Register a timeout callback if a timeout was specified.\n+                // This callback will override the return value when the timeout triggers.\n+                if let Some(timeout_time) = timeout_time {\n+                    this.register_timeout_callback(\n+                        thread,\n+                        timeout_time,\n+                        Box::new(move |this| {\n+                            this.unblock_thread(thread);\n+                            this.futex_remove_waiter(futex_ptr, thread);\n+                            let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n+                            this.set_last_error(etimedout)?;\n+                            this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                            Ok(())\n+                        }),\n+                    );\n+                }\n+            } else {\n+                // The futex value doesn't match the expected value, so we return failure\n+                // right away without sleeping: -1 and errno set to EAGAIN.\n+                let eagain = this.eval_libc(\"EAGAIN\")?;\n+                this.set_last_error(eagain)?;\n+                this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+            }\n+        }\n+        // FUTEX_WAKE: (int *addr, int op = FUTEX_WAKE, int val)\n+        // Wakes at most `val` threads waiting on the futex at `addr`.\n+        // Returns the amount of threads woken up.\n+        // Does not access the futex value at *addr.\n+        op if op == futex_wake => {\n+            let mut n = 0;\n+            for _ in 0..val {\n+                if let Some(thread) = this.futex_wake(futex_ptr) {\n+                    this.unblock_thread(thread);\n+                    this.unregister_timeout_callback_if_exists(thread);\n+                    n += 1;\n+                } else {\n+                    break;\n+                }\n+            }\n+            this.write_scalar(Scalar::from_machine_isize(n, this), dest)?;\n+        }\n+        op => throw_unsup_format!(\"miri does not support SYS_futex operation {}\", op),\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "0c12da8d684562a51af5a8e50d1390ec032b5bc1", "filename": "src/sync.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -96,12 +96,26 @@ struct Condvar {\n     waiters: VecDeque<CondvarWaiter>,\n }\n \n+/// The futex state.\n+#[derive(Default, Debug)]\n+struct Futex {\n+    waiters: VecDeque<FutexWaiter>,\n+}\n+\n+/// A thread waiting on a futex.\n+#[derive(Debug)]\n+struct FutexWaiter {\n+    /// The thread that is waiting on this futex.\n+    thread: ThreadId,\n+}\n+\n /// The state of all synchronization variables.\n #[derive(Default, Debug)]\n pub(super) struct SynchronizationState {\n     mutexes: IndexVec<MutexId, Mutex>,\n     rwlocks: IndexVec<RwLockId, RwLock>,\n     condvars: IndexVec<CondvarId, Condvar>,\n+    futexes: HashMap<Pointer, Futex>,\n }\n \n // Private extension trait for local helper methods\n@@ -403,4 +417,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.machine.threads.sync.condvars[id].waiters.retain(|waiter| waiter.thread != thread);\n     }\n+\n+    fn futex_wait(&mut self, addr: Pointer<stacked_borrows::Tag>, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        let waiters = &mut this.machine.threads.sync.futexes.entry(addr.erase_tag()).or_default().waiters;\n+        assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n+        waiters.push_back(FutexWaiter { thread });\n+    }\n+\n+    fn futex_wake(&mut self, addr: Pointer<stacked_borrows::Tag>) -> Option<ThreadId> {\n+        let this = self.eval_context_mut();\n+        let waiters = &mut this.machine.threads.sync.futexes.get_mut(&addr.erase_tag())?.waiters;\n+        waiters.pop_front().map(|waiter| waiter.thread)\n+    }\n+\n+    fn futex_remove_waiter(&mut self, addr: Pointer<stacked_borrows::Tag>, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        if let Some(futex) = this.machine.threads.sync.futexes.get_mut(&addr.erase_tag()) {\n+            futex.waiters.retain(|waiter| waiter.thread != thread);\n+        }\n+    }\n }"}, {"sha": "4c6adc8bf406222c1fe415d64dadddf44d611eb5", "filename": "tests/compile-fail/fs/isolated_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Fcompile-fail%2Ffs%2Fisolated_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Fcompile-fail%2Ffs%2Fisolated_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Fisolated_file.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: File handling is not implemented yet\n-// error-pattern: `open` not available when isolation is enabled\n+// error-pattern: open not available when isolation is enabled\n \n fn main() {\n     let _file = std::fs::File::open(\"file.txt\").unwrap();"}, {"sha": "19ce064089aaafcf6a3e07f952d372518f6e3c5f", "filename": "tests/compile-fail/fs/isolated_stdin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Fcompile-fail%2Ffs%2Fisolated_stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Fcompile-fail%2Ffs%2Fisolated_stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Fisolated_stdin.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -7,7 +7,7 @@ extern crate libc;\n fn main() -> std::io::Result<()> {\n     let mut bytes = [0u8; 512];\n     unsafe {\n-        libc::read(0, bytes.as_mut_ptr() as *mut libc::c_void, 512); //~ ERROR `read` not available when isolation is enabled\n+        libc::read(0, bytes.as_mut_ptr() as *mut libc::c_void, 512); //~ ERROR read not available when isolation is enabled\n     }\n     Ok(())\n }"}, {"sha": "391e9524324aecbfdf71573571164bb6062c6c25", "filename": "tests/run-pass/concurrency/linux-futex.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -0,0 +1,132 @@\n+// Unfortunately, the test framework does not support 'only-linux',\n+// so we need to ignore Windows and macOS instead.\n+// ignore-macos: Uses Linux-only APIs\n+// ignore-windows: Uses Linux-only APIs\n+// compile-flags: -Zmiri-disable-isolation\n+\n+#![feature(rustc_private)]\n+extern crate libc;\n+\n+use std::ptr;\n+use std::thread;\n+use std::time::{Duration, Instant};\n+\n+fn wake_nobody() {\n+    let futex = 0;\n+\n+    // Wake 1 waiter. Expect zero waiters woken up, as nobody is waiting.\n+    unsafe {\n+        assert_eq!(libc::syscall(\n+            libc::SYS_futex,\n+            &futex as *const i32,\n+            libc::FUTEX_WAKE,\n+            1,\n+        ), 0);\n+    }\n+\n+    // Same, but without omitting the unused arguments.\n+    unsafe {\n+        assert_eq!(libc::syscall(\n+            libc::SYS_futex,\n+            &futex as *const i32,\n+            libc::FUTEX_WAKE,\n+            1,\n+            0,\n+            0,\n+            0,\n+        ), 0);\n+    }\n+}\n+\n+fn wake_dangling() {\n+    let futex = Box::new(0);\n+    let ptr: *const i32 = &*futex;\n+    drop(futex);\n+\n+    // Wake 1 waiter. Expect zero waiters woken up, as nobody is waiting.\n+    unsafe {\n+        assert_eq!(libc::syscall(\n+            libc::SYS_futex,\n+            ptr,\n+            libc::FUTEX_WAKE,\n+            1,\n+        ), 0);\n+    }\n+}\n+\n+fn wait_wrong_val() {\n+    let futex: i32 = 123;\n+\n+    // Only wait if the futex value is 456.\n+    unsafe {\n+        assert_eq!(libc::syscall(\n+            libc::SYS_futex,\n+            &futex as *const i32,\n+            libc::FUTEX_WAIT,\n+            456,\n+            ptr::null::<libc::timespec>(),\n+        ), -1);\n+        assert_eq!(*libc::__errno_location(), libc::EAGAIN);\n+    }\n+}\n+\n+fn wait_timeout() {\n+    let start = Instant::now();\n+\n+    let futex: i32 = 123;\n+\n+    // Wait for 200ms, with nobody waking us up early.\n+    unsafe {\n+        assert_eq!(libc::syscall(\n+            libc::SYS_futex,\n+            &futex as *const i32,\n+            libc::FUTEX_WAIT,\n+            123,\n+            &libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 200_000_000,\n+            },\n+        ), -1);\n+        assert_eq!(*libc::__errno_location(), libc::ETIMEDOUT);\n+    }\n+\n+    assert!((200..500).contains(&start.elapsed().as_millis()));\n+}\n+\n+fn wait_wake() {\n+    let start = Instant::now();\n+\n+    static FUTEX: i32 = 0;\n+\n+    thread::spawn(move || {\n+        thread::sleep(Duration::from_millis(200));\n+        unsafe {\n+            assert_eq!(libc::syscall(\n+                libc::SYS_futex,\n+                &FUTEX as *const i32,\n+                libc::FUTEX_WAKE,\n+                10, // Wake up at most 10 threads.\n+            ), 1); // Woken up one thread.\n+        }\n+    });\n+\n+    unsafe {\n+        assert_eq!(libc::syscall(\n+            libc::SYS_futex,\n+            &FUTEX as *const i32,\n+            libc::FUTEX_WAIT,\n+            0,\n+            ptr::null::<libc::timespec>(),\n+        ), 0);\n+    }\n+\n+    assert!((200..500).contains(&start.elapsed().as_millis()));\n+}\n+\n+fn main() {\n+    wake_nobody();\n+    wake_dangling();\n+    wait_wrong_val();\n+    wait_timeout();\n+    wait_wake();\n+}"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/concurrency/linux-futex.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.stderr?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental. For example, Miri does not detect data races yet.\n+"}, {"sha": "1ed742931fe6bf0bfbf02c85cc24cf1100f48fe9", "filename": "tests/run-pass/concurrency/parking.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Frun-pass%2Fconcurrency%2Fparking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Frun-pass%2Fconcurrency%2Fparking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fparking.rs?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -0,0 +1,37 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::thread;\n+use std::time::{Duration, Instant};\n+\n+// Normally, waiting in park/park_timeout may spuriously wake up early, but we\n+// know Miri's timed synchronization primitives do not do that.\n+\n+fn park_timeout() {\n+    let start = Instant::now();\n+\n+    thread::park_timeout(Duration::from_millis(200));\n+\n+    assert!((200..500).contains(&start.elapsed().as_millis()));\n+}\n+\n+fn park_unpark() {\n+    let t1 = thread::current();\n+    let t2 = thread::spawn(move || {\n+        thread::park();\n+        thread::sleep(Duration::from_millis(200));\n+        t1.unpark();\n+    });\n+\n+    let start = Instant::now();\n+\n+    t2.thread().unpark();\n+    thread::park();\n+\n+    assert!((200..500).contains(&start.elapsed().as_millis()));\n+}\n+\n+fn main() {\n+    park_timeout();\n+    park_unpark();\n+}"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/concurrency/parking.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Frun-pass%2Fconcurrency%2Fparking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b0e02f02186ff6d5bc8a7654b645ee26135f7709/tests%2Frun-pass%2Fconcurrency%2Fparking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fparking.stderr?ref=b0e02f02186ff6d5bc8a7654b645ee26135f7709", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental. For example, Miri does not detect data races yet.\n+"}]}