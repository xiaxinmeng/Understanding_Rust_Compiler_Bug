{"sha": "08321f1c49d75e60a2c56320a3f1483e7bf79a91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MzIxZjFjNDlkNzVlNjBhMmM1NjMyMGEzZjE0ODNlN2JmNzlhOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-03T20:16:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-03T20:16:48Z"}, "message": "auto merge of #11149 : alexcrichton/rust/remove-either, r=brson\n\nHad to change some stuff in typeck to bootstrap (getting methods in fmt off of Either), but other than that not so painful.\r\n\r\nCloses #9157", "tree": {"sha": "fd429cf0c3cd63379bef08c36fd9acf0f3e0d82a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd429cf0c3cd63379bef08c36fd9acf0f3e0d82a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08321f1c49d75e60a2c56320a3f1483e7bf79a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08321f1c49d75e60a2c56320a3f1483e7bf79a91", "html_url": "https://github.com/rust-lang/rust/commit/08321f1c49d75e60a2c56320a3f1483e7bf79a91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08321f1c49d75e60a2c56320a3f1483e7bf79a91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11ce6b709ace233e473eddb26e3e23c2c4c16cdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/11ce6b709ace233e473eddb26e3e23c2c4c16cdd", "html_url": "https://github.com/rust-lang/rust/commit/11ce6b709ace233e473eddb26e3e23c2c4c16cdd"}, {"sha": "4bea679dbe3ba98049ac700d84ad48271753ce40", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bea679dbe3ba98049ac700d84ad48271753ce40", "html_url": "https://github.com/rust-lang/rust/commit/4bea679dbe3ba98049ac700d84ad48271753ce40"}], "stats": {"total": 455, "additions": 114, "deletions": 341}, "files": [{"sha": "63e19df9519e5b10893d8549e5b578c59d75059d", "filename": "src/libextra/test.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -337,9 +337,14 @@ pub enum TestResult {\n     TrBench(BenchSamples),\n }\n \n+enum OutputLocation<T> {\n+    Pretty(term::Terminal<T>),\n+    Raw(T),\n+}\n+\n struct ConsoleTestState<T> {\n     log_out: Option<File>,\n-    out: Either<term::Terminal<T>, T>,\n+    out: OutputLocation<T>,\n     use_color: bool,\n     total: uint,\n     passed: uint,\n@@ -358,8 +363,8 @@ impl<T: Writer> ConsoleTestState<T> {\n             None => None\n         };\n         let out = match term::Terminal::new(io::stdout()) {\n-            Err(_) => Right(io::stdout()),\n-            Ok(t) => Left(t)\n+            Err(_) => Raw(io::stdout()),\n+            Ok(t) => Pretty(t)\n         };\n         ConsoleTestState {\n             out: out,\n@@ -416,7 +421,7 @@ impl<T: Writer> ConsoleTestState<T> {\n                         word: &str,\n                         color: term::color::Color) {\n         match self.out {\n-            Left(ref mut term) => {\n+            Pretty(ref mut term) => {\n                 if self.use_color {\n                     term.fg(color);\n                 }\n@@ -425,14 +430,14 @@ impl<T: Writer> ConsoleTestState<T> {\n                     term.reset();\n                 }\n             }\n-            Right(ref mut stdout) => stdout.write(word.as_bytes())\n+            Raw(ref mut stdout) => stdout.write(word.as_bytes())\n         }\n     }\n \n     pub fn write_plain(&mut self, s: &str) {\n         match self.out {\n-            Left(ref mut term) => term.write(s.as_bytes()),\n-            Right(ref mut stdout) => stdout.write(s.as_bytes())\n+            Pretty(ref mut term) => term.write(s.as_bytes()),\n+            Raw(ref mut stdout) => stdout.write(s.as_bytes())\n         }\n     }\n \n@@ -683,7 +688,7 @@ fn should_sort_failures_before_printing_them() {\n \n     let mut st = ConsoleTestState {\n         log_out: None,\n-        out: Right(MemWriter::new()),\n+        out: Raw(MemWriter::new()),\n         use_color: false,\n         total: 0u,\n         passed: 0u,\n@@ -697,8 +702,8 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures();\n     let s = match st.out {\n-        Right(ref m) => str::from_utf8(*m.inner_ref()),\n-        Left(_) => unreachable!()\n+        Raw(ref m) => str::from_utf8(*m.inner_ref()),\n+        Pretty(_) => unreachable!()\n     };\n \n     let apos = s.find_str(\"a\").unwrap();"}, {"sha": "9bdcd191360b2bc4f94dbae64df0666a7cbb9df1", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -1705,9 +1705,12 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 fn_inputs.map(|a| *a)\n             } else {\n                 let msg = format!(\n-                    \"this function takes at least {0, plural, =1{# parameter} \\\n-                    other{# parameters}} but {1, plural, =1{# parameter was} \\\n-                    other{# parameters were}} supplied\", expected_arg_count, supplied_arg_count);\n+                    \"this function takes at least {} parameter{} \\\n+                     but {} parameter{} supplied\",\n+                     expected_arg_count,\n+                     if expected_arg_count == 1 {\"\"} else {\"s\"},\n+                     supplied_arg_count,\n+                     if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n \n                 tcx.sess.span_err(sp, msg);\n \n@@ -1722,10 +1725,12 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                                   the `for` keyword)\"\n             };\n             let msg = format!(\n-                \"this function takes {0, plural, =1{# parameter} \\\n-                other{# parameters}} but {1, plural, =1{# parameter was} \\\n-                other{# parameters were}} supplied{2}\",\n-                expected_arg_count, supplied_arg_count, suffix);\n+                \"this function takes {} parameter{} \\\n+                 but {} parameter{} supplied{}\",\n+                 expected_arg_count, if expected_arg_count == 1 {\"\"} else {\"s\"},\n+                 supplied_arg_count,\n+                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"},\n+                 suffix);\n \n             tcx.sess.span_err(sp, msg);\n "}, {"sha": "d07006aa6de7548c09f162e53b9da94bbe196e50", "filename": "src/libstd/either.rs", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/11ce6b709ace233e473eddb26e3e23c2c4c16cdd/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ce6b709ace233e473eddb26e3e23c2c4c16cdd/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=11ce6b709ace233e473eddb26e3e23c2c4c16cdd", "patch": "@@ -1,248 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Representing values with two possibilities (`Either` type)\n-\n-#[allow(missing_doc)];\n-\n-use option::{Some, None};\n-use clone::Clone;\n-use container::Container;\n-use cmp::Eq;\n-use iter::{Iterator, FilterMap};\n-use str::StrSlice;\n-use vec;\n-use vec::{OwnedVector, ImmutableVector};\n-\n-/// `Either` is a type that represents one of two alternatives\n-#[deriving(Clone, Eq, IterBytes)]\n-pub enum Either<L, R> {\n-    Left(L),\n-    Right(R)\n-}\n-\n-impl<L, R> Either<L, R> {\n-    /// Applies a function based on the given either value\n-    ///\n-    /// If `value` is `Left(L)` then `f_left` is applied to its contents, if\n-    /// `value` is `Right(R)` then `f_right` is applied to its contents, and the\n-    /// result is returned.\n-    #[inline]\n-    pub fn either<T>(&self, f_left: |&L| -> T, f_right: |&R| -> T) -> T {\n-        match *self {\n-            Left(ref l) => f_left(l),\n-            Right(ref r) => f_right(r)\n-        }\n-    }\n-\n-    /// Flips between left and right of a given `Either`\n-    #[inline]\n-    pub fn flip(self) -> Either<R, L> {\n-        match self {\n-            Right(r) => Left(r),\n-            Left(l) => Right(l)\n-        }\n-    }\n-\n-    /// Checks whether the given value is a `Left`\n-    #[inline]\n-    pub fn is_left(&self) -> bool {\n-        match *self {\n-            Left(_) => true,\n-            _ => false\n-        }\n-    }\n-\n-    /// Checks whether the given value is a `Right`\n-    #[inline]\n-    pub fn is_right(&self) -> bool {\n-        match *self {\n-            Right(_) => true,\n-            _ => false\n-        }\n-    }\n-\n-    /// Retrieves the value from a `Left`.\n-    /// Fails with a specified reason if the `Either` is `Right`.\n-    #[inline]\n-    pub fn expect_left(self, reason: &str) -> L {\n-        match self {\n-            Left(x) => x,\n-            Right(_) => fail!(\"{}\", reason.to_owned())\n-        }\n-    }\n-\n-    /// Retrieves the value from a `Left`. Fails if the `Either` is `Right`.\n-    #[inline]\n-    pub fn unwrap_left(self) -> L {\n-        self.expect_left(\"called Either::unwrap_left()` on `Right` value\")\n-    }\n-\n-    /// Retrieves the value from a `Right`.\n-    /// Fails with a specified reason if the `Either` is `Left`.\n-    #[inline]\n-    pub fn expect_right(self, reason: &str) -> R {\n-        match self {\n-            Right(x) => x,\n-            Left(_) => fail!(\"{}\", reason.to_owned())\n-        }\n-    }\n-\n-    /// Retrieves the value from a `Right`. Fails if the `Either` is `Left`.\n-    #[inline]\n-    pub fn unwrap_right(self) -> R {\n-        self.expect_right(\"called Either::unwrap_right()` on `Left` value\")\n-    }\n-}\n-\n-/// An iterator yielding the `Left` values of its source\n-pub type Lefts<L, R, Iter> = FilterMap<'static, Either<L, R>, L, Iter>;\n-\n-/// An iterator yielding the `Right` values of its source\n-pub type Rights<L, R, Iter> = FilterMap<'static, Either<L, R>, R, Iter>;\n-\n-/// Extracts all the left values\n-pub fn lefts<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n-    -> Lefts<L, R, Iter> {\n-    eithers.filter_map(|elt| {\n-        match elt {\n-            Left(x) => Some(x),\n-            _ => None,\n-        }\n-    })\n-}\n-\n-/// Extracts all the right values\n-pub fn rights<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n-    -> Rights<L, R, Iter> {\n-    eithers.filter_map(|elt| {\n-        match elt {\n-            Right(x) => Some(x),\n-            _ => None,\n-        }\n-    })\n-}\n-\n-\n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Extracts from a vector of either all the left values and right values\n-///\n-/// Returns a structure containing a vector of left values and a vector of\n-/// right values.\n-pub fn partition<L, R>(eithers: ~[Either<L, R>]) -> (~[L], ~[R]) {\n-    let n_lefts = eithers.iter().count(|elt| elt.is_left());\n-    let mut lefts = vec::with_capacity(n_lefts);\n-    let mut rights = vec::with_capacity(eithers.len() - n_lefts);\n-    for elt in eithers.move_iter() {\n-        match elt {\n-            Left(l) => lefts.push(l),\n-            Right(r) => rights.push(r)\n-        }\n-    }\n-    return (lefts, rights);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_either_left() {\n-        let val = Left(10);\n-        fn f_left(x: &int) -> bool { *x == 10 }\n-        fn f_right(_x: &uint) -> bool { false }\n-        assert!(val.either(f_left, f_right));\n-    }\n-\n-    #[test]\n-    fn test_either_right() {\n-        let val = Right(10u);\n-        fn f_left(_x: &int) -> bool { false }\n-        fn f_right(x: &uint) -> bool { *x == 10u }\n-        assert!(val.either(f_left, f_right));\n-    }\n-\n-    #[test]\n-    fn test_lefts() {\n-        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-        let result = lefts(input.move_iter()).to_owned_vec();\n-        assert_eq!(result, ~[10, 12, 14]);\n-    }\n-\n-    #[test]\n-    fn test_lefts_none() {\n-        let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n-        let result = lefts(input.move_iter()).to_owned_vec();\n-        assert_eq!(result.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_lefts_empty() {\n-        let input: ~[Either<int, int>] = ~[];\n-        let result = lefts(input.move_iter()).to_owned_vec();\n-        assert_eq!(result.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_rights() {\n-        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-        let result = rights(input.move_iter()).to_owned_vec();\n-        assert_eq!(result, ~[11, 13]);\n-    }\n-\n-    #[test]\n-    fn test_rights_none() {\n-        let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n-        let result = rights(input.move_iter()).to_owned_vec();\n-        assert_eq!(result.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_rights_empty() {\n-        let input: ~[Either<int, int>] = ~[];\n-        let result = rights(input.move_iter()).to_owned_vec();\n-        assert_eq!(result.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_partition() {\n-        let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-        let (lefts, rights) = partition(input);\n-        assert_eq!(lefts[0], 10);\n-        assert_eq!(lefts[1], 12);\n-        assert_eq!(lefts[2], 14);\n-        assert_eq!(rights[0], 11);\n-        assert_eq!(rights[1], 13);\n-    }\n-\n-    #[test]\n-    fn test_partition_no_lefts() {\n-        let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n-        let (lefts, rights) = partition(input);\n-        assert_eq!(lefts.len(), 0u);\n-        assert_eq!(rights.len(), 2u);\n-    }\n-\n-    #[test]\n-    fn test_partition_no_rights() {\n-        let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n-        let (lefts, rights) = partition(input);\n-        assert_eq!(lefts.len(), 2u);\n-        assert_eq!(rights.len(), 0u);\n-    }\n-\n-    #[test]\n-    fn test_partition_empty() {\n-        let input: ~[Either<int, int>] = ~[];\n-        let (lefts, rights) = partition(input);\n-        assert_eq!(lefts.len(), 0u);\n-        assert_eq!(rights.len(), 0u);\n-    }\n-}"}, {"sha": "53eaf17c7f876856346a457212e70256801f50c4", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -757,7 +757,7 @@ impl<'a> Formatter<'a> {\n                 // offsetted value\n                 for s in selectors.iter() {\n                     match s.selector {\n-                        Right(val) if value == val => {\n+                        rt::Literal(val) if value == val => {\n                             return self.runplural(value, s.result);\n                         }\n                         _ => {}\n@@ -769,17 +769,17 @@ impl<'a> Formatter<'a> {\n                 let value = value - match offset { Some(i) => i, None => 0 };\n                 for s in selectors.iter() {\n                     let run = match s.selector {\n-                        Left(parse::Zero) => value == 0,\n-                        Left(parse::One) => value == 1,\n-                        Left(parse::Two) => value == 2,\n+                        rt::Keyword(parse::Zero) => value == 0,\n+                        rt::Keyword(parse::One) => value == 1,\n+                        rt::Keyword(parse::Two) => value == 2,\n \n                         // XXX: Few/Many should have a user-specified boundary\n                         //      One possible option would be in the function\n                         //      pointer of the 'arg: Argument' struct.\n-                        Left(parse::Few) => value < 8,\n-                        Left(parse::Many) => value >= 8,\n+                        rt::Keyword(parse::Few) => value < 8,\n+                        rt::Keyword(parse::Many) => value >= 8,\n \n-                        Right(..) => false\n+                        rt::Literal(..) => false\n                     };\n                     if run {\n                         return self.runplural(value, s.result);"}, {"sha": "0ac1aac238087f42459faf16a5af0ec942f32279", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -122,12 +122,21 @@ pub enum Method<'a> {\n     Select(~[SelectArm<'a>], ~[Piece<'a>]),\n }\n \n+/// A selector for what pluralization a plural method should take\n+#[deriving(Eq, IterBytes)]\n+pub enum PluralSelector {\n+    /// One of the plural keywords should be used\n+    Keyword(PluralKeyword),\n+    /// A literal pluralization should be used\n+    Literal(uint),\n+}\n+\n /// Structure representing one \"arm\" of the `plural` function.\n #[deriving(Eq)]\n pub struct PluralArm<'a> {\n     /// A selector can either be specified by a keyword or with an integer\n     /// literal.\n-    selector: Either<PluralKeyword, uint>,\n+    selector: PluralSelector,\n     /// Array of pieces which are the format of this arm\n     result: ~[Piece<'a>],\n }\n@@ -504,29 +513,29 @@ impl<'a> Parser<'a> {\n             let mut isother = false;\n             let selector = if self.wsconsume('=') {\n                 match self.integer() {\n-                    Some(i) => Right(i),\n+                    Some(i) => Literal(i),\n                     None => {\n                         self.err(\"plural `=` selectors must be followed by an \\\n                                   integer\");\n-                        Right(0)\n+                        Literal(0)\n                     }\n                 }\n             } else {\n                 let word = self.word();\n                 match word {\n-                    \"other\" => { isother = true; Left(Zero) }\n-                    \"zero\"  => Left(Zero),\n-                    \"one\"   => Left(One),\n-                    \"two\"   => Left(Two),\n-                    \"few\"   => Left(Few),\n-                    \"many\"  => Left(Many),\n+                    \"other\" => { isother = true; Keyword(Zero) }\n+                    \"zero\"  => Keyword(Zero),\n+                    \"one\"   => Keyword(One),\n+                    \"two\"   => Keyword(Two),\n+                    \"few\"   => Keyword(Few),\n+                    \"many\"  => Keyword(Many),\n                     word    => {\n                         self.err(format!(\"unexpected plural selector `{}`\",\n                                          word));\n                         if word == \"\" {\n                             break\n                         } else {\n-                            Left(Zero)\n+                            Keyword(Zero)\n                         }\n                     }\n                 }\n@@ -955,9 +964,9 @@ mod tests {\n             position: ArgumentNext,\n             format: fmtdflt(),\n             method: Some(~Plural(Some(1), ~[\n-                PluralArm{ selector: Right(2), result: ~[String(\"2\")] },\n-                PluralArm{ selector: Right(3), result: ~[String(\"3\")] },\n-                PluralArm{ selector: Left(Many), result: ~[String(\"yes\")] }\n+                PluralArm{ selector: Literal(2), result: ~[String(\"2\")] },\n+                PluralArm{ selector: Literal(3), result: ~[String(\"3\")] },\n+                PluralArm{ selector: Keyword(Many), result: ~[String(\"yes\")] }\n             ], ~[String(\"haha\")]))\n         })]);\n     }"}, {"sha": "89895f305855aa027e1c8bcbd4d3d263da2f8d55", "filename": "src/libstd/fmt/rt.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -17,7 +17,6 @@\n #[allow(missing_doc)];\n #[doc(hidden)];\n \n-use either::Either;\n use fmt::parse;\n use option::Option;\n \n@@ -55,8 +54,13 @@ pub enum Method<'a> {\n     Select(&'a [SelectArm<'a>], &'a [Piece<'a>]),\n }\n \n+pub enum PluralSelector {\n+    Keyword(parse::PluralKeyword),\n+    Literal(uint),\n+}\n+\n pub struct PluralArm<'a> {\n-    selector: Either<parse::PluralKeyword, uint>,\n+    selector: PluralSelector,\n     result: &'a [Piece<'a>],\n }\n "}, {"sha": "1d24c2c66f80a0b1736c5f198e7a743d07e5bb49", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -148,7 +148,6 @@ pub mod any;\n \n pub mod option;\n pub mod result;\n-pub mod either;\n pub mod hashmap;\n pub mod cell;\n pub mod trie;"}, {"sha": "e1478de9485abc77a71f5ddcff2a7317b1087ab0", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -29,7 +29,6 @@ Rust's prelude has three main parts:\n */\n \n // Reexported core operators\n-pub use either::{Either, Left, Right};\n pub use kinds::{Freeze, Pod, Send, Sized};\n pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};"}, {"sha": "6c0424b50e108822f08c649bf284d20a7ae10bb9", "filename": "src/libstd/util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -82,7 +82,6 @@ mod tests {\n     use clone::Clone;\n     use ops::Drop;\n     use option::{None, Some};\n-    use either::{Either, Left, Right};\n     use mem::size_of;\n \n     #[test]\n@@ -111,15 +110,6 @@ mod tests {\n         assert!(y.is_some());\n     }\n \n-    #[test]\n-    fn test_uninhabited() {\n-        let could_only_be_coin : Either <Void, ()> = Right (());\n-        match could_only_be_coin {\n-            Right (coin) => coin,\n-            Left (is_void) => is_void.uninhabited ()\n-        }\n-    }\n-\n     #[test]\n     fn test_noncopyable() {\n         assert_eq!(size_of::<NonCopyable>(), 0);"}, {"sha": "d04e2e91d640d2c63905747a0c70f0cfddd7158c", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -28,6 +28,11 @@ enum ArgumentType {\n     String,\n }\n \n+enum Position {\n+    Exact(uint),\n+    Named(@str),\n+}\n+\n struct Context<'a> {\n     ecx: &'a mut ExtCtxt,\n     fmtsp: Span,\n@@ -148,10 +153,10 @@ impl<'a> Context<'a> {\n                         if self.check_positional_ok() {\n                             self.next_arg += 1;\n                         }\n-                        Left(i)\n+                        Exact(i)\n                     }\n-                    parse::ArgumentIs(i) => Left(i),\n-                    parse::ArgumentNamed(s) => Right(s.to_managed()),\n+                    parse::ArgumentIs(i) => Exact(i),\n+                    parse::ArgumentNamed(s) => Named(s.to_managed()),\n                 };\n \n                 // and finally the method being applied\n@@ -176,14 +181,14 @@ impl<'a> Context<'a> {\n         match c {\n             parse::CountImplied | parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n-                self.verify_arg_type(Left(i), Unsigned);\n+                self.verify_arg_type(Exact(i), Unsigned);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Right(s.to_managed()), Unsigned);\n+                self.verify_arg_type(Named(s.to_managed()), Unsigned);\n             }\n             parse::CountIsNextParam => {\n                 if self.check_positional_ok() {\n-                    self.verify_arg_type(Left(self.next_arg), Unsigned);\n+                    self.verify_arg_type(Exact(self.next_arg), Unsigned);\n                     self.next_arg += 1;\n                 }\n             }\n@@ -200,7 +205,7 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    fn verify_method(&mut self, pos: Either<uint, @str>, m: &parse::Method) {\n+    fn verify_method(&mut self, pos: Position, m: &parse::Method) {\n         self.nest_level += 1;\n         match *m {\n             parse::Plural(_, ref arms, ref default) => {\n@@ -209,12 +214,12 @@ impl<'a> Context<'a> {\n                 for arm in arms.iter() {\n                     if !seen_cases.insert(arm.selector) {\n                         match arm.selector {\n-                            Left(name) => {\n+                            parse::Keyword(name) => {\n                                 self.ecx.span_err(self.fmtsp,\n                                                   format!(\"duplicate selector \\\n                                                            `{:?}`\", name));\n                             }\n-                            Right(idx) => {\n+                            parse::Literal(idx) => {\n                                 self.ecx.span_err(self.fmtsp,\n                                                   format!(\"duplicate selector \\\n                                                            `={}`\", idx));\n@@ -245,9 +250,9 @@ impl<'a> Context<'a> {\n         self.nest_level -= 1;\n     }\n \n-    fn verify_arg_type(&mut self, arg: Either<uint, @str>, ty: ArgumentType) {\n+    fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n         match arg {\n-            Left(arg) => {\n+            Exact(arg) => {\n                 if arg < 0 || self.args.len() <= arg {\n                     let msg = format!(\"invalid reference to argument `{}` (there \\\n                                     are {} arguments)\", arg, self.args.len());\n@@ -260,7 +265,7 @@ impl<'a> Context<'a> {\n                 }\n             }\n \n-            Right(name) => {\n+            Named(name) => {\n                 let span = match self.names.find(&name) {\n                     Some(e) => e.span,\n                     None => {\n@@ -434,18 +439,16 @@ impl<'a> Context<'a> {\n                             self.trans_piece(p)\n                         }).collect();\n                         let (lr, selarg) = match arm.selector {\n-                            Left(t) => {\n+                            parse::Keyword(t) => {\n                                 let p = ctpath(format!(\"{:?}\", t));\n                                 let p = self.ecx.path_global(sp, p);\n-                                (self.ecx.ident_of(\"Left\"),\n-                                 self.ecx.expr_path(p))\n+                                (rtpath(\"Keyword\"), self.ecx.expr_path(p))\n                             }\n-                            Right(i) => {\n-                                (self.ecx.ident_of(\"Right\"),\n-                                 self.ecx.expr_uint(sp, i))\n+                            parse::Literal(i) => {\n+                                (rtpath(\"Literal\"), self.ecx.expr_uint(sp, i))\n                             }\n                         };\n-                        let selector = self.ecx.expr_call_ident(sp,\n+                        let selector = self.ecx.expr_call_global(sp,\n                                 lr, ~[selarg]);\n                         self.ecx.expr_struct(sp, p, ~[\n                             self.ecx.field_imm(sp,\n@@ -617,7 +620,7 @@ impl<'a> Context<'a> {\n             let name = self.ecx.ident_of(format!(\"__arg{}\", i));\n             let e = self.ecx.expr_addr_of(e.span, e);\n             lets.push(self.ecx.stmt_let(e.span, false, name, e));\n-            locals.push(self.format_arg(e.span, Left(i),\n+            locals.push(self.format_arg(e.span, Exact(i),\n                                         self.ecx.expr_ident(e.span, name)));\n         }\n         for (&name, &e) in self.names.iter() {\n@@ -627,7 +630,7 @@ impl<'a> Context<'a> {\n             let e = self.ecx.expr_addr_of(e.span, e);\n             lets.push(self.ecx.stmt_let(e.span, false, lname, e));\n             names[*self.name_positions.get(&name)] =\n-                Some(self.format_arg(e.span, Right(name),\n+                Some(self.format_arg(e.span, Named(name),\n                                      self.ecx.expr_ident(e.span, lname)));\n         }\n \n@@ -662,11 +665,11 @@ impl<'a> Context<'a> {\n                                            Some(result)))\n     }\n \n-    fn format_arg(&self, sp: Span, argno: Either<uint, @str>,\n+    fn format_arg(&self, sp: Span, argno: Position,\n                   arg: @ast::Expr) -> @ast::Expr {\n         let ty = match argno {\n-            Left(i) => self.arg_types[i].unwrap(),\n-            Right(s) => *self.name_types.get(&s)\n+            Exact(i) => self.arg_types[i].unwrap(),\n+            Named(s) => *self.name_types.get(&s)\n         };\n \n         let fmt_trait = match ty {"}, {"sha": "be93c9621373c04d201d318f1d68d480e24c16ce", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -19,7 +19,6 @@ use parse::token::{str_to_ident};\n \n use std::cast::transmute;\n use std::char;\n-use std::either;\n use std::num::from_str_radix;\n use std::util;\n \n@@ -475,34 +474,35 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     c = rdr.curr;\n     nextch(rdr);\n     if c == 'u' || c == 'i' {\n+        enum Result { Signed(ast::int_ty), Unsigned(ast::uint_ty) }\n         let signed = c == 'i';\n         let mut tp = {\n-            if signed { either::Left(ast::ty_i) }\n-            else { either::Right(ast::ty_u) }\n+            if signed { Signed(ast::ty_i) }\n+            else { Unsigned(ast::ty_u) }\n         };\n         bump(rdr);\n         c = rdr.curr;\n         if c == '8' {\n             bump(rdr);\n-            tp = if signed { either::Left(ast::ty_i8) }\n-                      else { either::Right(ast::ty_u8) };\n+            tp = if signed { Signed(ast::ty_i8) }\n+                      else { Unsigned(ast::ty_u8) };\n         }\n         n = nextch(rdr);\n         if c == '1' && n == '6' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { either::Left(ast::ty_i16) }\n-                      else { either::Right(ast::ty_u16) };\n+            tp = if signed { Signed(ast::ty_i16) }\n+                      else { Unsigned(ast::ty_u16) };\n         } else if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { either::Left(ast::ty_i32) }\n-                      else { either::Right(ast::ty_u32) };\n+            tp = if signed { Signed(ast::ty_i32) }\n+                      else { Unsigned(ast::ty_u32) };\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { either::Left(ast::ty_i64) }\n-                      else { either::Right(ast::ty_u64) };\n+            tp = if signed { Signed(ast::ty_i64) }\n+                      else { Unsigned(ast::ty_u64) };\n         }\n         if num_str.len() == 0u {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n@@ -515,8 +515,8 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         };\n \n         match tp {\n-          either::Left(t) => return token::LIT_INT(parsed as i64, t),\n-          either::Right(t) => return token::LIT_UINT(parsed, t)\n+          Signed(t) => return token::LIT_INT(parsed as i64, t),\n+          Unsigned(t) => return token::LIT_UINT(parsed, t)\n         }\n     }\n     let mut is_float = false;"}, {"sha": "1bd791ad5e01e9c43f91b08774be3025520f561a", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+enum Either<T, U> { Left(T), Right(U) }\n+\n struct X(Either<(uint,uint),extern fn()>);\n \n impl X {"}, {"sha": "300efbbc4fabb85fcb80f2c753cfbe7258c1ca95", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::either::{Either, Left, Right};\n+enum Either<T, U> { Left(T), Right(U) }\n \n     fn f(x: &mut Either<int,f64>, y: &Either<int,f64>) -> int {\n         match *y {"}, {"sha": "326d2e1c852822cab966399a43d1518deccb71e5", "filename": "src/test/compile-fail/issue-5358-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Fissue-5358-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Fissue-5358-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5358-1.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+enum Either<T, U> { Left(T), Right(U) }\n struct S(Either<uint, uint>);\n \n fn main() {\n     match S(Left(5)) {\n-        Right(_) => {}  //~ ERROR mismatched types: expected `S` but found `std::either::Either\n+        Right(_) => {}  //~ ERROR mismatched types: expected `S` but found `Either\n         _ => {}\n     }\n }"}, {"sha": "b9540fe2cf02b365e444b5cce2c194dc67764e7f", "filename": "src/test/compile-fail/issue-5358.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Fissue-5358.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Fissue-5358.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5358.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+enum Either<T, U> { Left(T), Right(U) }\n struct S(Either<uint, uint>);\n \n fn main() {\n     match *S(Left(5)) {\n-      S(_) => {}  //~ ERROR mismatched types: expected `std::either::Either<uint,uint>` but found a structure pattern\n+      S(_) => {}  //~ ERROR mismatched types: expected `Either<uint,uint>` but found a structure pattern\n     }\n }"}, {"sha": "c7565fa01691d5d8125c7e2f4a30db1b1a2304e7", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -14,8 +14,6 @@\n \n use cal = bar::c::cc;\n \n-use std::either::Right;        //~ ERROR unused import\n-\n use std::util::*;              // shouldn't get errors for not using\n                                 // everything imported\n "}, {"sha": "400486b2f22cc2cb61eb0cf4f7d92c1914442e92", "filename": "src/test/run-pass/issue-6117.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Frun-pass%2Fissue-6117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Frun-pass%2Fissue-6117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6117.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -10,6 +10,8 @@\n \n #[feature(managed_boxes)];\n \n+enum Either<T, U> { Left(T), Right(U) }\n+\n pub fn main() {\n     match Left(@17) {\n         Right(()) => {}"}, {"sha": "06b536b8391dfe09b82fddb6b299f4186c2911c9", "filename": "src/test/run-pass/small-enums-with-fields.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08321f1c49d75e60a2c56320a3f1483e7bf79a91/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmall-enums-with-fields.rs?ref=08321f1c49d75e60a2c56320a3f1483e7bf79a91", "patch": "@@ -12,6 +12,9 @@\n \n use std::mem::size_of;\n \n+#[deriving(Eq)]\n+enum Either<T, U> { Left(T), Right(U) }\n+\n macro_rules! check {\n     ($t:ty, $sz:expr, $($e:expr, $s:expr),*) => {{\n         assert_eq!(size_of::<$t>(), $sz);"}]}