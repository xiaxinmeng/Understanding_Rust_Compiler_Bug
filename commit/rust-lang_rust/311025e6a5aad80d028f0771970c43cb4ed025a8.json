{"sha": "311025e6a5aad80d028f0771970c43cb4ed025a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMTAyNWU2YTVhYWQ4MGQwMjhmMDc3MTk3MGM0M2NiNGVkMDI1YTg=", "commit": {"author": {"name": "Angelos Oikonomopoulos", "email": "a.oikonomopoulos@vu.nl", "date": "2019-03-07T17:30:26Z"}, "committer": {"name": "Angelos Oikonomopoulos", "email": "a.oikonomopoulos@vu.nl", "date": "2019-03-13T13:15:49Z"}, "message": "Fix generic argument lookup for Self\n\nRewrite the SelfCtor early and use the replacement Def when\ncalculating the path_segs.\n\nNote that this also changes which def is seen by the code that\ncomputes user_self_ty and is_alias_variant_ctor; I don't see a\nimmediate issue with that, but I'm not 100% clear on the\nimplications.\n\nFixes #57924", "tree": {"sha": "50c944a8ef77570e3d2c2703068bb9cdcc28c970", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50c944a8ef77570e3d2c2703068bb9cdcc28c970"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/311025e6a5aad80d028f0771970c43cb4ed025a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/311025e6a5aad80d028f0771970c43cb4ed025a8", "html_url": "https://github.com/rust-lang/rust/commit/311025e6a5aad80d028f0771970c43cb4ed025a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/311025e6a5aad80d028f0771970c43cb4ed025a8/comments", "author": null, "committer": null, "parents": [{"sha": "b58a0061a347532c55cd5eb27fd6f47f20889ec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b58a0061a347532c55cd5eb27fd6f47f20889ec6", "html_url": "https://github.com/rust-lang/rust/commit/b58a0061a347532c55cd5eb27fd6f47f20889ec6"}], "stats": {"total": 128, "additions": 69, "deletions": 59}, "files": [{"sha": "7dfe9f40d318f552b22b2a4e398dd2d4e47a24bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/311025e6a5aad80d028f0771970c43cb4ed025a8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311025e6a5aad80d028f0771970c43cb4ed025a8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=311025e6a5aad80d028f0771970c43cb4ed025a8", "patch": "@@ -5302,6 +5302,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n+    // Rewrite `SelfCtor` to `StructCtor`\n+    pub fn rewrite_self_ctor(&self, def: Def, span: Span) -> (Def, DefId, Ty<'tcx>) {\n+        let tcx = self.tcx;\n+        if let Def::SelfCtor(impl_def_id) = def {\n+            let ty = self.impl_self_ty(span, impl_def_id).ty;\n+            let adt_def = ty.ty_adt_def();\n+\n+            match adt_def {\n+                Some(adt_def) if adt_def.has_ctor() => {\n+                    let variant = adt_def.non_enum_variant();\n+                    let def = Def::StructCtor(variant.did, variant.ctor_kind);\n+                    (def, variant.did, tcx.type_of(variant.did))\n+                }\n+                _ => {\n+                    let mut err = tcx.sess.struct_span_err(span,\n+                        \"the `Self` constructor can only be used with tuple or unit structs\");\n+                    if let Some(adt_def) = adt_def {\n+                        match adt_def.adt_kind() {\n+                            AdtKind::Enum => {\n+                                err.help(\"did you mean to use one of the enum's variants?\");\n+                            },\n+                            AdtKind::Struct |\n+                            AdtKind::Union => {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use curly brackets\",\n+                                    String::from(\"Self { /* fields */ }\"),\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    err.emit();\n+\n+                    (def, impl_def_id, tcx.types.err)\n+                }\n+            }\n+        } else {\n+            let def_id = def.def_id();\n+\n+            // The things we are substituting into the type should not contain\n+            // escaping late-bound regions, and nor should the base type scheme.\n+            let ty = tcx.type_of(def_id);\n+            (def, def_id, ty)\n+        }\n+    }\n+\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -5321,6 +5368,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n+        match def {\n+            Def::Local(nid) | Def::Upvar(nid, ..) => {\n+                let hid = self.tcx.hir().node_to_hir_id(nid);\n+                let ty = self.local_ty(span, hid).decl_ty;\n+                let ty = self.normalize_associated_types_in(span, &ty);\n+                self.write_ty(hir_id, ty);\n+                return (ty, def);\n+            }\n+            _ => {}\n+        }\n+\n+        let (def, def_id, ty) = self.rewrite_self_ctor(def, span);\n         let path_segs = AstConv::def_ids_for_path_segments(self, segments, self_ty, def);\n \n         let mut user_self_ty = None;\n@@ -5382,17 +5441,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             user_self_ty = None;\n         }\n \n-        match def {\n-            Def::Local(nid) | Def::Upvar(nid, ..) => {\n-                let hid = self.tcx.hir().node_to_hir_id(nid);\n-                let ty = self.local_ty(span, hid).decl_ty;\n-                let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(hir_id, ty);\n-                return (ty, def);\n-            }\n-            _ => {}\n-        }\n-\n         // Now we have to compare the types that the user *actually*\n         // provided against the types that were *expected*. If the user\n         // did not provide any types, then we want to substitute inference\n@@ -5425,53 +5473,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n-        let mut new_def = def;\n-        let (def_id, ty) = match def {\n-            Def::SelfCtor(impl_def_id) => {\n-                let ty = self.impl_self_ty(span, impl_def_id).ty;\n-                let adt_def = ty.ty_adt_def();\n-\n-                match adt_def {\n-                    Some(adt_def) if adt_def.has_ctor() => {\n-                        let variant = adt_def.non_enum_variant();\n-                        new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                        (variant.did, tcx.type_of(variant.did))\n-                    }\n-                    _ => {\n-                        let mut err = tcx.sess.struct_span_err(span,\n-                            \"the `Self` constructor can only be used with tuple or unit structs\");\n-                        if let Some(adt_def) = adt_def {\n-                            match adt_def.adt_kind() {\n-                                AdtKind::Enum => {\n-                                    err.help(\"did you mean to use one of the enum's variants?\");\n-                                },\n-                                AdtKind::Struct |\n-                                AdtKind::Union => {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"use curly brackets\",\n-                                        String::from(\"Self { /* fields */ }\"),\n-                                        Applicability::HasPlaceholders,\n-                                    );\n-                                }\n-                            }\n-                        }\n-                        err.emit();\n-\n-                        (impl_def_id, tcx.types.err)\n-                    }\n-                }\n-            }\n-            _ => {\n-                let def_id = def.def_id();\n-\n-                // The things we are substituting into the type should not contain\n-                // escaping late-bound regions, and nor should the base type scheme.\n-                let ty = tcx.type_of(def_id);\n-                (def_id, ty)\n-            }\n-        };\n-\n         let substs = AstConv::create_substs_for_generic_args(\n             tcx,\n             def_id,\n@@ -5587,7 +5588,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n-        (ty_substituted, new_def)\n+        (ty_substituted, def)\n     }\n \n     fn check_rustc_args_require_const(&self,"}, {"sha": "232596334b0ed9cb4d80421f6d0b5ff3d52c560a", "filename": "src/test/run-pass/issues/issue-57924.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/311025e6a5aad80d028f0771970c43cb4ed025a8/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/311025e6a5aad80d028f0771970c43cb4ed025a8/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-57924.rs?ref=311025e6a5aad80d028f0771970c43cb4ed025a8", "patch": "@@ -0,0 +1,9 @@\n+pub struct Gcm<E>(E);\n+\n+impl<E> Gcm<E> {\n+    pub fn crash(e: E) -> Self {\n+        Self::<E>(e)\n+    }\n+}\n+\n+fn main() {}"}]}