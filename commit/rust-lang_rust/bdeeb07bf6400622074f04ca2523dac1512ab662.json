{"sha": "bdeeb07bf6400622074f04ca2523dac1512ab662", "node_id": "C_kwDOAAsO6NoAKGJkZWViMDdiZjY0MDA2MjIwNzRmMDRjYTI1MjNkYWMxNTEyYWI2NjI", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-12-16T20:24:28Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-12-16T20:24:28Z"}, "message": "Prove obligations to termination instead of ignoring ambiguities.\n\nSometimes an obligation depends on a later one, so we can't just process them in order like it was done previously.\n\nThis is not a problem in our test suite, but there may be ICEs out there and it will definitely be a problem with lazy TAIT.", "tree": {"sha": "30bc554f893cc5cf5fdce601009551dfb8195657", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30bc554f893cc5cf5fdce601009551dfb8195657"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdeeb07bf6400622074f04ca2523dac1512ab662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdeeb07bf6400622074f04ca2523dac1512ab662", "html_url": "https://github.com/rust-lang/rust/commit/bdeeb07bf6400622074f04ca2523dac1512ab662", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdeeb07bf6400622074f04ca2523dac1512ab662/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c4600227329a273c0c6c844e4a10ce650ead601", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c4600227329a273c0c6c844e4a10ce650ead601", "html_url": "https://github.com/rust-lang/rust/commit/5c4600227329a273c0c6c844e4a10ce650ead601"}], "stats": {"total": 61, "additions": 42, "deletions": 19}, "files": [{"sha": "d662f61e2cf4dbbc1532fef09b656d71d7b546d1", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bdeeb07bf6400622074f04ca2523dac1512ab662/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdeeb07bf6400622074f04ca2523dac1512ab662/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=bdeeb07bf6400622074f04ca2523dac1512ab662", "patch": "@@ -4,7 +4,9 @@ use crate::infer::canonical::{\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n-use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::infer::canonical::{Canonical, Certainty};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::PredicateObligations;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use std::fmt;\n@@ -17,7 +19,6 @@ pub mod implied_outlives_bounds;\n pub mod normalize;\n pub mod outlives;\n pub mod prove_predicate;\n-use self::prove_predicate::ProvePredicate;\n pub mod subtype;\n \n pub use rustc_middle::traits::query::type_op::*;\n@@ -80,9 +81,14 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'tcx>,\n         output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n-    ) -> Fallible<(Self::QueryResponse, Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>)> {\n+    ) -> Fallible<(\n+        Self::QueryResponse,\n+        Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>,\n+        PredicateObligations<'tcx>,\n+        Certainty,\n+    )> {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n-            return Ok((result, None));\n+            return Ok((result, None, vec![], Certainty::Proven));\n         }\n \n         // FIXME(#33684) -- We need to use\n@@ -104,20 +110,7 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<'tcx> + 'tcx {\n                 output_query_region_constraints,\n             )?;\n \n-        // Typically, instantiating NLL query results does not\n-        // create obligations. However, in some cases there\n-        // are unresolved type variables, and unify them *can*\n-        // create obligations. In that case, we have to go\n-        // fulfill them. We do this via a (recursive) query.\n-        for obligation in obligations {\n-            let ((), _) = ProvePredicate::fully_perform_into(\n-                obligation.param_env.and(ProvePredicate::new(obligation.predicate)),\n-                infcx,\n-                output_query_region_constraints,\n-            )?;\n-        }\n-\n-        Ok((value, Some(canonical_self)))\n+        Ok((value, Some(canonical_self), obligations, canonical_result.value.certainty))\n     }\n }\n \n@@ -129,9 +122,39 @@ where\n \n     fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let mut region_constraints = QueryRegionConstraints::default();\n-        let (output, canonicalized_query) =\n+        let (output, canonicalized_query, mut obligations, _) =\n             Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n \n+        // Typically, instantiating NLL query results does not\n+        // create obligations. However, in some cases there\n+        // are unresolved type variables, and unify them *can*\n+        // create obligations. In that case, we have to go\n+        // fulfill them. We do this via a (recursive) query.\n+        while !obligations.is_empty() {\n+            trace!(\"{:#?}\", obligations);\n+            let mut progress = false;\n+            for obligation in std::mem::take(&mut obligations) {\n+                let obligation = infcx.resolve_vars_if_possible(obligation);\n+                match ProvePredicate::fully_perform_into(\n+                    obligation.param_env.and(ProvePredicate::new(obligation.predicate)),\n+                    infcx,\n+                    &mut region_constraints,\n+                ) {\n+                    Ok(((), _, new, certainty)) => {\n+                        obligations.extend(new);\n+                        progress = true;\n+                        if let Certainty::Ambiguous = certainty {\n+                            obligations.push(obligation);\n+                        }\n+                    }\n+                    Err(_) => obligations.push(obligation),\n+                }\n+            }\n+            if !progress {\n+                return Err(NoSolution);\n+            }\n+        }\n+\n         // Promote the final query-region-constraints into a\n         // (optional) ref-counted vector:\n         let region_constraints ="}]}