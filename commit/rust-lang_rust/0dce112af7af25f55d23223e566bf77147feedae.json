{"sha": "0dce112af7af25f55d23223e566bf77147feedae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkY2UxMTJhZjdhZjI1ZjU1ZDIzMjIzZTU2NmJmNzcxNDdmZWVkYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-01T11:31:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-01T11:31:31Z"}, "message": "auto merge of #9636 : alexcrichton/rust/rustdoc, r=huonw\n\nCommits have all the juicy details.\r\n\r\nImport thing to note in this pull request is that `rustdoc html crate.rs` becomes `rustdoc crate.rs`", "tree": {"sha": "d5729e2b1485e24bc0814e982421c4d53791a203", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5729e2b1485e24bc0814e982421c4d53791a203"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dce112af7af25f55d23223e566bf77147feedae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dce112af7af25f55d23223e566bf77147feedae", "html_url": "https://github.com/rust-lang/rust/commit/0dce112af7af25f55d23223e566bf77147feedae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dce112af7af25f55d23223e566bf77147feedae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec2b9cc22826fcc109e9a01b0c9d6e64983bea0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec2b9cc22826fcc109e9a01b0c9d6e64983bea0d", "html_url": "https://github.com/rust-lang/rust/commit/ec2b9cc22826fcc109e9a01b0c9d6e64983bea0d"}, {"sha": "56da32c5566207627a57d9e336cbb8c1f09c91c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/56da32c5566207627a57d9e336cbb8c1f09c91c0", "html_url": "https://github.com/rust-lang/rust/commit/56da32c5566207627a57d9e336cbb8c1f09c91c0"}], "stats": {"total": 407, "additions": 294, "deletions": 113}, "files": [{"sha": "c7cdb8328879ced7de87e6a024c250d39d6bdc2b", "filename": "man/rustdoc.1", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0dce112af7af25f55d23223e566bf77147feedae/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/0dce112af7af25f55d23223e566bf77147feedae/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=0dce112af7af25f55d23223e566bf77147feedae", "patch": "@@ -3,49 +3,84 @@\n rustdoc \\- generate documentation from Rust source code\n .SH SYNOPSIS\n .B rustdoc\n-[\\fIOPTIONS\\fR] \\fICRATEFILE\\fR\n+[\\fIOPTIONS\\fR] \\fIINPUT\\fR\n \n .SH DESCRIPTION\n This tool generates API reference documentation by extracting comments from\n-source code written in the Rust language, available at <\\fBhttps://www.rust-\n-lang.org\\fR>. It provides several output formats for the generated\n-documentation.\n+source code written in the Rust language, available at\n+<\\fBhttps://www.rust-lang.org\\fR>. It accepts several input formats and provides\n+several output formats for the generated documentation.\n \n-.SH COMMANDS\n+.SH OPTIONS\n \n .TP\n---output-dir <val>\n-Put documents here (default: .)\n+-r --input-format <val>\n+html or json (default: inferred)\n .TP\n---output-format <val>\n-markdown or html (default: html)\n+-w --output-format <val>\n+html or json (default: html)\n .TP\n---output-style <val>\n-doc-per-crate or doc-per-mod (default: doc-per-mod)\n+-o --output <val>\n+where to place the output (default: doc/ for html, doc.json for json)\n .TP\n---pandoc-cmd <val>\n-Command for running pandoc\n+--passes <val>\n+space-separated list of passes to run (default: '')\n+.TP\n+--no-defaults\n+don't run the default passes\n+.TP\n+--plugins <val>\n+space-separated list of plugins to run (default: '')\n+.TP\n+--plugin-path <val>\n+directory to load plugins from (default: /tmp/rustdoc_ng/plugins)\n+.TP\n+-L --library-path <val>\n+directory to add to crate search path\n .TP\n -h, --help\n Print help\n \n .SH \"OUTPUT FORMATS\"\n \n-The rustdoc tool can generate documentation in either the Markdown\n-or HTML formats. It requires the pandoc tool\n-<\\fBhttp://johnmacfarlane.net/pandoc/\\fR> for conversion features.\n+The rustdoc tool can generate output in either an HTML or JSON format.\n+\n+If using an HTML format, then the specified output destination will be the root\n+directory of an HTML structure for all the documentation. Pages will be placed\n+into this directory, and source files will also possibly be rendered into it as\n+well.\n+\n+If using a JSON format, then the specified output destination will have the\n+rustdoc output serialized as JSON into it. This output format exists to\n+pre-compile documentation for crates, and for usage in non-rustdoc tools. The\n+JSON output is the following hash:\n+\n+    {\n+        \"schema\": VERSION,\n+        \"crate\": ...,\n+        \"plugins\": ...,\n+    }\n+\n+The schema version indicates what the structure of crate/plugins will look\n+like. Within a schema version the structure will remain the same. The `crate`\n+field will contain all relevant documentation for the source being documented,\n+and the `plugins` field will contain the output of the plugins run over the\n+crate.\n \n .SH \"EXAMPLES\"\n \n To generate documentation for the source in the current directory:\n     $ rustdoc hello.rs\n \n-To build documentation into a subdirectory named 'doc' in the Markdown\n-format:\n-    $ rustdoc --output-dir doc --output-format markdown hello.rs\n+List all available passes that rustdoc has, along with default passes:\n+    $ rustdoc --passes list\n+\n+To precompile the documentation for a crate, and then use it to render html at\n+a later date:\n+    $ rustdoc -w json hello.rs\n+    $ rustdoc doc.json\n \n-The generated HTML can be viewed with any standard web browser, while\n-the Markdown version is well-suited for conversion into other formats.\n+The generated HTML can be viewed with any standard web browser.\n \n .SH \"SEE ALSO\"\n "}, {"sha": "4663f9c9532b473ce02e83e07d4e966552fc91fb", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dce112af7af25f55d23223e566bf77147feedae/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0dce112af7af25f55d23223e566bf77147feedae/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=0dce112af7af25f55d23223e566bf77147feedae", "patch": "@@ -227,7 +227,7 @@ RUSTDOC = $(HBIN2_H_$(CFG_BUILD_TRIPLE))/rustdoc$(X_$(CFG_BUILD_TRIPLE))\n define libdoc\n doc/$(1)/index.html: $$(RUSTDOC) $$(TLIB2_T_$(3)_H_$(3))/$(CFG_STDLIB_$(3))\n \t@$$(call E, rustdoc: $$@)\n-\t$(Q)$(RUSTDOC) html $(2)\n+\t$(Q)$(RUSTDOC) $(2)\n \n DOCS += doc/$(1)/index.html\n endef"}, {"sha": "1dde7bd80d451b607275f82749a0ddb1076ba2aa", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 113, "deletions": 35, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0dce112af7af25f55d23223e566bf77147feedae/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dce112af7af25f55d23223e566bf77147feedae/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0dce112af7af25f55d23223e566bf77147feedae", "patch": "@@ -28,6 +28,7 @@ use std::vec;\n use extra::arc::RWArc;\n use extra::json::ToJson;\n use extra::sort;\n+use extra::time;\n \n use syntax::ast;\n use syntax::ast_util::is_local;\n@@ -60,7 +61,7 @@ struct Cache {\n     // typaram id => name of that typaram\n     typarams: HashMap<ast::NodeId, ~str>,\n     // type id => all implementations for that type\n-    impls: HashMap<ast::NodeId, ~[clean::Impl]>,\n+    impls: HashMap<ast::NodeId, ~[(clean::Impl, Option<~str>)]>,\n     // path id => (full qualified path, shortty) -- used to generate urls\n     paths: HashMap<ast::NodeId, (~[~str], &'static str)>,\n     // trait id => method name => dox\n@@ -76,7 +77,7 @@ struct Cache {\n struct SourceCollector<'self> {\n     seen: HashSet<~str>,\n     dst: Path,\n-    cx: &'self Context,\n+    cx: &'self mut Context,\n }\n \n struct Item<'self> { cx: &'self Context, item: &'self clean::Item, }\n@@ -179,21 +180,28 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n         w.flush();\n     }\n \n-    if cx.include_sources {\n+    info2!(\"emitting source files\");\n+    let started = time::precise_time_ns();\n+    {\n         let dst = cx.dst.push(\"src\");\n         mkdir(&dst);\n         let dst = dst.push(crate.name);\n         mkdir(&dst);\n         let mut folder = SourceCollector {\n             dst: dst,\n             seen: HashSet::new(),\n-            cx: &cx,\n+            cx: &mut cx,\n         };\n         crate = folder.fold_crate(crate);\n     }\n+    let ended = time::precise_time_ns();\n+    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1e9f64);\n \n-    // Now render the whole crate.\n+    info2!(\"rendering the whole crate\");\n+    let started = time::precise_time_ns();\n     cx.crate(crate, cache);\n+    let ended = time::precise_time_ns();\n+    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1e9f64);\n }\n \n fn write(dst: Path, contents: &str) {\n@@ -229,16 +237,28 @@ fn clean_srcpath(src: &str, f: &fn(&str)) {\n \n impl<'self> DocFolder for SourceCollector<'self> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if !self.seen.contains(&item.source.filename) {\n-            self.emit_source(item.source.filename);\n+        if self.cx.include_sources && !self.seen.contains(&item.source.filename) {\n+            // If it turns out that we couldn't read this file, then we probably\n+            // can't read any of the files (generating html output from json or\n+            // something like that), so just don't include sources for the\n+            // entire crate. The other option is maintaining this mapping on a\n+            // per-file basis, but that's probably not worth it...\n+            self.cx.include_sources = self.emit_source(item.source.filename);\n             self.seen.insert(item.source.filename.clone());\n+\n+            if !self.cx.include_sources {\n+                println!(\"warning: source code was requested to be rendered, \\\n+                          but `{}` is a missing source file.\",\n+                         item.source.filename);\n+                println!(\"         skipping rendering of source code\");\n+            }\n         }\n         self.fold_item_recur(item)\n     }\n }\n \n impl<'self> SourceCollector<'self> {\n-    fn emit_source(&self, filename: &str) {\n+    fn emit_source(&mut self, filename: &str) -> bool {\n         let p = Path(filename);\n \n         // Read the contents of the file\n@@ -251,7 +271,11 @@ impl<'self> SourceCollector<'self> {\n             // If we couldn't open this file, then just returns because it\n             // probably means that it's some standard library macro thing and we\n             // can't have the source to it anyway.\n-            let mut r = match r { Some(r) => r, None => return };\n+            let mut r = match r {\n+                Some(r) => r,\n+                // eew macro hacks\n+                None => return filename == \"<std-macros>\"\n+            };\n \n             // read everything\n             loop {\n@@ -273,7 +297,8 @@ impl<'self> SourceCollector<'self> {\n         }\n \n         let dst = cur.push(*p.components.last() + \".html\");\n-        let mut w = dst.open_writer(io::CreateOrTruncate);\n+        let w = dst.open_writer(io::CreateOrTruncate);\n+        let mut w = BufferedWriter::new(w);\n \n         let title = format!(\"{} -- source\", *dst.components.last());\n         let page = layout::Page {\n@@ -283,6 +308,8 @@ impl<'self> SourceCollector<'self> {\n         };\n         layout::render(&mut w as &mut io::Writer, &self.cx.layout,\n                        &page, &(\"\"), &Source(contents.as_slice()));\n+        w.flush();\n+        return true;\n     }\n }\n \n@@ -427,21 +454,34 @@ impl DocFolder for Cache {\n         // implementations elsewhere\n         let ret = match self.fold_item_recur(item) {\n             Some(item) => {\n-                match item.inner {\n-                    clean::ImplItem(i) => {\n+                match item {\n+                    clean::Item{ attrs, inner: clean::ImplItem(i), _ } => {\n                         match i.for_ {\n                             clean::ResolvedPath { did, _ } if is_local(did) => {\n                                 let id = did.node;\n                                 let v = do self.impls.find_or_insert_with(id) |_| {\n                                     ~[]\n                                 };\n-                                v.push(i);\n+                                // extract relevant documentation for this impl\n+                                match attrs.move_iter().find(|a| {\n+                                    match *a {\n+                                        clean::NameValue(~\"doc\", _) => true,\n+                                        _ => false\n+                                    }\n+                                }) {\n+                                    Some(clean::NameValue(_, dox)) => {\n+                                        v.push((i, Some(dox)));\n+                                    }\n+                                    Some(*) | None => {\n+                                        v.push((i, None));\n+                                    }\n+                                }\n                             }\n                             _ => {}\n                         }\n                         None\n                     }\n-                    _ => Some(item),\n+                    i => Some(i),\n                 }\n             }\n             i => i,\n@@ -1050,10 +1090,24 @@ fn render_method(w: &mut io::Writer, meth: &clean::Item, withlink: bool) {\n \n fn item_struct(w: &mut io::Writer, it: &clean::Item, s: &clean::Struct) {\n     write!(w, \"<pre class='struct'>\");\n-    render_struct(w, it, Some(&s.generics), s.struct_type, s.fields, \"\");\n+    render_struct(w, it, Some(&s.generics), s.struct_type, s.fields, \"\", true);\n     write!(w, \"</pre>\");\n \n     document(w, it);\n+    match s.struct_type {\n+        doctree::Plain => {\n+            write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\");\n+            for field in s.fields.iter() {\n+                write!(w, \"<tr><td id='structfield.{name}'>\\\n+                                <code>{name}</code></td><td>\",\n+                       name = field.name.get_ref().as_slice());\n+                document(w, field);\n+                write!(w, \"</td></tr>\");\n+            }\n+            write!(w, \"</table>\");\n+        }\n+        _ => {}\n+    }\n     render_methods(w, it);\n }\n \n@@ -1067,61 +1121,74 @@ fn item_enum(w: &mut io::Writer, it: &clean::Item, e: &clean::Enum) {\n     } else {\n         write!(w, \" \\\\{\\n\");\n         for v in e.variants.iter() {\n-            let name = format!(\"<a name='variant.{0}'>{0}</a>\",\n-                               v.name.get_ref().as_slice());\n+            write!(w, \"    \");\n+            let name = v.name.get_ref().as_slice();\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n-                        clean::CLikeVariant => write!(w, \"    {},\\n\", name),\n+                        clean::CLikeVariant => write!(w, \"{}\", name),\n                         clean::TupleVariant(ref tys) => {\n-                            write!(w, \"    {}(\", name);\n+                            write!(w, \"{}(\", name);\n                             for (i, ty) in tys.iter().enumerate() {\n                                 if i > 0 { write!(w, \", \") }\n                                 write!(w, \"{}\", *ty);\n                             }\n-                            write!(w, \"),\\n\");\n+                            write!(w, \")\");\n                         }\n                         clean::StructVariant(ref s) => {\n                             render_struct(w, v, None, s.struct_type, s.fields,\n-                                          \"    \");\n+                                          \"    \", false);\n                         }\n                     }\n                 }\n                 _ => unreachable!()\n             }\n+            write!(w, \",\\n\");\n         }\n         write!(w, \"\\\\}\");\n     }\n     write!(w, \"</pre>\");\n \n     document(w, it);\n+    if e.variants.len() > 0 {\n+        write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\");\n+        for variant in e.variants.iter() {\n+            write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n+                   name = variant.name.get_ref().as_slice());\n+            document(w, variant);\n+            write!(w, \"</td></tr>\");\n+        }\n+        write!(w, \"</table>\");\n+\n+    }\n     render_methods(w, it);\n }\n \n fn render_struct(w: &mut io::Writer, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,\n                  fields: &[clean::Item],\n-                 tab: &str) {\n-    write!(w, \"{}struct {}\",\n+                 tab: &str,\n+                 structhead: bool) {\n+    write!(w, \"{}{}{}\",\n            VisSpace(it.visibility),\n+           if structhead {\"struct \"} else {\"\"},\n            it.name.get_ref().as_slice());\n     match g {\n         Some(g) => write!(w, \"{}\", *g),\n         None => {}\n     }\n     match ty {\n         doctree::Plain => {\n-            write!(w, \" \\\\{\\n\");\n+            write!(w, \" \\\\{\\n{}\", tab);\n             for field in fields.iter() {\n                 match field.inner {\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"    {}<a name='structfield.{name}'>{name}</a>: \\\n-                                   {},\\n{}\",\n+                        write!(w, \"    {}{}: {},\\n{}\",\n                                VisSpace(field.visibility),\n+                               field.name.get_ref().as_slice(),\n                                ty.type_,\n-                               tab,\n-                               name = field.name.get_ref().as_slice());\n+                               tab);\n                     }\n                     _ => unreachable!()\n                 }\n@@ -1151,22 +1218,26 @@ fn render_methods(w: &mut io::Writer, it: &clean::Item) {\n         do cache.read |c| {\n             match c.impls.find(&it.id) {\n                 Some(v) => {\n-                    let mut non_trait = v.iter().filter(|i| i.trait_.is_none());\n+                    let mut non_trait = v.iter().filter(|p| {\n+                        p.n0_ref().trait_.is_none()\n+                    });\n                     let non_trait = non_trait.to_owned_vec();\n-                    let mut traits = v.iter().filter(|i| i.trait_.is_some());\n+                    let mut traits = v.iter().filter(|p| {\n+                        p.n0_ref().trait_.is_some()\n+                    });\n                     let traits = traits.to_owned_vec();\n \n                     if non_trait.len() > 0 {\n                         write!(w, \"<h2 id='methods'>Methods</h2>\");\n-                        for &i in non_trait.iter() {\n-                            render_impl(w, i);\n+                        for &(ref i, ref dox) in non_trait.move_iter() {\n+                            render_impl(w, i, dox);\n                         }\n                     }\n                     if traits.len() > 0 {\n                         write!(w, \"<h2 id='implementations'>Trait \\\n                                    Implementations</h2>\");\n-                        for &i in traits.iter() {\n-                            render_impl(w, i);\n+                        for &(ref i, ref dox) in traits.move_iter() {\n+                            render_impl(w, i, dox);\n                         }\n                     }\n                 }\n@@ -1176,7 +1247,7 @@ fn render_methods(w: &mut io::Writer, it: &clean::Item) {\n     }\n }\n \n-fn render_impl(w: &mut io::Writer, i: &clean::Impl) {\n+fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n     write!(w, \"<h3 class='impl'><code>impl{} \", i.generics);\n     let trait_id = match i.trait_ {\n         Some(ref ty) => {\n@@ -1189,6 +1260,13 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl) {\n         None => None\n     };\n     write!(w, \"{}</code></h3>\", i.for_);\n+    match *dox {\n+        Some(ref dox) => {\n+            write!(w, \"<div class='docblock'>{}</div>\",\n+                   Markdown(dox.as_slice()));\n+        }\n+        None => {}\n+    }\n     write!(w, \"<div class='methods'>\");\n     for meth in i.methods.iter() {\n         write!(w, \"<h4 id='method.{}' class='method'><code>\","}, {"sha": "bf40261e76509a30962af773abdf421f5884e5e9", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0dce112af7af25f55d23223e566bf77147feedae/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/0dce112af7af25f55d23223e566bf77147feedae/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=0dce112af7af25f55d23223e566bf77147feedae", "patch": "@@ -224,8 +224,8 @@\n                 }, 20);\n             });\n \n-            $(document).off('keyup.searchnav');\n-            $(document).on('keyup.searchnav', function (e) {\n+            $(document).off('keypress.searchnav');\n+            $(document).on('keypress.searchnav', function (e) {\n                 var $active = $results.filter('.highlighted');\n \n                 if (e.keyCode === 38) { // up\n@@ -321,8 +321,8 @@\n             output += \"</p>\";\n             $('#main.content').addClass('hidden');\n             $('#search.content').removeClass('hidden').html(output);\n-            $('.search-results .desc').width($('.content').width() - 40 -\n-                    $('.content td:first-child').first().width());\n+            $('#search .desc').width($('#search').width() - 40 -\n+                    $('#search td:first-child').first().width());\n             initSearchNav();\n         }\n "}, {"sha": "a7eac9f268d3c70003601b3b09f00453b17a1e33", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 120, "deletions": 52, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0dce112af7af25f55d23223e566bf77147feedae/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dce112af7af25f55d23223e566bf77147feedae/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=0dce112af7af25f55d23223e566bf77147feedae", "patch": "@@ -21,13 +21,15 @@ extern mod syntax;\n extern mod rustc;\n extern mod extra;\n \n-use extra::serialize::Encodable;\n-use extra::time;\n-use extra::getopts::groups;\n use std::cell::Cell;\n-use std::rt::io;\n use std::rt::io::Writer;\n use std::rt::io::file::FileInfo;\n+use std::rt::io;\n+use extra::getopts;\n+use extra::getopts::groups;\n+use extra::json;\n+use extra::serialize::{Decodable, Encodable};\n+use extra::time;\n \n pub mod clean;\n pub mod core;\n@@ -70,9 +72,7 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n \n local_data_key!(pub ctxtkey: @core::DocContext)\n \n-enum OutputFormat {\n-    HTML, JSON\n-}\n+type Output = (clean::Crate, ~[plugins::PluginJson]);\n \n pub fn main() {\n     std::os::set_exit_status(main_args(std::os::args()));\n@@ -81,6 +81,12 @@ pub fn main() {\n pub fn opts() -> ~[groups::OptGroup] {\n     use extra::getopts::groups::*;\n     ~[\n+        optflag(\"h\", \"help\", \"show this help message\"),\n+        optopt(\"r\", \"input-format\", \"the input type of the specified file\",\n+               \"[rust|json]\"),\n+        optopt(\"w\", \"output-format\", \"the output type to write\",\n+               \"[html|json]\"),\n+        optopt(\"o\", \"output\", \"where to place the output\", \"PATH\"),\n         optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n                  \"DIR\"),\n         optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\"),\n@@ -89,32 +95,22 @@ pub fn opts() -> ~[groups::OptGroup] {\n                  \"PASSES\"),\n         optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n                  \"PLUGINS\"),\n-        optflag(\"h\", \"help\", \"show this help message\"),\n-        optflag(\"\", \"nodefaults\", \"don't run the default passes\"),\n-        optopt(\"o\", \"output\", \"where to place the output\", \"PATH\"),\n+        optflag(\"\", \"no-defaults\", \"don't run the default passes\"),\n     ]\n }\n \n pub fn usage(argv0: &str) {\n-    println(groups::usage(format!(\"{} [options] [html|json] <crate>\",\n-                                  argv0), opts()));\n+    println(groups::usage(format!(\"{} [options] <input>\", argv0), opts()));\n }\n \n pub fn main_args(args: &[~str]) -> int {\n-    //use extra::getopts::groups::*;\n-\n     let matches = groups::getopts(args.tail(), opts()).unwrap();\n-\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         usage(args[0]);\n         return 0;\n     }\n \n-    let mut default_passes = !matches.opt_present(\"nodefaults\");\n-    let mut passes = matches.opt_strs(\"passes\");\n-    let mut plugins = matches.opt_strs(\"plugins\");\n-\n-    if passes == ~[~\"list\"] {\n+    if matches.opt_strs(\"passes\") == ~[~\"list\"] {\n         println(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n             println!(\"{:>20s} - {}\", name, description);\n@@ -126,25 +122,68 @@ pub fn main_args(args: &[~str]) -> int {\n         return 0;\n     }\n \n-    let (format, cratefile) = match matches.free.clone() {\n-        [~\"json\", crate] => (JSON, crate),\n-        [~\"html\", crate] => (HTML, crate),\n-        [s, _] => {\n-            println!(\"Unknown output format: `{}`\", s);\n-            usage(args[0]);\n+    let (crate, res) = match acquire_input(&matches) {\n+        Ok(pair) => pair,\n+        Err(s) => {\n+            println!(\"input error: {}\", s);\n             return 1;\n         }\n-        [_, .._] => {\n-            println!(\"Expected exactly one crate to process\");\n-            usage(args[0]);\n-            return 1;\n+    };\n+\n+    info2!(\"going to format\");\n+    let started = time::precise_time_ns();\n+    let output = matches.opt_str(\"o\").map(|s| Path(*s));\n+    match matches.opt_str(\"w\") {\n+        Some(~\"html\") | None => {\n+            html::render::run(crate, output.unwrap_or(Path(\"doc\")))\n+        }\n+        Some(~\"json\") => {\n+            json_output(crate, res, output.unwrap_or(Path(\"doc.json\")))\n         }\n-        _ => {\n-            println!(\"Expected an output format and then one crate\");\n-            usage(args[0]);\n+        Some(s) => {\n+            println!(\"unknown output format: {}\", s);\n             return 1;\n         }\n-    };\n+    }\n+    let ended = time::precise_time_ns();\n+    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1e9f64);\n+\n+    return 0;\n+}\n+\n+/// Looks inside the command line arguments to extract the relevant input format\n+/// and files and then generates the necessary rustdoc output for formatting.\n+fn acquire_input(matches: &getopts::Matches) -> Result<Output, ~str> {\n+    if matches.free.len() == 0 {\n+        return Err(~\"expected an input file to act on\");\n+    } if matches.free.len() > 1 {\n+        return Err(~\"only one input file may be specified\");\n+    }\n+\n+    let input = matches.free[0].as_slice();\n+    match matches.opt_str(\"r\") {\n+        Some(~\"rust\") => Ok(rust_input(input, matches)),\n+        Some(~\"json\") => json_input(input),\n+        Some(s) => Err(\"unknown input format: \" + s),\n+        None => {\n+            if input.ends_with(\".json\") {\n+                json_input(input)\n+            } else {\n+                Ok(rust_input(input, matches))\n+            }\n+        }\n+    }\n+}\n+\n+/// Interprets the input file as a rust source file, passing it through the\n+/// compiler all the way through the analysis passes. The rustdoc output is then\n+/// generated from the cleaned AST of the crate.\n+///\n+/// This form of input will run all of the plug/cleaning passes\n+fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n+    let mut default_passes = !matches.opt_present(\"no-defaults\");\n+    let mut passes = matches.opt_strs(\"passes\");\n+    let mut plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n     let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path(*s)));\n@@ -188,7 +227,8 @@ pub fn main_args(args: &[~str]) -> int {\n     }\n \n     // Load all plugins/passes into a PluginManager\n-    let mut pm = plugins::PluginManager::new(Path(\"/tmp/rustdoc_ng/plugins\"));\n+    let path = matches.opt_str(\"plugin-path\").unwrap_or(~\"/tmp/rustdoc_ng/plugins\");\n+    let mut pm = plugins::PluginManager::new(Path(path));\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n             Some(i) => PASSES[i].n1(),\n@@ -206,45 +246,73 @@ pub fn main_args(args: &[~str]) -> int {\n \n     // Run everything!\n     info2!(\"Executing passes/plugins\");\n-    let (crate, res) = pm.run_plugins(crate);\n+    return pm.run_plugins(crate);\n+}\n \n-    info2!(\"going to format\");\n-    let started = time::precise_time_ns();\n-    let output = matches.opt_str(\"o\").map(|s| Path(*s));\n-    match format {\n-        HTML => { html::render::run(crate, output.unwrap_or(Path(\"doc\"))) }\n-        JSON => { jsonify(crate, res, output.unwrap_or(Path(\"doc.json\"))) }\n+/// This input format purely deserializes the json output file. No passes are\n+/// run over the deserialized output.\n+fn json_input(input: &str) -> Result<Output, ~str> {\n+    let input = match ::std::io::file_reader(&Path(input)) {\n+        Ok(i) => i,\n+        Err(s) => return Err(s),\n+    };\n+    match json::from_reader(input) {\n+        Err(s) => Err(s.to_str()),\n+        Ok(json::Object(obj)) => {\n+            let mut obj = obj;\n+            // Make sure the schema is what we expect\n+            match obj.pop(&~\"schema\") {\n+                Some(json::String(version)) => {\n+                    if version.as_slice() != SCHEMA_VERSION {\n+                        return Err(format!(\"sorry, but I only understand \\\n+                                            version {}\", SCHEMA_VERSION))\n+                    }\n+                }\n+                Some(*) => return Err(~\"malformed json\"),\n+                None => return Err(~\"expected a schema version\"),\n+            }\n+            let crate = match obj.pop(&~\"crate\") {\n+                Some(json) => {\n+                    let mut d = json::Decoder(json);\n+                    Decodable::decode(&mut d)\n+                }\n+                None => return Err(~\"malformed json\"),\n+            };\n+            // XXX: this should read from the \"plugins\" field, but currently\n+            //      Json doesn't implement decodable...\n+            let plugin_output = ~[];\n+            Ok((crate, plugin_output))\n+        }\n+        Ok(*) => Err(~\"malformed json input: expected an object at the top\"),\n     }\n-    let ended = time::precise_time_ns();\n-    info2!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1000000000f64);\n-\n-    return 0;\n }\n \n-fn jsonify(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n+/// Outputs the crate/plugin json as a giant json blob at the specified\n+/// destination.\n+fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n     // {\n     //   \"schema\": version,\n     //   \"crate\": { parsed crate ... },\n     //   \"plugins\": { output of plugins ... }\n     // }\n     let mut json = ~extra::treemap::TreeMap::new();\n-    json.insert(~\"schema\", extra::json::String(SCHEMA_VERSION.to_owned()));\n+    json.insert(~\"schema\", json::String(SCHEMA_VERSION.to_owned()));\n     let plugins_json = ~res.move_iter().filter_map(|opt| opt).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n     let crate_json_str = do std::io::with_str_writer |w| {\n-        crate.encode(&mut extra::json::Encoder(w));\n+        crate.encode(&mut json::Encoder(w));\n     };\n-    let crate_json = match extra::json::from_str(crate_json_str) {\n+    let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,\n         Err(_) => fail2!(\"Rust generated JSON is invalid??\")\n     };\n \n     json.insert(~\"crate\", crate_json);\n-    json.insert(~\"plugins\", extra::json::Object(plugins_json));\n+    json.insert(~\"plugins\", json::Object(plugins_json));\n \n     let mut file = dst.open_writer(io::Create).unwrap();\n-    let output = extra::json::Object(json).to_str();\n+    let output = json::Object(json).to_str();\n     file.write(output.as_bytes());\n }"}]}