{"sha": "a50337a118c3fe9e0f32aa5cf4209b856d1f7bfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MDMzN2ExMThjM2ZlOWUwZjMyYWE1Y2Y0MjA5Yjg1NmQxZjdiZmM=", "commit": {"author": {"name": "Oliver Schneider", "email": "github4395871230gnr48oli-obk.de", "date": "2015-05-02T14:50:33Z"}, "committer": {"name": "Oliver Schneider", "email": "github4395871230gnr48oli-obk.de", "date": "2015-05-02T14:50:33Z"}, "message": "first step to a non-panicking idem_check function", "tree": {"sha": "6ed466d3e9774d02a6b083fd09819c2ba4578896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ed466d3e9774d02a6b083fd09819c2ba4578896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a50337a118c3fe9e0f32aa5cf4209b856d1f7bfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a50337a118c3fe9e0f32aa5cf4209b856d1f7bfc", "html_url": "https://github.com/rust-lang/rust/commit/a50337a118c3fe9e0f32aa5cf4209b856d1f7bfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a50337a118c3fe9e0f32aa5cf4209b856d1f7bfc/comments", "author": null, "committer": null, "parents": [{"sha": "f83e3400cbbb5e30a11276799af15cc14158eda0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83e3400cbbb5e30a11276799af15cc14158eda0", "html_url": "https://github.com/rust-lang/rust/commit/f83e3400cbbb5e30a11276799af15cc14158eda0"}], "stats": {"total": 75, "additions": 55, "deletions": 20}, "files": [{"sha": "72f3277f59465b9309e563c4766f89965185a82c", "filename": "tests/idem.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a50337a118c3fe9e0f32aa5cf4209b856d1f7bfc/tests%2Fidem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a50337a118c3fe9e0f32aa5cf4209b856d1f7bfc/tests%2Fidem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem.rs?ref=a50337a118c3fe9e0f32aa5cf4209b856d1f7bfc", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(std_misc)]\n+\n extern crate rustfmt;\n \n use std::collections::HashMap;\n use std::fs;\n use std::io::Read;\n-use std::sync::atomic;\n use rustfmt::*;\n \n // For now, the only supported regression tests are idempotent tests - the input and\n@@ -22,52 +23,86 @@ use rustfmt::*;\n #[test]\n fn idempotent_tests() {\n     println!(\"Idempotent tests:\");\n-    FAILURES.store(0, atomic::Ordering::Relaxed);\n \n     // Get all files in the tests/idem directory\n     let files = fs::read_dir(\"tests/idem\").unwrap();\n+    let files2 = fs::read_dir(\"tests\").unwrap();\n+    let files3 = fs::read_dir(\"src/bin\").unwrap();\n     // For each file, run rustfmt and collect the output\n+\n     let mut count = 0;\n-    for entry in files {\n+    let mut fails = 0;\n+    for entry in files.chain(files2).chain(files3) {\n         let path = entry.unwrap().path();\n         let file_name = path.to_str().unwrap();\n+        if !file_name.ends_with(\".rs\") {\n+            continue;\n+        }\n         println!(\"Testing '{}'...\", file_name);\n-        run(vec![\"rustfmt\".to_owned(), file_name.to_owned()], WriteMode::Return(HANDLE_RESULT));\n+        match idempotent_check(vec![\"rustfmt\".to_owned(), file_name.to_owned()]) {\n+            Ok(()) => {},\n+            Err(m) => {\n+                print_mismatches(m);\n+                fails += 1;\n+            },\n+        }\n         count += 1;\n     }\n-    // And also dogfood ourselves!\n+    // And also dogfood rustfmt!\n     println!(\"Testing 'src/lib.rs'...\");\n-    run(vec![\"rustfmt\".to_string(), \"src/lib.rs\".to_string()],\n-        WriteMode::Return(HANDLE_RESULT));\n+    match idempotent_check(vec![\"rustfmt\".to_owned(), \"src/lib.rs\".to_owned()]) {\n+        Ok(()) => {},\n+        Err(m) => {\n+            print_mismatches(m);\n+            fails += 1;\n+        },\n+    }\n     count += 1;\n \n     // Display results\n-    let fails = FAILURES.load(atomic::Ordering::Relaxed);\n     println!(\"Ran {} idempotent tests; {} failures.\", count, fails);\n     assert!(fails == 0, \"{} idempotent tests failed\", fails);\n }\n \n-// 'global' used by sys_tests and handle_result.\n-static FAILURES: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+// Compare output to input.\n+fn print_mismatches(result: HashMap<String, String>) {\n+    for (file_name, fmt_text) in result {\n+        println!(\"Mismatch in {}.\", file_name);\n+        println!(\"{}\", fmt_text);\n+    }\n+}\n+\n // Ick, just needed to get a &'static to handle_result.\n static HANDLE_RESULT: &'static Fn(HashMap<String, String>) = &handle_result;\n \n+pub fn idempotent_check(args: Vec<String>) -> Result<(), HashMap<String, String>> {\n+    use std::thread;\n+    use std::fs;\n+    use std::io::Read;\n+    thread::spawn(move || {\n+        run(args, WriteMode::Return(HANDLE_RESULT));\n+    }).join().map_err(|mut any|\n+        any.downcast_mut::<HashMap<String, String>>()\n+           .unwrap() // i know it is a hashmap\n+           .drain() // i only get a reference :(\n+           .collect() // so i need to turn it into an iter and then back\n+    )\n+}\n+\n // Compare output to input.\n fn handle_result(result: HashMap<String, String>) {\n-    let mut fails = 0;\n+    let mut failures = HashMap::new();\n \n-    for file_name in result.keys() {\n-        let mut f = fs::File::open(file_name).unwrap();\n+    for (file_name, fmt_text) in result {\n+        let mut f = fs::File::open(&file_name).unwrap();\n         let mut text = String::new();\n+        // TODO: speedup by running through bytes iterator\n         f.read_to_string(&mut text).unwrap();\n-        if result[file_name] != text {\n-            fails += 1;\n-            println!(\"Mismatch in {}.\", file_name);\n-            println!(\"{}\", result[file_name]);\n+        if fmt_text != text {\n+            failures.insert(file_name, fmt_text);\n         }\n     }\n-\n-    if fails > 0 {\n-        FAILURES.fetch_add(1, atomic::Ordering::Relaxed);\n+    if !failures.is_empty() {\n+        panic!(failures);\n     }\n }\n\\ No newline at end of file"}]}