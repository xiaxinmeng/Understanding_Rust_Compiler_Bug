{"sha": "5d5c20647f45f2eb74f337e5434bbe63b0c43345", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNWMyMDY0N2Y0NWYyZWI3NGYzMzdlNTQzNGJiZTYzYjBjNDMzNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-03T21:46:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-03T21:46:47Z"}, "message": "auto merge of #15377 : alexcrichton/rust/rollup, r=alexcrichton\n\nCloses #15276 (Guide: if)\r\nCloses #15280 (std::os - Add join_paths, make setenv non-utf8 capable)\r\nCloses #15314 (Guide: functions)\r\nCloses #15327 (Simplify PatIdent to contain an Ident rather than a Path)\r\nCloses #15340 (Guide: add mutable binding section)\r\nCloses #15342 (Fix ICE with nested macro_rules!-style macros)\r\nCloses #15350 (Remove duplicated slash in install script path)\r\nCloses #15351 (correct a few spelling mistakes in the tutorial)\r\nCloses #15352 (librustc: Have the kind checker check sub-bounds in trait casts.)\r\nCloses #15359 (Fix spelling errors.)\r\nCloses #15361 (Rename set_broadast() to set_broadcast().)\r\nCloses #15366 (Simplify creating a parser from a token tree)\r\nCloses #15367 (Add examples for StrVector methods)\r\nCloses #15372 (Vec::grow should use reserve_additional, Vec::reserve should check against capacity)\r\nCloses #15373 (Fix minor issues in the documentation of libtime.)", "tree": {"sha": "155aab01cbadfe647f739c31ce46b29b792ea7ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/155aab01cbadfe647f739c31ce46b29b792ea7ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d5c20647f45f2eb74f337e5434bbe63b0c43345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d5c20647f45f2eb74f337e5434bbe63b0c43345", "html_url": "https://github.com/rust-lang/rust/commit/5d5c20647f45f2eb74f337e5434bbe63b0c43345", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d5c20647f45f2eb74f337e5434bbe63b0c43345/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd812ccbb56193c36819993dea25912788b447f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd812ccbb56193c36819993dea25912788b447f0", "html_url": "https://github.com/rust-lang/rust/commit/dd812ccbb56193c36819993dea25912788b447f0"}, {"sha": "9bd6479912990046947913f160f69bc550dd3817", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bd6479912990046947913f160f69bc550dd3817", "html_url": "https://github.com/rust-lang/rust/commit/9bd6479912990046947913f160f69bc550dd3817"}], "stats": {"total": 1292, "additions": 869, "deletions": 423}, "files": [{"sha": "aca726812d2c6b1bc3710d0e2170226e4e88eed2", "filename": "src/doc/guide.md", "status": "modified", "additions": 332, "deletions": 3, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -515,9 +515,45 @@ let x: int = 5;\n ```\n \n If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n-is a binding with the type `int` and the value `five`.\" Rust requires you to\n-initialize the binding with a value before you're allowed to use it. If\n-we try...\n+is a binding with the type `int` and the value `five`.\"\n+\n+By default, bindings are **immutable**. This code will not compile:\n+\n+```{ignore}\n+let x = 5i;\n+x = 10i;\n+```\n+\n+It will give you this error:\n+\n+```{ignore,notrust}\n+error: re-assignment of immutable variable `x`\n+     x = 10i;\n+     ^~~~~~~\n+```\n+\n+If you want a binding to be mutable, you can use `mut`:\n+\n+```{rust}\n+let mut x = 5i;\n+x = 10i;\n+```\n+\n+There is no single reason that bindings are immutable by default, but we can\n+think about it through one of Rust's primary focuses: safety. If you forget to\n+say `mut`, the compiler will catch it, and let you know that you have mutated\n+something you may not have cared to mutate. If bindings were mutable by\n+default, the compiler would not be able to tell you this. If you _did_ intend\n+mutation, then the solution is quite easy: add `mut`.\n+\n+There are other good reasons to avoid mutable state when possible, but they're\n+out of the scope of this guide. In general, you can often avoid explicit\n+mutation, and so it is preferable in Rust. That said, sometimes, mutation is\n+what you need, so it's not verboten.\n+\n+Let's get back to bindings. Rust variable bindings have one more aspect that\n+differs from other languages: bindings are required to be initialized with a\n+value before you're allowed to use it. If we try...\n \n ```{ignore}\n let x;\n@@ -611,8 +647,301 @@ concept: `if`.\n \n ## If\n \n+Rust's take on `if` is not particularly complex, but it's much more like the\n+`if` you'll find in a dynamically typed language than in a more traditional\n+systems language. So let's talk about it, to make sure you grasp the nuances.\n+\n+`if` is a specific form of a more general concept, the 'branch.' The name comes\n+from a branch in a tree: a decision point, where depending on a choice,\n+multiple paths can be taken.\n+\n+In the case of `if`, there is one choice that leads down two paths:\n+\n+```rust\n+let x = 5i;\n+\n+if x == 5i {\n+    println!(\"x is five!\");\n+}\n+```\n+\n+If we changed the value of `x` to something else, this line would not print.\n+More specifically, if the expression after the `if` evaluates to `true`, then\n+the block is executed. If it's `false`, then it is not.\n+\n+If you want something to happen in the `false` case, use an `else`:\n+\n+```\n+let x = 5i;\n+\n+if x == 5i {\n+    println!(\"x is five!\");\n+} else {\n+    println!(\"x is not five :(\");\n+}\n+```\n+\n+This is all pretty standard. However, you can also do this:\n+\n+\n+```\n+let x = 5i;\n+\n+let y = if x == 5i {\n+    10i\n+} else {\n+    15i\n+};\n+```\n+\n+Which we can (and probably should) write like this:\n+\n+```\n+let x = 5i;\n+\n+let y = if x == 5i { 10i } else { 15i };\n+```\n+\n+This reveals two interesting things about Rust: it is an expression-based\n+language, and semicolons are different than in other 'curly brace and\n+semicolon'-based languages. These two things are related.\n+\n+### Expressions vs. Statements\n+\n+Rust is primarily an expression based language. There are only two kinds of\n+statements, and everything else is an expression.\n+\n+So what's the difference? Expressions return a value, and statements do not.\n+In many languages, `if` is a statement, and therefore, `let x = if ...` would\n+make no sense. But in Rust, `if` is an expression, which means that it returns\n+a value. We can then use this value to initialize the binding.\n+\n+Speaking of which, bindings are a kind of the first of Rust's two statements.\n+The proper name is a **declaration statement**. So far, `let` is the only kind\n+of declaration statement we've seen. Let's talk about that some more.\n+\n+In some languages, variable bindings can be written as expressions, not just\n+statements. Like Ruby:\n+\n+```{ruby}\n+x = y = 5\n+```\n+\n+In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n+following will produce a compile-time error:\n+\n+```{ignore}\n+let x = (let y = 5i); // found `let` in ident position\n+```\n+\n+The compiler is telling us here that it was expecting to see the beginning of\n+an expression, and a `let` can only begin a statement, not an expression.\n+\n+However, re-assigning to a mutable binding is an expression:\n+\n+```{rust}\n+let mut x = 0i;\n+let y = x = 5i;\n+```\n+\n+In this case, we have an assignment expression (`x = 5`) whose value is\n+being used as part of a `let` declaration statement (`let y = ...`).\n+\n+The second kind of statement in Rust is the **expression statement**. Its\n+purpose is to turn any expression into a statement. In practical terms, Rust's\n+grammar expects statements to follow other statements. This means that you use\n+semicolons to separate expressions from each other. This means that Rust\n+looks a lot like most other languages that require you to use semicolons\n+at the end of every line, and you will see semicolons at the end of almost\n+every line of Rust code you see.\n+\n+What is this exception that makes us say 'almost?' You saw it already, in this\n+code:\n+\n+```\n+let x = 5i;\n+\n+let y: int = if x == 5i { 10i } else { 15i };\n+```\n+\n+Note that I've added the type annotation to `y`, to specify explicitly that I\n+want `y` to be an integer.\n+\n+This is not the same as this, which won't compile:\n+\n+```{ignore}\n+let x = 5i;\n+\n+let y: int = if x == 5 { 10i; } else { 15i; };\n+```\n+\n+Note the semicolons after the 10 and 15. Rust will give us the following error:\n+\n+```{ignore,notrust}\n+error: mismatched types: expected `int` but found `()` (expected int but found ())\n+```\n+\n+We expected an integer, but we got `()`. `()` is pronounced 'unit', and is a\n+special type in Rust's type system. `()` is different than `null` in other\n+languages, because `()` is distinct from other types. For example, in C, `null`\n+is a valid value for a variable of type `int`. In Rust, `()` is _not_ a valid\n+value for a variable of type `int`. It's only a valid value for variables of\n+the type `()`, which aren't very useful. Remember how we said statements don't\n+return a value? Well, that's the purpose of unit in this case. The semicolon\n+turns any expression into a statement by throwing away its value and returning\n+unit instead.\n+\n+There's one more time in which you won't see a semicolon at the end of a line\n+of Rust code. For that, we'll need our next concept: functions.\n+\n ## Functions\n \n+You've already seen one function so far, the `main` function:\n+\n+```{rust}\n+fn main() {\n+}\n+```\n+\n+This is the simplest possible function declaration. As we mentioned before,\n+`fn` says 'this is a function,' followed by the name, some parenthesis because\n+this function takes no arguments, and then some curly braces to indicate the\n+body. Here's a function named `foo`:\n+\n+```{rust}\n+fn foo() {\n+}\n+```\n+\n+So, what about taking arguments? Here's a function that prints a number:\n+\n+```{rust}\n+fn print_number(x: int) {\n+    println!(\"x is: {}\", x);\n+}\n+```\n+\n+Here's a complete program that uses `print_number`:\n+\n+```{rust}\n+fn main() {\n+    print_number(5);\n+}\n+\n+fn print_number(x: int) {\n+    println!(\"x is: {}\", x);\n+}\n+```\n+\n+As you can see, function arguments work very similar to `let` declarations:\n+you add a type to the argument name, after a colon.\n+\n+Here's a complete program that adds two numbers together and prints them:\n+\n+```{rust}\n+fn main() {\n+    print_sum(5, 6);\n+}\n+\n+fn print_sum(x: int, y: int) {\n+    println!(\"sum is: {}\", x + y);\n+}\n+```\n+\n+You separate arguments with a comma, both when you call the function, as well\n+as when you declare it.\n+\n+Unlike `let`, you _must_ declare the types of function arguments. This does\n+not work:\n+\n+```{ignore}\n+fn print_number(x, y) {\n+    println!(\"x is: {}\", x + y);\n+}\n+```\n+\n+You get this error:\n+\n+```{ignore,notrust}\n+hello.rs:5:18: 5:19 error: expected `:` but found `,`\n+hello.rs:5 fn print_number(x, y) {\n+```\n+\n+This is a deliberate design decision. While full-program inference is possible,\n+languages which have it, like Haskell, often suggest that documenting your\n+types explicitly is a best-practice. We agree that forcing functions to declare\n+types while allowing for inference inside of function bodies is a wonderful\n+compromise between full inference and no inference.\n+\n+What about returning a value? Here's a function that adds one to an integer:\n+\n+```{rust}\n+fn add_one(x: int) -> int {\n+    x + 1\n+}\n+```\n+\n+Rust functions return exactly one value, and you declare the type after an\n+'arrow', which is a dash (`-`) followed by a greater-than sign (`>`).\n+\n+You'll note the lack of a semicolon here. If we added it in:\n+\n+```{ignore}\n+fn add_one(x: int) -> int {\n+    x + 1;\n+}\n+```\n+\n+We would get an error:\n+\n+```{ignore,notrust}\n+note: consider removing this semicolon:\n+     x + 1;\n+          ^\n+error: not all control paths return a value\n+fn add_one(x: int) -> int {\n+     x + 1;\n+}\n+```\n+\n+Remember our earlier discussions about semicolons and `()`? Our function claims\n+to return an `int`, but with a semicolon, it would return `()` instead. Rust\n+realizes this probably isn't what we want, and suggests removing the semicolon.\n+\n+This is very much like our `if` statement before: the result of the block\n+(`{}`) is the value of the expression. Other expression-oriented languages,\n+such as Ruby, work like this, but it's a bit unusual in the systems programming\n+world. When people first learn about this, they usually assume that it\n+introduces bugs. But because Rust's type system is so strong, and because unit\n+is its own unique type, we have never seen an issue where adding or removing a\n+semicolon in a return position would cause a bug.\n+\n+But what about early returns? Rust does have a keyword for that, `return`:\n+\n+```{rust}\n+fn foo(x: int) -> int {\n+    if x < 5 { return x; }\n+\n+    x + 1\n+}\n+```\n+\n+Using a `return` as the last line of a function works, but is considered poor\n+style:\n+\n+```{rust}\n+fn foo(x: int) -> int {\n+    if x < 5 { return x; }\n+\n+    return x + 1;\n+}\n+```\n+\n+There are some additional ways to define functions, but they involve features\n+that we haven't learned about yet, so let's just leave it at that for now.\n+\n+## Comments\n+\n return\n \n comments"}, {"sha": "2a788d7e7934c495d1d6ca218209faa3181c062c", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -469,7 +469,7 @@ fn signum(x: int) -> int {\n \n Rust's `match` construct is a generalized, cleaned-up version of C's\n `switch` construct. You provide it with a value and a number of\n-*arms*, each labelled with a pattern, and the code compares the value\n+*arms*, each labeled with a pattern, and the code compares the value\n against each pattern in order until one matches. The matching pattern\n executes its corresponding arm.\n \n@@ -2524,7 +2524,7 @@ of the components of types. By design, trait objects don't know the exact type\n of their contents and so the compiler cannot reason about those properties.\n \n You can instruct the compiler, however, that the contents of a trait object must\n-acribe to a particular bound with a trailing colon (`:`). These are examples of\n+ascribe to a particular bound with a trailing colon (`:`). These are examples of\n valid types:\n \n ~~~rust\n@@ -2579,7 +2579,7 @@ This is a silly way to compute the radius of a circle\n \n In type-parameterized functions,\n methods of the supertrait may be called on values of subtrait-bound type parameters.\n-Refering to the previous example of `trait Circle : Shape`:\n+Referring to the previous example of `trait Circle : Shape`:\n \n ~~~\n # trait Shape { fn area(&self) -> f64; }"}, {"sha": "2ed7a9dd6c28ab246cf857376ec3d33571f6631d", "filename": "src/etc/install.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fetc%2Finstall.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fetc%2Finstall.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstall.sh?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -214,7 +214,7 @@ need_cmd uname\n need_cmd tr\n need_cmd sed\n \n-CFG_SRC_DIR=\"$(cd $(dirname $0) && pwd)/\"\n+CFG_SRC_DIR=\"$(cd $(dirname $0) && pwd)\"\n CFG_SELF=\"$0\"\n CFG_ARGS=\"$@\"\n "}, {"sha": "9b4f879e61ea4a8474cc172002d31e021b4b6bd6", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -185,7 +185,7 @@ impl<T: Share + Send> Drop for Arc<T> {\n         // deletion of the data. Because it is marked `Release`, the\n         // decreasing of the reference count synchronizes with this `Acquire`\n         // fence. This means that use of the data happens before decreasing\n-        // the refernce count, which happens before this fence, which\n+        // the reference count, which happens before this fence, which\n         // happens before the deletion of the data.\n         //\n         // As explained in the [Boost documentation][1],"}, {"sha": "ddba4b34e3a2a4e8a5664f54b61d95e08ffeb943", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -160,9 +160,27 @@ pub fn from_chars(chs: &[char]) -> String {\n /// Methods for vectors of strings\n pub trait StrVector {\n     /// Concatenate a vector of strings.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let first = \"Restaurant at the End of the\".to_string();\n+    /// let second = \" Universe\".to_string();\n+    /// let string_vec = vec![first, second];\n+    /// assert_eq!(string_vec.concat(), \"Restaurant at the End of the Universe\".to_string());\n+    /// ```\n     fn concat(&self) -> String;\n \n     /// Concatenate a vector of strings, placing a given separator between each.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let first = \"Roast\".to_string();\n+    /// let second = \"Sirloin Steak\".to_string();\n+    /// let string_vec = vec![first, second];\n+    /// assert_eq!(string_vec.connect(\", \"), \"Roast, Sirloin Steak\".to_string());\n+    /// ```\n     fn connect(&self, sep: &str) -> String;\n }\n \n@@ -172,7 +190,7 @@ impl<'a, S: Str> StrVector for &'a [S] {\n             return String::new();\n         }\n \n-        // `len` calculation may overflow but push_str but will check boundaries\n+        // `len` calculation may overflow but push_str will check boundaries\n         let len = self.iter().map(|s| s.as_slice().len()).sum();\n \n         let mut result = String::with_capacity(len);"}, {"sha": "d53ecabd5a9cb147e5093e7ce172dd91acf1835a", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -253,8 +253,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec!(\"hello\", \"world\", \"world\"));\n     /// ```\n     pub fn grow(&mut self, n: uint, value: &T) {\n-        let new_len = self.len() + n;\n-        self.reserve(new_len);\n+        self.reserve_additional(n);\n         let mut i: uint = 0u;\n \n         while i < n {\n@@ -497,7 +496,7 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 10);\n     /// ```\n     pub fn reserve(&mut self, capacity: uint) {\n-        if capacity >= self.len {\n+        if capacity > self.cap {\n             self.reserve_exact(num::next_power_of_two(capacity))\n         }\n     }"}, {"sha": "848509cbab27883f21b589bd8c91660c43a60e06", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -59,7 +59,6 @@ use syntax::codemap::{Span, mk_sp};\n use syntax::ext::base;\n use syntax::ext::base::{ExtCtxt, MacExpr};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse;\n use syntax::parse::token;\n use syntax::parse::token::InternedString;\n use rustc::plugin::Registry;\n@@ -135,11 +134,7 @@ struct Ident {\n \n fn parse_tts(cx: &ExtCtxt,\n              tts: &[ast::TokenTree]) -> (Gc<ast::Expr>, Option<Ident>) {\n-    let p = &mut parse::new_parser_from_tts(cx.parse_sess(),\n-                                            cx.cfg(),\n-                                            tts.iter()\n-                                               .map(|x| (*x).clone())\n-                                               .collect());\n+    let p = &mut cx.new_parser_from_tts(tts);\n     let ex = p.parse_expr();\n     let id = if p.token == token::EOF {\n         None"}, {"sha": "5faa9cfe6f6a2bd0cbbb0c7d80cf95754de2331f", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -124,7 +124,7 @@ impl Drop for Stack {\n }\n \n pub struct StackPool {\n-    // Ideally this would be some datastructure that preserved ordering on\n+    // Ideally this would be some data structure that preserved ordering on\n     // Stack.min_size.\n     stacks: Vec<Stack>,\n }"}, {"sha": "369de484e8e84059d11b9517e48dc5724c81da9b", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -54,7 +54,6 @@ use syntax::codemap::{Span, mk_sp};\n use syntax::ext::base;\n use syntax::ext::base::{ExtCtxt, MacExpr};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse;\n use syntax::parse::token;\n use rustc::plugin::Registry;\n \n@@ -167,11 +166,7 @@ struct Ident {\n \n fn parse_tts(cx: &ExtCtxt,\n              tts: &[ast::TokenTree]) -> (Gc<ast::Expr>, Option<Ident>) {\n-    let p = &mut parse::new_parser_from_tts(cx.parse_sess(),\n-                                            cx.cfg(),\n-                                            tts.iter()\n-                                               .map(|x| (*x).clone())\n-                                               .collect());\n+    let p = &mut cx.new_parser_from_tts(tts);\n     let ex = p.parse_expr();\n     let id = if p.token == token::EOF {\n         None"}, {"sha": "17349f41b98f74889a1df242ddc81ea041e37b90", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -288,7 +288,7 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     unsafe { INIT.doit(init); }\n \n     // It's possible for many threads are in this function, only one of them\n-    // will peform the global initialization, but all of them will need to check\n+    // will perform the global initialization, but all of them will need to check\n     // again to whether they should really be here or not. Hence, despite this\n     // check being expanded manually in the logging macro, this function checks\n     // the log level again."}, {"sha": "f052826d303861f8b24b60d3f83380ef839c91d6", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -877,7 +877,7 @@ pub fn write<T>(fd: sock_t,\n             }\n \n             // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n-            // against unforseen circumstances.\n+            // against unforeseen circumstances.\n             let _guard = lock();\n             let ptr = buf.slice_from(written).as_ptr();\n             let len = buf.len() - written;"}, {"sha": "e5e8cdeffd7e4c2249b44d5a7f1db0fa2fee47f7", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -376,7 +376,7 @@ impl rtio::RtioPipe for UnixStream {\n         if ret != 0 { return Ok(bytes_read as uint) }\n \n         // If our errno doesn't say that the I/O is pending, then we hit some\n-        // legitimate error and reeturn immediately.\n+        // legitimate error and return immediately.\n         if os::errno() != libc::ERROR_IO_PENDING as uint {\n             return Err(super::last_error())\n         }"}, {"sha": "4108388e7766979df1df4e8a06e095d89d31e771", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -32,7 +32,6 @@ use syntax::ast;\n use syntax::codemap;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{ExtCtxt, MacResult, MacExpr, DummyResult};\n-use syntax::parse;\n use syntax::parse::token;\n use syntax::print::pprust;\n \n@@ -615,8 +614,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n /// Looks for a single string literal and returns it.\n /// Otherwise, logs an error with cx.span_err and returns None.\n fn parse(cx: &mut ExtCtxt, tts: &[ast::TokenTree]) -> Option<String> {\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(),\n-                                                Vec::from_slice(tts));\n+    let mut parser = cx.new_parser_from_tts(tts);\n     let entry = cx.expand_expr(parser.parse_expr());\n     let regex = match entry.node {\n         ast::ExprLit(lit) => {"}, {"sha": "4423ab62f0dcfc83c851edcf86102a0f924298b3", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -31,7 +31,7 @@\n #![no_std]\n #![experimental]\n \n-// This library is definining the builtin functions, so it would be a shame for\n+// This library defines the builtin functions, so it would be a shame for\n // LLVM to optimize these function calls to themselves!\n #![no_builtins]\n "}, {"sha": "a190d9309cc8df8612f6fbe85f5a8b76173be14f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -119,7 +119,7 @@ pub mod write {\n     // get all hardware potential via VFP3 (hardware floating point)\n     // and NEON (SIMD) instructions supported by LLVM.\n     // Note that without those flags various linking errors might\n-    // arise as some of intrinsicts are converted into function calls\n+    // arise as some of intrinsics are converted into function calls\n     // and nobody provides implementations those functions\n     fn target_feature<'a>(sess: &'a Session) -> &'a str {\n         match sess.targ_cfg.os {"}, {"sha": "a8f778934ae47e21c28b9b3c016d5326598bd1ea", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -902,12 +902,10 @@ impl LintPass for NonUppercasePatternStatics {\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n-            (&ast::PatIdent(_, ref path, _), Some(&def::DefStatic(_, false))) => {\n-                // last identifier alone is right choice for this lint.\n-                let ident = path.segments.last().unwrap().identifier;\n-                let s = token::get_ident(ident);\n+            (&ast::PatIdent(_, ref path1, _), Some(&def::DefStatic(_, false))) => {\n+                let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(NON_UPPERCASE_PATTERN_STATICS, path.span,\n+                    cx.span_lint(NON_UPPERCASE_PATTERN_STATICS, path1.span,\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n@@ -931,15 +929,13 @@ impl LintPass for UppercaseVariables {\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         match &p.node {\n-            &ast::PatIdent(_, ref path, _) => {\n+            &ast::PatIdent(_, ref path1, _) => {\n                 match cx.tcx.def_map.borrow().find(&p.id) {\n                     Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |\n                             Some(&def::DefArg(_, _)) => {\n-                        // last identifier alone is right choice for this lint.\n-                        let ident = path.segments.last().unwrap().identifier;\n-                        let s = token::get_ident(ident);\n+                        let s = token::get_ident(path1.node);\n                         if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n-                            cx.span_lint(UPPERCASE_VARIABLES, path.span,\n+                            cx.span_lint(UPPERCASE_VARIABLES, path1.span,\n                                          \"variable names should start with \\\n                                           a lowercase character\");\n                         }\n@@ -989,7 +985,7 @@ impl UnnecessaryParens {\n             _ => {}\n         }\n \n-        /// Expressions that syntatically contain an \"exterior\" struct\n+        /// Expressions that syntactically contain an \"exterior\" struct\n         /// literal i.e. not surrounded by any parens or other\n         /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n         /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n@@ -1113,15 +1109,10 @@ impl UnusedMut {\n         // avoid false warnings in match arms with multiple patterns\n         let mut mutables = HashMap::new();\n         for &p in pats.iter() {\n-            pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path| {\n+            pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path1| {\n+                let ident = path1.node;\n                 match mode {\n                     ast::BindByValue(ast::MutMutable) => {\n-                        if path.segments.len() != 1 {\n-                            cx.sess().span_bug(p.span,\n-                                               \"mutable binding that doesn't consist \\\n-                                                of exactly one segment\");\n-                        }\n-                        let ident = path.segments.get(0).identifier;\n                         if !token::get_ident(ident).get().starts_with(\"_\") {\n                             mutables.insert_or_update_with(ident.name as uint,\n                                 vec!(id), |_, old| { old.push(id); });"}, {"sha": "6eb7c5a4310e6f9cb61abc55001000ae275839cc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -809,9 +809,8 @@ fn encode_method_argument_names(ebml_w: &mut Encoder,\n     for arg in decl.inputs.iter() {\n         ebml_w.start_tag(tag_method_argument_name);\n         match arg.pat.node {\n-            ast::PatIdent(_, ref name, _) => {\n-                let name = name.segments.last().unwrap().identifier;\n-                let name = token::get_ident(name);\n+            ast::PatIdent(_, ref path1, _) => {\n+                let name = token::get_ident(path1.node);\n                 ebml_w.writer.write(name.get().as_bytes());\n             }\n             _ => {}\n@@ -1106,8 +1105,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         match ty.node {\n             ast::TyPath(ref path, ref bounds, _) if path.segments\n                                                         .len() == 1 => {\n+                let ident = path.segments.last().unwrap().identifier;\n                 assert!(bounds.is_none());\n-                encode_impl_type_basename(ebml_w, ast_util::path_to_ident(path));\n+                encode_impl_type_basename(ebml_w, ident);\n             }\n             _ => {}\n         }"}, {"sha": "de77fa602c9b406a0bf85a4e8c58b04bb72b7975", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -66,9 +66,9 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n                             move_pat: &ast::Pat,\n                             cmt: mc::cmt) {\n     let pat_span_path_opt = match move_pat.node {\n-        ast::PatIdent(_, ref path, _) => {\n-            Some(MoveSpanAndPath::with_span_and_path(move_pat.span,\n-                                                     (*path).clone()))\n+        ast::PatIdent(_, ref path1, _) => {\n+            Some(MoveSpanAndPath{span: move_pat.span,\n+                                 ident: path1.node})\n         },\n         _ => None,\n     };"}, {"sha": "f5c91f7b1b3bf4441e664ff0fd479486864b6d22", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -56,19 +56,8 @@ impl MoveError {\n \n #[deriving(Clone)]\n pub struct MoveSpanAndPath {\n-    span: codemap::Span,\n-    path: ast::Path\n-}\n-\n-impl MoveSpanAndPath {\n-    pub fn with_span_and_path(span: codemap::Span,\n-                              path: ast::Path)\n-                              -> MoveSpanAndPath {\n-        MoveSpanAndPath {\n-            span: span,\n-            path: path,\n-        }\n-    }\n+    pub span: codemap::Span,\n+    pub ident: ast::Ident\n }\n \n pub struct GroupedMoveErrors {\n@@ -83,7 +72,7 @@ fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {\n         let mut is_first_note = true;\n         for move_to in error.move_to_places.iter() {\n             note_move_destination(bccx, move_to.span,\n-                                  &move_to.path, is_first_note);\n+                                  &move_to.ident, is_first_note);\n             is_first_note = false;\n         }\n     }\n@@ -154,9 +143,9 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n \n fn note_move_destination(bccx: &BorrowckCtxt,\n                          move_to_span: codemap::Span,\n-                         pat_ident_path: &ast::Path,\n+                         pat_ident: &ast::Ident,\n                          is_first_note: bool) {\n-    let pat_name = pprust::path_to_str(pat_ident_path);\n+    let pat_name = pprust::ident_to_str(pat_ident);\n     if is_first_note {\n         bccx.span_note(\n             move_to_span,"}, {"sha": "70db3e964abb3273cc2f4d078a3c809b1c7fdad0", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -247,6 +247,10 @@ impl<'a> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a> {\n             ast::PatStruct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields.as_slice());\n             }\n+            ast::PatIdent(_, _, _) => {\n+                // it might be the only use of a static:\n+                self.lookup_and_handle_definition(&pat.id)\n+            }\n             _ => ()\n         }\n "}, {"sha": "a7154e78bc58612d7243430bd2aa3a106be75ac1", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -13,14 +13,15 @@ use middle::freevars::freevar_entry;\n use middle::freevars;\n use middle::subst;\n use middle::ty;\n+use middle::typeck::{MethodCall, NoAdjustment};\n use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n use util::ppaux::UserString;\n \n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Span;\n-use syntax::print::pprust::{expr_to_str,path_to_str};\n+use syntax::print::pprust::{expr_to_str, ident_to_str};\n use syntax::{visit};\n use syntax::visit::Visitor;\n \n@@ -261,7 +262,15 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n         ExprCast(ref source, _) => {\n             let source_ty = ty::expr_ty(cx.tcx, &**source);\n             let target_ty = ty::expr_ty(cx.tcx, e);\n-            check_trait_cast(cx, source_ty, target_ty, source.span);\n+            let method_call = MethodCall {\n+                expr_id: e.id,\n+                adjustment: NoAdjustment,\n+            };\n+            check_trait_cast(cx,\n+                             source_ty,\n+                             target_ty,\n+                             source.span,\n+                             method_call);\n         }\n         ExprRepeat(ref element, ref count_expr) => {\n             let count = ty::eval_repeat_count(cx.tcx, &**count_expr);\n@@ -281,7 +290,15 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n                 ty::AutoObject(..) => {\n                     let source_ty = ty::expr_ty(cx.tcx, e);\n                     let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n-                    check_trait_cast(cx, source_ty, target_ty, e.span);\n+                    let method_call = MethodCall {\n+                        expr_id: e.id,\n+                        adjustment: typeck::AutoObject,\n+                    };\n+                    check_trait_cast(cx,\n+                                     source_ty,\n+                                     target_ty,\n+                                     e.span,\n+                                     method_call);\n                 }\n                 ty::AutoAddEnv(..) |\n                 ty::AutoDerefRef(..) => {}\n@@ -364,15 +381,62 @@ fn check_bounds_on_type_parameters(cx: &mut Context, e: &Expr) {\n     }\n }\n \n-fn check_trait_cast(cx: &mut Context, source_ty: ty::t, target_ty: ty::t, span: Span) {\n+fn check_type_parameter_bounds_in_vtable_result(\n+        cx: &mut Context,\n+        span: Span,\n+        vtable_res: &typeck::vtable_res) {\n+    for origins in vtable_res.iter() {\n+        for origin in origins.iter() {\n+            let (type_param_defs, substs) = match *origin {\n+                typeck::vtable_static(def_id, ref tys, _) => {\n+                    let type_param_defs =\n+                        ty::lookup_item_type(cx.tcx, def_id).generics\n+                                                            .types\n+                                                            .clone();\n+                    (type_param_defs, (*tys).clone())\n+                }\n+                _ => {\n+                    // Nothing to do here.\n+                    continue\n+                }\n+            };\n+            for type_param_def in type_param_defs.iter() {\n+                let typ = substs.types.get(type_param_def.space,\n+                                           type_param_def.index);\n+                check_typaram_bounds(cx, span, *typ, type_param_def)\n+            }\n+        }\n+    }\n+}\n+\n+fn check_trait_cast(cx: &mut Context,\n+                    source_ty: ty::t,\n+                    target_ty: ty::t,\n+                    span: Span,\n+                    method_call: MethodCall) {\n     check_cast_for_escaping_regions(cx, source_ty, target_ty, span);\n     match ty::get(target_ty).sty {\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ ty, .. }) => match ty::get(ty).sty {\n-            ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n-                check_trait_cast_bounds(cx, span, source_ty, bounds);\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ ty, .. }) => {\n+            match ty::get(ty).sty {\n+                ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n+                     match cx.tcx.vtable_map.borrow().find(&method_call) {\n+                        None => {\n+                            cx.tcx.sess.span_bug(span,\n+                                                 \"trait cast not in vtable \\\n+                                                  map?!\")\n+                        }\n+                        Some(vtable_res) => {\n+                            check_type_parameter_bounds_in_vtable_result(\n+                                cx,\n+                                span,\n+                                vtable_res)\n+                        }\n+                    };\n+                    check_trait_cast_bounds(cx, span, source_ty, bounds);\n+                }\n+                _ => {}\n             }\n-            _ => {}\n-        },\n+        }\n         _ => {}\n     }\n }\n@@ -627,7 +691,7 @@ fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: String, sp: Span) {\n fn check_pat(cx: &mut Context, pat: &Pat) {\n     let var_name = match pat.node {\n         PatWild => Some(\"_\".to_string()),\n-        PatIdent(_, ref path, _) => Some(path_to_str(path).to_string()),\n+        PatIdent(_, ref path1, _) => Some(ident_to_str(&path1.node).to_string()),\n         _ => None\n     };\n "}, {"sha": "d48f7f541f0da016d1c85cfe980a529656c89031", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -367,9 +367,9 @@ fn visit_fn(ir: &mut IrMaps,\n     for arg in decl.inputs.iter() {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n                                &*arg.pat,\n-                               |_bm, arg_id, _x, path| {\n+                               |_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n-            let ident = ast_util::path_to_ident(path);\n+            let ident = path1.node;\n             fn_maps.add_variable(Arg(arg_id, ident));\n         })\n     };\n@@ -399,9 +399,9 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &Local) {\n-    pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path| {\n+    pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n-        let name = ast_util::path_to_ident(path);\n+        let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n         ir.add_variable(Local(LocalInfo {\n           id: p_id,\n@@ -413,10 +413,10 @@ fn visit_local(ir: &mut IrMaps, local: &Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n-            let name = ast_util::path_to_ident(path);\n+            let name = path1.node;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n             ir.add_variable(Local(LocalInfo {\n                 id: p_id,\n@@ -1522,10 +1522,10 @@ impl<'a> Liveness<'a> {\n         for arg in decl.inputs.iter() {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n                                    &*arg.pat,\n-                                   |_bm, p_id, sp, path| {\n+                                   |_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n-                let ident = ast_util::path_to_ident(path);\n+                let ident = path1.node;\n                 if ident.name != special_idents::self_.name {\n                     self.warn_about_unused(sp, p_id, entry_ln, var);\n                 }"}, {"sha": "54cca082e0de86950a10f7c26aeb8672369b6ae4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -383,7 +383,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             Some(adjustment) => {\n                 match *adjustment {\n                     ty::AutoObject(..) => {\n-                        // Implicity cast a concrete object to trait object.\n+                        // Implicitly cast a concrete object to trait object.\n                         // Result is an rvalue.\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))"}, {"sha": "2d53d742ee44b15800ed580c6f375f65b1e87a24", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -14,7 +14,7 @@ use middle::resolve;\n use std::collections::HashMap;\n use std::gc::{Gc, GC};\n use syntax::ast::*;\n-use syntax::ast_util::{path_to_ident, walk_pat};\n+use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n \n pub type PatIdMap = HashMap<Ident, NodeId>;\n@@ -23,8 +23,8 @@ pub type PatIdMap = HashMap<Ident, NodeId>;\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: &resolve::DefMap, pat: &Pat) -> PatIdMap {\n     let mut map = HashMap::new();\n-    pat_bindings(dm, pat, |_bm, p_id, _s, n| {\n-      map.insert(path_to_ident(n), p_id);\n+    pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n+      map.insert(path1.node, p_id);\n     });\n     map\n }\n@@ -75,7 +75,7 @@ pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &Pat) -> bool {\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings(dm: &resolve::DefMap,\n                     pat: &Pat,\n-                    it: |BindingMode, NodeId, Span, &Path|) {\n+                    it: |BindingMode, NodeId, Span, &SpannedIdent|) {\n     walk_pat(pat, |p| {\n         match p.node {\n           PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n@@ -102,10 +102,10 @@ pub fn pat_contains_bindings(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     contains_bindings\n }\n \n-pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Path> {\n+pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n     match pat.node {\n-        PatIdent(BindByValue(_), ref path, None) => {\n-            Some(path)\n+        PatIdent(BindByValue(_), ref path1, None) => {\n+            Some(&path1.node)\n         }\n         _ => {\n             None"}, {"sha": "76e962a3bc4da6a1894def5f64c29b5c0b374072", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -1267,7 +1267,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n             // error messages without (too many) false positives\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n-            // publically visible.\n+            // publicly visible.\n             ast::ItemImpl(ref g, ref trait_ref, self_, ref methods) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;"}, {"sha": "b7b4618a7904619a97f34eacd6d26a0efe1a2b0f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 56, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -23,11 +23,10 @@ use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_util::{local_def};\n-use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n+use syntax::ast_util::{walk_pat, trait_method_to_ty_method};\n use syntax::ext::mtwt;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n-use syntax::print::pprust::path_to_str;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n@@ -1247,7 +1246,7 @@ impl<'a> Resolver<'a> {\n                 // Create the module and add all methods.\n                 match ty.node {\n                     TyPath(ref path, _, _) if path.segments.len() == 1 => {\n-                        let name = path_to_ident(path);\n+                        let name = path.segments.last().unwrap().identifier;\n \n                         let parent_opt = parent.module().children.borrow()\n                                                .find_copy(&name.name);\n@@ -4104,8 +4103,8 @@ impl<'a> Resolver<'a> {\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n         let mut result = HashMap::new();\n-        pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path| {\n-            let name = mtwt::resolve(path_to_ident(path));\n+        pat_bindings(&self.def_map, pat, |binding_mode, _id, sp, path1| {\n+            let name = mtwt::resolve(path1.node);\n             result.insert(name,\n                           binding_info {span: sp,\n                                         binding_mode: binding_mode});\n@@ -4314,8 +4313,7 @@ impl<'a> Resolver<'a> {\n         let pat_id = pattern.id;\n         walk_pat(pattern, |pattern| {\n             match pattern.node {\n-                PatIdent(binding_mode, ref path, _)\n-                        if !path.global && path.segments.len() == 1 => {\n+                PatIdent(binding_mode, ref path1, _) => {\n \n                     // The meaning of pat_ident with no type parameters\n                     // depends on whether an enum variant or unit-like struct\n@@ -4326,7 +4324,7 @@ impl<'a> Resolver<'a> {\n                     // such a value is simply disallowed (since it's rarely\n                     // what you want).\n \n-                    let ident = path.segments.get(0).identifier;\n+                    let ident = path1.node;\n                     let renamed = mtwt::resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident) {\n@@ -4416,57 +4414,12 @@ impl<'a> Resolver<'a> {\n                                     format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            path_to_str(path)).as_slice());\n+                                            token::get_ident(ident)).as_slice());\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n                         }\n                     }\n-\n-                    // Check the types in the path pattern.\n-                    for ty in path.segments\n-                                  .iter()\n-                                  .flat_map(|seg| seg.types.iter()) {\n-                        self.resolve_type(&**ty);\n-                    }\n-                }\n-\n-                PatIdent(binding_mode, ref path, _) => {\n-                    // This must be an enum variant, struct, or constant.\n-                    match self.resolve_path(pat_id, path, ValueNS, false) {\n-                        Some(def @ (DefVariant(..), _)) |\n-                        Some(def @ (DefStruct(..), _)) => {\n-                            self.record_def(pattern.id, def);\n-                        }\n-                        Some(def @ (DefStatic(..), _)) => {\n-                            self.enforce_default_binding_mode(\n-                                pattern,\n-                                binding_mode,\n-                                \"a constant\");\n-                            self.record_def(pattern.id, def);\n-                        }\n-                        Some(_) => {\n-                            self.resolve_error(\n-                                path.span,\n-                                format!(\"`{}` is not an enum variant or constant\",\n-                                        token::get_ident(\n-                                            path.segments\n-                                                .last()\n-                                                .unwrap()\n-                                                .identifier)).as_slice())\n-                        }\n-                        None => {\n-                            self.resolve_error(path.span,\n-                                                  \"unresolved enum variant\");\n-                        }\n-                    }\n-\n-                    // Check the types in the path pattern.\n-                    for ty in path.segments\n-                                  .iter()\n-                                  .flat_map(|s| s.types.iter()) {\n-                        self.resolve_type(&**ty);\n-                    }\n                 }\n \n                 PatEnum(ref path, _) => {\n@@ -5202,8 +5155,8 @@ impl<'a> Resolver<'a> {\n                                              in a static method. Maybe a \\\n                                              `self` argument is missing?\");\n                                 } else {\n-                                    let name = path_to_ident(path).name;\n-                                    let mut msg = match self.find_fallback_in_self_type(name) {\n+                                    let last_name = path.segments.last().unwrap().identifier.name;\n+                                    let mut msg = match self.find_fallback_in_self_type(last_name) {\n                                         NoSuggestion => {\n                                             // limit search to 5 to reduce the number\n                                             // of stupid suggestions"}, {"sha": "bdb7d30339d66f010f0ba8e170dffe17dcaafe4b", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -484,7 +484,7 @@ impl <'l> DxrVisitor<'l> {\n     {\n         let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n \n-        // If the variable is immutable, save the initialising expresion.\n+        // If the variable is immutable, save the initialising expression.\n         let value = match mt {\n             ast::MutMutable => String::from_str(\"<mutable>\"),\n             ast::MutImmutable => self.span.snippet(expr.span),\n@@ -845,7 +845,7 @@ impl <'l> DxrVisitor<'l> {\n                 let decl_id = ty::trait_method_of_method(&self.analysis.ty_cx, def_id);\n \n                 // This incantation is required if the method referenced is a trait's\n-                // defailt implementation.\n+                // default implementation.\n                 let def_id = ty::method(&self.analysis.ty_cx, def_id).provided_source\n                                     .unwrap_or(def_id);\n                 (Some(def_id), decl_id)\n@@ -926,7 +926,7 @@ impl <'l> DxrVisitor<'l> {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n                 visit::walk_pat(self, p, e);\n             }\n-            ast::PatIdent(bm, ref path, ref optional_subpattern) => {\n+            ast::PatIdent(bm, ref path1, ref optional_subpattern) => {\n                 let immut = match bm {\n                     // Even if the ref is mut, you can't change the ref, only\n                     // the data pointed at, so showing the initialising expression\n@@ -940,7 +940,8 @@ impl <'l> DxrVisitor<'l> {\n                     }\n                 };\n                 // collect path for either visit_local or visit_arm\n-                self.collected_paths.push((p.id, path.clone(), immut, recorder::VarRef));\n+                let path = ast_util::ident_to_path(path1.span,path1.node);\n+                self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n                 match *optional_subpattern {\n                     None => {}\n                     Some(subpattern) => self.visit_pat(&*subpattern, e),\n@@ -1402,7 +1403,7 @@ pub fn process_crate(sess: &Session,\n         info!(\"Writing output to {}\", disp);\n     }\n \n-    // Create ouput file.\n+    // Create output file.\n     let mut out_name = cratename.clone();\n     out_name.push_str(\".csv\");\n     root_path.push(out_name);"}, {"sha": "655973c3d33d4a55f2f20f355c0d4e87416a49c0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -224,8 +224,6 @@ use std::rc::Rc;\n use std::gc::{Gc};\n use syntax::ast;\n use syntax::ast::Ident;\n-use syntax::ast_util::path_to_ident;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n \n@@ -429,13 +427,13 @@ fn expand_nested_bindings<'a, 'b>(\n \n     m.iter().map(|br| {\n         match br.pats.get(col).node {\n-            ast::PatIdent(_, ref path, Some(inner)) => {\n+            ast::PatIdent(_, ref path1, Some(inner)) => {\n                 let pats = Vec::from_slice(br.pats.slice(0u, col))\n                            .append((vec!(inner))\n                                    .append(br.pats.slice(col + 1u, br.pats.len())).as_slice());\n \n                 let mut bound_ptrs = br.bound_ptrs.clone();\n-                bound_ptrs.push((path_to_ident(path), val));\n+                bound_ptrs.push((path1.node, val));\n                 Match {\n                     pats: pats,\n                     data: &*br.data,\n@@ -473,9 +471,9 @@ fn enter_match<'a, 'b>(\n             let this = *br.pats.get(col);\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n-                ast::PatIdent(_, ref path, None) => {\n+                ast::PatIdent(_, ref path1, None) => {\n                     if pat_is_binding(dm, &*this) {\n-                        bound_ptrs.push((path_to_ident(path), val));\n+                        bound_ptrs.push((path1.node, val));\n                     }\n                 }\n                 _ => {}\n@@ -1366,8 +1364,8 @@ fn create_bindings_map(bcx: &Block, pat: Gc<ast::Pat>) -> BindingsMap {\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path| {\n-        let ident = path_to_ident(path);\n+    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n+        let ident = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();\n@@ -1520,10 +1518,10 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n             // In such cases, the more general path is unsafe, because\n             // it assumes it is matching against a valid value.\n             match simple_identifier(&*pat) {\n-                Some(path) => {\n+                Some(ident) => {\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n-                        bcx, pat.id, path, BindLocal, var_scope, (),\n+                        bcx, pat.id, ident, BindLocal, var_scope, (),\n                         |(), bcx, v, _| expr::trans_into(bcx, &*init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n@@ -1555,10 +1553,10 @@ pub fn store_local<'a>(bcx: &'a Block<'a>,\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        pat_bindings(&tcx.def_map, &*pat, |_, p_id, _, path| {\n+        pat_bindings(&tcx.def_map, &*pat, |_, p_id, _, path1| {\n                 let scope = cleanup::var_scope(tcx, p_id);\n                 bcx = mk_binding_alloca(\n-                    bcx, p_id, path, BindLocal, scope, (),\n+                    bcx, p_id, &path1.node, BindLocal, scope, (),\n                     |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n             });\n         bcx\n@@ -1586,7 +1584,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n     let _icx = push_ctxt(\"match::store_arg\");\n \n     match simple_identifier(&*pat) {\n-        Some(path) => {\n+        Some(ident) => {\n             // Generate nicer LLVM for the common case of fn a pattern\n             // like `x: T`\n             let arg_ty = node_id_type(bcx, pat.id);\n@@ -1601,7 +1599,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n                 bcx\n             } else {\n                 mk_binding_alloca(\n-                    bcx, pat.id, path, BindArgument, arg_scope, arg,\n+                    bcx, pat.id, ident, BindArgument, arg_scope, arg,\n                     |arg, bcx, llval, _| arg.store_to(bcx, llval))\n             }\n         }\n@@ -1619,17 +1617,16 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n \n fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n                            p_id: ast::NodeId,\n-                           path: &ast::Path,\n+                           ident: &ast::Ident,\n                            binding_mode: IrrefutablePatternBindingMode,\n                            cleanup_scope: cleanup::ScopeId,\n                            arg: A,\n                            populate: |A, &'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>)\n                          -> &'a Block<'a> {\n     let var_ty = node_id_type(bcx, p_id);\n-    let ident = ast_util::path_to_ident(path);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(ident).as_slice());\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident).as_slice());\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1687,13 +1684,13 @@ fn bind_irrefutable_pat<'a>(\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        ast::PatIdent(pat_binding_mode, ref path, inner) => {\n+        ast::PatIdent(pat_binding_mode, ref path1, inner) => {\n             if pat_is_binding(&tcx.def_map, &*pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map.\n                 bcx = mk_binding_alloca(\n-                    bcx, pat.id, path, binding_mode, cleanup_scope, (),\n+                    bcx, pat.id, &path1.node, binding_mode, cleanup_scope, (),\n                     |(), bcx, llval, ty| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {"}, {"sha": "b3c7c0d0fac46e19c278ed001880bf935842e695", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -842,8 +842,8 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n     let cx = bcx.ccx();\n     let def_map = &cx.tcx.def_map;\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path_ref| {\n-        let var_ident = ast_util::path_to_ident(path_ref);\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n+        let var_ident = path1.node;\n \n         let datum = match bcx.fcx.lllocals.borrow().find_copy(&node_id) {\n             Some(datum) => datum,\n@@ -890,8 +890,8 @@ pub fn create_captured_var_metadata(bcx: &Block,\n         }\n         Some(ast_map::NodeLocal(pat)) | Some(ast_map::NodeArg(pat)) => {\n             match pat.node {\n-                ast::PatIdent(_, ref path, _) => {\n-                    ast_util::path_to_ident(path)\n+                ast::PatIdent(_, ref path1, _) => {\n+                    path1.node\n                 }\n                 _ => {\n                     cx.sess()\n@@ -1007,7 +1007,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let def_map = &cx.tcx.def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path_ref| {\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n         let llarg = match bcx.fcx.llargs.borrow().find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n@@ -1022,8 +1022,6 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n                                     Referenced variable location is not an alloca!\");\n         }\n \n-        let argument_ident = ast_util::path_to_ident(path_ref);\n-\n         let argument_index = {\n             let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n             let argument_index = counter.get();\n@@ -1032,7 +1030,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n         };\n \n         declare_local(bcx,\n-                      argument_ident,\n+                      path1.node,\n                       llarg.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: llarg.val },\n@@ -3237,10 +3235,9 @@ fn populate_scope_map(cx: &CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for &arg_pat in arg_pats.iter() {\n-        pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path_ref| {\n-            let ident = ast_util::path_to_ident(path_ref);\n+        pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               ident: Some(ident) });\n+                                               ident: Some(path1.node) });\n         })\n     }\n \n@@ -3348,13 +3345,13 @@ fn populate_scope_map(cx: &CrateContext,\n         // ast_util::walk_pat() here because we have to visit *all* nodes in\n         // order to put them into the scope map. The above functions don't do that.\n         match pat.node {\n-            ast::PatIdent(_, ref path_ref, ref sub_pat_opt) => {\n+            ast::PatIdent(_, ref path1, ref sub_pat_opt) => {\n \n                 // Check if this is a binding. If so we need to put it on the\n                 // scope stack and maybe introduce an artificial scope\n                 if pat_util::pat_is_binding(def_map, &*pat) {\n \n-                    let ident = ast_util::path_to_ident(path_ref);\n+                    let ident = path1.node;\n \n                     // LLVM does not properly generate 'DW_AT_start_scope' fields\n                     // for variable DIEs. For this reason we have to introduce"}, {"sha": "9629fb38af80fb62cf58726d520725b139aba143", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -2771,8 +2771,8 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n     match cx.map.find(id) {\n         Some(ast_map::NodeLocal(pat)) => {\n             match pat.node {\n-                ast::PatIdent(_, ref path, _) => {\n-                    token::get_ident(ast_util::path_to_ident(path))\n+                ast::PatIdent(_, ref path1, _) => {\n+                    token::get_ident(path1.node)\n                 }\n                 _ => {\n                     cx.sess.bug("}, {"sha": "697c5d367ee5a51ab3a65cd2a6945de0d3ae5db6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -485,7 +485,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         demand::suptype(fcx, pat.span, expected, const_pty.ty);\n         fcx.write_ty(pat.id, const_pty.ty);\n       }\n-      ast::PatIdent(bm, ref name, sub) if pat_is_binding(&tcx.def_map, pat) => {\n+      ast::PatIdent(bm, ref path1, sub) if pat_is_binding(&tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n@@ -507,7 +507,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           }\n         }\n \n-        let canon_id = *pcx.map.get(&ast_util::path_to_ident(name));\n+        let canon_id = *pcx.map.get(&path1.node);\n         if canon_id != pat.id {\n             let ct = fcx.local_ty(pat.span, canon_id);\n             demand::eqtype(fcx, pat.span, ct, typ);\n@@ -521,8 +521,10 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           _ => ()\n         }\n       }\n-      ast::PatIdent(_, ref path, _) => {\n-        check_pat_variant(pcx, pat, path, &Some(Vec::new()), expected);\n+      // it's not a binding, it's an enum in disguise:\n+      ast::PatIdent(_, ref path1, _) => {\n+        let path = ast_util::ident_to_path(path1.span,path1.node);\n+        check_pat_variant(pcx, pat, &path, &Some(Vec::new()), expected);\n       }\n       ast::PatEnum(ref path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);"}, {"sha": "b68991aed70963c53c341788689c4f11e1652a7a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -406,11 +406,11 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n             match p.node {\n-              ast::PatIdent(_, ref path, _)\n+              ast::PatIdent(_, ref path1, _)\n                   if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n                 self.assign(p.id, None);\n                 debug!(\"Pattern binding {} is assigned to {}\",\n-                       token::get_ident(path.segments.get(0).identifier),\n+                       token::get_ident(path1.node),\n                        self.fcx.infcx().ty_to_str(\n                            self.fcx.inh.locals.borrow().get_copy(&p.id)));\n               }"}, {"sha": "bda47d99ed7146d0ec7b12ab9dd292a8d19df9ae", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -398,6 +398,9 @@ fn search_for_vtable(vcx: &VtableContext,\n         // Resolve any sub bounds. Note that there still may be free\n         // type variables in substs. This might still be OK: the\n         // process of looking up bounds might constrain some of them.\n+        //\n+        // This does not check built-in traits because those are handled\n+        // later in the kind checking pass.\n         let im_generics =\n             ty::lookup_item_type(tcx, impl_did).generics;\n         let subres = lookup_vtables(vcx,"}, {"sha": "44afc04d3f0efc3984c432dbe6d077e2e835148e", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -93,7 +93,7 @@ pub struct UnificationTable<K,V> {\n \n /**\n  * At any time, users may snapshot a unification table.  The changes\n- * made during the snapshot may either be *commited* or *rolled back*.\n+ * made during the snapshot may either be *committed* or *rolled back*.\n  */\n pub struct Snapshot<K> {\n     // Ensure that this snapshot is keyed to the table type.\n@@ -152,7 +152,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n \n     /**\n      * Starts a new snapshot. Each snapshot must be either\n-     * rolled back or commited in a \"LIFO\" (stack) order.\n+     * rolled back or committed in a \"LIFO\" (stack) order.\n      */\n     pub fn snapshot(&mut self) -> Snapshot<K> {\n         let length = self.undo_log.len();\n@@ -188,12 +188,12 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n             match self.undo_log.pop().unwrap() {\n                 OpenSnapshot => {\n                     // This indicates a failure to obey the stack discipline.\n-                    tcx.sess.bug(\"Cannot rollback an uncommited snapshot\");\n+                    tcx.sess.bug(\"Cannot rollback an uncommitted snapshot\");\n                 }\n \n                 CommittedSnapshot => {\n                     // This occurs when there are nested snapshots and\n-                    // the inner is commited but outer is rolled back.\n+                    // the inner is committed but outer is rolled back.\n                 }\n \n                 NewVar(i) => {"}, {"sha": "7b6935df42079a561fd0e8a12006937679511f71", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -216,9 +216,9 @@ pub type vtable_res = VecPerParamSpace<vtable_param_res>;\n #[deriving(Clone)]\n pub enum vtable_origin {\n     /*\n-      Statically known vtable. def_id gives the class or impl item\n+      Statically known vtable. def_id gives the impl item\n       from whence comes the vtable, and tys are the type substs.\n-      vtable_res is the vtable itself\n+      vtable_res is the vtable itself.\n      */\n     vtable_static(ast::DefId, subst::Substs, vtable_res),\n "}, {"sha": "d0873d4c66afc9ac9310355b71d55fd506717fe9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -1583,8 +1583,6 @@ impl Clean<PathSegment> for ast::PathSegment {\n }\n \n fn path_to_str(p: &ast::Path) -> String {\n-    use syntax::parse::token;\n-\n     let mut s = String::new();\n     let mut first = true;\n     for i in p.segments.iter().map(|x| token::get_ident(x.identifier)) {\n@@ -1739,7 +1737,7 @@ pub struct ViewItem {\n \n impl Clean<Vec<Item>> for ast::ViewItem {\n     fn clean(&self) -> Vec<Item> {\n-        // We consider inlining the documentation of `pub use` statments, but we\n+        // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n         let denied = self.vis != ast::Public || self.attrs.iter().any(|a| {\n@@ -1953,7 +1951,7 @@ fn name_from_pat(p: &ast::Pat) -> String {\n     match p.node {\n         PatWild => \"_\".to_string(),\n         PatWildMulti => \"..\".to_string(),\n-        PatIdent(_, ref p, _) => path_to_str(p),\n+        PatIdent(_, ref p, _) => token::get_ident(p.node).get().to_string(),\n         PatEnum(ref p, _) => path_to_str(p),\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),"}, {"sha": "161d3ed5e65e1cf70b259481e2321f7b2ebbb754", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -376,7 +376,7 @@ pub trait ToCStr {\n // (without forcing an additional & around &str). So we are instead\n // temporarily adding an instance for ~str and String, so that we can\n // take ToCStr as owned. When DST lands, the string instances should\n-// be revisted, and arguments bound by ToCStr should be passed by\n+// be revisited, and arguments bound by ToCStr should be passed by\n // reference.\n \n impl<'a> ToCStr for &'a str {"}, {"sha": "f018b3fc16b3b63a8b26145731084f6df32af474", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -97,7 +97,7 @@ extern {}\n \n extern \"C\" {\n     // iOS on armv7 uses SjLj exceptions and requires to link\n-    // agains corresponding routine (..._SjLj_...)\n+    // against corresponding routine (..._SjLj_...)\n     #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n     pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)\n                                   -> _Unwind_Reason_Code;"}, {"sha": "59401a8b66604f0568c80a293bf0421e9ed1ecee", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -170,7 +170,7 @@ impl Task {\n     /// This function can be used as an emulated \"try/catch\" to interoperate\n     /// with the rust runtime at the outermost boundary. It is not possible to\n     /// use this function in a nested fashion (a try/catch inside of another\n-    /// try/catch). Invoking this funciton is quite cheap.\n+    /// try/catch). Invoking this function is quite cheap.\n     ///\n     /// If the closure `f` succeeds, then the returned task can be used again\n     /// for another invocation of `run`. If the closure `f` fails then `self`\n@@ -276,7 +276,7 @@ impl Task {\n         // 1. If TLD destruction fails, heap destruction will be attempted.\n         //    There is a test for this at fail-during-tld-destroy.rs. Sadly the\n         //    other way can't be tested due to point 2 above. Note that we must\n-        //    immortalize the heap first becuase if any deallocations are\n+        //    immortalize the heap first because if any deallocations are\n         //    attempted while TLD is being dropped it will attempt to free the\n         //    allocation from the wrong heap (because the current one has been\n         //    replaced)."}, {"sha": "59784328cdb50c02448a3893b1a4776e947415e3", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -243,7 +243,7 @@ mod imp {\n                 // EINVAL means |stack_size| is either too small or not a\n                 // multiple of the system page size.  Because it's definitely\n                 // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the neareast page and try again.\n+                // Round up to the nearest page and try again.\n                 let page_size = libc::sysconf(libc::_SC_PAGESIZE) as uint;\n                 let stack_size = (stack_size + page_size - 1) &\n                                  (-(page_size as int - 1) as uint - 1);"}, {"sha": "a1712394634b8c2d52d7e0cf50ab48c41661228d", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -234,7 +234,7 @@ impl ForbidUnwind {\n impl Drop for ForbidUnwind {\n     fn drop(&mut self) {\n         assert!(self.failing_before == task::failing(),\n-                \"didnt want an unwind during: {}\", self.msg);\n+                \"didn't want an unwind during: {}\", self.msg);\n     }\n }\n "}, {"sha": "875c2dee46b4f874f9cf84a8d293c594558f563b", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -87,7 +87,7 @@ impl StreamWatcher {\n         // immediately as part of the call to alloc_cb. What this means is that\n         // we must be ready for this to happen (by setting the data in the uv\n         // handle). In theory this otherwise doesn't need to happen until after\n-        // the read is succesfully started.\n+        // the read is successfully started.\n         unsafe { uvll::set_data_for_uv_handle(self.handle, &mut rcx) }\n \n         // Send off the read request, but don't block until we're sure that the"}, {"sha": "f6c1cdd2977549f9a5ca7ebd36092fa85872b4cf", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -77,7 +77,7 @@ impl RtioTimer for TimerWatcher {\n     fn sleep(&mut self, msecs: u64) {\n         // As with all of the below functions, we must be extra careful when\n         // destroying the previous action. If the previous action was a channel,\n-        // destroying it could invoke a context switch. For these situtations,\n+        // destroying it could invoke a context switch. For these situations,\n         // we must temporarily un-home ourselves, then destroy the action, and\n         // then re-home again.\n         let missile = self.fire_homing_missile();"}, {"sha": "ca59849202b08677e03943747fb2617d6eb6a687", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -410,7 +410,7 @@ mod test {\n         // colon after v4\n         let none: Option<IpAddr> = FromStr::from_str(\"::127.0.0.1:\");\n         assert_eq!(None, none);\n-        // not enought groups\n+        // not enough groups\n         let none: Option<IpAddr> = FromStr::from_str(\"1.2.3.4.5:127.0.0.1\");\n         assert_eq!(None, none);\n         // too many groups"}, {"sha": "21903eb26439cc30c79b60d90acdd8ff29bf51a9", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -165,14 +165,20 @@ impl UdpSocket {\n \n     /// Sets the broadcast flag on or off\n     #[experimental]\n-    pub fn set_broadast(&mut self, broadcast: bool) -> IoResult<()> {\n+    pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n         if broadcast {\n             self.obj.hear_broadcasts()\n         } else {\n             self.obj.ignore_broadcasts()\n         }.map_err(IoError::from_rtio_error)\n     }\n \n+    /// Sets the broadcast flag on or off\n+    #[deprecated=\"renamed to `set_broadcast`\"]\n+    pub fn set_broadast(&mut self, broadcast: bool) -> IoResult<()> {\n+        self.set_broadcast(broadcast)\n+    }\n+\n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`"}, {"sha": "b3f25914c8f568768c22fd62c6523e837895e9c0", "filename": "src/libstd/os.rs", "status": "modified", "additions": 148, "deletions": 61, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -45,7 +45,7 @@ use path::{Path, GenericPath, BytesContainer};\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n-use slice::{Vector, ImmutableVector, MutableVector};\n+use slice::{Vector, ImmutableVector, MutableVector, ImmutableEqVector};\n use str::{Str, StrSlice, StrAllocating};\n use str;\n use string::String;\n@@ -398,9 +398,9 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n-pub fn setenv(n: &str, v: &str) {\n+pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n     #[cfg(unix)]\n-    fn _setenv(n: &str, v: &str) {\n+    fn _setenv(n: &str, v: &[u8]) {\n         unsafe {\n             with_env_lock(|| {\n                 n.with_c_str(|nbuf| {\n@@ -413,18 +413,20 @@ pub fn setenv(n: &str, v: &str) {\n     }\n \n     #[cfg(windows)]\n-    fn _setenv(n: &str, v: &str) {\n+    fn _setenv(n: &str, v: &[u8]) {\n         let n: Vec<u16> = n.utf16_units().collect();\n         let n = n.append_one(0);\n-        let v: Vec<u16> = v.utf16_units().collect();\n+        let v: Vec<u16> = str::from_utf8(v).unwrap().utf16_units().collect();\n         let v = v.append_one(0);\n+\n         unsafe {\n             with_env_lock(|| {\n                 libc::SetEnvironmentVariableW(n.as_ptr(), v.as_ptr());\n             })\n         }\n     }\n-    _setenv(n, v)\n+\n+    _setenv(n, v.container_as_bytes())\n }\n \n /// Remove a variable from the environment entirely.\n@@ -453,77 +455,130 @@ pub fn unsetenv(n: &str) {\n     _unsetenv(n);\n }\n \n-#[cfg(unix)]\n-/// Parse a string or vector according to the platform's conventions\n-/// for the `PATH` environment variable and return a Vec<Path>.\n-/// Drops empty paths.\n+/// Parses input according to platform conventions for the `PATH`\n+/// environment variable.\n ///\n /// # Example\n /// ```rust\n /// use std::os;\n ///\n /// let key = \"PATH\";\n-/// match os::getenv(key) {\n+/// match os::getenv_as_bytes(key) {\n ///     Some(paths) => {\n ///         for path in os::split_paths(paths).iter() {\n ///             println!(\"'{}'\", path.display());\n ///         }\n ///     }\n-///     None => println!(\"{} is not defined in the environnement.\", key)\n+///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    unparsed.container_as_bytes()\n-            .split(|b| *b == ':' as u8)\n-            .filter(|s| s.len() > 0)\n-            .map(Path::new)\n-            .collect()\n-}\n+    #[cfg(unix)]\n+    fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n+        unparsed.container_as_bytes()\n+                .split(|b| *b == b':')\n+                .map(Path::new)\n+                .collect()\n+    }\n \n-#[cfg(windows)]\n-/// Parse a string or vector according to the platform's conventions\n-/// for the `PATH` environment variable. Drops empty paths.\n-pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    // On Windows, the PATH environment variable is semicolon separated.  Double\n-    // quotes are used as a way of introducing literal semicolons (since\n-    // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n-    // permitted in path names, so there is no way to escape a double quote.\n-    // Quoted regions can appear in arbitrary locations, so\n-    //\n-    //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n-    //\n-    // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n-    //\n-    // (The above is based on testing; there is no clear reference available\n-    // for the grammar.)\n-\n-    let mut parsed = Vec::new();\n-    let mut in_progress = Vec::new();\n-    let mut in_quote = false;\n-\n-    for b in unparsed.container_as_bytes().iter() {\n-        match *b as char {\n-            ';' if !in_quote => {\n-                // ignore zero-length path strings\n-                if in_progress.len() > 0 {\n+    #[cfg(windows)]\n+    fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n+        // On Windows, the PATH environment variable is semicolon separated.  Double\n+        // quotes are used as a way of introducing literal semicolons (since\n+        // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n+        // permitted in path names, so there is no way to escape a double quote.\n+        // Quoted regions can appear in arbitrary locations, so\n+        //\n+        //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n+        //\n+        // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n+        //\n+        // (The above is based on testing; there is no clear reference available\n+        // for the grammar.)\n+\n+        let mut parsed = Vec::new();\n+        let mut in_progress = Vec::new();\n+        let mut in_quote = false;\n+\n+        for b in unparsed.container_as_bytes().iter() {\n+            match *b {\n+                b';' if !in_quote => {\n                     parsed.push(Path::new(in_progress.as_slice()));\n+                    in_progress.truncate(0)\n+                }\n+                b'\"' => {\n+                    in_quote = !in_quote;\n+                }\n+                _  => {\n+                    in_progress.push(*b);\n                 }\n-                in_progress.truncate(0)\n-            }\n-            '\\\"' => {\n-                in_quote = !in_quote;\n             }\n-            _  => {\n-                in_progress.push(*b);\n+        }\n+        parsed.push(Path::new(in_progress));\n+        parsed\n+    }\n+\n+    _split_paths(unparsed)\n+}\n+\n+/// Joins a collection of `Path`s appropriately for the `PATH`\n+/// environment variable.\n+///\n+/// Returns a `Vec<u8>` on success, since `Path`s are not utf-8\n+/// encoded on all platforms.\n+///\n+/// Returns an `Err` (containing an error message) if one of the input\n+/// `Path`s contains an invalid character for constructing the `PATH`\n+/// variable (a double quote on Windows or a colon on Unix).\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::os;\n+/// use std::path::Path;\n+///\n+/// let key = \"PATH\";\n+/// let mut paths = os::getenv_as_bytes(key).map_or(Vec::new(), os::split_paths);\n+/// paths.push(Path::new(\"/home/xyz/bin\"));\n+/// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n+/// ```\n+pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+    #[cfg(windows)]\n+    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+        let mut joined = Vec::new();\n+        let sep = b';';\n+\n+        for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+            if i > 0 { joined.push(sep) }\n+            if path.contains(&b'\"') {\n+                return Err(\"path segment contains `\\\"`\");\n+            } else if path.contains(&sep) {\n+                joined.push(b'\"');\n+                joined.push_all(path);\n+                joined.push(b'\"');\n+            } else {\n+                joined.push_all(path);\n             }\n         }\n+\n+        Ok(joined)\n     }\n \n-    if in_progress.len() > 0 {\n-        parsed.push(Path::new(in_progress));\n+    #[cfg(unix)]\n+    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+        let mut joined = Vec::new();\n+        let sep = b':';\n+\n+        for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+            if i > 0 { joined.push(sep) }\n+            if path.contains(&sep) { return Err(\"path segment contains separator `:`\") }\n+            joined.push_all(path);\n+        }\n+\n+        Ok(joined)\n     }\n \n-    parsed\n+    _join_paths(paths)\n }\n \n /// A low-level OS in-memory pipe.\n@@ -1767,7 +1822,7 @@ mod tests {\n     use c_str::ToCStr;\n     use option;\n     use os::{env, getcwd, getenv, make_absolute};\n-    use os::{split_paths, setenv, unsetenv};\n+    use os::{split_paths, join_paths, setenv, unsetenv};\n     use os;\n     use rand::Rng;\n     use rand;\n@@ -2032,11 +2087,11 @@ mod tests {\n                 parsed.iter().map(|s| Path::new(*s)).collect()\n         }\n \n-        assert!(check_parse(\"\", []));\n-        assert!(check_parse(r#\"\"\"\"#, []));\n-        assert!(check_parse(\";;\", []));\n+        assert!(check_parse(\"\", [\"\"]));\n+        assert!(check_parse(r#\"\"\"\"#, [\"\"]));\n+        assert!(check_parse(\";;\", [\"\", \"\", \"\"]));\n         assert!(check_parse(r\"c:\\\", [r\"c:\\\"]));\n-        assert!(check_parse(r\"c:\\;\", [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;\", [r\"c:\\\", \"\"]));\n         assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n                             [r\"c:\\\", r\"c:\\Program Files\\\"]));\n         assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, [r\"c:\\\", r\"c:\\foo\\\"]));\n@@ -2052,12 +2107,44 @@ mod tests {\n                 parsed.iter().map(|s| Path::new(*s)).collect()\n         }\n \n-        assert!(check_parse(\"\", []));\n-        assert!(check_parse(\"::\", []));\n+        assert!(check_parse(\"\", [\"\"]));\n+        assert!(check_parse(\"::\", [\"\", \"\", \"\"]));\n         assert!(check_parse(\"/\", [\"/\"]));\n-        assert!(check_parse(\"/:\", [\"/\"]));\n+        assert!(check_parse(\"/:\", [\"/\", \"\"]));\n         assert!(check_parse(\"/:/usr/local\", [\"/\", \"/usr/local\"]));\n     }\n \n+    #[test]\n+    #[cfg(unix)]\n+    fn join_paths_unix() {\n+        fn test_eq(input: &[&str], output: &str) -> bool {\n+            join_paths(input).unwrap().as_slice() == output.as_bytes()\n+        }\n+\n+        assert!(test_eq([], \"\"));\n+        assert!(test_eq([\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n+                        \"/bin:/usr/bin:/usr/local/bin\"));\n+        assert!(test_eq([\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n+                        \":/bin:::/usr/bin:\"));\n+        assert!(join_paths([\"/te:st\"]).is_err());\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    fn join_paths_windows() {\n+        fn test_eq(input: &[&str], output: &str) -> bool {\n+            join_paths(input).unwrap().as_slice() == output.as_bytes()\n+        }\n+\n+        assert!(test_eq([], \"\"));\n+        assert!(test_eq([r\"c:\\windows\", r\"c:\\\"],\n+                        r\"c:\\windows;c:\\\"));\n+        assert!(test_eq([\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n+                        r\";c:\\windows;;;c:\\;\"));\n+        assert!(test_eq([r\"c:\\te;st\", r\"c:\\\"],\n+                        r#\"\"c:\\te;st\";c:\\\"#));\n+        assert!(join_paths([r#\"c:\\te\"st\"#]).is_err());\n+    }\n+\n     // More recursive_mkdir tests are in extra::tempfile\n }"}, {"sha": "2e0dcdd8eb69f83588a353615eba5a3cb8f7e344", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -266,7 +266,7 @@ mod imp {\n         }\n \n         // while it doesn't requires lock for work as everything is\n-        // local, it still displays much nicier backtraces when a\n+        // local, it still displays much nicer backtraces when a\n         // couple of tasks fail simultaneously\n         static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         let _g = unsafe { LOCK.lock() };"}, {"sha": "742686069e283531461e68cd7852e9f6d88bbc58", "filename": "src/libsync/comm/oneshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsync%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsync%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Foneshot.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -354,7 +354,7 @@ impl<T: Send> Packet<T> {\n             }\n \n             // We woke ourselves up from select. Assert that the task should be\n-            // trashed and returne that we don't have any data.\n+            // trashed and returned that we don't have any data.\n             n => {\n                 let t = unsafe { BlockedTask::cast_from_uint(n) };\n                 t.trash();"}, {"sha": "5ad4dea5d2a89bc52df8a319d19cdecb1703ca94", "filename": "src/libsync/comm/shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsync%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsync%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fshared.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -81,7 +81,7 @@ impl<T: Send> Packet<T> {\n \n     // This function should be used after newly created Packet\n     // was wrapped with an Arc\n-    // In other case mutex data will be duplicated while clonning\n+    // In other case mutex data will be duplicated while cloning\n     // and that could cause problems on platforms where it is\n     // represented by opaque data structure\n     pub fn postinit_lock(&mut self) {\n@@ -140,7 +140,7 @@ impl<T: Send> Packet<T> {\n         // See Port::drop for what's going on\n         if self.port_dropped.load(atomics::SeqCst) { return Err(t) }\n \n-        // Note that the multiple sender case is a little tricker\n+        // Note that the multiple sender case is a little trickier\n         // semantically than the single sender case. The logic for\n         // incrementing is \"add and if disconnected store disconnected\".\n         // This could end up leading some senders to believe that there"}, {"sha": "a10ec7458690abcbf20e68bd12c2e4730dea4f76", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -215,7 +215,7 @@ impl StaticMutex {\n             None => {}\n         }\n \n-        // After we've failed the fast path, then we delegate to the differnet\n+        // After we've failed the fast path, then we delegate to the different\n         // locking protocols for green/native tasks. This will select two tasks\n         // to continue further (one native, one green).\n         let t: Box<Task> = Local::take();"}, {"sha": "237d0660a41dcca5edb5f15875cd41bdc5fd2f5a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -293,8 +293,8 @@ pub enum Pat_ {\n     // In the nullary enum case, the parser can't determine\n     // which it is. The resolver determines this, and\n     // records this pattern's NodeId in an auxiliary\n-    // set (of \"pat_idents that refer to nullary enums\")\n-    PatIdent(BindingMode, Path, Option<Gc<Pat>>),\n+    // set (of \"PatIdents that refer to nullary enums\")\n+    PatIdent(BindingMode, SpannedIdent, Option<Gc<Pat>>),\n     PatEnum(Path, Option<Vec<Gc<Pat>>>), /* \"none\" means a * pattern where\n                                      * we don't bind the fields to names */\n     PatStruct(Path, Vec<FieldPat>, bool),\n@@ -818,7 +818,7 @@ pub struct Arg {\n \n impl Arg {\n     pub fn new_self(span: Span, mutability: Mutability) -> Arg {\n-        let path = ast_util::ident_to_path(span, special_idents::self_);\n+        let path = Spanned{span:span,node:special_idents::self_};\n         Arg {\n             // HACK(eddyb) fake type for the self argument.\n             ty: P(Ty {"}, {"sha": "036d6b4b43adc62d537c8c0f9dfc745964d6bca3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -33,12 +33,6 @@ pub fn path_name_i(idents: &[Ident]) -> String {\n     }).collect::<Vec<String>>().connect(\"::\")\n }\n \n-// totally scary function: ignores all but the last element, should have\n-// a different name\n-pub fn path_to_ident(path: &Path) -> Ident {\n-    path.segments.last().unwrap().identifier\n-}\n-\n pub fn local_def(id: NodeId) -> DefId {\n     ast::DefId { krate: LOCAL_CRATE, node: id }\n }\n@@ -186,6 +180,8 @@ pub fn block_from_expr(e: Gc<Expr>) -> P<Block> {\n     })\n }\n \n+// convert a span and an identifier to the corresponding\n+// 1-segment path\n pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     ast::Path {\n         span: s,\n@@ -202,7 +198,7 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n \n pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> Gc<Pat> {\n     box(GC) ast::Pat { id: id,\n-                node: PatIdent(BindByValue(MutImmutable), ident_to_path(s, i), None),\n+                node: PatIdent(BindByValue(MutImmutable), codemap::Spanned{span:s, node:i}, None),\n                 span: s }\n }\n "}, {"sha": "f0494e181201375096c9e0417a84bce1ba43fb07", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -16,7 +16,6 @@ use ast;\n use codemap::Span;\n use ext::base;\n use ext::base::*;\n-use parse;\n use parse::token::InternedString;\n use parse::token;\n \n@@ -48,12 +47,7 @@ static OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                   -> Box<base::MacResult> {\n-    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n-                                           cx.cfg(),\n-                                           tts.iter()\n-                                              .map(|x| (*x).clone())\n-                                              .collect());\n-\n+    let mut p = cx.new_parser_from_tts(tts);\n     let mut asm = InternedString::new(\"\");\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();"}, {"sha": "d2e69204d333cb5cb0374857bdf9c456a0d22492", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -15,6 +15,7 @@ use codemap::{CodeMap, Span, ExpnInfo};\n use ext;\n use ext::expand;\n use parse;\n+use parse::parser;\n use parse::token;\n use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n@@ -433,6 +434,11 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n+    pub fn new_parser_from_tts(&self, tts: &[ast::TokenTree])\n+        -> parser::Parser<'a> {\n+        parse::tts_to_parser(self.parse_sess, Vec::from_slice(tts), self.cfg())\n+    }\n+\n     pub fn codemap(&self) -> &'a CodeMap { &self.parse_sess.span_diagnostic.cm }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n@@ -472,7 +478,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n     /// Emit `msg` attached to `sp`, and stop compilation immediately.\n     ///\n-    /// `span_err` should be strongly prefered where-ever possible:\n+    /// `span_err` should be strongly preferred where-ever possible:\n     /// this should *only* be used when\n     /// - continuing has a high risk of flow-on errors (e.g. errors in\n     ///   declaring a macro would cause all uses of that macro to\n@@ -586,11 +592,7 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n                           sp: Span,\n                           tts: &[ast::TokenTree]) -> Option<Vec<Gc<ast::Expr>>> {\n-    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n-                                           cx.cfg(),\n-                                           tts.iter()\n-                                              .map(|x| (*x).clone())\n-                                              .collect());\n+    let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::EOF {\n         es.push(cx.expand_expr(p.parse_expr()));"}, {"sha": "46bc4ec11ce4f044ac14b35d1f603042558bf089", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -759,8 +759,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> Gc<ast::Pat> {\n-        let path = self.path_ident(span, ident);\n-        let pat = ast::PatIdent(bm, path, None);\n+        let pat = ast::PatIdent(bm, Spanned{span: span, node: ident}, None);\n         self.pat(span, pat)\n     }\n     fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<Gc<ast::Pat>> ) -> Gc<ast::Pat> {"}, {"sha": "c2930662bc459a31bbb370875ae5a2088dd1171e", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -24,17 +24,11 @@ use attr::*;\n use parse::attr::ParserAttr;\n use parse::token::InternedString;\n use parse::token;\n-use parse;\n \n \n pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                   -> Box<base::MacResult> {\n-    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n-                                           cx.cfg(),\n-                                           tts.iter()\n-                                              .map(|x| (*x).clone())\n-                                              .collect());\n-\n+    let mut p = cx.new_parser_from_tts(tts);\n     let mut cfgs = Vec::new();\n     // parse `cfg!(meta_item, meta_item(x,y), meta_item=\"foo\", ...)`\n     while p.token != token::EOF {"}, {"sha": "157b64fb47c0a7fa3d699681bb0d223d7a718f46", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -834,7 +834,7 @@ impl<'a> MethodDef<'a> {\n                                 generic `deriving`\");\n             }\n \n-            // `ref` inside let matches is buggy. Causes havoc wih rusc.\n+            // `ref` inside let matches is buggy. Causes havoc with rusc.\n             // let (variant_index, ref self_vec) = matches_so_far[0];\n             let (variant, self_vec) = match matches_so_far.get(0) {\n                 &(_, v, ref s) => (v, s)\n@@ -1049,7 +1049,7 @@ impl<'a> TraitDef<'a> {\n \n     fn create_subpatterns(&self,\n                           cx: &mut ExtCtxt,\n-                          field_paths: Vec<ast::Path> ,\n+                          field_paths: Vec<ast::SpannedIdent> ,\n                           mutbl: ast::Mutability)\n                           -> Vec<Gc<ast::Pat>> {\n         field_paths.iter().map(|path| {\n@@ -1095,15 +1095,10 @@ impl<'a> TraitDef<'a> {\n                     cx.span_bug(sp, \"a struct with named and unnamed fields in `deriving`\");\n                 }\n             };\n-            let path =\n-                cx.path_ident(sp,\n-                              cx.ident_of(format!(\"{}_{}\",\n-                                                  prefix,\n-                                                  i).as_slice()));\n-            paths.push(path.clone());\n+            let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).as_slice());\n+            paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr(\n-                sp, ast::ExprParen(\n-                    cx.expr_deref(sp, cx.expr_path(path))));\n+                sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n             ident_expr.push((sp, opt_id, val));\n         }\n \n@@ -1145,15 +1140,11 @@ impl<'a> TraitDef<'a> {\n                 let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n-                    let path =\n-                        cx.path_ident(sp,\n-                                      cx.ident_of(format!(\"{}_{}\",\n-                                                          prefix,\n-                                                          i).as_slice()));\n-\n-                    paths.push(path.clone());\n-                    let val = cx.expr(\n-                        sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(path))));\n+                    let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).as_slice());\n+                    let path1 = codemap::Spanned{span: sp, node: ident};\n+                    paths.push(path1);\n+                    let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n+                    let val = cx.expr(sp, ast::ExprParen(cx.expr_deref(sp, expr_path)));\n                     ident_expr.push((sp, None, val));\n                 }\n "}, {"sha": "c3413293e52ae4b1ac664de13b7246ccffdd5070", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -705,22 +705,10 @@ impl Visitor<()> for NameFinderContext {\n             // we found a pat_ident!\n             ast::Pat {\n                 id: _,\n-                node: ast::PatIdent(_, ref path, ref inner),\n+                node: ast::PatIdent(_, ref path1, ref inner),\n                 span: _\n             } => {\n-                match path {\n-                    // a path of length one:\n-                    &ast::Path {\n-                        global: false,\n-                        span: _,\n-                        segments: ref segments\n-                    } if segments.len() == 1 => {\n-                        self.ident_accumulator.push(segments.get(0)\n-                                                            .identifier)\n-                    }\n-                    // I believe these must be enums...\n-                    _ => ()\n-                }\n+                self.ident_accumulator.push(path1.node);\n                 // visit optional subpattern of pat_ident:\n                 for subpat in inner.iter() {\n                     self.visit_pat(&**subpat, ())\n@@ -1307,7 +1295,7 @@ mod test {\n     }\n \n     // create a really evil test case where a $x appears inside a binding of $x\n-    // but *shouldnt* bind because it was inserted by a different macro....\n+    // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n \n     // FIXME #9383 : lambda var hygiene"}, {"sha": "f39e50ad1313f63501394e1a31da42b528c2a396", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -16,7 +16,6 @@ use ext::base;\n use ext::build::AstBuilder;\n use parse::token::InternedString;\n use parse::token;\n-use rsparse = parse;\n \n use parse = fmt_macros;\n use std::collections::HashMap;\n@@ -81,11 +80,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n     let mut names = HashMap::<String, Gc<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n-    let mut p = rsparse::new_parser_from_tts(ecx.parse_sess(),\n-                                             ecx.cfg(),\n-                                             tts.iter()\n-                                                .map(|x| (*x).clone())\n-                                                .collect());\n+    let mut p = ecx.new_parser_from_tts(tts);\n     // Parse the leading function expression (maybe a block, maybe a path)\n     let invocation = if allow_method {\n         let e = p.parse_expr();"}, {"sha": "7b24b97d5da4dd6be7557657bb8019f0ba816103", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -15,7 +15,6 @@ use ext::base;\n use ext::build::AstBuilder;\n use parse::token::*;\n use parse::token;\n-use parse;\n \n use std::gc::Gc;\n \n@@ -583,11 +582,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone.\n \n-    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n-                                           cx.cfg(),\n-                                           tts.iter()\n-                                              .map(|x| (*x).clone())\n-                                              .collect());\n+    let mut p = cx.new_parser_from_tts(tts);\n     p.quote_depth += 1u;\n \n     let cx_expr = p.parse_expr();"}, {"sha": "f9d7078da3dcbe4377132259c3c5699ae66fca36", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -791,9 +791,10 @@ pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n     let node = match p.node {\n         PatWild => PatWild,\n         PatWildMulti => PatWildMulti,\n-        PatIdent(binding_mode, ref pth, ref sub) => {\n+        PatIdent(binding_mode, ref pth1, ref sub) => {\n             PatIdent(binding_mode,\n-                     folder.fold_path(pth),\n+                     Spanned{span: folder.new_span(pth1.span),\n+                                       node: folder.fold_ident(pth1.node)},\n                      sub.map(|x| folder.fold_pat(x)))\n         }\n         PatLit(e) => PatLit(folder.fold_expr(e)),"}, {"sha": "4b5252bfba3118eb081d8a1783d18631a265b9bc", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -594,23 +594,15 @@ mod test {\n     #[test] fn parse_ident_pat () {\n         let sess = new_parse_sess();\n         let mut parser = string_to_parser(&sess, \"b\".to_string());\n-        assert!(parser.parse_pat() ==\n-                   box(GC) ast::Pat{id: ast::DUMMY_NODE_ID,\n-                             node: ast::PatIdent(\n-                                ast::BindByValue(ast::MutImmutable),\n-                                ast::Path {\n-                                    span:sp(0,1),\n-                                    global:false,\n-                                    segments: vec!(\n-                                        ast::PathSegment {\n-                                            identifier: str_to_ident(\"b\"),\n-                                            lifetimes: Vec::new(),\n-                                            types: OwnedSlice::empty(),\n-                                        }\n-                                    ),\n-                                },\n-                                None /* no idea */),\n-                             span: sp(0,1)});\n+        assert!(parser.parse_pat()\n+                == box(GC) ast::Pat{\n+                id: ast::DUMMY_NODE_ID,\n+                node: ast::PatIdent(ast::BindByValue(ast::MutImmutable),\n+                                    Spanned{ span:sp(0, 1),\n+                                             node: str_to_ident(\"b\")\n+                    },\n+                                    None),\n+                span: sp(0,1)});\n         parser_done(parser);\n     }\n \n@@ -643,24 +635,15 @@ mod test {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n                                             ast::BindByValue(ast::MutImmutable),\n-                                            ast::Path {\n-                                                span:sp(6,7),\n-                                                global:false,\n-                                                segments: vec!(\n-                                                    ast::PathSegment {\n-                                                        identifier:\n-                                                            str_to_ident(\"b\"),\n-                                                        lifetimes: Vec::new(),\n-                                                        types: OwnedSlice::empty(),\n-                                                    }\n-                                                ),\n-                                            },\n-                                            None // no idea\n-                                        ),\n-                                        span: sp(6,7)\n-                                    },\n-                                    id: ast::DUMMY_NODE_ID\n-                                }),\n+                                                Spanned{\n+                                                    span: sp(6,7),\n+                                                    node: str_to_ident(\"b\")},\n+                                                None\n+                                                    ),\n+                                            span: sp(6,7)\n+                                        },\n+                                        id: ast::DUMMY_NODE_ID\n+                                    }),\n                                 output: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                        node: ast::TyNil,\n                                                        span:sp(15,15)}), // not sure"}, {"sha": "f3789e25bc8a7e5e39bc1e1ded000561e43c4578", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -58,7 +58,7 @@ use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::Visibility;\n use ast;\n-use ast_util::{as_prec, lit_is_str, operator_prec};\n+use ast_util::{as_prec, ident_to_path, lit_is_str, operator_prec};\n use ast_util;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n use codemap;\n@@ -2854,8 +2854,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 self.parse_pat()\n             } else {\n-                let fieldpath = ast_util::ident_to_path(self.last_span,\n-                                                        fieldname);\n+                let fieldpath = codemap::Spanned{span:self.last_span, node: fieldname};\n                 box(GC) ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatIdent(bind_type, fieldpath, None),\n@@ -2961,6 +2960,7 @@ impl<'a> Parser<'a> {\n           }\n           _ => {}\n         }\n+        // at this point, token != _, ~, &, &&, (, [\n \n         if (!is_ident_or_path(&self.token) && self.token != token::MOD_SEP)\n                 || self.is_keyword(keywords::True)\n@@ -3017,7 +3017,9 @@ impl<'a> Parser<'a> {\n                 let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                 pat = PatRange(start, end);\n             } else if is_plain_ident(&self.token) && !can_be_enum_or_struct {\n-                let name = self.parse_path(NoTypesAllowed).path;\n+                let id = self.parse_ident();\n+                let id_span = self.last_span;\n+                let pth1 = codemap::Spanned{span:id_span, node: id};\n                 if self.eat(&token::NOT) {\n                     // macro invocation\n                     let ket = token::close_delimiter_for(&self.token)\n@@ -3028,7 +3030,7 @@ impl<'a> Parser<'a> {\n                                                     seq_sep_none(),\n                                                     |p| p.parse_token_tree());\n \n-                    let mac = MacInvocTT(name, tts, EMPTY_CTXT);\n+                    let mac = MacInvocTT(ident_to_path(id_span,id), tts, EMPTY_CTXT);\n                     pat = ast::PatMac(codemap::Spanned {node: mac, span: self.span});\n                 } else {\n                     let sub = if self.eat(&token::AT) {\n@@ -3038,7 +3040,7 @@ impl<'a> Parser<'a> {\n                         // or just foo\n                         None\n                     };\n-                    pat = PatIdent(BindByValue(MutImmutable), name, sub);\n+                    pat = PatIdent(BindByValue(MutImmutable), pth1, sub);\n                 }\n             } else {\n                 // parse an enum pat\n@@ -3084,8 +3086,11 @@ impl<'a> Parser<'a> {\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n                                   pat = PatIdent(BindByValue(MutImmutable),\n-                                                  enum_path,\n-                                                  None);\n+                                                 codemap::Spanned{\n+                                                    span: enum_path.span,\n+                                                    node: enum_path.segments.get(0)\n+                                                           .identifier},\n+                                                 None);\n                               } else {\n                                   pat = PatEnum(enum_path, Some(args));\n                               }\n@@ -3115,7 +3120,7 @@ impl<'a> Parser<'a> {\n                             \"expected identifier, found path\");\n         }\n         // why a path here, and not just an identifier?\n-        let name = self.parse_path(NoTypesAllowed).path;\n+        let name = codemap::Spanned{span: self.last_span, node: self.parse_ident()};\n         let sub = if self.eat(&token::AT) {\n             Some(self.parse_pat())\n         } else {\n@@ -3243,7 +3248,7 @@ impl<'a> Parser<'a> {\n                 None      => {\n                     // we only expect an ident if we didn't parse one\n                     // above.\n-                    let ident_str = if id == token::special_idents::invalid {\n+                    let ident_str = if id.name == token::special_idents::invalid.name {\n                         \"identifier, \"\n                     } else {\n                         \"\"\n@@ -3263,7 +3268,7 @@ impl<'a> Parser<'a> {\n             );\n             let hi = self.span.hi;\n \n-            if id == token::special_idents::invalid {\n+            if id.name == token::special_idents::invalid.name {\n                 return box(GC) spanned(lo, hi, StmtMac(\n                     spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT)), false));\n             } else {"}, {"sha": "4660bb337ab23e1d46c4d8ad2fb608a214d5804c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -196,6 +196,10 @@ pub fn path_to_str(p: &ast::Path) -> String {\n     to_str(|s| s.print_path(p, false))\n }\n \n+pub fn ident_to_str(id: &ast::Ident) -> String {\n+    to_str(|s| s.print_ident(*id))\n+}\n+\n pub fn fun_to_str(decl: &ast::FnDecl, fn_style: ast::FnStyle, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> String {\n@@ -1705,7 +1709,7 @@ impl<'a> State<'a> {\n         match pat.node {\n             ast::PatWild => try!(word(&mut self.s, \"_\")),\n             ast::PatWildMulti => try!(word(&mut self.s, \"..\")),\n-            ast::PatIdent(binding_mode, ref path, sub) => {\n+            ast::PatIdent(binding_mode, ref path1, sub) => {\n                 match binding_mode {\n                     ast::BindByRef(mutbl) => {\n                         try!(self.word_nbsp(\"ref\"));\n@@ -1716,7 +1720,7 @@ impl<'a> State<'a> {\n                         try!(self.word_nbsp(\"mut\"));\n                     }\n                 }\n-                try!(self.print_path(path, true));\n+                try!(self.print_ident(path1.node));\n                 match sub {\n                     Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n@@ -2148,9 +2152,8 @@ impl<'a> State<'a> {\n             ast::TyInfer => try!(self.print_pat(&*input.pat)),\n             _ => {\n                 match input.pat.node {\n-                    ast::PatIdent(_, ref path, _) if\n-                        path.segments.len() == 1 &&\n-                        path.segments.get(0).identifier.name ==\n+                    ast::PatIdent(_, ref path1, _) if\n+                        path1.node.name ==\n                             parse::token::special_idents::invalid.name => {\n                         // Do nothing.\n                     }"}, {"sha": "4ab064a88b7950d3ede7d4ab57d8c05591666205", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -454,8 +454,8 @@ pub fn walk_pat<E: Clone, V: Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E)\n         PatRegion(ref subpattern) => {\n             visitor.visit_pat(&**subpattern, env)\n         }\n-        PatIdent(_, ref path, ref optional_subpattern) => {\n-            visitor.visit_path(path, pattern.id, env.clone());\n+        PatIdent(_, ref pth1, ref optional_subpattern) => {\n+            visitor.visit_ident(pth1.span, pth1.node, env.clone());\n             match *optional_subpattern {\n                 None => {}\n                 Some(ref subpattern) => visitor.visit_pat(&**subpattern, env),"}, {"sha": "98544a1218aad705ae5348d0cc32f137c9aa19eb", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -330,7 +330,7 @@ impl Tm {\n      * Returns a time string formatted according to RFC 822.\n      *\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n-     * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n+     * utc:   \"Thu, 22 Mar 2012 14:53:18 GMT\"\n      */\n     pub fn rfc822(&self) -> String {\n         if self.tm_gmtoff == 0_i32 {\n@@ -351,7 +351,8 @@ impl Tm {\n     }\n \n     /**\n-     * Returns a time string formatted according to ISO 8601.\n+     * Returns a time string formatted according to RFC 3999. RFC 3999 is\n+     * compatible with ISO 8601.\n      *\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\""}, {"sha": "36afc729de9590c3f498cc73bf751ea3eb15f97b", "filename": "src/test/compile-fail/issue-10536.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// We only want to assert that this doesn't ICE, we don't particularly care\n+// about whether it nor it fails to compile.\n+\n+// error-pattern:\n+\n+#![feature(macro_rules)]\n+\n+macro_rules! foo{\n+    () => {{\n+        macro_rules! bar{() => (())}\n+        1\n+    }}\n+}\n+\n+pub fn main() {\n+    foo!();\n+\n+    assert!({one! two()});\n+\n+    // regardless of whether nested macro_rules works, the following should at\n+    // least throw a conventional error.\n+    assert!({one! two});\n+}\n+"}, {"sha": "48e1bdd671a117d80a4222b5c92bfce208a73e69", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5c20647f45f2eb74f337e5434bbe63b0c43345/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=5d5c20647f45f2eb74f337e5434bbe63b0c43345", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #14061: tests the interaction between generic implementation\n+// parameter bounds and trait objects.\n+\n+struct S<T>;\n+\n+trait Gettable<T> {}\n+\n+impl<T: Send + Copy> Gettable<T> for S<T> {}\n+\n+fn f<T>(val: T) {\n+    let t: S<T> = S;\n+    let a = &t as &Gettable<T>;\n+    //~^ ERROR instantiating a type parameter with an incompatible type `T`\n+    let a: &Gettable<T> = &t;\n+    //~^ ERROR instantiating a type parameter with an incompatible type `T`\n+}\n+\n+fn main() {\n+    let t: S<&int> = S;\n+    let a = &t as &Gettable<&int>;\n+    //~^ ERROR instantiating a type parameter with an incompatible type `&int`\n+    let t: Box<S<String>> = box S;\n+    let a = t as Box<Gettable<String>>;\n+    //~^ ERROR instantiating a type parameter with an incompatible type\n+    let t: Box<S<String>> = box S;\n+    let a: Box<Gettable<String>> = t;\n+    //~^ ERROR instantiating a type parameter with an incompatible type\n+}\n+"}]}