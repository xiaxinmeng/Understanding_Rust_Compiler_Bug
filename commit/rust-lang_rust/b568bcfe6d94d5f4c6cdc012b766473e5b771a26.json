{"sha": "b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NjhiY2ZlNmQ5NGQ1ZjRjNmNkYzAxMmI3NjY0NzNlNWI3NzFhMjY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-20T13:23:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-20T13:23:38Z"}, "message": "Merge #2325\n\n2325: Next gen IDs for functions r=matklad a=matklad\n\nThe current system with AstIds has two primaraly drawbacks:\r\n\r\n* It is possible to manufacture IDs out of thin air.\r\n  For example, it's possible to create IDs for items which are not\r\n  considered in CrateDefMap due to cfg. Or it is possible to mixup\r\n  structs and unions, because they share ID space.\r\n\r\n* Getting the ID of a parent requires a secondary index.\r\n\r\nInstead, the plan is to pursue the more traditional approach, where\r\neach items stores the id of the parent declaration. This makes\r\n`FromSource` more awkward, but also more correct: now, to get from an\r\nAST to HIR, we first do this recursively for the parent item, and the\r\njust search the children of the parent for the matching def\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e54c306ac0512e3610430574dc8bea39e4b50218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e54c306ac0512e3610430574dc8bea39e4b50218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd1T5aCRBK7hj4Ov3rIwAAdHIIABtVpuMGBAq4SKAD9NXy+6kp\nJu7pgNr//W2r/XUHhPO0S6P0GUY8g7zseKhGgOFrsHKsDBozBcOtUiDTq3fI11WY\nNa0foFNMBdpHZ5kFLU0bkP2krGoHXR3X7xk+MneA87lUi7LqTv1LeNoTKarB2Avp\n9UZcIz6pUAm8WKDt9BIKO1qs8oXFvAXyfO0/YQ1CJraPYdNzPEkjLpbD8o2cIMW6\nD1EIUnANB5Ktl70GLj7oE5hVIzdDXLSrgcMkAWO9a9m2iD5pPi8NH0hQLs/FqOyO\nepY+kj2+tZzXophc9MLZiz+wAxi6oiWBJvm1KUq0m/bsVGXuZiq6QUC1xA0U6po=\n=X7EE\n-----END PGP SIGNATURE-----\n", "payload": "tree e54c306ac0512e3610430574dc8bea39e4b50218\nparent 2d47f380baad4eacd87331c4b86c0ecb28239499\nparent cebeedc66fc40097eae20bf1767a285d00269966\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574256218 +0000\ncommitter GitHub <noreply@github.com> 1574256218 +0000\n\nMerge #2325\n\n2325: Next gen IDs for functions r=matklad a=matklad\n\nThe current system with AstIds has two primaraly drawbacks:\r\n\r\n* It is possible to manufacture IDs out of thin air.\r\n  For example, it's possible to create IDs for items which are not\r\n  considered in CrateDefMap due to cfg. Or it is possible to mixup\r\n  structs and unions, because they share ID space.\r\n\r\n* Getting the ID of a parent requires a secondary index.\r\n\r\nInstead, the plan is to pursue the more traditional approach, where\r\neach items stores the id of the parent declaration. This makes\r\n`FromSource` more awkward, but also more correct: now, to get from an\r\nAST to HIR, we first do this recursively for the parent item, and the\r\njust search the children of the parent for the matching def\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "html_url": "https://github.com/rust-lang/rust/commit/b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d47f380baad4eacd87331c4b86c0ecb28239499", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d47f380baad4eacd87331c4b86c0ecb28239499", "html_url": "https://github.com/rust-lang/rust/commit/2d47f380baad4eacd87331c4b86c0ecb28239499"}, {"sha": "cebeedc66fc40097eae20bf1767a285d00269966", "url": "https://api.github.com/repos/rust-lang/rust/commits/cebeedc66fc40097eae20bf1767a285d00269966", "html_url": "https://github.com/rust-lang/rust/commit/cebeedc66fc40097eae20bf1767a285d00269966"}], "stats": {"total": 232, "additions": 190, "deletions": 42}, "files": [{"sha": "c49190a0f06f087a930ecaa117d84cb4b82fe4cd", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -12,7 +12,8 @@ use hir_def::{\n     builtin_type::BuiltinType,\n     traits::TraitData,\n     type_ref::{Mutability, TypeRef},\n-    AssocItemId, CrateModuleId, ImplId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n+    AssocItemId, CrateModuleId, FunctionContainerId, HasModule, ImplId, LocalEnumVariantId,\n+    LocalStructFieldId, Lookup, ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -647,7 +648,7 @@ impl FnData {\n \n impl Function {\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n-        Module { id: self.id.module(db) }\n+        self.id.lookup(db).module(db).into()\n     }\n \n     pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n@@ -680,21 +681,25 @@ impl Function {\n \n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        ImplBlock::containing(db, self.into())\n+        match self.container(db) {\n+            Some(Container::ImplBlock(it)) => Some(it),\n+            _ => None,\n+        }\n     }\n \n     /// The containing trait, if this is a trait method definition.\n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n-        db.trait_items_index(self.module(db).id).get_parent_trait(self.id.into()).map(Trait::from)\n+        match self.container(db) {\n+            Some(Container::Trait(it)) => Some(it),\n+            _ => None,\n+        }\n     }\n \n     pub fn container(self, db: &impl DefDatabase) -> Option<Container> {\n-        if let Some(impl_block) = self.impl_block(db) {\n-            Some(impl_block.into())\n-        } else if let Some(trait_) = self.parent_trait(db) {\n-            Some(trait_.into())\n-        } else {\n-            None\n+        match self.id.lookup(db).container {\n+            FunctionContainerId::TraitId(it) => Some(Container::Trait(it.into())),\n+            FunctionContainerId::ImplId(it) => Some(Container::ImplBlock(it.into())),\n+            FunctionContainerId::ModuleId(_) => None,\n         }\n     }\n "}, {"sha": "91cab7414fe39877dd249b87db5137652f48b0ed", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n \n+use hir_def::{HasSource as _, Lookup};\n use ra_syntax::ast::{self, AstNode};\n \n use crate::{\n@@ -113,7 +114,7 @@ impl HasSource for EnumVariant {\n impl HasSource for Function {\n     type Ast = ast::FnDef;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::FnDef> {\n-        self.id.source(db)\n+        self.id.lookup(db).source(db)\n     }\n }\n impl HasSource for Const {"}, {"sha": "303d5f13891045340b8c3256c0d1d68604e22ecd", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -4,15 +4,15 @@ use hir_def::{ModuleId, StructId, StructOrUnionId, UnionId};\n use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n-    match_ast,\n+    match_ast, AstPtr,\n };\n \n use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n-    Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource, ImplBlock,\n-    Local, MacroDef, Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias,\n-    Union, VariantDef,\n+    AssocItem, Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource,\n+    ImplBlock, Local, MacroDef, Module, ModuleDef, ModuleSource, Source, Static, Struct,\n+    StructField, Trait, TypeAlias, Union, VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -52,10 +52,51 @@ impl FromSource for Trait {\n impl FromSource for Function {\n     type Ast = ast::FnDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let id = from_source(db, src)?;\n-        Some(Function { id })\n+        // FIXME: this doesn't try to handle nested declarations\n+        for container in src.value.syntax().ancestors() {\n+            let res = match_ast! {\n+                match container {\n+                    ast::TraitDef(it) => {\n+                        let c = Trait::from_source(db, src.with_value(it))?;\n+                        c.items(db)\n+                            .into_iter()\n+                            .filter_map(|it| match it {\n+                                AssocItem::Function(it) => Some(it),\n+                                _ => None\n+                            })\n+                            .find(|it| same_source(&it.source(db), &src))?\n+                    },\n+                    ast::ImplBlock(it) => {\n+                        let c = ImplBlock::from_source(db, src.with_value(it))?;\n+                        c.items(db)\n+                            .into_iter()\n+                            .filter_map(|it| match it {\n+                                AssocItem::Function(it) => Some(it),\n+                                _ => None\n+                            })\n+                            .find(|it| same_source(&it.source(db), &src))?\n+\n+                     },\n+                    _ => { continue },\n+                }\n+            };\n+            return Some(res);\n+        }\n+\n+        let module_source = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n+        let c = Module::from_definition(db, src.with_value(module_source))?;\n+        let res = c\n+            .declarations(db)\n+            .into_iter()\n+            .filter_map(|it| match it {\n+                ModuleDef::Function(it) => Some(it),\n+                _ => None,\n+            })\n+            .find(|it| same_source(&it.source(db), &src));\n+        res\n     }\n }\n+\n impl FromSource for Const {\n     type Ast = ast::ConstDef;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n@@ -108,7 +149,7 @@ impl FromSource for EnumVariant {\n         let parent_enum = src.value.parent_enum();\n         let src_enum = Source { file_id: src.file_id, value: parent_enum };\n         let variants = Enum::from_source(db, src_enum)?.variants(db);\n-        variants.into_iter().find(|v| v.source(db) == src)\n+        variants.into_iter().find(|v| same_source(&v.source(db), &src))\n     }\n }\n \n@@ -216,3 +257,13 @@ where\n     let ctx = LocationCtx::new(db, module.id, src.file_id);\n     Some(DEF::from_ast(ctx, &src.value))\n }\n+\n+/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n+/// equal if they point to exactly the same object.\n+///\n+/// In general, we do not guarantee that we have exactly one instance of a\n+/// syntax tree for each file. We probably should add such guanratree, but, for\n+/// the time being, we will use identity-less AstPtr comparison.\n+fn same_source<N: AstNode>(s1: &Source<N>, s2: &Source<N>) -> bool {\n+    s1.as_ref().map(AstPtr::new) == s2.as_ref().map(AstPtr::new)\n+}"}, {"sha": "5d9e22ee2e554fd701f6e10811cbff6f3f88b500", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -70,7 +70,7 @@ fn def_with_body_from_child_node(\n     child.value.ancestors().find_map(|node| {\n         match_ast! {\n             match node {\n-                ast::FnDef(def)  => { Some(Function {id: ctx.to_def(&def) }.into()) },\n+                ast::FnDef(def)  => { return Function::from_source(db, child.with_value(def)).map(DefWithBody::from); },\n                 ast::ConstDef(def) => { Some(Const { id: ctx.to_def(&def) }.into()) },\n                 ast::StaticDef(def) => { Some(Static { id: ctx.to_def(&def) }.into()) },\n                 _ => { None },"}, {"sha": "b69d4dea659b069d358cc8ecbf9c35303e13bd2d", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     expr::{Expr, ExprId, Pat, PatId},\n     nameres::CrateDefMap,\n     path::Path,\n-    AstItemDef, DefWithBodyId, ModuleId,\n+    AstItemDef, DefWithBodyId, HasModule, HasSource, Lookup, ModuleId,\n };\n \n pub struct Expander {\n@@ -149,6 +149,7 @@ impl Body {\n \n         let (file_id, module, body) = match def {\n             DefWithBodyId::FunctionId(f) => {\n+                let f = f.lookup(db);\n                 let src = f.source(db);\n                 params = src.value.param_list();\n                 (src.file_id, f.module(db), src.value.body().map(ast::Expr::from))"}, {"sha": "e4ffdebe975b309df6d862dab9ab9533b39dbe9b", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -14,13 +14,13 @@ use crate::{\n         CrateDefMap,\n     },\n     traits::{TraitData, TraitItemsIndex},\n-    DefWithBodyId, EnumId, ImplId, ItemLoc, ModuleId, StructOrUnionId, TraitId,\n+    DefWithBodyId, EnumId, FunctionLoc, ImplId, ItemLoc, ModuleId, StructOrUnionId, TraitId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n-    fn intern_function(&self, loc: ItemLoc<ast::FnDef>) -> crate::FunctionId;\n+    fn intern_function(&self, loc: FunctionLoc) -> crate::FunctionId;\n     #[salsa::interned]\n     fn intern_struct_or_union(&self, loc: ItemLoc<ast::StructDef>) -> crate::StructOrUnionId;\n     #[salsa::interned]"}, {"sha": "11dd2a94878d1014035c6034152203d72687f103", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n use crate::{\n     db::DefDatabase2,\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AstItemDef, GenericDefId,\n+    AdtId, AstItemDef, GenericDefId, HasSource, Lookup,\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n@@ -53,7 +53,7 @@ impl GenericParams {\n         let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n         match def {\n-            GenericDefId::FunctionId(it) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n             GenericDefId::AdtId(AdtId::StructId(it)) => {\n                 generics.fill(&it.0.source(db).value, start)\n             }"}, {"sha": "9be38c5e183b472fd8f73d3380dd6c499893ebe5", "filename": "crates/ra_hir_def/src/impls.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimpls.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -5,11 +5,12 @@\n \n use std::sync::Arc;\n \n+use hir_expand::AstId;\n use ra_syntax::ast;\n \n use crate::{\n-    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstId, FunctionId, ImplId,\n-    LocationCtx, TypeAliasId,\n+    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstId, FunctionContainerId,\n+    FunctionLoc, ImplId, Intern, LocationCtx, TypeAliasId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -35,7 +36,12 @@ impl ImplData {\n                 .impl_items()\n                 .map(|item_node| match item_node {\n                     ast::ImplItem::FnDef(it) => {\n-                        FunctionId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                        let func_id = FunctionLoc {\n+                            container: FunctionContainerId::ImplId(id),\n+                            ast_id: AstId::new(src.file_id, items.ast_id(&it)),\n+                        }\n+                        .intern(db);\n+                        func_id.into()\n                     }\n                     ast::ImplItem::ConstDef(it) => {\n                         ConstId::from_ast_id(ctx, items.ast_id(&it)).into()"}, {"sha": "b9a13776ff934d896f418c4422f753efc50f5904", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -199,15 +199,33 @@ pub trait AstItemDef<N: AstNode>: salsa::InternKey + Clone {\n pub struct FunctionId(salsa::InternId);\n impl_intern_key!(FunctionId);\n \n-impl AstItemDef<ast::FnDef> for FunctionId {\n-    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::FnDef>) -> Self {\n-        db.intern_function(loc)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FunctionLoc {\n+    pub container: FunctionContainerId,\n+    pub ast_id: AstId<ast::FnDef>,\n+}\n+\n+impl Intern for FunctionLoc {\n+    type ID = FunctionId;\n+    fn intern(self, db: &impl db::DefDatabase2) -> FunctionId {\n+        db.intern_function(self)\n     }\n-    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::FnDef> {\n-        db.lookup_intern_function(self)\n+}\n+\n+impl Lookup for FunctionId {\n+    type Data = FunctionLoc;\n+    fn lookup(&self, db: &impl db::DefDatabase2) -> FunctionLoc {\n+        db.lookup_intern_function(*self)\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum FunctionContainerId {\n+    ModuleId(ModuleId),\n+    ImplId(ImplId),\n+    TraitId(TraitId),\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructOrUnionId(salsa::InternId);\n impl_intern_key!(StructOrUnionId);\n@@ -433,3 +451,41 @@ impl_froms!(\n     EnumVariantId,\n     ConstId\n );\n+\n+trait Intern {\n+    type ID;\n+    fn intern(self, db: &impl db::DefDatabase2) -> Self::ID;\n+}\n+\n+pub trait Lookup {\n+    type Data;\n+    fn lookup(&self, db: &impl db::DefDatabase2) -> Self::Data;\n+}\n+\n+pub trait HasModule {\n+    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId;\n+}\n+\n+impl HasModule for FunctionLoc {\n+    fn module(&self, db: &impl db::DefDatabase2) -> ModuleId {\n+        match self.container {\n+            FunctionContainerId::ModuleId(it) => it,\n+            FunctionContainerId::ImplId(it) => it.module(db),\n+            FunctionContainerId::TraitId(it) => it.module(db),\n+        }\n+    }\n+}\n+\n+pub trait HasSource {\n+    type Value;\n+    fn source(&self, db: &impl db::DefDatabase2) -> Source<Self::Value>;\n+}\n+\n+impl HasSource for FunctionLoc {\n+    type Value = ast::FnDef;\n+\n+    fn source(&self, db: &impl db::DefDatabase2) -> Source<ast::FnDef> {\n+        let node = self.ast_id.to_node(db);\n+        Source::new(self.ast_id.file_id(), node)\n+    }\n+}"}, {"sha": "d2ed94a876cd603b34885f6640865d9569ec55a1", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -19,9 +19,9 @@ use crate::{\n         per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n-    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId, ImplId,\n-    LocationCtx, ModuleDefId, ModuleId, StaticId, StructId, StructOrUnionId, TraitId, TypeAliasId,\n-    UnionId,\n+    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionContainerId,\n+    FunctionLoc, ImplId, Intern, LocationCtx, ModuleDefId, ModuleId, StaticId, StructId,\n+    StructOrUnionId, TraitId, TypeAliasId, UnionId,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase2, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -673,7 +673,12 @@ where\n         let name = def.name.clone();\n         let def: PerNs = match def.kind {\n             raw::DefKind::Function(ast_id) => {\n-                let f = FunctionId::from_ast_id(ctx, ast_id);\n+                let f = FunctionLoc {\n+                    container: FunctionContainerId::ModuleId(module),\n+                    ast_id: AstId::new(self.file_id, ast_id),\n+                }\n+                .intern(self.def_collector.db);\n+\n                 PerNs::values(f.into())\n             }\n             raw::DefKind::Struct(ast_id) => {"}, {"sha": "6e36bc0d0cadb0f1a2538a067f2efc1247f2d154", "filename": "crates/ra_hir_def/src/traits.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftraits.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -2,14 +2,17 @@\n \n use std::sync::Arc;\n \n-use hir_expand::name::{AsName, Name};\n+use hir_expand::{\n+    name::{AsName, Name},\n+    AstId,\n+};\n \n use ra_syntax::ast::{self, NameOwner};\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    db::DefDatabase2, AssocItemId, AstItemDef, ConstId, FunctionId, LocationCtx, ModuleDefId,\n-    ModuleId, TraitId, TypeAliasId,\n+    db::DefDatabase2, AssocItemId, AstItemDef, ConstId, FunctionContainerId, FunctionLoc, Intern,\n+    LocationCtx, ModuleDefId, ModuleId, TraitId, TypeAliasId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -26,11 +29,17 @@ impl TraitData {\n         let module = tr.module(db);\n         let ctx = LocationCtx::new(db, module, src.file_id);\n         let auto = src.value.is_auto();\n+        let ast_id_map = db.ast_id_map(src.file_id);\n         let items = if let Some(item_list) = src.value.item_list() {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => FunctionId::from_ast(ctx, &it).into(),\n+                    ast::ImplItem::FnDef(it) => FunctionLoc {\n+                        container: FunctionContainerId::TraitId(tr),\n+                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    }\n+                    .intern(db)\n+                    .into(),\n                     ast::ImplItem::ConstDef(it) => ConstId::from_ast(ctx, &it).into(),\n                     ast::ImplItem::TypeAliasDef(it) => TypeAliasId::from_ast(ctx, &it).into(),\n                 })\n@@ -54,7 +63,13 @@ impl TraitItemsIndex {\n         for decl in crate_def_map[module.module_id].scope.declarations() {\n             if let ModuleDefId::TraitId(tr) = decl {\n                 for item in db.trait_data(tr).items.iter() {\n-                    index.traits_by_def.insert(*item, tr);\n+                    match item {\n+                        AssocItemId::FunctionId(_) => (),\n+                        _ => {\n+                            let prev = index.traits_by_def.insert(*item, tr);\n+                            assert!(prev.is_none());\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "e049fce611a06cdc19dd0f4665637890eb719c7f", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b568bcfe6d94d5f4c6cdc012b766473e5b771a26/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=b568bcfe6d94d5f4c6cdc012b766473e5b771a26", "patch": "@@ -43,7 +43,7 @@ impl SyntaxNodePtr {\n }\n \n /// Like `SyntaxNodePtr`, but remembers the type of node\n-#[derive(Debug, PartialEq, Eq, Hash)]\n+#[derive(Debug, Hash)]\n pub struct AstPtr<N: AstNode> {\n     raw: SyntaxNodePtr,\n     _ty: PhantomData<fn() -> N>,\n@@ -56,6 +56,14 @@ impl<N: AstNode> Clone for AstPtr<N> {\n     }\n }\n \n+impl<N: AstNode> Eq for AstPtr<N> {}\n+\n+impl<N: AstNode> PartialEq for AstPtr<N> {\n+    fn eq(&self, other: &AstPtr<N>) -> bool {\n+        self.raw == other.raw\n+    }\n+}\n+\n impl<N: AstNode> AstPtr<N> {\n     pub fn new(node: &N) -> AstPtr<N> {\n         AstPtr { raw: SyntaxNodePtr::new(node.syntax()), _ty: PhantomData }"}]}