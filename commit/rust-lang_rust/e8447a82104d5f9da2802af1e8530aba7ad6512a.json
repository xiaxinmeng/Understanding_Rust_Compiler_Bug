{"sha": "e8447a82104d5f9da2802af1e8530aba7ad6512a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NDQ3YTgyMTA0ZDVmOWRhMjgwMmFmMWU4NTMwYWJhN2FkNjUxMmE=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-19T19:41:47Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-19T21:06:36Z"}, "message": "Fix large block comments", "tree": {"sha": "ef25957af70c6c97892048a8b052158c5116cd18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef25957af70c6c97892048a8b052158c5116cd18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8447a82104d5f9da2802af1e8530aba7ad6512a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8447a82104d5f9da2802af1e8530aba7ad6512a", "html_url": "https://github.com/rust-lang/rust/commit/e8447a82104d5f9da2802af1e8530aba7ad6512a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8447a82104d5f9da2802af1e8530aba7ad6512a/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3970748f59376381f360e42d8f703b2f0f7bbde7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3970748f59376381f360e42d8f703b2f0f7bbde7", "html_url": "https://github.com/rust-lang/rust/commit/3970748f59376381f360e42d8f703b2f0f7bbde7"}], "stats": {"total": 382, "additions": 314, "deletions": 68}, "files": [{"sha": "c00a673ebf626f072638a9c45a75228c2b645b5b", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -7,7 +7,7 @@ dependencies = [\n  \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.0.1 (git+https://github.com/nrc/strings.rs.git)\",\n  \"term 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.1.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -93,7 +93,7 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.1.22\"\n+version = \"0.1.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "e4ce5a7ed3583dcca6380cc7b65cd723472b64f8", "filename": "src/comment.rs", "status": "modified", "additions": 86, "deletions": 33, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -81,11 +81,11 @@ pub fn rewrite_comment(orig: &str,\n             let rewrite = try_opt!(rewrite_string(line, &fmt));\n             result.push_str(&rewrite);\n         } else {\n-            if line.len() == 0 {\n-                result.pop(); // Remove space if this is an empty comment.\n-            } else {\n-                result.push_str(line);\n+            if line.len() == 0 || line.starts_with('!') {\n+                // Remove space if this is an empty comment or a doc comment.\n+                result.pop();\n             }\n+            result.push_str(line);\n         }\n \n         first = false;\n@@ -162,15 +162,15 @@ pub fn contains_comment(text: &str) -> bool {\n     CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment)\n }\n \n-pub struct CharClasses<T>\n+struct CharClasses<T>\n     where T: Iterator,\n           T::Item: RichChar\n {\n     base: iter::Peekable<T>,\n     status: CharClassesStatus,\n }\n \n-pub trait RichChar {\n+trait RichChar {\n     fn get_char(&self) -> char;\n }\n \n@@ -211,7 +211,7 @@ pub enum CodeCharKind {\n }\n \n impl<T> CharClasses<T> where T: Iterator, T::Item: RichChar {\n-    pub fn new(base: T) -> CharClasses<T> {\n+    fn new(base: T) -> CharClasses<T> {\n         CharClasses {\n             base: base.peekable(),\n             status: CharClassesStatus::Normal,\n@@ -291,28 +291,27 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n                     '\\n' => CharClassesStatus::Normal,\n                     _ => CharClassesStatus::LineComment,\n                 };\n-                // let code_char_kind = match chr {\n-                //     '\\n' => CodeCharKind::Normal,\n-                //     _ => CodeCharKind::Comment,\n-                // };\n                 return Some((CodeCharKind::Comment, item));\n             }\n         };\n         Some((CodeCharKind::Normal, item))\n     }\n }\n \n+/// Iterator over an alternating sequence of functional and commented parts of\n+/// a string. The first item is always a, possibly zero length, subslice of\n+/// functional text. Line style comments contain their ending newlines.\n pub struct CommentCodeSlices<'a> {\n     slice: &'a str,\n-    last_slice_type: CodeCharKind,\n+    last_slice_kind: CodeCharKind,\n     last_slice_end: usize,\n }\n \n impl<'a> CommentCodeSlices<'a> {\n     pub fn new(slice: &'a str) -> CommentCodeSlices<'a> {\n         CommentCodeSlices {\n             slice: slice,\n-            last_slice_type: CodeCharKind::Comment,\n+            last_slice_kind: CodeCharKind::Comment,\n             last_slice_end: 0,\n         }\n     }\n@@ -327,32 +326,52 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n         }\n \n         let mut sub_slice_end = self.last_slice_end;\n-        for (kind, (i, _)) in CharClasses::new(self.slice[self.last_slice_end..].char_indices()) {\n-            if kind == self.last_slice_type {\n-                sub_slice_end = self.last_slice_end + i;\n+        let mut first_whitespace = None;\n+        let subslice = &self.slice[self.last_slice_end..];\n+        let mut iter = CharClasses::new(subslice.char_indices());\n+\n+        for (kind, (i, c)) in &mut iter {\n+            let is_comment_connector = self.last_slice_kind == CodeCharKind::Normal &&\n+                                       &subslice[..2] == \"//\" &&\n+                                       [' ', '\\t'].contains(&c);\n+\n+            if is_comment_connector && first_whitespace.is_none() {\n+                first_whitespace = Some(i);\n+            }\n+\n+            if kind == self.last_slice_kind && !is_comment_connector {\n+                let last_index = match first_whitespace {\n+                    Some(j) => j,\n+                    None => i,\n+                };\n+                sub_slice_end = self.last_slice_end + last_index;\n                 break;\n             }\n+\n+            if !is_comment_connector {\n+                first_whitespace = None;\n+            }\n+        }\n+\n+        if let (None, true) = (iter.next(), sub_slice_end == self.last_slice_end) {\n+            // This was the last subslice.\n+            sub_slice_end = match first_whitespace {\n+                Some(i) => self.last_slice_end + i,\n+                None => self.slice.len(),\n+            };\n         }\n \n-        let kind = match self.last_slice_type {\n+        let kind = match self.last_slice_kind {\n             CodeCharKind::Comment => CodeCharKind::Normal,\n             CodeCharKind::Normal => CodeCharKind::Comment,\n         };\n-        self.last_slice_type = kind;\n-\n-        // FIXME: be consistent in use of kind vs type.\n-        if sub_slice_end == self.last_slice_end {\n-            // This was the last subslice.\n-            self.last_slice_end = self.slice.len();\n+        let res = (kind,\n+                   self.last_slice_end,\n+                   &self.slice[self.last_slice_end..sub_slice_end]);\n+        self.last_slice_end = sub_slice_end;\n+        self.last_slice_kind = kind;\n \n-            Some((kind, sub_slice_end, &self.slice[sub_slice_end..]))\n-        } else {\n-            let res = (kind,\n-                       self.last_slice_end,\n-                       &self.slice[self.last_slice_end..sub_slice_end]);\n-            self.last_slice_end = sub_slice_end;\n-            Some(res)\n-        }\n+        Some(res)\n     }\n }\n \n@@ -362,10 +381,20 @@ mod test {\n                 CommentCodeSlices};\n     use Indent;\n \n+    #[test]\n+    fn char_classes() {\n+        let mut iter = CharClasses::new(\"//\\n\\n\".chars());\n+\n+        assert_eq!((CodeCharKind::Comment, '/'), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, '/'), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, '\\n'), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Normal, '\\n'), iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n     #[test]\n     fn comment_code_slices() {\n         let input = \"code(); /* test */ 1 + 1\";\n-\n         let mut iter = CommentCodeSlices::new(input);\n \n         assert_eq!((CodeCharKind::Normal, 0, \"code(); \"), iter.next().unwrap());\n@@ -375,6 +404,31 @@ mod test {\n         assert_eq!(None, iter.next());\n     }\n \n+    #[test]\n+    fn comment_code_slices_two() {\n+        let input = \"// comment\\n    test();\";\n+        let mut iter = CommentCodeSlices::new(input);\n+\n+        assert_eq!((CodeCharKind::Normal, 0, \"\"), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, 0, \"// comment\\n\"),\n+                   iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Normal, 11, \"    test();\"),\n+                   iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n+    #[test]\n+    fn comment_code_slices_three() {\n+        let input = \"1 // comment\\n    // comment2\\n\\n\";\n+        let mut iter = CommentCodeSlices::new(input);\n+\n+        assert_eq!((CodeCharKind::Normal, 0, \"1 \"), iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Comment, 2, \"// comment\\n    // comment2\\n\"),\n+                   iter.next().unwrap());\n+        assert_eq!((CodeCharKind::Normal, 29, \"\\n\"), iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n     #[test]\n     #[rustfmt_skip]\n     fn format_comments() {\n@@ -434,7 +488,6 @@ mod test {\n     #[test]\n     fn test_find_uncommented() {\n         fn check(haystack: &str, needle: &str, expected: Option<usize>) {\n-            println!(\"haystack {:?}, needle: {:?}\", haystack, needle);\n             assert_eq!(expected, haystack.find_uncommented(needle));\n         }\n "}, {"sha": "f0a877db2158c66ccf80fea0ea0f069f02a6af13", "filename": "src/expr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -471,10 +471,6 @@ impl Rewrite for ast::Block {\n \n         visitor.visit_block(self);\n \n-        // Push text between last block item and end of block\n-        let snippet = visitor.snippet(mk_sp(visitor.last_pos, self.span.hi));\n-        visitor.buffer.push_str(&snippet);\n-\n         Some(format!(\"{}{}\", prefix, visitor.buffer))\n     }\n }\n@@ -1534,8 +1530,8 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n             let new_offset = offset.block_indent(context.config);\n             result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n \n-            // FIXME: we probably should related max_width to width instead of config.max_width\n-            // where is the 1 coming from anyway?\n+            // FIXME: we probably should related max_width to width instead of\n+            // config.max_width where is the 1 coming from anyway?\n             let max_width = try_opt!(context.config.max_width.checked_sub(new_offset.width() + 1));\n             let inner_context = context.nested_context();\n             let rhs = ex.rewrite(&inner_context, max_width, new_offset);"}, {"sha": "c8054b8d01fb5785ca9e2b29c7b1a70df339b5cf", "filename": "src/items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -287,8 +287,8 @@ impl<'a> FmtVisitor<'a> {\n                        has_body: bool)\n                        -> Option<(String, bool)> {\n         let mut force_new_line_for_brace = false;\n-        // FIXME we'll lose any comments in between parts of the function decl, but anyone\n-        // who comments there probably deserves what they get.\n+        // FIXME we'll lose any comments in between parts of the function decl, but\n+        // anyone who comments there probably deserves what they get.\n \n         let where_clause = &generics.where_clause;\n \n@@ -1008,7 +1008,8 @@ impl<'a> FmtVisitor<'a> {\n                                  span_start,\n                                  span_end);\n         let item_vec = items.collect::<Vec<_>>();\n-        // FIXME: we don't need to collect here if the where_layout isnt horizontalVertical\n+        // FIXME: we don't need to collect here if the where_layout isnt\n+        // HorizontalVertical.\n         let tactic = definitive_tactic(&item_vec, self.config.where_layout, budget);\n \n         let fmt = ListFormatting {"}, {"sha": "04d3ac3366a248371aaf2a6a92c0497e0d72224f", "filename": "src/missed_spans.rs", "status": "modified", "additions": 109, "deletions": 15, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -10,7 +10,7 @@\n \n use visitor::FmtVisitor;\n \n-use syntax::codemap::{self, BytePos, Span};\n+use syntax::codemap::{self, BytePos, Span, Pos};\n use comment::{CodeCharKind, CommentCodeSlices, rewrite_comment};\n \n impl<'a> FmtVisitor<'a> {\n@@ -55,22 +55,116 @@ impl<'a> FmtVisitor<'a> {\n         self.last_pos = end;\n         let span = codemap::mk_sp(start, end);\n \n-        self.write_snippet(&snippet, &process_last_snippet);\n+        self.write_snippet(span, &process_last_snippet);\n     }\n \n-    fn write_snippet<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,\n-                                                         snippet: &str,\n-                                                         process_last_snippet: F) {\n-        let mut lines: Vec<&str> = snippet.lines().collect();\n-        let last_snippet = if snippet.ends_with(\"\\n\") {\n-            \"\"\n-        } else {\n-            lines.pop().unwrap()\n-        };\n-        for line in lines.iter() {\n-            self.buffer.push_str(line.trim_right());\n-            self.buffer.push_str(\"\\n\");\n+    fn write_snippet<F>(&mut self, span: Span, process_last_snippet: F)\n+        where F: Fn(&mut FmtVisitor, &str, &str)\n+    {\n+        // Get a snippet from the file start to the span's hi without allocating.\n+        // We need it to determine what precedes the current comment. If the comment\n+        // follows code on the same line, we won't touch it.\n+        let big_span_lo = self.codemap.lookup_char_pos(span.lo).file.start_pos;\n+        let local_begin = self.codemap.lookup_byte_offset(big_span_lo);\n+        let local_end = self.codemap.lookup_byte_offset(span.hi);\n+        let start_index = local_begin.pos.to_usize();\n+        let end_index = local_end.pos.to_usize();\n+        let big_snippet = &local_begin.fm.src.as_ref().unwrap()[start_index..end_index];\n+\n+        let big_diff = (span.lo - big_span_lo).to_usize();\n+        let snippet = self.snippet(span);\n+\n+        self.write_snippet_inner(big_snippet, big_diff, &snippet, process_last_snippet);\n+    }\n+\n+    fn write_snippet_inner<F>(&mut self,\n+                              big_snippet: &str,\n+                              big_diff: usize,\n+                              snippet: &str,\n+                              process_last_snippet: F)\n+        where F: Fn(&mut FmtVisitor, &str, &str)\n+    {\n+        // Trim whitespace from the right hand side of each line.\n+        // Annoyingly, the library functions for splitting by lines etc. are not\n+        // quite right, so we must do it ourselves.\n+        let mut line_start = 0;\n+        let mut last_wspace = None;\n+        let mut rewrite_next_comment = true;\n+\n+        for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n+            if let CodeCharKind::Comment = kind {\n+                let last_char = big_snippet[..(offset + big_diff)]\n+                                    .chars()\n+                                    .rev()\n+                                    .skip_while(|rev_c| [' ', '\\t'].contains(&rev_c))\n+                                    .next();\n+\n+                let fix_indent = last_char.map(|rev_c| ['{', '\\n'].contains(&rev_c))\n+                                          .unwrap_or(true);\n+\n+                if rewrite_next_comment && fix_indent {\n+                    if let Some('{') = last_char {\n+                        self.buffer.push_str(\"\\n\");\n+                    }\n+\n+                    let comment_width = ::std::cmp::min(self.config.ideal_width,\n+                                                        self.config.max_width -\n+                                                        self.block_indent.width());\n+\n+                    self.buffer.push_str(&self.block_indent.to_string(self.config));\n+                    self.buffer.push_str(&rewrite_comment(subslice,\n+                                                          false,\n+                                                          comment_width,\n+                                                          self.block_indent,\n+                                                          self.config)\n+                                              .unwrap());\n+\n+                    last_wspace = None;\n+                    line_start = offset + subslice.len();\n+\n+                    if let Some('/') = subslice.chars().skip(1).next() {\n+                        self.buffer.push_str(\"\\n\");\n+                    } else if line_start < snippet.len() {\n+                        let x = (&snippet[line_start..]).chars().next().unwrap() != '\\n';\n+\n+                        if x {\n+                            self.buffer.push_str(\"\\n\");\n+                        }\n+                    }\n+\n+                    continue;\n+                } else {\n+                    rewrite_next_comment = false;\n+                }\n+            }\n+\n+            for (mut i, c) in subslice.char_indices() {\n+                i += offset;\n+\n+                if c == '\\n' {\n+                    if let Some(lw) = last_wspace {\n+                        self.buffer.push_str(&snippet[line_start..lw]);\n+                        self.buffer.push_str(\"\\n\");\n+                    } else {\n+                        self.buffer.push_str(&snippet[line_start..i + 1]);\n+                    }\n+\n+                    line_start = i + 1;\n+                    last_wspace = None;\n+                    rewrite_next_comment = rewrite_next_comment || kind == CodeCharKind::Normal;\n+                } else {\n+                    if c.is_whitespace() {\n+                        if last_wspace.is_none() {\n+                            last_wspace = Some(i);\n+                        }\n+                    } else {\n+                        rewrite_next_comment = rewrite_next_comment || kind == CodeCharKind::Normal;\n+                        last_wspace = None;\n+                    }\n+                }\n+            }\n         }\n-        process_last_snippet(self, &last_snippet, snippet);\n+\n+        process_last_snippet(self, &snippet[line_start..], &snippet);\n     }\n }"}, {"sha": "b8de0fc7189f6f3313c35dc2f40437f0c15a9b45", "filename": "src/visitor.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -101,11 +101,22 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n         }\n \n-        self.block_indent = self.block_indent.block_unindent(self.config);\n         // TODO: we should compress any newlines here to just one\n         self.format_missing_with_indent(b.span.hi - brace_compensation);\n+        // FIXME: this is a terrible hack to indent the comments between the last\n+        // item in the block and the closing brace to the block's level.\n+        // The closing brace itself, however, should be indented at a shallower\n+        // level.\n+        let total_len = self.buffer.len;\n+        let chars_too_many = if self.config.hard_tabs {\n+            1\n+        } else {\n+            self.config.tab_spaces\n+        };\n+        self.buffer.truncate(total_len - chars_too_many);\n         self.buffer.push_str(\"}\");\n         self.last_pos = b.span.hi;\n+        self.block_indent = self.block_indent.block_unindent(self.config);\n     }\n \n     // Note that this only gets called for function definitions. Required methods\n@@ -177,6 +188,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             // FIXME(#78): format traits and impl definitions.\n             ast::Item_::ItemImpl(..) |\n             ast::Item_::ItemTrait(..) => {\n+                self.format_missing_with_indent(item.span.lo);\n                 self.block_indent = self.block_indent.block_indent(self.config);\n                 visit::walk_item(self, item);\n                 self.block_indent = self.block_indent.block_unindent(self.config);\n@@ -215,6 +227,9 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n             ast::Item_::ItemMac(..) => {\n                 self.format_missing_with_indent(item.span.lo);\n+                let snippet = self.snippet(item.span);\n+                self.buffer.push_str(&snippet);\n+                self.last_pos = item.span.hi;\n                 // FIXME: we cannot format these yet, because of a bad span.\n                 // See rust lang issue #28424.\n                 // visit::walk_item(self, item);"}, {"sha": "34b5de79b754c3bec36e3dcd6216dd5621577bd2", "filename": "tests/source/comment.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Fsource%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Fsource%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcomment.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -0,0 +1,39 @@\n+//! Doc comment\n+fn test() {\n+// comment\n+        // comment2\n+\n+    code(); /* leave this comment alone!\n+             * ok? */\n+\n+        /* Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a\n+         * diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam\n+         * viverra nec consectetur ante hendrerit. Donec et mollis dolor.\n+         * Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam\n+         * tincidunt congue enim, ut porta lorem lacinia consectetur. Donec ut\n+         * libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit\n+         * amet, consectetur adipiscing elit. Aenean ut gravida lorem. Ut turpis\n+         * felis, pulvinar a semper sed, adipiscing id dolor. */\n+\n+    // Very looooooooooooooooooooooooooooooooooooooooooooooooooooooooong comment that should be split\n+\n+                    // println!(\"{:?}\", rewrite_comment(subslice,\n+                    //                                       false,\n+                    //                                       comment_width,\n+                    //                                       self.block_indent,\n+                    //                                       self.config)\n+                    //                           .unwrap());\n+\n+    funk(); //dontchangeme\n+            // or me\n+}\n+\n+  /// test123\n+fn doc_comment() {\n+}\n+\n+fn chains() {\n+                foo.bar(|| { \n+                let x = 10;\n+                /* comment */ x })\n+}"}, {"sha": "6ab217ed6c48c5f0e8aab685b55b5196a95a6ea6", "filename": "tests/target/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -19,7 +19,7 @@ fn main() {\n     };\n \n     let loooooooooooooong_name = |field| {\n-             // TODO(#27): format comments.\n+        // TODO(#27): format comments.\n         if field.node.attrs.len() > 0 {\n             field.node.attrs[0].span.lo\n         } else {\n@@ -39,7 +39,8 @@ fn main() {\n \n     let empty = |arg| {};\n \n-    let simple = |arg| { /* TODO(#27): comment formatting */\n+    let simple = |arg| {\n+        // TODO(#27): comment formatting\n         foo(arg)\n     };\n "}, {"sha": "575631cd3be12a041828658a26a14fb125d27145", "filename": "tests/target/comment.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -0,0 +1,42 @@\n+//! Doc comment\n+fn test() {\n+    // comment\n+    // comment2\n+\n+    code(); /* leave this comment alone!\n+             * ok? */\n+\n+    // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a\n+    // diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam\n+    // viverra nec consectetur ante hendrerit. Donec et mollis dolor.\n+    // Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam\n+    // tincidunt congue enim, ut porta lorem lacinia consectetur. Donec ut\n+    // libero sed arcu vehicula ultricies a non tortor. Lorem ipsum dolor sit\n+    // amet, consectetur adipiscing elit. Aenean ut gravida lorem. Ut turpis\n+    // felis, pulvinar a semper sed, adipiscing id dolor.\n+\n+    // Very looooooooooooooooooooooooooooooooooooooooooooooooooooooooong comment\n+    // that should be split\n+\n+    // println!(\"{:?}\", rewrite_comment(subslice,\n+    //                                       false,\n+    //                                       comment_width,\n+    //                                       self.block_indent,\n+    //                                       self.config)\n+    //                           .unwrap());\n+\n+    funk(); //dontchangeme\n+            // or me\n+}\n+\n+/// test123\n+fn doc_comment() {\n+}\n+\n+fn chains() {\n+    foo.bar(|| {\n+        let x = 10;\n+        // comment\n+        x\n+    })\n+}"}, {"sha": "9e883c50afa19b19710e95cf367d995a24718554", "filename": "tests/target/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fdoc.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -1,3 +1,3 @@\n \n // sadfsdfa\n-//sdffsdfasdf\n+// sdffsdfasdf"}, {"sha": "4b4afaa99e555a8a754095d36bda919516211e0b", "filename": "tests/target/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -142,7 +142,8 @@ fn baz() {\n fn qux() {\n     {}\n     // FIXME this one could be done better.\n-    { /* a block with a comment */\n+    {\n+        // a block with a comment\n     }\n     {\n "}, {"sha": "7202b0e0c80702c9cb92dda850cd0da357b099f7", "filename": "tests/target/match.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -6,7 +6,8 @@ fn foo() {\n         // Some comment.\n         a => foo(),\n         b if 0 < 42 => foo(),\n-        c => { // Another comment.\n+        c => {\n+            // Another comment.\n             // Comment.\n             an_expression;\n             foo()\n@@ -112,7 +113,8 @@ fn issue339() {\n         // collapsing here exceeds line length\n         ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffg => {\n         }\n-        h => { // comment above block\n+        h => {\n+            // comment above block\n         }\n         i => {} // comment below block\n         j => {\n@@ -133,7 +135,8 @@ fn issue339() {\n         m => {}\n         n => {}\n         o => {}\n-        p => { // Dont collapse me\n+        p => {\n+            // Dont collapse me\n         }\n         q => {}\n         r => {}"}, {"sha": "7d6513f70b72f00d52fd2aa33abfd914d507a7d2", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8447a82104d5f9da2802af1e8530aba7ad6512a/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=e8447a82104d5f9da2802af1e8530aba7ad6512a", "patch": "@@ -22,7 +22,8 @@ mod doc;\n mod other;\n \n \n-// sfdgfffffffffffffffffffffffffffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffffff\n+// sfdgfffffffffffffffffffffffffffffffffffffffffffffffffffffff\n+// ffffffffffffffffffffffffffffffffffffffffff\n \n fn foo(a: isize, b: u32 /* blah blah */, c: f64) {\n "}]}