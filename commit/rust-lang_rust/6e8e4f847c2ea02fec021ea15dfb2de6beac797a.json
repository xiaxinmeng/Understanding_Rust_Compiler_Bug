{"sha": "6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlOGU0Zjg0N2MyZWEwMmZlYzAyMWVhMTVkZmIyZGU2YmVhYzc5N2E=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-05-25T17:21:29Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-05-27T08:19:02Z"}, "message": "Remove #[cfg(stage0)] items.", "tree": {"sha": "7831f2de833ae0151217710dc87b2ba03a3bc128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7831f2de833ae0151217710dc87b2ba03a3bc128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "html_url": "https://github.com/rust-lang/rust/commit/6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07503dfb8bd60e2047a0a5083dd5377f9f14b77d", "url": "https://api.github.com/repos/rust-lang/rust/commits/07503dfb8bd60e2047a0a5083dd5377f9f14b77d", "html_url": "https://github.com/rust-lang/rust/commit/07503dfb8bd60e2047a0a5083dd5377f9f14b77d"}], "stats": {"total": 1367, "additions": 14, "deletions": 1353}, "files": [{"sha": "290b0566fd1b53d768858dc38e17df26049b0aec", "filename": "src/liballoc/arc_stage0.rs", "status": "removed", "additions": 0, "deletions": 686, "changes": 686, "blob_url": "https://github.com/rust-lang/rust/blob/07503dfb8bd60e2047a0a5083dd5377f9f14b77d/src%2Fliballoc%2Farc_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07503dfb8bd60e2047a0a5083dd5377f9f14b77d/src%2Fliballoc%2Farc_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc_stage0.rs?ref=07503dfb8bd60e2047a0a5083dd5377f9f14b77d", "patch": "@@ -1,686 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-//! Threadsafe reference-counted boxes (the `Arc<T>` type).\n-//!\n-//! The `Arc<T>` type provides shared ownership of an immutable value.\n-//! Destruction is deterministic, and will occur as soon as the last owner is\n-//! gone. It is marked as `Send` because it uses atomic reference counting.\n-//!\n-//! If you do not need thread-safety, and just need shared ownership, consider\n-//! the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n-//! does not use atomics, making it both thread-unsafe as well as significantly\n-//! faster when updating the reference count.\n-//!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n-//! to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n-//! will return `None` if the value has already been dropped.\n-//!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n-//! as `Weak<T>` pointers.\n-//!\n-//! # Examples\n-//!\n-//! Sharing some immutable data between threads:\n-//!\n-//! ```no_run\n-//! use std::sync::Arc;\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(5);\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         println!(\"{:?}\", five);\n-//!     });\n-//! }\n-//! ```\n-//!\n-//! Sharing mutable data safely between threads with a `Mutex`:\n-//!\n-//! ```no_run\n-//! use std::sync::{Arc, Mutex};\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(Mutex::new(5));\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         let mut number = five.lock().unwrap();\n-//!\n-//!         *number += 1;\n-//!\n-//!         println!(\"{}\", *number); // prints 6\n-//!     });\n-//! }\n-//! ```\n-\n-use boxed::Box;\n-\n-use core::prelude::*;\n-\n-use core::atomic;\n-use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n-use core::fmt;\n-use core::cmp::Ordering;\n-use core::mem::{min_align_of, size_of};\n-use core::mem;\n-use core::nonzero::NonZero;\n-use core::ops::Deref;\n-use core::ptr;\n-use core::hash::{Hash, Hasher};\n-use heap::deallocate;\n-\n-/// An atomically reference counted wrapper for shared state.\n-///\n-/// # Examples\n-///\n-/// In this example, a large vector of floats is shared between several threads.\n-/// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// thread.\n-///\n-/// When you clone an `Arc<T>`, it will create another pointer to the data and\n-/// increase the reference counter.\n-///\n-/// ```\n-/// # #![feature(alloc, core)]\n-/// use std::sync::Arc;\n-/// use std::thread;\n-///\n-/// fn main() {\n-///     let numbers: Vec<_> = (0..100u32).collect();\n-///     let shared_numbers = Arc::new(numbers);\n-///\n-///     for _ in 0..10 {\n-///         let child_numbers = shared_numbers.clone();\n-///\n-///         thread::spawn(move || {\n-///             let local_numbers = &child_numbers[..];\n-///\n-///             // Work with the local numbers\n-///         });\n-///     }\n-/// }\n-/// ```\n-#[unsafe_no_drop_flag]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Arc<T> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: NonZero<*mut ArcInner<T>>,\n-}\n-\n-unsafe impl<T: Sync + Send> Send for Arc<T> { }\n-unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n-\n-\n-/// A weak pointer to an `Arc`.\n-///\n-/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n-/// used to break cycles between `Arc` pointers.\n-#[unsafe_no_drop_flag]\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-pub struct Weak<T> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: NonZero<*mut ArcInner<T>>,\n-}\n-\n-unsafe impl<T: Sync + Send> Send for Weak<T> { }\n-unsafe impl<T: Sync + Send> Sync for Weak<T> { }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"(Weak)\")\n-    }\n-}\n-\n-struct ArcInner<T> {\n-    strong: atomic::AtomicUsize,\n-    weak: atomic::AtomicUsize,\n-    data: T,\n-}\n-\n-unsafe impl<T: Sync + Send> Send for ArcInner<T> {}\n-unsafe impl<T: Sync + Send> Sync for ArcInner<T> {}\n-\n-impl<T> Arc<T> {\n-    /// Constructs a new `Arc<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(data: T) -> Arc<T> {\n-        // Start the weak pointer count as 1 which is the weak pointer that's\n-        // held by all the strong pointers (kinda), see std/rc.rs for more info\n-        let x: Box<_> = box ArcInner {\n-            strong: atomic::AtomicUsize::new(1),\n-            weak: atomic::AtomicUsize::new(1),\n-            data: data,\n-        };\n-        Arc { _ptr: unsafe { NonZero::new(mem::transmute(x)) } }\n-    }\n-\n-    /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    /// ```\n-    #[unstable(feature = \"alloc\",\n-               reason = \"Weak pointers may not belong in this module.\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n-        // See the clone() impl for why this is relaxed\n-        self.inner().weak.fetch_add(1, Relaxed);\n-        Weak { _ptr: self._ptr }\n-    }\n-}\n-\n-impl<T> Arc<T> {\n-    #[inline]\n-    fn inner(&self) -> &ArcInner<T> {\n-        // This unsafety is ok because while this arc is alive we're guaranteed\n-        // that the inner pointer is valid. Furthermore, we know that the\n-        // `ArcInner` structure itself is `Sync` because the inner data is\n-        // `Sync` as well, so we're ok loaning out an immutable pointer to these\n-        // contents.\n-        unsafe { &**self._ptr }\n-    }\n-\n-    // Non-inlined part of `drop`.\n-    #[inline(never)]\n-    unsafe fn drop_slow(&mut self) {\n-        let ptr = *self._ptr;\n-\n-        // Destroy the data at this time, even though we may not free the box\n-        // allocation itself (there may still be weak pointers lying around).\n-        drop(ptr::read(&self.inner().data));\n-\n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n-            deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(), min_align_of::<ArcInner<T>>())\n-        }\n-    }\n-}\n-\n-/// Get the number of weak references to this value.\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n-\n-/// Get the number of strong references to this value.\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n-\n-\n-/// Returns a mutable reference to the contained value if the `Arc<T>` is unique.\n-///\n-/// Returns `None` if the `Arc<T>` is not unique.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(alloc)]\n-/// extern crate alloc;\n-/// # fn main() {\n-/// use alloc::arc::{Arc, get_mut};\n-///\n-/// let mut x = Arc::new(3);\n-/// *get_mut(&mut x).unwrap() = 4;\n-/// assert_eq!(*x, 4);\n-///\n-/// let _y = x.clone();\n-/// assert!(get_mut(&mut x).is_none());\n-/// # }\n-/// ```\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn get_mut<T>(this: &mut Arc<T>) -> Option<&mut T> {\n-    if strong_count(this) == 1 && weak_count(this) == 0 {\n-        // This unsafety is ok because we're guaranteed that the pointer\n-        // returned is the *only* pointer that will ever be returned to T. Our\n-        // reference count is guaranteed to be 1 at this point, and we required\n-        // the Arc itself to be `mut`, so we're returning the only possible\n-        // reference to the inner data.\n-        let inner = unsafe { &mut **this._ptr };\n-        Some(&mut inner.data)\n-    } else {\n-        None\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Arc<T> {\n-    /// Makes a clone of the `Arc<T>`.\n-    ///\n-    /// This increases the strong reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five.clone();\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Arc<T> {\n-        // Using a relaxed ordering is alright here, as knowledge of the\n-        // original reference prevents other threads from erroneously deleting\n-        // the object.\n-        //\n-        // As explained in the [Boost documentation][1], Increasing the\n-        // reference counter can always be done with memory_order_relaxed: New\n-        // references to an object can only be formed from an existing\n-        // reference, and passing an existing reference from one thread to\n-        // another must already provide any required synchronization.\n-        //\n-        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        self.inner().strong.fetch_add(1, Relaxed);\n-        Arc { _ptr: self._ptr }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Deref for Arc<T> {\n-    type Target = T;\n-\n-    #[inline]\n-    fn deref(&self) -> &T {\n-        &self.inner().data\n-    }\n-}\n-\n-impl<T: Clone> Arc<T> {\n-    /// Make a mutable reference from the given `Arc<T>`.\n-    ///\n-    /// This is also referred to as a copy-on-write operation because the inner\n-    /// data is cloned if the reference count is greater than one.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let mut five = Arc::new(5);\n-    ///\n-    /// let mut_five = five.make_unique();\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"alloc\")]\n-    pub fn make_unique(&mut self) -> &mut T {\n-        // Note that we hold a strong reference, which also counts as a weak\n-        // reference, so we only clone if there is an additional reference of\n-        // either kind.\n-        if self.inner().strong.load(SeqCst) != 1 ||\n-           self.inner().weak.load(SeqCst) != 1 {\n-            *self = Arc::new((**self).clone())\n-        }\n-        // As with `get_mut()`, the unsafety is ok because our reference was\n-        // either unique to begin with, or became one upon cloning the contents.\n-        let inner = unsafe { &mut **self._ptr };\n-        &mut inner.data\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Arc<T> {\n-    /// Drops the `Arc<T>`.\n-    ///\n-    /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///\n-    ///     // stuff\n-    ///\n-    ///     drop(five); // explicit drop\n-    /// }\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///\n-    ///     // stuff\n-    ///\n-    /// } // implicit drop\n-    /// ```\n-    #[inline]\n-    fn drop(&mut self) {\n-        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n-        // more than once (but it is guaranteed to be zeroed after the first if\n-        // it's run more than once)\n-        let ptr = *self._ptr;\n-        // if ptr.is_null() { return }\n-        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n-\n-        // Because `fetch_sub` is already atomic, we do not need to synchronize\n-        // with other threads unless we are going to delete the object. This\n-        // same logic applies to the below `fetch_sub` to the `weak` count.\n-        if self.inner().strong.fetch_sub(1, Release) != 1 { return }\n-\n-        // This fence is needed to prevent reordering of use of the data and\n-        // deletion of the data.  Because it is marked `Release`, the decreasing\n-        // of the reference count synchronizes with this `Acquire` fence. This\n-        // means that use of the data happens before decreasing the reference\n-        // count, which happens before this fence, which happens before the\n-        // deletion of the data.\n-        //\n-        // As explained in the [Boost documentation][1],\n-        //\n-        // > It is important to enforce any possible access to the object in one\n-        // > thread (through an existing reference) to *happen before* deleting\n-        // > the object in a different thread. This is achieved by a \"release\"\n-        // > operation after dropping a reference (any access to the object\n-        // > through this reference must obviously happened before), and an\n-        // > \"acquire\" operation before deleting the object.\n-        //\n-        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        atomic::fence(Acquire);\n-\n-        unsafe {\n-            self.drop_slow()\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n-    ///\n-    /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n-    ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    ///\n-    /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n-    /// ```\n-    pub fn upgrade(&self) -> Option<Arc<T>> {\n-        // We use a CAS loop to increment the strong count instead of a\n-        // fetch_add because once the count hits 0 it must never be above 0.\n-        let inner = self.inner();\n-        loop {\n-            let n = inner.strong.load(SeqCst);\n-            if n == 0 { return None }\n-            let old = inner.strong.compare_and_swap(n, n + 1, SeqCst);\n-            if old == n { return Some(Arc { _ptr: self._ptr }) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn inner(&self) -> &ArcInner<T> {\n-        // See comments above for why this is \"safe\"\n-        unsafe { &**self._ptr }\n-    }\n-}\n-\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n-    ///\n-    /// This increases the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// let weak_five = Arc::new(5).downgrade();\n-    ///\n-    /// weak_five.clone();\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Weak<T> {\n-        // See comments in Arc::clone() for why this is relaxed\n-        self.inner().weak.fetch_add(1, Relaxed);\n-        Weak { _ptr: self._ptr }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n-    ///\n-    /// This will decrement the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::sync::Arc;\n-    ///\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///     let weak_five = five.downgrade();\n-    ///\n-    ///     // stuff\n-    ///\n-    ///     drop(weak_five); // explicit drop\n-    /// }\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///     let weak_five = five.downgrade();\n-    ///\n-    ///     // stuff\n-    ///\n-    /// } // implicit drop\n-    /// ```\n-    fn drop(&mut self) {\n-        let ptr = *self._ptr;\n-\n-        // see comments above for why this check is here\n-        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n-\n-        // If we find out that we were the last weak pointer, then its time to\n-        // deallocate the data entirely. See the discussion in Arc::drop() about\n-        // the memory orderings\n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n-            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n-                                min_align_of::<ArcInner<T>>()) }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialEq> PartialEq for Arc<T> {\n-    /// Equality for two `Arc<T>`s.\n-    ///\n-    /// Two `Arc<T>`s are equal if their inner value are equal.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five == Arc::new(5);\n-    /// ```\n-    fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }\n-\n-    /// Inequality for two `Arc<T>`s.\n-    ///\n-    /// Two `Arc<T>`s are unequal if their inner value are unequal.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five != Arc::new(5);\n-    /// ```\n-    fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for Arc<T> {\n-    /// Partial comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `partial_cmp()` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five.partial_cmp(&Arc::new(5));\n-    /// ```\n-    fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n-        (**self).partial_cmp(&**other)\n-    }\n-\n-    /// Less-than comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `<` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five < Arc::new(5);\n-    /// ```\n-    fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }\n-\n-    /// 'Less-than or equal to' comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `<=` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five <= Arc::new(5);\n-    /// ```\n-    fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }\n-\n-    /// Greater-than comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `>` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five > Arc::new(5);\n-    /// ```\n-    fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }\n-\n-    /// 'Greater-than or equal to' comparison for two `Arc<T>`s.\n-    ///\n-    /// The two are compared by calling `>=` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// five >= Arc::new(5);\n-    /// ```\n-    fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for Arc<T> {\n-    fn cmp(&self, other: &Arc<T>) -> Ordering { (**self).cmp(&**other) }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for Arc<T> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Display> fmt::Display for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&**self, f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&**self, f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> fmt::Pointer for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self._ptr, f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Default> Default for Arc<T> {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> Arc<T> { Arc::new(Default::default()) }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash> Hash for Arc<T> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        (**self).hash(state)\n-    }\n-}"}, {"sha": "12eadcc145d5244b0154ad457a409da6092e1035", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -57,16 +57,12 @@ use core::any::Any;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n+use core::marker::Unsize;\n use core::mem;\n-use core::ops::{Deref, DerefMut};\n+use core::ops::{CoerceUnsized, Deref, DerefMut};\n use core::ptr::{Unique};\n use core::raw::{TraitObject};\n \n-#[cfg(not(stage0))]\n-use core::marker::Unsize;\n-#[cfg(not(stage0))]\n-use core::ops::CoerceUnsized;\n-\n /// A value that represents the heap. This is the default place that the `box`\n /// keyword allocates into when no place is supplied.\n ///\n@@ -392,5 +388,4 @@ impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}"}, {"sha": "ac5a5d60cbd47d0afdfda1180827efa3a7d6e991", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -112,14 +112,7 @@ pub mod boxed;\n mod boxed { pub use std::boxed::{Box, HEAP}; }\n #[cfg(test)]\n mod boxed_test;\n-#[cfg(not(stage0))]\n pub mod arc;\n-#[cfg(stage0)]\n-mod arc_stage0;\n-#[cfg(stage0)]\n-pub mod arc {\n-    pub use arc_stage0::*;\n-}\n pub mod rc;\n \n /// Common out-of-memory routine"}, {"sha": "44f4a6a6290c8e04ae12ebd96416921c83a8043a", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 415, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -159,36 +159,19 @@ use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n-use core::marker::{self, Sized};\n-use core::mem::{self, min_align_of, size_of, forget};\n+use core::intrinsics::{assume, drop_in_place};\n+use core::marker::{self, Sized, Unsize};\n+use core::mem::{self, min_align_of, size_of, min_align_of_val, size_of_val, forget};\n use core::nonzero::NonZero;\n-use core::ops::{Deref, Drop};\n+use core::ops::{CoerceUnsized, Deref, Drop};\n use core::option::Option;\n use core::option::Option::{Some, None};\n use core::ptr;\n use core::result::Result;\n use core::result::Result::{Ok, Err};\n-use core::intrinsics::assume;\n-\n-#[cfg(not(stage0))]\n-use core::intrinsics::drop_in_place;\n-#[cfg(not(stage0))]\n-use core::marker::Unsize;\n-#[cfg(not(stage0))]\n-use core::mem::{min_align_of_val, size_of_val};\n-#[cfg(not(stage0))]\n-use core::ops::CoerceUnsized;\n \n use heap::deallocate;\n \n-#[cfg(stage0)]\n-struct RcBox<T> {\n-    strong: Cell<usize>,\n-    weak: Cell<usize>,\n-    value: T,\n-}\n-\n-#[cfg(not(stage0))]\n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n     weak: Cell<usize>,\n@@ -199,15 +182,6 @@ struct RcBox<T: ?Sized> {\n /// A reference-counted pointer type over an immutable value.\n ///\n /// See the [module level documentation](./index.html) for more details.\n-#[cfg(stage0)]\n-#[unsafe_no_drop_flag]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Rc<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with field\n-    // accesses of the contained type via Deref\n-    _ptr: NonZero<*mut RcBox<T>>,\n-}\n-#[cfg(not(stage0))]\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n@@ -216,19 +190,9 @@ pub struct Rc<T: ?Sized> {\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n-#[cfg(stage0)]\n-impl<T> !marker::Send for Rc<T> {}\n-\n-#[cfg(not(stage0))]\n impl<T: ?Sized> !marker::Send for Rc<T> {}\n-\n-#[cfg(stage0)]\n-impl<T> !marker::Sync for Rc<T> {}\n-\n-#[cfg(not(stage0))]\n impl<T: ?Sized> !marker::Sync for Rc<T> {}\n \n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n \n impl<T> Rc<T> {\n@@ -259,7 +223,6 @@ impl<T> Rc<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T: ?Sized> Rc<T> {\n     /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n     ///\n@@ -281,44 +244,12 @@ impl<T: ?Sized> Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T> Rc<T> {\n-    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    /// ```\n-    #[unstable(feature = \"alloc\",\n-               reason = \"Weak pointers may not belong in this module\")]\n-    pub fn downgrade(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak { _ptr: self._ptr }\n-    }\n-}\n-\n /// Get the number of weak references to this value.\n-#[cfg(stage0)]\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }\n-#[cfg(not(stage0))]\n #[inline]\n #[unstable(feature = \"alloc\")]\n pub fn weak_count<T: ?Sized>(this: &Rc<T>) -> usize { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n-#[cfg(stage0)]\n-#[inline]\n-#[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }\n-#[cfg(not(stage0))]\n #[inline]\n #[unstable(feature = \"alloc\")]\n pub fn strong_count<T: ?Sized>(this: &Rc<T>) -> usize { this.strong() }\n@@ -438,17 +369,6 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Deref for Rc<T> {\n-    type Target = T;\n-\n-    #[inline(always)]\n-    fn deref(&self) -> &T {\n-        &self.inner().value\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Rc<T> {\n     type Target = T;\n@@ -459,58 +379,6 @@ impl<T: ?Sized> Deref for Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Rc<T> {\n-    /// Drops the `Rc<T>`.\n-    ///\n-    /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///\n-    ///     // stuff\n-    ///\n-    ///     drop(five); // explicit drop\n-    /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///\n-    ///     // stuff\n-    ///\n-    /// } // implicit drop\n-    /// ```\n-    fn drop(&mut self) {\n-        unsafe {\n-            let ptr = *self._ptr;\n-            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n-                self.dec_strong();\n-                if self.strong() == 0 {\n-                    ptr::read(&**self); // destroy the contained object\n-\n-                    // remove the implicit \"strong weak\" pointer now that we've\n-                    // destroyed the contents.\n-                    self.dec_weak();\n-\n-                    if self.weak() == 0 {\n-                        deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n-                                   min_align_of::<RcBox<T>>())\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n@@ -564,32 +432,6 @@ impl<T: ?Sized> Drop for Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for Rc<T> {\n-\n-    /// Makes a clone of the `Rc<T>`.\n-    ///\n-    /// When you clone an `Rc<T>`, it will create another pointer to the data and\n-    /// increase the strong reference counter.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5);\n-    ///\n-    /// five.clone();\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Rc<T> {\n-        self.inc_strong();\n-        Rc { _ptr: self._ptr }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Rc<T> {\n \n@@ -634,17 +476,6 @@ impl<T: Default> Default for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: PartialEq> PartialEq for Rc<T> {\n-    #[inline(always)]\n-    fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n-\n-    #[inline(always)]\n-    fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc<T>`s.\n     ///\n@@ -680,34 +511,9 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: Eq> Eq for Rc<T> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: ?Sized + Eq> Eq for Rc<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: PartialOrd> PartialOrd for Rc<T> {\n-    #[inline(always)]\n-    fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n-        (**self).partial_cmp(&**other)\n-    }\n-\n-    #[inline(always)]\n-    fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n-\n-    #[inline(always)]\n-    fn le(&self, other: &Rc<T>) -> bool { **self <= **other }\n-\n-    #[inline(always)]\n-    fn gt(&self, other: &Rc<T>) -> bool { **self > **other }\n-\n-    #[inline(always)]\n-    fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     /// Partial comparison for two `Rc<T>`s.\n     ///\n@@ -793,13 +599,6 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(stage0)]\n-impl<T: Ord> Ord for Rc<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg(not(stage0))]\n impl<T: ?Sized + Ord> Ord for Rc<T> {\n     /// Comparison for two `Rc<T>`s.\n     ///\n@@ -818,44 +617,20 @@ impl<T: ?Sized + Ord> Ord for Rc<T> {\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash> Hash for Rc<T> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized+Hash> Hash for Rc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Display> fmt::Display for Rc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&**self, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized+fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&**self, f)\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized+fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -876,16 +651,6 @@ impl<T> fmt::Pointer for Rc<T> {\n /// dropped.\n ///\n /// See the [module level documentation](./index.html) for more.\n-#[cfg(stage0)]\n-#[unsafe_no_drop_flag]\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-pub struct Weak<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: NonZero<*mut RcBox<T>>,\n-}\n-#[cfg(not(stage0))]\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n@@ -895,51 +660,9 @@ pub struct Weak<T: ?Sized> {\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n-#[cfg(stage0)]\n-impl<T> !marker::Send for Weak<T> {}\n-#[cfg(not(stage0))]\n impl<T: ?Sized> !marker::Send for Weak<T> {}\n-\n-#[cfg(stage0)]\n-impl<T> !marker::Sync for Weak<T> {}\n-#[cfg(not(stage0))]\n impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n-\n-#[cfg(stage0)]\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Weak<T> {\n-\n-    /// Upgrades a weak reference to a strong reference.\n-    ///\n-    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n-    ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    ///\n-    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n-    /// ```\n-    pub fn upgrade(&self) -> Option<Rc<T>> {\n-        if self.strong() == 0 {\n-            None\n-        } else {\n-            self.inc_strong();\n-            Some(Rc { _ptr: self._ptr })\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Weak<T> {\n@@ -973,52 +696,6 @@ impl<T: ?Sized> Weak<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n-    ///\n-    /// This will decrement the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = five.downgrade();\n-    ///\n-    ///     // stuff\n-    ///\n-    ///     drop(weak_five); // explicit drop\n-    /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = five.downgrade();\n-    ///\n-    ///     // stuff\n-    ///\n-    /// } // implicit drop\n-    /// ```\n-    fn drop(&mut self) {\n-        unsafe {\n-            let ptr = *self._ptr;\n-            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n-                self.dec_weak();\n-                // the weak count starts at 1, and will only go to zero if all\n-                // the strong pointers have disappeared.\n-                if self.weak() == 0 {\n-                    deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n-                               min_align_of::<RcBox<T>>())\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n@@ -1064,32 +741,6 @@ impl<T: ?Sized> Drop for Weak<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[unstable(feature = \"alloc\",\n-           reason = \"Weak pointers may not belong in this module.\")]\n-impl<T> Clone for Weak<T> {\n-\n-    /// Makes a clone of the `Weak<T>`.\n-    ///\n-    /// This increases the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(alloc)]\n-    /// use std::rc::Rc;\n-    ///\n-    /// let weak_five = Rc::new(5).downgrade();\n-    ///\n-    /// weak_five.clone();\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak { _ptr: self._ptr }\n-    }\n-}\n-#[cfg(not(stage0))]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: ?Sized> Clone for Weak<T> {\n@@ -1115,45 +766,13 @@ impl<T: ?Sized> Clone for Weak<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"(Weak)\")\n-    }\n-}\n-#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized+fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n }\n \n-#[cfg(stage0)]\n-#[doc(hidden)]\n-trait RcBoxPtr<T> {\n-    fn inner(&self) -> &RcBox<T>;\n-\n-    #[inline]\n-    fn strong(&self) -> usize { self.inner().strong.get() }\n-\n-    #[inline]\n-    fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }\n-\n-    #[inline]\n-    fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }\n-\n-    #[inline]\n-    fn weak(&self) -> usize { self.inner().weak.get() }\n-\n-    #[inline]\n-    fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }\n-\n-    #[inline]\n-    fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n-}\n-#[cfg(not(stage0))]\n #[doc(hidden)]\n trait RcBoxPtr<T: ?Sized> {\n     fn inner(&self) -> &RcBox<T>;\n@@ -1177,21 +796,6 @@ trait RcBoxPtr<T: ?Sized> {\n     fn dec_weak(&self) { self.inner().weak.set(self.weak() - 1); }\n }\n \n-#[cfg(stage0)]\n-impl<T> RcBoxPtr<T> for Rc<T> {\n-    #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n-            &(**self._ptr)\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n@@ -1206,21 +810,6 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T> RcBoxPtr<T> for Weak<T> {\n-    #[inline(always)]\n-    fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n-            &(**self._ptr)\n-        }\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {"}, {"sha": "8e8fc0bedec6ac5080aaf82df975424268a73da8", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -116,17 +116,11 @@ impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n     fn borrow_mut(&mut self) -> &mut T { &mut **self }\n }\n \n-#[cfg(stage0)]\n-impl<T> Borrow<T> for rc::Rc<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T: ?Sized> Borrow<T> for rc::Rc<T> {\n     fn borrow(&self) -> &T { &**self }\n }\n \n-impl<T> Borrow<T> for arc::Arc<T> {\n+impl<T: ?Sized> Borrow<T> for arc::Arc<T> {\n     fn borrow(&self) -> &T { &**self }\n }\n "}, {"sha": "2d8335d37347325e6ce0a296ff9678a6c4a37fff", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -19,7 +19,6 @@ pub use self::TraversalItem::*;\n use core::prelude::*;\n \n use core::cmp::Ordering::{Greater, Less, Equal};\n-#[cfg(not(stage0))]\n use core::intrinsics::arith_offset;\n use core::iter::Zip;\n use core::marker::PhantomData;\n@@ -207,22 +206,6 @@ impl<T> RawItems<T> {\n         RawItems::from_parts(slice.as_ptr(), slice.len())\n     }\n \n-    #[cfg(stage0)]\n-    unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n-        if mem::size_of::<T>() == 0 {\n-            RawItems {\n-                head: ptr,\n-                tail: (ptr as usize + len) as *const T,\n-            }\n-        } else {\n-            RawItems {\n-                head: ptr,\n-                tail: ptr.offset(len as isize),\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     unsafe fn from_parts(ptr: *const T, len: usize) -> RawItems<T> {\n         if mem::size_of::<T>() == 0 {\n             RawItems {\n@@ -237,18 +220,6 @@ impl<T> RawItems<T> {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    unsafe fn push(&mut self, val: T) {\n-        ptr::write(self.tail as *mut T, val);\n-\n-        if mem::size_of::<T>() == 0 {\n-            self.tail = (self.tail as usize + 1) as *const T;\n-        } else {\n-            self.tail = self.tail.offset(1);\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     unsafe fn push(&mut self, val: T) {\n         ptr::write(self.tail as *mut T, val);\n \n@@ -263,26 +234,6 @@ impl<T> RawItems<T> {\n impl<T> Iterator for RawItems<T> {\n     type Item = T;\n \n-    #[cfg(stage0)]\n-    fn next(&mut self) -> Option<T> {\n-        if self.head == self.tail {\n-            None\n-        } else {\n-            unsafe {\n-                let ret = Some(ptr::read(self.head));\n-\n-                if mem::size_of::<T>() == 0 {\n-                    self.head = (self.head as usize + 1) as *const T;\n-                } else {\n-                    self.head = self.head.offset(1);\n-                }\n-\n-                ret\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn next(&mut self) -> Option<T> {\n         if self.head == self.tail {\n             None\n@@ -303,24 +254,6 @@ impl<T> Iterator for RawItems<T> {\n }\n \n impl<T> DoubleEndedIterator for RawItems<T> {\n-    #[cfg(stage0)]\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.head == self.tail {\n-            None\n-        } else {\n-            unsafe {\n-                if mem::size_of::<T>() == 0 {\n-                    self.tail = (self.tail as usize - 1) as *const T;\n-                } else {\n-                    self.tail = self.tail.offset(-1);\n-                }\n-\n-                Some(ptr::read(self.tail))\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn next_back(&mut self) -> Option<T> {\n         if self.head == self.tail {\n             None"}, {"sha": "4d52eb8e8ae671e96666b95f01699748c763f8fb", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 71, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -66,9 +66,7 @@ use core::cmp::max;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::intrinsics::assume;\n-#[cfg(not(stage0))]\n-use core::intrinsics::arith_offset;\n+use core::intrinsics::{arith_offset, assume};\n use core::iter::{repeat, FromIterator};\n use core::marker::PhantomData;\n use core::mem;\n@@ -1526,25 +1524,6 @@ impl<T> IntoIterator for Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    #[cfg(stage0)]\n-    fn into_iter(self) -> IntoIter<T> {\n-        unsafe {\n-            let ptr = *self.ptr;\n-            assume(!ptr.is_null());\n-            let cap = self.cap;\n-            let begin = ptr as *const T;\n-            let end = if mem::size_of::<T>() == 0 {\n-                (ptr as usize + self.len()) as *const T\n-            } else {\n-                ptr.offset(self.len() as isize) as *const T\n-            };\n-            mem::forget(self);\n-            IntoIter { allocation: ptr, cap: cap, ptr: begin, end: end }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n             let ptr = *self.ptr;\n@@ -1764,32 +1743,6 @@ impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     #[inline]\n-    #[cfg(stage0)]\n-    fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            if self.ptr == self.end {\n-                None\n-            } else {\n-                if mem::size_of::<T>() == 0 {\n-                    // purposefully don't use 'ptr.offset' because for\n-                    // vectors with 0-size elements this would return the\n-                    // same pointer.\n-                    self.ptr = mem::transmute(self.ptr as usize + 1);\n-\n-                    // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n-                } else {\n-                    let old = self.ptr;\n-                    self.ptr = self.ptr.offset(1);\n-\n-                    Some(ptr::read(old))\n-                }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn next(&mut self) -> Option<T> {\n         unsafe {\n             if self.ptr == self.end {\n@@ -1830,29 +1783,6 @@ impl<T> Iterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n-    #[cfg(stage0)]\n-    fn next_back(&mut self) -> Option<T> {\n-        unsafe {\n-            if self.end == self.ptr {\n-                None\n-            } else {\n-                if mem::size_of::<T>() == 0 {\n-                    // See above for why 'ptr.offset' isn't used\n-                    self.end = mem::transmute(self.end as usize - 1);\n-\n-                    // Use a non-null pointer value\n-                    Some(ptr::read(EMPTY as *mut T))\n-                } else {\n-                    self.end = self.end.offset(-1);\n-\n-                    Some(ptr::read(mem::transmute(self.end)))\n-                }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn next_back(&mut self) -> Option<T> {\n         unsafe {\n             if self.end == self.ptr {"}, {"sha": "88a686ec255f34732454abed6f2a643df9c30226", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -145,13 +145,9 @@ extern \"rust-intrinsic\" {\n     /// but no instructions will be emitted for it. This is appropriate for operations\n     /// on the same thread that may be preempted, such as when interacting with signal\n     /// handlers.\n-    #[cfg(not(stage0))]     // SNAP 857ef6e\n     pub fn atomic_singlethreadfence();\n-    #[cfg(not(stage0))]     // SNAP 857ef6e\n     pub fn atomic_singlethreadfence_acq();\n-    #[cfg(not(stage0))]     // SNAP 857ef6e\n     pub fn atomic_singlethreadfence_rel();\n-    #[cfg(not(stage0))]     // SNAP 857ef6e\n     pub fn atomic_singlethreadfence_acqrel();\n \n     /// Aborts the execution of the process.\n@@ -193,11 +189,8 @@ extern \"rust-intrinsic\" {\n     pub fn min_align_of<T>() -> usize;\n     pub fn pref_align_of<T>() -> usize;\n \n-    #[cfg(not(stage0))]\n     pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n-    #[cfg(not(stage0))]\n     pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n-    #[cfg(not(stage0))]\n     pub fn drop_in_place<T: ?Sized>(_: *mut T);\n \n     /// Gets a static string slice containing the name of a type.\n@@ -294,7 +287,6 @@ extern \"rust-intrinsic\" {\n     /// resulting pointer to point into or one byte past the end of an allocated\n     /// object, and it wraps with two's complement arithmetic. The resulting\n     /// value is not necessarily valid to be used to actually access memory.\n-    #[cfg(not(stage0))]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -592,13 +584,6 @@ extern \"rust-intrinsic\" {\n     /// Returns (a * b) mod 2^N, where N is the width of N in bits.\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n \n-    /// Returns the value of the discriminant for the variant in 'v',\n-    /// cast to a `u64`; if `T` has no discriminant, returns 0.\n-    pub fn discriminant_value<T>(v: &T) -> u64;\n-}\n-\n-#[cfg(not(stage0))]\n-extern \"rust-intrinsic\" {\n     /// Performs an unchecked signed division, which results in undefined behavior,\n     /// in cases where y == 0, or x == int::MIN and y == -1\n     pub fn unchecked_sdiv<T>(x: T, y: T) -> T;\n@@ -612,4 +597,8 @@ extern \"rust-intrinsic\" {\n     /// Returns the remainder of an unchecked signed division, which results in\n     /// undefined behavior, in cases where y == 0\n     pub fn unchecked_srem<T>(x: T, y: T) -> T;\n+\n+    /// Returns the value of the discriminant for the variant in 'v',\n+    /// cast to a `u64`; if `T` has no discriminant, returns 0.\n+    pub fn discriminant_value<T>(v: &T) -> u64;\n }"}, {"sha": "bc0f3045972fe6b67e04c7189ea152cfe7ac9756", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -55,7 +55,6 @@ pub trait Sized {\n \n /// Types that can be \"unsized\" to a dynamically sized type.\n #[unstable(feature = \"core\")]\n-#[cfg(not(stage0))]\n #[lang=\"unsize\"]\n pub trait Unsize<T> {\n     // Empty."}, {"sha": "7749d053285ad09f646c27004bc28f7dd8c9a070", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -95,29 +95,12 @@ pub fn size_of<T>() -> usize {\n ///\n /// assert_eq!(4, mem::size_of_val(&5i32));\n /// ```\n-#[cfg(not(stage0))]\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::size_of_val(val) }\n }\n \n-/// Returns the size of the type that `_val` points to in bytes.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::size_of_val(&5i32));\n-/// ```\n-#[cfg(stage0)]\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn size_of_val<T>(_val: &T) -> usize {\n-    size_of::<T>()\n-}\n-\n /// Returns the ABI-required minimum alignment of a type\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n@@ -144,29 +127,12 @@ pub fn min_align_of<T>() -> usize {\n ///\n /// assert_eq!(4, mem::min_align_of_val(&5i32));\n /// ```\n-#[cfg(not(stage0))]\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that `_val` points to\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::min_align_of_val(&5i32));\n-/// ```\n-#[cfg(stage0)]\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn min_align_of_val<T>(_val: &T) -> usize {\n-    min_align_of::<T>()\n-}\n-\n /// Returns the alignment in memory for a type.\n ///\n /// This function will return the alignment, in bytes, of a type in memory. If the alignment"}, {"sha": "32522794254f683eb7a2894f0400a91f225d2205", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -11,9 +11,7 @@\n //! Exposes the NonZero lang item which provides optimization hints.\n \n use marker::Sized;\n-use ops::Deref;\n-#[cfg(not(stage0))]\n-use ops::CoerceUnsized;\n+use ops::{CoerceUnsized, Deref};\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n pub unsafe trait Zeroable {}\n@@ -57,5 +55,4 @@ impl<T: Zeroable> Deref for NonZero<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T: Zeroable+CoerceUnsized<U>, U: Zeroable> CoerceUnsized<NonZero<U>> for NonZero<T> {}"}, {"sha": "c52f4de732ff9f56d46902887b3e2e27a20d27e3", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -67,12 +67,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use marker::Sized;\n+use marker::{Sized, Unsize};\n use fmt;\n \n-#[cfg(not(stage0))]\n-use marker::Unsize;\n-\n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n /// is sometimes called a 'destructor'.\n ///\n@@ -1214,39 +1211,29 @@ mod impls {\n /// Trait that indicates that this is a pointer or a wrapper for one,\n /// where unsizing can be performed on the pointee.\n #[unstable(feature = \"core\")]\n-#[cfg(not(stage0))]\n #[lang=\"coerce_unsized\"]\n pub trait CoerceUnsized<T> {\n     // Empty.\n }\n \n // &mut T -> &mut U\n-#[cfg(not(stage0))]\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n // &mut T -> &U\n-#[cfg(not(stage0))]\n impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n // &mut T -> *mut U\n-#[cfg(not(stage0))]\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n // &mut T -> *const U\n-#[cfg(not(stage0))]\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n \n // &T -> &U\n-#[cfg(not(stage0))]\n impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n // &T -> *const U\n-#[cfg(not(stage0))]\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n \n // *mut T -> *mut U\n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n // *mut T -> *const U\n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n // *const T -> *const U\n-#[cfg(not(stage0))]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}"}, {"sha": "2dc28a4786f2dd76169672ee069d783378370db8", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -125,19 +125,6 @@ pub trait SliceExt {\n }\n \n // Use macros to be generic over const/mut\n-#[cfg(stage0)]\n-macro_rules! slice_offset {\n-    ($ptr:expr, $by:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            transmute((ptr as isize).wrapping_add($by))\n-        } else {\n-            ptr.offset($by)\n-        }\n-    }};\n-}\n-\n-#[cfg(not(stage0))]\n macro_rules! slice_offset {\n     ($ptr:expr, $by:expr) => {{\n         let ptr = $ptr;"}, {"sha": "c92bb81c5fb254d841fd0b59a44b1d90e609962b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -167,7 +167,4 @@ mod rustc {\n }\n \n // Build the diagnostics array at the end so that the metadata includes error use sites.\n-#[cfg(stage0)]\n-__build_diagnostic_array! { DIAGNOSTICS }\n-#[cfg(not(stage0))]\n __build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "a8457d3bf94cdf93c3fa622bc927d634d16fb8eb", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -47,7 +47,4 @@ mod borrowck;\n \n pub mod graphviz;\n \n-#[cfg(stage0)]\n-__build_diagnostic_array! { DIAGNOSTICS }\n-#[cfg(not(stage0))]\n __build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "cae0c7c7f5792ac8322ea88104d9b68544700318", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -3723,7 +3723,4 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     }\n }\n \n-#[cfg(stage0)]\n-__build_diagnostic_array! { DIAGNOSTICS }\n-#[cfg(not(stage0))]\n __build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "ed398c2cdedfc79f0d035e8f080b35e30e528fcd", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8e4f847c2ea02fec021ea15dfb2de6beac797a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6e8e4f847c2ea02fec021ea15dfb2de6beac797a", "patch": "@@ -344,7 +344,4 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     tcx.sess.abort_if_errors();\n }\n \n-#[cfg(stage0)]\n-__build_diagnostic_array! { DIAGNOSTICS }\n-#[cfg(not(stage0))]\n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}]}