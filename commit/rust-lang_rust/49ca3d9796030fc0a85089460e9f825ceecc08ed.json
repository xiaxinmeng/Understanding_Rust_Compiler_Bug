{"sha": "49ca3d9796030fc0a85089460e9f825ceecc08ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Y2EzZDk3OTYwMzBmYzBhODUwODk0NjBlOWY4MjVjZWVjYzA4ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-04T07:17:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-04T07:17:25Z"}, "message": "Auto merge of #87026 - FabianWolff:issue-86948, r=estebank\n\nAllow labeled loops as value expressions for `break`\n\nFixes #86948. This is currently allowed:\n```rust\nreturn 'label: loop { break 'label 42; };\nbreak ('label: loop { break 'label 42; });\nbreak 1 + 'label: loop { break 'label 42; };\nbreak 'outer 'inner: loop { break 'inner 42; };\n```\nBut not this:\n```rust\nbreak 'label: loop { break 'label 42; };\n```\nI have fixed this, so that the above now parses as an unlabeled break with a labeled loop as its value expression.", "tree": {"sha": "c2c0348ec5549e1e143498e37078e120e273fb6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2c0348ec5549e1e143498e37078e120e273fb6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49ca3d9796030fc0a85089460e9f825ceecc08ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49ca3d9796030fc0a85089460e9f825ceecc08ed", "html_url": "https://github.com/rust-lang/rust/commit/49ca3d9796030fc0a85089460e9f825ceecc08ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49ca3d9796030fc0a85089460e9f825ceecc08ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71ff9b41e9ebd3e336019513917a7a8868d1cc66", "url": "https://api.github.com/repos/rust-lang/rust/commits/71ff9b41e9ebd3e336019513917a7a8868d1cc66", "html_url": "https://github.com/rust-lang/rust/commit/71ff9b41e9ebd3e336019513917a7a8868d1cc66"}, {"sha": "7c81132a60579de56bd4baa7866fa9db2ecd5ddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c81132a60579de56bd4baa7866fa9db2ecd5ddd", "html_url": "https://github.com/rust-lang/rust/commit/7c81132a60579de56bd4baa7866fa9db2ecd5ddd"}], "stats": {"total": 178, "additions": 157, "deletions": 21}, "files": [{"sha": "4a646013ff89166a51d5f2fff2a4e4704fc274ef", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49ca3d9796030fc0a85089460e9f825ceecc08ed/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ca3d9796030fc0a85089460e9f825ceecc08ed/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=49ca3d9796030fc0a85089460e9f825ceecc08ed", "patch": "@@ -750,6 +750,14 @@ pub trait LintContext: Sized {\n                         db.note(&format!(\"to ignore the value produced by the macro, add a semicolon after the invocation of `{name}`\"));\n                     }\n                 }\n+                BuiltinLintDiagnostics::BreakWithLabelAndLoop(span) => {\n+                    db.multipart_suggestion(\n+                        \"wrap this expression in parentheses\",\n+                        vec![(span.shrink_to_lo(), \"(\".to_string()),\n+                             (span.shrink_to_hi(), \")\".to_string())],\n+                        Applicability::MachineApplicable\n+                    );\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));"}, {"sha": "9b1ee53df23bd1c99386d415499b52c66c88f870", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/49ca3d9796030fc0a85089460e9f825ceecc08ed/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ca3d9796030fc0a85089460e9f825ceecc08ed/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=49ca3d9796030fc0a85089460e9f825ceecc08ed", "patch": "@@ -2978,6 +2978,7 @@ declare_lint_pass! {\n         RUST_2021_PRELUDE_COLLISIONS,\n         RUST_2021_PREFIXES_INCOMPATIBLE_SYNTAX,\n         UNSUPPORTED_CALLING_CONVENTIONS,\n+        BREAK_WITH_LABEL_AND_LOOP,\n     ]\n }\n \n@@ -3351,3 +3352,32 @@ declare_lint! {\n         reference: \"issue #00000 <https://github.com/rust-lang/rust/issues/00000>\",\n     };\n }\n+\n+declare_lint! {\n+    /// The `break_with_label_and_loop` lint detects labeled `break` expressions with\n+    /// an unlabeled loop as their value expression.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// 'label: loop {\n+    ///     break 'label loop { break 42; };\n+    /// };\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In Rust, loops can have a label, and `break` expressions can refer to that label to\n+    /// break out of specific loops (and not necessarily the innermost one). `break` expressions\n+    /// can also carry a value expression, which can be another loop. A labeled `break` with an\n+    /// unlabeled loop as its value expression is easy to confuse with an unlabeled break with\n+    /// a labeled loop and is thus discouraged (but allowed for compatibility); use parentheses\n+    /// around the loop expression to silence this warning. Unlabeled `break` expressions with\n+    /// labeled loops yield a hard error, which can also be silenced by wrapping the expression\n+    /// in parentheses.\n+    pub BREAK_WITH_LABEL_AND_LOOP,\n+    Warn,\n+    \"`break` expression with label and unlabeled loop as value expression\"\n+}"}, {"sha": "b8f5345ffb8849dd2640cd7da128ce0361c419c8", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49ca3d9796030fc0a85089460e9f825ceecc08ed/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ca3d9796030fc0a85089460e9f825ceecc08ed/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=49ca3d9796030fc0a85089460e9f825ceecc08ed", "patch": "@@ -304,6 +304,7 @@ pub enum BuiltinLintDiagnostics {\n     OrPatternsBackCompat(Span, String),\n     ReservedPrefix(Span),\n     TrailingMacro(bool, Ident),\n+    BreakWithLabelAndLoop(Span),\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "824f2316e5850714956d3092058e6e32d0f04320", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/49ca3d9796030fc0a85089460e9f825ceecc08ed/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ca3d9796030fc0a85089460e9f825ceecc08ed/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=49ca3d9796030fc0a85089460e9f825ceecc08ed", "patch": "@@ -15,6 +15,8 @@ use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, DiagnosticBuilder, PResult};\n+use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -1375,14 +1377,59 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n-    /// Parse `\"('label \":\")? break expr?`.\n+    /// Parse `\"break\" (('label (:? expr)?) | expr?)` with `\"break\"` token already eaten.\n+    /// If the label is followed immediately by a `:` token, the label and `:` are\n+    /// parsed as part of the expression (i.e. a labeled loop). The language team has\n+    /// decided in #87026 to require parentheses as a visual aid to avoid confusion if\n+    /// the break expression of an unlabeled break is a labeled loop (as in\n+    /// `break 'lbl: loop {}`); a labeled break with an unlabeled loop as its value\n+    /// expression only gets a warning for compatibility reasons; and a labeled break\n+    /// with a labeled loop does not even get a warning because there is no ambiguity.\n     fn parse_break_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n-        let label = self.eat_label();\n-        let kind = if self.token != token::OpenDelim(token::Brace)\n+        let mut label = self.eat_label();\n+        let kind = if label.is_some() && self.token == token::Colon {\n+            // The value expression can be a labeled loop, see issue #86948, e.g.:\n+            // `loop { break 'label: loop { break 'label 42; }; }`\n+            let lexpr = self.parse_labeled_expr(label.take().unwrap(), AttrVec::new(), true)?;\n+            self.struct_span_err(\n+                lexpr.span,\n+                \"parentheses are required around this expression to avoid confusion with a labeled break expression\",\n+            )\n+            .multipart_suggestion(\n+                \"wrap the expression in parentheses\",\n+                vec![\n+                    (lexpr.span.shrink_to_lo(), \"(\".to_string()),\n+                    (lexpr.span.shrink_to_hi(), \")\".to_string()),\n+                ],\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+            Some(lexpr)\n+        } else if self.token != token::OpenDelim(token::Brace)\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n         {\n-            self.parse_expr_opt()?\n+            let expr = self.parse_expr_opt()?;\n+            if let Some(ref expr) = expr {\n+                if label.is_some()\n+                    && matches!(\n+                        expr.kind,\n+                        ExprKind::While(_, _, None)\n+                            | ExprKind::ForLoop(_, _, _, None)\n+                            | ExprKind::Loop(_, None)\n+                            | ExprKind::Block(_, None)\n+                    )\n+                {\n+                    self.sess.buffer_lint_with_diagnostic(\n+                        BREAK_WITH_LABEL_AND_LOOP,\n+                        lo.to(expr.span),\n+                        ast::CRATE_NODE_ID,\n+                        \"this labeled break expression is easy to confuse with an unlabeled break with a labeled value expression\",\n+                        BuiltinLintDiagnostics::BreakWithLabelAndLoop(expr.span),\n+                    );\n+                }\n+            }\n+            expr\n         } else {\n             None\n         };"}, {"sha": "903b4de6ef47c3edfd44f5f984aca0e7030d1a22", "filename": "src/test/ui/parser/lifetime_starts_expressions.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/49ca3d9796030fc0a85089460e9f825ceecc08ed/src%2Ftest%2Fui%2Fparser%2Flifetime_starts_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49ca3d9796030fc0a85089460e9f825ceecc08ed/src%2Ftest%2Fui%2Fparser%2Flifetime_starts_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flifetime_starts_expressions.rs?ref=49ca3d9796030fc0a85089460e9f825ceecc08ed", "patch": "@@ -1,13 +1,39 @@\n+#![allow(unused, dead_code)]\n+\n fn foo() -> u32 {\n     return 'label: loop { break 'label 42; };\n }\n \n fn bar() -> u32 {\n     loop { break 'label: loop { break 'label 42; }; }\n-    //~^ ERROR expected identifier, found keyword `loop`\n-    //~| ERROR expected type, found keyword `loop`\n+    //~^ ERROR: parentheses are required around this expression to avoid confusion\n+    //~| HELP: wrap the expression in parentheses\n+}\n+\n+fn baz() -> u32 {\n+    'label: loop {\n+        break 'label\n+        //~^ WARNING: this labeled break expression is easy to confuse with an unlabeled break\n+            loop { break 42; };\n+            //~^ HELP: wrap this expression in parentheses\n+    };\n+\n+    'label2: loop {\n+        break 'label2 'inner: loop { break 42; };\n+        // no warnings or errors here\n+    }\n }\n \n pub fn main() {\n-    foo();\n+    // Regression test for issue #86948, as resolved in #87026:\n+    let a = 'first_loop: loop {\n+        break 'first_loop 1;\n+    };\n+    let b = loop {\n+        break 'inner_loop: loop {\n+        //~^ ERROR: parentheses are required around this expression to avoid confusion\n+        //~| HELP: wrap the expression in parentheses\n+            break 'inner_loop 1;\n+        };\n+    };\n }"}, {"sha": "6f3320e283cdbb2a39207c546610459de036c977", "filename": "src/test/ui/parser/lifetime_starts_expressions.stderr", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/49ca3d9796030fc0a85089460e9f825ceecc08ed/src%2Ftest%2Fui%2Fparser%2Flifetime_starts_expressions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49ca3d9796030fc0a85089460e9f825ceecc08ed/src%2Ftest%2Fui%2Fparser%2Flifetime_starts_expressions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flifetime_starts_expressions.stderr?ref=49ca3d9796030fc0a85089460e9f825ceecc08ed", "patch": "@@ -1,23 +1,47 @@\n-error: expected identifier, found keyword `loop`\n-  --> $DIR/lifetime_starts_expressions.rs:6:26\n+error: parentheses are required around this expression to avoid confusion with a labeled break expression\n+  --> $DIR/lifetime_starts_expressions.rs:8:18\n    |\n LL |     loop { break 'label: loop { break 'label 42; }; }\n-   |                          ^^^^ expected identifier, found keyword\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: you can escape reserved keywords to use them as identifiers\n+help: wrap the expression in parentheses\n    |\n-LL |     loop { break 'label: r#loop { break 'label 42; }; }\n-   |                          ^^^^^^\n+LL |     loop { break ('label: loop { break 'label 42; }); }\n+   |                  ^                                 ^\n \n-error: expected type, found keyword `loop`\n-  --> $DIR/lifetime_starts_expressions.rs:6:26\n+error: parentheses are required around this expression to avoid confusion with a labeled break expression\n+  --> $DIR/lifetime_starts_expressions.rs:33:15\n    |\n-LL |     loop { break 'label: loop { break 'label 42; }; }\n-   |                        - ^^^^ expected type\n-   |                        |\n-   |                        help: maybe write a path separator here: `::`\n+LL |           break 'inner_loop: loop {\n+   |  _______________^\n+LL | |\n+LL | |\n+LL | |             break 'inner_loop 1;\n+LL | |         };\n+   | |_________^\n+   |\n+help: wrap the expression in parentheses\n+   |\n+LL |         break ('inner_loop: loop {\n+LL |\n+LL |\n+LL |             break 'inner_loop 1;\n+LL |         });\n+   |\n+\n+warning: this labeled break expression is easy to confuse with an unlabeled break with a labeled value expression\n+  --> $DIR/lifetime_starts_expressions.rs:15:9\n+   |\n+LL | /         break 'label\n+LL | |\n+LL | |             loop { break 42; };\n+   | |______________________________^\n+   |\n+   = note: `#[warn(break_with_label_and_loop)]` on by default\n+help: wrap this expression in parentheses\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+LL |             (loop { break 42; });\n+   |             ^                  ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 2 previous errors; 1 warning emitted\n "}]}