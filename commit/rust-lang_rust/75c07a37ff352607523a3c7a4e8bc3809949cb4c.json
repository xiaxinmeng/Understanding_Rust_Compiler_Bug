{"sha": "75c07a37ff352607523a3c7a4e8bc3809949cb4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YzA3YTM3ZmYzNTI2MDc1MjNhM2M3YTRlOGJjMzgwOTk0OWNiNGM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-12-17T04:17:27Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-12-18T09:59:10Z"}, "message": "Add memchr search support for multibyte characters", "tree": {"sha": "966744e30a5e4ddcc3151373e9eb217fc71df4c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/966744e30a5e4ddcc3151373e9eb217fc71df4c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75c07a37ff352607523a3c7a4e8bc3809949cb4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75c07a37ff352607523a3c7a4e8bc3809949cb4c", "html_url": "https://github.com/rust-lang/rust/commit/75c07a37ff352607523a3c7a4e8bc3809949cb4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75c07a37ff352607523a3c7a4e8bc3809949cb4c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f865164030ccd167a9e9f9fae665373fb58295fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f865164030ccd167a9e9f9fae665373fb58295fb", "html_url": "https://github.com/rust-lang/rust/commit/f865164030ccd167a9e9f9fae665373fb58295fb"}], "stats": {"total": 150, "additions": 102, "deletions": 48}, "files": [{"sha": "e44799bb9c5ab5c56a6126c03ea28422b6ad0228", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 102, "deletions": 48, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/75c07a37ff352607523a3c7a4e8bc3809949cb4c/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75c07a37ff352607523a3c7a4e8bc3809949cb4c/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=75c07a37ff352607523a3c7a4e8bc3809949cb4c", "patch": "@@ -252,13 +252,28 @@ pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n #[derive(Clone, Debug)]\n pub struct CharSearcher<'a> {\n     haystack: &'a str,\n-    // invariant: `finger`/`finger_back` must be a valid utf8 byte index of `haystack`\n+    // safety invariant: `finger`/`finger_back` must be a valid utf8 byte index of `haystack`\n+    // This invariant can be broken *within* next_match and next_match_back, however\n+    // they must exit with fingers on valid code point boundaries.\n+\n+    /// `finger` is the current byte index of the forward search.\n+    /// Imagine that it exists before the byte at its index, i.e.\n+    /// haystack[finger] is the first byte of the slice we must inspect during\n+    /// forward searching\n     finger: usize,\n+    /// `finger_back` is the current byte index of the reverse search.\n+    /// Imagine that it exists after the byte at its index, i.e.\n+    /// haystack[finger_back - 1] is the last byte of the slice we must inspect during\n+    /// forward searching (and thus the first byte to be inspected when calling next_back())\n     finger_back: usize,\n+    /// The character being searched for\n     needle: char,\n-    // For ascii chars\n-    // invariant: must be an ASCII byte (no high bit)\n-    single_byte: Option<u8>,\n+\n+    // safety invariant: `utf8_size` must be less than 5\n+    /// The number of bytes `needle` takes up when encoded in utf8\n+    utf8_size: usize,\n+    /// A utf8 encoded copy of the `needle`\n+    utf8_encoded: [u8; 4],\n }\n \n unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n@@ -269,12 +284,12 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next(&mut self) -> SearchStep {\n         let old_finger = self.finger;\n-        let slice = unsafe { self.haystack.get_unchecked(old_finger..) };\n+        let slice = unsafe { self.haystack.get_unchecked(old_finger..self.haystack.len()) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n         if let Some(ch) = iter.next() {\n             // add byte offset of current character\n-            // without recalculating\n+            // without re-encoding as utf-8\n             self.finger += old_len - iter.iter.len();\n             if ch == self.needle {\n                 SearchStep::Match(old_finger, self.finger)\n@@ -287,25 +302,44 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n     }\n     #[inline]\n     fn next_match(&mut self) -> Option<(usize, usize)> {\n-        if let Some(byte) = self.single_byte {\n-            let old_finger = self.finger;\n-            let slice = unsafe { self.haystack.get_unchecked(old_finger..) };\n-            let bytes = slice.as_bytes();\n-            if let Some(index) = memchr::memchr(byte, bytes) {\n-                // index is the index of a valid ASCII byte,\n-                // so we can add one to it\n-                self.finger += index + 1;\n-                Some((self.finger - 1, self.finger))\n+        loop {\n+            // get the haystack after the last character found\n+            let bytes = if let Some(slice) = self.haystack.as_bytes().get(self.finger..) {\n+                slice\n             } else {\n-                None\n-            }\n-        } else {\n-            loop {\n-                match self.next() {\n-                    SearchStep::Match(a, b) => break Some((a, b)),\n-                    SearchStep::Done => break None,\n-                    _ => continue,\n+                return None;\n+            };\n+            // the last byte of the utf8 encoded needle\n+            let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n+            if let Some(index) = memchr::memchr(last_byte, bytes) {\n+                // The new finger is the index of the byte we found,\n+                // plus one, since we memchr'd for the last byte of the character.\n+                //\n+                // Note that this doesn't always give us a finger on a UTF8 boundary.\n+                // If we *didn't* find our character\n+                // we may have indexed to the non-last byte of a 3-byte or 4-byte character.\n+                // We can't just skip to the next valid starting byte because a character like\n+                // \ua041 (U+A041 YI SYLLABLE PA), utf-8 `EA 81 81` will have us always find\n+                // the second byte when searching for the third.\n+                //\n+                // However, this is totally okay. While we have the invariant that\n+                // self.finger is on a UTF8 boundary, this invariant is not relid upon\n+                // within this method (it is relied upon in CharSearcher::next()).\n+                //\n+                // We only exit this method when we reach the end of the string, or if we\n+                // find something. When we find something the `finger` will be set\n+                // to a UTF8 boundary.\n+                self.finger += index + 1;\n+                let found_char = self.finger - self.utf8_size;\n+                if let Some(slice) = self.haystack.as_bytes().get(found_char..self.finger) {\n+                    if slice == &self.utf8_encoded[0..self.utf8_size] {\n+                        return Some((found_char, self.finger));\n+                    }\n                 }\n+            } else {\n+                // found nothing, exit\n+                self.finger = self.haystack.len();\n+                return None;\n             }\n         }\n     }\n@@ -322,7 +356,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n         let old_len = iter.iter.len();\n         if let Some(ch) = iter.next_back() {\n             // subtract byte offset of current character\n-            // without recalculating\n+            // without re-encoding as utf-8\n             self.finger_back -= old_len - iter.iter.len();\n             if ch == self.needle {\n                 SearchStep::Match(self.finger_back, old_finger)\n@@ -335,24 +369,47 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n     }\n     #[inline]\n     fn next_match_back(&mut self) -> Option<(usize, usize)> {\n-        if let Some(byte) = self.single_byte {\n-            let old_finger = self.finger_back;\n-            let slice = unsafe { self.haystack.slice_unchecked(0, old_finger) };\n-            let bytes = slice.as_bytes();\n-            if let Some(index) = memchr::memrchr(byte, bytes) {\n-                // index is the index of a valid ASCII byte\n-                self.finger_back = index;\n-                Some((self.finger_back, self.finger_back + 1))\n+        let haystack = self.haystack.as_bytes();\n+        loop {\n+            // get the haystack up to but not including the last character searched\n+            let bytes = if let Some(slice) = haystack.get(..self.finger_back) {\n+                slice\n             } else {\n-                None\n-            }\n-        } else {\n-            loop {\n-                match self.next_back() {\n-                    SearchStep::Match(a, b) => break Some((a, b)),\n-                    SearchStep::Done => break None,\n-                    _ => continue,\n+                return None;\n+            };\n+            // the last byte of the utf8 encoded needle\n+            let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n+            if let Some(index) = memchr::memrchr(last_byte, bytes) {\n+                // memrchr will return the index of the byte we wish to\n+                // find. In case of an ASCII character, this is indeed\n+                // were we wish our new finger to be (\"after\" the found\n+                // char in the paradigm of reverse iteration). For\n+                // multibyte chars we need to skip down by the number of more\n+                // bytes they have than ASCII\n+                let found_char = index - (self.utf8_size - 1);\n+                if let Some(slice) = haystack.get(found_char..(found_char + self.utf8_size)) {\n+                    if slice == &self.utf8_encoded[0..self.utf8_size] {\n+                        // move finger to before the character found (i.e. at its start index)\n+                        self.finger_back = found_char;\n+                        return Some((self.finger_back, self.finger_back + self.utf8_size));\n+                    }\n                 }\n+                // We can't use finger_back = index - size + 1 here. If we found the last char\n+                // of a different-sized character (or the middle byte of a different character)\n+                // we need to bump the finger_back down to `index`. This similarly makes\n+                // `finger_back` have the potential to no longer be on a boundary,\n+                // but this is OK since we only exit this function on a boundary\n+                // or when the haystack has been searched completely.\n+                //\n+                // Unlike next_match this does not\n+                // have the problem of repeated bytes in utf-8 because\n+                // we're searching for the last byte, and we can only have\n+                // found the last byte when searching in reverse.\n+                self.finger_back = index;\n+            } else {\n+                self.finger_back = 0;\n+                // found nothing, exit\n+                return None;\n             }\n         }\n     }\n@@ -368,19 +425,16 @@ impl<'a> Pattern<'a> for char {\n \n     #[inline]\n     fn into_searcher(self, haystack: &'a str) -> Self::Searcher {\n-        let single_byte = if self.len_utf8() == 1 {\n-            let mut storage = [0];\n-            self.encode_utf8(&mut storage);\n-            Some(storage[0])\n-        } else {\n-            None\n-        };\n+        let mut utf8_encoded = [0; 4];\n+        self.encode_utf8(&mut utf8_encoded);\n+        let utf8_size = self.len_utf8();\n         CharSearcher {\n             haystack,\n             finger: 0,\n             finger_back: haystack.len(),\n             needle: self,\n-            single_byte,\n+            utf8_size,\n+            utf8_encoded\n         }\n     }\n "}]}