{"sha": "81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "node_id": "C_kwDOAAsO6NoAKDgxZjM4NDFjZmI1ZWFlNTJkNzkxNGRmZWJiNmE1NWI1OTUxYzVjM2M", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-30T05:56:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-30T05:56:51Z"}, "message": "Rollup merge of #101101 - RalfJung:read-pointer-as-bytes, r=oli-obk\n\ninterpret: make read-pointer-as-bytes a CTFE-only error with extra information\n\nNext step in the reaction to https://github.com/rust-lang/rust/issues/99923. Also teaches Miri to implicitly strip provenance in more situations when transmuting pointers to integers, which fixes https://github.com/rust-lang/miri/issues/2456.\n\nPointer-to-int transmutation during CTFE now produces a message like this:\n```\n   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n```\n\nr? ``@oli-obk``", "tree": {"sha": "8f53022e4f14533603ae07b48c3d9b0ce2eaf6c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f53022e4f14533603ae07b48c3d9b0ce2eaf6c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDaajCRBK7hj4Ov3rIwAASo0IAC/c8uT5kopEAK1TQkf8/Hw4\nXG9kwmnkwuEW/N8ycGHFYqLmXVxFXc4M9Gjz0eQdu6rTvTYvDAYCQS1Wf/XR8GmF\nvVzlRSd2hUIM6zhMgIBH1LYjU0lyHAIRGiv5FUyuv+HzmqBZAALg7zhCZKkoOB9Z\nUdpsIRb9ljQqb0yyMIAuKMqYqkk5rj8PDm2VGjSer7/cqgJlGWa+fRCFhuqbUcTe\nTvx1+GM9DCs6dfdR5avO/+QUC9KdZsLg8efmkTvgenap3iPOy9a5DNtvXSgMuxQ9\nKpJOEBi7tNZLYnvhe2H19tcRWM0QspGzjDUflPeDHXKIF4fRdAcMaHpTAsjFK5c=\n=JGGv\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f53022e4f14533603ae07b48c3d9b0ce2eaf6c7\nparent 1ea84961e81de8e0eebbb8353d7867a039ffa70f\nparent c46e803aaf5a0bfc5dfcd1570349eee71ce81634\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661839011 +0530\ncommitter GitHub <noreply@github.com> 1661839011 +0530\n\nRollup merge of #101101 - RalfJung:read-pointer-as-bytes, r=oli-obk\n\ninterpret: make read-pointer-as-bytes a CTFE-only error with extra information\n\nNext step in the reaction to https://github.com/rust-lang/rust/issues/99923. Also teaches Miri to implicitly strip provenance in more situations when transmuting pointers to integers, which fixes https://github.com/rust-lang/miri/issues/2456.\n\nPointer-to-int transmutation during CTFE now produces a message like this:\n```\n   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n```\n\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "html_url": "https://github.com/rust-lang/rust/commit/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ea84961e81de8e0eebbb8353d7867a039ffa70f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea84961e81de8e0eebbb8353d7867a039ffa70f", "html_url": "https://github.com/rust-lang/rust/commit/1ea84961e81de8e0eebbb8353d7867a039ffa70f"}, {"sha": "c46e803aaf5a0bfc5dfcd1570349eee71ce81634", "url": "https://api.github.com/repos/rust-lang/rust/commits/c46e803aaf5a0bfc5dfcd1570349eee71ce81634", "html_url": "https://github.com/rust-lang/rust/commit/c46e803aaf5a0bfc5dfcd1570349eee71ce81634"}], "stats": {"total": 963, "additions": 629, "deletions": 334}, "files": [{"sha": "cb5d73a7e0ba9bd277c6318a70da19d284360bb4", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -430,7 +430,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n         let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n-        for &(offset, alloc_id) in alloc.relocations().iter() {\n+        for &(offset, alloc_id) in alloc.provenance().iter() {\n             let addend = {\n                 let endianness = tcx.data_layout.endian;\n                 let offset = offset.bytes() as usize;"}, {"sha": "1f358b1bbb96edb89a2893cf9bc526f6dbcc79b9", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -186,7 +186,10 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                         let size = Size::from_bytes(\n                             4 * ret_lane_count, /* size_of([u32; ret_lane_count]) */\n                         );\n-                        alloc.inner().get_bytes(fx, alloc_range(offset, size)).unwrap()\n+                        alloc\n+                            .inner()\n+                            .get_bytes_strip_provenance(fx, alloc_range(offset, size))\n+                            .unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", idx_const),\n                 };"}, {"sha": "356c03ee3c189cadeacc111f37403d29911ba704", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -127,7 +127,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n             //\n             // We could remove this hack whenever we decide to drop macOS 10.10 support.\n             if self.tcx.sess.target.options.is_like_osx {\n-                // The `inspect` method is okay here because we checked relocations, and\n+                // The `inspect` method is okay here because we checked for provenance, and\n                 // because we are doing this access to inspect the final interpreter state\n                 // (not as part of the interpreter execution).\n                 //\n@@ -296,17 +296,17 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAllocation<'tcx>) -> RValue<'gcc> {\n     let alloc = alloc.inner();\n-    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.provenance().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for &(offset, alloc_id) in alloc.relocations().iter() {\n+    for &(offset, alloc_id) in alloc.provenance().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // This `inspect` is okay since we have checked that it is not within a pointer with provenance, it\n             // is within the bounds of the allocation, and it doesn't affect interpreter execution\n             // (we inspect the result after interpreter execution). Any undef byte is replaced with\n             // some arbitrary byte value.\n@@ -319,7 +319,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n             read_target_uint( dl.endian,\n                 // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n                 // affect interpreter execution (we inspect the result after interpreter execution),\n-                // and we properly interpret the relocation as a relocation pointer offset.\n+                // and we properly interpret the provenance as a relocation pointer offset.\n                 alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n             )\n             .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n@@ -336,7 +336,7 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n     }\n     if alloc.len() >= next_offset {\n         let range = next_offset..alloc.len();\n-        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // This `inspect` is okay since we have check that it is after all provenance, it is\n         // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n         // inspect the result after interpreter execution). Any undef byte is replaced with some\n         // arbitrary byte value."}, {"sha": "d3e33da27993c6b3286765128fd0b7ca6ce04952", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -27,12 +27,12 @@ use tracing::debug;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n     let alloc = alloc.inner();\n-    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n+    let mut llvals = Vec::with_capacity(alloc.provenance().len() + 1);\n     let dl = cx.data_layout();\n     let pointer_size = dl.pointer_size.bytes() as usize;\n \n-    // Note: this function may call `inspect_with_uninit_and_ptr_outside_interpreter`,\n-    // so `range` must be within the bounds of `alloc` and not contain or overlap a relocation.\n+    // Note: this function may call `inspect_with_uninit_and_ptr_outside_interpreter`, so `range`\n+    // must be within the bounds of `alloc` and not contain or overlap a pointer provenance.\n     fn append_chunks_of_init_and_uninit_bytes<'ll, 'a, 'b>(\n         llvals: &mut Vec<&'ll Value>,\n         cx: &'a CodegenCx<'ll, 'b>,\n@@ -79,12 +79,12 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n     }\n \n     let mut next_offset = 0;\n-    for &(offset, alloc_id) in alloc.relocations().iter() {\n+    for &(offset, alloc_id) in alloc.provenance().iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // This `inspect` is okay since we have checked that there is no provenance, it\n             // is within the bounds of the allocation, and it doesn't affect interpreter execution\n             // (we inspect the result after interpreter execution).\n             append_chunks_of_init_and_uninit_bytes(&mut llvals, cx, alloc, next_offset..offset);\n@@ -93,7 +93,7 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n             dl.endian,\n             // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n             // affect interpreter execution (we inspect the result after interpreter execution),\n-            // and we properly interpret the relocation as a relocation pointer offset.\n+            // and we properly interpret the provenance as a relocation pointer offset.\n             alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n         )\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n@@ -121,7 +121,7 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n     }\n     if alloc.len() >= next_offset {\n         let range = next_offset..alloc.len();\n-        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // This `inspect` is okay since we have check that it is after all provenance, it is\n         // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n         // inspect the result after interpreter execution).\n         append_chunks_of_init_and_uninit_bytes(&mut llvals, cx, alloc, range);\n@@ -479,15 +479,15 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n                 if self.tcx.sess.target.is_like_osx {\n-                    // The `inspect` method is okay here because we checked relocations, and\n+                    // The `inspect` method is okay here because we checked for provenance, and\n                     // because we are doing this access to inspect the final interpreter state\n                     // (not as part of the interpreter execution).\n                     //\n                     // FIXME: This check requires that the (arbitrary) value of undefined bytes\n                     // happens to be zero. Instead, we should only check the value of defined bytes\n                     // and set all undefined bytes to zero if this allocation is headed for the\n                     // BSS.\n-                    let all_bytes_are_zero = alloc.relocations().is_empty()\n+                    let all_bytes_are_zero = alloc.provenance().is_empty()\n                         && alloc\n                             .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n@@ -511,9 +511,9 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                         section.as_str().as_ptr().cast(),\n                         section.as_str().len() as c_uint,\n                     );\n-                    assert!(alloc.relocations().is_empty());\n+                    assert!(alloc.provenance().is_empty());\n \n-                    // The `inspect` method is okay here because we checked relocations, and\n+                    // The `inspect` method is okay here because we checked for provenance, and\n                     // because we are doing this access to inspect the final interpreter state (not\n                     // as part of the interpreter execution).\n                     let bytes ="}, {"sha": "09d53331b5b269310fc29249887f64f2e28de83d", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -10,6 +10,7 @@ use rustc_span::{Span, Symbol};\n use super::InterpCx;\n use crate::interpret::{\n     struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine, MachineStopType,\n+    UnsupportedOpInfo,\n };\n \n /// The CTFE machine has some custom error kinds.\n@@ -149,6 +150,18 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             if let Some(span_msg) = span_msg {\n                 err.span_label(self.span, span_msg);\n             }\n+            // Add some more context for select error types.\n+            match self.error {\n+                InterpError::Unsupported(\n+                    UnsupportedOpInfo::ReadPointerAsBytes\n+                    | UnsupportedOpInfo::PartialPointerOverwrite(_)\n+                    | UnsupportedOpInfo::PartialPointerCopy(_),\n+                ) => {\n+                    err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n+                    err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n+                }\n+                _ => {}\n+            }\n             // Add spans for the stacktrace. Don't print a single-line backtrace though.\n             if self.stacktrace.len() > 1 {\n                 // Helper closure to print duplicated lines."}, {"sha": "b46f71fc78a3b9164919ce9c3e2097e7764875d9", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -2,8 +2,8 @@ use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n-    Immediate, InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking,\n-    StackPopCleanup,\n+    Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n+    RefTracking, StackPopCleanup,\n };\n \n use rustc_hir::def::DefKind;\n@@ -387,7 +387,9 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                     ecx.tcx,\n                     \"it is undefined behavior to use this value\",\n                     |diag| {\n-                        diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n+                        if matches!(err.error, InterpError::UndefinedBehavior(_)) {\n+                            diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n+                        }\n                         diag.note(&format!(\n                             \"the raw bytes of the constant ({}\",\n                             display_allocation("}, {"sha": "66ab3f15716f2e5d7eb93782df478f32bf5f50e2", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -134,7 +134,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n-    leftover_allocations.extend(alloc.relocations().iter().map(|&(_, alloc_id)| alloc_id));\n+    leftover_allocations.extend(alloc.provenance().iter().map(|&(_, alloc_id)| alloc_id));\n     let alloc = tcx.intern_const_alloc(alloc);\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n     None\n@@ -191,10 +191,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n                     return Ok(true);\n                 };\n \n-                // If there are no relocations in this allocation, it does not contain references\n+                // If there is no provenance in this allocation, it does not contain references\n                 // that point to another allocation, and we can avoid the interning walk.\n                 if let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, align)? {\n-                    if !alloc.has_relocations() {\n+                    if !alloc.has_provenance() {\n                         return Ok(false);\n                     }\n                 } else {\n@@ -233,8 +233,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n     }\n \n     fn visit_value(&mut self, mplace: &MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n-        // Handle Reference types, as these are the only relocations supported by const eval.\n-        // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n+        // Handle Reference types, as these are the only types with provenance supported by const eval.\n+        // Raw pointers (and boxes) are handled by the `leftover_allocations` logic.\n         let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, ref_mutability) = *ty.kind() {\n@@ -410,7 +410,7 @@ pub fn intern_const_alloc_recursive<\n             // references and a `leftover_allocations` set (where we only have a todo-list here).\n             // So we hand-roll the interning logic here again.\n             match intern_kind {\n-                // Statics may contain mutable allocations even behind relocations.\n+                // Statics may point to mutable allocations.\n                 // Even for immutable statics it would be ok to have mutable allocations behind\n                 // raw pointers, e.g. for `static FOO: *const AtomicUsize = &AtomicUsize::new(42)`.\n                 InternKind::Static(_) => {}\n@@ -441,7 +441,7 @@ pub fn intern_const_alloc_recursive<\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.set_alloc_id_memory(alloc_id, alloc);\n-            for &(_, alloc_id) in alloc.inner().relocations().iter() {\n+            for &(_, alloc_id) in alloc.inner().provenance().iter() {\n                 if leftover_allocations.insert(alloc_id) {\n                     todo.push(alloc_id);\n                 }"}, {"sha": "a8ec8447f64a4d1206fdf16aead8229ad09c38dd", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -687,10 +687,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n         assert!(!layout.is_unsized());\n \n-        let lhs = self.read_pointer(lhs)?;\n-        let rhs = self.read_pointer(rhs)?;\n-        let lhs_bytes = self.read_bytes_ptr(lhs, layout.size)?;\n-        let rhs_bytes = self.read_bytes_ptr(rhs, layout.size)?;\n+        let get_bytes = |this: &InterpCx<'mir, 'tcx, M>,\n+                         op: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+                         size|\n+         -> InterpResult<'tcx, &[u8]> {\n+            let ptr = this.read_pointer(op)?;\n+            let Some(alloc_ref) = self.get_ptr_alloc(ptr, size, Align::ONE)? else {\n+                // zero-sized access\n+                return Ok(&[]);\n+            };\n+            if alloc_ref.has_provenance() {\n+                throw_ub_format!(\"`raw_eq` on bytes with provenance\");\n+            }\n+            alloc_ref.get_bytes_strip_provenance()\n+        };\n+\n+        let lhs_bytes = get_bytes(self, lhs, layout.size)?;\n+        let rhs_bytes = get_bytes(self, rhs, layout.size)?;\n         Ok(Scalar::from_bool(lhs_bytes == rhs_bytes))\n     }\n }"}, {"sha": "5aabb14fba88454bc55bbf7c824e52d5a456a95a", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -315,7 +315,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n     ///\n-    /// This must only fail if `alloc` contains relocations.\n+    /// This must only fail if `alloc` contains provenance.\n     fn adjust_allocation<'b>(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         id: AllocId,"}, {"sha": "69dbc9592fa87a73bd11b0a4e38805260e30c8df", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -214,7 +214,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.allocate_raw_ptr(alloc, kind).unwrap()\n     }\n \n-    /// This can fail only of `alloc` contains relocations.\n+    /// This can fail only of `alloc` contains provenance.\n     pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n@@ -794,10 +794,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             todo.extend(static_roots);\n             while let Some(id) = todo.pop() {\n                 if reachable.insert(id) {\n-                    // This is a new allocation, add its relocations to `todo`.\n+                    // This is a new allocation, add the allocation it points to to `todo`.\n                     if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n                         todo.extend(\n-                            alloc.relocations().values().filter_map(|prov| prov.get_alloc_id()),\n+                            alloc.provenance().values().filter_map(|prov| prov.get_alloc_id()),\n                         );\n                     }\n                 }\n@@ -833,7 +833,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n             allocs_to_print: &mut VecDeque<AllocId>,\n             alloc: &Allocation<Prov, Extra>,\n         ) -> std::fmt::Result {\n-            for alloc_id in alloc.relocations().values().filter_map(|prov| prov.get_alloc_id()) {\n+            for alloc_id in alloc.provenance().values().filter_map(|prov| prov.get_alloc_id()) {\n                 allocs_to_print.push_back(alloc_id);\n             }\n             write!(fmt, \"{}\", display_allocation(tcx, alloc))\n@@ -953,24 +953,25 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n     }\n \n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn check_bytes(&self, range: AllocRange) -> InterpResult<'tcx> {\n+    pub fn get_bytes_strip_provenance<'b>(&'b self) -> InterpResult<'tcx, &'a [u8]> {\n         Ok(self\n             .alloc\n-            .check_bytes(&self.tcx, self.range.subrange(range))\n+            .get_bytes_strip_provenance(&self.tcx, self.range)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n \n-    /// Returns whether the allocation has relocations for the entire range of the `AllocRef`.\n-    pub(crate) fn has_relocations(&self) -> bool {\n-        self.alloc.has_relocations(&self.tcx, self.range)\n+    /// Returns whether the allocation has provenance anywhere in the range of the `AllocRef`.\n+    pub(crate) fn has_provenance(&self) -> bool {\n+        self.alloc.range_has_provenance(&self.tcx, self.range)\n     }\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// Reads the given number of bytes from memory. Returns them as a slice.\n+    /// Reads the given number of bytes from memory, and strips their provenance if possible.\n+    /// Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn read_bytes_ptr(\n+    pub fn read_bytes_ptr_strip_provenance(\n         &self,\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n@@ -983,7 +984,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // (We are staying inside the bounds here so all is good.)\n         Ok(alloc_ref\n             .alloc\n-            .get_bytes(&alloc_ref.tcx, alloc_ref.range)\n+            .get_bytes_strip_provenance(&alloc_ref.tcx, alloc_ref.range)\n             .map_err(|e| e.to_interp_error(alloc_ref.alloc_id))?)\n     }\n \n@@ -1078,17 +1079,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         };\n \n-        // This checks relocation edges on the src, which needs to happen before\n-        // `prepare_relocation_copy`.\n-        let src_bytes = src_alloc\n-            .get_bytes_with_uninit_and_ptr(&tcx, src_range)\n-            .map_err(|e| e.to_interp_error(src_alloc_id))?\n-            .as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n-        // first copy the relocations to a temporary buffer, because\n-        // `get_bytes_mut` will clear the relocations, which is correct,\n-        // since we don't want to keep any relocations at the target.\n-        let relocations =\n-            src_alloc.prepare_relocation_copy(self, src_range, dest_offset, num_copies);\n+        // Checks provenance edges on the src, which needs to happen before\n+        // `prepare_provenance_copy`.\n+        if src_alloc.range_has_provenance(&tcx, alloc_range(src_range.start, Size::ZERO)) {\n+            throw_unsup!(PartialPointerCopy(Pointer::new(src_alloc_id, src_range.start)));\n+        }\n+        if src_alloc.range_has_provenance(&tcx, alloc_range(src_range.end(), Size::ZERO)) {\n+            throw_unsup!(PartialPointerCopy(Pointer::new(src_alloc_id, src_range.end())));\n+        }\n+        let src_bytes = src_alloc.get_bytes_unchecked(src_range).as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n+        // first copy the provenance to a temporary buffer, because\n+        // `get_bytes_mut` will clear the provenance, which is correct,\n+        // since we don't want to keep any provenance at the target.\n+        let provenance =\n+            src_alloc.prepare_provenance_copy(self, src_range, dest_offset, num_copies);\n         // Prepare a copy of the initialization mask.\n         let compressed = src_alloc.compress_uninit_range(src_range);\n \n@@ -1117,7 +1121,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             dest_alloc\n                 .write_uninit(&tcx, dest_range)\n                 .map_err(|e| e.to_interp_error(dest_alloc_id))?;\n-            // We can forget about the relocations, this is all not initialized anyway.\n+            // We can forget about the provenance, this is all not initialized anyway.\n             return Ok(());\n         }\n \n@@ -1161,8 +1165,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             alloc_range(dest_offset, size), // just a single copy (i.e., not full `dest_range`)\n             num_copies,\n         );\n-        // copy the relocations to the destination\n-        dest_alloc.mark_relocation_range(relocations);\n+        // copy the provenance to the destination\n+        dest_alloc.mark_provenance_range(provenance);\n \n         Ok(())\n     }"}, {"sha": "35c2cf8102dc571269645cc1537433a415339063", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -415,7 +415,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.read_bytes_ptr(mplace.ptr, Size::from_bytes(len))?;\n+        let bytes = self.read_bytes_ptr_strip_provenance(mplace.ptr, Size::from_bytes(len))?;\n         let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }"}, {"sha": "a03b0dfb6038b737739098c77213a4433caab1e5", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -2,8 +2,6 @@\n //! into a place.\n //! All high-level functions to write to memory work on places as destinations.\n \n-use std::hash::Hash;\n-\n use rustc_ast::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty;\n@@ -290,7 +288,7 @@ impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n impl<'mir, 'tcx: 'mir, Prov, M> InterpCx<'mir, 'tcx, M>\n where\n-    Prov: Provenance + Eq + Hash + 'static,\n+    Prov: Provenance + 'static,\n     M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place."}, {"sha": "67dc9011ea209ace27078a8460ecc627feb1091b", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -7,8 +7,6 @@\n //! but we still need to do bounds checking and adjust the layout. To not duplicate that with MPlaceTy, we actually\n //! implement the logic on OpTy, and MPlaceTy calls that.\n \n-use std::hash::Hash;\n-\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::LayoutOf;\n@@ -22,7 +20,7 @@ use super::{\n // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n impl<'mir, 'tcx: 'mir, Prov, M> InterpCx<'mir, 'tcx, M>\n where\n-    Prov: Provenance + Eq + Hash + 'static,\n+    Prov: Provenance + 'static,\n     M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     //# Field access"}, {"sha": "0382e2d5805aacb10148c56487e9694aa609a0bc", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -20,9 +20,11 @@ use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, Wr\n \n use std::hash::Hash;\n \n+// for the validation errors\n+use super::UndefinedBehaviorInfo::*;\n use super::{\n-    alloc_range, CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy,\n-    Machine, MemPlaceMeta, OpTy, Scalar, ValueVisitor,\n+    CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine,\n+    MemPlaceMeta, OpTy, Scalar, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -60,6 +62,7 @@ macro_rules! throw_validation_failure {\n /// });\n /// ```\n ///\n+/// The patterns must be of type `UndefinedBehaviorInfo`.\n /// An additional expected parameter can also be added to the failure message:\n ///\n /// ```\n@@ -87,7 +90,7 @@ macro_rules! try_validation {\n             // allocation here as this can only slow down builds that fail anyway.\n             Err(e) => match e.kind() {\n                 $(\n-                    $($p)|+ =>\n+                    InterpError::UndefinedBehavior($($p)|+) =>\n                        throw_validation_failure!(\n                             $where,\n                             { $( $what_fmt ),+ } $( expected { $( $expected_fmt ),+ } )?\n@@ -313,8 +316,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         Ok(try_validation!(\n             self.ecx.read_immediate(op),\n             self.path,\n-            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"{expected}\" },\n-            err_ub!(InvalidUninitBytes(None)) => { \"uninitialized memory\" } expected { \"{expected}\" }\n+            InvalidUninitBytes(None) => { \"uninitialized memory\" } expected { \"{expected}\" }\n         ))\n     }\n \n@@ -339,18 +341,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let (_ty, _trait) = try_validation!(\n                     self.ecx.get_ptr_vtable(vtable),\n                     self.path,\n-                    err_ub!(DanglingIntPointer(..)) |\n-                    err_ub!(InvalidVTablePointer(..)) =>\n+                    DanglingIntPointer(..) |\n+                    InvalidVTablePointer(..) =>\n                         { \"{vtable}\" } expected { \"a vtable pointer\" },\n                 );\n                 // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n             ty::Slice(..) | ty::Str => {\n-                let _len = try_validation!(\n-                    meta.unwrap_meta().to_machine_usize(self.ecx),\n-                    self.path,\n-                    err_unsup!(ReadPointerAsBytes) => { \"non-integer slice length in wide pointer\" },\n-                );\n+                let _len = meta.unwrap_meta().to_machine_usize(self.ecx)?;\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n                 // \"dereferenceable\" check performed by Stacked Borrows.\n@@ -380,7 +378,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let size_and_align = try_validation!(\n             self.ecx.size_and_align_of_mplace(&place),\n             self.path,\n-            err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n+            InvalidMeta(msg) => { \"invalid {} metadata: {}\", kind, msg },\n         );\n         let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n@@ -396,21 +394,21 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 CheckInAllocMsg::InboundsTest, // will anyway be replaced by validity message\n             ),\n             self.path,\n-            err_ub!(AlignmentCheckFailed { required, has }) =>\n+            AlignmentCheckFailed { required, has } =>\n                 {\n                     \"an unaligned {kind} (required {} byte alignment but found {})\",\n                     required.bytes(),\n                     has.bytes()\n                 },\n-            err_ub!(DanglingIntPointer(0, _)) =>\n+            DanglingIntPointer(0, _) =>\n                 { \"a null {kind}\" },\n-            err_ub!(DanglingIntPointer(i, _)) =>\n+            DanglingIntPointer(i, _) =>\n                 { \"a dangling {kind} (address {i:#x} is unallocated)\" },\n-            err_ub!(PointerOutOfBounds { .. }) =>\n+            PointerOutOfBounds { .. } =>\n                 { \"a dangling {kind} (going beyond the bounds of its allocation)\" },\n             // This cannot happen during const-eval (because interning already detects\n             // dangling pointers), but it can happen in Miri.\n-            err_ub!(PointerUseAfterFree(..)) =>\n+            PointerUseAfterFree(..) =>\n                 { \"a dangling {kind} (use-after-free)\" },\n         );\n         // Do not allow pointers to uninhabited types.\n@@ -498,7 +496,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 try_validation!(\n                     value.to_bool(),\n                     self.path,\n-                    err_ub!(InvalidBool(..)) =>\n+                    InvalidBool(..) =>\n                         { \"{:x}\", value } expected { \"a boolean\" },\n                 );\n                 Ok(true)\n@@ -508,7 +506,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 try_validation!(\n                     value.to_char(),\n                     self.path,\n-                    err_ub!(InvalidChar(..)) =>\n+                    InvalidChar(..) =>\n                         { \"{:x}\", value } expected { \"a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\" },\n                 );\n                 Ok(true)\n@@ -567,8 +565,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n-                        err_ub!(DanglingIntPointer(..)) |\n-                        err_ub!(InvalidFunctionPointer(..)) =>\n+                        DanglingIntPointer(..) |\n+                        InvalidFunctionPointer(..) =>\n                             { \"{ptr}\" } expected { \"a function pointer\" },\n                     );\n                     // FIXME: Check if the signature matches\n@@ -683,12 +681,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             Ok(try_validation!(\n                 this.ecx.read_discriminant(op),\n                 this.path,\n-                err_ub!(InvalidTag(val)) =>\n+                InvalidTag(val) =>\n                     { \"{:x}\", val } expected { \"a valid enum tag\" },\n-                err_ub!(InvalidUninitBytes(None)) =>\n+                InvalidUninitBytes(None) =>\n                     { \"uninitialized bytes\" } expected { \"a valid enum tag\" },\n-                err_unsup!(ReadPointerAsBytes) =>\n-                    { \"a pointer\" } expected { \"a valid enum tag\" },\n             )\n             .1)\n         })\n@@ -828,10 +824,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(); // strings are unsized and hence never immediate\n                 let len = mplace.len(self.ecx)?;\n                 try_validation!(\n-                    self.ecx.read_bytes_ptr(mplace.ptr, Size::from_bytes(len)),\n+                    self.ecx.read_bytes_ptr_strip_provenance(mplace.ptr, Size::from_bytes(len)),\n                     self.path,\n-                    err_ub!(InvalidUninitBytes(..)) => { \"uninitialized data in `str`\" },\n-                    err_unsup!(ReadPointerAsBytes) => { \"a pointer in `str`\" },\n+                    InvalidUninitBytes(..) => { \"uninitialized data in `str`\" },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n@@ -879,9 +874,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // We also accept uninit, for consistency with the slow path.\n                 let alloc = self.ecx.get_ptr_alloc(mplace.ptr, size, mplace.align)?.expect(\"we already excluded size 0\");\n \n-                match alloc.check_bytes(alloc_range(Size::ZERO, size)) {\n+                match alloc.get_bytes_strip_provenance() {\n                     // In the happy case, we needn't check anything else.\n-                    Ok(()) => {}\n+                    Ok(_) => {}\n                     // Some error happened, try to provide a more detailed description.\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information.\n@@ -899,9 +894,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n                                 throw_validation_failure!(self.path, { \"uninitialized bytes\" })\n                             }\n-                            err_unsup!(ReadPointerAsBytes) => {\n-                                throw_validation_failure!(self.path, { \"a pointer\" } expected { \"plain (non-pointer) bytes\" })\n-                            }\n \n                             // Propagate upwards (that will also check for unexpected errors).\n                             _ => return Err(err),\n@@ -942,14 +934,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Ok(()) => Ok(()),\n             // Pass through validation failures.\n             Err(err) if matches!(err.kind(), err_ub!(ValidationFailure { .. })) => Err(err),\n-            // Also pass through InvalidProgram, those just indicate that we could not\n-            // validate and each caller will know best what to do with them.\n-            Err(err) if matches!(err.kind(), InterpError::InvalidProgram(_)) => Err(err),\n-            // Avoid other errors as those do not show *where* in the value the issue lies.\n-            Err(err) => {\n+            // Complain about any other kind of UB error -- those are bad because we'd like to\n+            // report them in a way that shows *where* in the value the issue lies.\n+            Err(err) if matches!(err.kind(), InterpError::UndefinedBehavior(_)) => {\n                 err.print_backtrace();\n-                bug!(\"Unexpected error during validation: {}\", err);\n+                bug!(\"Unexpected Undefined Behavior error during validation: {}\", err);\n             }\n+            // Pass through everything else.\n+            Err(err) => Err(err),\n         }\n     }\n "}, {"sha": "37ec04b07f847bc009814d04c51059e1594e247b", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 134, "deletions": 161, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -34,11 +34,11 @@ pub struct Allocation<Prov = AllocId, Extra = ()> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer.\n     bytes: Box<[u8]>,\n-    /// Maps from byte addresses to extra data for each pointer.\n+    /// Maps from byte addresses to extra provenance data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n     /// at the given offset.\n-    relocations: Relocations<Prov>,\n+    provenance: ProvenanceMap<Prov>,\n     /// Denotes which part of this allocation is initialized.\n     init_mask: InitMask,\n     /// The alignment of the allocation to detect unaligned reads.\n@@ -84,7 +84,7 @@ impl hash::Hash for Allocation {\n         }\n \n         // Hash the other fields as usual.\n-        self.relocations.hash(state);\n+        self.provenance.hash(state);\n         self.init_mask.hash(state);\n         self.align.hash(state);\n         self.mutability.hash(state);\n@@ -130,6 +130,8 @@ pub enum AllocError {\n     ReadPointerAsBytes,\n     /// Partially overwriting a pointer.\n     PartialPointerOverwrite(Size),\n+    /// Partially copying a pointer.\n+    PartialPointerCopy(Size),\n     /// Using uninitialized data where it is not allowed.\n     InvalidUninitBytes(Option<UninitBytesAccess>),\n }\n@@ -152,6 +154,9 @@ impl AllocError {\n             PartialPointerOverwrite(offset) => InterpError::Unsupported(\n                 UnsupportedOpInfo::PartialPointerOverwrite(Pointer::new(alloc_id, offset)),\n             ),\n+            PartialPointerCopy(offset) => InterpError::Unsupported(\n+                UnsupportedOpInfo::PartialPointerCopy(Pointer::new(alloc_id, offset)),\n+            ),\n             InvalidUninitBytes(info) => InterpError::UndefinedBehavior(\n                 UndefinedBehaviorInfo::InvalidUninitBytes(info.map(|b| (alloc_id, b))),\n             ),\n@@ -211,7 +216,7 @@ impl<Prov> Allocation<Prov> {\n         let size = Size::from_bytes(bytes.len());\n         Self {\n             bytes,\n-            relocations: Relocations::new(),\n+            provenance: ProvenanceMap::new(),\n             init_mask: InitMask::new(size, true),\n             align,\n             mutability,\n@@ -246,7 +251,7 @@ impl<Prov> Allocation<Prov> {\n         let bytes = unsafe { bytes.assume_init() };\n         Ok(Allocation {\n             bytes,\n-            relocations: Relocations::new(),\n+            provenance: ProvenanceMap::new(),\n             init_mask: InitMask::new(size, false),\n             align,\n             mutability: Mutability::Mut,\n@@ -266,22 +271,22 @@ impl Allocation {\n     ) -> Result<Allocation<Prov, Extra>, Err> {\n         // Compute new pointer provenance, which also adjusts the bytes.\n         let mut bytes = self.bytes;\n-        let mut new_relocations = Vec::with_capacity(self.relocations.0.len());\n+        let mut new_provenance = Vec::with_capacity(self.provenance.0.len());\n         let ptr_size = cx.data_layout().pointer_size.bytes_usize();\n         let endian = cx.data_layout().endian;\n-        for &(offset, alloc_id) in self.relocations.iter() {\n+        for &(offset, alloc_id) in self.provenance.iter() {\n             let idx = offset.bytes_usize();\n             let ptr_bytes = &mut bytes[idx..idx + ptr_size];\n             let bits = read_target_uint(endian, ptr_bytes).unwrap();\n             let (ptr_prov, ptr_offset) =\n                 adjust_ptr(Pointer::new(alloc_id, Size::from_bytes(bits)))?.into_parts();\n             write_target_uint(endian, ptr_bytes, ptr_offset.bytes().into()).unwrap();\n-            new_relocations.push((offset, ptr_prov));\n+            new_provenance.push((offset, ptr_prov));\n         }\n         // Create allocation.\n         Ok(Allocation {\n             bytes,\n-            relocations: Relocations::from_presorted(new_relocations),\n+            provenance: ProvenanceMap::from_presorted(new_provenance),\n             init_mask: self.init_mask,\n             align: self.align,\n             mutability: self.mutability,\n@@ -300,8 +305,8 @@ impl<Prov, Extra> Allocation<Prov, Extra> {\n         Size::from_bytes(self.len())\n     }\n \n-    /// Looks at a slice which may describe uninitialized bytes or describe a relocation. This differs\n-    /// from `get_bytes_with_uninit_and_ptr` in that it does no relocation checks (even on the\n+    /// Looks at a slice which may contain uninitialized bytes or provenance. This differs\n+    /// from `get_bytes_with_uninit_and_ptr` in that it does no provenance checks (even on the\n     /// edges) at all.\n     /// This must not be used for reads affecting the interpreter execution.\n     pub fn inspect_with_uninit_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n@@ -313,74 +318,47 @@ impl<Prov, Extra> Allocation<Prov, Extra> {\n         &self.init_mask\n     }\n \n-    /// Returns the relocation list.\n-    pub fn relocations(&self) -> &Relocations<Prov> {\n-        &self.relocations\n+    /// Returns the provenance map.\n+    pub fn provenance(&self) -> &ProvenanceMap<Prov> {\n+        &self.provenance\n     }\n }\n \n /// Byte accessors.\n impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n     /// This is the entirely abstraction-violating way to just grab the raw bytes without\n-    /// caring about relocations. It just deduplicates some code between `read_scalar`\n-    /// and `get_bytes_internal`.\n-    fn get_bytes_even_more_internal(&self, range: AllocRange) -> &[u8] {\n-        &self.bytes[range.start.bytes_usize()..range.end().bytes_usize()]\n-    }\n-\n-    /// The last argument controls whether we error out when there are uninitialized or pointer\n-    /// bytes. However, we *always* error when there are relocations overlapping the edges of the\n-    /// range.\n-    ///\n-    /// You should never call this, call `get_bytes` or `get_bytes_with_uninit_and_ptr` instead,\n+    /// caring about provenance or initialization.\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `mem_copy_repeatedly` relies\n     /// on that.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    fn get_bytes_internal(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        range: AllocRange,\n-        check_init_and_ptr: bool,\n-    ) -> AllocResult<&[u8]> {\n-        if check_init_and_ptr {\n-            self.check_init(range)?;\n-            self.check_relocations(cx, range)?;\n-        } else {\n-            // We still don't want relocations on the *edges*.\n-            self.check_relocation_edges(cx, range)?;\n-        }\n-\n-        Ok(self.get_bytes_even_more_internal(range))\n+    #[inline]\n+    pub fn get_bytes_unchecked(&self, range: AllocRange) -> &[u8] {\n+        &self.bytes[range.start.bytes_usize()..range.end().bytes_usize()]\n     }\n \n-    /// Checks that these bytes are initialized and not pointer bytes, and then return them\n-    /// as a slice.\n+    /// Checks that these bytes are initialized, and then strip provenance (if possible) and return\n+    /// them.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n     /// on `InterpCx` instead.\n     #[inline]\n-    pub fn get_bytes(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult<&[u8]> {\n-        self.get_bytes_internal(cx, range, true)\n-    }\n-\n-    /// It is the caller's responsibility to handle uninitialized and pointer bytes.\n-    /// However, this still checks that there are no relocations on the *edges*.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    #[inline]\n-    pub fn get_bytes_with_uninit_and_ptr(\n+    pub fn get_bytes_strip_provenance(\n         &self,\n         cx: &impl HasDataLayout,\n         range: AllocRange,\n     ) -> AllocResult<&[u8]> {\n-        self.get_bytes_internal(cx, range, false)\n+        self.check_init(range)?;\n+        if !Prov::OFFSET_IS_ADDR {\n+            if self.range_has_provenance(cx, range) {\n+                return Err(AllocError::ReadPointerAsBytes);\n+            }\n+        }\n+        Ok(self.get_bytes_unchecked(range))\n     }\n \n-    /// Just calling this already marks everything as defined and removes relocations,\n+    /// Just calling this already marks everything as defined and removes provenance,\n     /// so be sure to actually put data there!\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n@@ -392,7 +370,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         range: AllocRange,\n     ) -> AllocResult<&mut [u8]> {\n         self.mark_init(range, true);\n-        self.clear_relocations(cx, range)?;\n+        self.clear_provenance(cx, range)?;\n \n         Ok(&mut self.bytes[range.start.bytes_usize()..range.end().bytes_usize()])\n     }\n@@ -404,7 +382,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         range: AllocRange,\n     ) -> AllocResult<*mut [u8]> {\n         self.mark_init(range, true);\n-        self.clear_relocations(cx, range)?;\n+        self.clear_provenance(cx, range)?;\n \n         assert!(range.end().bytes_usize() <= self.bytes.len()); // need to do our own bounds-check\n         let begin_ptr = self.bytes.as_mut_ptr().wrapping_add(range.start.bytes_usize());\n@@ -415,13 +393,6 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n \n /// Reading and writing.\n impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n-    /// Validates that this memory range is initiailized and contains no relocations.\n-    pub fn check_bytes(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n-        // This implicitly does all the checking we are asking for.\n-        self.get_bytes(cx, range)?;\n-        Ok(())\n-    }\n-\n     /// Reads a *non-ZST* scalar.\n     ///\n     /// If `read_provenance` is `true`, this will also read provenance; otherwise (if the machine\n@@ -438,43 +409,53 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         range: AllocRange,\n         read_provenance: bool,\n     ) -> AllocResult<Scalar<Prov>> {\n-        if read_provenance {\n-            assert_eq!(range.size, cx.data_layout().pointer_size);\n-        }\n-\n         // First and foremost, if anything is uninit, bail.\n         if self.is_init(range).is_err() {\n             return Err(AllocError::InvalidUninitBytes(None));\n         }\n \n-        // If we are doing a pointer read, and there is a relocation exactly where we\n-        // are reading, then we can put data and relocation back together and return that.\n-        if read_provenance && let Some(&prov) = self.relocations.get(&range.start) {\n-            // We already checked init and relocations, so we can use this function.\n-            let bytes = self.get_bytes_even_more_internal(range);\n-            let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-            let ptr = Pointer::new(prov, Size::from_bytes(bits));\n-            return Ok(Scalar::from_pointer(ptr, cx));\n-        }\n+        // Get the integer part of the result. We HAVE TO check provenance before returning this!\n+        let bytes = self.get_bytes_unchecked(range);\n+        let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n \n-        // If we are *not* reading a pointer, and we can just ignore relocations,\n-        // then do exactly that.\n-        if !read_provenance && Prov::OFFSET_IS_ADDR {\n-            // We just strip provenance.\n-            let bytes = self.get_bytes_even_more_internal(range);\n-            let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-            return Ok(Scalar::from_uint(bits, range.size));\n+        if read_provenance {\n+            assert_eq!(range.size, cx.data_layout().pointer_size);\n+\n+            // When reading data with provenance, the easy case is finding provenance exactly where we\n+            // are reading, then we can put data and provenance back together and return that.\n+            if let Some(&prov) = self.provenance.get(&range.start) {\n+                // Now we can return the bits, with their appropriate provenance.\n+                let ptr = Pointer::new(prov, Size::from_bytes(bits));\n+                return Ok(Scalar::from_pointer(ptr, cx));\n+            }\n+\n+            // If we can work on pointers byte-wise, join the byte-wise provenances.\n+            if Prov::OFFSET_IS_ADDR {\n+                let mut prov = self.offset_get_provenance(cx, range.start);\n+                for offset in 1..range.size.bytes() {\n+                    let this_prov =\n+                        self.offset_get_provenance(cx, range.start + Size::from_bytes(offset));\n+                    prov = Prov::join(prov, this_prov);\n+                }\n+                // Now use this provenance.\n+                let ptr = Pointer::new(prov, Size::from_bytes(bits));\n+                return Ok(Scalar::from_maybe_pointer(ptr, cx));\n+            }\n+        } else {\n+            // We are *not* reading a pointer.\n+            // If we can just ignore provenance, do exactly that.\n+            if Prov::OFFSET_IS_ADDR {\n+                // We just strip provenance.\n+                return Ok(Scalar::from_uint(bits, range.size));\n+            }\n         }\n \n-        // It's complicated. Better make sure there is no provenance anywhere.\n-        // FIXME: If !OFFSET_IS_ADDR, this is the best we can do. But if OFFSET_IS_ADDR, then\n-        // `read_pointer` is true and we ideally would distinguish the following two cases:\n-        // - The entire `range` is covered by 2 relocations for the same provenance.\n-        //   Then we should return a pointer with that provenance.\n-        // - The range has inhomogeneous provenance. Then we should return just the\n-        //   underlying bits.\n-        let bytes = self.get_bytes(cx, range)?;\n-        let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n+        // Fallback path for when we cannot treat provenance bytewise or ignore it.\n+        assert!(!Prov::OFFSET_IS_ADDR);\n+        if self.range_has_provenance(cx, range) {\n+            return Err(AllocError::ReadPointerAsBytes);\n+        }\n+        // There is no provenance, we can just return the bits.\n         Ok(Scalar::from_uint(bits, range.size))\n     }\n \n@@ -508,9 +489,9 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         let dst = self.get_bytes_mut(cx, range)?;\n         write_target_uint(endian, dst, bytes).unwrap();\n \n-        // See if we have to also write a relocation.\n+        // See if we have to also store some provenance.\n         if let Some(provenance) = provenance {\n-            self.relocations.0.insert(range.start, provenance);\n+            self.provenance.0.insert(range.start, provenance);\n         }\n \n         Ok(())\n@@ -519,64 +500,65 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n     /// Write \"uninit\" to the given memory range.\n     pub fn write_uninit(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n         self.mark_init(range, false);\n-        self.clear_relocations(cx, range)?;\n+        self.clear_provenance(cx, range)?;\n         return Ok(());\n     }\n }\n \n-/// Relocations.\n+/// Provenance.\n impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n-    /// Returns all relocations overlapping with the given pointer-offset pair.\n-    fn get_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> &[(Size, Prov)] {\n+    /// Returns all provenance overlapping with the given pointer-offset pair.\n+    fn range_get_provenance(&self, cx: &impl HasDataLayout, range: AllocRange) -> &[(Size, Prov)] {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = range.start.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n-        self.relocations.range(Size::from_bytes(start)..range.end())\n+        self.provenance.range(Size::from_bytes(start)..range.end())\n     }\n \n-    /// Returns whether this allocation has relocations overlapping with the given range.\n-    ///\n-    /// Note: this function exists to allow `get_relocations` to be private, in order to somewhat\n-    /// limit access to relocations outside of the `Allocation` abstraction.\n-    ///\n-    pub fn has_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> bool {\n-        !self.get_relocations(cx, range).is_empty()\n+    /// Get the provenance of a single byte.\n+    fn offset_get_provenance(&self, cx: &impl HasDataLayout, offset: Size) -> Option<Prov> {\n+        let prov = self.range_get_provenance(cx, alloc_range(offset, Size::from_bytes(1)));\n+        assert!(prov.len() <= 1);\n+        prov.first().map(|(_offset, prov)| *prov)\n     }\n \n-    /// Checks that there are no relocations overlapping with the given range.\n-    #[inline(always)]\n-    fn check_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n-        if self.has_relocations(cx, range) { Err(AllocError::ReadPointerAsBytes) } else { Ok(()) }\n+    /// Returns whether this allocation has progrnance overlapping with the given range.\n+    ///\n+    /// Note: this function exists to allow `range_get_provenance` to be private, in order to somewhat\n+    /// limit access to provenance outside of the `Allocation` abstraction.\n+    ///\n+    pub fn range_has_provenance(&self, cx: &impl HasDataLayout, range: AllocRange) -> bool {\n+        !self.range_get_provenance(cx, range).is_empty()\n     }\n \n-    /// Removes all relocations inside the given range.\n-    /// If there are relocations overlapping with the edges, they\n+    /// Removes all provenance inside the given range.\n+    /// If there is provenance overlapping with the edges, it\n     /// are removed as well *and* the bytes they cover are marked as\n     /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n-    fn clear_relocations(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult\n+    fn clear_provenance(&mut self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult\n     where\n         Prov: Provenance,\n     {\n-        // Find the start and end of the given range and its outermost relocations.\n+        // Find the start and end of the given range and its outermost provenance.\n         let (first, last) = {\n-            // Find all relocations overlapping the given range.\n-            let relocations = self.get_relocations(cx, range);\n-            if relocations.is_empty() {\n+            // Find all provenance overlapping the given range.\n+            let provenance = self.range_get_provenance(cx, range);\n+            if provenance.is_empty() {\n                 return Ok(());\n             }\n \n             (\n-                relocations.first().unwrap().0,\n-                relocations.last().unwrap().0 + cx.data_layout().pointer_size,\n+                provenance.first().unwrap().0,\n+                provenance.last().unwrap().0 + cx.data_layout().pointer_size,\n             )\n         };\n         let start = range.start;\n         let end = range.end();\n \n-        // We need to handle clearing the relocations from parts of a pointer.\n-        // FIXME: Miri should preserve partial relocations; see\n+        // We need to handle clearing the provenance from parts of a pointer.\n+        // FIXME: Miri should preserve partial provenance; see\n         // https://github.com/rust-lang/miri/issues/2181.\n         if first < start {\n             if Prov::ERR_ON_PARTIAL_PTR_OVERWRITE {\n@@ -599,78 +581,69 @@ impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n             self.init_mask.set_range(end, last, false);\n         }\n \n-        // Forget all the relocations.\n-        // Since relocations do not overlap, we know that removing until `last` (exclusive) is fine,\n-        // i.e., this will not remove any other relocations just after the ones we care about.\n-        self.relocations.0.remove_range(first..last);\n-\n-        Ok(())\n-    }\n+        // Forget all the provenance.\n+        // Since provenance do not overlap, we know that removing until `last` (exclusive) is fine,\n+        // i.e., this will not remove any other provenance just after the ones we care about.\n+        self.provenance.0.remove_range(first..last);\n \n-    /// Errors if there are relocations overlapping with the edges of the\n-    /// given memory range.\n-    #[inline]\n-    fn check_relocation_edges(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n-        self.check_relocations(cx, alloc_range(range.start, Size::ZERO))?;\n-        self.check_relocations(cx, alloc_range(range.end(), Size::ZERO))?;\n         Ok(())\n     }\n }\n \n-/// \"Relocations\" stores the provenance information of pointers stored in memory.\n+/// Stores the provenance information of pointers stored in memory.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-pub struct Relocations<Prov = AllocId>(SortedMap<Size, Prov>);\n+pub struct ProvenanceMap<Prov = AllocId>(SortedMap<Size, Prov>);\n \n-impl<Prov> Relocations<Prov> {\n+impl<Prov> ProvenanceMap<Prov> {\n     pub fn new() -> Self {\n-        Relocations(SortedMap::new())\n+        ProvenanceMap(SortedMap::new())\n     }\n \n-    // The caller must guarantee that the given relocations are already sorted\n+    // The caller must guarantee that the given provenance list is already sorted\n     // by address and contain no duplicates.\n     pub fn from_presorted(r: Vec<(Size, Prov)>) -> Self {\n-        Relocations(SortedMap::from_presorted_elements(r))\n+        ProvenanceMap(SortedMap::from_presorted_elements(r))\n     }\n }\n \n-impl<Prov> Deref for Relocations<Prov> {\n+impl<Prov> Deref for ProvenanceMap<Prov> {\n     type Target = SortedMap<Size, Prov>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.0\n     }\n }\n \n-/// A partial, owned list of relocations to transfer into another allocation.\n+/// A partial, owned list of provenance to transfer into another allocation.\n ///\n /// Offsets are already adjusted to the destination allocation.\n-pub struct AllocationRelocations<Prov> {\n-    dest_relocations: Vec<(Size, Prov)>,\n+pub struct AllocationProvenance<Prov> {\n+    dest_provenance: Vec<(Size, Prov)>,\n }\n \n impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n-    pub fn prepare_relocation_copy(\n+    pub fn prepare_provenance_copy(\n         &self,\n         cx: &impl HasDataLayout,\n         src: AllocRange,\n         dest: Size,\n         count: u64,\n-    ) -> AllocationRelocations<Prov> {\n-        let relocations = self.get_relocations(cx, src);\n-        if relocations.is_empty() {\n-            return AllocationRelocations { dest_relocations: Vec::new() };\n+    ) -> AllocationProvenance<Prov> {\n+        let provenance = self.range_get_provenance(cx, src);\n+        if provenance.is_empty() {\n+            return AllocationProvenance { dest_provenance: Vec::new() };\n         }\n \n         let size = src.size;\n-        let mut new_relocations = Vec::with_capacity(relocations.len() * (count as usize));\n+        let mut new_provenance = Vec::with_capacity(provenance.len() * (count as usize));\n \n         // If `count` is large, this is rather wasteful -- we are allocating a big array here, which\n         // is mostly filled with redundant information since it's just N copies of the same `Prov`s\n-        // at slightly adjusted offsets. The reason we do this is so that in `mark_relocation_range`\n+        // at slightly adjusted offsets. The reason we do this is so that in `mark_provenance_range`\n         // we can use `insert_presorted`. That wouldn't work with an `Iterator` that just produces\n-        // the right sequence of relocations for all N copies.\n+        // the right sequence of provenance for all N copies.\n         for i in 0..count {\n-            new_relocations.extend(relocations.iter().map(|&(offset, reloc)| {\n+            new_provenance.extend(provenance.iter().map(|&(offset, reloc)| {\n                 // compute offset for current repetition\n                 let dest_offset = dest + size * i; // `Size` operations\n                 (\n@@ -681,17 +654,17 @@ impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n             }));\n         }\n \n-        AllocationRelocations { dest_relocations: new_relocations }\n+        AllocationProvenance { dest_provenance: new_provenance }\n     }\n \n-    /// Applies a relocation copy.\n-    /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n-    /// to be clear of relocations.\n+    /// Applies a provenance copy.\n+    /// The affected range, as defined in the parameters to `prepare_provenance_copy` is expected\n+    /// to be clear of provenance.\n     ///\n     /// This is dangerous to use as it can violate internal `Allocation` invariants!\n     /// It only exists to support an efficient implementation of `mem_copy_repeatedly`.\n-    pub fn mark_relocation_range(&mut self, relocations: AllocationRelocations<Prov>) {\n-        self.relocations.0.insert_presorted(relocations.dest_relocations);\n+    pub fn mark_provenance_range(&mut self, provenance: AllocationProvenance<Prov>) {\n+        self.provenance.0.insert_presorted(provenance.dest_provenance);\n     }\n }\n "}, {"sha": "e4039cc7c685ad0c635f15420582b72f3c486a8e", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -401,14 +401,18 @@ impl fmt::Display for UndefinedBehaviorInfo {\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n-    /// Encountered a pointer where we needed raw bytes.\n-    ReadPointerAsBytes,\n     /// Overwriting parts of a pointer; the resulting state cannot be represented in our\n     /// `Allocation` data structure. See <https://github.com/rust-lang/miri/issues/2181>.\n     PartialPointerOverwrite(Pointer<AllocId>),\n+    /// Attempting to `copy` parts of a pointer to somewhere else; the resulting state cannot be\n+    /// represented in our `Allocation` data structure. See\n+    /// <https://github.com/rust-lang/miri/issues/2181>.\n+    PartialPointerCopy(Pointer<AllocId>),\n     //\n     // The variants below are only reachable from CTFE/const prop, miri will never emit them.\n     //\n+    /// Encountered a pointer where we needed raw bytes.\n+    ReadPointerAsBytes,\n     /// Accessing thread local statics\n     ThreadLocalStatic(DefId),\n     /// Accessing an unsupported extern static.\n@@ -420,10 +424,13 @@ impl fmt::Display for UnsupportedOpInfo {\n         use UnsupportedOpInfo::*;\n         match self {\n             Unsupported(ref msg) => write!(f, \"{msg}\"),\n-            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\"),\n             PartialPointerOverwrite(ptr) => {\n                 write!(f, \"unable to overwrite parts of a pointer in memory at {ptr:?}\")\n             }\n+            PartialPointerCopy(ptr) => {\n+                write!(f, \"unable to copy parts of a pointer from memory at {ptr:?}\")\n+            }\n+            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\"),\n             ThreadLocalStatic(did) => write!(f, \"cannot access thread local static ({did:?})\"),\n             ReadExternStatic(did) => write!(f, \"cannot read from extern static ({did:?})\"),\n         }"}, {"sha": "0fc1217d571969c6f1fd4954631d04ed8eff1def", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -128,7 +128,7 @@ pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};\n \n pub use self::allocation::{\n     alloc_range, AllocRange, Allocation, ConstAllocation, InitChunk, InitChunkIter, InitMask,\n-    Relocations,\n+    ProvenanceMap,\n };\n \n pub use self::pointer::{Pointer, PointerArithmetic, Provenance};"}, {"sha": "95e52e391d8f8f60f8cc6450da3d49d149f36cce", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -107,8 +107,12 @@ impl<T: HasDataLayout> PointerArithmetic for T {}\n /// pointer), but `derive` adds some unnecessary bounds.\n pub trait Provenance: Copy + fmt::Debug {\n     /// Says whether the `offset` field of `Pointer`s with this provenance is the actual physical address.\n-    /// If `true, ptr-to-int casts work by simply discarding the provenance.\n-    /// If `false`, ptr-to-int casts are not supported. The offset *must* be relative in that case.\n+    /// - If `false`, the offset *must* be relative. This means the bytes representing a pointer are\n+    ///   different from what the Abstract Machine prescribes, so the interpreter must prevent any\n+    ///   operation that would inspect the underlying bytes of a pointer, such as ptr-to-int\n+    ///   transmutation. A `ReadPointerAsBytes` error will be raised in such situations.\n+    /// - If `true`, the interpreter will permit operations to inspect the underlying bytes of a\n+    ///   pointer, and implement ptr-to-int transmutation by stripping provenance.\n     const OFFSET_IS_ADDR: bool;\n \n     /// We also use this trait to control whether to abort execution when a pointer is being partially overwritten\n@@ -125,6 +129,9 @@ pub trait Provenance: Copy + fmt::Debug {\n     /// Otherwise this function is best-effort (but must agree with `Machine::ptr_get_alloc`).\n     /// (Identifying the offset in that allocation, however, is harder -- use `Memory::ptr_get_alloc` for that.)\n     fn get_alloc_id(self) -> Option<AllocId>;\n+\n+    /// Defines the 'join' of provenance: what happens when doing a pointer load and different bytes have different provenance.\n+    fn join(left: Option<Self>, right: Option<Self>) -> Option<Self>;\n }\n \n impl Provenance for AllocId {\n@@ -152,6 +159,10 @@ impl Provenance for AllocId {\n     fn get_alloc_id(self) -> Option<AllocId> {\n         Some(self)\n     }\n+\n+    fn join(_left: Option<Self>, _right: Option<Self>) -> Option<Self> {\n+        panic!(\"merging provenance is not supported when `OFFSET_IS_ADDR` is false\")\n+    }\n }\n \n /// Represents a pointer in the Miri engine."}, {"sha": "d4fad7f1ecdd9fc656e762831ff5c937d11d7964", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -130,9 +130,7 @@ pub enum Scalar<Prov = AllocId> {\n     /// The raw bytes of a simple value.\n     Int(ScalarInt),\n \n-    /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n-    /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n-    /// relocation and its associated offset together as a `Pointer` here.\n+    /// A pointer.\n     ///\n     /// We also store the size of the pointer, such that a `Scalar` always knows how big it is.\n     /// The size is always the pointer size of the current target, but this is not information\n@@ -509,7 +507,7 @@ pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) ->\n     if let ConstValue::Slice { data, start, end } = val {\n         let len = end - start;\n         data.inner()\n-            .get_bytes(\n+            .get_bytes_strip_provenance(\n                 cx,\n                 AllocRange { start: Size::from_bytes(start), size: Size::from_bytes(len) },\n             )"}, {"sha": "e94e1e8a10d0179ef1b91daa8c9ea15f66222473", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -2687,8 +2687,8 @@ fn pretty_print_const_value<'tcx>(\n                 match inner.kind() {\n                     ty::Slice(t) => {\n                         if *t == u8_type {\n-                            // The `inspect` here is okay since we checked the bounds, and there are\n-                            // no relocations (we have an active slice reference here). We don't use\n+                            // The `inspect` here is okay since we checked the bounds, and `u8` carries\n+                            // no provenance (we have an active slice reference here). We don't use\n                             // this result to affect interpreter execution.\n                             let byte_str = data\n                                 .inner()\n@@ -2698,8 +2698,8 @@ fn pretty_print_const_value<'tcx>(\n                         }\n                     }\n                     ty::Str => {\n-                        // The `inspect` here is okay since we checked the bounds, and there are no\n-                        // relocations (we have an active `str` reference here). We don't use this\n+                        // The `inspect` here is okay since we checked the bounds, and `str` carries\n+                        // no provenance (we have an active `str` reference here). We don't use this\n                         // result to affect interpreter execution.\n                         let slice = data\n                             .inner()\n@@ -2714,7 +2714,7 @@ fn pretty_print_const_value<'tcx>(\n                 let n = n.kind().try_to_bits(tcx.data_layout.pointer_size).unwrap();\n                 // cast is ok because we already checked for pointer size (32 or 64 bit) above\n                 let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n-                let byte_str = alloc.inner().get_bytes(&tcx, range).unwrap();\n+                let byte_str = alloc.inner().get_bytes_strip_provenance(&tcx, range).unwrap();\n                 fmt.write_str(\"*\")?;\n                 pretty_print_byte_str(fmt, byte_str)?;\n                 return Ok(());"}, {"sha": "88c16189f1dc6da259a40c38a0c76f19381f78ec", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -676,7 +676,7 @@ pub fn write_allocations<'tcx>(\n     fn alloc_ids_from_alloc(\n         alloc: ConstAllocation<'_>,\n     ) -> impl DoubleEndedIterator<Item = AllocId> + '_ {\n-        alloc.inner().relocations().values().map(|id| *id)\n+        alloc.inner().provenance().values().map(|id| *id)\n     }\n \n     fn alloc_ids_from_const_val(val: ConstValue<'_>) -> impl Iterator<Item = AllocId> + '_ {\n@@ -778,7 +778,7 @@ pub fn write_allocations<'tcx>(\n /// If the allocation is small enough to fit into a single line, no start address is given.\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n-/// This also prints relocations adequately.\n+/// This also prints provenance adequately.\n pub fn display_allocation<'a, 'tcx, Prov, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &'a Allocation<Prov, Extra>,\n@@ -873,34 +873,34 @@ fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n         if i != line_start {\n             write!(w, \" \")?;\n         }\n-        if let Some(&prov) = alloc.relocations().get(&i) {\n-            // Memory with a relocation must be defined\n+        if let Some(&prov) = alloc.provenance().get(&i) {\n+            // Memory with provenance must be defined\n             assert!(alloc.init_mask().is_range_initialized(i, i + ptr_size).is_ok());\n             let j = i.bytes_usize();\n             let offset = alloc\n                 .inspect_with_uninit_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n             let offset = read_target_uint(tcx.data_layout.endian, offset).unwrap();\n             let offset = Size::from_bytes(offset);\n-            let relocation_width = |bytes| bytes * 3;\n+            let provenance_width = |bytes| bytes * 3;\n             let ptr = Pointer::new(prov, offset);\n             let mut target = format!(\"{:?}\", ptr);\n-            if target.len() > relocation_width(ptr_size.bytes_usize() - 1) {\n+            if target.len() > provenance_width(ptr_size.bytes_usize() - 1) {\n                 // This is too long, try to save some space.\n                 target = format!(\"{:#?}\", ptr);\n             }\n             if ((i - line_start) + ptr_size).bytes_usize() > BYTES_PER_LINE {\n-                // This branch handles the situation where a relocation starts in the current line\n+                // This branch handles the situation where a provenance starts in the current line\n                 // but ends in the next one.\n                 let remainder = Size::from_bytes(BYTES_PER_LINE) - (i - line_start);\n                 let overflow = ptr_size - remainder;\n-                let remainder_width = relocation_width(remainder.bytes_usize()) - 2;\n-                let overflow_width = relocation_width(overflow.bytes_usize() - 1) + 1;\n+                let remainder_width = provenance_width(remainder.bytes_usize()) - 2;\n+                let overflow_width = provenance_width(overflow.bytes_usize() - 1) + 1;\n                 ascii.push('\u257e');\n                 for _ in 0..remainder.bytes() - 1 {\n                     ascii.push('\u2500');\n                 }\n                 if overflow_width > remainder_width && overflow_width >= target.len() {\n-                    // The case where the relocation fits into the part in the next line\n+                    // The case where the provenance fits into the part in the next line\n                     write!(w, \"\u257e{0:\u2500^1$}\", \"\", remainder_width)?;\n                     line_start =\n                         write_allocation_newline(w, line_start, &ascii, pos_width, prefix)?;\n@@ -921,11 +921,11 @@ fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n                 i += ptr_size;\n                 continue;\n             } else {\n-                // This branch handles a relocation that starts and ends in the current line.\n-                let relocation_width = relocation_width(ptr_size.bytes_usize() - 1);\n-                oversized_ptr(&mut target, relocation_width);\n+                // This branch handles a provenance that starts and ends in the current line.\n+                let provenance_width = provenance_width(ptr_size.bytes_usize() - 1);\n+                oversized_ptr(&mut target, provenance_width);\n                 ascii.push('\u257e');\n-                write!(w, \"\u257e{0:\u2500^1$}\u257c\", target, relocation_width)?;\n+                write!(w, \"\u257e{0:\u2500^1$}\u257c\", target, provenance_width)?;\n                 for _ in 0..ptr_size.bytes() - 2 {\n                     ascii.push('\u2500');\n                 }\n@@ -935,7 +935,7 @@ fn write_allocation_bytes<'tcx, Prov: Provenance, Extra>(\n         } else if alloc.init_mask().is_range_initialized(i, i + Size::from_bytes(1)).is_ok() {\n             let j = i.bytes_usize();\n \n-            // Checked definedness (and thus range) and relocations. This access also doesn't\n+            // Checked definedness (and thus range) and provenance. This access also doesn't\n             // influence interpreter execution but is only for debugging.\n             let c = alloc.inspect_with_uninit_and_ptr_outside_interpreter(j..j + 1)[0];\n             write!(w, \"{:02x}\", c)?;"}, {"sha": "d1c0d62ac6e005aaa90562cd2e382b1409e74c7e", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -113,7 +113,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n }\n \n // `Relocations` with default type parameters is a sorted map.\n-impl<'a, Prov> HashStable<StableHashingContext<'a>> for mir::interpret::Relocations<Prov>\n+impl<'a, Prov> HashStable<StableHashingContext<'a>> for mir::interpret::ProvenanceMap<Prov>\n where\n     Prov: HashStable<StableHashingContext<'a>>,\n {"}, {"sha": "329478f27b73c80ec2846f4b7e2e6a89a986b41d", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -1275,7 +1275,7 @@ pub trait PrettyPrinter<'tcx>:\n                                     let range =\n                                         AllocRange { start: offset, size: Size::from_bytes(len) };\n                                     if let Ok(byte_str) =\n-                                        alloc.inner().get_bytes(&self.tcx(), range)\n+                                        alloc.inner().get_bytes_strip_provenance(&self.tcx(), range)\n                                     {\n                                         p!(pretty_print_byte_str(byte_str))\n                                     } else {"}, {"sha": "5f5540495e93836a6e88eefc64b239887c2ed9ce", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -461,7 +461,7 @@ fn collect_items_rec<'tcx>(\n             recursion_depth_reset = None;\n \n             if let Ok(alloc) = tcx.eval_static_initializer(def_id) {\n-                for &id in alloc.inner().relocations().values() {\n+                for &id in alloc.inner().provenance().values() {\n                     collect_miri(tcx, id, &mut neighbors);\n                 }\n             }\n@@ -1424,7 +1424,7 @@ fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut MonoIte\n         }\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n-            for &inner in alloc.inner().relocations().values() {\n+            for &inner in alloc.inner().provenance().values() {\n                 rustc_data_structures::stack::ensure_sufficient_stack(|| {\n                     collect_miri(tcx, inner, output);\n                 });\n@@ -1463,7 +1463,7 @@ fn collect_const_value<'tcx>(\n     match value {\n         ConstValue::Scalar(Scalar::Ptr(ptr, _size)) => collect_miri(tcx, ptr.provenance, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } | ConstValue::ByRef { alloc, .. } => {\n-            for &id in alloc.inner().relocations().values() {\n+            for &id in alloc.inner().provenance().values() {\n                 collect_miri(tcx, id, output);\n             }\n         }"}, {"sha": "f8d839b64838020a6473b1742c38526c175dfb7d", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -542,13 +542,13 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId) {\n     // For the wasm32 target statics with `#[link_section]` are placed into custom\n     // sections of the final output file, but this isn't link custom sections of\n     // other executable formats. Namely we can only embed a list of bytes,\n-    // nothing with pointers to anything else or relocations. If any relocation\n-    // show up, reject them here.\n+    // nothing with provenance (pointers to anything else). If any provenance\n+    // show up, reject it here.\n     // `#[link_section]` may contain arbitrary, or even undefined bytes, but it is\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n     if let Ok(alloc) = tcx.eval_static_initializer(id.to_def_id())\n-        && alloc.inner().relocations().len() != 0\n+        && alloc.inner().provenance().len() != 0\n     {\n         let msg = \"statics with a custom `#[link_section]` must be a \\\n                         simple list of bytes on the wasm target with no \\"}, {"sha": "82a3c92e66fdf08eb11440a71186f5d66bed67cb", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -55,9 +55,10 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:27:1\n    |\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered a pointer, but expected plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257e\u2500ALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n@@ -170,9 +171,10 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:57:1\n    |\n LL | pub static R5: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered a pointer, but expected plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257eALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }"}, {"sha": "f88746af9769d9dac28b853d7eeaa145a34b2c3a", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -55,9 +55,10 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:27:1\n    |\n LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered a pointer, but expected plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n@@ -170,9 +171,10 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:57:1\n    |\n LL | pub static R5: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered a pointer, but expected plain (non-pointer) bytes\n+   | ^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }"}, {"sha": "12d5b7bd6bbc270a6b2998806b99a0149c9d7f19", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.64bit.stderr", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -7,6 +7,8 @@ LL |     const I32_REF_USIZE_UNION: usize = unsafe { Nonsense { int_32_ref: &3 }\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:30:43\n@@ -16,6 +18,8 @@ LL |     const I32_REF_U8_UNION: u8 = unsafe { Nonsense { int_32_ref: &3 }.uint_\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:34:45\n@@ -25,6 +29,8 @@ LL |     const I32_REF_U16_UNION: u16 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:38:45\n@@ -34,6 +40,8 @@ LL |     const I32_REF_U32_UNION: u32 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:42:45\n@@ -43,6 +51,8 @@ LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/const-pointer-values-in-various-types.rs:46:47\n@@ -58,6 +68,8 @@ LL |     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:54:45\n@@ -67,6 +79,8 @@ LL |     const I32_REF_I16_UNION: i16 = unsafe { Nonsense { int_32_ref: &3 }.int\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:58:45\n@@ -76,6 +90,8 @@ LL |     const I32_REF_I32_UNION: i32 = unsafe { Nonsense { int_32_ref: &3 }.int\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:62:45\n@@ -85,6 +101,8 @@ LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/const-pointer-values-in-various-types.rs:66:47\n@@ -100,6 +118,8 @@ LL |     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.flo\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:74:45\n@@ -109,6 +129,8 @@ LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.flo\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:78:47\n@@ -118,6 +140,8 @@ LL |     const I32_REF_BOOL_UNION: bool = unsafe { Nonsense { int_32_ref: &3 }.t\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:82:47\n@@ -127,6 +151,8 @@ LL |     const I32_REF_CHAR_UNION: char = unsafe { Nonsense { int_32_ref: &3 }.c\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:86:39\n@@ -136,6 +162,8 @@ LL |     const STR_U8_UNION: u8 = unsafe { Nonsense { stringy: \"3\" }.uint_8 };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:90:41\n@@ -145,6 +173,8 @@ LL |     const STR_U16_UNION: u16 = unsafe { Nonsense { stringy: \"3\" }.uint_16 }\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:94:41\n@@ -154,6 +184,8 @@ LL |     const STR_U32_UNION: u32 = unsafe { Nonsense { stringy: \"3\" }.uint_32 }\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:98:41\n@@ -163,6 +195,8 @@ LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 }\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:102:43\n@@ -172,6 +206,8 @@ LL |     const STR_U128_UNION: u128 = unsafe { Nonsense { stringy: \"3\" }.uint_12\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:106:39\n@@ -181,6 +217,8 @@ LL |     const STR_I8_UNION: i8 = unsafe { Nonsense { stringy: \"3\" }.int_8 };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:110:41\n@@ -190,6 +228,8 @@ LL |     const STR_I16_UNION: i16 = unsafe { Nonsense { stringy: \"3\" }.int_16 };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:114:41\n@@ -199,6 +239,8 @@ LL |     const STR_I32_UNION: i32 = unsafe { Nonsense { stringy: \"3\" }.int_32 };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:118:41\n@@ -208,6 +250,8 @@ LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:122:43\n@@ -217,6 +261,8 @@ LL |     const STR_I128_UNION: i128 = unsafe { Nonsense { stringy: \"3\" }.int_128\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:126:41\n@@ -226,6 +272,8 @@ LL |     const STR_F32_UNION: f32 = unsafe { Nonsense { stringy: \"3\" }.float_32\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:130:41\n@@ -235,6 +283,8 @@ LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:134:43\n@@ -244,6 +294,8 @@ LL |     const STR_BOOL_UNION: bool = unsafe { Nonsense { stringy: \"3\" }.truthy_\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:138:43\n@@ -253,6 +305,8 @@ LL |     const STR_CHAR_UNION: char = unsafe { Nonsense { stringy: \"3\" }.charact\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to 29 previous errors\n \n@@ -267,6 +321,8 @@ LL |     const I32_REF_USIZE_UNION: usize = unsafe { Nonsense { int_32_ref: &3 }\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -278,6 +334,8 @@ LL |     const I32_REF_U8_UNION: u8 = unsafe { Nonsense { int_32_ref: &3 }.uint_\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -289,6 +347,8 @@ LL |     const I32_REF_U16_UNION: u16 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -300,6 +360,8 @@ LL |     const I32_REF_U32_UNION: u32 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -311,6 +373,8 @@ LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -322,6 +386,8 @@ LL |     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -333,6 +399,8 @@ LL |     const I32_REF_I16_UNION: i16 = unsafe { Nonsense { int_32_ref: &3 }.int\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -344,6 +412,8 @@ LL |     const I32_REF_I32_UNION: i32 = unsafe { Nonsense { int_32_ref: &3 }.int\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -355,6 +425,8 @@ LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -366,6 +438,8 @@ LL |     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.flo\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -377,6 +451,8 @@ LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.flo\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -388,6 +464,8 @@ LL |     const I32_REF_BOOL_UNION: bool = unsafe { Nonsense { int_32_ref: &3 }.t\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -399,6 +477,8 @@ LL |     const I32_REF_CHAR_UNION: char = unsafe { Nonsense { int_32_ref: &3 }.c\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -410,6 +490,8 @@ LL |     const STR_U8_UNION: u8 = unsafe { Nonsense { stringy: \"3\" }.uint_8 };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -421,6 +503,8 @@ LL |     const STR_U16_UNION: u16 = unsafe { Nonsense { stringy: \"3\" }.uint_16 }\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -432,6 +516,8 @@ LL |     const STR_U32_UNION: u32 = unsafe { Nonsense { stringy: \"3\" }.uint_32 }\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -443,6 +529,8 @@ LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 }\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -454,6 +542,8 @@ LL |     const STR_U128_UNION: u128 = unsafe { Nonsense { stringy: \"3\" }.uint_12\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -465,6 +555,8 @@ LL |     const STR_I8_UNION: i8 = unsafe { Nonsense { stringy: \"3\" }.int_8 };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -476,6 +568,8 @@ LL |     const STR_I16_UNION: i16 = unsafe { Nonsense { stringy: \"3\" }.int_16 };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -487,6 +581,8 @@ LL |     const STR_I32_UNION: i32 = unsafe { Nonsense { stringy: \"3\" }.int_32 };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -498,6 +594,8 @@ LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -509,6 +607,8 @@ LL |     const STR_I128_UNION: i128 = unsafe { Nonsense { stringy: \"3\" }.int_128\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -520,6 +620,8 @@ LL |     const STR_F32_UNION: f32 = unsafe { Nonsense { stringy: \"3\" }.float_32\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -531,6 +633,8 @@ LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -542,6 +646,8 @@ LL |     const STR_BOOL_UNION: bool = unsafe { Nonsense { stringy: \"3\" }.truthy_\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -553,4 +659,6 @@ LL |     const STR_CHAR_UNION: char = unsafe { Nonsense { stringy: \"3\" }.charact\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n "}, {"sha": "75e50a27b3a83f5fcc1e1d3f9cb60910b119e810", "filename": "src/test/ui/consts/const-eval/partial_ptr_overwrite.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpartial_ptr_overwrite.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -10,6 +10,8 @@ LL |         *(ptr as *mut u8) = 123;\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to previous error\n \n@@ -26,4 +28,6 @@ LL |         *(ptr as *mut u8) = 123;\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n "}, {"sha": "30935e41549bf2654444adf607a476de4c9e9a14", "filename": "src/test/ui/consts/const-eval/ref_to_int_match.32bit.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.32bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -7,6 +7,8 @@ LL | const BAR: Int = unsafe { Foo { r: &42 }.f };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: could not evaluate constant pattern\n   --> $DIR/ref_to_int_match.rs:7:14\n@@ -32,4 +34,6 @@ LL | const BAR: Int = unsafe { Foo { r: &42 }.f };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n "}, {"sha": "30935e41549bf2654444adf607a476de4c9e9a14", "filename": "src/test/ui/consts/const-eval/ref_to_int_match.64bit.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.64bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -7,6 +7,8 @@ LL | const BAR: Int = unsafe { Foo { r: &42 }.f };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: could not evaluate constant pattern\n   --> $DIR/ref_to_int_match.rs:7:14\n@@ -32,4 +34,6 @@ LL | const BAR: Int = unsafe { Foo { r: &42 }.f };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n "}, {"sha": "752fd01f33805ee6ae19741b45a06e9ccd51f3ad", "filename": "src/test/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -18,6 +18,8 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-enum.rs:30:1\n@@ -27,6 +29,8 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:43:1\n@@ -47,6 +51,8 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-enum.rs:49:1\n@@ -56,6 +62,8 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:59:42\n@@ -71,6 +79,8 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:82:1\n@@ -130,6 +140,8 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -141,6 +153,8 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -152,6 +166,8 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -163,6 +179,8 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -174,4 +192,6 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n "}, {"sha": "3f1546a2786cac77cf847503b112c91182a53639", "filename": "src/test/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -18,6 +18,8 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-enum.rs:30:1\n@@ -27,6 +29,8 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:43:1\n@@ -47,6 +51,8 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-enum.rs:49:1\n@@ -56,6 +62,8 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-enum.rs:59:42\n@@ -71,6 +79,8 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:82:1\n@@ -130,6 +140,8 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -141,6 +153,8 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -152,6 +166,8 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -163,6 +179,8 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -174,4 +192,6 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n "}, {"sha": "3e93219c86dc1542d587fbb3bbb141943a30d231", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -51,6 +51,8 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-ref-ptr.rs:35:39\n@@ -60,6 +62,8 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-ref-ptr.rs:35:38\n@@ -78,6 +82,8 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-ref-ptr.rs:41:85\n@@ -168,6 +174,8 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -179,6 +187,8 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -201,6 +211,8 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error"}, {"sha": "bc2aa12a2f31e6e20c243549f2756409d32b1df2", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -51,6 +51,8 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-ref-ptr.rs:35:39\n@@ -60,6 +62,8 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-ref-ptr.rs:35:38\n@@ -78,6 +82,8 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-ref-ptr.rs:41:85\n@@ -168,6 +174,8 @@ LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -179,6 +187,8 @@ LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -201,6 +211,8 @@ LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[us\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error"}, {"sha": "4cd974e7bf97783c31a111866392eb29dcac816c", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -29,6 +29,8 @@ LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-wide-ptr.rs:46:1\n@@ -38,6 +40,8 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:49:1\n@@ -108,6 +112,8 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:80:1\n@@ -128,6 +134,8 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:88:1\n@@ -315,6 +323,8 @@ LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -326,6 +336,8 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -337,6 +349,8 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -348,6 +362,8 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error"}, {"sha": "1d84b7bce1410abb01ac8b745ddbe950397bf4bc", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -29,6 +29,8 @@ LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ub-wide-ptr.rs:46:1\n@@ -38,6 +40,8 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:49:1\n@@ -108,6 +112,8 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:80:1\n@@ -128,6 +134,8 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:88:1\n@@ -315,6 +323,8 @@ LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -326,6 +336,8 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -337,6 +349,8 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -348,6 +362,8 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error"}, {"sha": "86fbadb946d53d0f2c46a1df0e4c3479e9b1f6c3", "filename": "src/test/ui/consts/extra-const-ub/detect-extra-ub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -13,15 +13,15 @@ const INVALID_BOOL: () = unsafe {\n \n const INVALID_PTR_IN_INT: () = unsafe {\n     let _x: usize = transmute(&3u8);\n-    //[with_flag]~^ ERROR: evaluation of constant value failed\n-    //[with_flag]~| invalid value\n+    //[with_flag]~^ ERROR: any use of this value will cause an error\n+    //[with_flag]~| previously accepted\n };\n \n const INVALID_SLICE_TO_USIZE_TRANSMUTE: () = unsafe {\n     let x: &[u8] = &[0; 32];\n     let _x: (usize, usize) = transmute(x);\n-    //[with_flag]~^ ERROR: evaluation of constant value failed\n-    //[with_flag]~| invalid value\n+    //[with_flag]~^ ERROR: any use of this value will cause an error\n+    //[with_flag]~| previously accepted\n };\n \n const UNALIGNED_PTR: () = unsafe {"}, {"sha": "793725d3b80fcdbcd41f3baa77bbed2fb3d9d7ef", "filename": "src/test/ui/consts/extra-const-ub/detect-extra-ub.with_flag.stderr", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -4,17 +4,33 @@ error[E0080]: evaluation of constant value failed\n LL |     let _x: bool = transmute(3u8);\n    |                    ^^^^^^^^^^^^^^ constructing invalid value: encountered 0x03, but expected a boolean\n \n-error[E0080]: evaluation of constant value failed\n+error: any use of this value will cause an error\n   --> $DIR/detect-extra-ub.rs:15:21\n    |\n+LL | const INVALID_PTR_IN_INT: () = unsafe {\n+   | ----------------------------\n LL |     let _x: usize = transmute(&3u8);\n-   |                     ^^^^^^^^^^^^^^^ constructing invalid value: encountered (potentially part of) a pointer, but expected an integer\n+   |                     ^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n-error[E0080]: evaluation of constant value failed\n+error: any use of this value will cause an error\n   --> $DIR/detect-extra-ub.rs:22:30\n    |\n+LL | const INVALID_SLICE_TO_USIZE_TRANSMUTE: () = unsafe {\n+   | ------------------------------------------\n+LL |     let x: &[u8] = &[0; 32];\n LL |     let _x: (usize, usize) = transmute(x);\n-   |                              ^^^^^^^^^^^^ constructing invalid value at .0: encountered (potentially part of) a pointer, but expected an integer\n+   |                              ^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/detect-extra-ub.rs:28:20\n@@ -49,14 +65,44 @@ LL | const UNALIGNED_READ: () = {\n LL |     INNER;\n    |     ^^^^^ referenced constant has errors\n    |\n-   = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0080`.\n Future incompatibility report: Future breakage diagnostic:\n+error: any use of this value will cause an error\n+  --> $DIR/detect-extra-ub.rs:15:21\n+   |\n+LL | const INVALID_PTR_IN_INT: () = unsafe {\n+   | ----------------------------\n+LL |     let _x: usize = transmute(&3u8);\n+   |                     ^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+\n+Future breakage diagnostic:\n+error: any use of this value will cause an error\n+  --> $DIR/detect-extra-ub.rs:22:30\n+   |\n+LL | const INVALID_SLICE_TO_USIZE_TRANSMUTE: () = unsafe {\n+   | ------------------------------------------\n+LL |     let x: &[u8] = &[0; 32];\n+LL |     let _x: (usize, usize) = transmute(x);\n+   |                              ^^^^^^^^^^^^ unable to turn pointer into raw bytes\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n+\n+Future breakage diagnostic:\n error: any use of this value will cause an error\n   --> $DIR/detect-extra-ub.rs:34:5\n    |"}, {"sha": "2776e2b6fa21f8a13b820be41dd3fe25c383852a", "filename": "src/test/ui/consts/issue-83182.32bit.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.32bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -2,9 +2,10 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/issue-83182.rs:5:1\n    |\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered a pointer in `str`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                \u257e\u2500alloc4\u2500\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }"}, {"sha": "9e884ce12890b379b1c96115ddc767b05bd694b5", "filename": "src/test/ui/consts/issue-83182.64bit.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.64bit.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -2,9 +2,10 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/issue-83182.rs:5:1\n    |\n LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered a pointer in `str`\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }"}, {"sha": "2536d2f08f288864cdcad95ded56a105f2fc8f2f", "filename": "src/test/ui/consts/issue-83182.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-83182.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -4,5 +4,4 @@ use std::mem;\n struct MyStr(str);\n const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[&()]) };\n //~^ ERROR: it is undefined behavior to use this value\n-//~| constructing invalid value at .<deref>.0: encountered a pointer in `str`\n fn main() {}"}, {"sha": "29e0ea950264046dfe1025f4694fa6f68091f6ef", "filename": "src/test/ui/consts/issue-miri-1910.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.rs?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -1,4 +1,5 @@\n // error-pattern unable to turn pointer into raw bytes\n+// normalize-stderr-test: \"alloc[0-9]+\\+0x[a-z0-9]+\" -> \"ALLOC\"\n #![feature(const_ptr_read)]\n \n const C: () = unsafe {"}, {"sha": "0f0539e09799eff4404dae2947cfdab95ca62507", "filename": "src/test/ui/consts/issue-miri-1910.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-miri-1910.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -4,19 +4,21 @@ error: any use of this value will cause an error\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         unable to turn pointer into raw bytes\n+   |         unable to copy parts of a pointer from memory at ALLOC\n    |         inside `std::ptr::read::<u8>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |         inside `ptr::const_ptr::<impl *const u8>::read` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |         inside `C` at $DIR/issue-miri-1910.rs:7:5\n+   |         inside `C` at $DIR/issue-miri-1910.rs:8:5\n    |\n-  ::: $DIR/issue-miri-1910.rs:4:1\n+  ::: $DIR/issue-miri-1910.rs:5:1\n    |\n LL | const C: () = unsafe {\n    | -----------\n    |\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to previous error\n \n@@ -27,17 +29,19 @@ error: any use of this value will cause an error\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         unable to turn pointer into raw bytes\n+   |         unable to copy parts of a pointer from memory at ALLOC\n    |         inside `std::ptr::read::<u8>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |         inside `ptr::const_ptr::<impl *const u8>::read` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |         inside `C` at $DIR/issue-miri-1910.rs:7:5\n+   |         inside `C` at $DIR/issue-miri-1910.rs:8:5\n    |\n-  ::: $DIR/issue-miri-1910.rs:4:1\n+  ::: $DIR/issue-miri-1910.rs:5:1\n    |\n LL | const C: () = unsafe {\n    | -----------\n    |\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n "}, {"sha": "e0c4fa17585a9127836073e2203222feddde3a26", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -9,6 +9,9 @@ error[E0080]: could not evaluate static initializer\n    |\n LL |     let _v = x + 0;\n    |              ^ unable to turn pointer into raw bytes\n+   |\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n warning: skipping const checks\n    |"}, {"sha": "1d47f243f01cdeb6c4b5b7cdf3cc0ee12c34918c", "filename": "src/test/ui/consts/ptr_comparisons.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81f3841cfb5eae52d7914dfebb6a55b5951c5c3c/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr?ref=81f3841cfb5eae52d7914dfebb6a55b5951c5c3c", "patch": "@@ -27,6 +27,8 @@ LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) +\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n   --> $DIR/ptr_comparisons.rs:70:27\n@@ -36,6 +38,8 @@ LL | const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: aborting due to 4 previous errors\n \n@@ -50,6 +54,8 @@ LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) +\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n@@ -61,4 +67,6 @@ LL | const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4\n    = note: `#[deny(const_err)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+   = help: this code performed an operation that depends on the underlying bytes representing a pointer\n+   = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n "}]}