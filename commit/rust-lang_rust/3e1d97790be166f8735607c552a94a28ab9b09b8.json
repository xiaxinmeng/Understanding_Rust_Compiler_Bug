{"sha": "3e1d97790be166f8735607c552a94a28ab9b09b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMWQ5Nzc5MGJlMTY2Zjg3MzU2MDdjNTUyYTk0YTI4YWI5YjA5Yjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-08T15:18:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-08T15:18:55Z"}, "message": "Merge #3054\n\n3054: Move emacs support to emacs-lsp r=flodiebold a=flodiebold\n\nemacs-lsp has integrated most of the support code (https://github.com/emacs-lsp/lsp-mode/pull/1395 will remove the last differences, as far as I can tell), so remove rust-analyzer.el here and update the documentation.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "c012a1fb7f7e97a34ff65559c15413a179a59e60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c012a1fb7f7e97a34ff65559c15413a179a59e60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e1d97790be166f8735607c552a94a28ab9b09b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJePtFfCRBK7hj4Ov3rIwAAdHIIADT8lBq4S46Ei5uKK5KBmRak\n1JiiHwvafkDev5bjVSY5185ujXl0a9Mv25WT6ot/DtHQqBSGdaZqNpI6hB2LrEUe\nt37XCHN3J45t7PdG6W50NW6uyDq8mVicblcRylfiDaaO2+2oA4WF2CeuQuF3rPFX\nYoi/3DqrPvZwPHwbduOgjQRNaSNEJWDd5NARsqXAx4p081nR3kBRyTuticc7EtPO\nOMWHjWnansy4xDjmrWRLe8mdX5HgqA1kF54fC/HjyjApCF4fT/mOJx5PwNzIBEZ9\nvpVVvWvU46KLMe2QpHDoM8xMZvgm3WWOSjC5xCJocdRmmTXLAVbJwyvHew91uwg=\n=WG8E\n-----END PGP SIGNATURE-----\n", "payload": "tree c012a1fb7f7e97a34ff65559c15413a179a59e60\nparent 5397f05bfe7f3b18229a65040c6685e762b2f9a3\nparent 134cc70097f2386bf3af6a15e3c29de9c317ed24\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1581175135 +0000\ncommitter GitHub <noreply@github.com> 1581175135 +0000\n\nMerge #3054\n\n3054: Move emacs support to emacs-lsp r=flodiebold a=flodiebold\n\nemacs-lsp has integrated most of the support code (https://github.com/emacs-lsp/lsp-mode/pull/1395 will remove the last differences, as far as I can tell), so remove rust-analyzer.el here and update the documentation.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e1d97790be166f8735607c552a94a28ab9b09b8", "html_url": "https://github.com/rust-lang/rust/commit/3e1d97790be166f8735607c552a94a28ab9b09b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e1d97790be166f8735607c552a94a28ab9b09b8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5397f05bfe7f3b18229a65040c6685e762b2f9a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5397f05bfe7f3b18229a65040c6685e762b2f9a3", "html_url": "https://github.com/rust-lang/rust/commit/5397f05bfe7f3b18229a65040c6685e762b2f9a3"}, {"sha": "134cc70097f2386bf3af6a15e3c29de9c317ed24", "url": "https://api.github.com/repos/rust-lang/rust/commits/134cc70097f2386bf3af6a15e3c29de9c317ed24", "html_url": "https://github.com/rust-lang/rust/commit/134cc70097f2386bf3af6a15e3c29de9c317ed24"}], "stats": {"total": 325, "additions": 12, "deletions": 313}, "files": [{"sha": "732e4bdd30d30f47fc3042a452280c82cced0bbd", "filename": "docs/dev/README.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e1d97790be166f8735607c552a94a28ab9b09b8/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e1d97790be166f8735607c552a94a28ab9b09b8/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=3e1d97790be166f8735607c552a94a28ab9b09b8", "patch": "@@ -43,7 +43,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0\n \n We use GitHub Actions for CI. Most of the things, including formatting, are checked by\n `cargo test` so, if `cargo test` passes locally, that's a good sign that CI will\n-be green as well. The only exception is that long-running by default a skipped locally.\n+be green as well. The only exception is that some long-running tests are skipped locally by default.\n Use `env RUN_SLOW_TESTS=1 cargo test` to run the full suite.\n \n We use bors-ng to enforce the [not rocket science](https://graydon2.dreamwidth.org/1597.html) rule.\n@@ -54,9 +54,9 @@ You can run `cargo xtask install-pre-commit-hook` to install git-hook to run rus\n \n All Rust code lives in the `crates` top-level directory, and is organized as a\n single Cargo workspace. The `editors` top-level directory contains code for\n-integrating with editors. Currently, it contains plugins for VS Code (in\n-typescript) and Emacs (in elisp). The `docs` top-level directory contains both\n-developer and user documentation.\n+integrating with editors. Currently, it contains the plugin for VS Code (in\n+typescript). The `docs` top-level directory contains both developer and user\n+documentation.\n \n We have some automation infra in Rust in the `xtask` package. It contains\n stuff like formatting checking, code generation and powers `cargo xtask install`.\n@@ -107,8 +107,8 @@ If I need to fix something simultaneously in the server and in the client, I\n feel even more sad. I don't have a specific workflow for this case.\n \n Additionally, I use `cargo run --release -p ra_cli -- analysis-stats\n-path/to/some/rust/crate` to run a batch analysis. This is primaraly useful for\n-performance optimiations, or for bug minimization.\n+path/to/some/rust/crate` to run a batch analysis. This is primarily useful for\n+performance optimizations, or for bug minimization.\n \n # Logging\n "}, {"sha": "da99a063c689c2806af41951a1afcb3ef7505cca", "filename": "docs/user/README.md", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e1d97790be166f8735607c552a94a28ab9b09b8/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e1d97790be166f8735607c552a94a28ab9b09b8/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=3e1d97790be166f8735607c552a94a28ab9b09b8", "patch": "@@ -5,8 +5,7 @@ install lsp server, clone the repository and then run `cargo xtask install\n ./crates/ra_lsp_server`). This will produce a binary named `ra_lsp_server` which\n you should be able to use it with any LSP-compatible editor. We use custom\n extensions to LSP, so special client-side support is required to take full\n-advantage of rust-analyzer. This repository contains support code for VS Code\n-and Emacs.\n+advantage of rust-analyzer. This repository contains support code for VS Code.\n \n ```\n $ git clone git@github.com:rust-analyzer/rust-analyzer && cd rust-analyzer\n@@ -130,17 +129,12 @@ host.\n \n ## Emacs\n \n-Prerequisites:\n-\n-`emacs-lsp`, `dash` and `ht` packages.\n-\n-Installation:\n+* install recent version of `emacs-lsp` package by following the instructions [here][emacs-lsp]\n+* set `lsp-rust-server` to `'rust-analyzer`\n+* run `lsp` in a Rust buffer\n+* (Optionally) bind commands like `lsp-rust-analyzer-join-lines`, `lsp-extend-selection` and `lsp-rust-analyzer-expand-macro` to keys\n \n-* add\n-[rust-analyzer.el](../../editors/emacs/rust-analyzer.el)\n-to load path and require it in `init.el`\n-* run `lsp` in a rust buffer\n-* (Optionally) bind commands like `rust-analyzer-join-lines`, `rust-analyzer-extend-selection` and `rust-analyzer-expand-macro` to keys, and enable `rust-analyzer-inlay-hints-mode` to get inline type hints\n+[emacs-lsp]: https://github.com/emacs-lsp/lsp-mode\n \n \n ## Vim and NeoVim (coc-rust-analyzer)"}, {"sha": "9b426fcae92741ce216160a0fe6619b0de054e59", "filename": "editors/emacs/rust-analyzer.el", "status": "removed", "additions": 0, "deletions": 295, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/5397f05bfe7f3b18229a65040c6685e762b2f9a3/editors%2Femacs%2Frust-analyzer.el", "raw_url": "https://github.com/rust-lang/rust/raw/5397f05bfe7f3b18229a65040c6685e762b2f9a3/editors%2Femacs%2Frust-analyzer.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Femacs%2Frust-analyzer.el?ref=5397f05bfe7f3b18229a65040c6685e762b2f9a3", "patch": "@@ -1,295 +0,0 @@\n-;;; rust-analyzer.el --- Rust analyzer emacs bindings for emacs-lsp -*- lexical-binding: t; -*-\n-;;; Code:\n-\n-(require 'lsp)\n-(require 'dash)\n-(require 'ht)\n-\n-;; This currently\n-;;  - sets up rust-analyzer with emacs-lsp, giving\n-;;    - code actions\n-;;    - completion (use company-lsp for proper snippet support)\n-;;    - imenu support\n-;;    - on-type formatting\n-;;    - 'hover' type information & documentation (with lsp-ui)\n-;;  - implements source changes (for code actions etc.), except for file system changes\n-;;  - implements joinLines (you need to bind rust-analyzer-join-lines to a key)\n-;;  - implements selectionRanges (either bind lsp-extend-selection to a key, or use expand-region)\n-;;  - provides rust-analyzer-inlay-hints-mode for inline type hints\n-;;  - provides rust-analyzer-expand-macro to expand macros\n-\n-;; What's missing:\n-;;  - file system changes in apply-source-change\n-;;  - semantic highlighting\n-;;  - onEnter, parentModule, findMatchingBrace\n-;;  - runnables\n-;;  - the debugging commands (syntaxTree and analyzerStatus)\n-;;  - more\n-\n-;; Also, there's a problem with company-lsp's caching being too eager, sometimes\n-;; resulting in outdated completions.\n-\n-(defcustom rust-analyzer-command '(\"ra_lsp_server\")\n-  \"\"\n-  :type '(repeat (string)))\n-\n-(defconst rust-analyzer--notification-handlers\n-  '((\"rust-analyzer/publishDecorations\" . (lambda (_w _p)))))\n-\n-(defconst rust-analyzer--action-handlers\n-  '((\"rust-analyzer.applySourceChange\" .\n-     (lambda (p) (rust-analyzer--apply-source-change-command p)))\n-    (\"rust-analyzer.selectAndApplySourceChange\" .\n-     (lambda (p) (rust-analyzer--select-and-apply-source-change-command p)))))\n-\n-(defun rust-analyzer--uri-filename (text-document)\n-  (lsp--uri-to-path (gethash \"uri\" text-document)))\n-\n-(defun rust-analyzer--goto-lsp-loc (loc)\n-  (-let (((&hash \"line\" \"character\") loc))\n-    (goto-line (1+ line))\n-    (move-to-column character)))\n-\n-(defun rust-analyzer--apply-text-document-edit (edit)\n-  \"Like lsp--apply-text-document-edit, but it allows nil version.\"\n-  (let* ((ident (gethash \"textDocument\" edit))\n-         (filename (rust-analyzer--uri-filename ident))\n-         (version (gethash \"version\" ident)))\n-    (with-current-buffer (find-file-noselect filename)\n-      (when (or (not version) (= version (lsp--cur-file-version)))\n-        (lsp--apply-text-edits (gethash \"edits\" edit))))))\n-\n-(defun rust-analyzer--apply-source-change (data)\n-  ;; TODO fileSystemEdits\n-  (seq-doseq (it (-> data (ht-get \"workspaceEdit\") (ht-get \"documentChanges\")))\n-    (rust-analyzer--apply-text-document-edit it))\n-  (-when-let (cursor-position (ht-get data \"cursorPosition\"))\n-    (let ((filename (rust-analyzer--uri-filename (ht-get cursor-position \"textDocument\")))\n-          (position (ht-get cursor-position \"position\")))\n-      (find-file filename)\n-      (rust-analyzer--goto-lsp-loc position))))\n-\n-(defun rust-analyzer--apply-source-change-command (p)\n-  (let ((data (-> p (ht-get \"arguments\") (lsp-seq-first))))\n-    (rust-analyzer--apply-source-change data)))\n-\n-(defun rust-analyzer--select-and-apply-source-change-command (p)\n-  (let* ((options (-> p (ht-get \"arguments\") (lsp-seq-first)))\n-         (chosen-option (lsp--completing-read \"Select option:\" options\n-                                              (-lambda ((&hash \"label\")) label))))\n-    (rust-analyzer--apply-source-change chosen-option)))\n-\n-(lsp-register-client\n- (make-lsp-client\n-  :new-connection (lsp-stdio-connection (lambda () rust-analyzer-command))\n-  :notification-handlers (ht<-alist rust-analyzer--notification-handlers)\n-  :action-handlers (ht<-alist rust-analyzer--action-handlers)\n-  :major-modes '(rust-mode)\n-  :ignore-messages nil\n-  :server-id 'rust-analyzer))\n-\n-(defun rust-analyzer--initialized? ()\n-  (when-let ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name))))\n-    (eq 'initialized (lsp--workspace-status workspace))))\n-\n-(with-eval-after-load 'company-lsp\n-  ;; company-lsp provides a snippet handler for rust by default that adds () after function calls, which RA does better\n-  (setq company-lsp--snippet-functions (cl-delete \"rust\" company-lsp--snippet-functions :key #'car :test #'equal)))\n-\n-;; join lines\n-\n-(defun rust-analyzer--join-lines-params ()\n-  \"Join lines params.\"\n-  (list :textDocument (lsp--text-document-identifier)\n-        :range (if (use-region-p)\n-                   (lsp--region-to-range (region-beginning) (region-end))\n-                 (lsp--region-to-range (point) (point)))))\n-\n-(defun rust-analyzer-join-lines ()\n-  (interactive)\n-  (->\n-   (lsp-send-request (lsp-make-request \"rust-analyzer/joinLines\"\n-                                       (rust-analyzer--join-lines-params)))\n-   (rust-analyzer--apply-source-change)))\n-\n-;; selection ranges\n-\n-(defun rust-analyzer--add-er-expansion ()\n-  (make-variable-buffer-local 'er/try-expand-list)\n-  (setq er/try-expand-list (append\n-                            er/try-expand-list\n-                            '(lsp-extend-selection))))\n-\n-(with-eval-after-load 'expand-region\n-  ;; add the expansion for all existing rust-mode buffers. If expand-region is\n-  ;; loaded lazily, it might be loaded when the first rust buffer is opened, and\n-  ;; then it's too late for the hook for that buffer\n-  (dolist (buf (buffer-list))\n-    (with-current-buffer buf\n-      (when (eq 'rust-mode major-mode)\n-        (rust-analyzer--add-er-expansion))))\n-  (add-hook 'rust-mode-hook 'rust-analyzer--add-er-expansion))\n-\n-;; runnables\n-(defvar rust-analyzer--last-runnable nil)\n-\n-(defun rust-analyzer--runnables-params ()\n-  (list :textDocument (lsp--text-document-identifier)\n-        :position (lsp--cur-position)))\n-\n-(defun rust-analyzer--runnables ()\n-  (lsp-send-request (lsp-make-request \"rust-analyzer/runnables\"\n-                                      (rust-analyzer--runnables-params))))\n-\n-(defun rust-analyzer--select-runnable ()\n-  (lsp--completing-read\n-   \"Select runnable:\"\n-   (if rust-analyzer--last-runnable\n-       (cons rust-analyzer--last-runnable (rust-analyzer--runnables))\n-       (rust-analyzer--runnables))\n-   (-lambda ((&hash \"label\")) label)))\n-\n-(defun rust-analyzer-run (runnable)\n-  (interactive (list (rust-analyzer--select-runnable)))\n-  (-let* (((&hash \"env\" \"bin\" \"args\" \"label\") runnable)\n-          (compilation-environment (-map (-lambda ((k v)) (concat k \"=\" v)) (ht-items env))))\n-    (compilation-start\n-     (string-join (append (list bin) args '()) \" \")\n-     ;; cargo-process-mode is nice, but try to work without it...\n-     (if (functionp 'cargo-process-mode) 'cargo-process-mode nil)\n-     (lambda (_) (concat \"*\" label \"*\")))\n-    (setq rust-analyzer--last-runnable runnable)))\n-\n-(defun rust-analyzer-rerun (&optional runnable)\n-  (interactive (list (or rust-analyzer--last-runnable\n-                         (rust-analyzer--select-runnable))))\n-  (rust-analyzer-run (or runnable rust-analyzer--last-runnable)))\n-\n-;; analyzer status buffer\n-(define-derived-mode rust-analyzer-status-mode special-mode \"Rust-Analyzer-Status\"\n-  \"Mode for the rust-analyzer status buffer.\")\n-\n-(defvar-local rust-analyzer--status-buffer-workspace nil)\n-\n-(defun rust-analyzer-status ()\n-  \"Displays status information for rust-analyzer.\"\n-  (interactive)\n-  (let* ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name)))\n-         (buf (get-buffer-create (concat \"*rust-analyzer status \" (with-lsp-workspace workspace (lsp-workspace-root)) \"*\"))))\n-    (with-current-buffer buf\n-      (rust-analyzer-status-mode)\n-      (setq rust-analyzer--status-buffer-workspace workspace)\n-      (rust-analyzer-status-buffer-refresh))\n-    (pop-to-buffer buf)))\n-\n-(defun rust-analyzer-status-buffer-refresh ()\n-  (interactive)\n-  (when rust-analyzer--status-buffer-workspace\n-    (let ((inhibit-read-only t))\n-      (erase-buffer)\n-      (insert (with-lsp-workspace rust-analyzer--status-buffer-workspace\n-                (lsp-send-request (lsp-make-request\n-                                   \"rust-analyzer/analyzerStatus\")))))))\n-\n-\n-(defun rust-analyzer--syntax-tree-params ()\n-  \"Syntax tree params.\"\n-  (list :textDocument (lsp--text-document-identifier)\n-        :range (if (use-region-p)\n-                   (lsp--region-to-range (region-beginning) (region-end))\n-                 (lsp--region-to-range (point-min) (point-max)))))\n-\n-(defun rust-analyzer-syntax-tree ()\n-  \"Displays syntax tree for current buffer.\"\n-  (interactive)\n-  (when (eq 'rust-mode major-mode)\n-    (let* ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name)))\n-           (buf (get-buffer-create (concat \"*rust-analyzer syntax tree \" (with-lsp-workspace workspace (lsp-workspace-root)) \"*\"))))\n-      (when workspace\n-        (let ((parse-result (with-lsp-workspace workspace\n-                              (lsp-send-request (lsp-make-request\n-                                                 \"rust-analyzer/syntaxTree\"\n-                                                 (rust-analyzer--syntax-tree-params))))))\n-          (with-current-buffer buf\n-            (let ((inhibit-read-only t))\n-              (erase-buffer)\n-              (insert parse-result)))\n-          (pop-to-buffer buf))))))\n-\n-;; inlay hints\n-(defun rust-analyzer--update-inlay-hints (buffer)\n-  (if (and (rust-analyzer--initialized?) (eq buffer (current-buffer)))\n-    (lsp-request-async\n-     \"rust-analyzer/inlayHints\"\n-     (list :textDocument (lsp--text-document-identifier))\n-     (lambda (res)\n-       (remove-overlays (point-min) (point-max) 'rust-analyzer--inlay-hint t)\n-       (dolist (hint res)\n-         (-let* (((&hash \"range\" \"label\" \"kind\") hint)\n-                 ((beg . end) (lsp--range-to-region range))\n-                 (overlay (make-overlay beg end)))\n-           (overlay-put overlay 'rust-analyzer--inlay-hint t)\n-           (overlay-put overlay 'evaporate t)\n-           (cond\n-            ((string= kind \"TypeHint\")\n-             (overlay-put overlay 'after-string (propertize (concat \": \" label)\n-                                                            'font-lock-face 'font-lock-comment-face)))\n-            ((string= kind \"ParameterHint\")\n-             (overlay-put overlay 'before-string (propertize (concat label \": \")\n-                                                            'font-lock-face 'font-lock-comment-face)))\n-            )\n-           )))\n-     :mode 'tick))\n-  nil)\n-\n-(defvar-local rust-analyzer--inlay-hints-timer nil)\n-\n-(defun rust-analyzer--inlay-hints-change-handler (&rest rest)\n-  (when rust-analyzer--inlay-hints-timer\n-    (cancel-timer rust-analyzer--inlay-hints-timer))\n-  (setq rust-analyzer--inlay-hints-timer\n-        (run-with-idle-timer 0.1 nil #'rust-analyzer--update-inlay-hints (current-buffer))))\n-\n-(define-minor-mode rust-analyzer-inlay-hints-mode\n-  \"Mode for showing inlay hints.\"\n-  nil nil nil\n-  (cond\n-   (rust-analyzer-inlay-hints-mode\n-    (rust-analyzer--update-inlay-hints (current-buffer))\n-    (add-hook 'lsp-after-initialize-hook #'rust-analyzer--inlay-hints-change-handler nil t)\n-    (add-hook 'after-change-functions #'rust-analyzer--inlay-hints-change-handler nil t))\n-   (t\n-    (remove-overlays (point-min) (point-max) 'rust-analyzer--inlay-hint t)\n-    (remove-hook 'lsp-after-initialize-hook #'rust-analyzer--inlay-hints-change-handler t)\n-    (remove-hook 'after-change-functions #'rust-analyzer--inlay-hints-change-handler t))))\n-\n-\n-\n-;; expand macros\n-(defun rust-analyzer-expand-macro ()\n-  \"Expands the macro call at point recursively.\"\n-  (interactive)\n-  (when (eq 'rust-mode major-mode)\n-    (let* ((workspace (lsp-find-workspace 'rust-analyzer (buffer-file-name)))\n-           (params (list :textDocument (lsp--text-document-identifier)\n-                         :position (lsp--cur-position))))\n-      (when workspace\n-        (let* ((response (with-lsp-workspace workspace\n-                           (lsp-send-request (lsp-make-request\n-                                              \"rust-analyzer/expandMacro\"\n-                                              params))))\n-               (result (when response (ht-get response \"expansion\"))))\n-          (if result\n-            (let ((buf (get-buffer-create (concat \"*rust-analyzer macro expansion \" (with-lsp-workspace workspace (lsp-workspace-root)) \"*\"))))\n-              (with-current-buffer buf\n-                (let ((inhibit-read-only t))\n-                  (erase-buffer)\n-                  (insert result)\n-                  (setq buffer-read-only t)\n-                  (special-mode)))\n-              (pop-to-buffer buf))\n-            (message \"No macro found at point, or it could not be expanded\")))))))\n-\n-\n-(provide 'rust-analyzer)\n-;;; rust-analyzer.el ends here"}]}