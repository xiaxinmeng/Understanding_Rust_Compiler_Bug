{"sha": "1195708f64f34f6c402f98f5b551e2567be731c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTU3MDhmNjRmMzRmNmM0MDJmOThmNWI1NTFlMjU2N2JlNzMxYzk=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-09T01:26:43Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:47Z"}, "message": "librustc: use unboxed closures", "tree": {"sha": "210b60a36eb0fdeb1d6608647e4a334490dfcbfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/210b60a36eb0fdeb1d6608647e4a334490dfcbfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1195708f64f34f6c402f98f5b551e2567be731c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1195708f64f34f6c402f98f5b551e2567be731c9", "html_url": "https://github.com/rust-lang/rust/commit/1195708f64f34f6c402f98f5b551e2567be731c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1195708f64f34f6c402f98f5b551e2567be731c9/comments", "author": null, "committer": null, "parents": [{"sha": "933e7b4a3ec1ca93af8fa1cacba0f9bf55fe9daf", "url": "https://api.github.com/repos/rust-lang/rust/commits/933e7b4a3ec1ca93af8fa1cacba0f9bf55fe9daf", "html_url": "https://github.com/rust-lang/rust/commit/933e7b4a3ec1ca93af8fa1cacba0f9bf55fe9daf"}], "stats": {"total": 875, "additions": 517, "deletions": 358}, "files": [{"sha": "9f9e266c6c74b2ea0602799a4dea007398d758c5", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -464,9 +464,11 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n-    fn with_lint_attrs(&mut self,\n-                       attrs: &[ast::Attribute],\n-                       f: |&mut Context|) {\n+    fn with_lint_attrs<F>(&mut self,\n+                          attrs: &[ast::Attribute],\n+                          f: F) where\n+        F: FnOnce(&mut Context),\n+    {\n         // Parse all of the lint attributes, and then add them all to the\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n@@ -528,7 +530,9 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ids(&mut self, f: |&mut ast_util::IdVisitor<Context>|) {\n+    fn visit_ids<F>(&mut self, f: F) where\n+        F: FnOnce(&mut ast_util::IdVisitor<Context>)\n+    {\n         let mut v = ast_util::IdVisitor {\n             operation: self,\n             pass_through_items: false,"}, {"sha": "4cbb1babf9a2cbf8e9b5bc01790a8b14e78f440d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -47,20 +47,22 @@ pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> String {\n }\n \n /// Iterates over all the language items in the given crate.\n-pub fn each_lang_item(cstore: &cstore::CStore,\n-                      cnum: ast::CrateNum,\n-                      f: |ast::NodeId, uint| -> bool)\n-                      -> bool {\n+pub fn each_lang_item<F>(cstore: &cstore::CStore,\n+                         cnum: ast::CrateNum,\n+                         f: F)\n+                         -> bool where\n+    F: FnMut(ast::NodeId, uint) -> bool,\n+{\n     let crate_data = cstore.get_crate_data(cnum);\n     decoder::each_lang_item(&*crate_data, f)\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(cstore: &cstore::CStore,\n-                          def_id: ast::DefId,\n-                          callback: |decoder::DefLike,\n-                                     ast::Name,\n-                                     ast::Visibility|) {\n+pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n+                             def_id: ast::DefId,\n+                             callback: F) where\n+    F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n+{\n     let crate_data = cstore.get_crate_data(def_id.krate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n@@ -73,11 +75,11 @@ pub fn each_child_of_item(cstore: &cstore::CStore,\n }\n \n /// Iterates over each top-level crate item.\n-pub fn each_top_level_item_of_crate(cstore: &cstore::CStore,\n-                                    cnum: ast::CrateNum,\n-                                    callback: |decoder::DefLike,\n-                                               ast::Name,\n-                                               ast::Visibility|) {\n+pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n+                                       cnum: ast::CrateNum,\n+                                       callback: F) where\n+    F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n+{\n     let crate_data = cstore.get_crate_data(cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n@@ -195,9 +197,11 @@ pub fn get_methods_if_impl(cstore: &cstore::CStore,\n     decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n }\n \n-pub fn get_item_attrs(cstore: &cstore::CStore,\n-                      def_id: ast::DefId,\n-                      f: |Vec<ast::Attribute>|) {\n+pub fn get_item_attrs<F>(cstore: &cstore::CStore,\n+                         def_id: ast::DefId,\n+                         f: F) where\n+    F: FnOnce(Vec<ast::Attribute>),\n+{\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(&*cdata, def_id.node, f)\n }\n@@ -279,23 +283,29 @@ pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n     decoder::get_native_libraries(&*cdata)\n }\n \n-pub fn each_impl(cstore: &cstore::CStore,\n-                 crate_num: ast::CrateNum,\n-                 callback: |ast::DefId|) {\n+pub fn each_impl<F>(cstore: &cstore::CStore,\n+                    crate_num: ast::CrateNum,\n+                    callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::each_impl(&*cdata, callback)\n }\n \n-pub fn each_implementation_for_type(cstore: &cstore::CStore,\n-                                    def_id: ast::DefId,\n-                                    callback: |ast::DefId|) {\n+pub fn each_implementation_for_type<F>(cstore: &cstore::CStore,\n+                                       def_id: ast::DefId,\n+                                       callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_implementation_for_type(&*cdata, def_id.node, callback)\n }\n \n-pub fn each_implementation_for_trait(cstore: &cstore::CStore,\n-                                     def_id: ast::DefId,\n-                                     callback: |ast::DefId|) {\n+pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n+                                        def_id: ast::DefId,\n+                                        callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_implementation_for_trait(&*cdata, def_id.node, callback)\n }"}, {"sha": "c0642f29abc90fe534c55f6d76d9ea168345df2c", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -113,16 +113,18 @@ impl CStore {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n-    pub fn iter_crate_data(&self, i: |ast::CrateNum, &crate_metadata|) {\n+    pub fn iter_crate_data<I>(&self, mut i: I) where\n+        I: FnMut(ast::CrateNum, &crate_metadata),\n+    {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, &**v);\n         }\n     }\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n-    pub fn iter_crate_data_origins(&self, i: |ast::CrateNum,\n-                                              &crate_metadata,\n-                                              Option<CrateSource>|) {\n+    pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n+        I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n+    {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.get_used_crate_source(k);\n             origin.as_ref().map(|cs| { assert!(k == cs.cnum); });"}, {"sha": "4e892f53186bc2d9808584fd587f3fad52858fdf", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 43, "deletions": 30, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -60,8 +60,9 @@ pub type Cmd<'a> = &'a crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash<'a>(d: rbml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n-                   hash: u64) -> Option<rbml::Doc<'a>> {\n+fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml::Doc<'a>> where\n+    F: FnMut(&[u8]) -> bool,\n+{\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n@@ -448,7 +449,9 @@ pub enum DefLike {\n impl Copy for DefLike {}\n \n /// Iterates over the language items in the given crate.\n-pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n+pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n+    F: FnMut(ast::NodeId, uint) -> bool,\n+{\n     let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n@@ -464,13 +467,13 @@ pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n \n pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Rc<crate_metadata>;\n \n-fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n-                               cdata: Cmd,\n-                               item_doc: rbml::Doc,\n-                               get_crate_data: GetCrateDataCb,\n-                               callback: |DefLike,\n-                                          ast::Name,\n-                                          ast::Visibility|) {\n+fn each_child_of_item_or_crate<F>(intr: Rc<IdentInterner>,\n+                                  cdata: Cmd,\n+                                  item_doc: rbml::Doc,\n+                                  get_crate_data: GetCrateDataCb,\n+                                  mut callback: F) where\n+    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+{\n     // Iterate over all children.\n     let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n@@ -583,11 +586,13 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(intr: Rc<IdentInterner>,\n-                          cdata: Cmd,\n-                          id: ast::NodeId,\n-                          get_crate_data: GetCrateDataCb,\n-                          callback: |DefLike, ast::Name, ast::Visibility|) {\n+pub fn each_child_of_item<F>(intr: Rc<IdentInterner>,\n+                             cdata: Cmd,\n+                             id: ast::NodeId,\n+                             get_crate_data: GetCrateDataCb,\n+                             callback: F) where\n+    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+{\n     // Find the item.\n     let root_doc = rbml::Doc::new(cdata.data());\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -604,12 +609,12 @@ pub fn each_child_of_item(intr: Rc<IdentInterner>,\n }\n \n /// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate(intr: Rc<IdentInterner>,\n-                                    cdata: Cmd,\n-                                    get_crate_data: GetCrateDataCb,\n-                                    callback: |DefLike,\n-                                               ast::Name,\n-                                               ast::Visibility|) {\n+pub fn each_top_level_item_of_crate<F>(intr: Rc<IdentInterner>,\n+                                       cdata: Cmd,\n+                                       get_crate_data: GetCrateDataCb,\n+                                       callback: F) where\n+    F: FnMut(DefLike, ast::Name, ast::Visibility),\n+{\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n@@ -982,9 +987,11 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n     ret\n }\n \n-pub fn get_item_attrs(cdata: Cmd,\n-                      orig_node_id: ast::NodeId,\n-                      f: |Vec<ast::Attribute>|) {\n+pub fn get_item_attrs<F>(cdata: Cmd,\n+                         orig_node_id: ast::NodeId,\n+                         f: F) where\n+    F: FnOnce(Vec<ast::Attribute>),\n+{\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n@@ -1224,17 +1231,21 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n     }\n }\n \n-pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n+pub fn each_impl<F>(cdata: Cmd, mut callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n     let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n     });\n }\n \n-pub fn each_implementation_for_type(cdata: Cmd,\n+pub fn each_implementation_for_type<F>(cdata: Cmd,\n                                     id: ast::NodeId,\n-                                    callback: |ast::DefId|) {\n+                                    mut callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc,\n                         tag_items_data_item_inherent_impl,\n@@ -1245,9 +1256,11 @@ pub fn each_implementation_for_type(cdata: Cmd,\n     });\n }\n \n-pub fn each_implementation_for_trait(cdata: Cmd,\n-                                     id: ast::NodeId,\n-                                     callback: |ast::DefId|) {\n+pub fn each_implementation_for_trait<F>(cdata: Cmd,\n+                                        id: ast::NodeId,\n+                                        mut callback: F) where\n+    F: FnMut(ast::DefId),\n+{\n     let item_doc = lookup_item(id, cdata.data());\n \n     let _ = reader::tagged_docs(item_doc,"}, {"sha": "9804e3c20aa35c764c90043f51e2784c01157871", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -493,7 +493,9 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// top-level items that are sub-items of the given item. Specifically:\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: &ast::Item, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id<F>(item: &ast::Item, callback: F) -> bool where\n+    F: FnOnce(NodeId) -> bool,\n+{\n     let mut continue_ = true;\n     match item.node {\n         ast::ItemStruct(ref struct_def, _) => {\n@@ -1579,8 +1581,10 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n // Path and definition ID indexing\n \n-fn encode_index<T: Hash>(rbml_w: &mut Encoder, index: Vec<entry<T>>,\n-                         write_fn: |&mut SeekableMemWriter, &T|) {\n+fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n+    F: FnMut(&mut SeekableMemWriter, &T),\n+    T: Hash,\n+{\n     let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;"}, {"sha": "507fb751303f9fcff5161db02295d18b1f66e604", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -42,7 +42,9 @@ pub struct FileSearch<'a> {\n }\n \n impl<'a> FileSearch<'a> {\n-    pub fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch) {\n+    pub fn for_each_lib_search_path<F>(&self, mut f: F) where\n+        F: FnMut(&Path) -> FileMatch,\n+    {\n         let mut visited_dirs = HashSet::new();\n         let mut found = false;\n "}, {"sha": "7358b3bc9c969d3fab3ae284dea734523b0ba5ad", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -89,7 +89,10 @@ fn next_byte(st: &mut PState) -> u8 {\n     return b;\n }\n \n-fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n+fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n+    F: FnMut(char) -> bool,\n+    G: FnOnce(&[u8]) -> R,\n+{\n     let start_pos = st.pos;\n     debug!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n     while !is_last(st.data[st.pos] as char) {\n@@ -110,7 +113,9 @@ pub fn parse_name(st: &mut PState, last: char) -> ast::Name {\n     parse_name_(st, |a| is_last(last, a) )\n }\n \n-fn parse_name_(st: &mut PState, is_last: |char| -> bool) -> ast::Name {\n+fn parse_name_<F>(st: &mut PState, is_last: F) -> ast::Name where\n+    F: FnMut(char) -> bool,\n+{\n     scan(st, is_last, |bytes| {\n         token::intern(str::from_utf8(bytes).unwrap())\n     })\n@@ -234,9 +239,10 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     }\n }\n \n-fn parse_vec_per_param_space<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>,\n-                                          f: |&mut PState<'a, 'tcx>| -> T)\n-                                          -> VecPerParamSpace<T>\n+fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n+                                             mut f: F)\n+                                             -> VecPerParamSpace<T> where\n+    F: FnMut(&mut PState<'a, 'tcx>) -> T,\n {\n     let mut r = VecPerParamSpace::empty();\n     for &space in subst::ParamSpace::all().iter() {\n@@ -350,8 +356,9 @@ fn parse_scope(st: &mut PState) -> region::CodeExtent {\n     }\n }\n \n-fn parse_opt<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>, f: |&mut PState<'a, 'tcx>| -> T)\n-                          -> Option<T> {\n+fn parse_opt<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>, f: F) -> Option<T> where\n+    F: FnOnce(&mut PState<'a, 'tcx>) -> T,\n+{\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),"}, {"sha": "54376cd7b9078e6d651ee4abf80370650c93c205", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -86,7 +86,9 @@ fn enc_mt<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: |&mut SeekableMemWriter, T|) {\n+fn enc_opt<T, F>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: F) where\n+    F: FnOnce(&mut SeekableMemWriter, T),\n+{\n     match t {\n         None => mywrite!(w, \"n\"),\n         Some(v) => {\n@@ -96,10 +98,12 @@ fn enc_opt<T>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: |&mut SeekableMemW\n     }\n }\n \n-fn enc_vec_per_param_space<'a, 'tcx, T>(w: &mut SeekableMemWriter,\n-                                        cx: &ctxt<'a, 'tcx>,\n-                                        v: &VecPerParamSpace<T>,\n-                                        op: |&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T|) {\n+fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut SeekableMemWriter,\n+                                           cx: &ctxt<'a, 'tcx>,\n+                                           v: &VecPerParamSpace<T>,\n+                                           mut op: F) where\n+    F: FnMut(&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T),\n+{\n     for &space in subst::ParamSpace::all().iter() {\n         mywrite!(w, \"[\");\n         for t in v.get_slice(space).iter() {"}, {"sha": "26d70502a5b1677cb01b3970f850d70b849f3de8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -680,9 +680,8 @@ pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n }\n \n pub trait vtable_decoder_helpers<'tcx> {\n-    fn read_vec_per_param_space<T>(&mut self,\n-                                   f: |&mut Self| -> T)\n-                                   -> VecPerParamSpace<T>;\n+    fn read_vec_per_param_space<T, F>(&mut self, f: F) -> VecPerParamSpace<T> where\n+        F: FnMut(&mut Self) -> T;\n     fn read_vtable_res_with_key(&mut self,\n                                 tcx: &ty::ctxt<'tcx>,\n                                 cdata: &cstore::crate_metadata)\n@@ -699,9 +698,8 @@ pub trait vtable_decoder_helpers<'tcx> {\n }\n \n impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n-    fn read_vec_per_param_space<T>(&mut self,\n-                                   f: |&mut reader::Decoder<'a>| -> T)\n-                                   -> VecPerParamSpace<T>\n+    fn read_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n+        F: FnMut(&mut reader::Decoder<'a>) -> T,\n     {\n         let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n@@ -793,9 +791,11 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n // ___________________________________________________________________________\n //\n \n-fn encode_vec_per_param_space<T>(rbml_w: &mut Encoder,\n-                                 v: &subst::VecPerParamSpace<T>,\n-                                 f: |&mut Encoder, &T|) {\n+fn encode_vec_per_param_space<T, F>(rbml_w: &mut Encoder,\n+                                    v: &subst::VecPerParamSpace<T>,\n+                                    mut f: F) where\n+    F: FnMut(&mut Encoder, &T),\n+{\n     for &space in subst::ParamSpace::all().iter() {\n         rbml_w.emit_from_vec(v.get_slice(space),\n                              |rbml_w, n| Ok(f(rbml_w, n))).unwrap();\n@@ -1124,14 +1124,16 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n }\n \n trait write_tag_and_id {\n-    fn tag(&mut self, tag_id: c::astencode_tag, f: |&mut Self|);\n+    fn tag<F>(&mut self, tag_id: c::astencode_tag, f: F) where F: FnOnce(&mut Self);\n     fn id(&mut self, id: ast::NodeId);\n }\n \n impl<'a> write_tag_and_id for Encoder<'a> {\n-    fn tag(&mut self,\n-           tag_id: c::astencode_tag,\n-           f: |&mut Encoder<'a>|) {\n+    fn tag<F>(&mut self,\n+              tag_id: c::astencode_tag,\n+              f: F) where\n+        F: FnOnce(&mut Encoder<'a>),\n+    {\n         self.start_tag(tag_id as uint);\n         f(self);\n         self.end_tag();"}, {"sha": "a91ea8bfef8c77d93bd793ea0376c4b3fc054456", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -24,16 +24,22 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    fn with_const(&mut self, in_const: bool, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+    fn with_const<F>(&mut self, in_const: bool, f: F) where\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+    {\n         let was_const = self.in_const;\n         self.in_const = in_const;\n         f(self);\n         self.in_const = was_const;\n     }\n-    fn inside_const(&mut self, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+    fn inside_const<F>(&mut self, f: F) where\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+    {\n         self.with_const(true, f);\n     }\n-    fn outside_const(&mut self, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+    fn outside_const<F>(&mut self, f: F) where\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+    {\n         self.with_const(false, f);\n     }\n }"}, {"sha": "fee2d810fcb3dace18ad10917f3ddee04d83809d", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -64,7 +64,9 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n }\n \n impl<'a> CheckLoopVisitor<'a> {\n-    fn with_context(&mut self, cx: Context, f: |&mut CheckLoopVisitor<'a>|) {\n+    fn with_context<F>(&mut self, cx: Context, f: F) where\n+        F: FnOnce(&mut CheckLoopVisitor<'a>),\n+    {\n         let old_cx = self.cx;\n         self.cx = cx;\n         f(self);"}, {"sha": "ea3ef2af7390612b46020116e5f4d6020b0a959e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -980,7 +980,9 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n     }\n }\n \n-fn is_refutable<A>(cx: &MatchCheckCtxt, pat: &Pat, refutable: |&Pat| -> A) -> Option<A> {\n+fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A> where\n+    F: FnOnce(&Pat) -> A,\n+{\n     let pats = Matrix(vec!(vec!(pat)));\n     match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {"}, {"sha": "65412ff8effc96c5547f9213e409a51da80113de", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -85,7 +85,9 @@ pub fn check_crate(tcx: &ty::ctxt) {\n }\n \n impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n-    fn with_mode(&mut self, mode: Mode, f: |&mut CheckStaticVisitor<'a, 'tcx>|) {\n+    fn with_mode<F>(&mut self, mode: Mode, f: F) where\n+        F: FnOnce(&mut CheckStaticVisitor<'a, 'tcx>),\n+    {\n         let old = self.mode;\n         self.mode = mode;\n         f(self);"}, {"sha": "9373a5704b2b0b6401a9a2cf5c7725b0064d9732", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -280,10 +280,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n \n-    pub fn each_bit_on_entry(&self,\n-                             id: ast::NodeId,\n-                             f: |uint| -> bool)\n-                             -> bool {\n+    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, f: F) -> bool where\n+        F: FnMut(uint) -> bool,\n+    {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n@@ -293,11 +292,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit_for_node(Entry, cfgidx, f)\n     }\n \n-    pub fn each_bit_for_node(&self,\n-                             e: EntryOrExit,\n-                             cfgidx: CFGIndex,\n-                             f: |uint| -> bool)\n-                             -> bool {\n+    pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n+        F: FnMut(uint) -> bool,\n+    {\n         //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n         //! Only useful after `propagate()` has been called.\n \n@@ -324,8 +321,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit(&self, id: ast::NodeId, f: |uint| -> bool)\n-                        -> bool {\n+    pub fn each_gen_bit<F>(&self, id: ast::NodeId, f: F) -> bool where\n+        F: FnMut(uint) -> bool,\n+    {\n         //! Iterates through each bit in the gen set for `id`.\n         if !self.has_bitset_for_nodeid(id) {\n             return true;\n@@ -345,7 +343,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(gens, f)\n     }\n \n-    fn each_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {\n+    fn each_bit<F>(&self, words: &[uint], mut f: F) -> bool where\n+        F: FnMut(uint) -> bool,\n+    {\n         //! Helper for iterating over the bits in a bit set.\n         //! Returns false on the first call to `f` that returns false;\n         //! if all calls to `f` return true, then returns true."}, {"sha": "ca60ac45e266a8bafe98148a80e281fb01ff52eb", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -61,7 +61,9 @@ pub enum MethodProvenance {\n }\n \n impl MethodProvenance {\n-    pub fn map(self, f: |ast::DefId| -> ast::DefId) -> MethodProvenance {\n+    pub fn map<F>(self, f: F) -> MethodProvenance where\n+        F: FnOnce(ast::DefId) -> ast::DefId,\n+    {\n         match self {\n             FromTrait(did) => FromTrait(f(did)),\n             FromImpl(did) => FromImpl(f(did))"}, {"sha": "4c03ed2a480efd501949706acfdb706ee2884756", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -221,39 +221,43 @@ impl<N,E> Graph<N,E> {\n     ///////////////////////////////////////////////////////////////////////////\n     // Iterating over nodes, edges\n \n-    pub fn each_node<'a>(&'a self, f: |NodeIndex, &'a Node<N>| -> bool) -> bool {\n+    pub fn each_node<'a, F>(&'a self, mut f: F) -> bool where\n+        F: FnMut(NodeIndex, &'a Node<N>) -> bool,\n+    {\n         //! Iterates over all edges defined in the graph.\n         self.nodes.iter().enumerate().all(|(i, node)| f(NodeIndex(i), node))\n     }\n \n-    pub fn each_edge<'a>(&'a self, f: |EdgeIndex, &'a Edge<E>| -> bool) -> bool {\n+    pub fn each_edge<'a, F>(&'a self, mut f: F) -> bool where\n+        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         //! Iterates over all edges defined in the graph\n         self.edges.iter().enumerate().all(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n-    pub fn each_outgoing_edge<'a>(&'a self,\n-                                  source: NodeIndex,\n-                                  f: |EdgeIndex, &'a Edge<E>| -> bool)\n-                                  -> bool {\n+    pub fn each_outgoing_edge<'a, F>(&'a self, source: NodeIndex, f: F) -> bool where\n+        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         //! Iterates over all outgoing edges from the node `from`\n \n         self.each_adjacent_edge(source, Outgoing, f)\n     }\n \n-    pub fn each_incoming_edge<'a>(&'a self,\n-                                  target: NodeIndex,\n-                                  f: |EdgeIndex, &'a Edge<E>| -> bool)\n-                                  -> bool {\n+    pub fn each_incoming_edge<'a, F>(&'a self, target: NodeIndex, f: F) -> bool where\n+        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         //! Iterates over all incoming edges to the node `target`\n \n         self.each_adjacent_edge(target, Incoming, f)\n     }\n \n-    pub fn each_adjacent_edge<'a>(&'a self,\n-                                  node: NodeIndex,\n-                                  dir: Direction,\n-                                  f: |EdgeIndex, &'a Edge<E>| -> bool)\n-                                  -> bool {\n+    pub fn each_adjacent_edge<'a, F>(&'a self,\n+                                     node: NodeIndex,\n+                                     dir: Direction,\n+                                     mut f: F)\n+                                     -> bool where\n+        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         //! Iterates over all edges adjacent to the node `node`\n         //! in the direction `dir` (either `Outgoing` or `Incoming)\n \n@@ -277,11 +281,9 @@ impl<N,E> Graph<N,E> {\n     // variables or other bitsets. This method facilitates such a\n     // computation.\n \n-    pub fn iterate_until_fixed_point<'a>(&'a self,\n-                                         op: |iter_index: uint,\n-                                              edge_index: EdgeIndex,\n-                                              edge: &'a Edge<E>|\n-                                              -> bool) {\n+    pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F) where\n+        F: FnMut(uint, EdgeIndex, &'a Edge<E>) -> bool,\n+    {\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n@@ -294,7 +296,9 @@ impl<N,E> Graph<N,E> {\n     }\n }\n \n-pub fn each_edge_index(max_edge_index: EdgeIndex, f: |EdgeIndex| -> bool) {\n+pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F) where\n+    F: FnMut(EdgeIndex) -> bool,\n+{\n     let mut i = 0;\n     let n = max_edge_index.get();\n     while i < n {"}, {"sha": "c6422b36e384d43a18cdf4de85cd418d665d47f8", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -194,8 +194,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n     }\n \n-    pub fn unpack_actual_value<T>(&self, a: Ty<'tcx>, f: |&ty::sty<'tcx>| -> T)\n-                                  -> T {\n+    pub fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n+        F: FnOnce(&ty::sty<'tcx>) -> T,\n+    {\n         match resolve_type(self.get_ref().infcx, None,\n                            a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n@@ -458,13 +459,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                            || AutoUnsafe(b_mutbl, None))\n     }\n \n-    fn coerce_object(&self,\n-                     a: Ty<'tcx>,\n-                     sty_a: &ty::sty<'tcx>,\n-                     b: Ty<'tcx>,\n-                     b_mutbl: ast::Mutability,\n-                     mk_ty: |Ty<'tcx>| -> Ty<'tcx>,\n-                     mk_adjust: || -> ty::AutoRef<'tcx>) -> CoerceResult<'tcx>\n+    fn coerce_object<F, G>(&self,\n+                           a: Ty<'tcx>,\n+                           sty_a: &ty::sty<'tcx>,\n+                           b: Ty<'tcx>,\n+                           b_mutbl: ast::Mutability,\n+                           mk_ty: F,\n+                           mk_adjust: G) -> CoerceResult<'tcx> where\n+        F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n+        G: FnOnce() -> ty::AutoRef<'tcx>,\n     {\n         let tcx = self.get_ref().infcx.tcx;\n "}, {"sha": "be053afcca43660574a93cf6e75ae7ea13c416a4", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -426,11 +426,9 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<'tcx, T>(tcx: &ty::ctxt<'tcx>,\n-                            value: &T,\n-                            fldr: |ty::Region, ty::DebruijnIndex| -> ty::Region)\n-                            -> T\n-    where T: HigherRankedFoldable<'tcx>\n+fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>, value: &T, mut fldr: F) -> T where\n+    T: HigherRankedFoldable<'tcx>,\n+    F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n     value.fold_contents(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,"}, {"sha": "4c3b7589d76cbb59cc4c65e1005ea6954458f419", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -477,14 +477,17 @@ pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n }\n \n trait then<'tcx> {\n-    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err<'tcx>>)\n-        -> Result<T,ty::type_err<'tcx>>;\n+    fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n+        T: Clone,\n+        F: FnOnce() -> Result<T, ty::type_err<'tcx>>;\n }\n \n impl<'tcx> then<'tcx> for ures<'tcx> {\n-    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err<'tcx>>)\n-        -> Result<T,ty::type_err<'tcx>> {\n-        self.and_then(|_i| f())\n+    fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n+        T: Clone,\n+        F: FnOnce() -> Result<T, ty::type_err<'tcx>>,\n+    {\n+        self.and_then(move |_| f())\n     }\n }\n \n@@ -502,12 +505,15 @@ impl<'tcx, T> ToUres<'tcx> for cres<'tcx, T> {\n }\n \n trait CresCompare<'tcx, T> {\n-    fn compare(&self, t: T, f: || -> ty::type_err<'tcx>) -> cres<'tcx, T>;\n+    fn compare<F>(&self, t: T, f: F) -> cres<'tcx, T> where\n+        F: FnOnce() -> ty::type_err<'tcx>;\n }\n \n impl<'tcx, T:Clone + PartialEq> CresCompare<'tcx, T> for cres<'tcx, T> {\n-    fn compare(&self, t: T, f: || -> ty::type_err<'tcx>) -> cres<'tcx, T> {\n-        (*self).clone().and_then(|s| {\n+    fn compare<F>(&self, t: T, f: F) -> cres<'tcx, T> where\n+        F: FnOnce() -> ty::type_err<'tcx>,\n+    {\n+        (*self).clone().and_then(move |s| {\n             if s == t {\n                 (*self).clone()\n             } else {\n@@ -616,7 +622,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings\n-    pub fn commit_unconditionally<R>(&self, f: || -> R) -> R {\n+    pub fn commit_unconditionally<R, F>(&self, f: F) -> R where\n+        F: FnOnce() -> R,\n+    {\n         debug!(\"commit()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -625,12 +633,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    pub fn commit_if_ok<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n-        self.commit_unconditionally(|| self.try(|| f()))\n+    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>\n+    {\n+        self.commit_unconditionally(move || self.try(move || f()))\n     }\n \n     /// Execute `f`, unroll bindings on panic\n-    pub fn try<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>\n+    {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -647,7 +659,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<R>(&self, f: || -> R) -> R {\n+    pub fn probe<R, F>(&self, f: F) -> R where\n+        F: FnOnce() -> R,\n+    {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -902,22 +916,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these four methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str(&self,\n-                                  sp: Span,\n-                                  mk_msg: |Option<String>, String| -> String,\n-                                  actual_ty: String,\n-                                  err: Option<&ty::type_err<'tcx>>) {\n+    pub fn type_error_message_str<M>(&self,\n+                                     sp: Span,\n+                                     mk_msg: M,\n+                                     actual_ty: String,\n+                                     err: Option<&ty::type_err<'tcx>>) where\n+        M: FnOnce(Option<String>, String) -> String,\n+    {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n-    pub fn type_error_message_str_with_expected(&self,\n-                                                sp: Span,\n-                                                mk_msg: |Option<String>,\n-                                                         String|\n-                                                         -> String,\n-                                                expected_ty: Option<Ty<'tcx>>,\n-                                                actual_ty: String,\n-                                                err: Option<&ty::type_err<'tcx>>) {\n+    pub fn type_error_message_str_with_expected<M>(&self,\n+                                                   sp: Span,\n+                                                   mk_msg: M,\n+                                                   expected_ty: Option<Ty<'tcx>>,\n+                                                   actual_ty: String,\n+                                                   err: Option<&ty::type_err<'tcx>>) where\n+        M: FnOnce(Option<String>, String) -> String,\n+    {\n         debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let resolved_expected = expected_ty.map(|e_ty| {\n@@ -942,19 +958,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn type_error_message(&self,\n-                              sp: Span,\n-                              mk_msg: |String| -> String,\n-                              actual_ty: Ty<'tcx>,\n-                              err: Option<&ty::type_err<'tcx>>) {\n+    pub fn type_error_message<M>(&self,\n+                                 sp: Span,\n+                                 mk_msg: M,\n+                                 actual_ty: Ty<'tcx>,\n+                                 err: Option<&ty::type_err<'tcx>>) where\n+        M: FnOnce(String) -> String,\n+    {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n         if ty::type_is_error(actual_ty) {\n             return;\n         }\n \n-        self.type_error_message_str(sp, |_e, a| { mk_msg(a) }, self.ty_to_string(actual_ty), err);\n+        self.type_error_message_str(sp,\n+            move |_e, a| { mk_msg(a) },\n+            self.ty_to_string(actual_ty), err);\n     }\n \n     pub fn report_mismatched_types(&self,"}, {"sha": "98f69f66b27fc4536b91d96947e1db8dff1442c0", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -569,15 +569,15 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    pub fn combine_vars(&self,\n-                        t: CombineMapType,\n-                        a: Region,\n-                        b: Region,\n-                        origin: SubregionOrigin<'tcx>,\n-                        relate: |this: &RegionVarBindings<'a, 'tcx>,\n-                                 old_r: Region,\n-                                 new_r: Region|)\n-                        -> Region {\n+    pub fn combine_vars<F>(&self,\n+                           t: CombineMapType,\n+                           a: Region,\n+                           b: Region,\n+                           origin: SubregionOrigin<'tcx>,\n+                           mut relate: F)\n+                           -> Region where\n+        F: FnMut(&RegionVarBindings<'a, 'tcx>, Region, Region),\n+    {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).borrow().get(&vars) {\n             Some(&c) => {\n@@ -1539,9 +1539,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    fn iterate_until_fixed_point(&self,\n-                                 tag: &str,\n-                                 body: |constraint: &Constraint| -> bool) {\n+    fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F) where\n+        F: FnMut(&Constraint) -> bool,\n+    {\n         let mut iteration = 0u;\n         let mut changed = true;\n         while changed {"}, {"sha": "705b0ae730d498070c5b1374ee4ef068c9f9c6d5", "filename": "src/librustc/middle/infer/skolemize.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fskolemize.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -54,11 +54,12 @@ impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n         }\n     }\n \n-    fn skolemize(&mut self,\n-                 opt_ty: Option<Ty<'tcx>>,\n-                 key: ty::InferTy,\n-                 skolemizer: |uint| -> ty::InferTy)\n-                 -> Ty<'tcx>\n+    fn skolemize<F>(&mut self,\n+                    opt_ty: Option<Ty<'tcx>>,\n+                    key: ty::InferTy,\n+                    skolemizer: F)\n+                    -> Ty<'tcx> where\n+        F: FnOnce(uint) -> ty::InferTy,\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }"}, {"sha": "271e903bbdf1761feff735b8715788f8e106faa5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -616,19 +616,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.ir.variable(node_id, span)\n     }\n \n-    fn pat_bindings(&mut self,\n-                    pat: &ast::Pat,\n-                    f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n+    fn pat_bindings<F>(&mut self, pat: &ast::Pat, mut f: F) where\n+        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n+    {\n         pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n         })\n     }\n \n-    fn arm_pats_bindings(&mut self,\n-                         pat: Option<&ast::Pat>,\n-                         f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n+    fn arm_pats_bindings<F>(&mut self, pat: Option<&ast::Pat>, f: F) where\n+        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n+    {\n         match pat {\n             Some(pat) => {\n                 self.pat_bindings(pat, f);\n@@ -691,21 +691,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.assigned_on_entry(successor, var)\n     }\n \n-    fn indices2(&mut self,\n-                ln: LiveNode,\n-                succ_ln: LiveNode,\n-                op: |&mut Liveness<'a, 'tcx>, uint, uint|) {\n+    fn indices2<F>(&mut self, ln: LiveNode, succ_ln: LiveNode, mut op: F) where\n+        F: FnMut(&mut Liveness<'a, 'tcx>, uint, uint),\n+    {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for var_idx in range(0u, self.ir.num_vars) {\n             op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n \n-    fn write_vars(&self,\n-                  wr: &mut io::Writer,\n-                  ln: LiveNode,\n-                  test: |uint| -> LiveNode) -> io::IoResult<()> {\n+    fn write_vars<F>(&self,\n+                     wr: &mut io::Writer,\n+                     ln: LiveNode,\n+                     mut test: F)\n+                     -> io::IoResult<()> where\n+        F: FnMut(uint) -> LiveNode,\n+    {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n@@ -1408,12 +1410,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         cond_ln\n     }\n \n-    fn with_loop_nodes<R>(&mut self,\n-                          loop_node_id: NodeId,\n-                          break_ln: LiveNode,\n-                          cont_ln: LiveNode,\n-                          f: |&mut Liveness<'a, 'tcx>| -> R)\n-                          -> R {\n+    fn with_loop_nodes<R, F>(&mut self,\n+                             loop_node_id: NodeId,\n+                             break_ln: LiveNode,\n+                             cont_ln: LiveNode,\n+                             f: F)\n+                             -> R where\n+        F: FnOnce(&mut Liveness<'a, 'tcx>) -> R,\n+    {\n         debug!(\"with_loop_nodes: {} {}\", loop_node_id, break_ln.get());\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);"}, {"sha": "d96cf4495bdde95b0ab624606776aef7f0832531", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -1142,12 +1142,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         })\n     }\n \n+    // FIXME(#19596) unbox `op`\n     pub fn cat_pattern(&self,\n                        cmt: cmt<'tcx>,\n                        pat: &ast::Pat,\n-                       op: |&MemCategorizationContext<'t,TYPER>,\n-                            cmt<'tcx>,\n-                            &ast::Pat|)\n+                       op: |&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat|)\n                        -> McResult<()> {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against."}, {"sha": "8ef8e091c94858aeda905d049380ae50944c6c66", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -91,9 +91,9 @@ pub fn pat_is_binding_or_wild(dm: &resolve::DefMap, pat: &ast::Pat) -> bool {\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings(dm: &resolve::DefMap,\n-                    pat: &ast::Pat,\n-                    it: |ast::BindingMode, ast::NodeId, Span, &ast::SpannedIdent|) {\n+pub fn pat_bindings<I>(dm: &resolve::DefMap, pat: &ast::Pat, mut it: I) where\n+    I: FnMut(ast::BindingMode, ast::NodeId, Span, &ast::SpannedIdent),\n+{\n     walk_pat(pat, |p| {\n         match p.node {\n           ast::PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {"}, {"sha": "390729df0125d1ba7a5241354e5a5114f7dd5e9a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -62,7 +62,9 @@ impl CodeExtent {\n \n     /// Maps this scope to a potentially new one according to the\n     /// NodeId transformer `f_id`.\n-    pub fn map_id(&self, f_id: |ast::NodeId| -> ast::NodeId) -> CodeExtent {\n+    pub fn map_id<F>(&self, f_id: F) -> CodeExtent where\n+        F: FnOnce(ast::NodeId) -> ast::NodeId,\n+    {\n         match *self {\n             CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n         }"}, {"sha": "85e0c9294a6baeb87294dc5f26a3252945dad165", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -1837,10 +1837,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self,\n-                                            foreign_item: &ForeignItem,\n-                                            parent: ReducedGraphParent,\n-                                            f: |&mut Resolver|) {\n+    fn build_reduced_graph_for_foreign_item<F>(&mut self,\n+                                               foreign_item: &ForeignItem,\n+                                               parent: ReducedGraphParent,\n+                                               f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n@@ -3970,7 +3972,9 @@ impl<'a> Resolver<'a> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(&mut self, name: Option<Name>, f: |&mut Resolver|) {\n+    fn with_scope<F>(&mut self, name: Option<Name>, f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         let orig_module = self.current_module.clone();\n \n         // Move down in the graph.\n@@ -4373,9 +4377,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_type_parameter_rib(&mut self,\n-                               type_parameters: TypeParameters,\n-                               f: |&mut Resolver|) {\n+    fn with_type_parameter_rib<F>(&mut self, type_parameters: TypeParameters, f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         match type_parameters {\n             HasTypeParameters(generics, space, node_id, rib_kind) => {\n                 let mut function_type_rib = Rib::new(rib_kind);\n@@ -4422,13 +4426,17 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_label_rib(&mut self, f: |&mut Resolver|) {\n+    fn with_label_rib<F>(&mut self, f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         self.label_ribs.push(Rib::new(NormalRibKind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n-    fn with_constant_rib(&mut self, f: |&mut Resolver|) {\n+    fn with_constant_rib<F>(&mut self, f: F) where\n+        F: FnOnce(&mut Resolver),\n+    {\n         self.value_ribs.push(Rib::new(ConstantItemRibKind));\n         self.type_ribs.push(Rib::new(ConstantItemRibKind));\n         f(self);\n@@ -4676,17 +4684,21 @@ impl<'a> Resolver<'a> {\n                               method.pe_body());\n     }\n \n-    fn with_current_self_type<T>(&mut self, self_type: &Ty, f: |&mut Resolver| -> T) -> T {\n+    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T where\n+        F: FnOnce(&mut Resolver) -> T,\n+    {\n         // Handle nested impls (inside fn bodies)\n         let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n         let result = f(self);\n         self.current_self_type = previous_value;\n         result\n     }\n \n-    fn with_optional_trait_ref<T>(&mut self, id: NodeId,\n-                                  opt_trait_ref: &Option<TraitRef>,\n-                                  f: |&mut Resolver| -> T) -> T {\n+    fn with_optional_trait_ref<T, F>(&mut self, id: NodeId,\n+                                     opt_trait_ref: &Option<TraitRef>,\n+                                     f: F) -> T where\n+        F: FnOnce(&mut Resolver) -> T,\n+    {\n         let new_val = match *opt_trait_ref {\n             Some(ref trait_ref) => {\n                 self.resolve_trait_reference(id, trait_ref, TraitImplementation);\n@@ -5620,7 +5632,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn with_no_errors<T>(&mut self, f: |&mut Resolver| -> T) -> T {\n+    fn with_no_errors<T, F>(&mut self, f: F) -> T where\n+        F: FnOnce(&mut Resolver) -> T,\n+    {\n         self.emit_errors = false;\n         let rs = f(self);\n         self.emit_errors = true;"}, {"sha": "83332d275ce99ab19a1e27cea656c268dbbce739", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -247,7 +247,9 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n }\n \n impl<'a> LifetimeContext<'a> {\n-    fn with(&mut self, wrap_scope: ScopeChain, f: |&mut LifetimeContext|) {\n+    fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n+        F: FnOnce(&mut LifetimeContext),\n+    {\n         let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n         let mut this = LifetimeContext {\n             sess: sess,\n@@ -278,10 +280,12 @@ impl<'a> LifetimeContext<'a> {\n     /// already in scope (for a fn item, that will be 0, but for a method it might not be). Late\n     /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n     /// ordering is not important there.\n-    fn visit_early_late(&mut self,\n-                        early_space: subst::ParamSpace,\n-                        generics: &ast::Generics,\n-                        walk: |&mut LifetimeContext|) {\n+    fn visit_early_late<F>(&mut self,\n+                           early_space: subst::ParamSpace,\n+                           generics: &ast::Generics,\n+                           walk: F) where\n+        F: FnOnce(&mut LifetimeContext),\n+    {\n         let referenced_idents = early_bound_lifetime_names(generics);\n \n         debug!(\"visit_early_late: referenced_idents={}\",\n@@ -290,8 +294,8 @@ impl<'a> LifetimeContext<'a> {\n         let (early, late) = generics.lifetimes.clone().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n-        self.with(EarlyScope(early_space, &early, self.scope), |this| {\n-            this.with(LateScope(&late, this.scope), |this| {\n+        self.with(EarlyScope(early_space, &early, self.scope), move |this| {\n+            this.with(LateScope(&late, this.scope), move |this| {\n                 this.check_lifetime_defs(&generics.lifetimes);\n                 walk(this);\n             });"}, {"sha": "ca8029fdfca3b418babf952d150a6c8c9d97343b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -43,7 +43,9 @@ struct Annotator {\n impl Annotator {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate(&mut self, id: NodeId, attrs: &Vec<Attribute>, f: |&mut Annotator|) {\n+    fn annotate<F>(&mut self, id: NodeId, attrs: &Vec<Attribute>, f: F) where\n+        F: FnOnce(&mut Annotator),\n+    {\n         match attr::find_stability(attrs.as_slice()) {\n             Some(stab) => {\n                 self.index.local.insert(id, stab.clone());"}, {"sha": "2098aa3db533af673ae4f31110b4c1ca0f766e15", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -167,10 +167,9 @@ impl<'tcx> Substs<'tcx> {\n }\n \n impl RegionSubsts {\n-    fn map<A>(self,\n-              a: A,\n-              op: |VecPerParamSpace<ty::Region>, A| -> VecPerParamSpace<ty::Region>)\n-              -> RegionSubsts {\n+    fn map<A, F>(self, a: A, op: F) -> RegionSubsts where\n+        F: FnOnce(VecPerParamSpace<ty::Region>, A) -> VecPerParamSpace<ty::Region>,\n+    {\n         match self {\n             ErasedRegions => ErasedRegions,\n             NonerasedRegions(r) => NonerasedRegions(op(r, a))\n@@ -415,7 +414,9 @@ impl<T> VecPerParamSpace<T> {\n         self.content.as_slice()\n     }\n \n-    pub fn all_vecs(&self, pred: |&[T]| -> bool) -> bool {\n+    pub fn all_vecs<P>(&self, mut pred: P) -> bool where\n+        P: FnMut(&[T]) -> bool,\n+    {\n         let spaces = [TypeSpace, SelfSpace, FnSpace];\n         spaces.iter().all(|&space| { pred(self.get_slice(space)) })\n     }\n@@ -450,7 +451,9 @@ impl<T> VecPerParamSpace<T> {\n                                        self.assoc_limit)\n     }\n \n-    pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n+    pub fn map_move<U, F>(self, mut pred: F) -> VecPerParamSpace<U> where\n+        F: FnMut(T) -> U,\n+    {\n         let SeparateVecsPerParamSpace {\n             types: t,\n             selfs: s,"}, {"sha": "936304c5eb483d980ad1b0c3d5ee6c2047c05167", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -322,7 +322,9 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<'tcx, M> {\n+    pub fn map_move_nested<M, F>(self, op: F) -> Vtable<'tcx, M> where\n+        F: FnMut(N) -> M,\n+    {\n         match self {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n@@ -348,8 +350,9 @@ impl<'tcx, N> VtableImplData<'tcx, N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M)\n-                              -> VtableImplData<'tcx, M> {\n+    pub fn map_move_nested<M, F>(self, op: F) -> VtableImplData<'tcx, M> where\n+        F: FnMut(N) -> M,\n+    {\n         let VtableImplData { impl_def_id, substs, nested } = self;\n         VtableImplData {\n             impl_def_id: impl_def_id,\n@@ -370,7 +373,9 @@ impl<N> VtableBuiltinData<N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableBuiltinData<M> {\n+    pub fn map_move_nested<M, F>(self, op: F) -> VtableBuiltinData<M> where\n+        F: FnMut(N) -> M,\n+    {\n         VtableBuiltinData {\n             nested: self.nested.map_move(op)\n         }"}, {"sha": "d8956246d326fd41e989bf3c9dafbc8c6b8283ee", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -306,10 +306,11 @@ pub fn predicate_for_builtin_bound<'tcx>(\n /// of caller obligations), search through the trait and supertraits to find one where `test(d)` is\n /// true, where `d` is the def-id of the trait/supertrait. If any is found, return `Some(p)` where\n /// `p` is the path to that trait/supertrait. Else `None`.\n-pub fn search_trait_and_supertraits_from_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                                     caller_bound: Rc<ty::TraitRef<'tcx>>,\n-                                                     test: |ast::DefId| -> bool)\n-                                                     -> Option<VtableParamData<'tcx>>\n+pub fn search_trait_and_supertraits_from_bound<'tcx, F>(tcx: &ty::ctxt<'tcx>,\n+                                                        caller_bound: Rc<ty::TraitRef<'tcx>>,\n+                                                        mut test: F)\n+                                                        -> Option<VtableParamData<'tcx>> where\n+    F: FnMut(ast::DefId) -> bool,\n {\n     for bound in transitive_bounds(tcx, &[caller_bound]) {\n         if test(bound.def_id) {"}, {"sha": "8e99045cffb5831f57978fa9123054ece46ec870", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -2420,10 +2420,13 @@ pub fn mk_param_from_def<'tcx>(cx: &ctxt<'tcx>, def: &TypeParameterDef) -> Ty<'t\n \n pub fn mk_open<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_open(ty)) }\n \n-pub fn walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>|) {\n+pub fn walk_ty<'tcx, F>(ty: Ty<'tcx>, mut f: F) where\n+    F: FnMut(Ty<'tcx>),\n+{\n     maybe_walk_ty(ty, |ty| { f(ty); true });\n }\n \n+// FIXME(#19596) unbox `f`\n pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n     if !f(ty) {\n         return;\n@@ -2464,9 +2467,11 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty<'tcx>(cx: &ctxt<'tcx>, t0: Ty<'tcx>,\n-                     fldop: |Ty<'tcx>| -> Ty<'tcx>)\n-                     -> Ty<'tcx> {\n+pub fn fold_ty<'tcx, F>(cx: &ctxt<'tcx>, t0: Ty<'tcx>,\n+                        fldop: F)\n+                        -> Ty<'tcx> where\n+    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+{\n     let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n     f.fold_ty(t0)\n }\n@@ -2843,7 +2848,9 @@ impl TypeContents {\n         *self & TC::ReachesAll\n     }\n \n-    pub fn union<T>(v: &[T], f: |&T| -> TypeContents) -> TypeContents {\n+    pub fn union<T, F>(v: &[T], mut f: F) -> TypeContents where\n+        F: FnMut(&T) -> TypeContents,\n+    {\n         v.iter().fold(TC::None, |tc, ty| tc | f(ty))\n     }\n \n@@ -3162,10 +3169,12 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n         // Iterates over all builtin bounds on the type parameter def, including\n         // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound<'tcx>(cx: &ctxt<'tcx>,\n-                                              bounds: BuiltinBounds,\n-                                              traits: &[Rc<TraitRef<'tcx>>],\n-                                              f: |BuiltinBound|) {\n+        fn each_inherited_builtin_bound<'tcx, F>(cx: &ctxt<'tcx>,\n+                                                 bounds: BuiltinBounds,\n+                                                 traits: &[Rc<TraitRef<'tcx>>],\n+                                                 mut f: F) where\n+            F: FnMut(BuiltinBound),\n+        {\n             for bound in bounds.iter() {\n                 f(bound);\n             }\n@@ -3959,14 +3968,15 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n }\n \n /// See `expr_ty_adjusted`\n-pub fn adjust_ty<'tcx>(cx: &ctxt<'tcx>,\n-                       span: Span,\n-                       expr_id: ast::NodeId,\n-                       unadjusted_ty: Ty<'tcx>,\n-                       adjustment: Option<&AutoAdjustment<'tcx>>,\n-                       method_type: |MethodCall| -> Option<Ty<'tcx>>)\n-                       -> Ty<'tcx> {\n-\n+pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n+                          span: Span,\n+                          expr_id: ast::NodeId,\n+                          unadjusted_ty: Ty<'tcx>,\n+                          adjustment: Option<&AutoAdjustment<'tcx>>,\n+                          mut method_type: F)\n+                          -> Ty<'tcx> where\n+    F: FnMut(MethodCall) -> Option<Ty<'tcx>>,\n+{\n     if let ty_err = unadjusted_ty.sty {\n         return unadjusted_ty;\n     }\n@@ -4604,11 +4614,13 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n /// id is local, it should have been loaded into the map by the `typeck::collect` phase.  If the\n /// def-id is external, then we have to go consult the crate loading code (and cache the result for\n /// the future).\n-fn lookup_locally_or_in_crate_store<V:Clone>(\n-                                    descr: &str,\n-                                    def_id: ast::DefId,\n-                                    map: &mut DefIdMap<V>,\n-                                    load_external: || -> V) -> V {\n+fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n+                                          def_id: ast::DefId,\n+                                          map: &mut DefIdMap<V>,\n+                                          load_external: F) -> V where\n+    V: Clone,\n+    F: FnOnce() -> V,\n+{\n     match map.get(&def_id).cloned() {\n         Some(v) => { return v; }\n         None => { }\n@@ -5164,7 +5176,9 @@ pub fn predicates<'tcx>(\n /// Iterate over attributes of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: &ctxt, did: DefId, f: |&ast::Attribute| -> bool) -> bool {\n+pub fn each_attr<F>(tcx: &ctxt, did: DefId, mut f: F) -> bool where\n+    F: FnMut(&ast::Attribute) -> bool,\n+{\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n         item.attrs.iter().all(|attr| f(attr))\n@@ -5503,10 +5517,11 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n-pub fn each_bound_trait_and_supertraits<'tcx>(tcx: &ctxt<'tcx>,\n-                                              bounds: &[Rc<TraitRef<'tcx>>],\n-                                              f: |Rc<TraitRef<'tcx>>| -> bool)\n-                                              -> bool\n+pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n+                                                 bounds: &[Rc<TraitRef<'tcx>>],\n+                                                 mut f: F)\n+                                                 -> bool where\n+    F: FnMut(Rc<TraitRef<'tcx>>) -> bool,\n {\n     for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n         if !f(bound_trait_ref) {\n@@ -6194,7 +6209,9 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n \n-pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T) -> T {\n+pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n+    F: FnOnce(&[Freevar]) -> T,\n+{\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n         Some(d) => f(d.as_slice())\n@@ -6242,12 +6259,13 @@ pub fn erase_late_bound_regions<'tcx, HR>(\n }\n \n /// Replaces the late-bound-regions in `value` that are bound by `value`.\n-pub fn replace_late_bound_regions<'tcx, HR>(\n+pub fn replace_late_bound_regions<'tcx, HR, F>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &HR,\n-    mapf: |BoundRegion, DebruijnIndex| -> ty::Region)\n-    -> (HR, FnvHashMap<ty::BoundRegion,ty::Region>)\n-    where HR : HigherRankedFoldable<'tcx>\n+    mut mapf: F)\n+-> (HR, FnvHashMap<ty::BoundRegion, ty::Region>) where\n+    HR : HigherRankedFoldable<'tcx>,\n+    F: FnMut(BoundRegion, DebruijnIndex) -> ty::Region,\n {\n     debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n "}, {"sha": "63ee71dc6a51a26510611f7579eba2035b823e6b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -743,12 +743,14 @@ impl<'tcx, T:HigherRankedFoldable<'tcx>> HigherRankedFoldable<'tcx> for Rc<T> {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a, 'tcx: 'a> {\n+pub struct BottomUpFolder<'a, 'tcx: 'a, F> where F: FnMut(Ty<'tcx>) -> Ty<'tcx> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub fldop: |Ty<'tcx>|: 'a -> Ty<'tcx>,\n+    pub fldop: F,\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n+impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n+    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+{\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -772,15 +774,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n /// (The distinction between \"free\" and \"bound\" is represented by\n /// keeping track of each `FnSig` in the lexical context of the\n /// current position of the fold.)\n-pub struct RegionFolder<'a, 'tcx: 'a> {\n+pub struct RegionFolder<'a, 'tcx: 'a, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n     tcx: &'a ty::ctxt<'tcx>,\n     current_depth: uint,\n-    fld_r: |ty::Region, uint|: 'a -> ty::Region,\n+    fld_r: F,\n }\n \n-impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>, fld_r: |ty::Region, uint|: 'a -> ty::Region)\n-               -> RegionFolder<'a, 'tcx> {\n+impl<'a, 'tcx, F> RegionFolder<'a, 'tcx, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>, fld_r: F) -> RegionFolder<'a, 'tcx, F> {\n         RegionFolder {\n             tcx: tcx,\n             current_depth: 1,\n@@ -789,7 +790,9 @@ impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n+impl<'a, 'tcx, F> TypeFolder<'tcx> for RegionFolder<'a, 'tcx, F> where\n+    F: FnMut(ty::Region, uint) -> ty::Region,\n+{\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn enter_region_binder(&mut self) {"}, {"sha": "51e18c80d0584dbd94508d8d5cfdcd5f8e91a184", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -27,7 +27,9 @@ pub struct ErrorReported;\n \n impl Copy for ErrorReported {}\n \n-pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n+pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n+    F: FnOnce(U) -> T,\n+{\n     thread_local!(static DEPTH: Cell<uint> = Cell::new(0));\n     if !do_it { return f(u); }\n \n@@ -39,9 +41,13 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n \n     let mut u = Some(u);\n     let mut rv = None;\n-    let dur = Duration::span(|| {\n-        rv = Some(f(u.take().unwrap()))\n-    });\n+    let dur = {\n+        let ref mut rvp = rv;\n+\n+        Duration::span(move || {\n+            *rvp = Some(f(u.take().unwrap()))\n+        })\n+    };\n     let rv = rv.unwrap();\n \n     println!(\"{}time: {}.{:03} \\t{}\", \"  \".repeat(old),\n@@ -51,7 +57,10 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     rv\n }\n \n-pub fn indent<R: Show>(op: || -> R) -> R {\n+pub fn indent<R, F>(op: F) -> R where\n+    R: Show,\n+    F: FnOnce() -> R,\n+{\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");\n@@ -73,12 +82,12 @@ pub fn indenter() -> Indenter {\n     Indenter { _cannot_construct_outside_of_this_module: () }\n }\n \n-struct LoopQueryVisitor<'a> {\n-    p: |&ast::Expr_|: 'a -> bool,\n+struct LoopQueryVisitor<P> where P: FnMut(&ast::Expr_) -> bool {\n+    p: P,\n     flag: bool,\n }\n \n-impl<'a, 'v> Visitor<'v> for LoopQueryVisitor<'a> {\n+impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&ast::Expr_) -> bool {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         self.flag |= (self.p)(&e.node);\n         match e.node {\n@@ -92,7 +101,7 @@ impl<'a, 'v> Visitor<'v> for LoopQueryVisitor<'a> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n+pub fn loop_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr_) -> bool {\n     let mut v = LoopQueryVisitor {\n         p: p,\n         flag: false,\n@@ -101,12 +110,12 @@ pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n     return v.flag;\n }\n \n-struct BlockQueryVisitor<'a> {\n-    p: |&ast::Expr|: 'a -> bool,\n+struct BlockQueryVisitor<P> where P: FnMut(&ast::Expr) -> bool {\n+    p: P,\n     flag: bool,\n }\n \n-impl<'a, 'v> Visitor<'v> for BlockQueryVisitor<'a> {\n+impl<'v, P> Visitor<'v> for BlockQueryVisitor<P> where P: FnMut(&ast::Expr) -> bool {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         self.flag |= (self.p)(e);\n         visit::walk_expr(self, e)\n@@ -115,7 +124,7 @@ impl<'a, 'v> Visitor<'v> for BlockQueryVisitor<'a> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: &ast::Block, p: |&ast::Expr| -> bool) -> bool {\n+pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,\n@@ -194,11 +203,12 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n /// }\n /// ```\n #[inline(always)]\n-pub fn memoized<T: Clone + Hash<S> + Eq, U: Clone, S, H: Hasher<S>>(\n-    cache: &RefCell<HashMap<T, U, H>>,\n-    arg: T,\n-    f: |T| -> U\n-) -> U {\n+pub fn memoized<T, U, S, H, F>(cache: &RefCell<HashMap<T, U, H>>, arg: T, f: F) -> U where\n+    T: Clone + Hash<S> + Eq,\n+    U: Clone,\n+    H: Hasher<S>,\n+    F: FnOnce(T) -> U,\n+{\n     let key = arg.clone();\n     let result = cache.borrow().get(&key).map(|result| result.clone());\n     match result {"}, {"sha": "3bf817b42b06de19ec85ea76fd4a6dad36365bcf", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -232,8 +232,9 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan(&self, scope: region::CodeExtent, op: |&Loan<'tcx>| -> bool)\n-                            -> bool {\n+    pub fn each_issued_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+        F: FnMut(&Loan<'tcx>) -> bool,\n+    {\n         //! Iterates over each loan that has been issued\n         //! on entrance to `scope`, regardless of whether it is\n         //! actually *in scope* at that point.  Sometimes loans\n@@ -246,10 +247,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn each_in_scope_loan(&self,\n-                              scope: region::CodeExtent,\n-                              op: |&Loan<'tcx>| -> bool)\n-                              -> bool {\n+    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+        F: FnMut(&Loan<'tcx>) -> bool,\n+    {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n@@ -263,11 +263,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    fn each_in_scope_loan_affecting_path(&self,\n-                                         scope: region::CodeExtent,\n-                                         loan_path: &LoanPath<'tcx>,\n-                                         op: |&Loan<'tcx>| -> bool)\n-                                         -> bool {\n+    fn each_in_scope_loan_affecting_path<F>(&self,\n+                                            scope: region::CodeExtent,\n+                                            loan_path: &LoanPath<'tcx>,\n+                                            mut op: F)\n+                                            -> bool where\n+        F: FnMut(&Loan<'tcx>) -> bool,\n+    {\n         //! Iterates through all of the in-scope loans affecting `loan_path`,\n         //! calling `op`, and ceasing iteration if `false` is returned.\n "}, {"sha": "00b1377af73040793dfa803a227bd45ad65ed47d", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -523,8 +523,9 @@ impl<'tcx> MoveData<'tcx> {\n         }\n     }\n \n-    fn each_base_path(&self, index: MovePathIndex, f: |MovePathIndex| -> bool)\n-                      -> bool {\n+    fn each_base_path<F>(&self, index: MovePathIndex, mut f: F) -> bool where\n+        F: FnMut(MovePathIndex) -> bool,\n+    {\n         let mut p = index;\n         while p != InvalidMovePathIndex {\n             if !f(p) {\n@@ -535,10 +536,8 @@ impl<'tcx> MoveData<'tcx> {\n         return true;\n     }\n \n-    fn each_extending_path(&self,\n-                           index: MovePathIndex,\n-                           f: |MovePathIndex| -> bool)\n-                           -> bool {\n+    // FIXME(#19596) unbox `f`\n+    fn each_extending_path(&self, index: MovePathIndex, f: |MovePathIndex| -> bool) -> bool {\n         if !f(index) {\n             return false;\n         }\n@@ -554,10 +553,9 @@ impl<'tcx> MoveData<'tcx> {\n         return true;\n     }\n \n-    fn each_applicable_move(&self,\n-                            index0: MovePathIndex,\n-                            f: |MoveIndex| -> bool)\n-                            -> bool {\n+    fn each_applicable_move<F>(&self, index0: MovePathIndex, mut f: F) -> bool where\n+        F: FnMut(MoveIndex) -> bool,\n+    {\n         let mut ret = true;\n         self.each_extending_path(index0, |index| {\n             let mut p = self.path_first_move(index);\n@@ -660,11 +658,13 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     /// Iterates through each move of `loan_path` (or some base path of `loan_path`) that *may*\n     /// have occurred on entry to `id` without an intervening assignment. In other words, any moves\n     /// that would invalidate a reference to `loan_path` at location `id`.\n-    pub fn each_move_of(&self,\n-                        id: ast::NodeId,\n-                        loan_path: &Rc<LoanPath<'tcx>>,\n-                        f: |&Move, &LoanPath<'tcx>| -> bool)\n-                        -> bool {\n+    pub fn each_move_of<F>(&self,\n+                           id: ast::NodeId,\n+                           loan_path: &Rc<LoanPath<'tcx>>,\n+                           mut f: F)\n+                           -> bool where\n+        F: FnMut(&Move, &LoanPath<'tcx>) -> bool,\n+    {\n         // Bad scenarios:\n         //\n         // 1. Move of `a.b.c`, use of `a.b.c`\n@@ -715,11 +715,13 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n     /// Iterates through every assignment to `loan_path` that may have occurred on entry to `id`.\n     /// `loan_path` must be a single variable.\n-    pub fn each_assignment_of(&self,\n-                              id: ast::NodeId,\n-                              loan_path: &Rc<LoanPath<'tcx>>,\n-                              f: |&Assignment| -> bool)\n-                              -> bool {\n+    pub fn each_assignment_of<F>(&self,\n+                                 id: ast::NodeId,\n+                                 loan_path: &Rc<LoanPath<'tcx>>,\n+                                 mut f: F)\n+                                 -> bool where\n+        F: FnMut(&Assignment) -> bool,\n+    {\n         let loan_path_index = {\n             match self.move_data.existing_move_path(loan_path) {\n                 Some(i) => i,"}, {"sha": "e09ec79166997db26327b351cd191649ca01763b", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1195708f64f34f6c402f98f5b551e2567be731c9/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=1195708f64f34f6c402f98f5b551e2567be731c9", "patch": "@@ -75,11 +75,13 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         }\n     }\n \n-    fn build_set<O:DataFlowOperator>(&self,\n-                                     e: EntryOrExit,\n-                                     cfgidx: CFGIndex,\n-                                     dfcx: &DataFlowContext<'a, 'tcx, O>,\n-                                     to_lp: |uint| -> Rc<LoanPath<'tcx>>) -> String {\n+    fn build_set<O:DataFlowOperator, F>(&self,\n+                                        e: EntryOrExit,\n+                                        cfgidx: CFGIndex,\n+                                        dfcx: &DataFlowContext<'a, 'tcx, O>,\n+                                        mut to_lp: F) -> String where\n+        F: FnMut(uint) -> Rc<LoanPath<'tcx>>,\n+    {\n         let mut saw_some = false;\n         let mut set = \"{\".to_string();\n         dfcx.each_bit_for_node(e, cfgidx, |index| {\n@@ -98,7 +100,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n \n     fn dataflow_loans_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n         let dfcx = &self.analysis_data.loans;\n-        let loan_index_to_path = |loan_index| {\n+        let loan_index_to_path = |&mut: loan_index| {\n             let all_loans = &self.analysis_data.all_loans;\n             all_loans[loan_index].loan_path()\n         };\n@@ -107,7 +109,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n \n     fn dataflow_moves_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n         let dfcx = &self.analysis_data.move_data.dfcx_moves;\n-        let move_index_to_path = |move_index| {\n+        let move_index_to_path = |&mut: move_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let moves = move_data.moves.borrow();\n             let the_move = &(*moves)[move_index];\n@@ -118,7 +120,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n \n     fn dataflow_assigns_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n         let dfcx = &self.analysis_data.move_data.dfcx_assign;\n-        let assign_index_to_path = |assign_index| {\n+        let assign_index_to_path = |&mut: assign_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let assignments = move_data.var_assignments.borrow();\n             let assignment = &(*assignments)[assign_index];"}]}