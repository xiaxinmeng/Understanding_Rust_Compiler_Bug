{"sha": "9e8a982a234532ad9cce7f072d130029df96bebc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllOGE5ODJhMjM0NTMyYWQ5Y2NlN2YwNzJkMTMwMDI5ZGY5NmJlYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-19T14:07:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-19T14:07:45Z"}, "message": "Auto merge of #56051 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 25 pull requests\n\nSuccessful merges:\n\n - #55562 (Add powerpc- and powerpc64-unknown-linux-musl targets)\n - #55564 (test/linkage-visibility: Ignore on musl targets)\n - #55827 (A few tweaks to iterations/collecting)\n - #55834 (Forward the ABI of the non-zero sized fields of an union if they have the same ABI)\n - #55857 (remove unused dependency)\n - #55862 (in which the E0618 \"expected function\" diagnostic gets a makeover)\n - #55867 (do not panic just because cargo failed)\n - #55894 (miri enum discriminant handling: Fix treatment of pointers, better error when it is undef)\n - #55916 (Make miri value visitor useful for mutation)\n - #55919 (core/tests/num: Simplify `test_int_from_str_overflow()` test code)\n - #55923 (reword #[test] attribute error on fn items)\n - #55949 (ty: return impl Iterator from Predicate::walk_tys)\n - #55952 (Update to Clang 7 on CI.)\n - #55953 (#53488 Refactoring UpvarId)\n - #55962 (rustdoc: properly calculate spans for intra-doc link resolution errors)\n - #55963 (Stress test for MPSC)\n - #55968 (Clean up some non-mod-rs stuff.)\n - #55970 (Miri backtrace improvements)\n - #56007 (CTFE: dynamically make sure we do not call non-const-fn)\n - #56011 (Replace data.clone() by Arc::clone(&data) in mutex doc.)\n - #56012 (avoid shared ref in UnsafeCell::get)\n - #56016 (Add VecDeque::resize_with)\n - #56027 (docs: Add missing backtick in object_safety.rs docs)\n - #56043 (remove \"approx env bounds\" if we already know from trait)\n - #56059 (Increase `Duration` approximate equal threshold to 1us)", "tree": {"sha": "1726460645909068b603542104a0bbe3f09c40b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1726460645909068b603542104a0bbe3f09c40b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e8a982a234532ad9cce7f072d130029df96bebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e8a982a234532ad9cce7f072d130029df96bebc", "html_url": "https://github.com/rust-lang/rust/commit/9e8a982a234532ad9cce7f072d130029df96bebc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e8a982a234532ad9cce7f072d130029df96bebc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e82eda000c8d4abbdaa76b3563cd77f938fc411", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e82eda000c8d4abbdaa76b3563cd77f938fc411", "html_url": "https://github.com/rust-lang/rust/commit/7e82eda000c8d4abbdaa76b3563cd77f938fc411"}, {"sha": "8cea658b907dd929e99514dae4c8d29f047153dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cea658b907dd929e99514dae4c8d29f047153dc", "html_url": "https://github.com/rust-lang/rust/commit/8cea658b907dd929e99514dae4c8d29f047153dc"}], "stats": {"total": 1842, "additions": 1251, "deletions": 591}, "files": [{"sha": "14fb17aeeddca34d9a1cf98bf844c217ee700812", "filename": ".travis.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -227,9 +227,9 @@ install:\n             chmod +x /usr/local/bin/sccache &&\n           travis_retry curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n             chmod +x /usr/local/bin/stamp &&\n-          travis_retry curl -f http://releases.llvm.org/6.0.0/clang+llvm-6.0.0-x86_64-apple-darwin.tar.xz | tar xJf - &&\n-            export CC=`pwd`/clang+llvm-6.0.0-x86_64-apple-darwin/bin/clang &&\n-            export CXX=`pwd`/clang+llvm-6.0.0-x86_64-apple-darwin/bin/clang++ &&\n+          travis_retry curl -f http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-apple-darwin.tar.xz | tar xJf - &&\n+            export CC=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang &&\n+            export CXX=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++ &&\n             export AR=ar\n           ;;\n     esac"}, {"sha": "94a07f6c91cfa07d42ac9024059ba4887b7f4403", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -2191,7 +2191,6 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "b6bb11d07ef049d2ebf16d5274800b1339518c01", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -22,7 +22,7 @@ use std::fs::{self, File};\n use std::io::BufReader;\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Stdio};\n+use std::process::{Command, Stdio, exit};\n use std::str;\n \n use build_helper::{output, mtime, up_to_date};\n@@ -1098,7 +1098,7 @@ pub fn run_cargo(builder: &Builder,\n     });\n \n     if !ok {\n-        panic!(\"cargo must succeed\");\n+        exit(1);\n     }\n \n     // Ok now we need to actually find all the files listed in `toplevel`. We've"}, {"sha": "b087ea7899f4ce8e22ddb1e45f4055d1cf2cc3d2", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -67,7 +67,7 @@ RUN ./build-gcc.sh\n COPY dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n-# Now build LLVM+Clang 6, afterwards configuring further compilations to use the\n+# Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n # clang/clang++ compilers.\n COPY dist-x86_64-linux/build-clang.sh /tmp/\n RUN ./build-clang.sh"}, {"sha": "a1a778c2b2c619bcd57e6b8c3c20fb7ba1600318", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -67,7 +67,7 @@ RUN ./build-gcc.sh\n COPY dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n-# Now build LLVM+Clang 6, afterwards configuring further compilations to use the\n+# Now build LLVM+Clang 7, afterwards configuring further compilations to use the\n # clang/clang++ compilers.\n COPY dist-x86_64-linux/build-clang.sh /tmp/\n RUN ./build-clang.sh"}, {"sha": "2762f0bf7ec74026023e845f5e4a1cfa9dcee9ca", "filename": "src/ci/docker/dist-x86_64-linux/build-clang.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -13,7 +13,7 @@ set -ex\n \n source shared.sh\n \n-LLVM=6.0.0\n+LLVM=7.0.0\n \n mkdir clang\n cd clang"}, {"sha": "11d85471b7c08449e2d66babc29c048b11dce8ea", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -51,7 +51,7 @@ hide_output make clean\n \n cd ..\n \n-LLVM=60\n+LLVM=70\n \n # may have been downloaded in a previous run\n if [ ! -d libunwind-release_$LLVM ]; then"}, {"sha": "cbf104a8fcde9ac296a66fbd533eb54779fcf19b", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -19,7 +19,7 @@\n \n use core::cmp::Ordering;\n use core::fmt;\n-use core::iter::{repeat, FromIterator, FusedIterator};\n+use core::iter::{repeat, repeat_with, FromIterator, FusedIterator};\n use core::mem;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds};\n@@ -1920,6 +1920,44 @@ impl<T: Clone> VecDeque<T> {\n             self.truncate(new_len);\n         }\n     }\n+\n+    /// Modifies the `VecDeque` in-place so that `len()` is equal to `new_len`,\n+    /// either by removing excess elements from the back or by appending\n+    /// elements generated by calling `generator` to the back.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_resize_with)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// buf.push_back(5);\n+    /// buf.push_back(10);\n+    /// buf.push_back(15);\n+    /// assert_eq!(buf, [5, 10, 15]);\n+    ///\n+    /// buf.resize_with(5, Default::default);\n+    /// assert_eq!(buf, [5, 10, 15, 0, 0]);\n+    ///\n+    /// buf.resize_with(2, || unreachable!());\n+    /// assert_eq!(buf, [5, 10]);\n+    ///\n+    /// let mut state = 100;\n+    /// buf.resize_with(5, || { state += 1; state });\n+    /// assert_eq!(buf, [5, 10, 101, 102, 103]);\n+    /// ```\n+    #[unstable(feature = \"vec_resize_with\", issue = \"41758\")]\n+    pub fn resize_with(&mut self, new_len: usize, generator: impl FnMut()->T) {\n+        let len = self.len();\n+\n+        if new_len > len {\n+            self.extend(repeat_with(generator).take(new_len - len))\n+        } else {\n+            self.truncate(new_len);\n+        }\n+    }\n }\n \n /// Returns the index in the underlying buffer for a given logical element index."}, {"sha": "d8d51f53377f724e229f92f7b6ab546fcd16fa46", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -1509,7 +1509,9 @@ impl<T: ?Sized> UnsafeCell<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn get(&self) -> *mut T {\n-        &self.value as *const T as *mut T\n+        // We can just cast the pointer from `UnsafeCell<T>` to `T` because of\n+        // #[repr(transparent)]\n+        self as *const UnsafeCell<T> as *const T as *mut T\n     }\n }\n "}, {"sha": "0928f7560e175cd818c3d7353247f0d2c89f0be8", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -82,36 +82,28 @@ fn from_str_issue7588() {\n \n #[test]\n fn test_int_from_str_overflow() {\n-    let mut i8_val: i8 = 127;\n-    assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));\n+    assert_eq!(\"127\".parse::<i8>().ok(), Some(127i8));\n     assert_eq!(\"128\".parse::<i8>().ok(), None);\n \n-    i8_val = i8_val.wrapping_add(1);\n-    assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));\n+    assert_eq!(\"-128\".parse::<i8>().ok(), Some(-128i8));\n     assert_eq!(\"-129\".parse::<i8>().ok(), None);\n \n-    let mut i16_val: i16 = 32_767;\n-    assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));\n+    assert_eq!(\"32767\".parse::<i16>().ok(), Some(32_767i16));\n     assert_eq!(\"32768\".parse::<i16>().ok(), None);\n \n-    i16_val = i16_val.wrapping_add(1);\n-    assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));\n+    assert_eq!(\"-32768\".parse::<i16>().ok(), Some(-32_768i16));\n     assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n \n-    let mut i32_val: i32 = 2_147_483_647;\n-    assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));\n+    assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(2_147_483_647i32));\n     assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n \n-    i32_val = i32_val.wrapping_add(1);\n-    assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));\n+    assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(-2_147_483_648i32));\n     assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n \n-    let mut i64_val: i64 = 9_223_372_036_854_775_807;\n-    assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));\n+    assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(9_223_372_036_854_775_807i64));\n     assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n \n-    i64_val = i64_val.wrapping_add(1);\n-    assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n+    assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(-9_223_372_036_854_775_808i64));\n     assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n }\n "}, {"sha": "650aa39114fad4566f5bb88b930479117ed9a8bf", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -106,8 +106,7 @@ impl<'a> dot::GraphWalk<'a> for &'a cfg::CFG {\n     type Node = Node<'a>;\n     type Edge = Edge<'a>;\n     fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> {\n-        let mut v = Vec::new();\n-        self.graph.each_node(|i, nd| { v.push((i, nd)); true });\n+        let v: Vec<_> = self.graph.enumerated_nodes().collect();\n         v.into()\n     }\n     fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> {"}, {"sha": "ce1e678043188c5d7802778b97f2e2aa65fb4997", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -1062,8 +1062,7 @@ impl<'a> LoweringContext<'a> {\n         attrs\n             .iter()\n             .map(|a| self.lower_attr(a))\n-            .collect::<Vec<_>>()\n-            .into()\n+            .collect()\n     }\n \n     fn lower_attr(&mut self, attr: &Attribute) -> Attribute {"}, {"sha": "64685446e8fe14383a52e610b2fa96a5911eedde", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -216,7 +216,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::adjustment::AutoBorrow\n     }\n }\n \n-impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n+impl_stable_hash_for!(struct ty::UpvarPath { hir_id });\n+\n+impl_stable_hash_for!(struct ty::UpvarId { var_path, closure_expr_id });\n \n impl_stable_hash_for!(enum ty::BorrowKind {\n     ImmBorrow,\n@@ -387,10 +389,10 @@ impl_stable_hash_for!(enum mir::interpret::ErrorHandled {\n     TooGeneric\n });\n \n-impl_stable_hash_for!(struct mir::interpret::FrameInfo {\n-    span,\n+impl_stable_hash_for!(struct mir::interpret::FrameInfo<'tcx> {\n+    call_site,\n     lint_root,\n-    location\n+    instance\n });\n \n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n@@ -451,7 +453,7 @@ impl_stable_hash_for!(\n         FunctionRetMismatch(a, b),\n         NoMirFor(s),\n         UnterminatedCString(ptr),\n-        PointerOutOfBounds { ptr, access, allocation_size },\n+        PointerOutOfBounds { ptr, check, allocation_size },\n         InvalidBoolOp(bop),\n         Unimplemented(s),\n         BoundsCheck { len, index },\n@@ -471,6 +473,11 @@ impl_stable_hash_for!(\n     }\n );\n \n+impl_stable_hash_for!(enum mir::interpret::InboundsCheck {\n+    Live,\n+    MaybeDead\n+});\n+\n impl_stable_hash_for!(enum mir::interpret::Lock {\n     NoLock,\n     WriteLock(dl),"}, {"sha": "59a490f4a013d9a6dc6dec97f74fcd682e149f44", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -1315,7 +1315,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n                 let var_name = self.tcx.hir.name(var_node_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }"}, {"sha": "a539c321af3f0be79cc570f22a72bd560d171a84", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n                 let var_name = self.tcx.hir.name(var_node_id);\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\", var_name));\n@@ -174,7 +174,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n                 let var_name = self.tcx.hir.name(var_node_id);\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,"}, {"sha": "502a5828f3ea5c68109a389f4b9e27c38c13c430", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -389,22 +389,38 @@ where\n         // rule might not apply (but another rule might). For now, we err\n         // on the side of adding too few edges into the graph.\n \n+        // Compute the bounds we can derive from the trait definition.\n+        // These are guaranteed to apply, no matter the inference\n+        // results.\n+        let trait_bounds: Vec<_> = self.verify_bound\n+            .projection_declared_bounds_from_trait(projection_ty)\n+            .collect();\n+\n         // Compute the bounds we can derive from the environment. This\n         // is an \"approximate\" match -- in some cases, these bounds\n         // may not apply.\n-        let approx_env_bounds = self.verify_bound\n+        let mut approx_env_bounds = self.verify_bound\n             .projection_approx_declared_bounds_from_env(projection_ty);\n         debug!(\n             \"projection_must_outlive: approx_env_bounds={:?}\",\n             approx_env_bounds\n         );\n \n-        // Compute the bounds we can derive from the trait definition.\n-        // These are guaranteed to apply, no matter the inference\n-        // results.\n-        let trait_bounds: Vec<_> = self.verify_bound\n-            .projection_declared_bounds_from_trait(projection_ty)\n-            .collect();\n+        // Remove outlives bounds that we get from the environment but\n+        // which are also deducable from the trait. This arises (cc\n+        // #55756) in cases where you have e.g. `<T as Foo<'a>>::Item:\n+        // 'a` in the environment but `trait Foo<'b> { type Item: 'b\n+        // }` in the trait definition.\n+        approx_env_bounds.retain(|bound| {\n+            match bound.0.sty {\n+                ty::Projection(projection_ty) => {\n+                    self.verify_bound.projection_declared_bounds_from_trait(projection_ty)\n+                        .all(|r| r != bound.1)\n+                }\n+\n+                _ => panic!(\"expected only projection types from env, not {:?}\", bound.0),\n+            }\n+        });\n \n         // If declared bounds list is empty, the only applicable rule is\n         // OutlivesProjectionComponent. If there are inference variables,"}, {"sha": "5b92bfe6ad3c48629a67600f4e5e45b91e84ff15", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -938,7 +938,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 let var_hir_id = self.tcx().hir.node_to_hir_id(freevar.var_id());\n                 let closure_def_id = self.tcx().hir.local_def_id(closure_expr.id);\n                 let upvar_id = ty::UpvarId {\n-                    var_id: var_hir_id,\n+                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: closure_def_id.to_local(),\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);"}, {"sha": "cadf0c42d228fe21575c5cf2dc5a68c8d95fce36", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -818,7 +818,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let closure_expr_def_id = self.tcx.hir.local_def_id(fn_node_id);\n         let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n-            var_id: var_hir_id,\n+            var_path: ty::UpvarPath { hir_id: var_hir_id },\n             closure_expr_id: closure_expr_def_id.to_local(),\n         };\n "}, {"sha": "02c0ebcec4fefb64cc5d2175dd5b5b4d4af26e84", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -19,6 +19,14 @@ use mir;\n use std::ops::{Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n \n+/// Used by `check_bounds` to indicate whether the pointer needs to be just inbounds\n+/// or also inbounds of a *live* allocation.\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub enum InboundsCheck {\n+    Live,\n+    MaybeDead,\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation."}, {"sha": "f1c95e0f00024a57204a55a8dfb0ce82b0947aa8", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 53, "deletions": 18, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -10,20 +10,20 @@\n \n use std::{fmt, env};\n \n+use hir::map::definitions::DefPathData;\n use mir;\n-use ty::{Ty, layout};\n+use ty::{self, Ty, layout};\n use ty::layout::{Size, Align, LayoutError};\n use rustc_target::spec::abi::Abi;\n \n-use super::{Pointer, Scalar};\n+use super::{Pointer, InboundsCheck, ScalarMaybeUndef};\n \n use backtrace::Backtrace;\n \n-use ty;\n use ty::query::TyCtxtAt;\n use errors::DiagnosticBuilder;\n \n-use syntax_pos::Span;\n+use syntax_pos::{Pos, Span};\n use syntax::ast;\n use syntax::symbol::Symbol;\n \n@@ -52,16 +52,35 @@ pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n     pub error: ::mir::interpret::EvalErrorKind<'tcx, u64>,\n-    pub stacktrace: Vec<FrameInfo>,\n+    pub stacktrace: Vec<FrameInfo<'tcx>>,\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct FrameInfo {\n-    pub span: Span,\n-    pub location: String,\n+pub struct FrameInfo<'tcx> {\n+    pub call_site: Span, // this span is in the caller!\n+    pub instance: ty::Instance<'tcx>,\n     pub lint_root: Option<ast::NodeId>,\n }\n \n+impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n+                == DefPathData::ClosureExpr\n+            {\n+                write!(f, \"inside call to closure\")?;\n+            } else {\n+                write!(f, \"inside call to `{}`\", self.instance)?;\n+            }\n+            if !self.call_site.is_dummy() {\n+                let lo = tcx.sess.source_map().lookup_char_pos_adj(self.call_site.lo());\n+                write!(f, \" at {}:{}:{}\", lo.filename, lo.line, lo.col.to_usize() + 1)?;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     pub fn struct_error(&self,\n         tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n@@ -135,8 +154,13 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n             struct_error(tcx, message)\n         };\n         err.span_label(self.span, self.error.to_string());\n-        for FrameInfo { span, location, .. } in &self.stacktrace {\n-            err.span_label(*span, format!(\"inside call to `{}`\", location));\n+        // Skip the last, which is just the environment of the constant.  The stacktrace\n+        // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n+        // on constant values.\n+        if self.stacktrace.len() > 0 {\n+            for frame_info in &self.stacktrace[..self.stacktrace.len()-1] {\n+                err.span_label(frame_info.call_site, frame_info.to_string());\n+            }\n         }\n         Ok(err)\n     }\n@@ -172,16 +196,23 @@ fn print_backtrace(backtrace: &mut Backtrace) -> String {\n     write!(trace_text, \"backtrace frames: {}\\n\", backtrace.frames().len()).unwrap();\n     'frames: for (i, frame) in backtrace.frames().iter().enumerate() {\n         if frame.symbols().is_empty() {\n-            write!(trace_text, \"{}: no symbols\\n\", i).unwrap();\n+            write!(trace_text, \"  {}: no symbols\\n\", i).unwrap();\n         }\n+        let mut first = true;\n         for symbol in frame.symbols() {\n-            write!(trace_text, \"{}: \", i).unwrap();\n+            if first {\n+                write!(trace_text, \"  {}: \", i).unwrap();\n+                first = false;\n+            } else {\n+                let len = i.to_string().len();\n+                write!(trace_text, \"  {}  \", \" \".repeat(len)).unwrap();\n+            }\n             if let Some(name) = symbol.name() {\n                 write!(trace_text, \"{}\\n\", name).unwrap();\n             } else {\n                 write!(trace_text, \"<unknown>\\n\").unwrap();\n             }\n-            write!(trace_text, \"\\tat \").unwrap();\n+            write!(trace_text, \"           at \").unwrap();\n             if let Some(file_path) = symbol.filename() {\n                 write!(trace_text, \"{}\", file_path.display()).unwrap();\n             } else {\n@@ -240,10 +271,10 @@ pub enum EvalErrorKind<'tcx, O> {\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n-    InvalidDiscriminant(Scalar),\n+    InvalidDiscriminant(ScalarMaybeUndef),\n     PointerOutOfBounds {\n         ptr: Pointer,\n-        access: bool,\n+        check: InboundsCheck,\n         allocation_size: Size,\n     },\n     InvalidNullPointerUsage,\n@@ -457,9 +488,13 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::EvalErrorKind::*;\n         match *self {\n-            PointerOutOfBounds { ptr, access, allocation_size } => {\n-                write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n-                       if access { \"memory access\" } else { \"pointer computed\" },\n+            PointerOutOfBounds { ptr, check, allocation_size } => {\n+                write!(f, \"Pointer must be in-bounds{} at offset {}, but is outside bounds of \\\n+                           allocation {} which has size {}\",\n+                       match check {\n+                           InboundsCheck::Live => \" and live\",\n+                           InboundsCheck::MaybeDead => \"\",\n+                       },\n                        ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n             ValidationFailure(ref err) => {"}, {"sha": "ec25431bd1ffe505ad1b40ea817cfe90a63af481", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -28,7 +28,7 @@ pub use self::error::{\n pub use self::value::{Scalar, ConstValue, ScalarMaybeUndef};\n \n pub use self::allocation::{\n-    Allocation, AllocationExtra,\n+    InboundsCheck, Allocation, AllocationExtra,\n     Relocations, UndefMask,\n };\n "}, {"sha": "c79fa3861234f9b69e8cb632c3e09c93e99e9a12", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -470,7 +470,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     ///\n     /// for `self: &'a mut Self`, this means `&'a mut Self: DispatchFromDyn<&'a mut U>`\n     /// for `self: Rc<Self>`, this means `Rc<Self>: DispatchFromDyn<Rc<U>>`\n-    /// for `self: Pin<Box<Self>>, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`\n+    /// for `self: Pin<Box<Self>>`, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`\n     //\n     // FIXME(mikeyhew) when unsized receivers are implemented as part of unsized rvalues, add this\n     // fallback query: `Receiver: Unsize<Receiver[Self => U]>` to support receivers like"}, {"sha": "923d362c2345ff6a4fcdcdd163de411683463da4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -789,7 +789,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             pat_adjustments.hash_stable(hcx, hasher);\n             hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n                 let ty::UpvarId {\n-                    var_id,\n+                    var_path,\n                     closure_expr_id\n                 } = *up_var_id;\n \n@@ -798,14 +798,14 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n                 let var_owner_def_id = DefId {\n                     krate: local_id_root.krate,\n-                    index: var_id.owner,\n+                    index: var_path.hir_id.owner,\n                 };\n                 let closure_def_id = DefId {\n                     krate: local_id_root.krate,\n                     index: closure_expr_id.to_def_id().index,\n                 };\n                 (hcx.def_path_hash(var_owner_def_id),\n-                 var_id.local_id,\n+                 var_path.hir_id.local_id,\n                  hcx.def_path_hash(closure_def_id))\n             });\n "}, {"sha": "d7fb8da7acd05fca7bffaaff732f7066b5a65b0f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -697,7 +697,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             Align::from_bytes(repr_align, repr_align).unwrap());\n                     }\n \n+                    let optimize = !def.repr.inhibit_union_abi_opt();\n                     let mut size = Size::ZERO;\n+                    let mut abi = Abi::Aggregate { sized: true };\n                     let index = VariantIdx::new(0);\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n@@ -708,13 +710,44 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         } else {\n                             align = align.max(field.align);\n                         }\n+\n+                        // If all non-ZST fields have the same ABI, forward this ABI\n+                        if optimize && !field.is_zst() {\n+                            // Normalize scalar_unit to the maximal valid range\n+                            let field_abi = match &field.abi {\n+                                Abi::Scalar(x) => Abi::Scalar(scalar_unit(x.value)),\n+                                Abi::ScalarPair(x, y) => {\n+                                    Abi::ScalarPair(\n+                                        scalar_unit(x.value),\n+                                        scalar_unit(y.value),\n+                                    )\n+                                }\n+                                Abi::Vector { element: x, count } => {\n+                                    Abi::Vector {\n+                                        element: scalar_unit(x.value),\n+                                        count: *count,\n+                                    }\n+                                }\n+                                Abi::Uninhabited |\n+                                Abi::Aggregate { .. }  => Abi::Aggregate { sized: true },\n+                            };\n+\n+                            if size == Size::ZERO {\n+                                // first non ZST: initialize 'abi'\n+                                abi = field_abi;\n+                            } else if abi != field_abi  {\n+                                // different fields have different ABI: reset to Aggregate\n+                                abi = Abi::Aggregate { sized: true };\n+                            }\n+                        }\n+\n                         size = cmp::max(size, field.size);\n                     }\n \n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n-                        abi: Abi::Aggregate { sized: true },\n+                        abi,\n                         align,\n                         size: size.abi_align(align)\n                     }));"}, {"sha": "dfdffa2d54783dcb87baf7a6b9571ab000c931d8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -49,7 +49,6 @@ use std::hash::{Hash, Hasher};\n use std::ops::Deref;\n use rustc_data_structures::sync::{self, Lrc, ParallelIterator, par_iter};\n use std::slice;\n-use std::vec::IntoIter;\n use std::{mem, ptr};\n use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n@@ -731,12 +730,17 @@ impl<T> List<T> {\n     }\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct UpvarPath {\n+    pub hir_id: hir::HirId,\n+}\n+\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n-    pub var_id: hir::HirId,\n+    pub var_path: UpvarPath,\n     pub closure_expr_id: LocalDefId,\n }\n \n@@ -1343,49 +1347,88 @@ impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     }\n }\n \n+// A custom iterator used by Predicate::walk_tys.\n+enum WalkTysIter<'tcx, I, J, K>\n+    where I: Iterator<Item = Ty<'tcx>>,\n+          J: Iterator<Item = Ty<'tcx>>,\n+          K: Iterator<Item = Ty<'tcx>>\n+{\n+    None,\n+    One(Ty<'tcx>),\n+    Two(Ty<'tcx>, Ty<'tcx>),\n+    Types(I),\n+    InputTypes(J),\n+    ProjectionTypes(K)\n+}\n+\n+impl<'tcx, I, J, K> Iterator for WalkTysIter<'tcx, I, J, K>\n+    where I: Iterator<Item = Ty<'tcx>>,\n+          J: Iterator<Item = Ty<'tcx>>,\n+          K: Iterator<Item = Ty<'tcx>>\n+{\n+    type Item = Ty<'tcx>;\n+\n+    fn next(&mut self) -> Option<Ty<'tcx>> {\n+        match *self {\n+            WalkTysIter::None => None,\n+            WalkTysIter::One(item) => {\n+                *self = WalkTysIter::None;\n+                Some(item)\n+            },\n+            WalkTysIter::Two(item1, item2) => {\n+                *self = WalkTysIter::One(item2);\n+                Some(item1)\n+            },\n+            WalkTysIter::Types(ref mut iter) => {\n+                iter.next()\n+            },\n+            WalkTysIter::InputTypes(ref mut iter) => {\n+                iter.next()\n+            },\n+            WalkTysIter::ProjectionTypes(ref mut iter) => {\n+                iter.next()\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> Predicate<'tcx> {\n     /// Iterates over the types in this predicate. Note that in all\n     /// cases this is skipping over a binder, so late-bound regions\n     /// with depth 0 are bound by the predicate.\n-    pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n-        let vec: Vec<_> = match *self {\n+    pub fn walk_tys(&'a self) -> impl Iterator<Item = Ty<'tcx>> + 'a {\n+        match *self {\n             ty::Predicate::Trait(ref data) => {\n-                data.skip_binder().input_types().collect()\n+                WalkTysIter::InputTypes(data.skip_binder().input_types())\n             }\n             ty::Predicate::Subtype(binder) => {\n                 let SubtypePredicate { a, b, a_is_expected: _ } = binder.skip_binder();\n-                vec![a, b]\n+                WalkTysIter::Two(a, b)\n             }\n             ty::Predicate::TypeOutlives(binder) => {\n-                vec![binder.skip_binder().0]\n+                WalkTysIter::One(binder.skip_binder().0)\n             }\n             ty::Predicate::RegionOutlives(..) => {\n-                vec![]\n+                WalkTysIter::None\n             }\n             ty::Predicate::Projection(ref data) => {\n                 let inner = data.skip_binder();\n-                inner.projection_ty.substs.types().chain(Some(inner.ty)).collect()\n+                WalkTysIter::ProjectionTypes(\n+                    inner.projection_ty.substs.types().chain(Some(inner.ty)))\n             }\n             ty::Predicate::WellFormed(data) => {\n-                vec![data]\n+                WalkTysIter::One(data)\n             }\n             ty::Predicate::ObjectSafe(_trait_def_id) => {\n-                vec![]\n+                WalkTysIter::None\n             }\n             ty::Predicate::ClosureKind(_closure_def_id, closure_substs, _kind) => {\n-                closure_substs.substs.types().collect()\n+                WalkTysIter::Types(closure_substs.substs.types())\n             }\n             ty::Predicate::ConstEvaluatable(_, substs) => {\n-                substs.types().collect()\n+                WalkTysIter::Types(substs.types())\n             }\n-        };\n-\n-        // FIXME: The only reason to collect into a vector here is that I was\n-        // too lazy to make the full (somewhat complicated) iterator\n-        // type that would be needed here. But I wanted this fn to\n-        // return an iterator conceptually, rather than a `Vec`, so as\n-        // to be closer to `Ty::walk`.\n-        vec.into_iter()\n+        }\n     }\n \n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n@@ -1998,6 +2041,12 @@ impl ReprOptions {\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n     }\n+\n+    /// Returns true if this `#[repr()]` should inhibit union abi optimisations\n+    pub fn inhibit_union_abi_opt(&self) -> bool {\n+        self.c()\n+    }\n+\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {"}, {"sha": "7d3ae64f4fcd636d55cf17ab760a2feb440949be", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -281,7 +281,7 @@ impl<'sess> OnDiskCache<'sess> {\n                         // otherwise, abort\n                         break;\n                     }\n-                    interpret_alloc_index.reserve(new_n);\n+                    interpret_alloc_index.reserve(new_n - n);\n                     for idx in n..new_n {\n                         let id = encoder.interpret_allocs_inverse[idx];\n                         let pos = encoder.position() as u32;"}, {"sha": "d53370d242bd94c842e2bdc3557470e4aeb06453", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -678,8 +678,8 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"UpvarId({:?};`{}`;{:?})\",\n-               self.var_id,\n-               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n+               self.var_path.hir_id,\n+               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_path.hir_id))),\n                self.closure_expr_id)\n     }\n }"}, {"sha": "21fb0cdf90ad12306cfa346806ec747c9f0cc725", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -453,8 +453,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     }\n                     None\n                 }\n-                LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                    self.bccx.used_mut_nodes.borrow_mut().insert(var_id);\n+                LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n+                    self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                     None\n                 }\n                 LpExtend(ref base, mc::McInherited, LpDeref(pointer_kind)) |"}, {"sha": "cfd530b7e3d0924bc346687df631c92b8d05f657", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -97,7 +97,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            let var_node_id = bccx.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+            let var_node_id = bccx.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n             err.span_label(bccx.tcx.hir.span(var_node_id),\n                            \"captured outer variable\");\n         }"}, {"sha": "d189460d088484af00d84dd6656a173266f5e39a", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -846,7 +846,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     MutabilityViolation => {\n                         let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n                         if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n-                            let node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_id);\n+                            let node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n                             let sp = self.tcx.hir.span(node_id);\n                             let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n                                                   environment for modifications\";\n@@ -1415,7 +1415,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                       loan_path: &LoanPath<'tcx>,\n                                       out: &mut String) {\n         match loan_path.kind {\n-            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) => {\n+            LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id}, closure_expr_id: _ }) => {\n                 out.push_str(&self.tcx.hir.name(self.tcx.hir.hir_to_node_id(id)).as_str());\n             }\n             LpVar(id) => {\n@@ -1533,7 +1533,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n                 write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir.node_to_string(id)))\n             }\n \n-            LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n+            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n                 let s = ty::tls::with(|tcx| {\n                     let var_node_id = tcx.hir.hir_to_node_id(var_id);\n                     tcx.hir.node_to_string(var_node_id)\n@@ -1568,9 +1568,9 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n                 write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir.node_to_user_string(id)))\n             }\n \n-            LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n+            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir.hir_to_node_id(var_id);\n+                    let var_node_id = tcx.hir.hir_to_node_id(hir_id);\n                     tcx.hir.node_to_string(var_node_id)\n                 });\n                 write!(f, \"$({} captured by closure)\", s)"}, {"sha": "79f073d643ddcb437641cc0f5bc7804292e0b1d1", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -16,7 +16,6 @@ serialize = { path = \"../libserialize\" }\n graphviz = { path = \"../libgraphviz\" }\n cfg-if = \"0.1.2\"\n stable_deref_trait = \"1.0.0\"\n-parking_lot_core = \"0.2.8\"\n rustc-rayon = \"0.1.1\"\n rustc-rayon-core = \"0.1.1\"\n rustc-hash = \"1.0.1\""}, {"sha": "0aa1924c0e59c693df6a4524a569418391aa0111", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -664,7 +664,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n             let var_hir_id = tcx.hir.node_to_hir_id(var_id);\n             let closure_expr_id = tcx.hir.local_def_id(fn_id);\n             let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_id: var_hir_id,\n+                var_path: ty::UpvarPath {hir_id: var_hir_id},\n                 closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n             });\n             let by_ref = match capture {"}, {"sha": "51046399ec2017bed8a78d95f84f155f6fc38bd1", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -365,13 +365,19 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         ret: Option<mir::BasicBlock>,\n     ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n-        if !ecx.tcx.is_const_fn(instance.def_id()) {\n+        // Execution might have wandered off into other crates, so we cannot to a stability-\n+        // sensitive check here.  But we can at least rule out functions that are not const\n+        // at all.\n+        if !ecx.tcx.is_const_fn_raw(instance.def_id()) {\n             // Some functions we support even if they are non-const -- but avoid testing\n-            // that for const fn!\n-            if ecx.hook_fn(instance, args, dest)? {\n+            // that for const fn!  We certainly do *not* want to actually call the fn\n+            // though, so be sure we return here.\n+            return if ecx.hook_fn(instance, args, dest)? {\n                 ecx.goto_block(ret)?; // fully evaluated and done\n-                return Ok(None);\n-            }\n+                Ok(None)\n+            } else {\n+                err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n+            };\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def) {"}, {"sha": "2e9edf20c5708f3e2dc966fd2d04a10f9d1fa44d", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -1061,7 +1061,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n             let upvar_id = ty::UpvarId {\n-                var_id: var_hir_id,\n+                var_path: ty::UpvarPath {hir_id: var_hir_id},\n                 closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n             };\n             match cx.tables().upvar_capture(upvar_id) {\n@@ -1178,7 +1178,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    -> ExprRef<'tcx> {\n     let var_hir_id = cx.tcx.hir.node_to_hir_id(freevar.var_id());\n     let upvar_id = ty::UpvarId {\n-        var_id: var_hir_id,\n+        var_path: ty::UpvarPath { hir_id: var_hir_id },\n         closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).to_local(),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);"}, {"sha": "7d636b77ced4ce9453941fd90989e085ac7bfebf", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -44,28 +44,34 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             Misc => {\n+                let src_layout = src.layout;\n                 let src = self.read_immediate(src)?;\n \n-                if self.type_is_fat_ptr(src.layout.ty) {\n-                    match (*src, self.type_is_fat_ptr(dest.layout.ty)) {\n+                // There are no casts to references\n+                assert!(!dest.layout.ty.is_region_ptr());\n+                // Hence we make all casts erase the tag\n+                let src = src.erase_tag().with_default_tag();\n+\n+                if self.type_is_fat_ptr(src_layout.ty) {\n+                    match (src, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n                         (Immediate::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n                         (Immediate::ScalarPair(..), true) => {\n                             // No change to immediate\n-                            self.write_immediate(*src, dest)?;\n+                            self.write_immediate(src, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n                         (Immediate::ScalarPair(data, _), false) => {\n                             self.write_scalar(data, dest)?;\n                         }\n                     }\n                 } else {\n-                    match src.layout.variants {\n+                    match src_layout.variants {\n                         layout::Variants::Single { index } => {\n-                            if let Some(def) = src.layout.ty.ty_adt_def() {\n+                            if let Some(def) = src_layout.ty.ty_adt_def() {\n                                 // Cast from a univariant enum\n-                                assert!(src.layout.is_zst());\n+                                assert!(src_layout.is_zst());\n                                 let discr_val = def\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n@@ -78,7 +84,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         layout::Variants::NicheFilling { .. } => {},\n                     }\n \n-                    let dest_val = self.cast_scalar(src.to_scalar()?, src.layout, dest.layout)?;\n+                    let dest_val = self.cast_scalar(src.to_scalar()?, src_layout, dest.layout)?;\n                     self.write_scalar(dest_val, dest)?;\n                 }\n             }"}, {"sha": "ce7269d1e78394f65c798d3337a3590d114079ac", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -14,7 +14,6 @@ use std::mem;\n use syntax::source_map::{self, Span, DUMMY_SP};\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n-use rustc::hir::map::definitions::DefPathData;\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n@@ -667,11 +666,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         }\n     }\n \n-    pub fn generate_stacktrace(&self, explicit_span: Option<Span>) -> Vec<FrameInfo> {\n+    pub fn generate_stacktrace(&self, explicit_span: Option<Span>) -> Vec<FrameInfo<'tcx>> {\n         let mut last_span = None;\n         let mut frames = Vec::new();\n-        // skip 1 because the last frame is just the environment of the constant\n-        for &Frame { instance, span, mir, block, stmt, .. } in self.stack().iter().skip(1).rev() {\n+        for &Frame { instance, span, mir, block, stmt, .. } in self.stack().iter().rev() {\n             // make sure we don't emit frames that are duplicates of the previous\n             if explicit_span == Some(span) {\n                 last_span = Some(span);\n@@ -684,13 +682,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             } else {\n                 last_span = Some(span);\n             }\n-            let location = if self.tcx.def_key(instance.def_id()).disambiguated_data.data\n-                == DefPathData::ClosureExpr\n-            {\n-                \"closure\".to_owned()\n-            } else {\n-                instance.to_string()\n-            };\n             let block = &mir.basic_blocks()[block];\n             let source_info = if stmt < block.statements.len() {\n                 block.statements[stmt].source_info\n@@ -701,7 +692,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 mir::ClearCrossCrate::Set(ref ivs) => Some(ivs[source_info.scope].lint_root),\n                 mir::ClearCrossCrate::Clear => None,\n             };\n-            frames.push(FrameInfo { span, location, lint_root });\n+            frames.push(FrameInfo { call_site: span, instance, lint_root });\n         }\n         trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);\n         frames"}, {"sha": "c5a242f334c90ebedca7b1fc14bfcd7b150ace62", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::ast::Mutability;\n \n use super::{\n-    Pointer, AllocId, Allocation, ConstValue, GlobalId, AllocationExtra,\n+    Pointer, AllocId, Allocation, ConstValue, GlobalId, AllocationExtra, InboundsCheck,\n     EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ScalarMaybeUndef, ErrorHandled,\n };\n@@ -249,17 +249,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr {\n             Scalar::Ptr(ptr) => {\n-                let (size, align) = self.get_size_and_align(ptr.alloc_id);\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n-                if ptr.offset > size {\n-                    return err!(PointerOutOfBounds {\n-                        ptr: ptr.erase_tag(),\n-                        access: true,\n-                        allocation_size: size,\n-                    });\n-                };\n-                // keep data for alignment check\n+                self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead)?;\n+                // data required for alignment check\n+                let (_, align) = self.get_size_and_align(ptr.alloc_id);\n                 (ptr.offset.bytes(), align)\n             }\n             Scalar::Bits { bits, size } => {\n@@ -293,18 +287,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.  The `access` boolean is just used\n-    /// for the error message.\n-    /// If you want to check bounds before doing a memory access, be sure to\n-    /// check the pointer one past the end of your access, then everything will\n-    /// work out exactly.\n-    pub fn check_bounds_ptr(&self, ptr: Pointer<M::PointerTag>, access: bool) -> EvalResult<'tcx> {\n-        let alloc = self.get(ptr.alloc_id)?;\n-        let allocation_size = alloc.bytes.len() as u64;\n+    /// in-bounds!  This follows C's/LLVM's rules.  `check` indicates whether we\n+    /// additionally require the pointer to be pointing to a *live* (still allocated)\n+    /// allocation.\n+    /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n+    pub fn check_bounds_ptr(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+        check: InboundsCheck,\n+    ) -> EvalResult<'tcx> {\n+        let allocation_size = match check {\n+            InboundsCheck::Live => {\n+                let alloc = self.get(ptr.alloc_id)?;\n+                alloc.bytes.len() as u64\n+            }\n+            InboundsCheck::MaybeDead => {\n+                self.get_size_and_align(ptr.alloc_id).0.bytes()\n+            }\n+        };\n         if ptr.offset.bytes() > allocation_size {\n             return err!(PointerOutOfBounds {\n                 ptr: ptr.erase_tag(),\n-                access,\n+                check,\n                 allocation_size: Size::from_bytes(allocation_size),\n             });\n         }\n@@ -317,10 +321,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: Pointer<M::PointerTag>,\n         size: Size,\n-        access: bool\n+        check: InboundsCheck,\n     ) -> EvalResult<'tcx> {\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds_ptr(ptr.offset(size, &*self)?, access)\n+        self.check_bounds_ptr(ptr.offset(size, &*self)?, check)\n     }\n }\n \n@@ -626,7 +630,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        self.check_bounds(ptr, size, true)?;\n+        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n \n         if check_defined_and_ptr {\n             self.check_defined(ptr, size)?;\n@@ -677,7 +681,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        self.check_bounds(ptr, size, true)?;\n+        self.check_bounds(ptr, size, InboundsCheck::Live)?;\n \n         self.mark_definedness(ptr, size, true)?;\n         self.clear_relocations(ptr, size)?;"}, {"sha": "96ea0d509496665db414a8b05b82085dc59f0c1a", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -39,6 +39,6 @@ pub use self::machine::{Machine, AllocMap, MayLeak};\n \n pub use self::operand::{ScalarMaybeUndef, Immediate, ImmTy, Operand, OpTy};\n \n-pub use self::visitor::ValueVisitor;\n+pub use self::visitor::{ValueVisitor, MutValueVisitor};\n \n pub use self::validity::RefTracking;"}, {"sha": "b7910ad3bce9ed1adf8ece1a301320b9131c4942", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -19,7 +19,7 @@ use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerEx\n use rustc::mir::interpret::{\n     GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n-    EvalResult, EvalErrorKind\n+    EvalResult, EvalErrorKind, InboundsCheck,\n };\n use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -601,7 +601,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         // read raw discriminant value\n         let discr_op = self.operand_field(rval, 0)?;\n         let discr_val = self.read_immediate(discr_op)?;\n-        let raw_discr = discr_val.to_scalar()?;\n+        let raw_discr = discr_val.to_scalar_or_undef();\n         trace!(\"discr value: {:?}\", raw_discr);\n         // post-process\n         Ok(match rval.layout.variants {\n@@ -647,28 +647,33 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;\n                 match raw_discr {\n-                    Scalar::Ptr(_) => {\n-                        // The niche must be just 0 (which a pointer value never is)\n-                        assert!(niche_start == 0);\n-                        assert!(variants_start == variants_end);\n+                    ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n+                        // The niche must be just 0 (which an inbounds pointer value never is)\n+                        let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n+                            self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok();\n+                        if !ptr_valid {\n+                            return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n+                        }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n-                    Scalar::Bits { bits: raw_discr, size } => {\n+                    ScalarMaybeUndef::Scalar(Scalar::Bits { bits: raw_discr, size }) => {\n                         assert_eq!(size as u64, discr_val.layout.size.bytes());\n-                        let discr = raw_discr.wrapping_sub(niche_start)\n+                        let adjusted_discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n-                        if variants_start <= discr && discr <= variants_end {\n-                            let index = discr as usize;\n-                            assert_eq!(index as u128, discr);\n+                        if variants_start <= adjusted_discr && adjusted_discr <= variants_end {\n+                            let index = adjusted_discr as usize;\n+                            assert_eq!(index as u128, adjusted_discr);\n                             assert!(index < rval.layout.ty\n                                 .ty_adt_def()\n                                 .expect(\"tagged layout for non adt\")\n                                 .variants.len());\n-                            (discr, VariantIdx::from_usize(index))\n+                            (adjusted_discr, VariantIdx::from_usize(index))\n                         } else {\n                             (dataful_variant.as_u32() as u128, dataful_variant)\n                         }\n                     },\n+                    ScalarMaybeUndef::Undef =>\n+                        return err!(InvalidDiscriminant(ScalarMaybeUndef::Undef)),\n                 }\n             }\n         })"}, {"sha": "ad7ffd291bed1002985c69181ee6e174fd8f5ba4", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -17,11 +17,11 @@ use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocType, EvalResult, EvalErrorKind,\n+    Scalar, AllocType, EvalResult, EvalErrorKind, InboundsCheck,\n };\n \n use super::{\n-    OpTy, MPlaceTy, ImmTy, Machine, EvalContext, ValueVisitor\n+    OpTy, MPlaceTy, Machine, EvalContext, ValueVisitor\n };\n \n macro_rules! validation_failure {\n@@ -274,15 +274,16 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     ),\n                 EvalErrorKind::ReadPointerAsBytes =>\n                     validation_failure!(\n-                        \"a pointer\", self.path, \"plain bytes\"\n+                        \"a pointer\", self.path, \"plain (non-pointer) bytes\"\n                     ),\n                 _ => Err(err),\n             }\n         }\n     }\n \n-    fn visit_primitive(&mut self, value: ImmTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n+    fn visit_primitive(&mut self, value: OpTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n     {\n+        let value = self.ecx.read_immediate(value)?;\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n         match ty.sty {\n@@ -304,7 +305,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 if self.const_mode {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     try_validation!(value.to_bits(size),\n-                        value, self.path, \"initialized plain bits\");\n+                        value, self.path, \"initialized plain (non-pointer) bytes\");\n                 } else {\n                     // At run-time, for now, we accept *anything* for these types, including\n                     // undef. We should fix that, but let's start low.\n@@ -394,7 +395,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                         }\n                         // Maintain the invariant that the place we are checking is\n                         // already verified to be in-bounds.\n-                        try_validation!(self.ecx.memory.check_bounds(ptr, size, false),\n+                        try_validation!(\n+                            self.ecx.memory.check_bounds(ptr, size, InboundsCheck::Live),\n                             \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination"}, {"sha": "f0a71242599bff68a6001753760487450b4e6ed4", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, EvalContext, MPlaceTy, OpTy, ImmTy,\n+    Machine, EvalContext, MPlaceTy, OpTy,\n };\n \n // A thing that we can project into, and that has a layout.\n@@ -201,9 +201,11 @@ macro_rules! make_value_visitor {\n             { Ok(()) }\n \n             /// Called whenever we reach a value of primitive type.  There can be no recursion\n-            /// below such a value.  This is the leave function.\n+            /// below such a value.  This is the leaf function.\n+            /// We do *not* provide an `ImmTy` here because some implementations might want\n+            /// to write to the place this primitive lives in.\n             #[inline(always)]\n-            fn visit_primitive(&mut self, _val: ImmTy<'tcx, M::PointerTag>) -> EvalResult<'tcx>\n+            fn visit_primitive(&mut self, _v: Self::V) -> EvalResult<'tcx>\n             { Ok(()) }\n \n             // Default recursors. Not meant to be overloaded.\n@@ -279,9 +281,7 @@ macro_rules! make_value_visitor {\n                     _ => v.layout().ty.builtin_deref(true).is_some(),\n                 };\n                 if primitive {\n-                    let op = v.to_op(self.ecx())?;\n-                    let val = self.ecx().read_immediate(op)?;\n-                    return self.visit_primitive(val);\n+                    return self.visit_primitive(v);\n                 }\n \n                 // Proceed into the fields."}, {"sha": "f7ef1390f14deace706a5f8b47883bbd61a8cb23", "filename": "src/librustc_target/abi/call/powerpc64.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fpowerpc64.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -14,11 +14,12 @@\n \n use abi::call::{FnType, ArgType, Reg, RegKind, Uniform};\n use abi::{Align, Endian, HasDataLayout, LayoutOf, TyLayout, TyLayoutMethods};\n+use spec::HasTargetSpec;\n \n #[derive(Debug, Clone, Copy, PartialEq)]\n enum ABI {\n     ELFv1, // original ABI used for powerpc64 (big-endian)\n-    ELFv2, // newer ABI used for powerpc64le\n+    ELFv2, // newer ABI used for powerpc64le and musl (both endians)\n }\n use self::ABI::*;\n \n@@ -75,7 +76,9 @@ fn classify_ret_ty<'a, Ty, C>(cx: &C, ret: &mut ArgType<'a, Ty>, abi: ABI)\n     let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n-        let unit = if bits <= 8 {\n+        let unit = if cx.data_layout().endian == Endian::Big {\n+            Reg { kind: RegKind::Integer, size }\n+        } else if bits <= 8 {\n             Reg::i8()\n         } else if bits <= 16 {\n             Reg::i16()\n@@ -110,22 +113,15 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n     }\n \n     let size = arg.layout.size;\n-    let (unit, total) = match abi {\n-        ELFv1 => {\n-            // In ELFv1, aggregates smaller than a doubleword should appear in\n-            // the least-significant bits of the parameter doubleword.  The rest\n-            // should be padded at their tail to fill out multiple doublewords.\n-            if size.bits() <= 64 {\n-                (Reg { kind: RegKind::Integer, size }, size)\n-            } else {\n-                let align = Align::from_bits(64, 64).unwrap();\n-                (Reg::i64(), size.abi_align(align))\n-            }\n-        },\n-        ELFv2 => {\n-            // In ELFv2, we can just cast directly.\n-            (Reg::i64(), size)\n-        },\n+    let (unit, total) = if size.bits() <= 64 {\n+        // Aggregates smaller than a doubleword should appear in\n+        // the least-significant bits of the parameter doubleword.\n+        (Reg { kind: RegKind::Integer, size }, size)\n+    } else {\n+        // Aggregates larger than a doubleword should be padded\n+        // at the tail to fill out a whole number of doublewords.\n+        let align = Align::from_bits(64, 64).unwrap();\n+        (Reg::i64(), size.abi_align(align))\n     };\n \n     arg.cast_to(Uniform {\n@@ -136,11 +132,15 @@ fn classify_arg_ty<'a, Ty, C>(cx: &C, arg: &mut ArgType<'a, Ty>, abi: ABI)\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fty: &mut FnType<'a, Ty>)\n     where Ty: TyLayoutMethods<'a, C> + Copy,\n-          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout\n+          C: LayoutOf<Ty = Ty, TyLayout = TyLayout<'a, Ty>> + HasDataLayout + HasTargetSpec\n {\n-    let abi = match cx.data_layout().endian {\n-        Endian::Big => ELFv1,\n-        Endian::Little => ELFv2,\n+    let abi = if cx.target_spec().target_env == \"musl\" {\n+        ELFv2\n+    } else {\n+        match cx.data_layout().endian {\n+            Endian::Big => ELFv1,\n+            Endian::Little => ELFv2\n+        }\n     };\n \n     if !fty.ret.is_ignore() {"}, {"sha": "22afb0da05bc14843bd66b4dd34dda2549d80f20", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -229,7 +229,7 @@ impl HasDataLayout for TargetDataLayout {\n }\n \n /// Endianness of the target, which must match cfg(target-endian).\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq)]\n pub enum Endian {\n     Little,\n     Big"}, {"sha": "f67152ee90b7a0abcd9cd31b6291fd8fe4ad4f89", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -297,7 +297,9 @@ supported_targets! {\n     (\"mipsel-unknown-linux-gnu\", mipsel_unknown_linux_gnu),\n     (\"powerpc-unknown-linux-gnu\", powerpc_unknown_linux_gnu),\n     (\"powerpc-unknown-linux-gnuspe\", powerpc_unknown_linux_gnuspe),\n+    (\"powerpc-unknown-linux-musl\", powerpc_unknown_linux_musl),\n     (\"powerpc64-unknown-linux-gnu\", powerpc64_unknown_linux_gnu),\n+    (\"powerpc64-unknown-linux-musl\", powerpc64_unknown_linux_musl),\n     (\"powerpc64le-unknown-linux-gnu\", powerpc64le_unknown_linux_gnu),\n     (\"powerpc64le-unknown-linux-musl\", powerpc64le_unknown_linux_musl),\n     (\"s390x-unknown-linux-gnu\", s390x_unknown_linux_gnu),"}, {"sha": "95e95510e1feaa729eff698ddadc8572c73b642f", "filename": "src/librustc_target/spec/powerpc64_unknown_linux_musl.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_linux_musl.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+    base.cpu = \"ppc64\".to_string();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc64-unknown-linux-musl\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n+        arch: \"powerpc64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "1a4d0cb323f1fdef373e4ace1b45a867689ab2fe", "filename": "src/librustc_target/spec/powerpc_unknown_linux_musl.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc_unknown_linux_musl.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n+    base.max_atomic_width = Some(32);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc-unknown-linux-musl\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n+        arch: \"powerpc\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "7a71cf57a2f2784f3184feee8bdfaaed90d69441", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 63, "deletions": 32, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -219,35 +219,62 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                let mut err = type_error_struct!(\n-                    self.tcx.sess,\n-                    call_expr.span,\n-                    callee_ty,\n-                    E0618,\n-                    \"expected function, found {}\",\n-                    match unit_variant {\n-                        Some(ref path) => format!(\"enum variant `{}`\", path),\n-                        None => format!(\"`{}`\", callee_ty),\n-                    });\n-\n-                err.span_label(call_expr.span, \"not a function\");\n+                if let hir::ExprKind::Call(ref callee, _) = call_expr.node {\n+                    let mut err = type_error_struct!(\n+                        self.tcx.sess,\n+                        callee.span,\n+                        callee_ty,\n+                        E0618,\n+                        \"expected function, found {}\",\n+                        match unit_variant {\n+                            Some(ref path) => format!(\"enum variant `{}`\", path),\n+                            None => format!(\"`{}`\", callee_ty),\n+                        });\n \n-                if let Some(ref path) = unit_variant {\n-                    err.span_suggestion_with_applicability(\n-                        call_expr.span,\n-                        &format!(\"`{}` is a unit variant, you need to write it \\\n-                                  without the parenthesis\", path),\n-                        path.to_string(),\n-                        Applicability::MachineApplicable\n-                    );\n-                }\n+                    if let Some(ref path) = unit_variant {\n+                        err.span_suggestion_with_applicability(\n+                            call_expr.span,\n+                            &format!(\"`{}` is a unit variant, you need to write it \\\n+                                      without the parenthesis\", path),\n+                            path.to_string(),\n+                            Applicability::MachineApplicable\n+                        );\n+                    }\n \n-                if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n-                    let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n-                        self.tables.borrow().qpath_def(qpath, expr.hir_id)\n-                    } else {\n-                        Def::Err\n+                    let mut inner_callee_path = None;\n+                    let def = match callee.node {\n+                        hir::ExprKind::Path(ref qpath) => {\n+                            self.tables.borrow().qpath_def(qpath, callee.hir_id)\n+                        },\n+                        hir::ExprKind::Call(ref inner_callee, _) => {\n+                            // If the call spans more than one line and the callee kind is\n+                            // itself another `ExprCall`, that's a clue that we might just be\n+                            // missing a semicolon (Issue #51055)\n+                            let call_is_multiline = self.tcx.sess.source_map()\n+                                .is_multiline(call_expr.span);\n+                            if call_is_multiline {\n+                                let span = self.tcx.sess.source_map().next_point(callee.span);\n+                                err.span_suggestion_with_applicability(\n+                                    span,\n+                                    \"try adding a semicolon\",\n+                                    \";\".to_owned(),\n+                                    Applicability::MaybeIncorrect\n+                                );\n+                            }\n+                            if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.node {\n+                                inner_callee_path = Some(inner_qpath);\n+                                self.tables.borrow().qpath_def(inner_qpath, inner_callee.hir_id)\n+                            } else {\n+                                Def::Err\n+                            }\n+                        },\n+                        _ => {\n+                            Def::Err\n+                        }\n                     };\n+\n+                    err.span_label(call_expr.span, \"call expression requires function\");\n+\n                     let def_span = match def {\n                         Def::Err => None,\n                         Def::Local(id) | Def::Upvar(id, ..) => {\n@@ -256,16 +283,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => self.tcx.hir.span_if_local(def.def_id())\n                     };\n                     if let Some(span) = def_span {\n-                        let name = match unit_variant {\n-                            Some(path) => path,\n-                            None => callee_ty.to_string(),\n+                        let label = match (unit_variant, inner_callee_path) {\n+                            (Some(path), _) => format!(\"`{}` defined here\", path),\n+                            (_, Some(hir::QPath::Resolved(_, path))) => format!(\n+                                \"`{}` defined here returns `{}`\", path, callee_ty.to_string()\n+                            ),\n+                            _ => format!(\"`{}` defined here\", callee_ty.to_string()),\n                         };\n-                        err.span_label(span, format!(\"`{}` defined here\", name));\n+                        err.span_label(span, label);\n                     }\n+                    err.emit();\n+                } else {\n+                    bug!(\"call_expr.node should be an ExprKind::Call, got {:?}\", call_expr.node);\n                 }\n \n-                err.emit();\n-\n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n                 // set up all the node type bindings."}, {"sha": "312ce402775d226759853d2c424ace38fe65a373", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 82, "deletions": 78, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -45,14 +45,14 @@ use super::FnCtxt;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt, UpvarSubsts};\n+use rustc::hir::def_id::LocalDefId;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::infer::UpvarRegion;\n+use rustc::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir;\n-use rustc::hir::def_id::LocalDefId;\n-use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze(&self, body: &'gcx hir::Body) {\n@@ -121,7 +121,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let infer_kind = if let UpvarSubsts::Closure(closure_substs) = substs{\n+        let infer_kind = if let UpvarSubsts::Closure(closure_substs) = substs {\n             if self.closure_kind(closure_def_id, closure_substs).is_none() {\n                 Some(closure_substs)\n             } else {\n@@ -134,7 +134,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.with_freevars(closure_node_id, |freevars| {\n             for freevar in freevars {\n                 let upvar_id = ty::UpvarId {\n-                    var_id: self.tcx.hir.node_to_hir_id(freevar.var_id()),\n+                    var_path: ty::UpvarPath {\n+                        hir_id : self.tcx.hir.node_to_hir_id(freevar.var_id()),\n+                    },\n                     closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                 };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n@@ -213,12 +215,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n         debug!(\n             \"analyze_closure: id={:?} substs={:?} final_upvar_tys={:?}\",\n-            closure_node_id,\n-            substs,\n-            final_upvar_tys\n+            closure_node_id, substs, final_upvar_tys\n         );\n-        for (upvar_ty, final_upvar_ty) in substs.upvar_tys(closure_def_id, self.tcx)\n-                                                .zip(final_upvar_tys)\n+        for (upvar_ty, final_upvar_ty) in substs\n+            .upvar_tys(closure_def_id, self.tcx)\n+            .zip(final_upvar_tys)\n         {\n             self.demand_suptype(span, upvar_ty, final_upvar_ty);\n         }\n@@ -249,16 +250,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let var_hir_id = tcx.hir.node_to_hir_id(var_node_id);\n                     let freevar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n-                        var_id: var_hir_id,\n+                        var_path: ty::UpvarPath {\n+                            hir_id: var_hir_id,\n+                        },\n                         closure_expr_id: LocalDefId::from_def_id(closure_def_index),\n                     };\n                     let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n                     debug!(\n                         \"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                        var_node_id,\n-                        freevar_ty,\n-                        capture\n+                        var_node_id, freevar_ty, capture\n                     );\n \n                     match capture {\n@@ -271,8 +272,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             },\n                         ),\n                     }\n-                })\n-                .collect()\n+                }).collect()\n         })\n     }\n }\n@@ -301,12 +301,14 @@ struct InferBorrowKind<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n-    fn adjust_upvar_borrow_kind_for_consume(&mut self, cmt: &mc::cmt_<'tcx>,\n-                                            mode: euv::ConsumeMode) {\n+    fn adjust_upvar_borrow_kind_for_consume(\n+        &mut self,\n+        cmt: &mc::cmt_<'tcx>,\n+        mode: euv::ConsumeMode,\n+    ) {\n         debug!(\n             \"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n-            cmt,\n-            mode\n+            cmt, mode\n         );\n \n         // we only care about moves\n@@ -349,7 +351,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         upvar_id.closure_expr_id,\n                         ty::ClosureKind::FnOnce,\n                         guarantor.span,\n-                        var_name(tcx, upvar_id.var_id),\n+                        var_name(tcx, upvar_id.var_path.hir_id),\n                     );\n \n                     self.adjust_upvar_captures\n@@ -366,7 +368,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         upvar_id.closure_expr_id,\n                         ty::ClosureKind::FnOnce,\n                         guarantor.span,\n-                        var_name(tcx, upvar_id.var_id),\n+                        var_name(tcx, upvar_id.var_path.hir_id),\n                     );\n                 }\n                 mc::NoteIndex | mc::NoteNone => {}\n@@ -381,9 +383,9 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n-            Categorization::Deref(base, mc::Unique) |\n-            Categorization::Interior(base, _) |\n-            Categorization::Downcast(base, _) => {\n+            Categorization::Deref(base, mc::Unique)\n+            | Categorization::Interior(base, _)\n+            | Categorization::Downcast(base, _) => {\n                 // Interior or owned data is mutable if base is\n                 // mutable, so iterate to the base.\n                 self.adjust_upvar_borrow_kind_for_mut(&base);\n@@ -399,12 +401,12 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Categorization::Deref(_, mc::UnsafePtr(..)) |\n-            Categorization::StaticItem |\n-            Categorization::ThreadLocal(..) |\n-            Categorization::Rvalue(..) |\n-            Categorization::Local(_) |\n-            Categorization::Upvar(..) => {\n+            Categorization::Deref(_, mc::UnsafePtr(..))\n+            | Categorization::StaticItem\n+            | Categorization::ThreadLocal(..)\n+            | Categorization::Rvalue(..)\n+            | Categorization::Local(_)\n+            | Categorization::Upvar(..) => {\n                 return;\n             }\n         }\n@@ -414,9 +416,9 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n-            Categorization::Deref(base, mc::Unique) |\n-            Categorization::Interior(base, _) |\n-            Categorization::Downcast(base, _) => {\n+            Categorization::Deref(base, mc::Unique)\n+            | Categorization::Interior(base, _)\n+            | Categorization::Downcast(base, _) => {\n                 // Interior or owned data is unique if base is\n                 // unique.\n                 self.adjust_upvar_borrow_kind_for_unique(&base);\n@@ -430,18 +432,20 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Categorization::Deref(_, mc::UnsafePtr(..)) |\n-            Categorization::StaticItem |\n-            Categorization::ThreadLocal(..) |\n-            Categorization::Rvalue(..) |\n-            Categorization::Local(_) |\n-            Categorization::Upvar(..) => {}\n+            Categorization::Deref(_, mc::UnsafePtr(..))\n+            | Categorization::StaticItem\n+            | Categorization::ThreadLocal(..)\n+            | Categorization::Rvalue(..)\n+            | Categorization::Local(_)\n+            | Categorization::Upvar(..) => {}\n         }\n     }\n \n-    fn try_adjust_upvar_deref(&mut self, cmt: &mc::cmt_<'tcx>, borrow_kind: ty::BorrowKind)\n-                              -> bool\n-    {\n+    fn try_adjust_upvar_deref(\n+        &mut self,\n+        cmt: &mc::cmt_<'tcx>,\n+        borrow_kind: ty::BorrowKind,\n+    ) -> bool {\n         assert!(match borrow_kind {\n             ty::MutBorrow => true,\n             ty::UniqueImmBorrow => true,\n@@ -465,7 +469,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                     upvar_id.closure_expr_id,\n                     ty::ClosureKind::FnMut,\n                     cmt.span,\n-                    var_name(tcx, upvar_id.var_id),\n+                    var_name(tcx, upvar_id.var_path.hir_id),\n                 );\n \n                 true\n@@ -478,7 +482,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                     upvar_id.closure_expr_id,\n                     ty::ClosureKind::FnMut,\n                     cmt.span,\n-                    var_name(tcx, upvar_id.var_id),\n+                    var_name(tcx, upvar_id.var_path.hir_id),\n                 );\n \n                 true\n@@ -493,15 +497,14 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n     fn adjust_upvar_borrow_kind(&mut self, upvar_id: ty::UpvarId, kind: ty::BorrowKind) {\n-        let upvar_capture = self.adjust_upvar_captures\n+        let upvar_capture = self\n+            .adjust_upvar_captures\n             .get(&upvar_id)\n             .cloned()\n             .unwrap_or_else(|| self.fcx.tables.borrow().upvar_capture(upvar_id));\n         debug!(\n             \"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n-            upvar_id,\n-            upvar_capture,\n-            kind\n+            upvar_id, upvar_capture, kind\n         );\n \n         match upvar_capture {\n@@ -511,18 +514,18 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             ty::UpvarCapture::ByRef(mut upvar_borrow) => {\n                 match (upvar_borrow.kind, kind) {\n                     // Take RHS:\n-                    (ty::ImmBorrow, ty::UniqueImmBorrow) |\n-                    (ty::ImmBorrow, ty::MutBorrow) |\n-                    (ty::UniqueImmBorrow, ty::MutBorrow) => {\n+                    (ty::ImmBorrow, ty::UniqueImmBorrow)\n+                    | (ty::ImmBorrow, ty::MutBorrow)\n+                    | (ty::UniqueImmBorrow, ty::MutBorrow) => {\n                         upvar_borrow.kind = kind;\n                         self.adjust_upvar_captures\n                             .insert(upvar_id, ty::UpvarCapture::ByRef(upvar_borrow));\n                     }\n                     // Take LHS:\n-                    (ty::ImmBorrow, ty::ImmBorrow) |\n-                    (ty::UniqueImmBorrow, ty::ImmBorrow) |\n-                    (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n-                    (ty::MutBorrow, _) => {}\n+                    (ty::ImmBorrow, ty::ImmBorrow)\n+                    | (ty::UniqueImmBorrow, ty::ImmBorrow)\n+                    | (ty::UniqueImmBorrow, ty::UniqueImmBorrow)\n+                    | (ty::MutBorrow, _) => {}\n                 }\n             }\n         }\n@@ -537,10 +540,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     ) {\n         debug!(\n             \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n-            closure_id,\n-            new_kind,\n-            upvar_span,\n-            var_name\n+            closure_id, new_kind, upvar_span, var_name\n         );\n \n         // Is this the closure whose kind is currently being inferred?\n@@ -554,22 +554,20 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n-            closure_id,\n-            existing_kind,\n-            new_kind\n+            closure_id, existing_kind, new_kind\n         );\n \n         match (existing_kind, new_kind) {\n-            (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::Fn) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-            (ty::ClosureKind::FnOnce, _) => {\n+            (ty::ClosureKind::Fn, ty::ClosureKind::Fn)\n+            | (ty::ClosureKind::FnMut, ty::ClosureKind::Fn)\n+            | (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut)\n+            | (ty::ClosureKind::FnOnce, _) => {\n                 // no change needed\n             }\n \n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) |\n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut)\n+            | (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce)\n+            | (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                 // new kind is stronger than the old kind\n                 self.current_closure_kind = new_kind;\n                 self.current_origin = Some((upvar_span, var_name));\n@@ -590,12 +588,20 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn matched_pat(&mut self, _matched_pat: &hir::Pat, _cmt: &mc::cmt_<'tcx>,\n-                   _mode: euv::MatchMode) {\n+    fn matched_pat(\n+        &mut self,\n+        _matched_pat: &hir::Pat,\n+        _cmt: &mc::cmt_<'tcx>,\n+        _mode: euv::MatchMode,\n+    ) {\n     }\n \n-    fn consume_pat(&mut self, _consume_pat: &hir::Pat, cmt: &mc::cmt_<'tcx>,\n-                   mode: euv::ConsumeMode) {\n+    fn consume_pat(\n+        &mut self,\n+        _consume_pat: &hir::Pat,\n+        cmt: &mc::cmt_<'tcx>,\n+        mode: euv::ConsumeMode,\n+    ) {\n         debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n@@ -611,9 +617,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     ) {\n         debug!(\n             \"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n-            borrow_id,\n-            cmt,\n-            bk\n+            borrow_id, cmt, bk\n         );\n \n         match bk {"}, {"sha": "4460d5f64ce26283e7d93e99dd29622b8a7fa941", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -306,7 +306,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n                     let r = upvar_borrow.region;\n-                    let r = self.resolve(&r, &upvar_id.var_id);\n+                    let r = self.resolve(&r, &upvar_id.var_path.hir_id);\n                     ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n                         kind: upvar_borrow.kind,\n                         region: r,"}, {"sha": "f5056cead567e3acb59d50f69ff40d050f84723a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -527,7 +527,7 @@ fn resolution_failure(\n                 doc_comment_padding +\n                     // Each subsequent leading whitespace and `///`\n                     code_dox.lines().skip(1).take(line_offset - 1).fold(0, |sum, line| {\n-                        sum + doc_comment_padding + line.len() - line.trim().len()\n+                        sum + doc_comment_padding + line.len() - line.trim_start().len()\n                     })\n             };\n "}, {"sha": "5604729d2f8dc80819fda77d72c9888c1ca6faa3", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -146,7 +146,7 @@ impl FromHex for str {\n         }\n \n         match modulus {\n-            0 => Ok(b.into_iter().collect()),\n+            0 => Ok(b),\n             _ => Err(InvalidHexLength),\n         }\n     }"}, {"sha": "ec9207ea45b4fc74592a519a6e6f171105b2fc7e", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -69,7 +69,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n ///\n /// let (tx, rx) = channel();\n /// for _ in 0..N {\n-///     let (data, tx) = (data.clone(), tx.clone());\n+///     let (data, tx) = (Arc::clone(&data), tx.clone());\n ///     thread::spawn(move || {\n ///         // The shared state can only be accessed once the lock is held.\n ///         // Our non-atomic increment is safe because we're the only thread"}, {"sha": "58be1972a81210241cbab9b5c25e7437aa1510e4", "filename": "src/libstd/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -481,7 +481,7 @@ mod tests {\n             let (a, b) = ($a, $b);\n             if a != b {\n                 let (a, b) = if a > b {(a, b)} else {(b, a)};\n-                assert!(a - Duration::new(0, 100) <= b,\n+                assert!(a - Duration::new(0, 1000) <= b,\n                         \"{:?} is not almost equal to {:?}\", a, b);\n             }\n         })"}, {"sha": "0584cd5a3df47bed085b896c6becfab9505845ea", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -1890,7 +1890,6 @@ mod tests {\n             missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n             raw_identifier_spans: Lock::new(Vec::new()),\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n-            non_modrs_mods: Lock::new(vec![]),\n             buffered_lints: Lock::new(vec![]),\n         }\n     }"}, {"sha": "ac972f20f94326f5f52c863011a42ddf35265a08", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -52,9 +52,6 @@ pub struct ParseSess {\n     pub raw_identifier_spans: Lock<Vec<Span>>,\n     /// The registered diagnostics codes\n     crate registered_diagnostics: Lock<ErrorMap>,\n-    // Spans where a `mod foo;` statement was included in a non-mod.rs file.\n-    // These are used to issue errors if the non_modrs_mods feature is not enabled.\n-    pub non_modrs_mods: Lock<Vec<(ast::Ident, Span)>>,\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: Lock<Vec<PathBuf>>,\n     source_map: Lrc<SourceMap>,\n@@ -81,7 +78,6 @@ impl ParseSess {\n             registered_diagnostics: Lock::new(ErrorMap::new()),\n             included_mod_stack: Lock::new(vec![]),\n             source_map,\n-            non_modrs_mods: Lock::new(vec![]),\n             buffered_lints: Lock::new(vec![]),\n         }\n     }"}, {"sha": "b4fc9c2c6fc7ca568c9e62eb832433371f7d745b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -6591,16 +6591,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let relative = match self.directory.ownership {\n-            DirectoryOwnership::Owned { relative } => {\n-                // Push the usage onto the list of non-mod.rs mod uses.\n-                // This is used later for feature-gate error reporting.\n-                if let Some(cur_file_ident) = relative {\n-                    self.sess\n-                        .non_modrs_mods.borrow_mut()\n-                        .push((cur_file_ident, id_sp));\n-                }\n-                relative\n-            },\n+            DirectoryOwnership::Owned { relative } => relative,\n             DirectoryOwnership::UnownedViaBlock |\n             DirectoryOwnership::UnownedViaMod(_) => None,\n         };"}, {"sha": "a5b12ce4c4d834c83586cd0f3e2321ffd342be54", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -1200,16 +1200,14 @@ impl<'a> MethodDef<'a> {\n         let sp = trait_.span;\n         let variants = &enum_def.variants;\n \n-        let self_arg_names = self_args.iter()\n-            .enumerate()\n-            .map(|(arg_count, _self_arg)| {\n-                if arg_count == 0 {\n-                    \"__self\".to_string()\n-                } else {\n+        let self_arg_names = iter::once(\"__self\".to_string()).chain(\n+            self_args.iter()\n+                .enumerate()\n+                .skip(1)\n+                .map(|(arg_count, _self_arg)|\n                     format!(\"__arg_{}\", arg_count)\n-                }\n-            })\n-            .collect::<Vec<String>>();\n+                )\n+            ).collect::<Vec<String>>();\n \n         let self_arg_idents = self_arg_names.iter()\n             .map(|name| cx.ident_of(&name[..]))\n@@ -1218,7 +1216,7 @@ impl<'a> MethodDef<'a> {\n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to an int\n         // value corresponding to its discriminant.\n-        let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n+        let vi_idents = self_arg_names.iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n                 cx.ident_of(&vi_suffix[..]).gensym()"}, {"sha": "b8a171b52adf2c49deadf58c747c6e2e70f08052", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -53,7 +53,7 @@ pub fn expand_test_or_bench(\n         if let Annotatable::Item(i) = item { i }\n         else {\n             cx.parse_sess.span_diagnostic.span_fatal(item.span(),\n-                \"#[test] attribute is only allowed on fn items\").raise();\n+                \"#[test] attribute is only allowed on non associated functions\").raise();\n         };\n \n     if let ast::ItemKind::Mac(_) = item.node {"}, {"sha": "786968128ec1bbc06c32fc211f9ee018d6dbf1ed", "filename": "src/test/codegen/union-abi.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+// This test that using union forward the abi of the inner type, as\n+// discussed in #54668\n+\n+#![crate_type=\"lib\"]\n+#![feature(repr_simd)]\n+\n+#[derive(Copy, Clone)]\n+pub enum Unhab {}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct i64x4(i64, i64, i64, i64);\n+\n+#[derive(Copy, Clone)]\n+pub union UnionI64x4{ a:(), b: i64x4 }\n+\n+// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4(_: UnionI64x4) { loop {} }\n+\n+pub union UnionI64x4_{ a: i64x4, b: (), c:i64x4, d: Unhab, e: ((),()), f: UnionI64x4 }\n+\n+// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4_(_: UnionI64x4_) { loop {} }\n+\n+pub union UnionI64x4I64{ a: i64x4, b: i64 }\n+\n+// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4I64(_: UnionI64x4I64) { loop {} }\n+\n+pub union UnionI64x4Tuple{ a: i64x4, b: (i64, i64, i64, i64) }\n+\n+// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4Tuple(_: UnionI64x4Tuple) { loop {} }\n+\n+\n+pub union UnionF32{a:f32}\n+\n+// CHECK: define float @test_UnionF32(float %arg0)\n+#[no_mangle]\n+pub fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n+\n+pub union UnionF32F32{a:f32, b:f32}\n+\n+// CHECK: define float @test_UnionF32F32(float %arg0)\n+#[no_mangle]\n+pub fn test_UnionF32F32(_: UnionF32F32) -> UnionF32F32 { loop {} }\n+\n+pub union UnionF32U32{a:f32, b:u32}\n+\n+// CHECK: define i32 @test_UnionF32U32(i32)\n+#[no_mangle]\n+pub fn test_UnionF32U32(_: UnionF32U32) -> UnionF32U32 { loop {} }\n+\n+pub union UnionU128{a:u128}\n+// CHECK: define i128 @test_UnionU128(i128 %arg0)\n+#[no_mangle]\n+pub fn test_UnionU128(_: UnionU128) -> UnionU128 { loop {} }\n+\n+#[repr(C)]\n+pub union CUnionU128{a:u128}\n+// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n+"}, {"sha": "17dc9f94fe19c80c4ed26e877e121b5b34e43c3e", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -19,6 +19,7 @@ const fn f(x: usize) -> usize {\n     for i in 0..x {\n         //~^ ERROR E0015\n         //~| ERROR E0019\n+        //~| ERROR E0080\n         sum += i;\n     }\n     sum"}, {"sha": "1ed513033fd5d34f34644abd70d560d0fb750d02", "filename": "src/test/compile-fail/issue-52443.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -14,4 +14,5 @@ fn main() {\n     [(); {while true {break}; 0}]; //~ ERROR constant contains unimplemented expression type\n     [(); { for _ in 0usize.. {}; 0}]; //~ ERROR calls in constants are limited to constant functions\n     //~^ ERROR constant contains unimplemented expression type\n+    //~| ERROR evaluation of constant value failed\n }"}, {"sha": "2aaa28341ad91cc49a70f0049156646ca08ed9c0", "filename": "src/test/run-pass-fulldeps/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flinkage-visibility.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-musl - dlsym doesn't see symbols without \"-C link-arg=-Wl,--export-dynamic\"\n+\n #![feature(rustc_private)]\n \n // We're testing linkage visibility; the compiler warns us, but we want to"}, {"sha": "aa369bb17fead69364876919953e98598f570846", "filename": "src/test/run-pass/mpsc_stress.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmpsc_stress.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,172 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+// ignore-emscripten\n+\n+use std::sync::mpsc::channel;\n+use std::sync::mpsc::TryRecvError;\n+use std::sync::mpsc::RecvError;\n+use std::sync::mpsc::RecvTimeoutError;\n+use std::sync::Arc;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::Ordering;\n+\n+use std::thread;\n+use std::time::Duration;\n+\n+\n+/// Simple thread synchronization utility\n+struct Barrier {\n+    // Not using mutex/condvar for precision\n+    shared: Arc<AtomicUsize>,\n+    count: usize,\n+}\n+\n+impl Barrier {\n+    fn new(count: usize) -> Vec<Barrier> {\n+        let shared = Arc::new(AtomicUsize::new(0));\n+        (0..count).map(|_| Barrier { shared: shared.clone(), count: count }).collect()\n+    }\n+\n+    fn new2() -> (Barrier, Barrier) {\n+        let mut v = Barrier::new(2);\n+        (v.pop().unwrap(), v.pop().unwrap())\n+    }\n+\n+    /// Returns when `count` threads enter `wait`\n+    fn wait(self) {\n+        self.shared.fetch_add(1, Ordering::SeqCst);\n+        while self.shared.load(Ordering::SeqCst) != self.count {\n+        }\n+    }\n+}\n+\n+\n+fn shared_close_sender_does_not_lose_messages_iter() {\n+    let (tb, rb) = Barrier::new2();\n+\n+    let (tx, rx) = channel();\n+    let _ = tx.clone(); // convert to shared\n+\n+    thread::spawn(move || {\n+        tb.wait();\n+        thread::sleep(Duration::from_micros(1));\n+        tx.send(17).expect(\"send\");\n+        drop(tx);\n+    });\n+\n+    let i = rx.into_iter();\n+    rb.wait();\n+    // Make sure it doesn't return disconnected before returning an element\n+    assert_eq!(vec![17], i.collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn shared_close_sender_does_not_lose_messages() {\n+    for _ in 0..10000 {\n+        shared_close_sender_does_not_lose_messages_iter();\n+    }\n+}\n+\n+\n+// https://github.com/rust-lang/rust/issues/39364\n+fn concurrent_recv_timeout_and_upgrade_iter() {\n+    // 1 us\n+    let sleep = Duration::new(0, 1_000);\n+\n+    let (a, b) = Barrier::new2();\n+    let (tx, rx) = channel();\n+    let th = thread::spawn(move || {\n+        a.wait();\n+        loop {\n+            match rx.recv_timeout(sleep) {\n+                Ok(_) => {\n+                    break;\n+                },\n+                Err(_) => {},\n+            }\n+        }\n+    });\n+    b.wait();\n+    thread::sleep(sleep);\n+    tx.clone().send(()).expect(\"send\");\n+    th.join().unwrap();\n+}\n+\n+#[test]\n+fn concurrent_recv_timeout_and_upgrade() {\n+    // FIXME: fix and enable\n+    if true { return }\n+\n+    // at the moment of writing this test fails like this:\n+    // thread '<unnamed>' panicked at 'assertion failed: `(left == right)`\n+    //  left: `4561387584`,\n+    // right: `0`', libstd/sync/mpsc/shared.rs:253:13\n+\n+    for _ in 0..10000 {\n+        concurrent_recv_timeout_and_upgrade_iter();\n+    }\n+}\n+\n+\n+fn concurrent_writes_iter() {\n+    const THREADS: usize = 4;\n+    const PER_THR: usize = 100;\n+\n+    let mut bs = Barrier::new(THREADS + 1);\n+    let (tx, rx) = channel();\n+\n+    let mut threads = Vec::new();\n+    for j in 0..THREADS {\n+        let tx = tx.clone();\n+        let b = bs.pop().unwrap();\n+        threads.push(thread::spawn(move || {\n+            b.wait();\n+            for i in 0..PER_THR {\n+                tx.send(j * 1000 + i).expect(\"send\");\n+            }\n+        }));\n+    }\n+\n+    let b = bs.pop().unwrap();\n+    b.wait();\n+\n+    let mut v: Vec<_> = rx.iter().take(THREADS * PER_THR).collect();\n+    v.sort();\n+\n+    for j in 0..THREADS {\n+        for i in 0..PER_THR {\n+            assert_eq!(j * 1000 + i, v[j * PER_THR + i]);\n+        }\n+    }\n+\n+    for t in threads {\n+        t.join().unwrap();\n+    }\n+\n+    let one_us = Duration::new(0, 1000);\n+\n+    assert_eq!(TryRecvError::Empty, rx.try_recv().unwrap_err());\n+    assert_eq!(RecvTimeoutError::Timeout, rx.recv_timeout(one_us).unwrap_err());\n+\n+    drop(tx);\n+\n+    assert_eq!(RecvError, rx.recv().unwrap_err());\n+    assert_eq!(RecvTimeoutError::Disconnected, rx.recv_timeout(one_us).unwrap_err());\n+    assert_eq!(TryRecvError::Disconnected, rx.try_recv().unwrap_err());\n+}\n+\n+#[test]\n+fn concurrent_writes() {\n+    for _ in 0..100 {\n+        concurrent_writes_iter();\n+    }\n+}"}, {"sha": "b2fea9b5e53f87e6217a43ed231b16d83f193dd5", "filename": "src/test/run-pass/non_modrs_mods/foors_mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Ffoors_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Ffoors_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Ffoors_mod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -12,3 +12,7 @@\n \n pub mod inner_modrs_mod;\n pub mod inner_foors_mod;\n+pub mod inline {\n+    #[path=\"somename.rs\"]\n+    pub mod innie;\n+}"}, {"sha": "b76b4321d62aa8e066b24d213c79ccc8230b8d7b", "filename": "src/test/run-pass/non_modrs_mods/foors_mod/inline/somename.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Ffoors_mod%2Finline%2Fsomename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Ffoors_mod%2Finline%2Fsomename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Ffoors_mod%2Finline%2Fsomename.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1 @@\n+pub fn foo() {}"}, {"sha": "b76b4321d62aa8e066b24d213c79ccc8230b8d7b", "filename": "src/test/run-pass/non_modrs_mods/modrs_mod/inline/somename.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fmodrs_mod%2Finline%2Fsomename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fmodrs_mod%2Finline%2Fsomename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fmodrs_mod%2Finline%2Fsomename.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1 @@\n+pub fn foo() {}"}, {"sha": "99684c86d2eaf60ed0166a6f39422738d2fb3f3b", "filename": "src/test/run-pass/non_modrs_mods/modrs_mod/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fmodrs_mod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fmodrs_mod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fmodrs_mod%2Fmod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -10,3 +10,7 @@\n \n pub mod inner_modrs_mod;\n pub mod inner_foors_mod;\n+pub mod inline {\n+    #[path=\"somename.rs\"]\n+    pub mod innie;\n+}"}, {"sha": "f664b0166d80dfab41da99eea65938927db013ba", "filename": "src/test/run-pass/non_modrs_mods/non_modrs_mods.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fnon_modrs_mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fnon_modrs_mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon_modrs_mods%2Fnon_modrs_mods.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+//\n+// ignore-pretty issue #37195\n+pub mod modrs_mod;\n+pub mod foors_mod;\n+#[path = \"some_crazy_attr_mod_dir/arbitrary_name.rs\"]\n+pub mod attr_mod;\n+pub fn main() {\n+    modrs_mod::inner_modrs_mod::innest::foo();\n+    modrs_mod::inner_foors_mod::innest::foo();\n+    modrs_mod::inline::innie::foo();\n+    foors_mod::inner_modrs_mod::innest::foo();\n+    foors_mod::inner_foors_mod::innest::foo();\n+    foors_mod::inline::innie::foo();\n+    attr_mod::inner_modrs_mod::innest::foo();\n+}"}, {"sha": "12e59a4813f8539d01bfa71ca62c59c09c4e91a1", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-end-whitespace\n+\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+// An error in calculating spans while reporting intra-doc link resolution errors caused rustdoc to\n+// attempt to slice in the middle of a multibyte character. See\n+// https://github.com/rust-lang/rust/issues/55723\n+\n+/// ## For example:\n+///  \n+/// \uff08arr[i]\uff09\n+pub fn test_ice() {\n+    unimplemented!();\n+}"}, {"sha": "7ae6af4a75e8c6699fa387125f909e039a2d3488", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,13 @@\n+error: `[i]` cannot be resolved, ignoring it...\n+  --> $DIR/intra-link-span-ice-55723.rs:21:10\n+   |\n+LL | /// \uff08arr[i]\uff09\n+   |           ^ cannot be resolved, ignoring\n+   |\n+note: lint level defined here\n+  --> $DIR/intra-link-span-ice-55723.rs:13:9\n+   |\n+LL | #![deny(intra_doc_link_resolution_failure)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n+"}, {"sha": "194cfab8527c014a2a08d212364d6449f92d670e", "filename": "src/test/ui/block-result/issue-20862.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fblock-result%2Fissue-20862.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fblock-result%2Fissue-20862.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-20862.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -12,8 +12,16 @@ LL |     |y| x + y\n error[E0618]: expected function, found `()`\n   --> $DIR/issue-20862.rs:17:13\n    |\n-LL |     let x = foo(5)(2);\n-   |             ^^^^^^^^^ not a function\n+LL | / fn foo(x: i32) {\n+LL | |     |y| x + y\n+LL | | //~^ ERROR: mismatched types\n+LL | | }\n+   | |_- `foo` defined here returns `()`\n+...\n+LL |       let x = foo(5)(2);\n+   |               ^^^^^^---\n+   |               |\n+   |               call expression requires function\n \n error: aborting due to 2 previous errors\n "}, {"sha": "bd407192cd7a1079e98050f9bb8b997b8dcf647b", "filename": "src/test/ui/consts/const-call.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -15,4 +15,5 @@ fn f(x: usize) -> usize {\n fn main() {\n     let _ = [0; f(2)];\n     //~^ ERROR calls in constants are limited to constant functions\n+    //~| ERROR evaluation of constant value failed\n }"}, {"sha": "219fcec51b386f47196541a4d9d62dd2842351a4", "filename": "src/test/ui/consts/const-call.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -4,6 +4,13 @@ error[E0015]: calls in constants are limited to constant functions, tuple struct\n LL |     let _ = [0; f(2)];\n    |                 ^^^^\n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-call.rs:16:17\n+   |\n+LL |     let _ = [0; f(2)];\n+   |                 ^^^^ calling non-const function `f`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors occurred: E0015, E0080.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "0126743eedecba9ced796711dfebdbad95645730", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:24:5\n    |\n LL |     const I32_REF_USIZE_UNION: usize = unsafe { Nonsense { int_32_ref: &3 }.u };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -36,7 +36,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:36:5\n    |\n LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uint_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -74,7 +74,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:51:5\n    |\n LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -96,7 +96,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:60:5\n    |\n LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.float_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -144,7 +144,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:78:5\n    |\n LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -184,7 +184,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:93:5\n    |\n LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n@@ -208,7 +208,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:102:5\n    |\n LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "608094b179dd69331a3c7532e2f2b5c97eef37ba", "filename": "src/test/ui/consts/const-eval/issue-52442.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -8,7 +8,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/issue-52442.rs:12:11\n    |\n LL |     [();  { &loop { break } as *const _ as usize } ]; //~ ERROR unimplemented expression type\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "c4bad73eb027626792fd54488ce2f39895f0e696", "filename": "src/test/ui/consts/const-eval/ref_to_int_match.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fref_to_int_match.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ref_to_int_match.rs:33:1\n    |\n LL | const BAR: Int = unsafe { Foo { r: &42 }.f }; //~ ERROR it is undefined behavior to use this value\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "89b449464419e9a3f04295b012f3caf22c6372db", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -39,6 +39,7 @@ union TransmuteEnum2 {\n     in3: (),\n     out1: Enum2,\n     out2: Wrap<Enum2>, // something wrapping the enum so that we test layout first, not enum\n+    out3: Option<Enum2>,\n }\n const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n //~^ ERROR is undefined behavior\n@@ -51,6 +52,10 @@ const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n const BAD_ENUM_UNDEF: [Enum2; 2] = [unsafe { TransmuteEnum2 { in3: () }.out1 }; 2];\n //~^ ERROR is undefined behavior\n \n+// Pointer value in an enum with a niche that is not just 0.\n+const BAD_ENUM_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+//~^ ERROR is undefined behavior\n+\n // Invalid enum field content (mostly to test printing of paths for enum tuple\n // variants and tuples).\n union TransmuteChar {"}, {"sha": "5aae3a2f35110528693dc8df9eef56917b3c1865", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -7,45 +7,53 @@ LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.out };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:43:1\n+  --> $DIR/ub-enum.rs:44:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM3: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:47:1\n+  --> $DIR/ub-enum.rs:48:1\n    |\n LL | const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be in the range 2..=2\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:51:1\n+  --> $DIR/ub-enum.rs:52:1\n    |\n LL | const BAD_ENUM_UNDEF: [Enum2; 2] = [unsafe { TransmuteEnum2 { in3: () }.out1 }; 2];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempted to read undefined bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at [0], but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:61:1\n+  --> $DIR/ub-enum.rs:56:1\n+   |\n+LL | const BAD_ENUM_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:66:1\n    |\n LL | const BAD_ENUM_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "fe969d40a2ea6c8389b821fa92d510b31e006640", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -18,15 +18,15 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref.rs:22:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref.rs:25:1\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<deref>, but expected plain bytes\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<deref>, but expected plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "98c2c1472aae016c6005ee0760b8167e1ad82e0b", "filename": "src/test/ui/consts/const-eval/union-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -13,7 +13,7 @@ LL | / const FIELD_PATH: Struct = Struct { //~ ERROR it is undefined behavior to\n LL | |     a: 42,\n LL | |     b: unsafe { UNION.field3 },\n LL | | };\n-   | |__^ type validation failed: encountered uninitialized bytes at .b, but expected initialized plain bits\n+   | |__^ type validation failed: encountered uninitialized bytes at .b, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "360e0c6f107b2cc991c91925e8eae502660fe9d0", "filename": "src/test/ui/empty/empty-struct-unit-expr.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fempty%2Fempty-struct-unit-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fempty%2Fempty-struct-unit-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-struct-unit-expr.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -5,7 +5,9 @@ LL | struct Empty2;\n    | -------------- `Empty2` defined here\n ...\n LL |     let e2 = Empty2(); //~ ERROR expected function, found `Empty2`\n-   |              ^^^^^^^^ not a function\n+   |              ^^^^^^--\n+   |              |\n+   |              call expression requires function\n \n error[E0618]: expected function, found enum variant `E::Empty4`\n   --> $DIR/empty-struct-unit-expr.rs:26:14\n@@ -14,7 +16,9 @@ LL |     Empty4\n    |     ------ `E::Empty4` defined here\n ...\n LL |     let e4 = E::Empty4();\n-   |              ^^^^^^^^^^^ not a function\n+   |              ^^^^^^^^^--\n+   |              |\n+   |              call expression requires function\n help: `E::Empty4` is a unit variant, you need to write it without the parenthesis\n    |\n LL |     let e4 = E::Empty4;\n@@ -24,13 +28,17 @@ error[E0618]: expected function, found `empty_struct::XEmpty2`\n   --> $DIR/empty-struct-unit-expr.rs:28:15\n    |\n LL |     let xe2 = XEmpty2(); //~ ERROR expected function, found `empty_struct::XEmpty2`\n-   |               ^^^^^^^^^ not a function\n+   |               ^^^^^^^--\n+   |               |\n+   |               call expression requires function\n \n error[E0618]: expected function, found enum variant `XE::XEmpty4`\n   --> $DIR/empty-struct-unit-expr.rs:29:15\n    |\n LL |     let xe4 = XE::XEmpty4();\n-   |               ^^^^^^^^^^^^^ not a function\n+   |               ^^^^^^^^^^^--\n+   |               |\n+   |               call expression requires function\n help: `XE::XEmpty4` is a unit variant, you need to write it without the parenthesis\n    |\n LL |     let xe4 = XE::XEmpty4;"}, {"sha": "3bcc83e01c1f0f217c503630eca2cf59d6267f82", "filename": "src/test/ui/error-codes/E0618.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Ferror-codes%2FE0618.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Ferror-codes%2FE0618.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0618.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -5,7 +5,9 @@ LL |     Entry,\n    |     ----- `X::Entry` defined here\n ...\n LL |     X::Entry();\n-   |     ^^^^^^^^^^ not a function\n+   |     ^^^^^^^^--\n+   |     |\n+   |     call expression requires function\n help: `X::Entry` is a unit variant, you need to write it without the parenthesis\n    |\n LL |     X::Entry;\n@@ -17,7 +19,9 @@ error[E0618]: expected function, found `i32`\n LL |     let x = 0i32;\n    |         - `i32` defined here\n LL |     x();\n-   |     ^^^ not a function\n+   |     ^--\n+   |     |\n+   |     call expression requires function\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4246ec2dad332f34c8dd49c50ca41d8939dbacee", "filename": "src/test/ui/infinite/infinite-recursion-const-fn.stderr", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-recursion-const-fn.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -5,61 +5,61 @@ LL | const fn a() -> usize { b() } //~ ERROR evaluation of constant value failed\n    |                         ^^^\n    |                         |\n    |                         reached the configured maximum number of stack frames\n-   |                         inside call to `b`\n+   |                         inside call to `b` at $DIR/infinite-recursion-const-fn.rs:13:25\n LL | const fn b() -> usize { a() }\n    |                         ---\n    |                         |\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n-   |                         inside call to `a`\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n+   |                         inside call to `a` at $DIR/infinite-recursion-const-fn.rs:14:25\n LL | const ARR: [i32; a()] = [5; 6];\n-   |                  --- inside call to `a`\n+   |                  --- inside call to `a` at $DIR/infinite-recursion-const-fn.rs:15:18\n \n error: aborting due to previous error\n "}, {"sha": "229b005ec7d5614d69a50791ac26ac8bc8258ca2", "filename": "src/test/ui/invalid-module-declaration/invalid-module-declaration.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// ignore-windows\n \n mod auxiliary {\n     mod foo;"}, {"sha": "d04108ca39e24f782e0bfcef1920cd7830aff208", "filename": "src/test/ui/issues/issue-10969.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-10969.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-10969.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10969.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -4,15 +4,19 @@ error[E0618]: expected function, found `i32`\n LL | fn func(i: i32) {\n    |         - `i32` defined here\n LL |     i(); //~ERROR expected function, found `i32`\n-   |     ^^^ not a function\n+   |     ^--\n+   |     |\n+   |     call expression requires function\n \n error[E0618]: expected function, found `i32`\n   --> $DIR/issue-10969.rs:16:5\n    |\n LL |     let i = 0i32;\n    |         - `i32` defined here\n LL |     i(); //~ERROR expected function, found `i32`\n-   |     ^^^ not a function\n+   |     ^--\n+   |     |\n+   |     call expression requires function\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c297c20069ec235b09201f5d21f1c828a36f1819", "filename": "src/test/ui/issues/issue-18532.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-18532.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-18532.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18532.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -2,7 +2,9 @@ error[E0618]: expected function, found `!`\n   --> $DIR/issue-18532.rs:16:5\n    |\n LL |     (return)((),()); //~ ERROR expected function, found `!`\n-   |     ^^^^^^^^^^^^^^^ not a function\n+   |     ^^^^^^^^-------\n+   |     |\n+   |     call expression requires function\n \n error: aborting due to previous error\n "}, {"sha": "70a9736d2a2433131fcef7537c9ad6c2ed09ea8f", "filename": "src/test/ui/issues/issue-20714.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-20714.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-20714.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20714.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -5,7 +5,9 @@ LL | struct G;\n    | --------- `G` defined here\n ...\n LL |     let g = G(); //~ ERROR: expected function, found `G`\n-   |             ^^^ not a function\n+   |             ^--\n+   |             |\n+   |             call expression requires function\n \n error: aborting due to previous error\n "}, {"sha": "b94e0833a581072450ba76a828ac180c154ec8bc", "filename": "src/test/ui/issues/issue-21701.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-21701.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-21701.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21701.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -4,7 +4,9 @@ error[E0618]: expected function, found `U`\n LL | fn foo<U>(t: U) {\n    |           - `U` defined here\n LL |     let y = t();\n-   |             ^^^ not a function\n+   |             ^--\n+   |             |\n+   |             call expression requires function\n \n error[E0618]: expected function, found `Bar`\n   --> $DIR/issue-21701.rs:19:13\n@@ -13,7 +15,9 @@ LL | struct Bar;\n    | ----------- `Bar` defined here\n ...\n LL |     let f = Bar();\n-   |             ^^^^^ not a function\n+   |             ^^^--\n+   |             |\n+   |             call expression requires function\n \n error: aborting due to 2 previous errors\n "}, {"sha": "af32c0e20ce9d5499c15724891c208ad9e652ab8", "filename": "src/test/ui/issues/issue-22468.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-22468.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-22468.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22468.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -4,7 +4,9 @@ error[E0618]: expected function, found `&str`\n LL |     let foo = \"bar\";\n    |         --- `&str` defined here\n LL |     let x = foo(\"baz\");\n-   |             ^^^^^^^^^^ not a function\n+   |             ^^^-------\n+   |             |\n+   |             call expression requires function\n \n error: aborting due to previous error\n "}, {"sha": "ffffe6d3ab5db93dfeaacdcf9faaa9bde1b153b4", "filename": "src/test/ui/issues/issue-26237.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-26237.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-26237.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26237.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -11,13 +11,12 @@\n macro_rules! macro_panic {\n     ($not_a_function:expr, $some_argument:ident) => {\n         $not_a_function($some_argument)\n-        //~^ ERROR expected function, found `{integer}`\n     }\n }\n \n fn main() {\n     let mut value_a = 0;\n     let mut value_b = 0;\n     macro_panic!(value_a, value_b);\n-    //~^ in this expansion of macro_panic!\n+    //~^ ERROR expected function, found `{integer}`\n }"}, {"sha": "7f481c230ba65329f090b739ef517d7fbb7c7d12", "filename": "src/test/ui/issues/issue-26237.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-26237.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-26237.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26237.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -1,14 +1,14 @@\n error[E0618]: expected function, found `{integer}`\n-  --> $DIR/issue-26237.rs:13:9\n+  --> $DIR/issue-26237.rs:20:18\n    |\n LL |         $not_a_function($some_argument)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not a function\n+   |         ------------------------------- call expression requires function\n ...\n LL |     let mut value_a = 0;\n    |         ----------- `{integer}` defined here\n LL |     let mut value_b = 0;\n LL |     macro_panic!(value_a, value_b);\n-   |     ------------------------------- in this macro invocation\n+   |                  ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f01fd1fd8f1442571c9a7cfa6f9005f647b335a2", "filename": "src/test/ui/issues/issue-39559-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -23,6 +23,8 @@ impl Dim for Dim3 {\n fn main() {\n     let array: [usize; Dim3::dim()]\n     //~^ ERROR E0015\n+    //~| ERROR E0080\n         = [0; Dim3::dim()];\n         //~^ ERROR E0015\n+        //~| ERROR E0080\n }"}, {"sha": "57e9f23e0b33c311ba0492a00c0a130d74137661", "filename": "src/test/ui/issues/issue-39559-2.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -4,12 +4,25 @@ error[E0015]: calls in constants are limited to constant functions, tuple struct\n LL |     let array: [usize; Dim3::dim()]\n    |                        ^^^^^^^^^^^\n \n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-39559-2.rs:24:24\n+   |\n+LL |     let array: [usize; Dim3::dim()]\n+   |                        ^^^^^^^^^^^ calling non-const function `<Dim3 as Dim>::dim`\n+\n error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/issue-39559-2.rs:26:15\n+  --> $DIR/issue-39559-2.rs:27:15\n    |\n LL |         = [0; Dim3::dim()];\n    |               ^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-39559-2.rs:27:15\n+   |\n+LL |         = [0; Dim3::dim()];\n+   |               ^^^^^^^^^^^ calling non-const function `<Dim3 as Dim>::dim`\n+\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors occurred: E0015, E0080.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "60b18a66f1a384c02b5664356a7182d70849836a", "filename": "src/test/ui/issues/issue-43105.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-43105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-43105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43105.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -12,10 +12,12 @@ fn xyz() -> u8 { 42 }\n \n const NUM: u8 = xyz();\n //~^ ERROR calls in constants are limited to constant functions, tuple structs and tuple variants\n+//~| ERROR any use of this value will cause an error [const_err]\n \n fn main() {\n     match 1 {\n         NUM => unimplemented!(),\n+        //~^ ERROR could not evaluate constant pattern\n         _ => unimplemented!(),\n     }\n }"}, {"sha": "f26447ed2b9f0a860a9f7d29cbbb2f50c68a54ac", "filename": "src/test/ui/issues/issue-43105.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-43105.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-43105.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43105.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -4,6 +4,22 @@ error[E0015]: calls in constants are limited to constant functions, tuple struct\n LL | const NUM: u8 = xyz();\n    |                 ^^^^^\n \n-error: aborting due to previous error\n+error: any use of this value will cause an error\n+  --> $DIR/issue-43105.rs:13:1\n+   |\n+LL | const NUM: u8 = xyz();\n+   | ^^^^^^^^^^^^^^^^-----^\n+   |                 |\n+   |                 calling non-const function `xyz`\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: could not evaluate constant pattern\n+  --> $DIR/issue-43105.rs:19:9\n+   |\n+LL |         NUM => unimplemented!(),\n+   |         ^^^\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0015`."}, {"sha": "b7b5f76395a9dc4b3a4e94bd1ef28628b1da2025", "filename": "src/test/ui/issues/issue-45965.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-45965.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-45965.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45965.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -2,7 +2,9 @@ error[E0618]: expected function, found `{float}`\n   --> $DIR/issue-45965.rs:12:30\n    |\n LL |     let a = |r: f64| if r != 0.0(r != 0.0) { 1.0 } else { 0.0 };\n-   |                              ^^^^^^^^^^^^^ not a function\n+   |                              ^^^----------\n+   |                              |\n+   |                              call expression requires function\n \n error: aborting due to previous error\n "}, {"sha": "90adb3ed73f5696beb8332306e8b25fc49a68834", "filename": "src/test/ui/issues/issue-46771.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-46771.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-46771.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46771.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -4,7 +4,9 @@ error[E0618]: expected function, found `main::Foo`\n LL |     struct Foo;\n    |     ----------- `main::Foo` defined here\n LL |     (1 .. 2).find(|_| Foo(0) == 0); //~ ERROR expected function, found `main::Foo`\n-   |                       ^^^^^^ not a function\n+   |                       ^^^---\n+   |                       |\n+   |                       call expression requires function\n \n error: aborting due to previous error\n "}, {"sha": "305ee2f547145131cc913df95709f07beefaff16", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -47,9 +47,9 @@ error[E0618]: expected function, found `(char, char)`\n   --> $DIR/issue-5100.rs:58:14\n    |\n LL |       let v = [('a', 'b')   //~ ERROR expected function, found `(char, char)`\n-   |  ______________^\n+   |  ______________-^^^^^^^^^\n LL | |              ('c', 'd'),\n-   | |_______________________^ not a function\n+   | |_______________________- call expression requires function\n \n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:65:19"}, {"sha": "a4c228416147e6d2a634e513d8e79b2212f04d03", "filename": "src/test/ui/issues/issue-52023-array-size-pointer-cast.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -10,7 +10,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/issue-52023-array-size-pointer-cast.rs:12:17\n    |\n LL |     let _ = [0; (&0 as *const i32) as usize]; //~ ERROR casting pointers to integers in constants\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain bits\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "df60629eca161bc697430e9e3837e4ded9667c4f", "filename": "src/test/ui/missing_non_modrs_mod/foo_inline.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Ffoo_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Ffoo_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Ffoo_inline.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,5 @@\n+// ignore-test this is just a helper for the real test in this dir\n+\n+mod inline {\n+    mod missing;\n+}"}, {"sha": "84fa1f032d78e6d65e216f6ec3eea6a2565d9c9e", "filename": "src/test/ui/missing_non_modrs_mod/missing_non_modrs_mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -8,7 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-windows\n-\n mod foo;\n fn main() {}"}, {"sha": "9ebb4f1bdbdb3ce8a69f770e31d9601f6b327de3", "filename": "src/test/ui/missing_non_modrs_mod/missing_non_modrs_mod_inline.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,2 @@\n+mod foo_inline;\n+fn main() {}"}, {"sha": "457e8fcccbfb3252c903a43c5e3393001992f6a6", "filename": "src/test/ui/missing_non_modrs_mod/missing_non_modrs_mod_inline.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,11 @@\n+error[E0583]: file not found for module `missing`\n+  --> $DIR/foo_inline.rs:4:9\n+   |\n+LL |     mod missing;\n+   |         ^^^^^^^\n+   |\n+   = help: name the file either missing.rs or missing/mod.rs inside the directory \"$DIR/foo_inline/inline\"\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0583`."}, {"sha": "cda3915849e2d686853992c4fdde2d91f674b50f", "filename": "src/test/ui/nll/ty-outlives/issue-55756.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-55756.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-55756.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-55756.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,37 @@\n+// Regression test for #55756.\n+//\n+// In this test, the result of `self.callee` is a projection `<D as\n+// Database<'?0>>::Guard`. As it may contain a destructor, the dropck\n+// rules require that this type outlivess the scope of `state`. Unfortunately,\n+// our region inference is not smart enough to figure out how to\n+// translate a requirement like\n+//\n+//     <D as Database<'0>>::guard: 'r\n+//\n+// into a requirement that `'0: 'r` -- in particular, it fails to do\n+// so because it *also* knows that `<D as Database<'a>>::Guard: 'a`\n+// from the trait definition. Faced with so many choices, the current\n+// solver opts to do nothing.\n+//\n+// Fixed by tweaking the solver to recognize that the constraint from\n+// the environment duplicates one from the trait.\n+//\n+// compile-pass\n+\n+#![crate_type=\"lib\"]\n+\n+pub trait Database<'a> {\n+    type Guard: 'a;\n+}\n+\n+pub struct Stateful<'a, D: 'a>(&'a D);\n+\n+impl<'b, D: for <'a> Database<'a>> Stateful<'b, D> {\n+    pub fn callee<'a>(&'a self) -> <D as Database<'a>>::Guard {\n+        unimplemented!()\n+    }\n+    pub fn caller<'a>(&'a self) -> <D as Database<'a>>::Guard {\n+        let state = self.callee();\n+        unimplemented!()\n+    }\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/non_modrs_mods/foors_mod/compiletest-ignore-dir", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Fcompiletest-ignore-dir", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Fcompiletest-ignore-dir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Fcompiletest-ignore-dir?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411"}, {"sha": "77cab972352bd77d0554c07da2fea4dda04fe76a", "filename": "src/test/ui/non_modrs_mods/foors_mod/inner_foors_mod.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_foors_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_foors_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_foors_mod.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub mod innest;"}, {"sha": "b61667cfd882ce02e3a44b5141adea3352a211f1", "filename": "src/test/ui/non_modrs_mods/foors_mod/inner_foors_mod/innest.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_foors_mod%2Finnest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_foors_mod%2Finnest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_foors_mod%2Finnest.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn foo() {}"}, {"sha": "b61667cfd882ce02e3a44b5141adea3352a211f1", "filename": "src/test/ui/non_modrs_mods/foors_mod/inner_modrs_mod/innest.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_modrs_mod%2Finnest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_modrs_mod%2Finnest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_modrs_mod%2Finnest.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn foo() {}"}, {"sha": "77cab972352bd77d0554c07da2fea4dda04fe76a", "filename": "src/test/ui/non_modrs_mods/foors_mod/inner_modrs_mod/mod.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_modrs_mod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_modrs_mod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Ffoors_mod%2Finner_modrs_mod%2Fmod.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub mod innest;"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/non_modrs_mods/modrs_mod/compiletest-ignore-dir", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Fcompiletest-ignore-dir", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Fcompiletest-ignore-dir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Fcompiletest-ignore-dir?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411"}, {"sha": "77cab972352bd77d0554c07da2fea4dda04fe76a", "filename": "src/test/ui/non_modrs_mods/modrs_mod/inner_foors_mod.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_foors_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_foors_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_foors_mod.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub mod innest;"}, {"sha": "b61667cfd882ce02e3a44b5141adea3352a211f1", "filename": "src/test/ui/non_modrs_mods/modrs_mod/inner_foors_mod/innest.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_foors_mod%2Finnest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_foors_mod%2Finnest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_foors_mod%2Finnest.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn foo() {}"}, {"sha": "b61667cfd882ce02e3a44b5141adea3352a211f1", "filename": "src/test/ui/non_modrs_mods/modrs_mod/inner_modrs_mod/innest.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_modrs_mod%2Finnest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_modrs_mod%2Finnest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_modrs_mod%2Finnest.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn foo() {}"}, {"sha": "77cab972352bd77d0554c07da2fea4dda04fe76a", "filename": "src/test/ui/non_modrs_mods/modrs_mod/inner_modrs_mod/mod.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_modrs_mod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_modrs_mod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Finner_modrs_mod%2Fmod.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub mod innest;"}, {"sha": "9e3f10f12ed63916e14646e5909b90b8b0ad217e", "filename": "src/test/ui/non_modrs_mods/modrs_mod/mod.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fmodrs_mod%2Fmod.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub mod inner_modrs_mod;\n-pub mod inner_foors_mod;"}, {"sha": "226e6fda0a41fdd9c28e63cd0866528357046423", "filename": "src/test/ui/non_modrs_mods/some_crazy_attr_mod_dir/arbitrary_name.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Farbitrary_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Farbitrary_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Farbitrary_name.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub mod inner_modrs_mod;"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/non_modrs_mods/some_crazy_attr_mod_dir/compiletest-ignore-dir", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Fcompiletest-ignore-dir", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Fcompiletest-ignore-dir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Fcompiletest-ignore-dir?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411"}, {"sha": "b61667cfd882ce02e3a44b5141adea3352a211f1", "filename": "src/test/ui/non_modrs_mods/some_crazy_attr_mod_dir/inner_modrs_mod/innest.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Finner_modrs_mod%2Finnest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Finner_modrs_mod%2Finnest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Finner_modrs_mod%2Finnest.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn foo() {}"}, {"sha": "77cab972352bd77d0554c07da2fea4dda04fe76a", "filename": "src/test/ui/non_modrs_mods/some_crazy_attr_mod_dir/inner_modrs_mod/mod.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Finner_modrs_mod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e82eda000c8d4abbdaa76b3563cd77f938fc411/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Finner_modrs_mod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon_modrs_mods%2Fsome_crazy_attr_mod_dir%2Finner_modrs_mod%2Fmod.rs?ref=7e82eda000c8d4abbdaa76b3563cd77f938fc411", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub mod innest;"}, {"sha": "9c87806da9e5dd29c13411dd8dde22c2795236f0", "filename": "src/test/ui/parse-error-correct.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fparse-error-correct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fparse-error-correct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparse-error-correct.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -17,7 +17,9 @@ LL |     let y = 42;\n    |         - `{integer}` defined here\n LL |     let x = y.;  //~ ERROR unexpected token\n LL |     let x = y.();  //~ ERROR unexpected token\n-   |             ^^^^ not a function\n+   |             ^---\n+   |             |\n+   |             call expression requires function\n \n error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n   --> $DIR/parse-error-correct.rs:21:15"}, {"sha": "01e6488de5303ae387ae768a04f3bfb3edebcce7", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -171,7 +171,9 @@ LL |             Unit,\n    |             ---- `Z::Unit` defined here\n ...\n LL |         let _ = Z::Unit();\n-   |                 ^^^^^^^^^ not a function\n+   |                 ^^^^^^^--\n+   |                 |\n+   |                 call expression requires function\n help: `Z::Unit` is a unit variant, you need to write it without the parenthesis\n    |\n LL |         let _ = Z::Unit;\n@@ -193,7 +195,9 @@ LL |         Unit,\n    |         ---- `m::E::Unit` defined here\n ...\n LL |     let _: E = m::E::Unit();\n-   |                ^^^^^^^^^^^^ not a function\n+   |                ^^^^^^^^^^--\n+   |                |\n+   |                call expression requires function\n help: `m::E::Unit` is a unit variant, you need to write it without the parenthesis\n    |\n LL |     let _: E = m::E::Unit;\n@@ -215,7 +219,9 @@ LL |         Unit,\n    |         ---- `E::Unit` defined here\n ...\n LL |     let _: E = E::Unit();\n-   |                ^^^^^^^^^ not a function\n+   |                ^^^^^^^--\n+   |                |\n+   |                call expression requires function\n help: `E::Unit` is a unit variant, you need to write it without the parenthesis\n    |\n LL |     let _: E = E::Unit;"}, {"sha": "37f078285d695330d1c92697a2e42f049ad9be35", "filename": "src/test/ui/suggestions/issue-51055-missing-semicolon-between-call-and-tuple.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fsuggestions%2Fissue-51055-missing-semicolon-between-call-and-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fsuggestions%2Fissue-51055-missing-semicolon-between-call-and-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-51055-missing-semicolon-between-call-and-tuple.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,8 @@\n+fn vindictive() -> bool { true }\n+\n+fn perfidy() -> (i32, i32) {\n+    vindictive() //~ ERROR expected function, found `bool`\n+    (1, 2)\n+}\n+\n+fn main() {}"}, {"sha": "40ddb5ec53c290ceb068e6a98524b8f56c390682", "filename": "src/test/ui/suggestions/issue-51055-missing-semicolon-between-call-and-tuple.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fsuggestions%2Fissue-51055-missing-semicolon-between-call-and-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Fsuggestions%2Fissue-51055-missing-semicolon-between-call-and-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-51055-missing-semicolon-between-call-and-tuple.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,16 @@\n+error[E0618]: expected function, found `bool`\n+  --> $DIR/issue-51055-missing-semicolon-between-call-and-tuple.rs:4:5\n+   |\n+LL |   fn vindictive() -> bool { true }\n+   |   -------------------------------- `vindictive` defined here returns `bool`\n+...\n+LL |       vindictive() //~ ERROR expected function, found `bool`\n+   |       -^^^^^^^^^^^- help: try adding a semicolon: `;`\n+   |  _____|\n+   | |\n+LL | |     (1, 2)\n+   | |__________- call expression requires function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0618`."}, {"sha": "348bc6b4e982dfa48905394676359e772bf7cd84", "filename": "src/test/ui/test-attr-non-associated-functions.rs", "status": "renamed", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Ftest-attr-non-associated-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Ftest-attr-non-associated-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attr-non-associated-functions.rs?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,8 +7,23 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-//\n-// ignore-test: not a test, used by non_modrs_mods.rs\n \n-pub mod inner_modrs_mod;\n-pub mod inner_foors_mod;\n+// #[test] attribute is not allowed on associated functions or methods\n+// reworded error message\n+// compile-flags:--test\n+\n+struct A {}\n+\n+impl A {\n+    #[test]\n+    fn new() -> A { //~ ERROR #[test] attribute is only allowed on non associated functions\n+        A {}\n+    }\n+}\n+\n+#[test]\n+fn test() {\n+    let _ = A::new();\n+}\n+\n+fn main() {}", "previous_filename": "src/test/ui/non_modrs_mods/foors_mod.rs"}, {"sha": "491fcc01431191b1710e1393783f8d2433d83142", "filename": "src/test/ui/test-attr-non-associated-functions.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Ftest-attr-non-associated-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e8a982a234532ad9cce7f072d130029df96bebc/src%2Ftest%2Fui%2Ftest-attr-non-associated-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attr-non-associated-functions.stderr?ref=9e8a982a234532ad9cce7f072d130029df96bebc", "patch": "@@ -0,0 +1,10 @@\n+error: #[test] attribute is only allowed on non associated functions\n+  --> $DIR/test-attr-non-associated-functions.rs:19:5\n+   |\n+LL | /     fn new() -> A { //~ ERROR #[test] attribute is only allowed on non associated functions\n+LL | |         A {}\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to previous error\n+"}]}