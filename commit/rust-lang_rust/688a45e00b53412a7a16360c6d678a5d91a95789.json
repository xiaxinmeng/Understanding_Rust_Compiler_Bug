{"sha": "688a45e00b53412a7a16360c6d678a5d91a95789", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OGE0NWUwMGI1MzQxMmE3YTE2MzYwYzZkNjc4YTVkOTFhOTU3ODk=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-12T20:27:35Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-19T15:02:06Z"}, "message": "Implement beginnings of generics\n\n - add HIR for generic params\n - resolve generic params in type paths\n - add substitions for ADTs\n - insert type variables for substitutions", "tree": {"sha": "d3f3481bbad9889d22867729e9efcde184e45671", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3f3481bbad9889d22867729e9efcde184e45671"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/688a45e00b53412a7a16360c6d678a5d91a95789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/688a45e00b53412a7a16360c6d678a5d91a95789", "html_url": "https://github.com/rust-lang/rust/commit/688a45e00b53412a7a16360c6d678a5d91a95789", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/688a45e00b53412a7a16360c6d678a5d91a95789/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "415cdc52108807126f0339fbf812856582f01c18", "url": "https://api.github.com/repos/rust-lang/rust/commits/415cdc52108807126f0339fbf812856582f01c18", "html_url": "https://github.com/rust-lang/rust/commit/415cdc52108807126f0339fbf812856582f01c18"}], "stats": {"total": 370, "additions": 288, "deletions": 82}, "files": [{"sha": "ab1c428db7ebee53945e08c60508f3343cdaa8d1", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -1,3 +1,6 @@\n+//! This module contains the implementation details of the HIR for ADTs, i.e.\n+//! structs and enums (and unions).\n+\n use std::sync::Arc;\n \n use ra_syntax::{\n@@ -62,7 +65,7 @@ fn get_def_id(\n     };\n     let loc = DefLoc {\n         kind: expected_kind,\n-        source_item_id: source_item_id,\n+        source_item_id,\n         ..*same_file_loc\n     };\n     loc.id(db)"}, {"sha": "6c85e5939f41e38c5846e83159518d0a9c18c4bd", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -12,6 +12,7 @@ use crate::{\n     expr::BodySyntaxMapping,\n     ty::InferenceResult,\n     adt::VariantData,\n+    generics::Generics,\n     code_model_impl::def_id_to_ast,\n };\n \n@@ -201,6 +202,10 @@ impl Struct {\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n         def_id_to_ast(db, self.def_id)\n     }\n+\n+    pub fn generics(&self, db: &impl HirDatabase) -> Arc<Generics> {\n+        db.generics(self.def_id)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -228,6 +233,10 @@ impl Enum {\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::EnumDef>) {\n         def_id_to_ast(db, self.def_id)\n     }\n+\n+    pub fn generics(&self, db: &impl HirDatabase) -> Arc<Generics> {\n+        db.generics(self.def_id)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -339,6 +348,10 @@ impl Function {\n     pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.def_id)\n     }\n+\n+    pub fn generics(&self, db: &impl HirDatabase) -> Arc<Generics> {\n+        db.generics(self.def_id)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -384,6 +397,10 @@ impl Trait {\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::TraitDef>) {\n         def_id_to_ast(db, self.def_id)\n     }\n+\n+    pub fn generics(&self, db: &impl HirDatabase) -> Arc<Generics> {\n+        db.generics(self.def_id)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -399,4 +416,8 @@ impl Type {\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::TypeDef>) {\n         def_id_to_ast(db, self.def_id)\n     }\n+\n+    pub fn generics(&self, db: &impl HirDatabase) -> Arc<Generics> {\n+        db.generics(self.def_id)\n+    }\n }"}, {"sha": "10e64f8806af3b8a2a31007d47ec510c7a88e303", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n+    generics::Generics,\n };\n \n #[salsa::query_group]\n@@ -101,6 +102,9 @@ pub trait HirDatabase:\n     #[salsa::invoke(crate::expr::body_syntax_mapping)]\n     fn body_syntax_mapping(&self, def_id: DefId) -> Arc<crate::expr::BodySyntaxMapping>;\n \n+    #[salsa::invoke(crate::generics::Generics::generics_query)]\n+    fn generics(&self, def_id: DefId) -> Arc<Generics>;\n+\n     #[salsa::invoke(crate::FnSignature::fn_signature_query)]\n     fn fn_signature(&self, def_id: DefId) -> Arc<FnSignature>;\n }"}, {"sha": "cdabc042435ea988a385bfa77054abfce600c07b", "filename": "crates/ra_hir/src/generics.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -0,0 +1,48 @@\n+//! Many kinds of items or constructs can have generic parameters: functions,\n+//! structs, impls, traits, etc. This module provides a common HIR for these\n+//! generic parameters. See also the `Generics` type and the `generics_of` query\n+//! in rustc.\n+\n+use std::sync::Arc;\n+\n+use ra_syntax::ast::{TypeParamList, AstNode, NameOwner};\n+\n+use crate::{db::HirDatabase, DefId, Name, AsName};\n+\n+/// Data about a generic parameter (to a function, struct, impl, ...).\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct GenericParam {\n+    pub(crate) idx: u32,\n+    pub(crate) name: Name,\n+}\n+\n+/// Data about the generic parameters of a function, struct, impl, etc.\n+#[derive(Clone, PartialEq, Eq, Debug, Default)]\n+pub struct Generics {\n+    pub(crate) params: Vec<GenericParam>,\n+}\n+\n+impl Generics {\n+    pub(crate) fn generics_query(db: &impl HirDatabase, def_id: DefId) -> Arc<Generics> {\n+        let (_file_id, node) = def_id.source(db);\n+        let mut generics = Generics::default();\n+        if let Some(type_param_list) = node.children().find_map(TypeParamList::cast) {\n+            for (idx, type_param) in type_param_list.type_params().enumerate() {\n+                let name = type_param\n+                    .name()\n+                    .map(AsName::as_name)\n+                    .unwrap_or_else(Name::missing);\n+                let param = GenericParam {\n+                    idx: idx as u32,\n+                    name,\n+                };\n+                generics.params.push(param);\n+            }\n+        }\n+        Arc::new(generics)\n+    }\n+\n+    pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n+        self.params.iter().find(|p| &p.name == name)\n+    }\n+}"}, {"sha": "361d39f03e828a9e9ce3ffc2ad8561aebbca4c9f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -24,6 +24,7 @@ mod type_ref;\n mod ty;\n mod impl_block;\n mod expr;\n+mod generics;\n \n mod code_model_api;\n mod code_model_impl;"}, {"sha": "d674db8e636782c1242d32726799252fe816a1ee", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -243,6 +243,7 @@ salsa::database_storage! {\n             fn body_hir() for db::BodyHirQuery;\n             fn body_syntax_mapping() for db::BodySyntaxMappingQuery;\n             fn fn_signature() for db::FnSignatureQuery;\n+            fn generics() for db::GenericsQuery;\n         }\n     }\n }"}, {"sha": "b9a48929d0de4be1bc87c856fd74051b5601290f", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 147, "deletions": 33, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -37,6 +37,7 @@ use crate::{\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat},\n+    generics::Generics,\n };\n \n /// The ID of a type variable.\n@@ -151,10 +152,14 @@ impl Expectation {\n     }\n }\n \n+/// A list of substitutions for generic parameters.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct Substs(Arc<[Ty]>);\n+\n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n ///\n /// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum Ty {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -175,7 +180,8 @@ pub enum Ty {\n         def_id: DefId,\n         /// The name, for displaying.\n         name: Name,\n-        // later we'll need generic substitutions here\n+        /// Substitutions for the generic parameters of the type.\n+        substs: Substs,\n     },\n \n     /// The pointee of a string slice. Written as `str`.\n@@ -234,9 +240,14 @@ pub enum Ty {\n \n     // Opaque (`impl Trait`) type found in a return type.\n     // Opaque(DefId, Substs),\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    Param {\n+        /// The index of the parameter.\n+        idx: u32,\n+        /// The name of the parameter, for displaying.\n+        name: Name,\n+    },\n \n-    // A type parameter; for example, `T` in `fn f<T>(x: T) {}\n-    // Param(ParamTy),\n     /// A type variable used during type checking. Not to be confused with a\n     /// type parameter.\n     Infer(InferTy),\n@@ -250,7 +261,7 @@ pub enum Ty {\n }\n \n /// A function signature.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FnSig {\n     input: Vec<Ty>,\n     output: Ty,\n@@ -261,39 +272,40 @@ impl Ty {\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n+        generics: &Generics,\n         type_ref: &TypeRef,\n     ) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n+                    .map(|tr| Ty::from_hir(db, module, impl_block, generics, tr))\n                     .collect::<Vec<_>>();\n                 Ty::Tuple(inner_tys.into())\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, path),\n+            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, generics, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n+                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n                 Ty::RawPtr(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n+                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n                 Ty::Array(Arc::new(inner_ty))\n             }\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n+                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n                 Ty::Slice(Arc::new(inner_ty))\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n+                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n+                    .map(|tr| Ty::from_hir(db, module, impl_block, generics, tr))\n                     .collect::<Vec<_>>();\n                 let return_ty = inner_tys\n                     .pop()\n@@ -312,15 +324,19 @@ impl Ty {\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n+        generics: &Generics,\n         type_ref: Option<&TypeRef>,\n     ) -> Self {\n-        type_ref.map_or(Ty::Unknown, |t| Ty::from_hir(db, module, impl_block, t))\n+        type_ref.map_or(Ty::Unknown, |t| {\n+            Ty::from_hir(db, module, impl_block, generics, t)\n+        })\n     }\n \n     pub(crate) fn from_hir_path(\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n+        generics: &Generics,\n         path: &Path,\n     ) -> Self {\n         if let Some(name) = path.as_ident() {\n@@ -329,14 +345,27 @@ impl Ty {\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n                 return Ty::Float(float_ty);\n             } else if name.as_known_name() == Some(KnownName::SelfType) {\n-                return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n+                // TODO pass the impl block's generics?\n+                let generics = &Generics::default();\n+                return Ty::from_hir_opt(\n+                    db,\n+                    module,\n+                    None,\n+                    generics,\n+                    impl_block.map(|i| i.target_type()),\n+                );\n             } else if let Some(known) = name.as_known_name() {\n                 match known {\n                     KnownName::Bool => return Ty::Bool,\n                     KnownName::Char => return Ty::Char,\n                     KnownName::Str => return Ty::Str,\n                     _ => {}\n                 }\n+            } else if let Some(generic_param) = generics.find_by_name(&name) {\n+                return Ty::Param {\n+                    idx: generic_param.idx,\n+                    name: generic_param.name.clone(),\n+                };\n             }\n         }\n \n@@ -374,7 +403,14 @@ impl Ty {\n                 }\n                 sig_mut.output.walk_mut(f);\n             }\n-            Ty::Adt { .. } => {} // need to walk type parameters later\n+            Ty::Adt { substs, .. } => {\n+                // Without an Arc::make_mut_slice, we can't avoid the clone here:\n+                let mut v: Vec<_> = substs.0.iter().cloned().collect();\n+                for t in &mut v {\n+                    t.walk_mut(f);\n+                }\n+                substs.0 = v.into();\n+            }\n             _ => {}\n         }\n     }\n@@ -394,6 +430,32 @@ impl Ty {\n             _ => None,\n         }\n     }\n+\n+    /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n+    /// if `self` is `&[T]`, where type parameter T has index 0, and the\n+    /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n+    pub fn subst(self, substs: &Substs) -> Ty {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Param { idx, name } => {\n+                if (idx as usize) < substs.0.len() {\n+                    substs.0[idx as usize].clone()\n+                } else {\n+                    // TODO it's yet unclear to me whether we need to shift the indices here\n+                    Ty::Param { idx, name }\n+                }\n+            }\n+            ty => ty,\n+        })\n+    }\n+\n+    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n+    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n+    fn substs(&self) -> Option<Substs> {\n+        match self {\n+            Ty::Adt { substs, .. } => Some(substs.clone()),\n+            _ => None,\n+        }\n+    }\n }\n \n impl fmt::Display for Ty {\n@@ -425,7 +487,17 @@ impl fmt::Display for Ty {\n                     .to_fmt(f)?;\n                 write!(f, \" -> {}\", sig.output)\n             }\n-            Ty::Adt { name, .. } => write!(f, \"{}\", name),\n+            Ty::Adt { name, substs, .. } => {\n+                write!(f, \"{}\", name)?;\n+                if substs.0.len() > 0 {\n+                    join(substs.0.iter())\n+                        .surround_with(\"<\", \">\")\n+                        .separator(\", \")\n+                        .to_fmt(f)?;\n+                }\n+                Ok(())\n+            }\n+            Ty::Param { name, .. } => write!(f, \"{}\", name),\n             Ty::Unknown => write!(f, \"[unknown]\"),\n             Ty::Infer(..) => write!(f, \"_\"),\n         }\n@@ -440,28 +512,49 @@ fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n     let signature = f.signature(db);\n     let module = f.module(db);\n     let impl_block = f.impl_block(db);\n-    // TODO we ignore type parameters for now\n+    let generics = f.generics(db);\n     let input = signature\n         .params()\n         .iter()\n-        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), tr))\n+        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), &generics, tr))\n         .collect::<Vec<_>>();\n-    let output = Ty::from_hir(db, &module, impl_block.as_ref(), signature.ret_type());\n+    let output = Ty::from_hir(\n+        db,\n+        &module,\n+        impl_block.as_ref(),\n+        &generics,\n+        signature.ret_type(),\n+    );\n     let sig = FnSig { input, output };\n     Ty::FnPtr(Arc::new(sig))\n }\n \n+fn make_substs(generics: &Generics) -> Substs {\n+    Substs(\n+        generics\n+            .params\n+            .iter()\n+            .map(|_p| Ty::Unknown)\n+            .collect::<Vec<_>>()\n+            .into(),\n+    )\n+}\n+\n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n+    let generics = s.generics(db);\n     Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n+        substs: make_substs(&generics),\n     }\n }\n \n pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n+    let generics = s.generics(db);\n     Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n+        substs: make_substs(&generics),\n     }\n }\n \n@@ -506,8 +599,15 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n     };\n     let module = def_id.module(db);\n     let impl_block = def_id.impl_block(db);\n+    let generics = db.generics(def_id);\n     let type_ref = variant_data.get_field_type_ref(&field)?;\n-    Some(Ty::from_hir(db, &module, impl_block.as_ref(), &type_ref))\n+    Some(Ty::from_hir(\n+        db,\n+        &module,\n+        impl_block.as_ref(),\n+        &generics,\n+        &type_ref,\n+    ))\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -684,8 +784,18 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_pat.insert(pat, ty);\n     }\n \n-    fn make_ty(&self, type_ref: &TypeRef) -> Ty {\n-        Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n+        // TODO provide generics of function\n+        let generics = Generics::default();\n+        let ty = Ty::from_hir(\n+            self.db,\n+            &self.module,\n+            self.impl_block.as_ref(),\n+            &generics,\n+            type_ref,\n+        );\n+        let ty = self.insert_type_vars(ty);\n+        ty\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n@@ -848,7 +958,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Some(ty)\n     }\n \n-    fn resolve_variant(&self, path: Option<&Path>) -> (Ty, Option<DefId>) {\n+    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<DefId>) {\n         let path = if let Some(path) = path {\n             path\n         } else {\n@@ -862,10 +972,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         match def_id.resolve(self.db) {\n             Def::Struct(s) => {\n                 let ty = type_for_struct(self.db, s);\n+                let ty = self.insert_type_vars(ty);\n                 (ty, Some(def_id))\n             }\n             Def::EnumVariant(ev) => {\n                 let ty = type_for_enum_variant(self.db, ev);\n+                let ty = self.insert_type_vars(ty);\n                 (ty, Some(def_id))\n             }\n             _ => (Ty::Unknown, None),\n@@ -1155,11 +1267,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 spread,\n             } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n+                let substs = ty.substs().expect(\"adt should have substs\");\n                 for field in fields {\n                     let field_ty = if let Some(def_id) = def_id {\n                         self.db\n                             .type_for_field(def_id, field.name.clone())\n                             .unwrap_or(Ty::Unknown)\n+                            .subst(&substs)\n                     } else {\n                         Ty::Unknown\n                     };\n@@ -1180,7 +1294,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             let i = name.to_string().parse::<usize>().ok();\n                             i.and_then(|i| fields.get(i).cloned())\n                         }\n-                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, name.clone()),\n+                        Ty::Adt {\n+                            def_id, ref substs, ..\n+                        } => self\n+                            .db\n+                            .type_for_field(def_id, name.clone())\n+                            .map(|ty| ty.subst(substs)),\n                         _ => None,\n                     })\n                     .unwrap_or(Ty::Unknown);\n@@ -1193,7 +1312,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Cast { expr, type_ref } => {\n                 let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let cast_ty = self.make_ty(type_ref);\n-                let cast_ty = self.insert_type_vars(cast_ty);\n                 // TODO check the cast...\n                 cast_ty\n             }\n@@ -1305,12 +1423,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     type_ref,\n                     initializer,\n                 } => {\n-                    let decl_ty = Ty::from_hir_opt(\n-                        self.db,\n-                        &self.module,\n-                        self.impl_block.as_ref(),\n-                        type_ref.as_ref(),\n-                    );\n+                    let decl_ty = type_ref\n+                        .as_ref()\n+                        .map(|tr| self.make_ty(tr))\n+                        .unwrap_or(Ty::Unknown);\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = initializer {\n                         let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n@@ -1338,13 +1454,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n             let ty = self.make_ty(type_ref);\n-            let ty = self.insert_type_vars(ty);\n \n             self.infer_pat(*pat, &ty);\n         }\n         self.return_ty = {\n             let ty = self.make_ty(signature.ret_type());\n-            let ty = self.insert_type_vars(ty);\n             ty\n         };\n     }"}, {"sha": "53b6d15a81109afaefcb5f9ffe679d658bac93a1", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -8,7 +8,11 @@ use rustc_hash::FxHashMap;\n \n use ra_db::SourceRootId;\n \n-use crate::{HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function, impl_block::{ImplId, ImplBlock, ImplItem}};\n+use crate::{\n+    HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function,\n+    impl_block::{ImplId, ImplBlock, ImplItem},\n+    generics::Generics\n+};\n use super::Ty;\n \n /// This is used as a key for indexing impls.\n@@ -64,8 +68,15 @@ impl CrateImplBlocks {\n             if let Some(_target_trait) = impl_data.target_trait() {\n                 // ignore for now\n             } else {\n-                let target_ty =\n-                    Ty::from_hir(db, &module, Some(&impl_block), impl_data.target_type());\n+                // TODO provide generics of impl\n+                let generics = Generics::default();\n+                let target_ty = Ty::from_hir(\n+                    db,\n+                    &module,\n+                    Some(&impl_block),\n+                    &generics,\n+                    impl_data.target_type(),\n+                );\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                     self.impls\n                         .entry(target_ty_fp)"}, {"sha": "e44d26cfdc96d22e67f149f693b4f8955777cddf", "filename": "crates/ra_hir/src/ty/tests/data/function_generics.txt", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffunction_generics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffunction_generics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffunction_generics.txt?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -2,13 +2,13 @@\n [21; 26) '{ t }': [unknown]\n [23; 24) 't': [unknown]\n [38; 98) '{     ...(1); }': ()\n-[44; 46) 'id': fn([unknown]) -> [unknown]\n-[44; 52) 'id(1u32)': [unknown]\n-[47; 51) '1u32': [unknown]\n-[58; 68) 'id::<i128>': fn([unknown]) -> [unknown]\n-[58; 71) 'id::<i128>(1)': [unknown]\n-[69; 70) '1': [unknown]\n-[81; 82) 'x': u64\n-[90; 92) 'id': fn([unknown]) -> u64\n-[90; 95) 'id(1)': u64\n-[93; 94) '1': [unknown]\n+[44; 46) 'id': fn(T) -> T\n+[44; 52) 'id(1u32)': T\n+[47; 51) '1u32': u32\n+[58; 68) 'id::<i128>': fn(T) -> T\n+[58; 71) 'id::<i128>(1)': T\n+[69; 70) '1': T\n+[81; 82) 'x': T\n+[90; 92) 'id': fn(T) -> T\n+[90; 95) 'id(1)': T\n+[93; 94) '1': T"}, {"sha": "568e00846be985dc6d4e47b105eb52309a22f911", "filename": "crates/ra_hir/src/ty/tests/data/generic_chain.txt", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgeneric_chain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgeneric_chain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgeneric_chain.txt?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -1,29 +1,29 @@\n-[53; 57) 'self': A\n+[53; 57) 'self': A<[unknown]>\n [65; 87) '{     ...     }': [unknown]\n-[75; 79) 'self': A\n+[75; 79) 'self': A<[unknown]>\n [75; 81) 'self.x': [unknown]\n [99; 100) 't': [unknown]\n [110; 115) '{ t }': [unknown]\n [112; 113) 't': [unknown]\n [135; 261) '{     ....x() }': i128\n-[146; 147) 'x': [unknown]\n-[150; 151) '1': [unknown]\n-[162; 163) 'y': [unknown]\n-[166; 168) 'id': fn([unknown]) -> [unknown]\n-[166; 171) 'id(x)': [unknown]\n-[169; 170) 'x': [unknown]\n-[182; 183) 'a': A\n-[186; 200) 'A { x: id(y) }': A\n-[193; 195) 'id': fn([unknown]) -> [unknown]\n-[193; 198) 'id(y)': [unknown]\n-[196; 197) 'y': [unknown]\n-[211; 212) 'z': [unknown]\n-[215; 217) 'id': fn([unknown]) -> [unknown]\n-[215; 222) 'id(a.x)': [unknown]\n-[218; 219) 'a': A\n-[218; 221) 'a.x': [unknown]\n-[233; 234) 'b': A\n-[237; 247) 'A { x: z }': A\n-[244; 245) 'z': [unknown]\n-[254; 255) 'b': A\n+[146; 147) 'x': T\n+[150; 151) '1': T\n+[162; 163) 'y': T\n+[166; 168) 'id': fn(T) -> T\n+[166; 171) 'id(x)': T\n+[169; 170) 'x': T\n+[182; 183) 'a': A<T>\n+[186; 200) 'A { x: id(y) }': A<T>\n+[193; 195) 'id': fn(T) -> T\n+[193; 198) 'id(y)': T\n+[196; 197) 'y': T\n+[211; 212) 'z': T\n+[215; 217) 'id': fn(T) -> T\n+[215; 222) 'id(a.x)': T\n+[218; 219) 'a': A<T>\n+[218; 221) 'a.x': T\n+[233; 234) 'b': A<T>\n+[237; 247) 'A { x: z }': A<T>\n+[244; 245) 'z': T\n+[254; 255) 'b': A<T>\n [254; 259) 'b.x()': i128"}, {"sha": "88cd2b409d7de3050c4395430bb166a99d75c17a", "filename": "crates/ra_hir/src/ty/tests/data/struct_generics.txt", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -1,15 +1,15 @@\n-[36; 38) 'a1': A\n+[36; 38) 'a1': A<[unknown]>\n [48; 49) 'i': i32\n [56; 147) '{     ...3.x; }': ()\n-[62; 64) 'a1': A\n+[62; 64) 'a1': A<[unknown]>\n [62; 66) 'a1.x': [unknown]\n-[76; 78) 'a2': A\n-[81; 91) 'A { x: i }': A\n+[76; 78) 'a2': A<i32>\n+[81; 91) 'A { x: i }': A<i32>\n [88; 89) 'i': i32\n-[97; 99) 'a2': A\n-[97; 101) 'a2.x': [unknown]\n-[111; 113) 'a3': A\n-[116; 134) 'A::<i1...x: 1 }': A\n-[131; 132) '1': [unknown]\n-[140; 142) 'a3': A\n-[140; 144) 'a3.x': [unknown]\n+[97; 99) 'a2': A<i32>\n+[97; 101) 'a2.x': i32\n+[111; 113) 'a3': A<i32>\n+[116; 134) 'A::<i1...x: 1 }': A<i32>\n+[131; 132) '1': i32\n+[140; 142) 'a3': A<i32>\n+[140; 144) 'a3.x': i32"}, {"sha": "76c2f8173c04fa43864d05d99229b8b0f1299f9f", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -24,7 +24,9 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     for receiver in receiver.autoderef(ctx.db) {\n         match receiver {\n-            Ty::Adt { def_id, .. } => {\n+            Ty::Adt {\n+                def_id, ref substs, ..\n+            } => {\n                 match def_id.resolve(ctx.db) {\n                     Def::Struct(s) => {\n                         for field in s.fields(ctx.db) {\n@@ -33,7 +35,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n                                 field.name().to_string(),\n                             )\n                             .kind(CompletionItemKind::Field)\n-                            .set_detail(field.ty(ctx.db).map(|ty| ty.to_string()))\n+                            .set_detail(field.ty(ctx.db).map(|ty| ty.subst(substs).to_string()))\n                             .add_to(acc);\n                         }\n                     }"}, {"sha": "d53919973249049420a15afc449dc70d5ff45977", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/688a45e00b53412a7a16360c6d678a5d91a95789/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=688a45e00b53412a7a16360c6d678a5d91a95789", "patch": "@@ -129,6 +129,7 @@ salsa::database_storage! {\n             fn body_hir() for hir::db::BodyHirQuery;\n             fn body_syntax_mapping() for hir::db::BodySyntaxMappingQuery;\n             fn fn_signature() for hir::db::FnSignatureQuery;\n+            fn generics() for hir::db::GenericsQuery;\n         }\n     }\n }"}]}