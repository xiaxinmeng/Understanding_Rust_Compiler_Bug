{"sha": "cf062179a84c8f3f619ce86b0e794b34825a36ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMDYyMTc5YTg0YzhmM2Y2MTljZTg2YjBlNzk0YjM0ODI1YTM2YmE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-11-03T06:27:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-03T06:27:19Z"}, "message": "Rollup merge of #78668 - tmiasko:inline, r=oli-obk\n\ninliner: Remove redundant loop\n\nNo functional changes intended.", "tree": {"sha": "ff3e7bc5f5a3ee63998d8871009e123b4f0e23a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff3e7bc5f5a3ee63998d8871009e123b4f0e23a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf062179a84c8f3f619ce86b0e794b34825a36ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfoPhICRBK7hj4Ov3rIwAAdHIIABLoVHvqH9gyn9GLn1uM+Bn4\nSs3m+WGRa+WA+6wjvqDbyXvjOY0rD5BeDCsc9kcDoxAyaN6GtM5EJFC5yH+aNpnq\nkPT51VSPyeAdK3SDZZz8cQ0XwMs0oFIg8oPvBYWQ2uwnEp/kiGgrMj9z5h2UuHsU\nxkQ2I0afKhFUHFg/7vdoEqPqAOCF0iN2liP1sGMszbSZz9SozscqTE0z5//EliU4\nqimhwfPGCjNiLuQNf0/HOGVal8ldS5cepuwfogLyoli7wajMvuPqQWRgCFNSB0i+\nYQ2lOM8tBHJaAPg5rWLblTL7KWxJGofu5FQon7tm+DoXUYqnvDQ3wROKguDWeNQ=\n=2o9w\n-----END PGP SIGNATURE-----\n", "payload": "tree ff3e7bc5f5a3ee63998d8871009e123b4f0e23a4\nparent 9d4cdbbfcd899a7446b13da98fcac9ab81e69740\nparent c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1604384839 +0900\ncommitter GitHub <noreply@github.com> 1604384839 +0900\n\nRollup merge of #78668 - tmiasko:inline, r=oli-obk\n\ninliner: Remove redundant loop\n\nNo functional changes intended.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf062179a84c8f3f619ce86b0e794b34825a36ba", "html_url": "https://github.com/rust-lang/rust/commit/cf062179a84c8f3f619ce86b0e794b34825a36ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf062179a84c8f3f619ce86b0e794b34825a36ba/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d4cdbbfcd899a7446b13da98fcac9ab81e69740", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d4cdbbfcd899a7446b13da98fcac9ab81e69740", "html_url": "https://github.com/rust-lang/rust/commit/9d4cdbbfcd899a7446b13da98fcac9ab81e69740"}, {"sha": "c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f", "html_url": "https://github.com/rust-lang/rust/commit/c0cbf6368d3bf0620d4b7ce9cdf0c37cc31ce49f"}], "stats": {"total": 137, "additions": 60, "deletions": 77}, "files": [{"sha": "010a7470ccd38d29166260b7e9814d693ba5e3a2", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 60, "deletions": 77, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/cf062179a84c8f3f619ce86b0e794b34825a36ba/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf062179a84c8f3f619ce86b0e794b34825a36ba/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=cf062179a84c8f3f619ce86b0e794b34825a36ba", "patch": "@@ -93,96 +93,79 @@ impl Inliner<'tcx> {\n             return;\n         }\n \n-        let mut local_change;\n         let mut changed = false;\n+        while let Some(callsite) = callsites.pop_front() {\n+            debug!(\"checking whether to inline callsite {:?}\", callsite);\n \n-        loop {\n-            local_change = false;\n-            while let Some(callsite) = callsites.pop_front() {\n-                debug!(\"checking whether to inline callsite {:?}\", callsite);\n-\n-                if let InstanceDef::Item(_) = callsite.callee.def {\n-                    if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n-                        debug!(\n-                            \"checking whether to inline callsite {:?} - MIR unavailable\",\n-                            callsite,\n-                        );\n-                        continue;\n-                    }\n+            if let InstanceDef::Item(_) = callsite.callee.def {\n+                if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n+                    debug!(\"checking whether to inline callsite {:?} - MIR unavailable\", callsite,);\n+                    continue;\n                 }\n+            }\n \n-                let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n-                    let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n-                    // Avoid a cycle here by only using `instance_mir` only if we have\n-                    // a lower `HirId` than the callee. This ensures that the callee will\n-                    // not inline us. This trick only works without incremental compilation.\n-                    // So don't do it if that is enabled. Also avoid inlining into generators,\n-                    // since their `optimized_mir` is used for layout computation, which can\n-                    // create a cycle, even when no attempt is made to inline the function\n-                    // in the other direction.\n-                    if !self.tcx.dep_graph.is_fully_enabled()\n-                        && self_hir_id < callee_hir_id\n-                        && caller_body.generator_kind.is_none()\n-                    {\n-                        self.tcx.instance_mir(callsite.callee.def)\n-                    } else {\n-                        continue;\n-                    }\n-                } else {\n-                    // This cannot result in a cycle since the callee MIR is from another crate\n-                    // and is already optimized.\n+            let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n+                let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n+                // Avoid a cycle here by only using `instance_mir` only if we have\n+                // a lower `HirId` than the callee. This ensures that the callee will\n+                // not inline us. This trick only works without incremental compilation.\n+                // So don't do it if that is enabled. Also avoid inlining into generators,\n+                // since their `optimized_mir` is used for layout computation, which can\n+                // create a cycle, even when no attempt is made to inline the function\n+                // in the other direction.\n+                if !self.tcx.dep_graph.is_fully_enabled()\n+                    && self_hir_id < callee_hir_id\n+                    && caller_body.generator_kind.is_none()\n+                {\n                     self.tcx.instance_mir(callsite.callee.def)\n-                };\n-\n-                let callee_body: &Body<'tcx> = &*callee_body;\n-\n-                let callee_body = if self.consider_optimizing(callsite, callee_body) {\n-                    self.tcx.subst_and_normalize_erasing_regions(\n-                        &callsite.callee.substs,\n-                        self.param_env,\n-                        callee_body,\n-                    )\n                 } else {\n                     continue;\n-                };\n+                }\n+            } else {\n+                // This cannot result in a cycle since the callee MIR is from another crate\n+                // and is already optimized.\n+                self.tcx.instance_mir(callsite.callee.def)\n+            };\n \n-                // Copy only unevaluated constants from the callee_body into the caller_body.\n-                // Although we are only pushing `ConstKind::Unevaluated` consts to\n-                // `required_consts`, here we may not only have `ConstKind::Unevaluated`\n-                // because we are calling `subst_and_normalize_erasing_regions`.\n-                caller_body.required_consts.extend(\n-                    callee_body.required_consts.iter().copied().filter(|&constant| {\n-                        matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _))\n-                    }),\n-                );\n+            let callee_body: &Body<'tcx> = &*callee_body;\n \n-                let start = caller_body.basic_blocks().len();\n-                debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n-                if !self.inline_call(callsite, caller_body, callee_body) {\n-                    debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n-                    continue;\n-                }\n-                debug!(\"attempting to inline callsite {:?} - success\", callsite);\n-\n-                // Add callsites from inlined function\n-                for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n-                    if let Some(new_callsite) =\n-                        self.get_valid_function_call(bb, bb_data, caller_body)\n-                    {\n-                        // Don't inline the same function multiple times.\n-                        if callsite.callee != new_callsite.callee {\n-                            callsites.push_back(new_callsite);\n-                        }\n+            let callee_body = if self.consider_optimizing(callsite, callee_body) {\n+                self.tcx.subst_and_normalize_erasing_regions(\n+                    &callsite.callee.substs,\n+                    self.param_env,\n+                    callee_body,\n+                )\n+            } else {\n+                continue;\n+            };\n+\n+            // Copy only unevaluated constants from the callee_body into the caller_body.\n+            // Although we are only pushing `ConstKind::Unevaluated` consts to\n+            // `required_consts`, here we may not only have `ConstKind::Unevaluated`\n+            // because we are calling `subst_and_normalize_erasing_regions`.\n+            caller_body.required_consts.extend(callee_body.required_consts.iter().copied().filter(\n+                |&constant| matches!(constant.literal.val, ConstKind::Unevaluated(_, _, _)),\n+            ));\n+\n+            let start = caller_body.basic_blocks().len();\n+            debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n+            if !self.inline_call(callsite, caller_body, callee_body) {\n+                debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n+                continue;\n+            }\n+            debug!(\"attempting to inline callsite {:?} - success\", callsite);\n+\n+            // Add callsites from inlined function\n+            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n+                if let Some(new_callsite) = self.get_valid_function_call(bb, bb_data, caller_body) {\n+                    // Don't inline the same function multiple times.\n+                    if callsite.callee != new_callsite.callee {\n+                        callsites.push_back(new_callsite);\n                     }\n                 }\n-\n-                local_change = true;\n-                changed = true;\n             }\n \n-            if !local_change {\n-                break;\n-            }\n+            changed = true;\n         }\n \n         // Simplify if we inlined anything."}]}