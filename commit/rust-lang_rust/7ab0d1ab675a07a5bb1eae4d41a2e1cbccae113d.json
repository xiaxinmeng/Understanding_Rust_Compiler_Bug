{"sha": "7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYjBkMWFiNjc1YTA3YTViYjFlYWU0ZDQxYTJlMWNiY2NhZTExM2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-07T10:12:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-17T14:12:55Z"}, "message": "Port to using the newer graph, which offers iterators instead of the\nolder `each` method, but is otherwise identical.", "tree": {"sha": "8090b4b170016b22658967bb23e8d85c7fa8bba4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8090b4b170016b22658967bb23e8d85c7fa8bba4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "html_url": "https://github.com/rust-lang/rust/commit/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52c34625866f6e23fd0de484282f326da6a100e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/52c34625866f6e23fd0de484282f326da6a100e3", "html_url": "https://github.com/rust-lang/rust/commit/52c34625866f6e23fd0de484282f326da6a100e3"}], "stats": {"total": 564, "additions": 320, "deletions": 244}, "files": [{"sha": "ab5c4e76966018210dd4c09020d23c7beca461dc", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -104,7 +104,6 @@ pub mod middle {\n     pub mod entry;\n     pub mod expr_use_visitor;\n     pub mod fast_reject;\n-    pub mod graph;\n     pub mod intrinsicck;\n     pub mod infer;\n     pub mod lang_items;"}, {"sha": "359a1a486c9da7cabb5666f45cbc71de2ba607e5", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::graph;\n use middle::cfg::*;\n use middle::def;\n-use middle::graph;\n use middle::pat_util;\n use middle::region::CodeExtent;\n use middle::ty;"}, {"sha": "3ca221c9630be93c92aefaecad46fd3462da9ea8", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -11,7 +11,7 @@\n //! Module that constructs a control-flow graph representing an item.\n //! Uses `Graph` as the underlying representation.\n \n-use middle::graph;\n+use rustc_data_structures::graph;\n use middle::ty;\n use syntax::ast;\n \n@@ -24,7 +24,7 @@ pub struct CFG {\n     pub exit: CFGIndex,\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum CFGNodeData {\n     AST(ast::NodeId),\n     Entry,\n@@ -43,6 +43,7 @@ impl CFGNodeData {\n     }\n }\n \n+#[derive(Debug)]\n pub struct CFGEdgeData {\n     pub exiting_scopes: Vec<ast::NodeId>\n }"}, {"sha": "1d5d4f72fc2da7693531a303e7e89a8927c2fe02", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -576,10 +576,9 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n                                                pred_bits: &[usize],\n                                                cfg: &cfg::CFG,\n                                                cfgidx: CFGIndex) {\n-        cfg.graph.each_outgoing_edge(cfgidx, |_e_idx, edge| {\n+        for (_, edge) in cfg.graph.outgoing_edges(cfgidx) {\n             self.propagate_bits_into_entry_set_for(pred_bits, edge);\n-            true\n-        });\n+        }\n     }\n \n     fn propagate_bits_into_entry_set_for(&mut self,"}, {"sha": "e76468131e04d973cf6e6935fd15313de298875a", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -20,14 +20,13 @@ use self::Classification::*;\n \n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n+use rustc_data_structures::graph::{self, Direction, NodeIndex};\n use middle::region;\n use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::ty_relate::RelateResult;\n-use middle::graph;\n-use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::{Repr, UserString};\n@@ -1325,10 +1324,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let num_vars = self.num_vars();\n \n         let constraints = self.constraints.borrow();\n-        let num_edges = constraints.len();\n \n-        let mut graph = graph::Graph::with_capacity(num_vars as usize + 1,\n-                                                    num_edges);\n+        let mut graph = graph::Graph::new();\n \n         for _ in 0..num_vars {\n             graph.add_node(());\n@@ -1370,10 +1367,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // not contained by an upper-bound.\n         let (mut lower_bounds, lower_dup) =\n             self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::Incoming, dup_vec);\n+                                          graph::INCOMING, dup_vec);\n         let (mut upper_bounds, upper_dup) =\n             self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::Outgoing, dup_vec);\n+                                          graph::OUTGOING, dup_vec);\n \n         if lower_dup || upper_dup {\n             return;\n@@ -1433,7 +1430,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // that have no intersection.\n         let (upper_bounds, dup_found) =\n             self.collect_concrete_regions(graph, var_data, node_idx,\n-                                          graph::Outgoing, dup_vec);\n+                                          graph::OUTGOING, dup_vec);\n \n         if dup_found {\n             return;\n@@ -1508,8 +1505,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             // figure out the direction from which this node takes its\n             // values, and search for concrete regions etc in that direction\n             let dir = match classification {\n-                Expanding => graph::Incoming,\n-                Contracting => graph::Outgoing,\n+                Expanding => graph::INCOMING,\n+                Contracting => graph::OUTGOING,\n             };\n \n             process_edges(self, &mut state, graph, node_idx, dir);\n@@ -1519,14 +1516,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         return (result, dup_found);\n \n         fn process_edges<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n-                         state: &mut WalkState<'tcx>,\n-                         graph: &RegionGraph,\n-                         source_vid: RegionVid,\n-                         dir: Direction) {\n+                                   state: &mut WalkState<'tcx>,\n+                                   graph: &RegionGraph,\n+                                   source_vid: RegionVid,\n+                                   dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.index as usize);\n-            graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n+            for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n                         let opp_vid =\n@@ -1544,8 +1541,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         });\n                     }\n                 }\n-                true\n-            });\n+            }\n         }\n     }\n "}, {"sha": "f5924ef5a3f637e74ce4eb8d959d06c2ff48140f", "filename": "src/librustc_data_structures/bitvec.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -0,0 +1,32 @@\n+use std::iter;\n+\n+/// A very simple BitVector type.\n+pub struct BitVector {\n+    data: Vec<u64>\n+}\n+\n+impl BitVector {\n+    pub fn new(num_bits: usize) -> BitVector {\n+        let num_words = (num_bits + 63) / 64;\n+        BitVector { data: iter::repeat(0).take(num_words).collect() }\n+    }\n+\n+    fn word_mask(&self, bit: usize) -> (usize, u64) {\n+        let word = bit / 64;\n+        let mask = 1 << (bit % 64);\n+        (word, mask)\n+    }\n+\n+    pub fn contains(&self, bit: usize) -> bool {\n+        let (word, mask) = self.word_mask(bit);\n+        (self.data[word] & mask) != 0\n+    }\n+\n+    pub fn insert(&mut self, bit: usize) -> bool {\n+        let (word, mask) = self.word_mask(bit);\n+        let data = &mut self.data[word];\n+        let value = *data;\n+        *data = value | mask;\n+        (value | mask) != value\n+    }\n+}"}, {"sha": "5741544fe5419638d262839ab3c512d8e4ef4a28", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "renamed", "additions": 136, "deletions": 217, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -30,15 +30,17 @@\n //! the field `next_edge`). Each of those fields is an array that should\n //! be indexed by the direction (see the type `Direction`).\n \n-#![allow(dead_code)] // still WIP\n-\n+use bitvec::BitVector;\n use std::fmt::{Formatter, Error, Debug};\n use std::usize;\n-use std::collections::BitSet;\n+use snapshot_vec::{SnapshotVec, SnapshotVecDelegate};\n+\n+#[cfg(test)]\n+mod test;\n \n pub struct Graph<N,E> {\n-    nodes: Vec<Node<N>> ,\n-    edges: Vec<Edge<E>> ,\n+    nodes: SnapshotVec<Node<N>> ,\n+    edges: SnapshotVec<Edge<E>> ,\n }\n \n pub struct Node<N> {\n@@ -53,6 +55,20 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n+impl<N> SnapshotVecDelegate for Node<N> {\n+    type Value = Node<N>;\n+    type Undo = ();\n+\n+    fn reverse(_: &mut Vec<Node<N>>, _: ()) {}\n+}\n+\n+impl<N> SnapshotVecDelegate for Edge<N> {\n+    type Value = Edge<N>;\n+    type Undo = ();\n+\n+    fn reverse(_: &mut Vec<Edge<N>>, _: ()) {}\n+}\n+\n impl<E: Debug> Debug for Edge<E> {\n     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n         write!(f, \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n@@ -61,49 +77,37 @@ impl<E: Debug> Debug for Edge<E> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub struct NodeIndex(pub usize);\n-#[allow(non_upper_case_globals)]\n-pub const InvalidNodeIndex: NodeIndex = NodeIndex(usize::MAX);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub struct EdgeIndex(pub usize);\n-#[allow(non_upper_case_globals)]\n-pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(usize::MAX);\n+\n+pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[derive(Copy, Clone, Debug)]\n pub struct Direction { repr: usize }\n-#[allow(non_upper_case_globals)]\n-pub const Outgoing: Direction = Direction { repr: 0 };\n-#[allow(non_upper_case_globals)]\n-pub const Incoming: Direction = Direction { repr: 1 };\n+\n+pub const OUTGOING: Direction = Direction { repr: 0 };\n+\n+pub const INCOMING: Direction = Direction { repr: 1 };\n \n impl NodeIndex {\n-    fn get(&self) -> usize { let NodeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated node).\n-    pub fn node_id(&self) -> usize { self.get() }\n+    pub fn node_id(&self) -> usize { self.0 }\n }\n \n impl EdgeIndex {\n-    fn get(&self) -> usize { let EdgeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated edge).\n-    pub fn edge_id(&self) -> usize { self.get() }\n+    pub fn edge_id(&self) -> usize { self.0 }\n }\n \n-impl<N,E> Graph<N,E> {\n+impl<N:Debug,E:Debug> Graph<N,E> {\n     pub fn new() -> Graph<N,E> {\n         Graph {\n-            nodes: Vec::new(),\n-            edges: Vec::new(),\n-        }\n-    }\n-\n-    pub fn with_capacity(num_nodes: usize,\n-                         num_edges: usize) -> Graph<N,E> {\n-        Graph {\n-            nodes: Vec::with_capacity(num_nodes),\n-            edges: Vec::with_capacity(num_edges),\n+            nodes: SnapshotVec::new(),\n+            edges: SnapshotVec::new(),\n         }\n     }\n \n@@ -130,22 +134,22 @@ impl<N,E> Graph<N,E> {\n     pub fn add_node(&mut self, data: N) -> NodeIndex {\n         let idx = self.next_node_index();\n         self.nodes.push(Node {\n-            first_edge: [InvalidEdgeIndex, InvalidEdgeIndex],\n+            first_edge: [INVALID_EDGE_INDEX, INVALID_EDGE_INDEX],\n             data: data\n         });\n         idx\n     }\n \n     pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n-        &mut self.nodes[idx.get()].data\n+        &mut self.nodes[idx.0].data\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n-        &self.nodes[idx.get()].data\n+        &self.nodes[idx.0].data\n     }\n \n     pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n-        &self.nodes[idx.get()]\n+        &self.nodes[idx.0]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -159,13 +163,15 @@ impl<N,E> Graph<N,E> {\n                     source: NodeIndex,\n                     target: NodeIndex,\n                     data: E) -> EdgeIndex {\n+        debug!(\"graph: add_edge({:?}, {:?}, {:?})\", source, target, data);\n+\n         let idx = self.next_edge_index();\n \n         // read current first of the list of edges from each node\n-        let source_first = self.nodes[source.get()]\n-                                     .first_edge[Outgoing.repr];\n-        let target_first = self.nodes[target.get()]\n-                                     .first_edge[Incoming.repr];\n+        let source_first = self.nodes[source.0]\n+                                     .first_edge[OUTGOING.repr];\n+        let target_first = self.nodes[target.0]\n+                                     .first_edge[INCOMING.repr];\n \n         // create the new edge, with the previous firsts from each node\n         // as the next pointers\n@@ -177,38 +183,38 @@ impl<N,E> Graph<N,E> {\n         });\n \n         // adjust the firsts for each node target be the next object.\n-        self.nodes[source.get()].first_edge[Outgoing.repr] = idx;\n-        self.nodes[target.get()].first_edge[Incoming.repr] = idx;\n+        self.nodes[source.0].first_edge[OUTGOING.repr] = idx;\n+        self.nodes[target.0].first_edge[INCOMING.repr] = idx;\n \n         return idx;\n     }\n \n     pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n-        &mut self.edges[idx.get()].data\n+        &mut self.edges[idx.0].data\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n-        &self.edges[idx.get()].data\n+        &self.edges[idx.0].data\n     }\n \n     pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n-        &self.edges[idx.get()]\n+        &self.edges[idx.0]\n     }\n \n     pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the index of the first edge adjacent to `node`.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.nodes[node.get()].first_edge[dir.repr]\n+        self.nodes[node.0].first_edge[dir.repr]\n     }\n \n     pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the next edge in a given direction.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.edges[edge.get()].next_edge[dir.repr]\n+        self.edges[edge.0].next_edge[dir.repr]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -228,41 +234,25 @@ impl<N,E> Graph<N,E> {\n         self.edges.iter().enumerate().all(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n-    pub fn each_outgoing_edge<'a, F>(&'a self, source: NodeIndex, f: F) -> bool where\n-        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n-    {\n-        //! Iterates over all outgoing edges from the node `from`\n+    pub fn outgoing_edges(&self, source: NodeIndex) -> AdjacentEdges<N,E> {\n+        self.adjacent_edges(source, OUTGOING)\n+    }\n \n-        self.each_adjacent_edge(source, Outgoing, f)\n+    pub fn incoming_edges(&self, source: NodeIndex) -> AdjacentEdges<N,E> {\n+        self.adjacent_edges(source, INCOMING)\n     }\n \n-    pub fn each_incoming_edge<'a, F>(&'a self, target: NodeIndex, f: F) -> bool where\n-        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n-    {\n-        //! Iterates over all incoming edges to the node `target`\n+    pub fn adjacent_edges(&self, source: NodeIndex, direction: Direction) -> AdjacentEdges<N,E> {\n+        let first_edge = self.node(source).first_edge[direction.repr];\n+        AdjacentEdges { graph: self, direction: direction, next: first_edge }\n+    }\n \n-        self.each_adjacent_edge(target, Incoming, f)\n+    pub fn successor_nodes<'a>(&'a self, source: NodeIndex) -> AdjacentTargets<N,E> {\n+        self.outgoing_edges(source).targets()\n     }\n \n-    pub fn each_adjacent_edge<'a, F>(&'a self,\n-                                     node: NodeIndex,\n-                                     dir: Direction,\n-                                     mut f: F)\n-                                     -> bool where\n-        F: FnMut(EdgeIndex, &'a Edge<E>) -> bool,\n-    {\n-        //! Iterates over all edges adjacent to the node `node`\n-        //! in the direction `dir` (either `Outgoing` or `Incoming)\n-\n-        let mut edge_idx = self.first_adjacent(node, dir);\n-        while edge_idx != InvalidEdgeIndex {\n-            let edge = &self.edges[edge_idx.get()];\n-            if !f(edge_idx, edge) {\n-                return false;\n-            }\n-            edge_idx = edge.next_edge[dir.repr];\n-        }\n-        return true;\n+    pub fn predecessor_nodes<'a>(&'a self, target: NodeIndex) -> AdjacentSources<N,E> {\n+        self.incoming_edges(target).sources()\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -292,31 +282,95 @@ impl<N,E> Graph<N,E> {\n         DepthFirstTraversal {\n             graph: self,\n             stack: vec![start],\n-            visited: BitSet::new()\n+            visited: BitVector::new(self.nodes.len()),\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Iterators\n+\n+pub struct AdjacentEdges<'g,N,E>\n+    where N:'g, E:'g\n+{\n+    graph: &'g Graph<N, E>,\n+    direction: Direction,\n+    next: EdgeIndex,\n+}\n+\n+impl<'g,N,E> AdjacentEdges<'g,N,E> {\n+    fn targets(self) -> AdjacentTargets<'g,N,E> {\n+        AdjacentTargets { edges: self }\n+    }\n+\n+    fn sources(self) -> AdjacentSources<'g,N,E> {\n+        AdjacentSources { edges: self }\n+    }\n+}\n+\n+impl<'g, N:Debug, E:Debug> Iterator for AdjacentEdges<'g, N, E> {\n+    type Item = (EdgeIndex, &'g Edge<E>);\n+\n+    fn next(&mut self) -> Option<(EdgeIndex, &'g Edge<E>)> {\n+        let edge_index = self.next;\n+        if edge_index == INVALID_EDGE_INDEX {\n+            return None;\n         }\n+\n+        let edge = self.graph.edge(edge_index);\n+        self.next = edge.next_edge[self.direction.repr];\n+        Some((edge_index, edge))\n+    }\n+}\n+\n+pub struct AdjacentTargets<'g,N:'g,E:'g>\n+    where N:'g, E:'g\n+{\n+    edges: AdjacentEdges<'g,N,E>,\n+}\n+\n+impl<'g, N:Debug, E:Debug> Iterator for AdjacentTargets<'g, N, E> {\n+    type Item = NodeIndex;\n+\n+    fn next(&mut self) -> Option<NodeIndex> {\n+        self.edges.next().map(|(_, edge)| edge.target)\n+    }\n+}\n+\n+pub struct AdjacentSources<'g,N:'g,E:'g>\n+    where N:'g, E:'g\n+{\n+    edges: AdjacentEdges<'g,N,E>,\n+}\n+\n+impl<'g, N:Debug, E:Debug> Iterator for AdjacentSources<'g, N, E> {\n+    type Item = NodeIndex;\n+\n+    fn next(&mut self) -> Option<NodeIndex> {\n+        self.edges.next().map(|(_, edge)| edge.source)\n     }\n }\n \n pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitSet\n+    visited: BitVector\n }\n \n-impl<'g, N, E> Iterator for DepthFirstTraversal<'g, N, E> {\n+impl<'g, N:Debug, E:Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     type Item = &'g N;\n \n     fn next(&mut self) -> Option<&'g N> {\n         while let Some(idx) = self.stack.pop() {\n             if !self.visited.insert(idx.node_id()) {\n                 continue;\n             }\n-            self.graph.each_outgoing_edge(idx, |_, e| -> bool {\n-                if !self.visited.contains(&e.target().node_id()) {\n-                    self.stack.push(e.target());\n+\n+            for (_, edge) in self.graph.outgoing_edges(idx) {\n+                if !self.visited.contains(edge.target().node_id()) {\n+                    self.stack.push(edge.target());\n                 }\n-                true\n-            });\n+            }\n \n             return Some(self.graph.node_data(idx));\n         }\n@@ -329,7 +383,7 @@ pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F) where\n     F: FnMut(EdgeIndex) -> bool,\n {\n     let mut i = 0;\n-    let n = max_edge_index.get();\n+    let n = max_edge_index.0;\n     while i < n {\n         if !f(EdgeIndex(i)) {\n             return;\n@@ -347,138 +401,3 @@ impl<E> Edge<E> {\n         self.target\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use middle::graph::*;\n-    use std::fmt::Debug;\n-\n-    type TestNode = Node<&'static str>;\n-    type TestEdge = Edge<&'static str>;\n-    type TestGraph = Graph<&'static str, &'static str>;\n-\n-    fn create_graph() -> TestGraph {\n-        let mut graph = Graph::new();\n-\n-        // Create a simple graph\n-        //\n-        //    A -+> B --> C\n-        //       |  |     ^\n-        //       |  v     |\n-        //       F  D --> E\n-\n-        let a = graph.add_node(\"A\");\n-        let b = graph.add_node(\"B\");\n-        let c = graph.add_node(\"C\");\n-        let d = graph.add_node(\"D\");\n-        let e = graph.add_node(\"E\");\n-        let f = graph.add_node(\"F\");\n-\n-        graph.add_edge(a, b, \"AB\");\n-        graph.add_edge(b, c, \"BC\");\n-        graph.add_edge(b, d, \"BD\");\n-        graph.add_edge(d, e, \"DE\");\n-        graph.add_edge(e, c, \"EC\");\n-        graph.add_edge(f, b, \"FB\");\n-\n-        return graph;\n-    }\n-\n-    #[test]\n-    fn each_node() {\n-        let graph = create_graph();\n-        let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n-        graph.each_node(|idx, node| {\n-            assert_eq!(&expected[idx.get()], graph.node_data(idx));\n-            assert_eq!(expected[idx.get()], node.data);\n-            true\n-        });\n-    }\n-\n-    #[test]\n-    fn each_edge() {\n-        let graph = create_graph();\n-        let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n-        graph.each_edge(|idx, edge| {\n-            assert_eq!(&expected[idx.get()], graph.edge_data(idx));\n-            assert_eq!(expected[idx.get()], edge.data);\n-            true\n-        });\n-    }\n-\n-    fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n-                                      start_index: NodeIndex,\n-                                      start_data: N,\n-                                      expected_incoming: &[(E,N)],\n-                                      expected_outgoing: &[(E,N)]) {\n-        assert!(graph.node_data(start_index) == &start_data);\n-\n-        let mut counter = 0;\n-        graph.each_incoming_edge(start_index, |edge_index, edge| {\n-            assert!(graph.edge_data(edge_index) == &edge.data);\n-            assert!(counter < expected_incoming.len());\n-            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n-                   counter, expected_incoming[counter], edge_index, edge);\n-            match expected_incoming[counter] {\n-                (ref e, ref n) => {\n-                    assert!(e == &edge.data);\n-                    assert!(n == graph.node_data(edge.source));\n-                    assert!(start_index == edge.target);\n-                }\n-            }\n-            counter += 1;\n-            true\n-        });\n-        assert_eq!(counter, expected_incoming.len());\n-\n-        let mut counter = 0;\n-        graph.each_outgoing_edge(start_index, |edge_index, edge| {\n-            assert!(graph.edge_data(edge_index) == &edge.data);\n-            assert!(counter < expected_outgoing.len());\n-            debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n-                   counter, expected_outgoing[counter], edge_index, edge);\n-            match expected_outgoing[counter] {\n-                (ref e, ref n) => {\n-                    assert!(e == &edge.data);\n-                    assert!(start_index == edge.source);\n-                    assert!(n == graph.node_data(edge.target));\n-                }\n-            }\n-            counter += 1;\n-            true\n-        });\n-        assert_eq!(counter, expected_outgoing.len());\n-    }\n-\n-    #[test]\n-    fn each_adjacent_from_a() {\n-        let graph = create_graph();\n-        test_adjacent_edges(&graph, NodeIndex(0), \"A\",\n-                            &[],\n-                            &[(\"AB\", \"B\")]);\n-    }\n-\n-    #[test]\n-    fn each_adjacent_from_b() {\n-        let graph = create_graph();\n-        test_adjacent_edges(&graph, NodeIndex(1), \"B\",\n-                            &[(\"FB\", \"F\"), (\"AB\", \"A\"),],\n-                            &[(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n-    }\n-\n-    #[test]\n-    fn each_adjacent_from_c() {\n-        let graph = create_graph();\n-        test_adjacent_edges(&graph, NodeIndex(2), \"C\",\n-                            &[(\"EC\", \"E\"), (\"BC\", \"B\")],\n-                            &[]);\n-    }\n-\n-    #[test]\n-    fn each_adjacent_from_d() {\n-        let graph = create_graph();\n-        test_adjacent_edges(&graph, NodeIndex(3), \"D\",\n-                            &[(\"BD\", \"B\")],\n-                            &[(\"DE\", \"E\")]);\n-    }\n-}", "previous_filename": "src/librustc/middle/graph.rs"}, {"sha": "a26d1d2fbd9e4fbd2502173f9f590b76e2683d6e", "filename": "src/librustc_data_structures/graph/test.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -0,0 +1,129 @@\n+use graph::*;\n+use std::fmt::Debug;\n+\n+type TestNode = Node<&'static str>;\n+type TestEdge = Edge<&'static str>;\n+type TestGraph = Graph<&'static str, &'static str>;\n+\n+fn create_graph() -> TestGraph {\n+    let mut graph = Graph::new();\n+\n+    // Create a simple graph\n+    //\n+    //    A -+> B --> C\n+    //       |  |     ^\n+    //       |  v     |\n+    //       F  D --> E\n+\n+    let a = graph.add_node(\"A\");\n+    let b = graph.add_node(\"B\");\n+    let c = graph.add_node(\"C\");\n+    let d = graph.add_node(\"D\");\n+    let e = graph.add_node(\"E\");\n+    let f = graph.add_node(\"F\");\n+\n+    graph.add_edge(a, b, \"AB\");\n+    graph.add_edge(b, c, \"BC\");\n+    graph.add_edge(b, d, \"BD\");\n+    graph.add_edge(d, e, \"DE\");\n+    graph.add_edge(e, c, \"EC\");\n+    graph.add_edge(f, b, \"FB\");\n+\n+    return graph;\n+}\n+\n+#[test]\n+fn each_node() {\n+    let graph = create_graph();\n+    let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n+    graph.each_node(|idx, node| {\n+        assert_eq!(&expected[idx.0], graph.node_data(idx));\n+        assert_eq!(expected[idx.0], node.data);\n+        true\n+    });\n+}\n+\n+#[test]\n+fn each_edge() {\n+    let graph = create_graph();\n+    let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n+    graph.each_edge(|idx, edge| {\n+        assert_eq!(&expected[idx.0], graph.edge_data(idx));\n+        assert_eq!(expected[idx.0], edge.data);\n+        true\n+    });\n+}\n+\n+fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n+                                                            start_index: NodeIndex,\n+                                                            start_data: N,\n+                                                            expected_incoming: &[(E,N)],\n+                                                            expected_outgoing: &[(E,N)]) {\n+    assert!(graph.node_data(start_index) == &start_data);\n+\n+    let mut counter = 0;\n+    for (edge_index, edge) in graph.incoming_edges(start_index) {\n+        assert!(graph.edge_data(edge_index) == &edge.data);\n+        assert!(counter < expected_incoming.len());\n+        debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+               counter, expected_incoming[counter], edge_index, edge);\n+        match expected_incoming[counter] {\n+            (ref e, ref n) => {\n+                assert!(e == &edge.data);\n+                assert!(n == graph.node_data(edge.source()));\n+                assert!(start_index == edge.target);\n+            }\n+        }\n+        counter += 1;\n+    }\n+    assert_eq!(counter, expected_incoming.len());\n+\n+    let mut counter = 0;\n+    for (edge_index, edge) in graph.outgoing_edges(start_index) {\n+        assert!(graph.edge_data(edge_index) == &edge.data);\n+        assert!(counter < expected_outgoing.len());\n+        debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n+               counter, expected_outgoing[counter], edge_index, edge);\n+        match expected_outgoing[counter] {\n+            (ref e, ref n) => {\n+                assert!(e == &edge.data);\n+                assert!(start_index == edge.source);\n+                assert!(n == graph.node_data(edge.target));\n+            }\n+        }\n+        counter += 1;\n+    }\n+    assert_eq!(counter, expected_outgoing.len());\n+}\n+\n+#[test]\n+fn each_adjacent_from_a() {\n+    let graph = create_graph();\n+    test_adjacent_edges(&graph, NodeIndex(0), \"A\",\n+                        &[],\n+                        &[(\"AB\", \"B\")]);\n+}\n+\n+#[test]\n+fn each_adjacent_from_b() {\n+    let graph = create_graph();\n+    test_adjacent_edges(&graph, NodeIndex(1), \"B\",\n+                        &[(\"FB\", \"F\"), (\"AB\", \"A\"),],\n+                        &[(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n+}\n+\n+#[test]\n+fn each_adjacent_from_c() {\n+    let graph = create_graph();\n+    test_adjacent_edges(&graph, NodeIndex(2), \"C\",\n+                        &[(\"EC\", \"E\"), (\"BC\", \"B\")],\n+                        &[]);\n+}\n+\n+#[test]\n+fn each_adjacent_from_d() {\n+    let graph = create_graph();\n+    test_adjacent_edges(&graph, NodeIndex(3), \"D\",\n+                        &[(\"BD\", \"B\")],\n+                        &[(\"DE\", \"E\")]);\n+}"}, {"sha": "d90a40941cb27a204229c1f8537cf0e4f661eb40", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -33,3 +33,5 @@\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod snapshot_vec;\n+pub mod graph;\n+pub mod bitvec;"}, {"sha": "33a817cfedbb2225f025a84f58b04c341c113b8f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7ab0d1ab675a07a5bb1eae4d41a2e1cbccae113d", "patch": "@@ -1886,14 +1886,13 @@ impl LintPass for UnconditionalRecursion {\n                 continue;\n             }\n             // add the successors of this node to explore the graph further.\n-            cfg.graph.each_outgoing_edge(idx, |_, edge| {\n+            for (_, edge) in cfg.graph.outgoing_edges(idx) {\n                 let target_idx = edge.target();\n                 let target_cfg_id = target_idx.node_id();\n                 if !visited.contains(&target_cfg_id) {\n                     work_queue.push(target_idx)\n                 }\n-                true\n-            });\n+            }\n         }\n \n         // Check the number of self calls because a function that"}]}