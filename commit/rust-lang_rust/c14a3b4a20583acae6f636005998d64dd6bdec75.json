{"sha": "c14a3b4a20583acae6f636005998d64dd6bdec75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNGEzYjRhMjA1ODNhY2FlNmY2MzYwMDU5OThkNjRkZDZiZGVjNzU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-04T16:53:30Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-04T16:53:30Z"}, "message": "Modernize qual path completion tests", "tree": {"sha": "34f64efc91ce82e920416d41868e275ea55291a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34f64efc91ce82e920416d41868e275ea55291a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c14a3b4a20583acae6f636005998d64dd6bdec75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c14a3b4a20583acae6f636005998d64dd6bdec75", "html_url": "https://github.com/rust-lang/rust/commit/c14a3b4a20583acae6f636005998d64dd6bdec75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c14a3b4a20583acae6f636005998d64dd6bdec75/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "824a24c71029a9c672f1ba4bd38a8bd568228f5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/824a24c71029a9c672f1ba4bd38a8bd568228f5a", "html_url": "https://github.com/rust-lang/rust/commit/824a24c71029a9c672f1ba4bd38a8bd568228f5a"}], "stats": {"total": 1580, "additions": 475, "deletions": 1105}, "files": [{"sha": "f3a5e9573514506d0f1c24359fe8e68e269f058a", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14a3b4a20583acae6f636005998d64dd6bdec75/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14a3b4a20583acae6f636005998d64dd6bdec75/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=c14a3b4a20583acae6f636005998d64dd6bdec75", "patch": "@@ -2,6 +2,9 @@ mod completion_config;\n mod completion_item;\n mod completion_context;\n mod presentation;\n+mod patterns;\n+#[cfg(test)]\n+mod test_utils;\n \n mod complete_attribute;\n mod complete_dot;\n@@ -15,9 +18,6 @@ mod complete_unqualified_path;\n mod complete_postfix;\n mod complete_macro_in_item_position;\n mod complete_trait_impl;\n-mod patterns;\n-#[cfg(test)]\n-mod test_utils;\n \n use ra_ide_db::RootDatabase;\n "}, {"sha": "ba4121103686b7911872d9e0c53507f281c85672", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 421, "deletions": 1102, "changes": 1523, "blob_url": "https://github.com/rust-lang/rust/blob/c14a3b4a20583acae6f636005998d64dd6bdec75/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14a3b4a20583acae6f636005998d64dd6bdec75/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=c14a3b4a20583acae6f636005998d64dd6bdec75", "patch": "@@ -147,1269 +147,588 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n #[cfg(test)]\n mod tests {\n+    use expect::{expect, Expect};\n     use test_utils::mark;\n \n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n-    use insta::assert_debug_snapshot;\n+    use crate::completion::{\n+        test_utils::{check_edit, completion_list},\n+        CompletionKind,\n+    };\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture, CompletionKind::Reference);\n+        expect.assert_eq(&actual);\n+    }\n \n-    fn do_reference_completion(code: &str) -> Vec<CompletionItem> {\n-        do_completion(code, CompletionKind::Reference)\n+    fn check_builtin(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture, CompletionKind::BuiltinType);\n+        expect.assert_eq(&actual);\n     }\n \n     #[test]\n     fn dont_complete_current_use() {\n         mark::check!(dont_complete_current_use);\n-        let completions = do_completion(r\"use self::foo<|>;\", CompletionKind::Reference);\n-        assert!(completions.is_empty());\n+        check(r#\"use self::foo<|>;\"#, expect![[\"\"]]);\n     }\n \n     #[test]\n     fn dont_complete_current_use_in_braces_with_glob() {\n-        let completions = do_completion(\n-            r\"\n-            mod foo { pub struct S; }\n-            use self::{foo::*, bar<|>};\n-            \",\n-            CompletionKind::Reference,\n+        check(\n+            r#\"\n+mod foo { pub struct S; }\n+use self::{foo::*, bar<|>};\n+\"#,\n+            expect![[r#\"\n+                st S\n+                md foo\n+            \"#]],\n         );\n-        assert_eq!(completions.len(), 2);\n     }\n \n     #[test]\n     fn dont_complete_primitive_in_use() {\n-        let completions = do_completion(r\"use self::<|>;\", CompletionKind::BuiltinType);\n-        assert!(completions.is_empty());\n+        check_builtin(r#\"use self::<|>;\"#, expect![[\"\"]]);\n     }\n \n     #[test]\n     fn dont_complete_primitive_in_module_scope() {\n-        let completions = do_completion(r\"fn foo() { self::<|> }\", CompletionKind::BuiltinType);\n-        assert!(completions.is_empty());\n+        check_builtin(r#\"fn foo() { self::<|> }\"#, expect![[\"\"]]);\n     }\n \n     #[test]\n     fn completes_primitives() {\n-        let completions =\n-            do_completion(r\"fn main() { let _: <|> = 92; }\", CompletionKind::BuiltinType);\n-        assert_eq!(completions.len(), 17);\n-    }\n-\n-    #[test]\n-    fn completes_mod_with_docs() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                use self::my<|>;\n-\n-                /// Some simple\n-                /// docs describing `mod my`.\n-                mod my {\n-                    struct Bar;\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"my\",\n-                source_range: 10..12,\n-                delete: 10..12,\n-                insert: \"my\",\n-                kind: Module,\n-                documentation: Documentation(\n-                    \"Some simple\\ndocs describing `mod my`.\",\n-                ),\n-            },\n-        ]\n-        \"###\n+        check_builtin(\n+            r#\"fn main() { let _: <|> = 92; }\"#,\n+            expect![[r#\"\n+                bt bool\n+                bt char\n+                bt f32\n+                bt f64\n+                bt i128\n+                bt i16\n+                bt i32\n+                bt i64\n+                bt i8\n+                bt isize\n+                bt str\n+                bt u128\n+                bt u16\n+                bt u32\n+                bt u64\n+                bt u8\n+                bt usize\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_mod_with_same_name_as_function() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                use self::my::<|>;\n-\n-                mod my {\n-                    pub struct Bar;\n-                }\n-\n-                fn my() {}\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Bar\",\n-                source_range: 14..14,\n-                delete: 14..14,\n-                insert: \"Bar\",\n-                kind: Struct,\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+use self::my::<|>;\n+\n+mod my { pub struct Bar; }\n+fn my() {}\n+\"#,\n+            expect![[r#\"\n+                st Bar\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn path_visibility() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                use self::my::<|>;\n-\n-                mod my {\n-                    struct Bar;\n-                    pub struct Foo;\n-                    pub use Bar as PublicBar;\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Foo\",\n-                source_range: 14..14,\n-                delete: 14..14,\n-                insert: \"Foo\",\n-                kind: Struct,\n-            },\n-            CompletionItem {\n-                label: \"PublicBar\",\n-                source_range: 14..14,\n-                delete: 14..14,\n-                insert: \"PublicBar\",\n-                kind: Struct,\n-            },\n-        ]\n-        \"###\n+    fn filters_visibility() {\n+        check(\n+            r#\"\n+use self::my::<|>;\n+\n+mod my {\n+    struct Bar;\n+    pub struct Foo;\n+    pub use Bar as PublicBar;\n+}\n+\"#,\n+            expect![[r#\"\n+                st Foo\n+                st PublicBar\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_use_item_starting_with_self() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                use self::m::<|>;\n+        check(\n+            r#\"\n+use self::m::<|>;\n \n-                mod m {\n-                    pub struct Bar;\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Bar\",\n-                source_range: 13..13,\n-                delete: 13..13,\n-                insert: \"Bar\",\n-                kind: Struct,\n-            },\n-        ]\n-        \"###\n+mod m { pub struct Bar; }\n+\"#,\n+            expect![[r#\"\n+                st Bar\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_use_item_starting_with_crate() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                mod foo;\n-                struct Spam;\n-                //- /foo.rs\n-                use crate::Sp<|>\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Spam\",\n-                source_range: 11..13,\n-                delete: 11..13,\n-                insert: \"Spam\",\n-                kind: Struct,\n-            },\n-            CompletionItem {\n-                label: \"foo\",\n-                source_range: 11..13,\n-                delete: 11..13,\n-                insert: \"foo\",\n-                kind: Module,\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+struct Spam;\n+//- /foo.rs\n+use crate::Sp<|>\n+\"#,\n+            expect![[r#\"\n+                st Spam\n+                md foo\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_nested_use_tree() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                mod foo;\n-                struct Spam;\n-                //- /foo.rs\n-                use crate::{Sp<|>};\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Spam\",\n-                source_range: 12..14,\n-                delete: 12..14,\n-                insert: \"Spam\",\n-                kind: Struct,\n-            },\n-            CompletionItem {\n-                label: \"foo\",\n-                source_range: 12..14,\n-                delete: 12..14,\n-                insert: \"foo\",\n-                kind: Module,\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+struct Spam;\n+//- /foo.rs\n+use crate::{Sp<|>};\n+\"#,\n+            expect![[r#\"\n+                st Spam\n+                md foo\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_deeply_nested_use_tree() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                mod foo;\n-                pub mod bar {\n-                    pub mod baz {\n-                        pub struct Spam;\n-                    }\n-                }\n-                //- /foo.rs\n-                use crate::{bar::{baz::Sp<|>}};\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Spam\",\n-                source_range: 23..25,\n-                delete: 23..25,\n-                insert: \"Spam\",\n-                kind: Struct,\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                /// An enum\n-                enum E {\n-                    /// Foo Variant\n-                    Foo,\n-                    /// Bar Variant with i32\n-                    Bar(i32)\n-                }\n-                fn foo() { let _ = E::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Bar(\u2026)\",\n-                source_range: 116..116,\n-                delete: 116..116,\n-                insert: \"Bar($0)\",\n-                kind: EnumVariant,\n-                lookup: \"Bar\",\n-                detail: \"(i32)\",\n-                documentation: Documentation(\n-                    \"Bar Variant with i32\",\n-                ),\n-                trigger_call_info: true,\n-            },\n-            CompletionItem {\n-                label: \"Foo\",\n-                source_range: 116..116,\n-                delete: 116..116,\n-                insert: \"Foo\",\n-                kind: EnumVariant,\n-                detail: \"()\",\n-                documentation: Documentation(\n-                    \"Foo Variant\",\n-                ),\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_with_details() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                struct S { field: u32 }\n-                /// An enum\n-                enum E {\n-                    /// Foo Variant (empty)\n-                    Foo,\n-                    /// Bar Variant with i32 and u32\n-                    Bar(i32, u32),\n-                    ///\n-                    S(S),\n-                }\n-                fn foo() { let _ = E::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Bar(\u2026)\",\n-                source_range: 180..180,\n-                delete: 180..180,\n-                insert: \"Bar($0)\",\n-                kind: EnumVariant,\n-                lookup: \"Bar\",\n-                detail: \"(i32, u32)\",\n-                documentation: Documentation(\n-                    \"Bar Variant with i32 and u32\",\n-                ),\n-                trigger_call_info: true,\n-            },\n-            CompletionItem {\n-                label: \"Foo\",\n-                source_range: 180..180,\n-                delete: 180..180,\n-                insert: \"Foo\",\n-                kind: EnumVariant,\n-                detail: \"()\",\n-                documentation: Documentation(\n-                    \"Foo Variant (empty)\",\n-                ),\n-            },\n-            CompletionItem {\n-                label: \"S(\u2026)\",\n-                source_range: 180..180,\n-                delete: 180..180,\n-                insert: \"S($0)\",\n-                kind: EnumVariant,\n-                lookup: \"S\",\n-                detail: \"(S)\",\n-                documentation: Documentation(\n-                    \"\",\n-                ),\n-                trigger_call_info: true,\n-            },\n-        ]\n-        \"###\n-        );\n+        check(\n+            r#\"\n+//- /lib.rs\n+mod foo;\n+pub mod bar {\n+    pub mod baz {\n+        pub struct Spam;\n     }\n-\n-    #[test]\n-    fn completes_struct_associated_method() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                /// A Struct\n-                struct S;\n-\n-                impl S {\n-                    /// An associated method\n-                    fn m() { }\n-                }\n-\n-                fn foo() { let _ = S::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"m()\",\n-                source_range: 102..102,\n-                delete: 102..102,\n-                insert: \"m()$0\",\n-                kind: Function,\n-                lookup: \"m\",\n-                detail: \"fn m()\",\n-                documentation: Documentation(\n-                    \"An associated method\",\n-                ),\n-            },\n-        ]\n-        \"###\n+}\n+//- /foo.rs\n+use crate::{bar::{baz::Sp<|>}};\n+\"#,\n+            expect![[r#\"\n+                st Spam\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn completes_struct_associated_method_with_self() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                /// A Struct\n-                struct S;\n-\n-                impl S {\n-                    /// An associated method\n-                    fn m(&self) { }\n-                }\n-\n-                fn foo() { let _ = S::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"m()\",\n-                source_range: 107..107,\n-                delete: 107..107,\n-                insert: \"m()$0\",\n-                kind: Method,\n-                lookup: \"m\",\n-                detail: \"fn m(&self)\",\n-                documentation: Documentation(\n-                    \"An associated method\",\n-                ),\n-            },\n-        ]\n-        \"###\n+    fn completes_enum_variant() {\n+        check(\n+            r#\"\n+enum E { Foo, Bar(i32) }\n+fn foo() { let _ = E::<|> }\n+\"#,\n+            expect![[r#\"\n+                ev Bar(\u2026) (i32)\n+                ev Foo ()\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn completes_struct_associated_const() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                /// A Struct\n-                struct S;\n-\n-                impl S {\n-                    /// An associated const\n-                    const C: i32 = 42;\n-                }\n+    fn completes_struct_associated_items() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+struct S;\n+\n+impl S {\n+    fn a() {}\n+    fn b(&self) {}\n+    const C: i32 = 42;\n+    type T = i32;\n+}\n \n-                fn foo() { let _ = S::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"C\",\n-                source_range: 109..109,\n-                delete: 109..109,\n-                insert: \"C\",\n-                kind: Const,\n-                detail: \"const C: i32 = 42;\",\n-                documentation: Documentation(\n-                    \"An associated const\",\n-                ),\n-            },\n-        ]\n-        \"###\n+fn foo() { let _ = S::<|> }\n+\"#,\n+            expect![[r#\"\n+                ct C const C: i32 = 42;\n+                ta T type T = i32;\n+                fn a() fn a()\n+                me b() fn b(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn completes_struct_associated_type() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                /// A Struct\n-                struct S;\n-\n-                impl S {\n-                    /// An associated type\n-                    type T = i32;\n-                }\n+    fn associated_item_visibility() {\n+        check(\n+            r#\"\n+struct S;\n \n-                fn foo() { let _ = S::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"T\",\n-                source_range: 103..103,\n-                delete: 103..103,\n-                insert: \"T\",\n-                kind: TypeAlias,\n-                detail: \"type T = i32;\",\n-                documentation: Documentation(\n-                    \"An associated type\",\n-                ),\n-            },\n-        ]\n-        \"###\n-        );\n+mod m {\n+    impl super::S {\n+        pub(super) fn public_method() { }\n+        fn private_method() { }\n+        pub(super) type PublicType = u32;\n+        type PrivateType = u32;\n+        pub(super) const PUBLIC_CONST: u32 = 1;\n+        const PRIVATE_CONST: u32 = 1;\n     }\n+}\n \n-    #[test]\n-    fn associated_item_visibility() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                struct S;\n-\n-                mod m {\n-                    impl super::S {\n-                        pub(super) fn public_method() { }\n-                        fn private_method() { }\n-                        pub(super) type PublicType = u32;\n-                        type PrivateType = u32;\n-                        pub(super) const PUBLIC_CONST: u32 = 1;\n-                        const PRIVATE_CONST: u32 = 1;\n-                    }\n-                }\n-\n-                fn foo() { let _ = S::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"PUBLIC_CONST\",\n-                source_range: 304..304,\n-                delete: 304..304,\n-                insert: \"PUBLIC_CONST\",\n-                kind: Const,\n-                detail: \"pub(super) const PUBLIC_CONST: u32 = 1;\",\n-            },\n-            CompletionItem {\n-                label: \"PublicType\",\n-                source_range: 304..304,\n-                delete: 304..304,\n-                insert: \"PublicType\",\n-                kind: TypeAlias,\n-                detail: \"pub(super) type PublicType = u32;\",\n-            },\n-            CompletionItem {\n-                label: \"public_method()\",\n-                source_range: 304..304,\n-                delete: 304..304,\n-                insert: \"public_method()$0\",\n-                kind: Function,\n-                lookup: \"public_method\",\n-                detail: \"pub(super) fn public_method()\",\n-            },\n-        ]\n-        \"###\n+fn foo() { let _ = S::<|> }\n+\"#,\n+            expect![[r#\"\n+                ct PUBLIC_CONST pub(super) const PUBLIC_CONST: u32 = 1;\n+                ta PublicType pub(super) type PublicType = u32;\n+                fn public_method() pub(super) fn public_method()\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_enum_associated_method() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                /// An enum\n-                enum S {};\n-\n-                impl S {\n-                    /// An associated method\n-                    fn m() { }\n-                }\n-\n-                fn foo() { let _ = S::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"m()\",\n-                source_range: 102..102,\n-                delete: 102..102,\n-                insert: \"m()$0\",\n-                kind: Function,\n-                lookup: \"m\",\n-                detail: \"fn m()\",\n-                documentation: Documentation(\n-                    \"An associated method\",\n-                ),\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+enum E {};\n+impl E { fn m() { } }\n+\n+fn foo() { let _ = E::<|> }\n+        \"#,\n+            expect![[r#\"\n+                fn m() fn m()\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_union_associated_method() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                /// A union\n-                union U {};\n-\n-                impl U {\n-                    /// An associated method\n-                    fn m() { }\n-                }\n-\n-                fn foo() { let _ = U::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"m()\",\n-                source_range: 103..103,\n-                delete: 103..103,\n-                insert: \"m()$0\",\n-                kind: Function,\n-                lookup: \"m\",\n-                detail: \"fn m()\",\n-                documentation: Documentation(\n-                    \"An associated method\",\n-                ),\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+union U {};\n+impl U { fn m() { } }\n+\n+fn foo() { let _ = U::<|> }\n+\"#,\n+            expect![[r#\"\n+                fn m() fn m()\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_use_paths_across_crates() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /main.rs\n-                use foo::<|>;\n-\n-                //- /foo/lib.rs\n-                pub mod bar {\n-                    pub struct S;\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"bar\",\n-                source_range: 9..9,\n-                delete: 9..9,\n-                insert: \"bar\",\n-                kind: Module,\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+//- /main.rs\n+use foo::<|>;\n+\n+//- /foo/lib.rs\n+pub mod bar { pub struct S; }\n+\"#,\n+            expect![[r#\"\n+                md bar\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_trait_associated_method_1() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                trait Trait {\n-                  /// A trait method\n-                  fn m();\n-                }\n+        check(\n+            r#\"\n+trait Trait { fn m(); }\n \n-                fn foo() { let _ = Trait::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"m()\",\n-                source_range: 74..74,\n-                delete: 74..74,\n-                insert: \"m()$0\",\n-                kind: Function,\n-                lookup: \"m\",\n-                detail: \"fn m()\",\n-                documentation: Documentation(\n-                    \"A trait method\",\n-                ),\n-            },\n-        ]\n-        \"###\n+fn foo() { let _ = Trait::<|> }\n+\"#,\n+            expect![[r#\"\n+                fn m() fn m()\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_trait_associated_method_2() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                trait Trait {\n-                  /// A trait method\n-                  fn m();\n-                }\n+        check(\n+            r#\"\n+trait Trait { fn m(); }\n+\n+struct S;\n+impl Trait for S {}\n \n-                struct S;\n-                impl Trait for S {}\n-\n-                fn foo() { let _ = S::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"m()\",\n-                source_range: 101..101,\n-                delete: 101..101,\n-                insert: \"m()$0\",\n-                kind: Function,\n-                lookup: \"m\",\n-                detail: \"fn m()\",\n-                documentation: Documentation(\n-                    \"A trait method\",\n-                ),\n-            },\n-        ]\n-        \"###\n+fn foo() { let _ = S::<|> }\n+\"#,\n+            expect![[r#\"\n+                fn m() fn m()\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_trait_associated_method_3() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                trait Trait {\n-                  /// A trait method\n-                  fn m();\n-                }\n+        check(\n+            r#\"\n+trait Trait { fn m(); }\n \n-                struct S;\n-                impl Trait for S {}\n-\n-                fn foo() { let _ = <S as Trait>::<|> }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"m()\",\n-                source_range: 112..112,\n-                delete: 112..112,\n-                insert: \"m()$0\",\n-                kind: Function,\n-                lookup: \"m\",\n-                detail: \"fn m()\",\n-                documentation: Documentation(\n-                    \"A trait method\",\n-                ),\n-            },\n-        ]\n-        \"###\n+struct S;\n+impl Trait for S {}\n+\n+fn foo() { let _ = <S as Trait>::<|> }\n+\"#,\n+            expect![[r#\"\n+                fn m() fn m()\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_ty_param_assoc_ty() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                trait Super {\n-                    type Ty;\n-                    const CONST: u8;\n-                    fn func() {}\n-                    fn method(&self) {}\n-                }\n+        check(\n+            r#\"\n+trait Super {\n+    type Ty;\n+    const CONST: u8;\n+    fn func() {}\n+    fn method(&self) {}\n+}\n \n-                trait Sub: Super {\n-                    type SubTy;\n-                    const C2: ();\n-                    fn subfunc() {}\n-                    fn submethod(&self) {}\n-                }\n+trait Sub: Super {\n+    type SubTy;\n+    const C2: ();\n+    fn subfunc() {}\n+    fn submethod(&self) {}\n+}\n \n-                fn foo<T: Sub>() {\n-                    T::<|>\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"C2\",\n-                source_range: 221..221,\n-                delete: 221..221,\n-                insert: \"C2\",\n-                kind: Const,\n-                detail: \"const C2: ();\",\n-            },\n-            CompletionItem {\n-                label: \"CONST\",\n-                source_range: 221..221,\n-                delete: 221..221,\n-                insert: \"CONST\",\n-                kind: Const,\n-                detail: \"const CONST: u8;\",\n-            },\n-            CompletionItem {\n-                label: \"SubTy\",\n-                source_range: 221..221,\n-                delete: 221..221,\n-                insert: \"SubTy\",\n-                kind: TypeAlias,\n-                detail: \"type SubTy;\",\n-            },\n-            CompletionItem {\n-                label: \"Ty\",\n-                source_range: 221..221,\n-                delete: 221..221,\n-                insert: \"Ty\",\n-                kind: TypeAlias,\n-                detail: \"type Ty;\",\n-            },\n-            CompletionItem {\n-                label: \"func()\",\n-                source_range: 221..221,\n-                delete: 221..221,\n-                insert: \"func()$0\",\n-                kind: Function,\n-                lookup: \"func\",\n-                detail: \"fn func()\",\n-            },\n-            CompletionItem {\n-                label: \"method()\",\n-                source_range: 221..221,\n-                delete: 221..221,\n-                insert: \"method()$0\",\n-                kind: Method,\n-                lookup: \"method\",\n-                detail: \"fn method(&self)\",\n-            },\n-            CompletionItem {\n-                label: \"subfunc()\",\n-                source_range: 221..221,\n-                delete: 221..221,\n-                insert: \"subfunc()$0\",\n-                kind: Function,\n-                lookup: \"subfunc\",\n-                detail: \"fn subfunc()\",\n-            },\n-            CompletionItem {\n-                label: \"submethod()\",\n-                source_range: 221..221,\n-                delete: 221..221,\n-                insert: \"submethod()$0\",\n-                kind: Method,\n-                lookup: \"submethod\",\n-                detail: \"fn submethod(&self)\",\n-            },\n-        ]\n-        \"###\n+fn foo<T: Sub>() { T::<|> }\n+\"#,\n+            expect![[r#\"\n+                ct C2 const C2: ();\n+                ct CONST const CONST: u8;\n+                ta SubTy type SubTy;\n+                ta Ty type Ty;\n+                fn func() fn func()\n+                me method() fn method(&self)\n+                fn subfunc() fn subfunc()\n+                me submethod() fn submethod(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_self_param_assoc_ty() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                //- /lib.rs\n-                trait Super {\n-                    type Ty;\n-                    const CONST: u8 = 0;\n-                    fn func() {}\n-                    fn method(&self) {}\n-                }\n+        check(\n+            r#\"\n+trait Super {\n+    type Ty;\n+    const CONST: u8 = 0;\n+    fn func() {}\n+    fn method(&self) {}\n+}\n \n-                trait Sub: Super {\n-                    type SubTy;\n-                    const C2: () = ();\n-                    fn subfunc() {}\n-                    fn submethod(&self) {}\n-                }\n+trait Sub: Super {\n+    type SubTy;\n+    const C2: () = ();\n+    fn subfunc() {}\n+    fn submethod(&self) {}\n+}\n \n-                struct Wrap<T>(T);\n-                impl<T> Super for Wrap<T> {}\n-                impl<T> Sub for Wrap<T> {\n-                    fn subfunc() {\n-                        // Should be able to assume `Self: Sub + Super`\n-                        Self::<|>\n-                    }\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"C2\",\n-                source_range: 367..367,\n-                delete: 367..367,\n-                insert: \"C2\",\n-                kind: Const,\n-                detail: \"const C2: () = ();\",\n-            },\n-            CompletionItem {\n-                label: \"CONST\",\n-                source_range: 367..367,\n-                delete: 367..367,\n-                insert: \"CONST\",\n-                kind: Const,\n-                detail: \"const CONST: u8 = 0;\",\n-            },\n-            CompletionItem {\n-                label: \"SubTy\",\n-                source_range: 367..367,\n-                delete: 367..367,\n-                insert: \"SubTy\",\n-                kind: TypeAlias,\n-                detail: \"type SubTy;\",\n-            },\n-            CompletionItem {\n-                label: \"Ty\",\n-                source_range: 367..367,\n-                delete: 367..367,\n-                insert: \"Ty\",\n-                kind: TypeAlias,\n-                detail: \"type Ty;\",\n-            },\n-            CompletionItem {\n-                label: \"func()\",\n-                source_range: 367..367,\n-                delete: 367..367,\n-                insert: \"func()$0\",\n-                kind: Function,\n-                lookup: \"func\",\n-                detail: \"fn func()\",\n-            },\n-            CompletionItem {\n-                label: \"method()\",\n-                source_range: 367..367,\n-                delete: 367..367,\n-                insert: \"method()$0\",\n-                kind: Method,\n-                lookup: \"method\",\n-                detail: \"fn method(&self)\",\n-            },\n-            CompletionItem {\n-                label: \"subfunc()\",\n-                source_range: 367..367,\n-                delete: 367..367,\n-                insert: \"subfunc()$0\",\n-                kind: Function,\n-                lookup: \"subfunc\",\n-                detail: \"fn subfunc()\",\n-            },\n-            CompletionItem {\n-                label: \"submethod()\",\n-                source_range: 367..367,\n-                delete: 367..367,\n-                insert: \"submethod()$0\",\n-                kind: Method,\n-                lookup: \"submethod\",\n-                detail: \"fn submethod(&self)\",\n-            },\n-        ]\n-        \"###\n+struct Wrap<T>(T);\n+impl<T> Super for Wrap<T> {}\n+impl<T> Sub for Wrap<T> {\n+    fn subfunc() {\n+        // Should be able to assume `Self: Sub + Super`\n+        Self::<|>\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                ct C2 const C2: () = ();\n+                ct CONST const CONST: u8 = 0;\n+                ta SubTy type SubTy;\n+                ta Ty type Ty;\n+                fn func() fn func()\n+                me method() fn method(&self)\n+                fn subfunc() fn subfunc()\n+                me submethod() fn submethod(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_type_alias() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                struct S;\n-                impl S { fn foo() {} }\n-                type T = S;\n-                impl T { fn bar() {} }\n-\n-                fn main() {\n-                    T::<|>;\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"bar()\",\n-                source_range: 88..88,\n-                delete: 88..88,\n-                insert: \"bar()$0\",\n-                kind: Function,\n-                lookup: \"bar\",\n-                detail: \"fn bar()\",\n-            },\n-            CompletionItem {\n-                label: \"foo()\",\n-                source_range: 88..88,\n-                delete: 88..88,\n-                insert: \"foo()$0\",\n-                kind: Function,\n-                lookup: \"foo\",\n-                detail: \"fn foo()\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+struct S;\n+impl S { fn foo() {} }\n+type T = S;\n+impl T { fn bar() {} }\n+\n+fn main() { T::<|>; }\n+\"#,\n+            expect![[r#\"\n+                fn bar() fn bar()\n+                fn foo() fn foo()\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_qualified_macros() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                \"\n-                #[macro_export]\n-                macro_rules! foo {\n-                    () => {}\n-                }\n-\n-                fn main() {\n-                    let _ = crate::<|>\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo!(\u2026)\",\n-                source_range: 82..82,\n-                delete: 82..82,\n-                insert: \"foo!($0)\",\n-                kind: Macro,\n-                lookup: \"foo!\",\n-                detail: \"#[macro_export]\\nmacro_rules! foo\",\n-            },\n-            CompletionItem {\n-                label: \"main()\",\n-                source_range: 82..82,\n-                delete: 82..82,\n-                insert: \"main()$0\",\n-                kind: Function,\n-                lookup: \"main\",\n-                detail: \"fn main()\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+#[macro_export]\n+macro_rules! foo { () => {} }\n+\n+fn main() { let _ = crate::<|> }\n+        \"#,\n+            expect![[r##\"\n+                ma foo!(\u2026) #[macro_export]\n+                macro_rules! foo\n+                fn main() fn main()\n+            \"##]],\n         );\n     }\n \n     #[test]\n     fn test_super_super_completion() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                mod a {\n-                    const A: usize = 0;\n-\n-                    mod b {\n-                        const B: usize = 0;\n-\n-                        mod c {\n-                            use super::super::<|>\n-                        }\n-                    }\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"A\",\n-                source_range: 120..120,\n-                delete: 120..120,\n-                insert: \"A\",\n-                kind: Const,\n-            },\n-            CompletionItem {\n-                label: \"b\",\n-                source_range: 120..120,\n-                delete: 120..120,\n-                insert: \"b\",\n-                kind: Module,\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+mod a {\n+    const A: usize = 0;\n+    mod b {\n+        const B: usize = 0;\n+        mod c { use super::super::<|> }\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                ct A\n+                md b\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_reexported_items_under_correct_name() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                fn foo() {\n-                    self::m::<|>\n-                }\n+        check(\n+            r#\"\n+fn foo() { self::m::<|> }\n \n-                mod m {\n-                    pub use super::p::wrong_fn as right_fn;\n-                    pub use super::p::WRONG_CONST as RIGHT_CONST;\n-                    pub use super::p::WrongType as RightType;\n-                }\n-                mod p {\n-                    fn wrong_fn() {}\n-                    const WRONG_CONST: u32 = 1;\n-                    struct WrongType {};\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"RIGHT_CONST\",\n-                source_range: 24..24,\n-                delete: 24..24,\n-                insert: \"RIGHT_CONST\",\n-                kind: Const,\n-            },\n-            CompletionItem {\n-                label: \"RightType\",\n-                source_range: 24..24,\n-                delete: 24..24,\n-                insert: \"RightType\",\n-                kind: Struct,\n-            },\n-            CompletionItem {\n-                label: \"right_fn()\",\n-                source_range: 24..24,\n-                delete: 24..24,\n-                insert: \"right_fn()$0\",\n-                kind: Function,\n-                lookup: \"right_fn\",\n-                detail: \"fn wrong_fn()\",\n-            },\n-        ]\n-        \"###\n+mod m {\n+    pub use super::p::wrong_fn as right_fn;\n+    pub use super::p::WRONG_CONST as RIGHT_CONST;\n+    pub use super::p::WrongType as RightType;\n+}\n+mod p {\n+    fn wrong_fn() {}\n+    const WRONG_CONST: u32 = 1;\n+    struct WrongType {};\n+}\n+\"#,\n+            expect![[r#\"\n+                ct RIGHT_CONST\n+                st RightType\n+                fn right_fn() fn wrong_fn()\n+            \"#]],\n+        );\n+\n+        check_edit(\n+            \"RightType\",\n+            r#\"\n+fn foo() { self::m::<|> }\n+\n+mod m {\n+    pub use super::p::wrong_fn as right_fn;\n+    pub use super::p::WRONG_CONST as RIGHT_CONST;\n+    pub use super::p::WrongType as RightType;\n+}\n+mod p {\n+    fn wrong_fn() {}\n+    const WRONG_CONST: u32 = 1;\n+    struct WrongType {};\n+}\n+\"#,\n+            r#\"\n+fn foo() { self::m::RightType }\n+\n+mod m {\n+    pub use super::p::wrong_fn as right_fn;\n+    pub use super::p::WRONG_CONST as RIGHT_CONST;\n+    pub use super::p::WrongType as RightType;\n+}\n+mod p {\n+    fn wrong_fn() {}\n+    const WRONG_CONST: u32 = 1;\n+    struct WrongType {};\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn completes_in_simple_macro_call() {\n-        let completions = do_reference_completion(\n+        check(\n             r#\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                fn main() { m!(self::f<|>); }\n-                fn foo() {}\n-            \"#,\n+macro_rules! m { ($e:expr) => { $e } }\n+fn main() { m!(self::f<|>); }\n+fn foo() {}\n+\"#,\n+            expect![[r#\"\n+                fn foo() fn foo()\n+                fn main() fn main()\n+            \"#]],\n         );\n-        assert_debug_snapshot!(completions, @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo()\",\n-                source_range: 60..61,\n-                delete: 60..61,\n-                insert: \"foo()$0\",\n-                kind: Function,\n-                lookup: \"foo\",\n-                detail: \"fn foo()\",\n-            },\n-            CompletionItem {\n-                label: \"main()\",\n-                source_range: 60..61,\n-                delete: 60..61,\n-                insert: \"main()$0\",\n-                kind: Function,\n-                lookup: \"main\",\n-                detail: \"fn main()\",\n-            },\n-        ]\n-        \"###);\n     }\n \n     #[test]\n     fn function_mod_share_name() {\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n-                r\"\n-                fn foo() {\n-                    self::m::<|>\n-                }\n+        check(\n+            r#\"\n+fn foo() { self::m::<|> }\n \n-                mod m {\n-                    pub mod z {}\n-                    pub fn z() {}\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"z\",\n-                source_range: 24..24,\n-                delete: 24..24,\n-                insert: \"z\",\n-                kind: Module,\n-            },\n-            CompletionItem {\n-                label: \"z()\",\n-                source_range: 24..24,\n-                delete: 24..24,\n-                insert: \"z()$0\",\n-                kind: Function,\n-                lookup: \"z\",\n-                detail: \"pub fn z()\",\n-            },\n-        ]\n-        \"###\n+mod m {\n+    pub mod z {}\n+    pub fn z() {}\n+}\n+\"#,\n+            expect![[r#\"\n+                md z\n+                fn z() pub fn z()\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_hashmap_new() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                struct RandomState;\n-                struct HashMap<K, V, S = RandomState> {}\n-\n-                impl<K, V> HashMap<K, V, RandomState> {\n-                    pub fn new() -> HashMap<K, V, RandomState> { }\n-                }\n-                fn foo() {\n-                    HashMap::<|>\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"new()\",\n-                source_range: 179..179,\n-                delete: 179..179,\n-                insert: \"new()$0\",\n-                kind: Function,\n-                lookup: \"new\",\n-                detail: \"pub fn new() -> HashMap<K, V, RandomState>\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+struct RandomState;\n+struct HashMap<K, V, S = RandomState> {}\n+\n+impl<K, V> HashMap<K, V, RandomState> {\n+    pub fn new() -> HashMap<K, V, RandomState> { }\n+}\n+fn foo() {\n+    HashMap::<|>\n+}\n+\"#,\n+            expect![[r#\"\n+                fn new() pub fn new() -> HashMap<K, V, RandomState>\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn dont_complete_attr() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                mod foo { pub struct Foo; }\n-                #[foo::<|>]\n-                fn f() {}\n-                \"\n-            ),\n-            @r###\"[]\"###\n-        )\n+        check(\n+            r#\"\n+mod foo { pub struct Foo; }\n+#[foo::<|>]\n+fn f() {}\n+\"#,\n+            expect![[\"\"]],\n+        );\n     }\n }"}, {"sha": "bfa7e08be1a522aa09ec18000069420bd5811c40", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c14a3b4a20583acae6f636005998d64dd6bdec75/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14a3b4a20583acae6f636005998d64dd6bdec75/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=c14a3b4a20583acae6f636005998d64dd6bdec75", "patch": "@@ -683,6 +683,57 @@ impl S {\n                     },\n                 ]\n             \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+use self::my<|>;\n+\n+/// mod docs\n+mod my { }\n+\n+/// enum docs\n+enum E {\n+    /// variant docs\n+    V\n+}\n+use self::E::*;\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"E\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"E\",\n+                        kind: Enum,\n+                        documentation: Documentation(\n+                            \"enum docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"V\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"V\",\n+                        kind: EnumVariant,\n+                        detail: \"()\",\n+                        documentation: Documentation(\n+                            \"variant docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"my\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"my\",\n+                        kind: Module,\n+                        documentation: Documentation(\n+                            \"mod docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n         )\n     }\n "}]}