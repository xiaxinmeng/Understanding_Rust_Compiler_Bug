{"sha": "bdd2439529c23b4fcd2676d7427c45ca223385ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZDI0Mzk1MjljMjNiNGZjZDI2NzZkNzQyN2M0NWNhMjIzMzg1Y2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-06T05:00:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-06T05:00:50Z"}, "message": "auto merge of #5733 : dbaupp/rust/std-complex-rational, r=thestinger\n\nThis adds two generic data types, `Ratio` and `Cmplx` (and some aliases for useful instances, e.g. `Ratio<int>` and `Cmplx<f64>`), and basic arithmetic support, as well as `.to_str` (for both) and `.from_str` (for rational).\r\n\r\nThe complex number implementation doesn't solve #1284 other than getting something into the libraries, specifically it doesn't even try to address C interop. If the complex part of this gets merged, maybe it's worth closing that issue and reopening more specific issue(s) about the failings.\r\n\r\nThe implementations can be fleshed out when the numeric traits stabilise (and trait inheritance works).", "tree": {"sha": "b722a99b095de611361906d112ffa5b8d9c71fc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b722a99b095de611361906d112ffa5b8d9c71fc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdd2439529c23b4fcd2676d7427c45ca223385ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd2439529c23b4fcd2676d7427c45ca223385ce", "html_url": "https://github.com/rust-lang/rust/commit/bdd2439529c23b4fcd2676d7427c45ca223385ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdd2439529c23b4fcd2676d7427c45ca223385ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f678d63507a779d81810c342dd1bdc828fb983ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/f678d63507a779d81810c342dd1bdc828fb983ba", "html_url": "https://github.com/rust-lang/rust/commit/f678d63507a779d81810c342dd1bdc828fb983ba"}, {"sha": "c6949b3669d23a1694b964108f21d5200c985cb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6949b3669d23a1694b964108f21d5200c985cb5", "html_url": "https://github.com/rust-lang/rust/commit/c6949b3669d23a1694b964108f21d5200c985cb5"}], "stats": {"total": 831, "additions": 831, "deletions": 0}, "files": [{"sha": "35b1a28a465cd535dd429c6bf99246f9523f0224", "filename": "src/libstd/num/bigint.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bdd2439529c23b4fcd2676d7427c45ca223385ce/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd2439529c23b4fcd2676d7427c45ca223385ce/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=bdd2439529c23b4fcd2676d7427c45ca223385ce", "previous_filename": "src/libstd/bigint.rs"}, {"sha": "1e8fc0e6c2baad7e8a23bd867e3a4518c77b5b36", "filename": "src/libstd/num/complex.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/bdd2439529c23b4fcd2676d7427c45ca223385ce/src%2Flibstd%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd2439529c23b4fcd2676d7427c45ca223385ce/src%2Flibstd%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcomplex.rs?ref=bdd2439529c23b4fcd2676d7427c45ca223385ce", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//! Complex numbers.\n+\n+use core::num::{Zero,One,ToStrRadix};\n+use core::prelude::*;\n+\n+// FIXME #1284: handle complex NaN & infinity etc. This\n+// probably doesn't map to C's _Complex correctly.\n+\n+// FIXME #5734:: Need generic sin/cos for .to/from_polar().\n+// FIXME #5735: Need generic sqrt to implement .norm().\n+\n+\n+/// A complex number in Cartesian form.\n+#[deriving(Eq,Clone)]\n+pub struct Cmplx<T> {\n+    re: T,\n+    im: T\n+}\n+\n+pub type Complex = Cmplx<float>;\n+pub type Complex32 = Cmplx<f32>;\n+pub type Complex64 = Cmplx<f64>;\n+\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Cmplx<T> {\n+    /// Create a new Cmplx\n+    #[inline]\n+    pub fn new(re: T, im: T) -> Cmplx<T> {\n+        Cmplx { re: re, im: im }\n+    }\n+\n+    /**\n+    Returns the square of the norm (since `T` doesn't necessarily\n+    have a sqrt function), i.e. `re^2 + im^2`.\n+    */\n+    #[inline]\n+    pub fn norm_sqr(&self) -> T {\n+        self.re * self.re + self.im * self.im\n+    }\n+\n+\n+    /// Returns the complex conjugate. i.e. `re - i im`\n+    #[inline]\n+    pub fn conj(&self) -> Cmplx<T> {\n+        Cmplx::new(self.re, -self.im)\n+    }\n+\n+\n+    /// Multiplies `self` by the scalar `t`.\n+    #[inline]\n+    pub fn scale(&self, t: T) -> Cmplx<T> {\n+        Cmplx::new(self.re * t, self.im * t)\n+    }\n+\n+    /// Divides `self` by the scalar `t`.\n+    #[inline]\n+    pub fn unscale(&self, t: T) -> Cmplx<T> {\n+        Cmplx::new(self.re / t, self.im / t)\n+    }\n+\n+    /// Returns `1/self`\n+    #[inline]\n+    pub fn inv(&self) -> Cmplx<T> {\n+        let norm_sqr = self.norm_sqr();\n+        Cmplx::new(self.re / norm_sqr,\n+                    -self.im / norm_sqr)\n+    }\n+}\n+\n+/* arithmetic */\n+// (a + i b) + (c + i d) == (a + c) + i (b + d)\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn add(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+        Cmplx::new(self.re + other.re, self.im + other.im)\n+    }\n+}\n+// (a + i b) - (c + i d) == (a - c) + i (b - d)\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn sub(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+        Cmplx::new(self.re - other.re, self.im - other.im)\n+    }\n+}\n+// (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn mul(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+        Cmplx::new(self.re*other.re - self.im*other.im,\n+                     self.re*other.im + self.im*other.re)\n+    }\n+}\n+\n+// (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n+//   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+        let norm_sqr = other.norm_sqr();\n+        Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n+                     (self.im*other.re - self.re*other.im) / norm_sqr)\n+    }\n+}\n+\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Neg<Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn neg(&self) -> Cmplx<T> {\n+        Cmplx::new(-self.re, -self.im)\n+    }\n+}\n+\n+/* constants */\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T> + Zero>\n+    Zero for Cmplx<T> {\n+    #[inline]\n+    fn zero() -> Cmplx<T> {\n+        Cmplx::new(Zero::zero(), Zero::zero())\n+    }\n+}\n+\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T> + Zero + One>\n+    One for Cmplx<T> {\n+    #[inline]\n+    fn one() -> Cmplx<T> {\n+        Cmplx::new(One::one(), Zero::zero())\n+    }\n+}\n+\n+/* string conversions */\n+impl<T: ToStr + Zero + Ord + Neg<T>> ToStr for Cmplx<T> {\n+    fn to_str(&self) -> ~str {\n+        if self.im < Zero::zero() {\n+            fmt!(\"%s-%si\", self.re.to_str(), (-self.im).to_str())\n+        } else {\n+            fmt!(\"%s+%si\", self.re.to_str(), self.im.to_str())\n+        }\n+    }\n+}\n+\n+impl<T: ToStrRadix + Zero + Ord + Neg<T>> ToStrRadix for Cmplx<T> {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n+        if self.im < Zero::zero() {\n+            fmt!(\"%s-%si\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n+        } else {\n+            fmt!(\"%s+%si\", self.re.to_str_radix(radix), self.im.to_str_radix(radix))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use core::prelude::*;\n+    use super::*;\n+    use core::num::{Zero,One};\n+\n+    pub static _0_0i : Complex = Cmplx { re: 0f, im: 0f };\n+    pub static _1_0i : Complex = Cmplx { re: 1f, im: 0f };\n+    pub static _1_1i : Complex = Cmplx { re: 1f, im: 1f };\n+    pub static _0_1i : Complex = Cmplx { re: 0f, im: 1f };\n+    pub static _neg1_1i : Complex = Cmplx { re: -1f, im: 1f };\n+    pub static _05_05i : Complex = Cmplx { re: 0.5f, im: 0.5f };\n+    pub static all_consts : [Complex, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n+\n+    #[test]\n+    fn test_consts() {\n+        // check our constants are what Cmplx::new creates\n+        fn test(c : Complex, r : float, i: float) {\n+            assert_eq!(c, Cmplx::new(r,i));\n+        }\n+        test(_0_0i, 0f, 0f);\n+        test(_1_0i, 1f, 0f);\n+        test(_1_1i, 1f, 1f);\n+        test(_neg1_1i, -1f, 1f);\n+        test(_05_05i, 0.5f, 0.5f);\n+\n+        assert_eq!(_0_0i, Zero::zero());\n+        assert_eq!(_1_0i, One::one());\n+    }\n+\n+    #[test]\n+    fn test_norm_sqr() {\n+        fn test(c: Complex, ns: float) {\n+            assert_eq!(c.norm_sqr(), ns);\n+        }\n+        test(_0_0i, 0f);\n+        test(_1_0i, 1f);\n+        test(_1_1i, 2f);\n+        test(_neg1_1i, 2f);\n+        test(_05_05i, 0.5f);\n+    }\n+\n+    #[test]\n+    fn test_scale_unscale() {\n+        assert_eq!(_05_05i.scale(2f), _1_1i);\n+        assert_eq!(_1_1i.unscale(2f), _05_05i);\n+        for all_consts.each |&c| {\n+            assert_eq!(c.scale(2f).unscale(2f), c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_conj() {\n+        for all_consts.each |&c| {\n+            assert_eq!(c.conj(), Cmplx::new(c.re, -c.im));\n+            assert_eq!(c.conj().conj(), c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_inv() {\n+        assert_eq!(_1_1i.inv(), _05_05i.conj());\n+        assert_eq!(_1_0i.inv(), _1_0i.inv());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore]\n+    fn test_inv_zero() {\n+        // FIXME #5736: should this really fail, or just NaN?\n+        _0_0i.inv();\n+    }\n+\n+\n+    mod arith {\n+        use super::*;\n+        use super::super::*;\n+        use core::num::Zero;\n+\n+        #[test]\n+        fn test_add() {\n+            assert_eq!(_05_05i + _05_05i, _1_1i);\n+            assert_eq!(_0_1i + _1_0i, _1_1i);\n+            assert_eq!(_1_0i + _neg1_1i, _0_1i);\n+\n+            for all_consts.each |&c| {\n+                assert_eq!(_0_0i + c, c);\n+                assert_eq!(c + _0_0i, c);\n+            }\n+        }\n+\n+        #[test]\n+        fn test_sub() {\n+            assert_eq!(_05_05i - _05_05i, _0_0i);\n+            assert_eq!(_0_1i - _1_0i, _neg1_1i);\n+            assert_eq!(_0_1i - _neg1_1i, _1_0i);\n+\n+            for all_consts.each |&c| {\n+                assert_eq!(c - _0_0i, c);\n+                assert_eq!(c - c, _0_0i);\n+            }\n+        }\n+\n+        #[test]\n+        fn test_mul() {\n+            assert_eq!(_05_05i * _05_05i, _0_1i.unscale(2f));\n+            assert_eq!(_1_1i * _0_1i, _neg1_1i);\n+\n+            // i^2 & i^4\n+            assert_eq!(_0_1i * _0_1i, -_1_0i);\n+            assert_eq!(_0_1i * _0_1i * _0_1i * _0_1i, _1_0i);\n+\n+            for all_consts.each |&c| {\n+                assert_eq!(c * _1_0i, c);\n+                assert_eq!(_1_0i * c, c);\n+            }\n+        }\n+        #[test]\n+        fn test_div() {\n+            assert_eq!(_neg1_1i / _0_1i, _1_1i);\n+            for all_consts.each |&c| {\n+                if c != Zero::zero() {\n+                    assert_eq!(c / c, _1_0i);\n+                }\n+            }\n+        }\n+        #[test]\n+        fn test_neg() {\n+            assert_eq!(-_1_0i + _0_1i, _neg1_1i);\n+            assert_eq!((-_0_1i) * _0_1i, _1_0i);\n+            for all_consts.each |&c| {\n+                assert_eq!(-(-c), c);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_str() {\n+        fn test(c : Complex, s: ~str) {\n+            assert_eq!(c.to_str(), s);\n+        }\n+        test(_0_0i, ~\"0+0i\");\n+        test(_1_0i, ~\"1+0i\");\n+        test(_0_1i, ~\"0+1i\");\n+        test(_1_1i, ~\"1+1i\");\n+        test(_neg1_1i, ~\"-1+1i\");\n+        test(-_neg1_1i, ~\"1-1i\");\n+        test(_05_05i, ~\"0.5+0.5i\");\n+    }\n+}"}, {"sha": "f15b382dcd35105a11b75ae9155873ab15fce48e", "filename": "src/libstd/num/rational.rs", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/bdd2439529c23b4fcd2676d7427c45ca223385ce/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd2439529c23b4fcd2676d7427c45ca223385ce/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=bdd2439529c23b4fcd2676d7427c45ca223385ce", "patch": "@@ -0,0 +1,511 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//! Rational numbers\n+\n+use core::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n+use core::from_str::FromStr;\n+use core::to_str::ToStr;\n+use core::prelude::*;\n+use core::cmp::TotalEq;\n+use super::bigint::BigInt;\n+\n+/// Represents the ratio between 2 numbers.\n+#[deriving(Clone)]\n+pub struct Ratio<T> {\n+    numer: T,\n+    denom: T\n+}\n+\n+/// Alias for a `Ratio` of machine-sized integers.\n+pub type Rational = Ratio<int>;\n+pub type Rational32 = Ratio<i32>;\n+pub type Rational64 = Ratio<i64>;\n+\n+/// Alias for arbitrary precision rationals.\n+pub type BigRational = Ratio<BigInt>;\n+\n+impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+    Ratio<T> {\n+    /// Create a ratio representing the integer `t`.\n+    #[inline(always)]\n+    pub fn from_integer(t: T) -> Ratio<T> {\n+        Ratio::new_raw(t, One::one())\n+    }\n+\n+    /// Create a ratio without checking for `denom == 0` or reducing.\n+    #[inline(always)]\n+    pub fn new_raw(numer: T, denom: T) -> Ratio<T> {\n+        Ratio { numer: numer, denom: denom }\n+    }\n+\n+    // Create a new Ratio. Fails if `denom == 0`.\n+    #[inline(always)]\n+    pub fn new(numer: T, denom: T) -> Ratio<T> {\n+        if denom == Zero::zero() {\n+            fail!(~\"divide by 0\");\n+        }\n+        let mut ret = Ratio::new_raw(numer, denom);\n+        ret.reduce();\n+        ret\n+    }\n+\n+    /// Put self into lowest terms, with denom > 0.\n+    fn reduce(&mut self) {\n+        let mut g : T = gcd(self.numer, self.denom);\n+\n+        self.numer /= g;\n+        self.denom /= g;\n+\n+        // keep denom positive!\n+        if self.denom < Zero::zero() {\n+            self.numer = -self.numer;\n+            self.denom = -self.denom;\n+        }\n+    }\n+    /// Return a `reduce`d copy of self.\n+    fn reduced(&self) -> Ratio<T> {\n+        let mut ret = copy *self;\n+        ret.reduce();\n+        ret\n+    }\n+}\n+\n+/**\n+Compute the greatest common divisor of two numbers, via Euclid's algorithm.\n+\n+The result can be negative.\n+*/\n+#[inline]\n+pub fn gcd_raw<T: Modulo<T,T> + Zero + Eq>(n: T, m: T) -> T {\n+    let mut m = m, n = n;\n+    while m != Zero::zero() {\n+        let temp = m;\n+        m = n % temp;\n+        n = temp;\n+    }\n+    n\n+}\n+\n+/**\n+Compute the greatest common divisor of two numbers, via Euclid's algorithm.\n+\n+The result is always positive.\n+*/\n+#[inline]\n+pub fn gcd<T: Modulo<T,T> + Neg<T> + Zero + Ord + Eq>(n: T, m: T) -> T {\n+    let g = gcd_raw(n, m);\n+    if g < Zero::zero() { -g }\n+    else { g }\n+}\n+\n+/* Comparisons */\n+\n+// comparing a/b and c/d is the same as comparing a*d and b*c, so we\n+// abstract that pattern. The following macro takes a trait and either\n+// a comma-separated list of \"method name -> return value\" or just\n+// \"method name\" (return value is bool in that case)\n+macro_rules! cmp_impl {\n+    (impl $imp:ident, $($method:ident),+) => {\n+        cmp_impl!(impl $imp, $($method -> bool),+)\n+    };\n+    // return something other than a Ratio<T>\n+    (impl $imp:ident, $($method:ident -> $res:ty),+) => {\n+        impl<T: Mul<T,T> + $imp> $imp for Ratio<T> {\n+            $(\n+                #[inline]\n+                fn $method(&self, other: &Ratio<T>) -> $res {\n+                    (self.numer * other.denom). $method (&(self.denom*other.numer))\n+                }\n+            )+\n+        }\n+    };\n+}\n+cmp_impl!(impl Eq, eq, ne)\n+cmp_impl!(impl TotalEq, equals)\n+cmp_impl!(impl Ord, lt, gt, le, ge)\n+cmp_impl!(impl TotalOrd, cmp -> cmp::Ordering)\n+\n+/* Arithmetic */\n+// a/b * c/d = (a*c)/(b*d)\n+impl<T: Copy + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+    Mul<Ratio<T>,Ratio<T>> for Ratio<T> {\n+    #[inline]\n+    fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> {\n+        Ratio::new(self.numer * rhs.numer, self.denom * rhs.denom)\n+    }\n+}\n+\n+// (a/b) / (c/d) = (a*d)/(b*c)\n+impl<T: Copy + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+    Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n+    #[inline]\n+    fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n+        Ratio::new(self.numer * rhs.denom, self.denom * rhs.numer)\n+    }\n+}\n+\n+// Abstracts the a/b `op` c/d = (a*d `op` b*d) / (b*d) pattern\n+macro_rules! arith_impl {\n+    (impl $imp:ident, $method:ident) => {\n+        impl<T: Copy +\n+                Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> +\n+                Zero + One + Ord + Eq>\n+            $imp<Ratio<T>,Ratio<T>> for Ratio<T> {\n+            #[inline]\n+            fn $method(&self, rhs: &Ratio<T>) -> Ratio<T> {\n+                Ratio::new((self.numer * rhs.denom).$method(&(self.denom * rhs.numer)),\n+                           self.denom * rhs.denom)\n+            }\n+        }\n+    }\n+}\n+\n+// a/b + c/d = (a*d + b*c)/(b*d\n+arith_impl!(impl Add, add)\n+\n+// a/b - c/d = (a*d - b*c)/(b*d)\n+arith_impl!(impl Sub, sub)\n+\n+// a/b % c/d = (a*d % b*c)/(b*d)\n+arith_impl!(impl Modulo, modulo)\n+\n+impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+    Neg<Ratio<T>> for Ratio<T> {\n+    #[inline]\n+    fn neg(&self) -> Ratio<T> {\n+        Ratio::new_raw(-self.numer, self.denom)\n+    }\n+}\n+\n+/* Constants */\n+impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+    Zero for Ratio<T> {\n+    #[inline]\n+    fn zero() -> Ratio<T> {\n+        Ratio::new_raw(Zero::zero(), One::one())\n+    }\n+}\n+\n+impl<T: Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+    One for Ratio<T> {\n+    #[inline]\n+    fn one() -> Ratio<T> {\n+        Ratio::new_raw(One::one(), One::one())\n+    }\n+}\n+\n+/* Utils */\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Modulo<T,T> + Neg<T> +\n+    Zero + One + Ord + Eq>\n+    Round for Ratio<T> {\n+    fn round(&self, mode: num::RoundMode) -> Ratio<T> {\n+        match mode {\n+            num::RoundUp => { self.ceil() }\n+            num::RoundDown => { self.floor()}\n+            num::RoundToZero => { Ratio::from_integer(self.numer / self.denom) }\n+            num::RoundFromZero => {\n+                if *self < Zero::zero() {\n+                    Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n+                } else {\n+                    Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn floor(&self) -> Ratio<T> {\n+        if *self < Zero::zero() {\n+            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n+        } else {\n+            Ratio::from_integer(self.numer / self.denom)\n+        }\n+    }\n+    fn ceil(&self) -> Ratio<T> {\n+        if *self < Zero::zero() {\n+            Ratio::from_integer(self.numer / self.denom)\n+        } else {\n+            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n+        }\n+    }\n+    fn fract(&self) -> Ratio<T> {\n+        Ratio::new_raw(self.numer % self.denom, self.denom)\n+    }\n+}\n+\n+\n+/* String conversions */\n+impl<T: ToStr> ToStr for Ratio<T> {\n+    /// Renders as `numer/denom`.\n+    fn to_str(&self) -> ~str {\n+        fmt!(\"%s/%s\", self.numer.to_str(), self.denom.to_str())\n+    }\n+}\n+impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n+    /// Renders as `numer/denom` where the numbers are in base `radix`.\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n+        fmt!(\"%s/%s\", self.numer.to_str_radix(radix), self.denom.to_str_radix(radix))\n+    }\n+}\n+\n+impl<T: FromStr + Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+    FromStr for Ratio<T> {\n+    /// Parses `numer/denom`.\n+    fn from_str(s: &str) -> Option<Ratio<T>> {\n+        let split = vec::build(|push| {\n+            for str::each_splitn_char(s, '/', 1) |s| {\n+                push(s.to_owned());\n+            }\n+        });\n+        if split.len() < 2 { return None; }\n+        do FromStr::from_str(split[0]).chain |a| {\n+            do FromStr::from_str(split[1]).chain |b| {\n+                Some(Ratio::new(a,b))\n+            }\n+        }\n+    }\n+}\n+impl<T: FromStrRadix + Copy + Div<T,T> + Modulo<T,T> + Neg<T> + Zero + One + Ord + Eq>\n+    FromStrRadix for Ratio<T> {\n+    /// Parses `numer/denom` where the numbers are in base `radix`.\n+    fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n+        let split = vec::build(|push| {\n+            for str::each_splitn_char(s, '/', 1) |s| {\n+                push(s.to_owned());\n+            }\n+        });\n+        if split.len() < 2 { None }\n+        else {\n+            do FromStrRadix::from_str_radix(split[0], radix).chain |a| {\n+                do FromStrRadix::from_str_radix(split[1], radix).chain |b| {\n+                    Some(Ratio::new(a,b))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use core::prelude::*;\n+    use super::*;\n+    use core::num::{Zero,One,FromStrRadix};\n+    use core::from_str::FromStr;\n+\n+    pub static _0 : Rational = Ratio { numer: 0, denom: 1};\n+    pub static _1 : Rational = Ratio { numer: 1, denom: 1};\n+    pub static _2: Rational = Ratio { numer: 2, denom: 1};\n+    pub static _1_2: Rational = Ratio { numer: 1, denom: 2};\n+    pub static _3_2: Rational = Ratio { numer: 3, denom: 2};\n+    pub static _neg1_2: Rational =  Ratio { numer: -1, denom: 2};\n+\n+    #[test]\n+    fn test_gcd() {\n+        assert_eq!(gcd(10,2),2);\n+        assert_eq!(gcd(10,3),1);\n+        assert_eq!(gcd(0,3),3);\n+        assert_eq!(gcd(3,3),3);\n+\n+        assert_eq!(gcd(3,-3), 3);\n+        assert_eq!(gcd(-6,3), 3);\n+        assert_eq!(gcd(-4,-2), 2);\n+    }\n+\n+    #[test]\n+    fn test_test_constants() {\n+        // check our constants are what Ratio::new etc. would make.\n+        assert_eq!(_0, Zero::zero());\n+        assert_eq!(_1, One::one());\n+        assert_eq!(_2, Ratio::from_integer(2));\n+        assert_eq!(_1_2, Ratio::new(1,2));\n+        assert_eq!(_3_2, Ratio::new(3,2));\n+        assert_eq!(_neg1_2, Ratio::new(-1,2));\n+    }\n+\n+    #[test]\n+    fn test_new_reduce() {\n+        let one22 = Ratio::new(2i,2);\n+\n+        assert_eq!(one22, One::one());\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_new_zero() {\n+        let _a = Ratio::new(1,0);\n+    }\n+\n+\n+    #[test]\n+    fn test_cmp() {\n+        assert!(_0 == _0 && _1 == _1);\n+        assert!(_0 != _1 && _1 != _0);\n+        assert!(_0 < _1 && !(_1 < _0));\n+        assert!(_1 > _0 && !(_0 > _1));\n+\n+        assert!(_0 <= _0 && _1 <= _1);\n+        assert!(_0 <= _1 && !(_1 <= _0));\n+\n+        assert!(_0 >= _0 && _1 >= _1);\n+        assert!(_1 >= _0 && !(_0 >= _1));\n+    }\n+\n+\n+    mod arith {\n+        use super::*;\n+        use super::super::*;\n+\n+\n+        #[test]\n+        fn test_add() {\n+            assert_eq!(_1 + _1_2, _3_2);\n+            assert_eq!(_1 + _1, _2);\n+            assert_eq!(_1_2 + _3_2, _2);\n+            assert_eq!(_1_2 + _neg1_2, _0);\n+        }\n+\n+        #[test]\n+        fn test_sub() {\n+            assert_eq!(_1 - _1_2, _1_2);\n+            assert_eq!(_3_2 - _1_2, _1);\n+            assert_eq!(_1 - _neg1_2, _3_2);\n+        }\n+\n+        #[test]\n+        fn test_mul() {\n+            assert_eq!(_1 * _1_2, _1_2);\n+            assert_eq!(_1_2 * _3_2, Ratio::new(3,4));\n+            assert_eq!(_1_2 * _neg1_2, Ratio::new(-1, 4));\n+        }\n+\n+        #[test]\n+        fn test_div() {\n+            assert_eq!(_1 / _1_2, _2);\n+            assert_eq!(_3_2 / _1_2, _1 + _2);\n+            assert_eq!(_1 / _neg1_2, _neg1_2 + _neg1_2 + _neg1_2 + _neg1_2);\n+        }\n+\n+        #[test]\n+        fn test_modulo() {\n+            assert_eq!(_3_2 % _1, _1_2);\n+            assert_eq!(_2 % _neg1_2, _0);\n+            assert_eq!(_1_2 % _2,  _1_2);\n+        }\n+\n+        #[test]\n+        fn test_neg() {\n+            assert_eq!(-_0, _0);\n+            assert_eq!(-_1_2, _neg1_2);\n+            assert_eq!(-(-_1), _1);\n+        }\n+        #[test]\n+        fn test_zero() {\n+            assert_eq!(_0 + _0, _0);\n+            assert_eq!(_0 * _0, _0);\n+            assert_eq!(_0 * _1, _0);\n+            assert_eq!(_0 / _neg1_2, _0);\n+            assert_eq!(_0 - _0, _0);\n+        }\n+        #[test]\n+        #[should_fail]\n+        fn test_div_0() {\n+            let _a =  _1 / _0;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_round() {\n+        assert_eq!(_1_2.ceil(), _1);\n+        assert_eq!(_1_2.floor(), _0);\n+        assert_eq!(_1_2.round(num::RoundToZero), _0);\n+        assert_eq!(_1_2.round(num::RoundFromZero), _1);\n+\n+        assert_eq!(_neg1_2.ceil(), _0);\n+        assert_eq!(_neg1_2.floor(), -_1);\n+        assert_eq!(_neg1_2.round(num::RoundToZero), _0);\n+        assert_eq!(_neg1_2.round(num::RoundFromZero), -_1);\n+\n+        assert_eq!(_1.ceil(), _1);\n+        assert_eq!(_1.floor(), _1);\n+        assert_eq!(_1.round(num::RoundToZero), _1);\n+        assert_eq!(_1.round(num::RoundFromZero), _1);\n+    }\n+\n+    #[test]\n+    fn test_fract() {\n+        assert_eq!(_1.fract(), _0);\n+        assert_eq!(_neg1_2.fract(), _neg1_2);\n+        assert_eq!(_1_2.fract(), _1_2);\n+        assert_eq!(_3_2.fract(), _1_2);\n+    }\n+\n+    #[test]\n+    fn test_to_from_str() {\n+        fn test(r: Rational, s: ~str) {\n+            assert_eq!(FromStr::from_str(s), Some(r));\n+            assert_eq!(r.to_str(), s);\n+        }\n+        test(_1, ~\"1/1\");\n+        test(_0, ~\"0/1\");\n+        test(_1_2, ~\"1/2\");\n+        test(_3_2, ~\"3/2\");\n+        test(_2, ~\"2/1\");\n+        test(_neg1_2, ~\"-1/2\");\n+    }\n+    #[test]\n+    fn test_from_str_fail() {\n+        fn test(s: &str) {\n+            assert_eq!(FromStr::from_str::<Rational>(s), None);\n+        }\n+\n+        for [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"].each |&s| {\n+            test(s);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_from_str_radix() {\n+        fn test(r: Rational, s: ~str, n: uint) {\n+            assert_eq!(FromStrRadix::from_str_radix(s, n), Some(r));\n+            assert_eq!(r.to_str_radix(n), s);\n+        }\n+        fn test3(r: Rational, s: ~str) { test(r, s, 3) }\n+        fn test16(r: Rational, s: ~str) { test(r, s, 16) }\n+\n+        test3(_1, ~\"1/1\");\n+        test3(_0, ~\"0/1\");\n+        test3(_1_2, ~\"1/2\");\n+        test3(_3_2, ~\"10/2\");\n+        test3(_2, ~\"2/1\");\n+        test3(_neg1_2, ~\"-1/2\");\n+        test3(_neg1_2 / _2, ~\"-1/11\");\n+\n+        test16(_1, ~\"1/1\");\n+        test16(_0, ~\"0/1\");\n+        test16(_1_2, ~\"1/2\");\n+        test16(_3_2, ~\"3/2\");\n+        test16(_2, ~\"2/1\");\n+        test16(_neg1_2, ~\"-1/2\");\n+        test16(_neg1_2 / _2, ~\"-1/4\");\n+        test16(Ratio::new(13,15), ~\"d/f\");\n+        test16(_1_2*_1_2*_1_2*_1_2, ~\"1/10\");\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix_fail() {\n+        fn test(s: &str) {\n+            assert_eq!(FromStrRadix::from_str_radix::<Rational>(s, 3), None);\n+        }\n+\n+        for [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"].each |&s| {\n+            test(s);\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "9aac8d230558d77cd61fad04e2befe186819e84c", "filename": "src/libstd/std.rc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdd2439529c23b4fcd2676d7427c45ca223385ce/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bdd2439529c23b4fcd2676d7427c45ca223385ce/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=bdd2439529c23b4fcd2676d7427c45ca223385ce", "patch": "@@ -95,7 +95,12 @@ pub mod cmp;\n pub mod base64;\n pub mod rl;\n pub mod workcache;\n+#[path=\"num/bigint.rs\"]\n pub mod bigint;\n+#[path=\"num/rational.rs\"]\n+pub mod rational;\n+#[path=\"num/complex.rs\"]\n+pub mod complex;\n pub mod stats;\n pub mod semver;\n pub mod fileinput;"}]}