{"sha": "9c88f3be126d0fe02a92c20e1d78192f4b648401", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljODhmM2JlMTI2ZDBmZTAyYTkyYzIwZTFkNzgxOTJmNGI2NDg0MDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-27T20:46:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-27T20:46:48Z"}, "message": "Auto merge of #24765 - pnkfelix:fsk-enum-swapindrop, r=nikomatsakis\n\nInspect enum discriminant *after* calling its destructor\r\n\r\nIncludes some drive-by cleanup (e.g. changed some field and method names to reflect fill-on-drop; added comments about zero-variant enums being classified as `_match::Single`).\r\n\r\nProbably the most invasive change was the expansion of the maps `available_drop_glues` and `drop_glues` to now hold two different kinds of drop glues; there is the (old) normal drop glue, and there is (new) drop-contents glue that jumps straight to dropping the contents of a struct or enum, skipping its destructor.\r\n\r\n * For all types that do not have user-defined Drop implementations, the normal glue is generated as usual (i.e. recursively dropping the fields of the data structure).\r\n\r\n  (And this actually is exactly what the newly-added drop-contents glue does as well.)\r\n\r\n * For types that have user-defined Drop implementations, the \"normal\" drop glue now schedules a cleanup before invoking the `Drop::drop` method that will call the drop-contents glue after that invocation returns.\r\n\r\nFix #23611.\r\n\r\n----\r\n\r\nIs this a breaking change?  The prior behavior was totally unsound, and it seems unreasonable that anyone was actually relying on it.\r\n\r\nNonetheless, since there is a user-visible change to the language semantics, I guess I will conservatively mark this as a:\r\n\r\n[breaking-change]\r\n\r\n(To see an example of what sort of user-visible change this causes, see the comments in the regression test.)", "tree": {"sha": "4c88238657a17c1fafca0f5bd1726479f6428994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c88238657a17c1fafca0f5bd1726479f6428994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c88f3be126d0fe02a92c20e1d78192f4b648401", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c88f3be126d0fe02a92c20e1d78192f4b648401", "html_url": "https://github.com/rust-lang/rust/commit/9c88f3be126d0fe02a92c20e1d78192f4b648401", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c88f3be126d0fe02a92c20e1d78192f4b648401/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "url": "https://api.github.com/repos/rust-lang/rust/commits/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651", "html_url": "https://github.com/rust-lang/rust/commit/857ef6e272e5634cb9f3e6ee50eb6bc2a2e71651"}, {"sha": "805349a50b9577e81b04e34a7482d6d5dcb01527", "url": "https://api.github.com/repos/rust-lang/rust/commits/805349a50b9577e81b04e34a7482d6d5dcb01527", "html_url": "https://github.com/rust-lang/rust/commit/805349a50b9577e81b04e34a7482d6d5dcb01527"}], "stats": {"total": 563, "additions": 447, "deletions": 116}, "files": [{"sha": "060dde02c2d12269b38fb724153f363f24ac3759", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9c88f3be126d0fe02a92c20e1d78192f4b648401", "patch": "@@ -916,8 +916,8 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         let datum = Datum::new(llval, binding_info.ty, Lvalue);\n         if let Some(cs) = cs {\n-            bcx.fcx.schedule_drop_and_zero_mem(cs, llval, binding_info.ty);\n             bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n+            bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty);\n         }\n \n         debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));"}, {"sha": "cecf35001c4eb00097b85afead452b719da981d7", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=9c88f3be126d0fe02a92c20e1d78192f4b648401", "patch": "@@ -771,6 +771,7 @@ pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             (_match::Switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n         Univariant(..) => {\n+            // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n             (_match::Single, None)\n         }\n     }\n@@ -1062,7 +1063,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n                 let ptr = struct_field_ptr(variant_cx, st, value, (st.fields.len() - 1), false);\n-                datum::Datum::new(ptr, ptr_ty, datum::Rvalue::new(datum::ByRef))\n+                datum::Datum::new(ptr, ptr_ty, datum::Lvalue)\n                     .store_to(variant_cx, scratch.val)\n             });\n             let expr_datum = scratch.to_expr_datum();"}, {"sha": "1e5b4d4d5ff333f26491585e5fb2cec52bc4d6bc", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=9c88f3be126d0fe02a92c20e1d78192f4b648401", "patch": "@@ -471,8 +471,11 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n \n           match adt::trans_switch(cx, &*repr, av) {\n               (_match::Single, None) => {\n-                  cx = iter_variant(cx, &*repr, av, &*(*variants)[0],\n-                                    substs, &mut f);\n+                  if n_variants != 0 {\n+                      assert!(n_variants == 1);\n+                      cx = iter_variant(cx, &*repr, av, &*(*variants)[0],\n+                                        substs, &mut f);\n+                  }\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, cx.tcx().types.isize);"}, {"sha": "3ec73ff8eb9de129ffb1b8afe40b9b98556cc570", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 67, "deletions": 17, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=9c88f3be126d0fe02a92c20e1d78192f4b648401", "patch": "@@ -393,19 +393,22 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: false\n+            fill_on_drop: false,\n+            skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n+        debug!(\"schedule_drop_mem({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()));\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n-    /// Schedules a (deep) drop and zero-ing of `val`, which is a pointer to an instance of `ty`\n-    fn schedule_drop_and_zero_mem(&self,\n+    /// Schedules a (deep) drop and filling of `val`, which is a pointer to an instance of `ty`\n+    fn schedule_drop_and_fill_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>) {\n@@ -416,14 +419,48 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: true\n+            fill_on_drop: true,\n+            skip_dtor: false,\n+        };\n+\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={}, fill_on_drop={}, skip_dtor={})\",\n+               cleanup_scope,\n+               self.ccx.tn().val_to_string(val),\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n+\n+        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n+    }\n+\n+    /// Issue #23611: Schedules a (deep) drop of the contents of\n+    /// `val`, which is a pointer to an instance of struct/enum type\n+    /// `ty`. The scheduled code handles extracting the discriminant\n+    /// and dropping the contents associated with that variant\n+    /// *without* executing any associated drop implementation.\n+    fn schedule_drop_enum_contents(&self,\n+                                   cleanup_scope: ScopeId,\n+                                   val: ValueRef,\n+                                   ty: Ty<'tcx>) {\n+        // `if` below could be \"!contents_needs_drop\"; skipping drop\n+        // is just an optimization, so sound to be conservative.\n+        if !self.type_needs_drop(ty) { return; }\n+\n+        let drop = box DropValue {\n+            is_immediate: false,\n+            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n+            val: val,\n+            ty: ty,\n+            fill_on_drop: false,\n+            skip_dtor: true,\n         };\n \n-        debug!(\"schedule_drop_and_zero_mem({:?}, val={}, ty={}, zero={})\",\n+        debug!(\"schedule_drop_enum_contents({:?}, val={}, ty={}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty.repr(self.ccx.tcx()),\n-               true);\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -440,13 +477,16 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n-            zero: false\n+            fill_on_drop: false,\n+            skip_dtor: false,\n         };\n \n-        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?})\",\n+        debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n-               ty.repr(self.ccx.tcx()));\n+               ty.repr(self.ccx.tcx()),\n+               drop.fill_on_drop,\n+               drop.skip_dtor);\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -987,7 +1027,8 @@ pub struct DropValue<'tcx> {\n     must_unwind: bool,\n     val: ValueRef,\n     ty: Ty<'tcx>,\n-    zero: bool\n+    fill_on_drop: bool,\n+    skip_dtor: bool,\n }\n \n impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n@@ -1007,13 +1048,18 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n                    bcx: Block<'blk, 'tcx>,\n                    debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        let _icx = base::push_ctxt(\"<DropValue as Cleanup>::trans\");\n+        let skip_dtor = self.skip_dtor;\n+        let _icx = if skip_dtor {\n+            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=true\")\n+        } else {\n+            base::push_ctxt(\"<DropValue as Cleanup>::trans skip_dtor=false\")\n+        };\n         let bcx = if self.is_immediate {\n-            glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n+            glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         } else {\n-            glue::drop_ty(bcx, self.val, self.ty, debug_loc)\n+            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         };\n-        if self.zero {\n+        if self.fill_on_drop {\n             base::drop_done_fill_mem(bcx, self.val, self.ty);\n         }\n         bcx\n@@ -1190,10 +1236,14 @@ pub trait CleanupMethods<'blk, 'tcx> {\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n                          ty: Ty<'tcx>);\n-    fn schedule_drop_and_zero_mem(&self,\n+    fn schedule_drop_and_fill_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>);\n+    fn schedule_drop_enum_contents(&self,\n+                                   cleanup_scope: ScopeId,\n+                                   val: ValueRef,\n+                                   ty: Ty<'tcx>);\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,"}, {"sha": "1506e5b266981fc5bd11097bad1f2769cc02ffd2", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=9c88f3be126d0fe02a92c20e1d78192f4b648401", "patch": "@@ -21,6 +21,7 @@ use trans::builder::Builder;\n use trans::common::{ExternMap,BuilderRef_res};\n use trans::debuginfo;\n use trans::declare;\n+use trans::glue::DropGlueKind;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n use middle::subst::Substs;\n@@ -73,7 +74,7 @@ pub struct SharedCrateContext<'tcx> {\n     check_drop_flag_for_sanity: bool,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n-    available_drop_glues: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n+    available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -89,7 +90,7 @@ pub struct LocalCrateContext<'tcx> {\n     item_vals: RefCell<NodeMap<ValueRef>>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n+    drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n     /// Track mapping of external ids to local items imported for inlining\n     external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     /// Backwards version of the `external` map (inlined items to where they\n@@ -574,7 +575,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.fn_pointer_shims\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>> {\n         &self.local.drop_glues\n     }\n \n@@ -660,7 +661,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.available_monomorphizations\n     }\n \n-    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n+    pub fn available_drop_glues(&self) -> &RefCell<FnvHashMap<DropGlueKind<'tcx>, String>> {\n         &self.shared.available_drop_glues\n     }\n "}, {"sha": "652f6ad366aaa09604301d0f2a9c7e282598d70f", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 102, "deletions": 91, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=9c88f3be126d0fe02a92c20e1d78192f4b648401", "patch": "@@ -30,7 +30,6 @@ use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n-use trans::datum;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n@@ -132,14 +131,26 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n-                           debug_loc: DebugLoc)\n-                           -> Block<'blk, 'tcx> {\n+                           debug_loc: DebugLoc) -> Block<'blk, 'tcx> {\n+    drop_ty_core(bcx, v, t, debug_loc, false)\n+}\n+\n+pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                v: ValueRef,\n+                                t: Ty<'tcx>,\n+                                debug_loc: DebugLoc,\n+                                skip_dtor: bool) -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n+    debug!(\"drop_ty_core(t={}, skip_dtor={})\", t.repr(bcx.tcx()), skip_dtor);\n     let _icx = push_ctxt(\"drop_ty\");\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n-        let glue = get_drop_glue(ccx, t);\n+        let g = if skip_dtor {\n+            DropGlueKind::TyContents(t)\n+        } else {\n+            DropGlueKind::Ty(t)\n+        };\n+        let glue = get_drop_glue_core(ccx, g);\n         let glue_type = get_drop_glue_type(ccx, t);\n         let ptr = if glue_type != t {\n             PointerCast(bcx, v, type_of(ccx, glue_type).ptr_to())\n@@ -155,22 +166,64 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      v: ValueRef,\n                                      t: Ty<'tcx>,\n-                                     debug_loc: DebugLoc)\n+                                     debug_loc: DebugLoc,\n+                                     skip_dtor: bool)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     store_ty(bcx, v, vp, t);\n-    drop_ty(bcx, vp, t, debug_loc)\n+    drop_ty_core(bcx, vp, t, debug_loc, skip_dtor)\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n-    debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    let t = get_drop_glue_type(ccx, t);\n-    debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    match ccx.drop_glues().borrow().get(&t) {\n+    get_drop_glue_core(ccx, DropGlueKind::Ty(t))\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum DropGlueKind<'tcx> {\n+    /// The normal path; runs the dtor, and then recurs on the contents\n+    Ty(Ty<'tcx>),\n+    /// Skips the dtor, if any, for ty; drops the contents directly.\n+    /// Note that the dtor is only skipped at the most *shallow*\n+    /// level, namely, an `impl Drop for Ty` itself. So, for example,\n+    /// if Ty is Newtype(S) then only the Drop impl for for Newtype\n+    /// itself will be skipped, while the Drop impl for S, if any,\n+    /// will be invoked.\n+    TyContents(Ty<'tcx>),\n+}\n+\n+impl<'tcx> DropGlueKind<'tcx> {\n+    fn ty(&self) -> Ty<'tcx> {\n+        match *self { DropGlueKind::Ty(t) | DropGlueKind::TyContents(t) => t }\n+    }\n+\n+    fn map_ty<F>(&self, mut f: F) -> DropGlueKind<'tcx> where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n+    {\n+        match *self {\n+            DropGlueKind::Ty(t) => DropGlueKind::Ty(f(t)),\n+            DropGlueKind::TyContents(t) => DropGlueKind::TyContents(f(t)),\n+        }\n+    }\n+\n+    fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n+        let t_str = ppaux::ty_to_string(ccx.tcx(), self.ty());\n+        match *self {\n+            DropGlueKind::Ty(_) => format!(\"DropGlueKind::Ty({})\", t_str),\n+            DropGlueKind::TyContents(_) => format!(\"DropGlueKind::TyContents({})\", t_str),\n+        }\n+    }\n+}\n+\n+fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                g: DropGlueKind<'tcx>) -> ValueRef {\n+    debug!(\"make drop glue for {}\", g.to_string(ccx));\n+    let g = g.map_ty(|t| get_drop_glue_type(ccx, t));\n+    debug!(\"drop glue type {}\", g.to_string(ccx));\n+    match ccx.drop_glues().borrow().get(&g) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n+    let t = g.ty();\n \n     let llty = if type_is_sized(ccx.tcx(), t) {\n         type_of(ccx, t).ptr_to()\n@@ -182,17 +235,17 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n-    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&t) {\n+    if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&g) {\n         let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n-        ccx.drop_glues().borrow_mut().insert(t, llfn);\n+        ccx.drop_glues().borrow_mut().insert(g, llfn);\n         return llfn;\n     };\n \n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n     let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n        ccx.sess().bug(&format!(\"symbol `{}` already defined\", fn_nm));\n     });\n-    ccx.available_drop_glues().borrow_mut().insert(t, fn_nm);\n+    ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n \n     let _s = StatRecorder::new(ccx, format!(\"drop {}\", ty_to_short_str(ccx.tcx(), t)));\n \n@@ -217,7 +270,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n     // type, so we don't need to explicitly cast the function parameter.\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n-    let bcx = make_drop_glue(bcx, llrawptr0, t);\n+    let bcx = make_drop_glue(bcx, llrawptr0, g);\n     finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n \n     llfn\n@@ -307,88 +360,36 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  substs: &subst::Substs<'tcx>)\n                                  -> Block<'blk, 'tcx>\n {\n-    let repr = adt::represent_type(bcx.ccx(), t);\n+    debug!(\"trans_struct_drop t: {}\", bcx.ty_to_string(t));\n \n     // Find and call the actual destructor\n-    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t,\n-                                 class_did, substs);\n+    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, t, class_did, substs);\n \n-    // The first argument is the \"self\" argument for drop\n+    // Class dtors have no explicit args, so the params should\n+    // just consist of the environment (self).\n     let params = unsafe {\n         let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n         ty.element_type().func_params()\n     };\n+    assert_eq!(params.len(), 1);\n \n-    let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n-    let self_ty = match fty.sty {\n-        ty::ty_bare_fn(_, ref f) => {\n-            let sig = ty::erase_late_bound_regions(bcx.tcx(), &f.sig);\n-            assert!(sig.inputs.len() == 1);\n-            sig.inputs[0]\n-        }\n-        _ => bcx.sess().bug(&format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty)))\n-    };\n-\n-    let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n-        (v0, None)\n-    } else {\n-        let data = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-        let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n-        (Load(bcx, data), Some(Load(bcx, info)))\n-    };\n-\n-    adt::fold_variants(bcx, &*repr, struct_data, |variant_cx, st, value| {\n-        // Be sure to put all of the fields into a scope so we can use an invoke\n-        // instruction to call the user destructor but still call the field\n-        // destructors if the user destructor panics.\n-        let field_scope = variant_cx.fcx.push_custom_cleanup_scope();\n-\n-        // Class dtors have no explicit args, so the params should\n-        // just consist of the environment (self).\n-        assert_eq!(params.len(), 1);\n-        let self_arg = if type_is_fat_ptr(bcx.tcx(), self_ty) {\n-            // The dtor expects a fat pointer, so make one, even if we have to fake it.\n-            let scratch = datum::rvalue_scratch_datum(bcx, t, \"__fat_ptr_drop_self\");\n-            Store(bcx, value, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n-            Store(bcx,\n-                  // If we just had a thin pointer, make a fat pointer by sticking\n-                  // null where we put the unsizing info. This works because t\n-                  // is a sized type, so we will only unpack the fat pointer, never\n-                  // use the fake info.\n-                  info.unwrap_or(C_null(Type::i8p(bcx.ccx()))),\n-                  GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n-            PointerCast(variant_cx, scratch.val, params[0])\n-        } else {\n-            PointerCast(variant_cx, value, params[0])\n-        };\n-        let args = vec!(self_arg);\n+    // Be sure to put the contents into a scope so we can use an invoke\n+    // instruction to call the user destructor but still call the field\n+    // destructors if the user destructor panics.\n+    //\n+    // FIXME (#14875) panic-in-drop semantics might be unsupported; we\n+    // might well consider changing below to more direct code.\n+    let contents_scope = bcx.fcx.push_custom_cleanup_scope();\n \n-        // Add all the fields as a value which needs to be cleaned at the end of\n-        // this scope. Iterate in reverse order so a Drop impl doesn't reverse\n-        // the order in which fields get dropped.\n-        for (i, &ty) in st.fields.iter().enumerate().rev() {\n-            let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n+    // Issue #23611: schedule cleanup of contents, re-inspecting the\n+    // discriminant (if any) in case of variant swap in drop code.\n+    bcx.fcx.schedule_drop_enum_contents(cleanup::CustomScope(contents_scope), v0, t);\n \n-            let val = if type_is_sized(bcx.tcx(), ty) {\n-                llfld_a\n-            } else {\n-                let scratch = datum::rvalue_scratch_datum(bcx, ty, \"__fat_ptr_drop_field\");\n-                Store(bcx, llfld_a, GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n-                Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n-                scratch.val\n-            };\n-            variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope), val, ty);\n-        }\n-\n-        let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n-                                     class_did,\n-                                     &[get_drop_glue_type(bcx.ccx(), t)],\n-                                     ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[..], dtor_ty, DebugLoc::None);\n+    let glue_type = get_drop_glue_type(bcx.ccx(), t);\n+    let dtor_ty = ty::mk_ctor_fn(bcx.tcx(), class_did, &[glue_type], ty::mk_nil(bcx.tcx()));\n+    let (_, bcx) = invoke(bcx, dtor_addr, &[v0], dtor_ty, DebugLoc::None);\n \n-        variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope)\n-    })\n+    bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n@@ -454,8 +455,10 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n     }\n }\n \n-fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n+fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueKind<'tcx>)\n                               -> Block<'blk, 'tcx> {\n+    let t = g.ty();\n+    let skip_dtor = match g { DropGlueKind::Ty(_) => false, DropGlueKind::TyContents(_) => true };\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n \n@@ -469,6 +472,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n \n     match t.sty {\n         ty::ty_uniq(content_ty) => {\n+            // Support for ty_uniq is built-in and its drop glue is\n+            // special. It may move to library and have Drop impl. As\n+            // a safe-guard, assert ty_uniq not used with TyContents.\n+            assert!(!skip_dtor);\n             if !type_is_sized(bcx.tcx(), content_ty) {\n                 let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n                 let llbox = Load(bcx, llval);\n@@ -505,8 +512,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         }\n         ty::ty_struct(did, substs) | ty::ty_enum(did, substs) => {\n             let tcx = bcx.tcx();\n-            match ty::ty_dtor(tcx, did) {\n-                ty::TraitDtor(dtor, true) => {\n+            match (ty::ty_dtor(tcx, did), skip_dtor) {\n+                (ty::TraitDtor(dtor, true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n@@ -523,16 +530,20 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n-                ty::TraitDtor(dtor, false) => {\n+                (ty::TraitDtor(dtor, false), false) => {\n                     trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                 }\n-                ty::NoDtor => {\n+                (ty::NoDtor, _) | (_, true) => {\n                     // No dtor? Just the default case\n                     iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n                 }\n             }\n         }\n         ty::ty_trait(..) => {\n+            // No support in vtable for distinguishing destroying with\n+            // versus without calling Drop::drop. Assert caller is\n+            // okay with always calling the Drop impl, if any.\n+            assert!(!skip_dtor);\n             let data_ptr = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n             let vtable_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n             let dtor = Load(bcx, vtable_ptr);"}, {"sha": "540cbd50e9d57d80374b5c705aeec7a0858c825c", "filename": "src/test/run-pass/issue-23611-enum-swap-in-drop.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Ftest%2Frun-pass%2Fissue-23611-enum-swap-in-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c88f3be126d0fe02a92c20e1d78192f4b648401/src%2Ftest%2Frun-pass%2Fissue-23611-enum-swap-in-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23611-enum-swap-in-drop.rs?ref=9c88f3be126d0fe02a92c20e1d78192f4b648401", "patch": "@@ -0,0 +1,265 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 23611: this test is ensuring that, for an instance `X` of the\n+// enum `E`, if you swap in a different variant during the execution\n+// of the `<E as Drop>::drop`, then the appropriate substructure will\n+// be torn down after the `<E as Drop>::drop` method returns.\n+\n+use std::cell::RefCell;\n+use std::mem;\n+\n+use self::d::D;\n+\n+pub fn main() {\n+    let log = RefCell::new(vec![]);\n+    d::println(&format!(\"created empty log\"));\n+    test(&log);\n+\n+    // println!(\"log: {:?}\", &log.borrow()[..]);\n+    assert_eq!(\n+        &log.borrow()[..],\n+        [\n+            //                                         created empty log\n+            // +-- Make D(test_1, 10000000)\n+            // | +-- Make D(g_b_5, 50000001)\n+            // | |                                     in g_B(b2b0) from E::drop, b=b4b0\n+            // | +-- Drop D(g_b_5, 50000001)\n+            50000001,\n+            // |\n+            // | +-- Make D(drop_6, 60000002)\n+            // | | +-- Make D(g_b_5, 50000003)\n+            // | | |                                   in g_B(b2b0) from E::drop, b=b4b1\n+            // | | +-- Drop D(g_b_5, 50000003)\n+            50000003,\n+            // | |\n+            // | | +-- Make D(GaspB::drop_3, 30000004)\n+            // | | | +-- Make D(g_b_5, 50000005)\n+            // | | | |                                 in g_B(b4b2) from GaspB::drop\n+            // | | | +-- Drop D(g_b_5, 50000005)\n+            50000005,\n+            // | | |\n+            // | | +-- Drop D(GaspB::drop_3, 30000004)\n+            30000004,\n+            // | |\n+            // +-- Drop D(test_1, 10000000)\n+            10000000,\n+            //   |\n+            // +-- Make D(GaspA::drop_2, 20000006)\n+            // | | +-- Make D(f_a_4, 40000007)\n+            // | | |                                   in f_A(a3a0) from GaspA::drop\n+            // | | +-- Drop D(f_a_4, 40000007)\n+            40000007,\n+            // | |\n+            // +-- Drop D(GaspA::drop_2, 20000006)\n+            20000006,\n+            //   |\n+            //   +-- Drop D(drop_6, 60000002)\n+            60000002\n+            //\n+                ]);\n+\n+    // For reference purposes, the old (incorrect) behavior would produce the following\n+    // output, which you can compare to the above:\n+    //\n+    //                                             created empty log\n+    // +-- Make D(test_1, 10000000)\n+    // | +-- Make D(g_b_5, 50000001)\n+    // | |                                     in g_B(b2b0) from E::drop, b=b4b0\n+    // | +-- Drop D(g_b_5, 50000001)\n+    // |\n+    // | +-- Make D(drop_6, 60000002)\n+    // | | +-- Make D(g_b_5, 50000003)\n+    // | | |                                   in g_B(b2b0) from E::drop, b=b4b1\n+    // | | +-- Drop D(g_b_5, 50000003)\n+    // | |\n+    // | | +-- Make D(GaspB::drop_3, 30000004)\n+    // | | | +-- Make D(g_b_5, 50000005)\n+    // | | | |                                 in g_B(b4b2) from GaspB::drop\n+    // | | | +-- Drop D(g_b_5, 50000005)\n+    // | | |\n+    // | | +-- Drop D(GaspB::drop_3, 30000004)\n+    // | |\n+    // +-- Drop D(test_1, 10000000)\n+    //   |\n+    // +-- Make D(GaspB::drop_3, 30000006)\n+    // | | +-- Make D(f_a_4, 40000007)\n+    // | | |                                   in f_A(a3a0) from GaspB::drop\n+    // | | +-- Drop D(f_a_4, 40000007)\n+    // | |\n+    // +-- Drop D(GaspB::drop_3, 30000006)\n+    //   |\n+    //   +-- Drop D(drop_6, 60000002)\n+\n+    // Note that this calls f_A from GaspB::drop (and thus creates a D\n+    // with a uid incorporating the origin of GaspB's drop that\n+    // surrounds the f_A invocation), but the code as written only\n+    // ever hands f_A off to instances of GaspA, and thus one should\n+    // be able to prove the invariant that f_A is *only* invoked from\n+    // from an instance of GaspA (either via the GaspA drop\n+    // implementation or the E drop implementaton). Yet the old (bad)\n+    // behavior allowed a call to f_A to leak in while we are tearing\n+    // down a value of type GaspB.\n+}\n+\n+fn test<'a>(log: d::Log<'a>) {\n+    let _e = E::B(GaspB(g_b, 0xB4B0, log, D::new(\"test\", 1, log)), true);\n+}\n+\n+struct GaspA<'a>(for <'b> fn(u32, &'b str, d::Log<'a>), u32, d::Log<'a>, d::D<'a>);\n+struct GaspB<'a>(for <'b> fn(u32, &'b str, d::Log<'a>), u32, d::Log<'a>, d::D<'a>);\n+\n+impl<'a> Drop for GaspA<'a> {\n+    fn drop(&mut self) {\n+        let _d = d::D::new(\"GaspA::drop\", 2, self.2);\n+        (self.0)(self.1, \"GaspA::drop\", self.2);\n+    }\n+}\n+\n+impl<'a> Drop for GaspB<'a> {\n+    fn drop(&mut self) {\n+        let _d = d::D::new(\"GaspB::drop\", 3, self.2);\n+        (self.0)(self.1, \"GaspB::drop\", self.2);\n+    }\n+}\n+\n+enum E<'a> {\n+    A(GaspA<'a>, bool), B(GaspB<'a>, bool),\n+}\n+\n+fn f_a(x: u32, ctxt: &str, log: d::Log) {\n+    let _d = d::D::new(\"f_a\", 4, log);\n+    d::println(&format!(\"in f_A({:x}) from {}\", x, ctxt));\n+}\n+fn g_b(y: u32, ctxt: &str, log: d::Log) {\n+    let _d = d::D::new(\"g_b\", 5, log);\n+    d::println(&format!(\"in g_B({:x}) from {}\", y, ctxt));\n+}\n+\n+impl<'a> Drop for E<'a> {\n+    fn drop(&mut self) {\n+        let (do_drop, log) = match *self {\n+            E::A(GaspA(ref f, ref mut val_a, log, ref _d_a), ref mut do_drop) => {\n+                f(0xA1A0, &format!(\"E::drop, a={:x}\", val_a), log);\n+                *val_a += 1;\n+                // swap in do_drop := false to avoid infinite dtor regress\n+                (mem::replace(do_drop, false), log)\n+            }\n+            E::B(GaspB(ref g, ref mut val_b, log, ref _d_b), ref mut do_drop) => {\n+                g(0xB2B0, &format!(\"E::drop, b={:x}\", val_b), log);\n+                *val_b += 1;\n+                // swap in do_drop := false to avoid infinite dtor regress\n+                (mem::replace(do_drop, false), log)\n+            }\n+        };\n+\n+        if do_drop {\n+            mem::replace(self, E::A(GaspA(f_a, 0xA3A0, log, D::new(\"drop\", 6, log)), true));\n+        }\n+    }\n+}\n+\n+// This module provides simultaneous printouts of the dynamic extents\n+// of all of the D values, in addition to logging the order that each\n+// is dropped.\n+//\n+// This code is similar to a support code module embedded within\n+// test/run-pass/issue-123338-ensure-param-drop-order.rs; however,\n+// that (slightly simpler) code only identifies objects in the log via\n+// (creation) time-stamps; this incorporates both timestamping and the\n+// point of origin within the source code into the unique ID (uid).\n+\n+const PREF_INDENT: u32 = 20;\n+\n+pub mod d {\n+    #![allow(unused_parens)]\n+    use std::fmt;\n+    use std::mem;\n+    use std::cell::RefCell;\n+\n+    static mut counter: u16 = 0;\n+    static mut trails: u64 = 0;\n+\n+    pub type Log<'a> = &'a RefCell<Vec<u32>>;\n+\n+    pub fn current_width() -> u32 {\n+        unsafe { max_width() - trails.leading_zeros() }\n+    }\n+\n+    pub fn max_width() -> u32 {\n+        unsafe {\n+            (mem::size_of_val(&trails)*8) as u32\n+        }\n+    }\n+\n+    pub fn indent_println(my_trails: u32, s: &str) {\n+        let mut indent: String = String::new();\n+        for i in 0..my_trails {\n+            unsafe {\n+                if trails & (1 << i) != 0 {\n+                    indent = indent + \"| \";\n+                } else {\n+                    indent = indent + \"  \";\n+                }\n+            }\n+        }\n+        println!(\"{}{}\", indent, s);\n+    }\n+\n+    pub fn println(s: &str) {\n+        indent_println(super::PREF_INDENT, s);\n+    }\n+\n+    fn first_avail() -> u32 {\n+        unsafe {\n+            for i in 0..64 {\n+                if trails & (1 << i) == 0 {\n+                    return i;\n+                }\n+            }\n+        }\n+        panic!(\"exhausted trails\");\n+    }\n+\n+    pub struct D<'a> {\n+        name: &'static str, i: u8, uid: u32, trail: u32, log: Log<'a>\n+    }\n+\n+    impl<'a> fmt::Display for D<'a> {\n+        fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+            write!(w, \"D({}_{}, {})\", self.name, self.i, self.uid)\n+        }\n+    }\n+\n+    impl<'a> D<'a> {\n+        pub fn new(name: &'static str, i: u8, log: Log<'a>) -> D<'a> {\n+            unsafe {\n+                let trail = first_avail();\n+                let ctr = ((i as u32) * 10_000_000) + (counter as u32);\n+                counter += 1;\n+                trails |= (1 << trail);\n+                let ret = D {\n+                    name: name, i: i, log: log, uid: ctr, trail: trail\n+                };\n+                indent_println(trail, &format!(\"+-- Make {}\", ret));\n+                ret\n+            }\n+        }\n+    }\n+\n+    impl<'a> Drop for D<'a> {\n+        fn drop(&mut self) {\n+            unsafe { trails &= !(1 << self.trail); };\n+            self.log.borrow_mut().push(self.uid);\n+            indent_println(self.trail, &format!(\"+-- Drop {}\", self));\n+            indent_println(::PREF_INDENT, \"\");\n+        }\n+    }\n+}"}]}