{"sha": "34c60b6edb810d9f142d248b27d8e6e34c95d63c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YzYwYjZlZGI4MTBkOWYxNDJkMjQ4YjI3ZDhlNmUzNGM5NWQ2M2M=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-19T01:30:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-19T01:30:57Z"}, "message": "Make a tag for iterness / fnness, teach many places about it.", "tree": {"sha": "af27746355ac27ccf6ec837e05112043798e2737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af27746355ac27ccf6ec837e05112043798e2737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34c60b6edb810d9f142d248b27d8e6e34c95d63c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34c60b6edb810d9f142d248b27d8e6e34c95d63c", "html_url": "https://github.com/rust-lang/rust/commit/34c60b6edb810d9f142d248b27d8e6e34c95d63c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34c60b6edb810d9f142d248b27d8e6e34c95d63c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aba50ff331f4d97b1ca2a60091b03e012837b98", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aba50ff331f4d97b1ca2a60091b03e012837b98", "html_url": "https://github.com/rust-lang/rust/commit/3aba50ff331f4d97b1ca2a60091b03e012837b98"}], "stats": {"total": 531, "additions": 303, "deletions": 228}, "files": [{"sha": "01739d19f8f49203a363a377dbb12de11533aa48", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=34c60b6edb810d9f142d248b27d8e6e34c95d63c", "patch": "@@ -78,6 +78,11 @@ tag effect {\n     eff_unsafe;\n }\n \n+tag proto {\n+    proto_iter;\n+    proto_fn;\n+}\n+\n tag binop {\n     add;\n     sub;\n@@ -187,7 +192,8 @@ tag lit_ {\n type ty_field = rec(ident ident, @ty ty);\n type ty_arg = rec(mode mode, @ty ty);\n // TODO: effect\n-type ty_method = rec(ident ident, vec[ty_arg] inputs, @ty output);\n+type ty_method = rec(proto proto, ident ident,\n+                     vec[ty_arg] inputs, @ty output);\n type ty = spanned[ty_];\n tag ty_ {\n     ty_nil;\n@@ -201,7 +207,7 @@ tag ty_ {\n     ty_vec(@ty);\n     ty_tup(vec[@ty]);\n     ty_rec(vec[ty_field]);\n-    ty_fn(vec[ty_arg], @ty);        // TODO: effect\n+    ty_fn(proto, vec[ty_arg], @ty);        // TODO: effect\n     ty_obj(vec[ty_method]);\n     ty_path(path, option.t[def]);\n     ty_mutable(@ty);\n@@ -210,10 +216,10 @@ tag ty_ {\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n type fn_decl = rec(effect effect,\n+                   proto proto,\n                    vec[arg] inputs,\n                    @ty output);\n type _fn = rec(fn_decl decl,\n-               bool is_iter,\n                block body);\n \n "}, {"sha": "71b06b45817acf44718af5f6ce98df83b5f92ec2", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=34c60b6edb810d9f142d248b27d8e6e34c95d63c", "patch": "@@ -133,7 +133,8 @@ impure fn parse_str_lit(parser p) -> ast.ident {\n }\n \n \n-impure fn parse_ty_fn(parser p, ast.span lo) -> ast.ty_ {\n+impure fn parse_ty_fn(ast.proto proto, parser p,\n+                      ast.span lo) -> ast.ty_ {\n     impure fn parse_fn_input_ty(parser p) -> rec(ast.mode mode, @ast.ty ty) {\n         auto mode;\n         if (p.peek() == token.BINOP(token.AND)) {\n@@ -167,7 +168,16 @@ impure fn parse_ty_fn(parser p, ast.span lo) -> ast.ty_ {\n         output = @spanned(lo, inputs.span, ast.ty_nil);\n     }\n \n-    ret ast.ty_fn(inputs.node, output);\n+    ret ast.ty_fn(proto, inputs.node, output);\n+}\n+\n+impure fn parse_proto(parser p) -> ast.proto {\n+    alt (p.peek()) {\n+        case (token.ITER) { p.bump(); ret ast.proto_iter; }\n+        case (token.FN) { p.bump(); ret ast.proto_fn; }\n+        case (?t) { unexpected(p, t); }\n+    }\n+    fail;\n }\n \n impure fn parse_ty_obj(parser p, &mutable ast.span hi) -> ast.ty_ {\n@@ -177,14 +187,14 @@ impure fn parse_ty_obj(parser p, &mutable ast.span hi) -> ast.ty_ {\n \n         // FIXME: do something with this, currently it's dropped on the floor.\n         let ast.effect eff = parse_effect(p);\n-\n-        expect(p, token.FN);\n+        let ast.proto proto = parse_proto(p);\n         auto ident = parse_ident(p);\n-        auto f = parse_ty_fn(p, flo);\n+        auto f = parse_ty_fn(proto, p, flo);\n         expect(p, token.SEMI);\n         alt (f) {\n-            case (ast.ty_fn(?inputs, ?output)) {\n-                ret rec(ident=ident, inputs=inputs, output=output);\n+            case (ast.ty_fn(?proto, ?inputs, ?output)) {\n+                ret rec(proto=proto, ident=ident,\n+                        inputs=inputs, output=output);\n             }\n         }\n         fail;\n@@ -286,9 +296,20 @@ impure fn parse_ty(parser p) -> @ast.ty {\n         case (token.FN) {\n             auto flo = p.get_span();\n             p.bump();\n-            t = parse_ty_fn(p, flo);\n+            t = parse_ty_fn(ast.proto_fn, p, flo);\n             alt (t) {\n-                case (ast.ty_fn(_, ?out)) {\n+                case (ast.ty_fn(_, _, ?out)) {\n+                    hi = out.span;\n+                }\n+            }\n+        }\n+\n+        case (token.ITER) {\n+            auto flo = p.get_span();\n+            p.bump();\n+            t = parse_ty_fn(ast.proto_iter, p, flo);\n+            alt (t) {\n+                case (ast.ty_fn(_, _, ?out)) {\n                     hi = out.span;\n                 }\n             }\n@@ -1537,7 +1558,8 @@ impure fn parse_ty_params(parser p) -> vec[ast.ty_param] {\n     ret ty_params;\n }\n \n-impure fn parse_fn_decl(parser p, ast.effect eff) -> ast.fn_decl {\n+impure fn parse_fn_decl(parser p, ast.proto proto,\n+                        ast.effect eff) -> ast.fn_decl {\n     auto pf = parse_arg;\n     let util.common.spanned[vec[ast.arg]] inputs =\n         // FIXME: passing parse_arg as an lval doesn't work at the\n@@ -1555,35 +1577,30 @@ impure fn parse_fn_decl(parser p, ast.effect eff) -> ast.fn_decl {\n     } else {\n         output = @spanned(inputs.span, inputs.span, ast.ty_nil);\n     }\n-    ret rec(effect=eff, inputs=inputs.node, output=output);\n+    ret rec(effect=eff, proto=proto,\n+            inputs=inputs.node, output=output);\n }\n \n-impure fn parse_fn(parser p, ast.effect eff, bool is_iter) -> ast._fn {\n-    auto decl = parse_fn_decl(p, eff);\n+impure fn parse_fn(parser p, ast.effect eff, ast.proto proto) -> ast._fn {\n+    auto decl = parse_fn_decl(p, proto, eff);\n     auto body = parse_block(p);\n     ret rec(decl = decl,\n-            is_iter = is_iter,\n             body = body);\n }\n \n-impure fn parse_fn_header(parser p, bool is_iter) -> tup(span, ast.ident,\n-                                                         vec[ast.ty_param]) {\n+impure fn parse_fn_header(parser p)\n+    -> tup(span, ast.proto, ast.ident, vec[ast.ty_param]) {\n     auto lo = p.get_span();\n-    if (is_iter) {\n-        expect(p, token.ITER);\n-    } else {\n-        expect(p, token.FN);\n-    }\n+    auto proto = parse_proto(p);\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n-    ret tup(lo, id, ty_params);\n+    ret tup(lo, proto, id, ty_params);\n }\n \n-impure fn parse_item_fn_or_iter(parser p, ast.effect eff,\n-                                bool is_iter) -> @ast.item {\n-    auto t = parse_fn_header(p, is_iter);\n-    auto f = parse_fn(p, eff, is_iter);\n-    auto item = ast.item_fn(t._1, f, t._2,\n+impure fn parse_item_fn_or_iter(parser p, ast.effect eff) -> @ast.item {\n+    auto t = parse_fn_header(p);\n+    auto f = parse_fn(p, eff, t._1);\n+    auto item = ast.item_fn(t._2, f, t._3,\n                             p.next_def_id(), ast.ann_none);\n     ret @spanned(t._0, f.body.span, item);\n }\n@@ -1598,14 +1615,9 @@ impure fn parse_obj_field(parser p) -> ast.obj_field {\n impure fn parse_method(parser p) -> @ast.method {\n     auto lo = p.get_span();\n     auto eff = parse_effect(p);\n-    auto is_iter = false;\n-    alt (p.peek()) {\n-        case (token.FN) { p.bump(); }\n-        case (token.ITER) { p.bump(); is_iter = true; }\n-        case (?t) { unexpected(p, t); }\n-    }\n+    auto proto = parse_proto(p);\n     auto ident = parse_ident(p);\n-    auto f = parse_fn(p, eff, is_iter);\n+    auto f = parse_fn(p, eff, proto);\n     auto meth = rec(ident=ident, meth=f,\n                     id=p.next_def_id(), ann=ast.ann_none);\n     ret @spanned(lo, f.body.span, meth);\n@@ -1689,11 +1701,11 @@ impure fn parse_item_native_type(parser p) -> @ast.native_item {\n }\n \n impure fn parse_item_native_fn(parser p, ast.effect eff) -> @ast.native_item {\n-    auto t = parse_fn_header(p, false);\n-    auto decl = parse_fn_decl(p, eff);\n+    auto t = parse_fn_header(p);\n+    auto decl = parse_fn_decl(p, t._1, eff);\n     auto hi = p.get_span();\n     expect(p, token.SEMI);\n-    auto item = ast.native_item_fn(t._1, decl, t._2, p.next_def_id(),\n+    auto item = ast.native_item_fn(t._2, decl, t._3, p.next_def_id(),\n                                    ast.ann_none);\n     ret @spanned(t._0, hi, item);\n }\n@@ -1883,11 +1895,11 @@ impure fn parse_item(parser p) -> @ast.item {\n \n         case (token.FN) {\n             check (lyr == ast.layer_value);\n-            ret parse_item_fn_or_iter(p, eff, false);\n+            ret parse_item_fn_or_iter(p, eff);\n         }\n         case (token.ITER) {\n             check (lyr == ast.layer_value);\n-            ret parse_item_fn_or_iter(p, eff, true);\n+            ret parse_item_fn_or_iter(p, eff);\n         }\n         case (token.MOD) {\n             check (eff == ast.eff_pure);"}, {"sha": "abe94b8919ec78e7681c76d3f0837fc38914a771", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=34c60b6edb810d9f142d248b27d8e6e34c95d63c", "patch": "@@ -59,6 +59,7 @@ type ast_fold[ENV] =\n          vec[ast.ty_method] meths) -> @ty)        fold_ty_obj,\n \n      (fn(&ENV e, &span sp,\n+         ast.proto proto,\n          vec[rec(ast.mode mode, @ty ty)] inputs,\n          @ty output) -> @ty)                      fold_ty_fn,\n \n@@ -252,11 +253,10 @@ type ast_fold[ENV] =\n          &ast.block_) -> block)                   fold_block,\n \n      (fn(&ENV e, &fn_decl decl,\n-         bool is_iter,\n          &block body) -> ast._fn)                 fold_fn,\n \n      (fn(&ENV e, ast.effect effect,\n-         vec[arg] inputs,\n+         ast.proto proto, vec[arg] inputs,\n          @ty output) -> ast.fn_decl)              fold_fn_decl,\n \n      (fn(&ENV e, &ast._mod m) -> ast._mod)        fold_mod,\n@@ -349,11 +349,13 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n         case (ast.ty_obj(?meths)) {\n             let vec[ast.ty_method] meths_ = vec();\n             for (ast.ty_method m in meths) {\n-                auto tfn = fold_ty_fn(env_, fld, t.span, m.inputs, m.output);\n+                auto tfn = fold_ty_fn(env_, fld, t.span, m.proto,\n+                                      m.inputs, m.output);\n                 alt (tfn.node) {\n-                    case (ast.ty_fn(?ins, ?out)) {\n+                    case (ast.ty_fn(?p, ?ins, ?out)) {\n                         append[ast.ty_method]\n-                            (meths_, rec(inputs=ins, output=out with m));\n+                            (meths_, rec(proto=p, inputs=ins, output=out\n+                                         with m));\n                     }\n                 }\n             }\n@@ -370,13 +372,14 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n             ret fld.fold_ty_mutable(env_, t.span, ty_);\n         }\n \n-        case (ast.ty_fn(?inputs, ?output)) {\n-            ret fold_ty_fn(env_, fld, t.span, inputs, output);\n+        case (ast.ty_fn(?proto, ?inputs, ?output)) {\n+            ret fold_ty_fn(env_, fld, t.span, proto, inputs, output);\n         }\n     }\n }\n \n fn fold_ty_fn[ENV](&ENV env, ast_fold[ENV] fld, &span sp,\n+                   ast.proto proto,\n                    vec[rec(ast.mode mode, @ty ty)] inputs,\n                    @ty output) -> @ty {\n     auto output_ = fold_ty(env, fld, output);\n@@ -386,7 +389,7 @@ fn fold_ty_fn[ENV](&ENV env, ast_fold[ENV] fld, &span sp,\n         auto input_ = rec(ty=ty_ with input);\n         inputs_ += vec(input_);\n     }\n-    ret fld.fold_ty_fn(env, sp, inputs_, output_);\n+    ret fld.fold_ty_fn(env, sp, proto, inputs_, output_);\n }\n \n fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n@@ -754,15 +757,15 @@ fn fold_fn_decl[ENV](&ENV env, ast_fold[ENV] fld,\n         inputs += fold_arg(env, fld, a);\n     }\n     auto output = fold_ty[ENV](env, fld, decl.output);\n-    ret fld.fold_fn_decl(env, decl.effect, inputs, output);\n+    ret fld.fold_fn_decl(env, decl.effect, decl.proto, inputs, output);\n }\n \n fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n     auto decl = fold_fn_decl(env, fld, f.decl);\n \n     auto body = fold_block[ENV](env, fld, f.body);\n \n-    ret fld.fold_fn(env, decl, f.is_iter, body);\n+    ret fld.fold_fn(env, decl, body);\n }\n \n \n@@ -1019,9 +1022,10 @@ fn identity_fold_ty_obj[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_ty_fn[ENV](&ENV env, &span sp,\n+                            ast.proto proto,\n                             vec[rec(ast.mode mode, @ty ty)] inputs,\n                             @ty output) -> @ty {\n-    ret @respan(sp, ast.ty_fn(inputs, output));\n+    ret @respan(sp, ast.ty_fn(proto, inputs, output));\n }\n \n fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n@@ -1301,16 +1305,16 @@ fn identity_fold_block[ENV](&ENV e, &span sp, &ast.block_ blk) -> block {\n \n fn identity_fold_fn_decl[ENV](&ENV e,\n                               ast.effect effect,\n+                              ast.proto proto,\n                               vec[arg] inputs,\n                               @ty output) -> ast.fn_decl {\n-    ret rec(effect=effect, inputs=inputs, output=output);\n+    ret rec(effect=effect, proto=proto, inputs=inputs, output=output);\n }\n \n fn identity_fold_fn[ENV](&ENV e,\n                          &fn_decl decl,\n-                         bool is_iter,\n                          &block body) -> ast._fn {\n-    ret rec(decl=decl, is_iter=is_iter, body=body);\n+    ret rec(decl=decl, body=body);\n }\n \n fn identity_fold_mod[ENV](&ENV e, &ast._mod m) -> ast._mod {\n@@ -1404,7 +1408,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_ty_tup     = bind identity_fold_ty_tup[ENV](_,_,_),\n          fold_ty_rec     = bind identity_fold_ty_rec[ENV](_,_,_),\n          fold_ty_obj     = bind identity_fold_ty_obj[ENV](_,_,_),\n-         fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_),\n+         fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_,_),\n          fold_ty_path    = bind identity_fold_ty_path[ENV](_,_,_,_),\n          fold_ty_mutable = bind identity_fold_ty_mutable[ENV](_,_,_),\n \n@@ -1470,8 +1474,8 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n              bind identity_fold_view_item_import[ENV](_,_,_,_,_,_),\n \n          fold_block = bind identity_fold_block[ENV](_,_,_),\n-         fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n-         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_),\n+         fold_fn = bind identity_fold_fn[ENV](_,_,_),\n+         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_,_),\n          fold_mod = bind identity_fold_mod[ENV](_,_),\n          fold_native_mod = bind identity_fold_native_mod[ENV](_,_),\n          fold_crate = bind identity_fold_crate[ENV](_,_,_),"}, {"sha": "03d1fad99092eafe19c072e9c1303943fa9be0de", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=34c60b6edb810d9f142d248b27d8e6e34c95d63c", "patch": "@@ -449,8 +449,7 @@ fn type_of_explicit_args(@crate_ctxt cx,\n //  - trans_args\n \n fn type_of_fn_full(@crate_ctxt cx,\n-                   // FIXME: change bool flag to tag\n-                   bool is_iter,\n+                   ast.proto proto,\n                    option.t[TypeRef] obj_self,\n                    vec[ty.arg] inputs,\n                    @ty.t output) -> TypeRef {\n@@ -480,20 +479,22 @@ fn type_of_fn_full(@crate_ctxt cx,\n     // Args >3: ty params, if not acquired via capture...\n     if (obj_self == none[TypeRef]) {\n         auto ty_param_count =\n-            ty.count_ty_params(plain_ty(ty.ty_fn(inputs, output)));\n+            ty.count_ty_params(plain_ty(ty.ty_fn(proto,\n+                                                 inputs,\n+                                                 output)));\n         auto i = 0u;\n         while (i < ty_param_count) {\n             atys += T_ptr(T_tydesc(cx.tn));\n             i += 1u;\n         }\n     }\n \n-    if (is_iter) {\n+    if (proto == ast.proto_iter) {\n         // If it's an iter, the 'output' type of the iter is actually the\n         // *input* type of the function we're given as our iter-block\n         // argument.\n         atys += T_fn_pair(cx.tn,\n-                          type_of_fn_full(cx, false, none[TypeRef],\n+                          type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=output)),\n                                           plain_ty(ty.ty_nil)));\n     }\n@@ -505,10 +506,9 @@ fn type_of_fn_full(@crate_ctxt cx,\n }\n \n fn type_of_fn(@crate_ctxt cx,\n-              // FIXME: change bool flag to tag\n-              bool is_iter,\n+              ast.proto proto,\n               vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n-    ret type_of_fn_full(cx, is_iter, none[TypeRef], inputs, output);\n+    ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output);\n }\n \n fn type_of_native_fn(@crate_ctxt cx, vec[ty.arg] inputs,\n@@ -563,9 +563,8 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             }\n             ret T_struct(tys);\n         }\n-        case (ty.ty_fn(?args, ?out)) {\n-            // FIXME: put iter in ty_fn.\n-            ret T_fn_pair(cx.tn, type_of_fn(cx, false, args, out));\n+        case (ty.ty_fn(?proto, ?args, ?out)) {\n+            ret T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out));\n         }\n         case (ty.ty_native_fn(?args, ?out)) {\n             ret T_fn_pair(cx.tn, type_of_native_fn(cx, args, out));\n@@ -577,9 +576,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             let vec[TypeRef] mtys = vec();\n             for (ty.method m in meths) {\n                 let TypeRef mty =\n-                    type_of_fn_full(cx,\n-                                    // FIXME: support method iters\n-                                    false,\n+                    type_of_fn_full(cx, m.proto,\n                                     some[TypeRef](self_ty),\n                                     m.inputs, m.output);\n                 mtys += T_ptr(mty);\n@@ -1339,7 +1336,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                                         T_int(), C_int(0));\n         }\n \n-        case (ty.ty_fn(_,_)) {\n+        case (ty.ty_fn(_,_,_)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n \n                 // Call through the closure's own fields-drop glue first.\n@@ -1440,7 +1437,7 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n fn type_of_variant(@crate_ctxt cx, &ast.variant v) -> TypeRef {\n     let vec[TypeRef] lltys = vec();\n     alt (ty.ann_to_type(v.ann).struct) {\n-        case (ty.ty_fn(?args, _)) {\n+        case (ty.ty_fn(_, ?args, _)) {\n             for (ty.arg arg in args) {\n                 lltys += vec(type_of(cx, arg.ty));\n             }\n@@ -1547,7 +1544,7 @@ fn iter_structural_ty(@block_ctxt cx,\n \n                         auto fn_ty = ty.ann_to_type(variants.(i).ann);\n                         alt (fn_ty.struct) {\n-                            case (ty.ty_fn(?args, _)) {\n+                            case (ty.ty_fn(_, ?args, _)) {\n                                 auto llvarp = variant_cx.build.\n                                     TruncOrBitCast(llunion_ptr,\n                                                    T_ptr(llvarty));\n@@ -1584,7 +1581,7 @@ fn iter_structural_ty(@block_ctxt cx,\n \n             ret res(next_cx, C_nil());\n         }\n-        case (ty.ty_fn(_,_)) {\n+        case (ty.ty_fn(_,_,_)) {\n             auto box_cell =\n                 cx.build.GEP(v,\n                              vec(C_int(0),\n@@ -2264,31 +2261,35 @@ fn trans_for_each(@block_ctxt cx,\n     // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n     // and pass it in as a first class fn-arg to the iterator.\n \n-    auto foreach_llty = type_of_fn_full(cx.fcx.ccx, false, none[TypeRef],\n-                                        vec(rec(mode=ast.val, ty=decl_ty)),\n-                                        plain_ty(ty.ty_nil));\n+    auto iter_body_llty = type_of_fn_full(cx.fcx.ccx, ast.proto_fn,\n+                                          none[TypeRef],\n+                                          vec(rec(mode=ast.val, ty=decl_ty)),\n+                                          plain_ty(ty.ty_nil));\n \n-    let ValueRef llforeach = decl_fastcall_fn(cx.fcx.ccx.llmod,\n-                                              s, foreach_llty);\n+    let ValueRef lliterbody = decl_fastcall_fn(cx.fcx.ccx.llmod,\n+                                               s, iter_body_llty);\n \n     // FIXME: handle ty params properly.\n     let vec[ast.ty_param] ty_params = vec();\n \n-    auto fcx = new_fn_ctxt(cx.fcx.ccx, s, llforeach);\n+    auto fcx = new_fn_ctxt(cx.fcx.ccx, s, lliterbody);\n     auto bcx = new_top_block_ctxt(fcx);\n \n     // FIXME: populate lllocals from llenv here.\n     auto res = trans_block(bcx, body);\n     res.bcx.build.RetVoid();\n \n \n-    // Step 3: Call iter passing [llforeach, llenv], plus other args.\n+    // Step 3: Call iter passing [lliterbody, llenv], plus other args.\n \n     alt (seq.node) {\n         case (ast.expr_call(?f, ?args, ?ann)) {\n-            // FIXME_ finish here by transferring to trans_call,\n-            // suitably refactored.\n-            cx.fcx.ccx.sess.unimpl(\"for each loop in trans\");\n+\n+            // log \"lliterbody: \" + val_str(cx.fcx.ccx.tn, lliterbody);\n+            ret trans_call(cx, f,\n+                           some[ValueRef](lliterbody),\n+                           args,\n+                           ann);\n         }\n     }\n     fail;\n@@ -2933,6 +2934,7 @@ fn trans_args(@block_ctxt cx,\n               ValueRef llenv,\n               option.t[ValueRef] llobj,\n               option.t[generic_info] gen,\n+              option.t[ValueRef] lliterbody,\n               &vec[@ast.expr] es,\n               @ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef], ValueRef) {\n@@ -2993,6 +2995,14 @@ fn trans_args(@block_ctxt cx,\n     // Args >3: ty_params ...\n     llargs += lltydescs;\n \n+    // ... then possibly an lliterbody argument.\n+    alt (lliterbody) {\n+        case (none[ValueRef]) {}\n+        case (some[ValueRef](?lli)) {\n+            llargs += lli;\n+        }\n+    }\n+\n     // ... then explicit args.\n     auto i = 0u;\n     for (@ast.expr e in es) {\n@@ -3048,7 +3058,9 @@ fn trans_args(@block_ctxt cx,\n }\n \n fn trans_call(@block_ctxt cx, @ast.expr f,\n-              vec[@ast.expr] args, &ast.ann ann) -> result {\n+              option.t[ValueRef] lliterbody,\n+              vec[@ast.expr] args,\n+              &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     auto faddr = f_res.res.val;\n     auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.ccx.tn));\n@@ -3077,12 +3089,21 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     auto args_res = trans_args(f_res.res.bcx,\n                                llenv, f_res.llobj,\n                                f_res.generic,\n+                               lliterbody,\n                                args, fn_ty);\n \n     auto bcx = args_res._0;\n     auto llargs = args_res._1;\n     auto llretslot = args_res._2;\n \n+    /*\n+    log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n+\n+    for (ValueRef arg in llargs) {\n+        log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n+    }\n+    */\n+\n     bcx.build.FastCall(faddr, llargs);\n     auto retval = C_nil();\n \n@@ -3308,7 +3329,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         }\n \n         case (ast.expr_call(?f, ?args, ?ann)) {\n-            ret trans_call(cx, f, args, ann);\n+            ret trans_call(cx, f, none[ValueRef], args, ann);\n         }\n \n         case (ast.expr_cast(?e, _, ?ann)) {\n@@ -3707,8 +3728,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n //  - trans_args\n \n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n-                             // FIXME: change bool flag to tag\n-                             bool is_iter,\n+                             ast.proto proto,\n                              option.t[TypeRef] ty_self,\n                              @ty.t ret_ty,\n                              &vec[ast.arg] args,\n@@ -3733,7 +3753,7 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n         }\n     }\n \n-    if (is_iter) {\n+    if (proto == ast.proto_iter) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n         check (llarg as int != 0);\n         cx.lliterbody = some[ValueRef](llarg);\n@@ -3794,7 +3814,7 @@ fn is_terminated(@block_ctxt cx) -> bool {\n \n fn arg_tys_of_fn(ast.ann ann) -> vec[ty.arg] {\n     alt (ty.ann_to_type(ann).struct) {\n-        case (ty.ty_fn(?arg_tys, _)) {\n+        case (ty.ty_fn(_, ?arg_tys, _)) {\n             ret arg_tys;\n         }\n     }\n@@ -3803,7 +3823,7 @@ fn arg_tys_of_fn(ast.ann ann) -> vec[ty.arg] {\n \n fn ret_ty_of_fn_ty(@ty.t t) -> @ty.t {\n     alt (t.struct) {\n-        case (ty.ty_fn(_, ?ret_ty)) {\n+        case (ty.ty_fn(_, _, ?ret_ty)) {\n             ret ret_ty;\n         }\n     }\n@@ -3875,7 +3895,7 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     cx.item_names.insert(cx.path, llfndecl);\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llfndecl);\n-    create_llargs_for_fn_args(fcx, f.is_iter,\n+    create_llargs_for_fn_args(fcx, f.decl.proto,\n                               ty_self, ret_ty_of_fn(ann),\n                               f.decl.inputs, ty_params);\n     auto bcx = new_top_block_ctxt(fcx);\n@@ -3915,10 +3935,8 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n \n         auto llfnty = T_nil();\n         alt (node_ann_type(cx, m.node.ann).struct) {\n-            case (ty.ty_fn(?inputs, ?output)) {\n-                llfnty = type_of_fn_full(cx,\n-                                         // FIXME: support method iters.\n-                                         false,\n+            case (ty.ty_fn(?proto, ?inputs, ?output)) {\n+                llfnty = type_of_fn_full(cx, proto,\n                                          some[TypeRef](self_ty),\n                                          inputs, output);\n             }\n@@ -3962,7 +3980,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     }\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llctor_decl);\n-    create_llargs_for_fn_args(fcx, false,\n+    create_llargs_for_fn_args(fcx, ast.proto_fn,\n                               none[TypeRef], ret_ty_of_fn(ann),\n                               fn_args, ty_params);\n \n@@ -4091,7 +4109,7 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     let ValueRef llfndecl = cx.item_ids.get(variant.id);\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llfndecl);\n-    create_llargs_for_fn_args(fcx, false,\n+    create_llargs_for_fn_args(fcx, ast.proto_fn,\n                               none[TypeRef], ret_ty_of_fn(variant.ann),\n                               fn_args, ty_params);\n "}, {"sha": "68c2114078cf5226db7c2039d4bfb25c641031bd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 136, "deletions": 107, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=34c60b6edb810d9f142d248b27d8e6e34c95d63c", "patch": "@@ -19,7 +19,10 @@ import util.common.span;\n \n type arg = rec(ast.mode mode, @t ty);\n type field = rec(ast.ident ident, @t ty);\n-type method = rec(ast.ident ident, vec[arg] inputs, @t output);\n+type method = rec(ast.proto proto,\n+                  ast.ident ident,\n+                  vec[arg] inputs,\n+                  @t output);\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n@@ -37,7 +40,7 @@ tag sty {\n     ty_vec(@t);\n     ty_tup(vec[@t]);\n     ty_rec(vec[field]);\n-    ty_fn(vec[arg], @t);                            // TODO: effect\n+    ty_fn(ast.proto, vec[arg], @t);                 // TODO: effect\n     ty_native_fn(vec[arg], @t);                     // TODO: effect\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n@@ -122,9 +125,13 @@ fn ast_ty_to_str(&@ast.ty ty) -> str {\n             s += \")\";\n         }\n \n-        case (ast.ty_fn(?inputs, ?output)) {\n+        case (ast.ty_fn(?proto, ?inputs, ?output)) {\n             auto f = ast_fn_input_to_str;\n-            s = \"fn(\";\n+            if (proto == ast.proto_fn) {\n+                s = \"fn(\";\n+            } else {\n+                s = \"iter(\";\n+            }\n             auto is = _vec.map[rec(ast.mode mode, @ast.ty ty),str](f, inputs);\n             s += _str.connect(is, \", \");\n             s += \")\";\n@@ -175,10 +182,14 @@ fn ty_to_str(&@t typ) -> str {\n         ret s + ty_to_str(input.ty);\n     }\n \n-    fn fn_to_str(option.t[ast.ident] ident,\n+    fn fn_to_str(ast.proto proto,\n+                 option.t[ast.ident] ident,\n                  vec[arg] inputs, @t output) -> str {\n             auto f = fn_input_to_str;\n             auto s = \"fn\";\n+            if (proto == ast.proto_iter) {\n+                s = \"iter\";\n+            }\n             alt (ident) {\n                 case (some[ast.ident](?i)) {\n                     s += \" \";\n@@ -198,7 +209,8 @@ fn ty_to_str(&@t typ) -> str {\n     }\n \n     fn method_to_str(&method m) -> str {\n-        ret fn_to_str(some[ast.ident](m.ident), m.inputs, m.output) + \";\";\n+        ret fn_to_str(m.proto, some[ast.ident](m.ident),\n+                      m.inputs, m.output) + \";\";\n     }\n \n     fn field_to_str(&field f) -> str {\n@@ -245,12 +257,12 @@ fn ty_to_str(&@t typ) -> str {\n             }\n         }\n \n-        case (ty_fn(?inputs, ?output)) {\n-            s = fn_to_str(none[ast.ident], inputs, output);\n+        case (ty_fn(?proto, ?inputs, ?output)) {\n+            s = fn_to_str(proto, none[ast.ident], inputs, output);\n         }\n \n         case (ty_native_fn(?inputs, ?output)) {\n-            s = fn_to_str(none[ast.ident], inputs, output);\n+            s = fn_to_str(ast.proto_fn, none[ast.ident], inputs, output);\n         }\n \n         case (ty_obj(?meths)) {\n@@ -326,13 +338,13 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n             }\n             ret rewrap(ty, ty_rec(new_fields));\n         }\n-        case (ty_fn(?args, ?ret_ty)) {\n+        case (ty_fn(?proto, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n                 auto new_ty = fold_ty(fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ret rewrap(ty, ty_fn(new_args, fold_ty(fld, ret_ty)));\n+            ret rewrap(ty, ty_fn(proto, new_args, fold_ty(fld, ret_ty)));\n         }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n@@ -341,7 +353,8 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n                 for (arg a in m.inputs) {\n                     new_args += vec(rec(mode=a.mode, ty=fold_ty(fld, a.ty)));\n                 }\n-                new_methods += vec(rec(ident=m.ident, inputs=new_args,\n+                new_methods += vec(rec(proto=m.proto, ident=m.ident,\n+                                       inputs=new_args,\n                                        output=fold_ty(fld, m.output)));\n             }\n             ret rewrap(ty, ty_obj(new_methods));\n@@ -378,7 +391,7 @@ fn type_is_structural(@t ty) -> bool {\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n         case (ty_tag(_,_))  { ret true; }\n-        case (ty_fn(_,_))   { ret true; }\n+        case (ty_fn(_,_,_)) { ret true; }\n         case (ty_obj(_))    { ret true; }\n         case (_)            { ret false; }\n     }\n@@ -573,23 +586,29 @@ fn count_ty_params(@t ty) -> uint {\n // Type accessors for substructures of types\n \n fn ty_fn_args(@t fty) -> vec[arg] {\n-  alt (fty.struct) {\n-    case (ty.ty_fn(?a, _)) { ret a; }\n-  }\n+    alt (fty.struct) {\n+        case (ty.ty_fn(_, ?a, _)) { ret a; }\n+    }\n+}\n+\n+fn ty_fn_proto(@t fty) -> ast.proto {\n+    alt (fty.struct) {\n+        case (ty.ty_fn(?p, _, _)) { ret p; }\n+    }\n }\n \n fn ty_fn_ret(@t fty) -> @t {\n-  alt (fty.struct) {\n-    case (ty.ty_fn(_, ?r)) { ret r; }\n-  }\n+    alt (fty.struct) {\n+        case (ty.ty_fn(_, _, ?r)) { ret r; }\n+    }\n }\n \n fn is_fn_ty(@t fty) -> bool {\n-  alt (fty.struct) {\n-    case (ty.ty_fn(_, _)) { ret true; }\n-    case (_) { ret false; }\n-  }\n-  ret false;\n+    alt (fty.struct) {\n+        case (ty.ty_fn(_, _, _)) { ret true; }\n+        case (_) { ret false; }\n+    }\n+    ret false;\n }\n \n \n@@ -808,80 +827,87 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n     }\n \n     fn unify_fn(@hashmap[int,@ty.t] bindings,\n+                ast.proto e_proto,\n+                ast.proto a_proto,\n                 @ty.t expected,\n                 @ty.t actual,\n                 &unify_handler handler,\n                 vec[arg] expected_inputs, @t expected_output,\n                 vec[arg] actual_inputs, @t actual_output)\n-      -> unify_result {\n-      auto expected_len = _vec.len[arg](expected_inputs);\n-      auto actual_len = _vec.len[arg](actual_inputs);\n-      if (expected_len != actual_len) {\n-        ret ures_err(terr_arg_count, expected, actual);\n-      }\n+        -> unify_result {\n \n-      // TODO: as above, we should have an iter2 iterator.\n-      let vec[arg] result_ins = vec();\n-      auto i = 0u;\n-      while (i < expected_len) {\n-        auto expected_input = expected_inputs.(i);\n-        auto actual_input = actual_inputs.(i);\n-\n-        // This should be safe, I think?\n-        auto result_mode;\n-        if (mode_is_alias(expected_input.mode) ||\n-            mode_is_alias(actual_input.mode)) {\n-          result_mode = ast.alias;\n-        } else {\n-          result_mode = ast.val;\n+        if (e_proto != a_proto) {\n+            ret ures_err(terr_mismatch, expected, actual);\n         }\n \n-        auto result = unify_step(bindings,\n-                                 actual_input.ty,\n-                                 expected_input.ty,\n-                                 handler);\n+        auto expected_len = _vec.len[arg](expected_inputs);\n+        auto actual_len = _vec.len[arg](actual_inputs);\n+        if (expected_len != actual_len) {\n+            ret ures_err(terr_arg_count, expected, actual);\n+        }\n \n-        alt (result) {\n-          case (ures_ok(?rty)) {\n-            result_ins += vec(rec(mode=result_mode,\n-                                  ty=rty));\n-          }\n+        // TODO: as above, we should have an iter2 iterator.\n+        let vec[arg] result_ins = vec();\n+        auto i = 0u;\n+        while (i < expected_len) {\n+            auto expected_input = expected_inputs.(i);\n+            auto actual_input = actual_inputs.(i);\n \n-          case (_) {\n-            ret result;\n-          }\n-        }\n+            // This should be safe, I think?\n+            auto result_mode;\n+            if (mode_is_alias(expected_input.mode) ||\n+                mode_is_alias(actual_input.mode)) {\n+                result_mode = ast.alias;\n+            } else {\n+                result_mode = ast.val;\n+            }\n \n-        i += 1u;\n-      }\n+            auto result = unify_step(bindings,\n+                                     actual_input.ty,\n+                                     expected_input.ty,\n+                                     handler);\n \n-      // Check the output.\n-      auto result_out;\n-      auto result = unify_step(bindings,\n-                               expected_output,\n-                               actual_output,\n-                               handler);\n-      alt (result) {\n-        case (ures_ok(?rty)) {\n-          result_out = rty;\n+            alt (result) {\n+                case (ures_ok(?rty)) {\n+                    result_ins += vec(rec(mode=result_mode,\n+                                          ty=rty));\n+                }\n+\n+                case (_) {\n+                    ret result;\n+                }\n+            }\n+\n+            i += 1u;\n         }\n \n-        case (_) {\n-          ret result;\n+        // Check the output.\n+        auto result_out;\n+        auto result = unify_step(bindings,\n+                                 expected_output,\n+                                 actual_output,\n+                                 handler);\n+        alt (result) {\n+            case (ures_ok(?rty)) {\n+                result_out = rty;\n+            }\n+\n+            case (_) {\n+                ret result;\n+            }\n         }\n-      }\n \n-      auto t = plain_ty(ty.ty_fn(result_ins, result_out));\n-      ret ures_ok(t);\n+        auto t = plain_ty(ty.ty_fn(e_proto, result_ins, result_out));\n+        ret ures_ok(t);\n \n     }\n \n     fn unify_obj(@hashmap[int,@ty.t] bindings,\n-                @ty.t expected,\n-                @ty.t actual,\n-                &unify_handler handler,\n-                vec[method] expected_meths,\n-                vec[method] actual_meths) -> unify_result {\n+                 @ty.t expected,\n+                 @ty.t actual,\n+                 &unify_handler handler,\n+                 vec[method] expected_meths,\n+                 vec[method] actual_meths) -> unify_result {\n       let vec[method] result_meths = vec();\n       let uint i = 0u;\n       let uint expected_len = _vec.len[method](expected_meths);\n@@ -893,28 +919,28 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n \n       // FIXME: work around buggy typestate logic for 'alt', sigh.\n       fn is_ok(&unify_result r) -> bool {\n-        alt (r) {\n-          case (ures_ok(?tfn)) {\n-            ret true;\n+          alt (r) {\n+              case (ures_ok(?tfn)) {\n+                  ret true;\n+              }\n+              case (_) {}\n           }\n-          case (_) {}\n-        }\n-        ret false;\n+          ret false;\n       }\n \n       fn append_if_ok(&method e_meth,\n                       &unify_result r, &mutable vec[method] result_meths) {\n-        alt (r) {\n-          case (ures_ok(?tfn)) {\n-            alt (tfn.struct) {\n-              case (ty_fn(?ins, ?out)) {\n-                result_meths += vec(rec(inputs = ins,\n-                                        output = out\n-                                        with e_meth));\n+          alt (r) {\n+              case (ures_ok(?tfn)) {\n+                  alt (tfn.struct) {\n+                      case (ty_fn(?proto, ?ins, ?out)) {\n+                          result_meths += vec(rec(inputs = ins,\n+                                                  output = out\n+                                                  with e_meth));\n+                      }\n+                  }\n               }\n-            }\n           }\n-        }\n       }\n \n       while (i < expected_len) {\n@@ -924,7 +950,9 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n           ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident),\n                        expected, actual);\n         }\n-        auto r = unify_fn(bindings, expected, actual, handler,\n+        auto r = unify_fn(bindings,\n+                          e_meth.proto, a_meth.proto,\n+                          expected, actual, handler,\n                           e_meth.inputs, e_meth.output,\n                           a_meth.inputs, a_meth.output);\n         if (!is_ok(r)) {\n@@ -1215,12 +1243,13 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 }\n             }\n \n-            case (ty.ty_fn(?expected_inputs, ?expected_output)) {\n+            case (ty.ty_fn(?ep, ?expected_inputs, ?expected_output)) {\n                 alt (actual.struct) {\n-                    case (ty.ty_fn(?actual_inputs, ?actual_output)) {\n-                      ret unify_fn(bindings, expected, actual, handler,\n-                                   expected_inputs, expected_output,\n-                                   actual_inputs, actual_output);\n+                    case (ty.ty_fn(?ap, ?actual_inputs, ?actual_output)) {\n+                        ret unify_fn(bindings, ep, ap,\n+                                     expected, actual, handler,\n+                                     expected_inputs, expected_output,\n+                                     actual_inputs, actual_output);\n                     }\n \n                     case (_) {\n@@ -1230,15 +1259,15 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             }\n \n             case (ty.ty_obj(?expected_meths)) {\n-              alt (actual.struct) {\n-                case (ty.ty_obj(?actual_meths)) {\n-                  ret unify_obj(bindings, expected, actual, handler,\n-                                expected_meths, actual_meths);\n-                }\n-                case (_) {\n-                  ret ures_err(terr_mismatch, expected, actual);\n+                alt (actual.struct) {\n+                    case (ty.ty_obj(?actual_meths)) {\n+                        ret unify_obj(bindings, expected, actual, handler,\n+                                      expected_meths, actual_meths);\n+                    }\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n                 }\n-              }\n             }\n \n             case (ty.ty_var(?expected_id)) {"}, {"sha": "ee92d8d7406af5be5f867d33771ea3f2141af296", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c60b6edb810d9f142d248b27d8e6e34c95d63c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=34c60b6edb810d9f142d248b27d8e6e34c95d63c", "patch": "@@ -155,10 +155,10 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n             sty = ty.ty_rec(flds);\n         }\n \n-        case (ast.ty_fn(?inputs, ?output)) {\n+        case (ast.ty_fn(?proto, ?inputs, ?output)) {\n             auto f = bind ast_arg_to_arg(getter, _);\n             auto i = _vec.map[ast.ty_arg, arg](f, inputs);\n-            sty = ty.ty_fn(i, ast_ty_to_ty(getter, output));\n+            sty = ty.ty_fn(proto, i, ast_ty_to_ty(getter, output));\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n@@ -194,7 +194,8 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n                 auto ins = _vec.map[ast.ty_arg, arg](f, m.inputs);\n                 auto out = ast_ty_to_ty(getter, m.output);\n                 append[ty.method](tmeths,\n-                                  rec(ident=m.ident,\n+                                  rec(proto=m.proto,\n+                                      ident=m.ident,\n                                       inputs=ins,\n                                       output=out));\n             }\n@@ -295,7 +296,7 @@ fn ty_of_fn_decl(@ty_item_table id_to_ty_item,\n                  ast.def_id def_id) -> @ty.t {\n     auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n     auto output_ty = convert(decl.output);\n-    auto t_fn = plain_ty(ty.ty_fn(input_tys, output_ty));\n+    auto t_fn = plain_ty(ty.ty_fn(decl.proto, input_tys, output_ty));\n     item_to_ty.insert(def_id, t_fn);\n     ret t_fn;\n }\n@@ -354,7 +355,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         auto f = bind ty_of_arg(id_to_ty_item, item_to_ty, _);\n         auto inputs = _vec.map[ast.arg,arg](f, m.node.meth.decl.inputs);\n         auto output = convert(m.node.meth.decl.output);\n-        ret rec(ident=m.node.ident, inputs=inputs, output=output);\n+        ret rec(proto=m.node.meth.decl.proto, ident=m.node.ident,\n+                inputs=inputs, output=output);\n     }\n \n     fn ty_of_obj(@ty_item_table id_to_ty_item,\n@@ -385,7 +387,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             auto t_field = ast_ty_to_ty(g, f.ty);\n             append[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n-        auto t_fn = plain_ty(ty.ty_fn(t_inputs, t_obj));\n+        auto t_fn = plain_ty(ty.ty_fn(ast.proto_fn, t_inputs, t_obj));\n         ret t_fn;\n     }\n \n@@ -501,7 +503,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     args += vec(rec(mode=ast.alias, ty=arg_ty));\n                 }\n                 auto tag_t = plain_ty(ty.ty_tag(tag_id, ty_param_tys));\n-                result_ty = plain_ty(ty.ty_fn(args, tag_t));\n+                result_ty = plain_ty(ty.ty_fn(ast.proto_fn, args, tag_t));\n             }\n \n             item_to_ty.insert(variant.id, result_ty);\n@@ -615,7 +617,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n     fn get_ctor_obj_methods(@ty.t t) -> vec[method] {\n         alt (t.struct) {\n-            case (ty.ty_fn(_,?tobj)) {\n+            case (ty.ty_fn(_,_,?tobj)) {\n                 alt (tobj.struct) {\n                     case (ty.ty_obj(?tm)) {\n                         ret tm;\n@@ -650,7 +652,8 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             let method meth_ty = meth_tys.(ix);\n             let ast.method_ m_;\n             let @ast.method m;\n-            auto meth_tfn = plain_ty(ty.ty_fn(meth_ty.inputs,\n+            auto meth_tfn = plain_ty(ty.ty_fn(meth_ty.proto,\n+                                              meth_ty.inputs,\n                                               meth_ty.output));\n             m_ = rec(ann=ast.ann_type(meth_tfn) with meth.node);\n             m = @rec(node=m_ with *meth);\n@@ -877,7 +880,7 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n                     check (subpats_len == 0u);\n                     p_1 = ast.pat_tag(id, subpats, vdef_opt, ast.ann_type(t));\n                 }\n-                case (ty.ty_fn(?args, ?tag_ty)) {\n+                case (ty.ty_fn(_, ?args, ?tag_ty)) {\n                     let vec[@ast.pat] new_subpats = vec();\n                     auto i = 0u;\n                     for (arg a in args) {\n@@ -1189,7 +1192,7 @@ fn check_pat(&@fn_ctxt fcx, @ast.pat pat) -> @ast.pat {\n             auto last_id = p.node.idents.(len - 1u);\n             alt (t.struct) {\n                 // N-ary variants have function types.\n-                case (ty.ty_fn(?args, ?tag_ty)) {\n+                case (ty.ty_fn(_, ?args, ?tag_ty)) {\n                     auto arg_len = _vec.len[arg](args);\n                     auto subpats_len = _vec.len[@ast.pat](subpats);\n                     if (arg_len != subpats_len) {\n@@ -1628,6 +1631,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                       ty_to_str(t_0));\n             }\n \n+            let ast.proto proto = ty.ty_fn_proto(t_0);\n             let vec[arg] arg_tys_0 = ty.ty_fn_args(t_0);\n             let @ty.t rt_0 = ty.ty_fn_ret(t_0);\n             let vec[option.t[@ast.expr]] args_1 = vec();\n@@ -1654,7 +1658,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 i += 1u;\n             }\n \n-            let @ty.t t_1 = plain_ty(ty.ty_fn(residual_args, rt_0));\n+            let @ty.t t_1 = plain_ty(ty.ty_fn(proto,\n+                                              residual_args, rt_0));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(f_0, args_1,\n                                                       ast.ann_type(t_1)));\n@@ -1677,7 +1682,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 append[arg](arg_tys_0, rec(mode=ast.val, ty=expr_ty(a_0)));\n             }\n             auto rt_0 = next_ty_var(fcx.ccx);\n-            auto t_0 = plain_ty(ty.ty_fn(arg_tys_0, rt_0));\n+            auto t_0 = plain_ty(ty.ty_fn(ty.ty_fn_proto(expr_ty(f_0)),\n+                                         arg_tys_0, rt_0));\n \n             // Unify and write back to the function.\n             auto f_1 = demand_expr(fcx, t_0, f_0);\n@@ -1877,7 +1883,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                               \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n-                    auto t = plain_ty(ty.ty_fn(meth.inputs, meth.output));\n+                    auto t = plain_ty(ty.ty_fn(meth.proto,\n+                                               meth.inputs, meth.output));\n                     auto ann = ast.ann_type(t);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n@@ -2047,8 +2054,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, ast.ident ident, @ast.ty t,\n     ret @fold.respan[ast.item_](sp, item);\n }\n \n-fn check_fn(&@crate_ctxt ccx, &ast.fn_decl decl,\n-            bool is_iter, &ast.block body) -> ast._fn {\n+fn check_fn(&@crate_ctxt ccx, &ast.fn_decl decl, &ast.block body) -> ast._fn {\n     auto local_ty_table = @common.new_def_hash[@ty.t]();\n \n     // FIXME: duplicate work: the item annotation already has the arg types\n@@ -2075,8 +2081,8 @@ fn check_fn(&@crate_ctxt ccx, &ast.fn_decl decl,\n     auto block_t = check_block(fcx, body);\n     auto block_wb = writeback(fcx, block_t);\n \n-     auto fn_t = rec(decl=decl, is_iter=is_iter,\n-                    body=block_wb);\n+     auto fn_t = rec(decl=decl,\n+                     body=block_wb);\n     ret fn_t;\n }\n \n@@ -2095,7 +2101,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n-    auto fn_sty = ty.ty_fn(inputs, output_ty);\n+    auto fn_sty = ty.ty_fn(f.decl.proto, inputs, output_ty);\n     auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n@@ -2127,7 +2133,7 @@ fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto fld = fold.new_identity_fold[@crate_ctxt]();\n \n     fld = @rec(update_env_for_item = bind update_obj_fields(_, _),\n-               fold_fn      = bind check_fn(_,_,_,_),\n+               fold_fn      = bind check_fn(_,_,_),\n                fold_item_fn = bind check_item_fn(_,_,_,_,_,_,_)\n                with *fld);\n     ret fold.fold_crate[@crate_ctxt](ccx, fld, result._0);"}]}