{"sha": "93e44432e1055a529c4923709a6533114bb7820f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZTQ0NDMyZTEwNTVhNTI5YzQ5MjM3MDlhNjUzMzExNGJiNzgyMGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-25T14:02:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-25T14:02:56Z"}, "message": "check for both partialeq and eq", "tree": {"sha": "23a62a5b51aae69e272ad041507c4874f232a72a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23a62a5b51aae69e272ad041507c4874f232a72a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93e44432e1055a529c4923709a6533114bb7820f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93e44432e1055a529c4923709a6533114bb7820f", "html_url": "https://github.com/rust-lang/rust/commit/93e44432e1055a529c4923709a6533114bb7820f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93e44432e1055a529c4923709a6533114bb7820f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f661ec417616ea7036f0cc4aefc7034592a3647", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f661ec417616ea7036f0cc4aefc7034592a3647", "html_url": "https://github.com/rust-lang/rust/commit/7f661ec417616ea7036f0cc4aefc7034592a3647"}], "stats": {"total": 120, "additions": 82, "deletions": 38}, "files": [{"sha": "879b894562092f6847cb8f45c5a02e37c46439f6", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e44432e1055a529c4923709a6533114bb7820f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e44432e1055a529c4923709a6533114bb7820f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=93e44432e1055a529c4923709a6533114bb7820f", "patch": "@@ -146,7 +146,7 @@ declare_lint! {\n     pub ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n     Deny,\n     \"constants of struct or enum type can only be used in a pattern if \\\n-     the struct or enum has `#[derive(Eq)]`\"\n+     the struct or enum has `#[derive(PartialEq, Eq)]`\"\n }\n \n declare_lint! {"}, {"sha": "c102822e8c126049579f254cc5e4bd4056a8e38d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93e44432e1055a529c4923709a6533114bb7820f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e44432e1055a529c4923709a6533114bb7820f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=93e44432e1055a529c4923709a6533114bb7820f", "patch": "@@ -345,7 +345,7 @@ pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, spa\n                     span,\n                     format!(\"to use a constant of type `{}` \\\n                              in a pattern, \\\n-                             `{}` must be annotated with `#[derive(Eq)]`\",\n+                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n                             tcx.item_path_str(adt_def.did),\n                             tcx.item_path_str(adt_def.did)));\n             }"}, {"sha": "1774167e8300007214d1d2bc56d9d9af25de9561", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/93e44432e1055a529c4923709a6533114bb7820f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e44432e1055a529c4923709a6533114bb7820f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=93e44432e1055a529c4923709a6533114bb7820f", "patch": "@@ -92,6 +92,9 @@ fn expand_derive(cx: &mut ExtCtxt,\n                 cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n             }\n \n+            let mut found_partial_eq = false;\n+            let mut found_eq = false;\n+\n             for titem in traits.iter().rev() {\n                 let tname = match titem.node {\n                     MetaItemKind::Word(ref tname) => tname,\n@@ -110,50 +113,56 @@ fn expand_derive(cx: &mut ExtCtxt,\n                     continue;\n                 }\n \n-                // RFC #1445. `#[derive(Eq)]` adds a (trusted)\n-                // `#[structural_match]` attribute.\n                 if &tname[..] == \"Eq\" {\n-                    // This span is **very** sensitive and crucial to\n-                    // getting the stability behavior we want. What we\n-                    // are doing is marking `#[structural_match]` with\n-                    // the span of the `#[deriving(Eq)]` attribute\n-                    // (the entire attribute, not just the `Eq` part),\n-                    // but with the current backtrace. The current\n-                    // backtrace will contain a topmost entry that IS\n-                    // this `#[deriving(Eq)]` attribute and with the\n-                    // \"allow-unstable\" flag set to true.\n-                    //\n-                    // Note that we do NOT use the span of the `Eq`\n-                    // text itself.  You might think this is\n-                    // equivalent, because the `Eq` appears within the\n-                    // `#[deriving(Eq)]` attribute, and hence we would\n-                    // inherit the \"allows unstable\" from the\n-                    // backtrace.  But in fact this is not always the\n-                    // case. The actual source text that led to\n-                    // deriving can be `#[$attr]`, for example, where\n-                    // `$attr == deriving(Eq)`. In that case, the\n-                    // \"#[structural_match]\" would be considered to\n-                    // originate not from the deriving call but from\n-                    // text outside the deriving call, and hence would\n-                    // be forbidden from using unstable\n-                    // content.\n-                    //\n-                    // See tests src/run-pass/rfc1445 for\n-                    // examples. --nmatsakis\n-                    let span = Span { expn_id: cx.backtrace(), .. span };\n-                    assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n-                    debug!(\"inserting structural_match with span {:?}\", span);\n-                    let structural_match = intern_and_get_ident(\"structural_match\");\n-                    item.attrs.push(cx.attribute(span,\n-                                                 cx.meta_word(span,\n-                                                              structural_match)));\n+                    found_eq = true;\n+                } else if &tname[..] == \"PartialEq\" {\n+                    found_partial_eq = true;\n                 }\n \n                 // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n                 item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n                     intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n             }\n \n+            // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n+            // `#[structural_match]` attribute.\n+            if found_partial_eq && found_eq {\n+                // This span is **very** sensitive and crucial to\n+                // getting the stability behavior we want. What we are\n+                // doing is marking `#[structural_match]` with the\n+                // span of the `#[deriving(...)]` attribute (the\n+                // entire attribute, not just the `PartialEq` or `Eq`\n+                // part), but with the current backtrace. The current\n+                // backtrace will contain a topmost entry that IS this\n+                // `#[deriving(...)]` attribute and with the\n+                // \"allow-unstable\" flag set to true.\n+                //\n+                // Note that we do NOT use the span of the `Eq`\n+                // text itself. You might think this is\n+                // equivalent, because the `Eq` appears within the\n+                // `#[deriving(Eq)]` attribute, and hence we would\n+                // inherit the \"allows unstable\" from the\n+                // backtrace.  But in fact this is not always the\n+                // case. The actual source text that led to\n+                // deriving can be `#[$attr]`, for example, where\n+                // `$attr == deriving(Eq)`. In that case, the\n+                // \"#[structural_match]\" would be considered to\n+                // originate not from the deriving call but from\n+                // text outside the deriving call, and hence would\n+                // be forbidden from using unstable\n+                // content.\n+                //\n+                // See tests src/run-pass/rfc1445 for\n+                // examples. --nmatsakis\n+                let span = Span { expn_id: cx.backtrace(), .. span };\n+                assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n+                debug!(\"inserting structural_match with span {:?}\", span);\n+                let structural_match = intern_and_get_ident(\"structural_match\");\n+                item.attrs.push(cx.attribute(span,\n+                                             cx.meta_word(span,\n+                                                          structural_match)));\n+            }\n+\n             item\n         })\n     }, |a| {"}, {"sha": "029df08ebc37a99234834573c8572706f3d5d853", "filename": "src/test/compile-fail/rfc1445/match-requires-both-partialeq-and-eq.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/93e44432e1055a529c4923709a6533114bb7820f/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e44432e1055a529c4923709a6533114bb7820f/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs?ref=93e44432e1055a529c4923709a6533114bb7820f", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(future_incompatible)]\n+\n+#[derive(Eq)]\n+struct Foo {\n+    x: u32\n+}\n+\n+impl PartialEq for Foo {\n+    fn eq(&self, _: &Foo) -> bool {\n+        false // ha ha sucker!\n+    }\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARNING will become a hard error\n+        _ => { }\n+    }\n+}"}]}