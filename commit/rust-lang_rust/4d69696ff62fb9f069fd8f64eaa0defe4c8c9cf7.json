{"sha": "4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNjk2OTZmZjYyZmI5ZjA2OWZkOGY2NGVhYTBkZWZlNGM4YzljZjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-24T20:35:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-24T20:35:52Z"}, "message": "auto merge of #17410 : jakub-/rust/dead-code, r=alexcrichton", "tree": {"sha": "9666241bbfdde746072428a34f021e94b6ed1713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9666241bbfdde746072428a34f021e94b6ed1713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "html_url": "https://github.com/rust-lang/rust/commit/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0bd16c5ec7ff4c5445fa3991bd679b4d7d4e966", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0bd16c5ec7ff4c5445fa3991bd679b4d7d4e966", "html_url": "https://github.com/rust-lang/rust/commit/e0bd16c5ec7ff4c5445fa3991bd679b4d7d4e966"}, {"sha": "fd52224e78fe14828f8750fed469cc5c40f260e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd52224e78fe14828f8750fed469cc5c40f260e7", "html_url": "https://github.com/rust-lang/rust/commit/fd52224e78fe14828f8750fed469cc5c40f260e7"}], "stats": {"total": 894, "additions": 184, "deletions": 710}, "files": [{"sha": "92ef0c281f282eecc5095b4a9d226925e4fc02b5", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 9, "deletions": 46, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -28,21 +28,12 @@ pub enum ExponentFormat {\n     /// Use exponential notation with the exponent having a base of 10 and the\n     /// exponent sign being `e` or `E`. For example, 1000 would be printed\n     /// 1e3.\n-    ExpDec,\n-    /// Use exponential notation with the exponent having a base of 2 and the\n-    /// exponent sign being `p` or `P`. For example, 8 would be printed 1p3.\n-    ExpBin,\n+    ExpDec\n }\n \n /// The number of digits used for emitting the fractional part of a number, if\n /// any.\n pub enum SignificantDigits {\n-    /// All calculable digits will be printed.\n-    ///\n-    /// Note that bignums or fractions may cause a surprisingly large number\n-    /// of digits to be printed.\n-    DigAll,\n-\n     /// At most the given number of digits will be printed, truncating any\n     /// trailing zeroes.\n     DigMax(uint),\n@@ -53,17 +44,11 @@ pub enum SignificantDigits {\n \n /// How to emit the sign of a number.\n pub enum SignFormat {\n-    /// No sign will be printed. The exponent sign will also be emitted.\n-    SignNone,\n     /// `-` will be printed for negative values, but no sign will be emitted\n     /// for positive numbers.\n-    SignNeg,\n-    /// `+` will be printed for positive values, and `-` will be printed for\n-    /// negative values.\n-    SignAll,\n+    SignNeg\n }\n \n-static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n /**\n@@ -111,9 +96,6 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n           => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n                     use of 'e' as decimal exponent\", radix),\n-        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n-                    use of 'p' as binary exponent\", radix),\n         _ => ()\n     }\n \n@@ -123,16 +105,10 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n     match num.classify() {\n         FPNaN => return f(\"NaN\".as_bytes()),\n         FPInfinite if num > _0 => {\n-            return match sign {\n-                SignAll => return f(\"+inf\".as_bytes()),\n-                _       => return f(\"inf\".as_bytes()),\n-            };\n+            return f(\"inf\".as_bytes());\n         }\n         FPInfinite if num < _0 => {\n-            return match sign {\n-                SignNone => return f(\"inf\".as_bytes()),\n-                _        => return f(\"-inf\".as_bytes()),\n-            };\n+            return f(\"-inf\".as_bytes());\n         }\n         _ => {}\n     }\n@@ -147,11 +123,10 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n \n     let (num, exp) = match exp_format {\n         ExpNone => (num, 0i32),\n-        ExpDec | ExpBin if num == _0 => (num, 0i32),\n-        ExpDec | ExpBin => {\n+        ExpDec if num == _0 => (num, 0i32),\n+        ExpDec => {\n             let (exp, exp_base) = match exp_format {\n                 ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n-                ExpBin => (num.abs().log2().floor(), cast::<f64, T>(2.0f64).unwrap()),\n                 ExpNone => fail!(\"unreachable\"),\n             };\n \n@@ -185,21 +160,16 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n \n     // If limited digits, calculate one digit more for rounding.\n     let (limit_digits, digit_count, exact) = match digits {\n-        DigAll          => (false, 0u,      false),\n-        DigMax(count)   => (true,  count+1, false),\n-        DigExact(count) => (true,  count+1, true)\n+        DigMax(count)   => (true, count + 1, false),\n+        DigExact(count) => (true, count + 1, true)\n     };\n \n     // Decide what sign to put in front\n     match sign {\n-        SignNeg | SignAll if neg => {\n+        SignNeg if neg => {\n             buf[end] = b'-';\n             end += 1;\n         }\n-        SignAll => {\n-            buf[end] = b'+';\n-            end += 1;\n-        }\n         _ => ()\n     }\n \n@@ -329,8 +299,6 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n             buf[end] = match exp_format {\n                 ExpDec if exp_upper => 'E',\n                 ExpDec if !exp_upper => 'e',\n-                ExpBin if exp_upper => 'P',\n-                ExpBin if !exp_upper => 'p',\n                 _ => fail!(\"unreachable\"),\n             } as u8;\n             end += 1;\n@@ -356,11 +324,6 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n                         fmt::write(&mut filler, args)\n                     }, \"{:-}\", exp);\n                 }\n-                SignNone | SignAll => {\n-                    let _ = format_args!(|args| {\n-                        fmt::write(&mut filler, args)\n-                    }, \"{}\", exp);\n-                }\n             }\n         }\n     }"}, {"sha": "633248562a5538f5c099ae1bdb54f6e5abf3f598", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -397,13 +397,6 @@ pub fn get_cc_prog(sess: &Session) -> String {\n     }.to_string()\n }\n \n-pub fn get_ar_prog(sess: &Session) -> String {\n-    match sess.opts.cg.ar {\n-        Some(ref ar) => (*ar).clone(),\n-        None => \"ar\".to_string()\n-    }\n-}\n-\n pub fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}"}, {"sha": "20842beae16d55b510503d266b09e3ded29eed82", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -114,7 +114,6 @@ register_diagnostics!(\n     E0102,\n     E0103,\n     E0104,\n-    E0105,\n     E0106,\n     E0107,\n     E0108,\n@@ -152,7 +151,6 @@ register_diagnostics!(\n     E0144,\n     E0145,\n     E0146,\n-    E0147,\n     E0148,\n     E0151,\n     E0152,"}, {"sha": "3919bf6bb9442d3fe634b3a14dd9c22409de214b", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -1269,11 +1269,6 @@ impl LintPass for UnusedMut {\n     }\n }\n \n-enum Allocation {\n-    VectorAllocation,\n-    BoxAllocation\n-}\n-\n declare_lint!(UNNECESSARY_ALLOCATION, Warn,\n               \"detects unnecessary allocations that can be eliminated\")\n \n@@ -1285,30 +1280,21 @@ impl LintPass for UnnecessaryAllocation {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        // Warn if boxing expressions are immediately borrowed.\n-        let allocation = match e.node {\n-            ast::ExprUnary(ast::UnUniq, _) |\n-            ast::ExprUnary(ast::UnBox, _) => BoxAllocation,\n-\n+        match e.node {\n+            ast::ExprUnary(ast::UnUniq, _) | ast::ExprUnary(ast::UnBox, _) => (),\n             _ => return\n-        };\n+        }\n \n         match cx.tcx.adjustments.borrow().find(&e.id) {\n             Some(adjustment) => {\n                 match *adjustment {\n                     ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n-                        match (allocation, autoref) {\n-                            (VectorAllocation, &Some(ty::AutoPtr(_, _, None))) => {\n-                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n-                                             \"unnecessary allocation, the sigil can be removed\");\n-                            }\n-                            (BoxAllocation,\n-                             &Some(ty::AutoPtr(_, ast::MutImmutable, None))) => {\n+                        match autoref {\n+                            &Some(ty::AutoPtr(_, ast::MutImmutable, None)) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use & instead\");\n                             }\n-                            (BoxAllocation,\n-                             &Some(ty::AutoPtr(_, ast::MutMutable, None))) => {\n+                            &Some(ty::AutoPtr(_, ast::MutMutable, None)) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                              \"unnecessary allocation, use &mut instead\");\n                             }"}, {"sha": "f40d6d47281c16bcdb6d37a036572603ba67baff", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -662,30 +662,6 @@ impl tr for MethodOrigin {\n     }\n }\n \n-// ______________________________________________________________________\n-// Encoding and decoding vtable_res\n-\n-pub fn encode_vtable_res(ecx: &e::EncodeContext,\n-                         rbml_w: &mut Encoder,\n-                         dr: &typeck::vtable_res) {\n-    // can't autogenerate this code because automatic code of\n-    // ty::t doesn't work, and there is no way (atm) to have\n-    // hand-written encoding routines combine with auto-generated\n-    // ones. perhaps we should fix this.\n-    encode_vec_per_param_space(\n-        rbml_w, dr,\n-        |rbml_w, param_tables| encode_vtable_param_res(ecx, rbml_w,\n-                                                       param_tables))\n-}\n-\n-pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n-                     rbml_w: &mut Encoder,\n-                     param_tables: &typeck::vtable_param_res) {\n-    rbml_w.emit_from_vec(param_tables.as_slice(), |rbml_w, vtable_origin| {\n-        Ok(encode_vtable_origin(ecx, rbml_w, vtable_origin))\n-    }).unwrap()\n-}\n-\n pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n                                    kind: ty::UnboxedClosureKind) {\n     use serialize::Encoder;\n@@ -714,55 +690,6 @@ pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n     }).unwrap()\n }\n \n-pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n-                            rbml_w: &mut Encoder,\n-                            vtable_origin: &typeck::vtable_origin) {\n-    use serialize::Encoder;\n-\n-    rbml_w.emit_enum(\"vtable_origin\", |rbml_w| {\n-        match *vtable_origin {\n-          typeck::vtable_static(def_id, ref substs, ref vtable_res) => {\n-            rbml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |rbml_w| {\n-                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n-                    Ok(rbml_w.emit_def_id(def_id))\n-                });\n-                rbml_w.emit_enum_variant_arg(1u, |rbml_w| {\n-                    Ok(rbml_w.emit_substs(ecx, substs))\n-                });\n-                rbml_w.emit_enum_variant_arg(2u, |rbml_w| {\n-                    Ok(encode_vtable_res(ecx, rbml_w, vtable_res))\n-                })\n-            })\n-          }\n-          typeck::vtable_param(pn, bn) => {\n-            rbml_w.emit_enum_variant(\"vtable_param\", 1u, 3u, |rbml_w| {\n-                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n-                    pn.encode(rbml_w)\n-                });\n-                rbml_w.emit_enum_variant_arg(1u, |rbml_w| {\n-                    rbml_w.emit_uint(bn)\n-                })\n-            })\n-          }\n-          typeck::vtable_unboxed_closure(def_id) => {\n-              rbml_w.emit_enum_variant(\"vtable_unboxed_closure\",\n-                                       2u,\n-                                       1u,\n-                                       |rbml_w| {\n-                rbml_w.emit_enum_variant_arg(0u, |rbml_w| {\n-                    Ok(rbml_w.emit_def_id(def_id))\n-                })\n-              })\n-          }\n-          typeck::vtable_error => {\n-            rbml_w.emit_enum_variant(\"vtable_error\", 3u, 3u, |_rbml_w| {\n-                Ok(())\n-            })\n-          }\n-        }\n-    }).unwrap()\n-}\n-\n pub trait vtable_decoder_helpers {\n     fn read_vec_per_param_space<T>(&mut self,\n                                    f: |&mut Self| -> T)"}, {"sha": "d3d6e7508f0775052e2cf7339e2e3abe18c91484", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -16,7 +16,6 @@ use middle::cfg;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n-use middle::def;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::ty;\n@@ -243,12 +242,6 @@ struct BorrowStats {\n \n pub type BckResult<T> = Result<T, BckError>;\n \n-#[deriving(PartialEq)]\n-pub enum PartialTotal {\n-    Partial,   // Loan affects some portion\n-    Total      // Loan affects entire path\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n@@ -392,11 +385,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n \n-    pub fn is_subscope_of(&self, r_sub: ast::NodeId, r_sup: ast::NodeId)\n-                          -> bool {\n-        self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n-    }\n-\n     pub fn mc(&self) -> mc::MemCategorizationContext<'a, ty::ctxt<'tcx>> {\n         mc::MemCategorizationContext::new(self.tcx)\n     }\n@@ -410,82 +398,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> mc::cmt {\n-        match self.mc().cat_expr_unadjusted(expr) {\n-            Ok(c) => c,\n-            Err(()) => {\n-                self.tcx.sess.span_bug(expr.span, \"error in mem categorization\");\n-            }\n-        }\n-    }\n-\n-    pub fn cat_expr_autoderefd(&self,\n-                               expr: &ast::Expr,\n-                               adj: &ty::AutoAdjustment)\n-                               -> mc::cmt {\n-        let r = match *adj {\n-            ty::AdjustDerefRef(\n-                ty::AutoDerefRef {\n-                    autoderefs: autoderefs, ..}) => {\n-                self.mc().cat_expr_autoderefd(expr, autoderefs)\n-            }\n-            ty::AdjustAddEnv(..) => {\n-                // no autoderefs\n-                self.mc().cat_expr_unadjusted(expr)\n-            }\n-        };\n-\n-        match r {\n-            Ok(c) => c,\n-            Err(()) => {\n-                self.tcx.sess.span_bug(expr.span,\n-                                       \"error in mem categorization\");\n-            }\n-        }\n-    }\n-\n-    pub fn cat_def(&self,\n-                   id: ast::NodeId,\n-                   span: Span,\n-                   ty: ty::t,\n-                   def: def::Def)\n-                   -> mc::cmt {\n-        match self.mc().cat_def(id, span, ty, def) {\n-            Ok(c) => c,\n-            Err(()) => {\n-                self.tcx.sess.span_bug(span, \"error in mem categorization\");\n-            }\n-        }\n-    }\n-\n-    pub fn cat_captured_var(&self,\n-                            closure_id: ast::NodeId,\n-                            closure_span: Span,\n-                            upvar_def: def::Def)\n-                            -> mc::cmt {\n-        // Create the cmt for the variable being borrowed, from the\n-        // caller's perspective\n-        let var_id = upvar_def.def_id().node;\n-        let var_ty = ty::node_id_to_type(self.tcx, var_id);\n-        self.cat_def(closure_id, closure_span, var_ty, upvar_def)\n-    }\n-\n-    pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::NodeId) -> mc::cmt {\n-        Rc::new(mc::cmt_ {\n-            cat: mc::cat_discr(cmt.clone(), match_id),\n-            mutbl: cmt.mutbl.inherit(),\n-            ..*cmt\n-        })\n-    }\n-\n-    pub fn cat_pattern(&self,\n-                       cmt: mc::cmt,\n-                       pat: &ast::Pat,\n-                       op: |mc::cmt, &ast::Pat|) {\n-        let r = self.mc().cat_pattern(cmt, pat, |_,x,y| op(x,y));\n-        assert!(r.is_ok());\n-    }\n-\n     pub fn report(&self, err: BckError) {\n         self.span_err(\n             err.span,"}, {"sha": "d8597c08b454c470d0d0050ca27963638ee70c29", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -568,22 +568,6 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         }\n     }\n \n-    pub fn each_path_moved_by(&self,\n-                              id: ast::NodeId,\n-                              f: |&Move, &LoanPath| -> bool)\n-                              -> bool {\n-        /*!\n-         * Iterates through each path moved by `id`\n-         */\n-\n-        self.dfcx_moves.each_gen_bit(id, |index| {\n-            let move = self.move_data.moves.borrow();\n-            let move = move.get(index);\n-            let moved_path = move.path;\n-            f(move, &*self.move_data.path_loan_path(moved_path))\n-        })\n-    }\n-\n     pub fn kind_of_move_of_path(&self,\n                                 id: ast::NodeId,\n                                 loan_path: &Rc<LoanPath>)\n@@ -665,13 +649,6 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         })\n     }\n \n-    pub fn is_assignee(&self,\n-                       id: ast::NodeId)\n-                       -> bool {\n-        //! True if `id` is the id of the LHS of an assignment\n-        self.move_data.assignee_ids.borrow().iter().any(|x| x == &id)\n-    }\n-\n     pub fn each_assignment_of(&self,\n                               id: ast::NodeId,\n                               loan_path: &Rc<LoanPath>,"}, {"sha": "1b2f62a9385a2cdf8f6c5fee0a2fc29ff514ee00", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 71, "deletions": 42, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -13,21 +13,20 @@\n // from live codes are live, and everything else is dead.\n \n use middle::def;\n-use lint;\n+use middle::pat_util;\n use middle::privacy;\n use middle::ty;\n use middle::typeck;\n+use lint;\n use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, is_local, PostExpansionMethod};\n-use syntax::attr::AttrMetaMethods;\n-use syntax::attr;\n+use syntax::attr::{mod, AttrMetaMethods};\n use syntax::codemap;\n-use syntax::visit::Visitor;\n-use syntax::visit;\n+use syntax::visit::{mod, Visitor};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live NodeItem that is a\n@@ -51,7 +50,8 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: &'a ty::ctxt<'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n-    struct_has_extern_repr: bool\n+    struct_has_extern_repr: bool,\n+    ignore_paths: bool\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n@@ -61,7 +61,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             worklist: worklist,\n             tcx: tcx,\n             live_symbols: box HashSet::new(),\n-            struct_has_extern_repr: false\n+            struct_has_extern_repr: false,\n+            ignore_paths: false\n         }\n     }\n \n@@ -73,19 +74,18 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n-        let def = match self.tcx.def_map.borrow().find(id) {\n-            Some(&def) => def,\n-            None => return\n-        };\n-        let def_id = match def {\n-            def::DefVariant(enum_id, _, _) => Some(enum_id),\n-            def::DefPrimTy(_) => None,\n-            _ => Some(def.def_id())\n-        };\n-        match def_id {\n-            Some(def_id) => self.check_def_id(def_id),\n-            None => (),\n-        }\n+        self.tcx.def_map.borrow().find(id).map(|def| {\n+            match def {\n+                &def::DefPrimTy(_) => (),\n+                &def::DefVariant(enum_id, variant_id, _) => {\n+                    self.check_def_id(enum_id);\n+                    self.check_def_id(variant_id);\n+                }\n+                _ => {\n+                    self.check_def_id(def.def_id());\n+                }\n+            }\n+        });\n     }\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n@@ -275,22 +275,27 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &ast::Pat) {\n+        let def_map = &self.tcx.def_map;\n         match pat.node {\n             ast::PatStruct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields.as_slice());\n             }\n-            ast::PatIdent(_, _, _) => {\n+            _ if pat_util::pat_is_const(def_map, pat) => {\n                 // it might be the only use of a static:\n                 self.lookup_and_handle_definition(&pat.id)\n             }\n             _ => ()\n         }\n \n+        self.ignore_paths = true;\n         visit::walk_pat(self, pat);\n+        self.ignore_paths = false;\n     }\n \n     fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n-        self.lookup_and_handle_definition(&id);\n+        if !self.ignore_paths {\n+            self.lookup_and_handle_definition(&id);\n+        }\n         visit::walk_path(self, path);\n     }\n \n@@ -330,15 +335,19 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n struct LifeSeeder {\n-    worklist: Vec<ast::NodeId> ,\n+    worklist: Vec<ast::NodeId>\n }\n \n impl<'v> Visitor<'v> for LifeSeeder {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        if has_allow_dead_code_or_lang_attr(item.attrs.as_slice()) {\n+        let allow_dead_code = has_allow_dead_code_or_lang_attr(item.attrs.as_slice());\n+        if allow_dead_code {\n             self.worklist.push(item.id);\n         }\n         match item.node {\n+            ast::ItemEnum(ref enum_def, _) if allow_dead_code => {\n+                self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n+            }\n             ast::ItemImpl(_, Some(ref _trait_ref), _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n@@ -415,16 +424,6 @@ fn find_live(tcx: &ty::ctxt,\n     symbol_visitor.live_symbols\n }\n \n-fn should_warn(item: &ast::Item) -> bool {\n-    match item.node {\n-        ast::ItemStatic(..)\n-        | ast::ItemFn(..)\n-        | ast::ItemEnum(..)\n-        | ast::ItemStruct(..) => true,\n-        _ => false\n-    }\n-}\n-\n fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     match item.node {\n         ast::ItemStruct(ref struct_def, _) => struct_def.ctor_id,\n@@ -438,6 +437,18 @@ struct DeadVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n+    fn should_warn_about_item(&mut self, item: &ast::Item) -> bool {\n+        let should_warn = match item.node {\n+            ast::ItemStatic(..)\n+            | ast::ItemFn(..)\n+            | ast::ItemEnum(..)\n+            | ast::ItemStruct(..) => true,\n+            _ => false\n+        };\n+        let ctor_id = get_struct_ctor_id(item);\n+        should_warn && !self.symbol_is_live(item.id, ctor_id)\n+    }\n+\n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let is_named = node.ident().is_some();\n         let field_type = ty::node_id_to_type(self.tcx, node.id);\n@@ -451,6 +462,11 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             && !has_allow_dead_code_or_lang_attr(node.attrs.as_slice())\n     }\n \n+    fn should_warn_about_variant(&mut self, variant: &ast::Variant_) -> bool {\n+        !self.symbol_is_live(variant.id, None)\n+            && !has_allow_dead_code_or_lang_attr(variant.attrs.as_slice())\n+    }\n+\n     // id := node id of an item's definition.\n     // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n     //            `None` otherwise.\n@@ -491,31 +507,43 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn warn_dead_code(&mut self,\n                       id: ast::NodeId,\n                       span: codemap::Span,\n-                      ident: ast::Ident) {\n+                      ident: ast::Ident,\n+                      node_type: &str) {\n         let name = ident.as_str();\n         if !name.starts_with(\"_\") {\n             self.tcx\n                 .sess\n                 .add_lint(lint::builtin::DEAD_CODE,\n                           id,\n                           span,\n-                          format!(\"code is never used: `{}`\", name));\n+                          format!(\"{} is never used: `{}`\", node_type, name));\n         }\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        let ctor_id = get_struct_ctor_id(item);\n-        if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n-            self.warn_dead_code(item.id, item.span, item.ident);\n+        if self.should_warn_about_item(item) {\n+            self.warn_dead_code(item.id, item.span, item.ident, item.node.descriptive_variant());\n+        } else {\n+            match item.node {\n+                ast::ItemEnum(ref enum_def, _) => {\n+                    for variant in enum_def.variants.iter() {\n+                        if self.should_warn_about_variant(&variant.node) {\n+                            self.warn_dead_code(variant.node.id, variant.span,\n+                                                variant.node.name, \"variant\");\n+                        }\n+                    }\n+                },\n+                _ => ()\n+            }\n         }\n         visit::walk_item(self, item);\n     }\n \n     fn visit_foreign_item(&mut self, fi: &ast::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n-            self.warn_dead_code(fi.id, fi.span, fi.ident);\n+            self.warn_dead_code(fi.id, fi.span, fi.ident, fi.node.descriptive_variant());\n         }\n         visit::walk_foreign_item(self, fi);\n     }\n@@ -527,7 +555,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         match fk {\n             visit::FkMethod(name, _, _) => {\n                 if !self.symbol_is_live(id, None) {\n-                    self.warn_dead_code(id, span, name);\n+                    self.warn_dead_code(id, span, name, \"method\");\n                 }\n             }\n             _ => ()\n@@ -537,7 +565,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_struct_field(&mut self, field: &ast::StructField) {\n         if self.should_warn_about_field(&field.node) {\n-            self.warn_dead_code(field.node.id, field.span, field.node.ident().unwrap());\n+            self.warn_dead_code(field.node.id, field.span,\n+                                field.node.ident().unwrap(), \"struct field\");\n         }\n \n         visit::walk_struct_field(self, field);"}, {"sha": "f5d4ece3bcccf859ff39983f1005ef8f113ceccd", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -355,17 +355,6 @@ pub fn check_freevar_bounds(cx: &Context, fn_span: Span, sp: Span, ty: ty::t,\n     });\n }\n \n-pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n-                               bounds: ty::BuiltinBounds) {\n-    check_builtin_bounds(cx, ty, bounds, |missing| {\n-        span_err!(cx.tcx.sess, sp, E0147,\n-            \"cannot pack type `{}`, which does not fulfill `{}`, as a trait bounded by {}\",\n-            ty_to_string(cx.tcx, ty),\n-            missing.user_string(cx.tcx),\n-            bounds.user_string(cx.tcx));\n-    });\n-}\n-\n fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n     debug!(\"type_contents({})={}\",\n            ty_to_string(cx.tcx, ty),"}, {"sha": "3b831dd6847a1b07414a10ce06654a5df736cfce", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -735,10 +735,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         })\n     }\n \n-    pub fn cat_deref_obj<N:ast_node>(&self, node: &N, base_cmt: cmt) -> cmt {\n-        self.cat_deref_common(node, base_cmt, 0, ty::mk_nil(), false)\n-    }\n-\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt,"}, {"sha": "7d88ba57ad7b7434208e5a85401a1bbcc479b4b6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -488,7 +488,6 @@ enum ParentLink {\n #[deriving(PartialEq)]\n enum ModuleKind {\n     NormalModuleKind,\n-    ExternModuleKind,\n     TraitModuleKind,\n     ImplModuleKind,\n     AnonymousModuleKind,\n@@ -3348,7 +3347,6 @@ impl<'a> Resolver<'a> {\n                                     parents\");\n                             return Failed(None);\n                         }\n-                        ExternModuleKind |\n                         TraitModuleKind |\n                         ImplModuleKind |\n                         AnonymousModuleKind => {\n@@ -3446,7 +3444,6 @@ impl<'a> Resolver<'a> {\n                     let new_module = new_module.upgrade().unwrap();\n                     match new_module.kind.get() {\n                         NormalModuleKind => return Some(new_module),\n-                        ExternModuleKind |\n                         TraitModuleKind |\n                         ImplModuleKind |\n                         AnonymousModuleKind => module_ = new_module,\n@@ -3462,7 +3459,6 @@ impl<'a> Resolver<'a> {\n                                                 -> Rc<Module> {\n         match module_.kind.get() {\n             NormalModuleKind => return module_,\n-            ExternModuleKind |\n             TraitModuleKind |\n             ImplModuleKind |\n             AnonymousModuleKind => {"}, {"sha": "b55678e3a5078ca08dc9dff83cc6506cd252db5e", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -195,11 +195,6 @@ impl Substs {\n         }\n     }\n \n-    pub fn with_method_from(self, substs: &Substs) -> Substs {\n-        self.with_method(Vec::from_slice(substs.types.get_slice(FnSpace)),\n-                         Vec::from_slice(substs.regions().get_slice(FnSpace)))\n-    }\n-\n     pub fn with_method(self,\n                        m_types: Vec<ty::t>,\n                        m_regions: Vec<ty::Region>)\n@@ -292,15 +287,6 @@ impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n     }\n }\n \n-impl<T:Clone> VecPerParamSpace<T> {\n-    pub fn push_all(&mut self, space: ParamSpace, values: &[T]) {\n-        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n-        for t in values.iter() {\n-            self.push(space, t.clone());\n-        }\n-    }\n-}\n-\n impl<T> VecPerParamSpace<T> {\n     fn limits(&self, space: ParamSpace) -> (uint, uint) {\n         match space {\n@@ -348,14 +334,6 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    pub fn sort(t: Vec<T>, space: |&T| -> ParamSpace) -> VecPerParamSpace<T> {\n-        let mut result = VecPerParamSpace::empty();\n-        for t in t.into_iter() {\n-            result.push(space(&t), t);\n-        }\n-        result\n-    }\n-\n     /// Appends `value` to the vector associated with `space`.\n     ///\n     /// Unlike the `push` method in `Vec`, this should not be assumed\n@@ -435,12 +413,6 @@ impl<T> VecPerParamSpace<T> {\n         &self.get_slice(space)[index]\n     }\n \n-    pub fn get_mut<'a>(&'a mut self,\n-                       space: ParamSpace,\n-                       index: uint) -> &'a mut T {\n-        &mut self.get_mut_slice(space)[index]\n-    }\n-\n     pub fn iter<'a>(&'a self) -> Items<'a,T> {\n         self.content.iter()\n     }\n@@ -476,30 +448,6 @@ impl<T> VecPerParamSpace<T> {\n                               f.into_iter().map(|p| pred(p)).collect())\n     }\n \n-    pub fn map_rev<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n-        /*!\n-         * Executes the map but in reverse order. For hacky reasons, we rely\n-         * on this in table.\n-         *\n-         * FIXME(#5527) -- order of eval becomes irrelevant with newer\n-         * trait reform, which features an idempotent algorithm that\n-         * can be run to a fixed point\n-         */\n-\n-        let mut fns: Vec<U> = self.get_slice(FnSpace).iter().rev().map(|p| pred(p)).collect();\n-\n-        // NB: Calling foo.rev().map().rev() causes the calls to map\n-        // to occur in the wrong order. This was somewhat surprising\n-        // to me, though it makes total sense.\n-        fns.reverse();\n-\n-        let mut selfs: Vec<U> = self.get_slice(SelfSpace).iter().rev().map(|p| pred(p)).collect();\n-        selfs.reverse();\n-        let mut tys: Vec<U> = self.get_slice(TypeSpace).iter().rev().map(|p| pred(p)).collect();\n-        tys.reverse();\n-        VecPerParamSpace::new(tys, selfs, fns)\n-    }\n-\n     pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {\n         // FIXME (#15418): this does two traversals when in principle\n         // one would suffice.  i.e. change to use `move_iter`."}, {"sha": "12a2815cfef3488a8f1143fc786d680be7b4278d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -21,7 +21,6 @@ use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::foreign;\n use middle::ty;\n-use middle::typeck;\n use util::ppaux::Repr;\n \n use syntax::abi;\n@@ -285,37 +284,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     (lldecl, true)\n }\n \n-// Used to identify cached monomorphized functions\n-#[deriving(PartialEq, Eq, Hash)]\n-pub struct MonoParamId {\n-    pub subst: ty::t,\n-}\n-\n #[deriving(PartialEq, Eq, Hash)]\n pub struct MonoId {\n     pub def: ast::DefId,\n     pub params: subst::VecPerParamSpace<ty::t>\n }\n-\n-pub fn make_vtable_id(_ccx: &CrateContext,\n-                      origin: &typeck::vtable_origin)\n-                      -> MonoId {\n-    match origin {\n-        &typeck::vtable_static(impl_id, ref substs, _) => {\n-            MonoId {\n-                def: impl_id,\n-                params: substs.types.clone()\n-            }\n-        }\n-\n-        &typeck::vtable_unboxed_closure(def_id) => {\n-            MonoId {\n-                def: def_id,\n-                params: subst::VecPerParamSpace::empty(),\n-            }\n-        }\n-\n-        // can't this be checked at the callee?\n-        _ => fail!(\"make_vtable_id needs vtable_static\")\n-    }\n-}"}, {"sha": "f1499cb91663ff4a2f3d482a3ab940dbfc56c871", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -1915,13 +1915,6 @@ pub fn fold_ty(cx: &ctxt, t0: t, fldop: |t| -> t) -> t {\n     f.fold_ty(t0)\n }\n \n-pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n-                           -> t {\n-    ty_fold::RegionFolder::general(cx,\n-                                   |r| { fldr(r); r },\n-                                   |t| { fldt(t); t }).fold_ty(ty)\n-}\n-\n impl ParamTy {\n     pub fn new(space: subst::ParamSpace,\n                index: uint,\n@@ -3551,58 +3544,6 @@ pub fn unsize_ty(cx: &ctxt,\n     }\n }\n \n-impl AutoRef {\n-    pub fn map_region(&self, f: |Region| -> Region) -> AutoRef {\n-        match *self {\n-            ty::AutoPtr(r, m, None) => ty::AutoPtr(f(r), m, None),\n-            ty::AutoPtr(r, m, Some(ref a)) => ty::AutoPtr(f(r), m, Some(box a.map_region(f))),\n-            ty::AutoUnsize(ref k) => ty::AutoUnsize(k.clone()),\n-            ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.clone()),\n-            ty::AutoUnsafe(m, None) => ty::AutoUnsafe(m, None),\n-            ty::AutoUnsafe(m, Some(ref a)) => ty::AutoUnsafe(m, Some(box a.map_region(f))),\n-        }\n-    }\n-}\n-\n-pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n-                                            origin: &typeck::MethodOrigin)\n-                                            -> VecPerParamSpace<TypeParameterDef>\n-                                            where T: mc::Typer<'tcx> {\n-    match *origin {\n-        typeck::MethodStatic(did) => {\n-            ty::lookup_item_type(typer.tcx(), did).generics.types.clone()\n-        }\n-        typeck::MethodStaticUnboxedClosure(did) => {\n-            let def_id = typer.unboxed_closures()\n-                              .borrow()\n-                              .find(&did)\n-                              .expect(\"method_call_type_param_defs: didn't \\\n-                                       find unboxed closure\")\n-                              .kind\n-                              .trait_did(typer.tcx());\n-            lookup_trait_def(typer.tcx(), def_id).generics.types.clone()\n-        }\n-        typeck::MethodTypeParam(typeck::MethodParam{\n-            trait_ref: ref trait_ref,\n-            method_num: n_mth,\n-            ..\n-        }) |\n-        typeck::MethodTraitObject(typeck::MethodObject{\n-                trait_ref: ref trait_ref,\n-                method_num: n_mth,\n-                ..\n-        }) => {\n-            match ty::trait_item(typer.tcx(), trait_ref.def_id, n_mth) {\n-                ty::MethodTraitItem(method) => method.generics.types.clone(),\n-                ty::TypeTraitItem(_) => {\n-                    typer.tcx().sess.bug(\"method_call_type_param_defs() \\\n-                                          called on associated type\")\n-                }\n-            }\n-        }\n-    }\n-}\n-\n pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     match tcx.def_map.borrow().find(&expr.id) {\n         Some(&def) => def,\n@@ -3821,22 +3762,6 @@ pub fn impl_or_trait_item_idx(id: ast::Ident, trait_items: &[ImplOrTraitItem])\n     trait_items.iter().position(|m| m.ident() == id)\n }\n \n-/// Returns a vector containing the indices of all type parameters that appear\n-/// in `ty`.  The vector may contain duplicates.  Probably should be converted\n-/// to a bitset or some other representation.\n-pub fn param_tys_in_type(ty: t) -> Vec<ParamTy> {\n-    let mut rslt = Vec::new();\n-    walk_ty(ty, |ty| {\n-        match get(ty).sty {\n-          ty_param(p) => {\n-            rslt.push(p);\n-          }\n-          _ => ()\n-        }\n-    });\n-    rslt\n-}\n-\n pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n@@ -4706,17 +4631,6 @@ pub fn is_tuple_struct(cx: &ctxt, did: ast::DefId) -> bool {\n     !fields.is_empty() && fields.iter().all(|f| f.name == token::special_names::unnamed_field)\n }\n \n-pub fn lookup_struct_field(cx: &ctxt,\n-                           parent: ast::DefId,\n-                           field_id: ast::DefId)\n-                        -> field_ty {\n-    let r = lookup_struct_fields(cx, parent);\n-    match r.iter().find(|f| f.id.node == field_id.node) {\n-        Some(t) => t.clone(),\n-        None => cx.sess.bug(\"struct ID not found in parent's fields\")\n-    }\n-}\n-\n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)"}, {"sha": "2359f9d72d2b734ac7b779cdd66378ea68b617f0", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -77,17 +77,3 @@ pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n       }\n     }\n }\n-\n-pub fn coerce_with_fn(fcx: &FnCtxt,\n-                      sp: Span,\n-                      expected: ty::t,\n-                      expr: &ast::Expr,\n-                      handle_err: |Span, ty::t, ty::t, &ty::type_err|) {\n-    let expr_ty = fcx.expr_ty(expr);\n-    match fcx.mk_assignty(expr, expr_ty, expected) {\n-      result::Ok(()) => { /* ok */ }\n-      result::Err(ref err) => {\n-        handle_err(sp, expected, expr_ty, err);\n-      }\n-    }\n-}"}, {"sha": "821cf629d835c489f52caf5a4bc54a358eebddde", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -1901,18 +1901,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn method_ty_substs(&self, id: ast::NodeId) -> subst::Substs {\n-        match self.inh.method_map.borrow().find(&MethodCall::expr(id)) {\n-            Some(method) => method.substs.clone(),\n-            None => {\n-                self.tcx().sess.bug(\n-                    format!(\"no method entry for node {}: {} in fcx {}\",\n-                            id, self.tcx().map.node_to_string(id),\n-                            self.tag()).as_slice());\n-            }\n-        }\n-    }\n-\n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n                               f: |&ty::ItemSubsts|) {\n@@ -1984,18 +1972,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n-    pub fn report_mismatched_return_types(&self,\n-                                          sp: Span,\n-                                          e: ty::t,\n-                                          a: ty::t,\n-                                          err: &ty::type_err) {\n-        // Derived error\n-        if ty::type_is_error(e) || ty::type_is_error(a) {\n-            return;\n-        }\n-        self.infcx().report_mismatched_types(sp, e, a, err)\n-    }\n-\n     pub fn report_mismatched_types(&self,\n                                    sp: Span,\n                                    e: ty::t,\n@@ -4663,24 +4639,6 @@ impl Repr for Expectation {\n     }\n }\n \n-pub fn require_uint(fcx: &FnCtxt, sp: Span, t: ty::t) {\n-    if !type_is_uint(fcx, sp, t) {\n-        fcx.type_error_message(sp, |actual| {\n-            format!(\"mismatched types: expected `uint` type, found `{}`\",\n-                    actual)\n-        }, t, None);\n-    }\n-}\n-\n-pub fn require_integral(fcx: &FnCtxt, sp: Span, t: ty::t) {\n-    if !type_is_integral(fcx, sp, t) {\n-        fcx.type_error_message(sp, |actual| {\n-            format!(\"mismatched types: expected integral type, found `{}`\",\n-                    actual)\n-        }, t, None);\n-    }\n-}\n-\n pub fn check_decl_initializer(fcx: &FnCtxt,\n                               nid: ast::NodeId,\n                               init: &ast::Expr)\n@@ -5602,51 +5560,6 @@ pub fn structure_of<'a>(fcx: &FnCtxt, sp: Span, typ: ty::t)\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-pub fn type_is_integral(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_integral(typ_s);\n-}\n-\n-pub fn type_is_uint(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_uint(typ_s);\n-}\n-\n-pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_scalar(typ_s);\n-}\n-\n-pub fn type_is_char(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_char(typ_s);\n-}\n-\n-pub fn type_is_bare_fn(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_bare_fn(typ_s);\n-}\n-\n-pub fn type_is_floating_point(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_floating_point(typ_s);\n-}\n-\n-pub fn type_is_unsafe_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_unsafe_ptr(typ_s);\n-}\n-\n-pub fn type_is_region_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_region_ptr(typ_s);\n-}\n-\n-pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n-}\n-\n // Returns true if b contains a break that can exit from b\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately"}, {"sha": "85fe0a42c49d3330dcc185a4b6c5e2274bf0a25f", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -213,26 +213,6 @@ pub struct Rcx<'a, 'tcx: 'a> {\n     repeating_scope: ast::NodeId,\n }\n \n-/// When entering a function, we can derive relationships from the\n-/// signature between various regions and type parameters. Consider\n-/// a function like:\n-///\n-///     fn foo<'a, A>(x: &'a A) { ... }\n-///\n-/// Here, we can derive that `A` must outlive `'a`, because otherwise\n-/// the caller would be illegal. We record this by storing a series of\n-/// pairs (in this case, `('a, A)`). These pairs will be consulted\n-/// later during regionck.\n-///\n-/// In the case of nested fns, additional relationships may be\n-/// derived.  The result is a link list walking up the stack (hence\n-/// the `previous` field).\n-#[deriving(Clone)]\n-pub struct RegionSubParamConstraints<'a> {\n-    pairs: Vec<(ty::Region, ty::ParamTy)>,\n-    previous: Option<&'a RegionSubParamConstraints<'a>>,\n-}\n-\n fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     /*!\n      * Returns the validity region of `def` -- that is, how long"}, {"sha": "61ff86afcec3f0745e974c8d3fb065c743c9b0c4", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -25,17 +25,6 @@ use syntax::codemap::Span;\n use util::ppaux::UserString;\n use util::ppaux::Repr;\n \n-/// When reporting an error about a failed trait obligation, it's nice\n-/// to include some context indicating why we were checking that\n-/// obligation in the first place. The span is often enough but\n-/// sometimes it's not. Currently this enum is a bit of a hack and I\n-/// suspect it should be carried in the obligation or more deeply\n-/// integrated somehow.\n-pub enum ErrorReportingContext {\n-    GenericContext,\n-    ImplSupertraitCheck,\n-}\n-\n pub fn check_object_cast(fcx: &FnCtxt,\n                          cast_expr: &ast::Expr,\n                          source_expr: &ast::Expr,"}, {"sha": "f734aa09e4a126743a1d4dd162fc6fb15bd0388c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -22,7 +22,6 @@ use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::{MethodCall, MethodCallee};\n-use middle::typeck::vtable_res;\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n use util::ppaux::Repr;\n@@ -67,17 +66,6 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     wbcx.visit_object_cast_map();\n }\n \n-pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n-                        span: Span,\n-                        vtable_res: &vtable_res)\n-                        -> vtable_res {\n-    let errors = Cell::new(false); // nobody cares\n-    let mut resolver = Resolver::from_infcx(infcx,\n-                                            &errors,\n-                                            ResolvingImplRes(span));\n-    vtable_res.resolve_in(&mut resolver)\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // The Writerback context. This visitor walks the AST, checking the\n // fn-specific tables to find references to types or regions. It\n@@ -361,7 +349,6 @@ enum ResolveReason {\n     ResolvingLocal(Span),\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n-    ResolvingImplRes(Span),\n     ResolvingUnboxedClosure(ast::DefId),\n }\n \n@@ -374,7 +361,6 @@ impl ResolveReason {\n             ResolvingUpvar(upvar_id) => {\n                 ty::expr_span(tcx, upvar_id.closure_expr_id)\n             }\n-            ResolvingImplRes(s) => s,\n             ResolvingUnboxedClosure(did) => {\n                 if did.krate == ast::LOCAL_CRATE {\n                     ty::expr_span(tcx, did.node)\n@@ -415,10 +401,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n            reason: ResolveReason)\n            -> Resolver<'cx, 'tcx>\n     {\n-        Resolver { infcx: fcx.infcx(),\n-                   tcx: fcx.tcx(),\n-                   writeback_errors: &fcx.writeback_errors,\n-                   reason: reason }\n+        Resolver::from_infcx(fcx.infcx(), &fcx.writeback_errors, reason)\n     }\n \n     fn from_infcx(infcx: &'cx infer::InferCtxt<'cx, 'tcx>,\n@@ -462,11 +445,6 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                         infer::fixup_err_to_string(e));\n                 }\n \n-                ResolvingImplRes(span) => {\n-                    span_err!(self.tcx.sess, span, E0105,\n-                        \"cannot determine a type for impl supertrait\");\n-                }\n-\n                 ResolvingUnboxedClosure(_) => {\n                     let span = self.reason.span(self.tcx);\n                     self.tcx.sess.span_err(span,"}, {"sha": "d1b754155f8c7a63689abb504864e94ab139371b", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -66,12 +66,6 @@ pub mod unify;\n \n pub type Bound<T> = Option<T>;\n \n-#[deriving(PartialEq,Clone)]\n-pub struct Bounds<T> {\n-    pub lb: Bound<T>,\n-    pub ub: Bound<T>\n-}\n-\n pub type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n pub type ures = cres<()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n@@ -271,9 +265,7 @@ pub enum RegionVariableOrigin {\n pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_float_ty(FloatVid),\n-    unresolved_ty(TyVid),\n-    unresolved_region(RegionVid),\n-    region_var_bound_by_region_var(RegionVid, RegionVid)\n+    unresolved_ty(TyVid)\n }\n \n pub fn fixup_err_to_string(f: fixup_err) -> String {\n@@ -287,11 +279,6 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n            the type explicitly\".to_string()\n       }\n       unresolved_ty(_) => \"unconstrained type\".to_string(),\n-      unresolved_region(_) => \"unconstrained region\".to_string(),\n-      region_var_bound_by_region_var(r1, r2) => {\n-        format!(\"region var {:?} bound by another region var {:?}; \\\n-                 this is a bug in rustc\", r1, r2)\n-      }\n     }\n }\n "}, {"sha": "008ca6c0771655bb523e534a18558fb26468adab", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -525,17 +525,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    pub fn max_regions(&self,\n-                       a: Region,\n-                       b: Region)\n-                       -> Option<Region>\n-    {\n-        match self.glb_concrete_regions(a, b) {\n-            Ok(r) => Some(r),\n-            Err(_) => None\n-        }\n-    }\n-\n     pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n         match *self.values.borrow() {\n             None => {"}, {"sha": "0a4fd90765c039b4808f5e2bb46708e8216b15c0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -25,7 +25,6 @@ use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::typeck;\n use middle::typeck::check::regionmanip;\n-use middle::typeck::infer;\n \n use std::rc::Rc;\n use syntax::abi;\n@@ -1181,14 +1180,6 @@ impl Repr for ast::FloatTy {\n     }\n }\n \n-impl<T:Repr> Repr for infer::Bounds<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"({} <= {})\",\n-                self.lb.repr(tcx),\n-                self.ub.repr(tcx))\n-    }\n-}\n-\n impl Repr for ty::ExplicitSelfCategory {\n     fn repr(&self, _: &ctxt) -> String {\n         explicit_self_category_to_str(self).to_string()"}, {"sha": "38d8136c1a13cd921bd2ad4b5b322433f60c41c0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -1323,6 +1323,22 @@ pub enum Item_ {\n     ItemMac(Mac),\n }\n \n+impl Item_ {\n+    pub fn descriptive_variant(&self) -> &str {\n+        match *self {\n+            ItemStatic(..) => \"static item\",\n+            ItemFn(..) => \"function\",\n+            ItemMod(..) => \"module\",\n+            ItemForeignMod(..) => \"foreign module\",\n+            ItemTy(..) => \"type alias\",\n+            ItemEnum(..) => \"enum\",\n+            ItemStruct(..) => \"struct\",\n+            ItemTrait(..) => \"trait\",\n+            _ => \"item\"\n+        }\n+    }\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct ForeignItem {\n     pub ident: Ident,\n@@ -1339,6 +1355,15 @@ pub enum ForeignItem_ {\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n }\n \n+impl ForeignItem_ {\n+    pub fn descriptive_variant(&self) -> &str {\n+        match *self {\n+            ForeignItemFn(..) => \"foreign function\",\n+            ForeignItemStatic(..) => \"foreign static item\"\n+        }\n+    }\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum UnboxedClosureKind {\n     FnUnboxedClosureKind,"}, {"sha": "1ed41e6870d7ef3692cb63cccaa5536318248a66", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -24,8 +24,7 @@ use std::string;\n #[deriving(PartialEq)]\n enum ArgumentType {\n     Known(string::String),\n-    Unsigned,\n-    String,\n+    Unsigned\n }\n \n enum Position {\n@@ -691,12 +690,6 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                 }\n             }\n-            String => {\n-                return ecx.expr_call_global(sp, vec![\n-                        ecx.ident_of(\"std\"),\n-                        ecx.ident_of(\"fmt\"),\n-                        ecx.ident_of(\"argumentstr\")], vec![arg])\n-            }\n             Unsigned => {\n                 return ecx.expr_call_global(sp, vec![\n                         ecx.ident_of(\"std\"),"}, {"sha": "095acf56e4865a39d9565e44ff44d7aee4d3c4c1", "filename": "src/test/compile-fail-fulldeps/syntax-extension-regex-unused-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-regex-unused-static.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -26,5 +26,5 @@ extern crate regex;\n // unused variable warning).\n \n fn main() {\n-    static fubar: regex::Regex = regex!(\"abc\"); //~ ERROR code is never used: `fubar`\n+    static fubar: regex::Regex = regex!(\"abc\"); //~ ERROR static item is never used: `fubar`\n }"}, {"sha": "58ecdec538e0bc2a25c6f4d834d3333a72b87ac0", "filename": "src/test/compile-fail/fail-no-dead-code-core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -15,7 +15,7 @@\n #[phase(link, plugin)] extern crate core;\n \n \n-fn foo() { //~ ERROR code is never used\n+fn foo() { //~ ERROR function is never used\n \n     // none of these should have any dead_code exposed to the user\n     fail!();"}, {"sha": "897710609fd41685e750b7ea1c1bbcf850dd9e82", "filename": "src/test/compile-fail/fail-no-dead-code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -11,7 +11,7 @@\n #![deny(dead_code)]\n #![allow(unreachable_code)]\n \n-fn foo() { //~ ERROR code is never used\n+fn foo() { //~ ERROR function is never used\n \n     // none of these should have any dead_code exposed to the user\n     fail!();"}, {"sha": "3e563e9e1380632a2b5dd1e4f15c41399b54f6d7", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -22,23 +22,23 @@ pub use foo2::Bar2;\n pub trait Sized {}\n \n mod foo {\n-    pub struct Bar; //~ ERROR: code is never used\n+    pub struct Bar; //~ ERROR: struct is never used\n }\n \n mod foo2 {\n     pub struct Bar2;\n }\n \n pub static pub_static: int = 0;\n-static priv_static: int = 0; //~ ERROR: code is never used\n+static priv_static: int = 0; //~ ERROR: static item is never used\n static used_static: int = 0;\n pub static used_static2: int = used_static;\n static USED_STATIC: int = 0;\n static STATIC_USED_IN_ENUM_DISCRIMINANT: int = 10;\n \n pub type typ = *const UsedStruct4;\n pub struct PubStruct;\n-struct PrivStruct; //~ ERROR: code is never used\n+struct PrivStruct; //~ ERROR: struct is never used\n struct UsedStruct1 {\n     #[allow(dead_code)]\n     x: int\n@@ -63,8 +63,12 @@ pub struct PubStruct2 {\n pub enum pub_enum { foo1, bar1 }\n pub enum pub_enum2 { a(*const StructUsedInEnum) }\n pub enum pub_enum3 { Foo = STATIC_USED_IN_ENUM_DISCRIMINANT }\n-enum priv_enum { foo2, bar2 } //~ ERROR: code is never used\n-enum used_enum { foo3, bar3 }\n+\n+enum priv_enum { foo2, bar2 } //~ ERROR: enum is never used\n+enum used_enum {\n+    foo3,\n+    bar3 //~ ERROR variant is never used\n+}\n \n fn f<T>() {}\n \n@@ -83,17 +87,17 @@ pub fn pub_fn() {\n     }\n     f::<StructUsedInGeneric>();\n }\n-fn priv_fn() { //~ ERROR: code is never used\n+fn priv_fn() { //~ ERROR: function is never used\n     let unused_struct = PrivStruct;\n }\n fn used_fn() {}\n \n-fn foo() { //~ ERROR: code is never used\n+fn foo() { //~ ERROR: function is never used\n     bar();\n     let unused_enum = foo2;\n }\n \n-fn bar() { //~ ERROR: code is never used\n+fn bar() { //~ ERROR: function is never used\n     foo();\n }\n "}, {"sha": "eb284c4d05426ab6e4baab394e49358b261332a7", "filename": "src/test/compile-fail/lint-dead-code-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -28,10 +28,10 @@ impl Bar for Foo {\n \n fn live_fn() {}\n \n-fn dead_fn() {} //~ ERROR: code is never used\n+fn dead_fn() {} //~ ERROR: function is never used\n \n #[main]\n-fn dead_fn2() {} //~ ERROR: code is never used\n+fn dead_fn2() {} //~ ERROR: function is never used\n \n fn used_fn() {}\n \n@@ -44,7 +44,7 @@ fn start(_: int, _: *const *const u8) -> int {\n }\n \n // this is not main\n-fn main() { //~ ERROR: code is never used\n+fn main() { //~ ERROR: function is never used\n     dead_fn();\n     dead_fn2();\n }"}, {"sha": "f73c19b5fc987c4da9983aad0c8ef0093ff1efd5", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -21,15 +21,15 @@ extern {\n     fn extern_foo();\n }\n \n-struct Foo; //~ ERROR: code is never used\n+struct Foo; //~ ERROR: struct is never used\n impl Foo {\n-    fn foo(&self) { //~ ERROR: code is never used\n+    fn foo(&self) { //~ ERROR: method is never used\n         bar()\n     }\n }\n \n-fn bar() { //~ ERROR: code is never used\n-    fn baz() {} //~ ERROR: code is never used\n+fn bar() { //~ ERROR: function is never used\n+    fn baz() {} //~ ERROR: function is never used\n \n     Foo.foo();\n     baz();\n@@ -68,9 +68,9 @@ mod blah {\n     }\n }\n \n-enum c_void {} //~ ERROR: code is never used\n+enum c_void {} //~ ERROR: enum is never used\n extern {\n-    fn free(p: *const c_void); //~ ERROR: code is never used\n+    fn free(p: *const c_void); //~ ERROR: foreign function is never used\n }\n \n // Check provided method"}, {"sha": "ba02faf11c305aa42b0febf3bdde7a055e12f180", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -19,7 +19,7 @@ use std::num;\n \n struct Foo {\n     x: uint,\n-    b: bool, //~ ERROR: code is never used\n+    b: bool, //~ ERROR: struct field is never used\n     marker: std::kinds::marker::NoCopy\n }\n \n@@ -28,10 +28,10 @@ fn field_read(f: Foo) -> uint {\n }\n \n enum XYZ {\n-    X,\n-    Y {\n+    X, //~ ERROR variant is never used\n+    Y { //~ ERROR variant is never used\n         a: String,\n-        b: int //~ ERROR: code is never used\n+        b: int //~ ERROR: struct field is never used\n     },\n     Z\n }\n@@ -44,7 +44,7 @@ fn field_match_in_patterns(b: XYZ) -> String {\n }\n \n struct Bar {\n-    x: uint, //~ ERROR: code is never used\n+    x: uint, //~ ERROR: struct field is never used\n     b: bool,\n     _guard: ()\n }"}, {"sha": "62afa089bbe2303472f68ce9d0855aac5bce26ed", "filename": "src/test/compile-fail/lint-dead-code-5.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-5.rs?ref=4d69696ff62fb9f069fd8f64eaa0defe4c8c9cf7", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+#![allow(unused_variable)]\n+#![deny(dead_code)]\n+\n+enum Enum1 {\n+    Variant1(int),\n+    Variant2 //~ ERROR: variant is never used\n+}\n+\n+enum Enum2 {\n+    Variant3(bool),\n+    #[allow(dead_code)]\n+    Variant4(int),\n+    Variant5 { _x: int }, //~ ERROR: variant is never used: `Variant5`\n+    Variant6(int), //~ ERROR: variant is never used: `Variant6`\n+    _Variant7,\n+}\n+\n+enum Enum3 { //~ ERROR: enum is never used\n+    Variant8,\n+    Variant9\n+}\n+\n+fn main() {\n+    let v = Variant1(1);\n+    match v {\n+        Variant1(_) => (),\n+        Variant2 => ()\n+    }\n+    let x = Variant3(true);\n+}"}]}