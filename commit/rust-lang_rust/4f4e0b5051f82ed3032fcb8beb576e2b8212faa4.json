{"sha": "4f4e0b5051f82ed3032fcb8beb576e2b8212faa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNGUwYjUwNTFmODJlZDMwMzJmY2I4YmViNTc2ZTJiODIxMmZhYTQ=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-06T10:23:24Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-06T10:23:24Z"}, "message": "Implement a call stack using the new memory system.", "tree": {"sha": "cee410492abc67527a7c632e8da4166173f84955", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cee410492abc67527a7c632e8da4166173f84955"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4", "html_url": "https://github.com/rust-lang/rust/commit/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e78465956864198acdd5ce8c0dcb465c9db5e48a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e78465956864198acdd5ce8c0dcb465c9db5e48a", "html_url": "https://github.com/rust-lang/rust/commit/e78465956864198acdd5ce8c0dcb465c9db5e48a"}], "stats": {"total": 203, "additions": 87, "deletions": 116}, "files": [{"sha": "f9a00fc9166d1d92beab54be326bbdc3b958db5b", "filename": "src/interpreter.rs", "status": "modified", "additions": 77, "deletions": 104, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=4f4e0b5051f82ed3032fcb8beb576e2b8212faa4", "patch": "@@ -54,116 +54,94 @@ impl fmt::Display for EvalError {\n //     Func(def_id::DefId),\n // }\n \n-/// A stack frame:\n-///\n-/// ```text\n-/// +-----------------------+\n-/// | Arg(0)                |\n-/// | Arg(1)                | arguments\n-/// | ...                   |\n-/// | Arg(num_args - 1)     |\n-/// + - - - - - - - - - - - +\n-/// | Var(0)                |\n-/// | Var(1)                | variables\n-/// | ...                   |\n-/// | Var(num_vars - 1)     |\n-/// + - - - - - - - - - - - +\n-/// | Temp(0)               |\n-/// | Temp(1)               | temporaries\n-/// | ...                   |\n-/// | Temp(num_temps - 1)   |\n-/// + - - - - - - - - - - - +\n-/// | Aggregates            | aggregates\n-/// +-----------------------+\n-/// ```\n-// #[derive(Debug)]\n-// struct Frame {\n-//     /// A pointer to a stack cell to write the return value of the current call, if it's not a\n-//     /// divering call.\n-//     return_ptr: Option<Pointer>,\n-\n-//     offset: usize,\n-//     num_args: usize,\n-//     num_vars: usize,\n-//     num_temps: usize,\n-//     num_aggregate_fields: usize,\n-// }\n+/// A stack frame.\n+#[derive(Debug)]\n+struct Frame {\n+    /// A pointer for writing the return value of the current call, if it's not a diverging call.\n+    return_ptr: Option<Pointer>,\n \n-// impl Frame {\n-//     fn size(&self) -> usize {\n-//         self.num_args + self.num_vars + self.num_temps + self.num_aggregate_fields\n-//     }\n+    /// The list of locals for the current function, stored in order as\n+    /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n+    /// and the temporaries at `self.temp_offset`.\n+    locals: Vec<Pointer>,\n \n-//     fn arg_offset(&self, i: usize) -> usize {\n-//         self.offset + i\n-//     }\n+    /// The offset of the first variable in `self.locals`.\n+    var_offset: usize,\n \n-//     fn var_offset(&self, i: usize) -> usize {\n-//         self.offset + self.num_args + i\n-//     }\n+    /// The offset of the first temporary in `self.locals`.\n+    temp_offset: usize,\n+}\n \n-//     fn temp_offset(&self, i: usize) -> usize {\n-//         self.offset + self.num_args + self.num_vars + i\n-//     }\n-// }\n+impl Frame {\n+    fn arg_ptr(&self, i: u32) -> Pointer {\n+        self.locals[i as usize].clone()\n+    }\n+\n+    fn var_ptr(&self, i: u32) -> Pointer {\n+        self.locals[self.var_offset + i as usize].clone()\n+    }\n+\n+    fn temp_ptr(&self, i: u32) -> Pointer {\n+        self.locals[self.temp_offset + i as usize].clone()\n+    }\n+}\n \n struct Interpreter<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     mir_map: &'a MirMap<'tcx>,\n-    // value_stack: Vec<Value>,\n-    // call_stack: Vec<Frame>,\n     memory: memory::Memory,\n-    return_ptr: Option<Pointer>,\n+    stack: Vec<Frame>,\n }\n \n impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n     fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         Interpreter {\n             tcx: tcx,\n             mir_map: mir_map,\n-            // value_stack: vec![Value::Uninit], // Allocate a spot for the top-level return value.\n-            // call_stack: Vec::new(),\n             memory: memory::Memory::new(),\n-            return_ptr: None,\n+            stack: Vec::new(),\n+        }\n+    }\n+\n+    fn push_stack_frame(&mut self, mir: &Mir, args: &[&mir::Operand], return_ptr: Option<Pointer>)\n+        -> EvalResult<()>\n+    {\n+        let num_args = mir.arg_decls.len();\n+        let num_vars = mir.var_decls.len();\n+        assert_eq!(args.len(), num_args);\n+\n+        let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n+        let var_tys = mir.var_decls.iter().map(|v| v.ty);\n+        let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n+\n+        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n+            self.memory.allocate(Repr::from_ty(ty))\n+        }).collect();\n+\n+        for (dest, operand) in locals[..num_args].iter().zip(args) {\n+            let src = try!(self.operand_to_ptr(operand));\n+            try!(self.memory.copy(&src, dest, dest.repr.size()));\n         }\n+\n+        self.stack.push(Frame { \n+            return_ptr: return_ptr,\n+            locals: locals,\n+            var_offset: num_args,\n+            temp_offset: num_args + num_vars,\n+        });\n+\n+        Ok(())\n     }\n \n-    // fn push_stack_frame(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) {\n-    //     let frame = Frame {\n-    //         return_ptr: return_ptr,\n-    //         offset: self.value_stack.len(),\n-    //         num_args: mir.arg_decls.len(),\n-    //         num_vars: mir.var_decls.len(),\n-    //         num_temps: mir.temp_decls.len(),\n-    //         num_aggregate_fields: 0,\n-    //     };\n-\n-    //     self.value_stack.extend(iter::repeat(Value::Uninit).take(frame.size()));\n-\n-    //     for (i, arg) in args.iter().enumerate() {\n-    //         self.value_stack[frame.arg_offset(i)] = arg.clone();\n-    //     }\n-\n-    //     self.call_stack.push(frame);\n-    // }\n-\n-    // fn pop_stack_frame(&mut self) {\n-    //     let frame = self.call_stack.pop().expect(\"tried to pop stack frame, but there were none\");\n-    //     self.value_stack.truncate(frame.offset);\n-    // }\n-\n-    // fn allocate_aggregate(&mut self, size: usize) -> Pointer {\n-    //     let frame = self.call_stack.last_mut().expect(\"missing call frame\");\n-    //     frame.num_aggregate_fields += size;\n-\n-    //     let ptr = Pointer::Stack(self.value_stack.len());\n-    //     self.value_stack.extend(iter::repeat(Value::Uninit).take(size));\n-    //     ptr\n-    // }\n-\n-    fn call(&mut self, mir: &Mir, args: &[Allocation], return_ptr: Option<Pointer>) -> EvalResult<()> {\n-        self.return_ptr = return_ptr;\n-        // self.push_stack_frame(mir, args, return_ptr);\n+    fn pop_stack_frame(&mut self) {\n+        let _frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        // TODO(tsion): Deallocate local variables.\n+    }\n+\n+    fn call(&mut self, mir: &Mir, args: &[&mir::Operand], return_ptr: Option<Pointer>)\n+        -> EvalResult<()>\n+    {\n+        try!(self.push_stack_frame(mir, args, return_ptr));\n         let mut block = mir::START_BLOCK;\n \n         loop {\n@@ -252,29 +230,24 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n             }\n         }\n \n-        // self.pop_stack_frame();\n-\n+        self.pop_stack_frame();\n         Ok(())\n     }\n \n     fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue) -> EvalResult<Pointer> {\n+        let frame = self.stack.last().expect(\"no call frames exists\");\n+\n         let ptr = match *lvalue {\n-            mir::Lvalue::ReturnPointer =>\n-                self.return_ptr.clone().expect(\"fn has no return pointer\"),\n-            _ => unimplemented!(),\n+            mir::Lvalue::ReturnPointer => frame.return_ptr.clone()\n+                .expect(\"ReturnPointer used in a function with no return value\"),\n+            mir::Lvalue::Arg(i)  => frame.arg_ptr(i),\n+            mir::Lvalue::Var(i)  => frame.var_ptr(i),\n+            mir::Lvalue::Temp(i) => frame.temp_ptr(i),\n+            ref l => panic!(\"can't handle lvalue: {:?}\", l),\n         };\n \n         Ok(ptr)\n \n-        // let frame = self.call_stack.last().expect(\"missing call frame\");\n-\n-        // match *lvalue {\n-        //     mir::Lvalue::ReturnPointer =>\n-        //         frame.return_ptr.expect(\"ReturnPointer used in a function with no return value\"),\n-        //     mir::Lvalue::Arg(i)  => Pointer::Stack(frame.arg_offset(i as usize)),\n-        //     mir::Lvalue::Var(i)  => Pointer::Stack(frame.var_offset(i as usize)),\n-        //     mir::Lvalue::Temp(i) => Pointer::Stack(frame.temp_offset(i as usize)),\n-\n         //     mir::Lvalue::Projection(ref proj) => {\n         //         let base_ptr = self.lvalue_to_ptr(&proj.base);\n "}, {"sha": "36c82649c51633c72359591d5db07fd4a472f4d9", "filename": "test/new_values.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4/test%2Fnew_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4e0b5051f82ed3032fcb8beb576e2b8212faa4/test%2Fnew_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fnew_values.rs?ref=4f4e0b5051f82ed3032fcb8beb576e2b8212faa4", "patch": "@@ -34,17 +34,17 @@ fn tuple_5() -> (i32, i32, i32, i32, i32) {\n     (1, 2, 3, 4, 5)\n }\n \n-// #[miri_run(expected = \"Int(3)\")]\n-// fn indirect_add() -> i32 {\n-//     let x = 1;\n-//     let y = 2;\n-//     x + y\n-// }\n+#[miri_run]\n+fn indirect_add() -> i32 {\n+    let x = 1;\n+    let y = 2;\n+    x + y\n+}\n \n-// #[miri_run(expected = \"Int(25)\")]\n-// fn arith() -> i32 {\n-//     3*3 + 4*4\n-// }\n+#[miri_run]\n+fn arith() -> i32 {\n+    3*3 + 4*4\n+}\n \n // #[miri_run(expected = \"Int(0)\")]\n // fn if_false() -> i32 {\n@@ -190,5 +190,3 @@ fn tuple_5() -> (i32, i32, i32, i32, i32) {\n // fn cross_crate_fn_call() -> i32 {\n //     if 1i32.is_positive() { 1 } else { 0 }\n // }\n-\n-// fn main() {}"}]}