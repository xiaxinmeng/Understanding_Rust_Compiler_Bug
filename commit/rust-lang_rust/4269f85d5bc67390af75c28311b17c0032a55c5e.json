{"sha": "4269f85d5bc67390af75c28311b17c0032a55c5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNjlmODVkNWJjNjczOTBhZjc1YzI4MzExYjE3YzAwMzJhNTVjNWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-28T00:11:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:01:58Z"}, "message": "libsyntax: De-`@mut` `name_idx`", "tree": {"sha": "264ede01faca7a74a04b45800cf1bfb429b4c887", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/264ede01faca7a74a04b45800cf1bfb429b4c887"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4269f85d5bc67390af75c28311b17c0032a55c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4269f85d5bc67390af75c28311b17c0032a55c5e", "html_url": "https://github.com/rust-lang/rust/commit/4269f85d5bc67390af75c28311b17c0032a55c5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4269f85d5bc67390af75c28311b17c0032a55c5e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/449ebeea08a3e0c50b3487bc6d561f49caf57b7e", "html_url": "https://github.com/rust-lang/rust/commit/449ebeea08a3e0c50b3487bc6d561f49caf57b7e"}], "stats": {"total": 15, "additions": 8, "deletions": 7}, "files": [{"sha": "ca856a5311670a0afc3df7772dd0b5edc03bd850", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4269f85d5bc67390af75c28311b17c0032a55c5e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4269f85d5bc67390af75c28311b17c0032a55c5e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4269f85d5bc67390af75c28311b17c0032a55c5e", "patch": "@@ -81,6 +81,7 @@ use parse::{new_sub_parser_from_file, ParseSess};\n use opt_vec;\n use opt_vec::OptVec;\n \n+use std::cell::Cell;\n use std::hashmap::HashSet;\n use std::util;\n use std::vec;\n@@ -2185,7 +2186,7 @@ impl Parser {\n         // unification of matchers and token_trees would vastly improve\n         // the interpolation of matchers\n         maybe_whole!(self, nt_matchers);\n-        let name_idx = @mut 0u;\n+        let name_idx = @Cell::new(0u);\n         match self.token {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n                 let other_delimiter = token::flip_delimiter(&self.token);\n@@ -2200,7 +2201,7 @@ impl Parser {\n     // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n     pub fn parse_matcher_subseq_upto(&mut self,\n-                                     name_idx: @mut uint,\n+                                     name_idx: @Cell<uint>,\n                                      ket: &token::Token)\n                                      -> ~[matcher] {\n         let mut ret_val = ~[];\n@@ -2217,27 +2218,27 @@ impl Parser {\n         return ret_val;\n     }\n \n-    pub fn parse_matcher(&mut self, name_idx: @mut uint) -> matcher {\n+    pub fn parse_matcher(&mut self, name_idx: @Cell<uint>) -> matcher {\n         let lo = self.span.lo;\n \n         let m = if self.token == token::DOLLAR {\n             self.bump();\n             if self.token == token::LPAREN {\n-                let name_idx_lo = *name_idx;\n+                let name_idx_lo = name_idx.get();\n                 self.bump();\n                 let ms = self.parse_matcher_subseq_upto(name_idx,\n                                                         &token::RPAREN);\n                 if ms.len() == 0u {\n                     self.fatal(\"repetition body must be nonempty\");\n                 }\n                 let (sep, zerok) = self.parse_sep_and_zerok();\n-                match_seq(ms, sep, zerok, name_idx_lo, *name_idx)\n+                match_seq(ms, sep, zerok, name_idx_lo, name_idx.get())\n             } else {\n                 let bound_to = self.parse_ident();\n                 self.expect(&token::COLON);\n                 let nt_name = self.parse_ident();\n-                let m = match_nonterminal(bound_to, nt_name, *name_idx);\n-                *name_idx += 1u;\n+                let m = match_nonterminal(bound_to, nt_name, name_idx.get());\n+                name_idx.set(name_idx.get() + 1u);\n                 m\n             }\n         } else {"}]}