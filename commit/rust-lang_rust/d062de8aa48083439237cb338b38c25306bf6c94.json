{"sha": "d062de8aa48083439237cb338b38c25306bf6c94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNjJkZThhYTQ4MDgzNDM5MjM3Y2IzMzhiMzhjMjUzMDZiZjZjOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-24T02:20:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-24T02:20:58Z"}, "message": "auto merge of #9310 : pcwalton/rust/at-fn, r=pcwalton\n\nr? @brson", "tree": {"sha": "1ced905a1f2255a3f5207ed6c70fbe5e80cf4b41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ced905a1f2255a3f5207ed6c70fbe5e80cf4b41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d062de8aa48083439237cb338b38c25306bf6c94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d062de8aa48083439237cb338b38c25306bf6c94", "html_url": "https://github.com/rust-lang/rust/commit/d062de8aa48083439237cb338b38c25306bf6c94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d062de8aa48083439237cb338b38c25306bf6c94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "348d8446739f9633897a3d728d265ee6ac59c8fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/348d8446739f9633897a3d728d265ee6ac59c8fb", "html_url": "https://github.com/rust-lang/rust/commit/348d8446739f9633897a3d728d265ee6ac59c8fb"}, {"sha": "3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f", "html_url": "https://github.com/rust-lang/rust/commit/3b1d3e5bf8e2f288147fd879b37bc5e6f8c5528f"}], "stats": {"total": 5783, "additions": 2854, "deletions": 2929}, "files": [{"sha": "a8d384226a3507b90d715728aa929740305c7e3e", "filename": "doc/tutorial.md", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1469,34 +1469,6 @@ cannot be stored in data structures or returned from\n functions. Despite these limitations, stack closures are used\n pervasively in Rust code.\n \n-## Managed closures\n-\n-When you need to store a closure in a data structure, a stack closure\n-will not do, since the compiler will refuse to let you store it. For\n-this purpose, Rust provides a type of closure that has an arbitrary\n-lifetime, written `@fn` (boxed closure, analogous to the `@` pointer\n-type described earlier). This type of closure *is* first-class.\n-\n-A managed closure does not directly access its environment, but merely\n-copies out the values that it closes over into a private data\n-structure. This means that it can not assign to these variables, and\n-cannot observe updates to them.\n-\n-This code creates a closure that adds a given string to its argument,\n-returns it from a function, and then calls it:\n-\n-~~~~\n-fn mk_appender(suffix: ~str) -> @fn(~str) -> ~str {\n-    // The compiler knows that we intend this closure to be of type @fn\n-    return |s| s + suffix;\n-}\n-\n-fn main() {\n-    let shout = mk_appender(~\"!\");\n-    println(shout(~\"hey ho, let's go\"));\n-}\n-~~~~\n-\n ## Owned closures\n \n Owned closures, written `~fn` in analogy to the `~` pointer type,"}, {"sha": "bd3ce20742ed19e26382382585b7ebec9862afff", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 37, "deletions": 22, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -36,37 +36,39 @@\n  * still held if needed.\n  */\n \n-\n-use std::option;\n use std::ptr;\n+use std::routine::Runnable;\n+use std::util;\n \n /**\n  * The type representing a foreign chunk of memory\n- *\n  */\n pub struct CVec<T> {\n     priv base: *mut T,\n     priv len: uint,\n-    priv rsrc: @DtorRes\n+    priv rsrc: @DtorRes,\n }\n \n struct DtorRes {\n-  dtor: Option<@fn()>,\n+    dtor: Option<~Runnable>,\n }\n \n #[unsafe_destructor]\n impl Drop for DtorRes {\n     fn drop(&mut self) {\n-        match self.dtor {\n-            option::None => (),\n-            option::Some(f) => f()\n+        let dtor = util::replace(&mut self.dtor, None);\n+        match dtor {\n+            None => (),\n+            Some(f) => f.run()\n         }\n     }\n }\n \n-fn DtorRes(dtor: Option<@fn()>) -> DtorRes {\n-    DtorRes {\n-        dtor: dtor\n+impl DtorRes {\n+    fn new(dtor: Option<~Runnable>) -> DtorRes {\n+        DtorRes {\n+            dtor: dtor,\n+        }\n     }\n }\n \n@@ -83,10 +85,10 @@ fn DtorRes(dtor: Option<@fn()>) -> DtorRes {\n  * * len - The number of elements in the buffer\n  */\n pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n-    return CVec{\n+    return CVec {\n         base: base,\n         len: len,\n-        rsrc: @DtorRes(option::None)\n+        rsrc: @DtorRes::new(None)\n     };\n }\n \n@@ -101,12 +103,12 @@ pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n  * * dtor - A function to run when the value is destructed, useful\n  *          for freeing the buffer, etc.\n  */\n-pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n-  -> CVec<T> {\n+pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: ~Runnable)\n+                                 -> CVec<T> {\n     return CVec{\n         base: base,\n         len: len,\n-        rsrc: @DtorRes(option::Some(dtor))\n+        rsrc: @DtorRes::new(Some(dtor))\n     };\n }\n \n@@ -153,6 +155,20 @@ mod tests {\n \n     use std::libc::*;\n     use std::libc;\n+    use std::routine::Runnable;\n+\n+    struct LibcFree {\n+        mem: *c_void,\n+    }\n+\n+    impl Runnable for LibcFree {\n+        #[fixed_stack_segment]\n+        fn run(~self) {\n+            unsafe {\n+                libc::free(self.mem)\n+            }\n+        }\n+    }\n \n     fn malloc(n: size_t) -> CVec<u8> {\n         #[fixed_stack_segment];\n@@ -163,12 +179,11 @@ mod tests {\n \n             assert!(mem as int != 0);\n \n-            return c_vec_with_dtor(mem as *mut u8, n as uint, || f(mem));\n-        }\n-\n-        fn f(mem: *c_void) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            unsafe { libc::free(mem) }\n+            return c_vec_with_dtor(mem as *mut u8,\n+                                   n as uint,\n+                                   ~LibcFree {\n+                                    mem: mem,\n+                                   } as ~Runnable);\n         }\n     }\n "}, {"sha": "7662a159ba49a3943e3c4ded2855a20896fc9018", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -30,7 +30,7 @@ pub mod rustrt {\n \n macro_rules! locked {\n     ($expr:expr) => {\n-        unsafe {\n+        {\n             // FIXME #9105: can't use a static mutex in pure Rust yet.\n             rustrt::rust_take_linenoise_lock();\n             let x = $expr;\n@@ -43,35 +43,46 @@ macro_rules! locked {\n /// Add a line to history\n pub fn add_history(line: &str) -> bool {\n     do line.with_c_str |buf| {\n-        (locked!(rustrt::linenoiseHistoryAdd(buf))) == 1 as c_int\n+        unsafe {\n+            (locked!(rustrt::linenoiseHistoryAdd(buf))) == 1 as c_int\n+        }\n     }\n }\n \n /// Set the maximum amount of lines stored\n pub fn set_history_max_len(len: int) -> bool {\n-    (locked!(rustrt::linenoiseHistorySetMaxLen(len as c_int))) == 1 as c_int\n+    unsafe {\n+        (locked!(rustrt::linenoiseHistorySetMaxLen(len as c_int))) == 1\n+            as c_int\n+    }\n }\n \n /// Save line history to a file\n pub fn save_history(file: &str) -> bool {\n     do file.with_c_str |buf| {\n         // 0 on success, -1 on failure\n-        (locked!(rustrt::linenoiseHistorySave(buf))) == 0 as c_int\n+        unsafe {\n+            (locked!(rustrt::linenoiseHistorySave(buf))) == 0 as c_int\n+        }\n     }\n }\n \n /// Load line history from a file\n pub fn load_history(file: &str) -> bool {\n     do file.with_c_str |buf| {\n         // 0 on success, -1 on failure\n-        (locked!(rustrt::linenoiseHistoryLoad(buf))) == 0 as c_int\n+        unsafe {\n+            (locked!(rustrt::linenoiseHistoryLoad(buf))) == 0 as c_int\n+        }\n     }\n }\n \n /// Print out a prompt and then wait for input and return it\n pub fn read(prompt: &str) -> Option<~str> {\n     do prompt.with_c_str |buf| {\n-        let line = locked!(rustrt::linenoise(buf));\n+        let line = unsafe {\n+            locked!(rustrt::linenoise(buf))\n+        };\n \n         if line.is_null() { None }\n         else {\n@@ -88,35 +99,36 @@ pub fn read(prompt: &str) -> Option<~str> {\n     }\n }\n \n-pub type CompletionCb = @fn(~str, @fn(~str));\n+/// The callback used to perform completions.\n+pub trait CompletionCb {\n+    /// Performs a completion.\n+    fn complete(&self, line: ~str, suggestion: &fn(~str));\n+}\n \n-local_data_key!(complete_key: CompletionCb)\n+local_data_key!(complete_key: @CompletionCb)\n \n /// Bind to the main completion callback in the current task.\n ///\n /// The completion callback should not call any `extra::rl` functions\n /// other than the closure that it receives as its second\n /// argument. Calling such a function will deadlock on the mutex used\n /// to ensure that the calls are thread-safe.\n-pub fn complete(cb: CompletionCb) {\n+pub unsafe fn complete(cb: @CompletionCb) {\n     local_data::set(complete_key, cb);\n \n-    extern fn callback(c_line: *c_char, completions: *()) {\n+    extern fn callback(line: *c_char, completions: *()) {\n         do local_data::get(complete_key) |opt_cb| {\n             // only fetch completions if a completion handler has been\n             // registered in the current task.\n             match opt_cb {\n-                None => {},\n+                None => {}\n                 Some(cb) => {\n-                    let line = unsafe { str::raw::from_c_str(c_line) };\n-                    do (*cb)(line) |suggestion| {\n-                        do suggestion.with_c_str |buf| {\n-                            // This isn't locked, because `callback` gets\n-                            // called inside `rustrt::linenoise`, which\n-                            // *is* already inside the mutex, so\n-                            // re-locking would be a deadlock.\n-                            unsafe {\n-                                rustrt::linenoiseAddCompletion(completions, buf);\n+                    unsafe {\n+                        do cb.complete(str::raw::from_c_str(line))\n+                                |suggestion| {\n+                            do suggestion.with_c_str |buf| {\n+                                rustrt::linenoiseAddCompletion(completions,\n+                                                               buf);\n                             }\n                         }\n                     }"}, {"sha": "7400973c28a809226b5e460a06d4a5b20e2c6bf4", "filename": "src/libextra/test.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -807,11 +807,6 @@ pub fn filter_tests(\n     }\n }\n \n-struct TestFuture {\n-    test: TestDesc,\n-    wait: @fn() -> TestResult,\n-}\n-\n pub fn run_test(force_ignore: bool,\n                 test: TestDescAndFn,\n                 monitor_ch: SharedChan<MonitorMsg>) {"}, {"sha": "c9a5ca2c61c40ac8362fa5788267e0c6990a922f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 99, "deletions": 56, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -113,8 +113,8 @@ pub fn build_configuration(sess: Session) ->\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: ~[~str],\n-                  demitter: diagnostic::Emitter) -> ast::CrateConfig {\n+fn parse_cfgspecs(cfgspecs: ~[~str], demitter: @diagnostic::Emitter)\n+                  -> ast::CrateConfig {\n     do cfgspecs.move_iter().map |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n         parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n@@ -439,15 +439,70 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n     phase_6_link_output(sess, &trans, outputs);\n }\n \n-pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n-                          ppm: PpMode) {\n+struct IdentifiedAnnotation {\n+    contents: (),\n+}\n \n-    fn ann_paren_for_expr(node: pprust::ann_node) {\n+impl pprust::pp_ann for IdentifiedAnnotation {\n+    fn pre(&self, node: pprust::ann_node) {\n         match node {\n-          pprust::node_expr(s, _) => pprust::popen(s),\n-          _ => ()\n+            pprust::node_expr(s, _) => pprust::popen(s),\n+            _ => ()\n+        }\n+    }\n+    fn post(&self, node: pprust::ann_node) {\n+        match node {\n+            pprust::node_item(s, item) => {\n+                pp::space(s.s);\n+                pprust::synth_comment(s, item.id.to_str());\n+            }\n+            pprust::node_block(s, ref blk) => {\n+                pp::space(s.s);\n+                pprust::synth_comment(s, ~\"block \" + blk.id.to_str());\n+            }\n+            pprust::node_expr(s, expr) => {\n+                pp::space(s.s);\n+                pprust::synth_comment(s, expr.id.to_str());\n+                pprust::pclose(s);\n+            }\n+            pprust::node_pat(s, pat) => {\n+                pp::space(s.s);\n+                pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n+            }\n         }\n     }\n+}\n+\n+struct TypedAnnotation {\n+    analysis: CrateAnalysis,\n+}\n+\n+impl pprust::pp_ann for TypedAnnotation {\n+    fn pre(&self, node: pprust::ann_node) {\n+        match node {\n+            pprust::node_expr(s, _) => pprust::popen(s),\n+            _ => ()\n+        }\n+    }\n+    fn post(&self, node: pprust::ann_node) {\n+        let tcx = self.analysis.ty_cx;\n+        match node {\n+            pprust::node_expr(s, expr) => {\n+                pp::space(s.s);\n+                pp::word(s.s, \"as\");\n+                pp::space(s.s);\n+                pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+                pprust::pclose(s);\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+pub fn pretty_print_input(sess: Session,\n+                          cfg: ast::CrateConfig,\n+                          input: &input,\n+                          ppm: PpMode) {\n     fn ann_typed_post(tcx: ty::ctxt, node: pprust::ann_node) {\n         match node {\n           pprust::node_expr(s, expr) => {\n@@ -460,28 +515,6 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n           _ => ()\n         }\n     }\n-    fn ann_identified_post(node: pprust::ann_node) {\n-        match node {\n-          pprust::node_item(s, item) => {\n-            pp::space(s.s);\n-            pprust::synth_comment(s, item.id.to_str());\n-          }\n-          pprust::node_block(s, ref blk) => {\n-            pp::space(s.s);\n-            pprust::synth_comment(\n-                s, ~\"block \" + blk.id.to_str());\n-          }\n-          pprust::node_expr(s, expr) => {\n-            pp::space(s.s);\n-            pprust::synth_comment(s, expr.id.to_str());\n-            pprust::pclose(s);\n-          }\n-          pprust::node_pat(s, pat) => {\n-            pp::space(s.s);\n-            pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n-          }\n-        }\n-    }\n \n     let crate = phase_1_parse_input(sess, cfg.clone(), input);\n \n@@ -494,28 +527,30 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n \n     let annotation = match ppm {\n         PpmIdentified | PpmExpandedIdentified => {\n-            pprust::pp_ann {\n-                pre: ann_paren_for_expr,\n-                post: ann_identified_post\n-            }\n+            @IdentifiedAnnotation {\n+                contents: (),\n+            } as @pprust::pp_ann\n         }\n         PpmTyped => {\n             let analysis = phase_3_run_analysis_passes(sess, crate);\n-            pprust::pp_ann {\n-                pre: ann_paren_for_expr,\n-                post: |a| ann_typed_post(analysis.ty_cx, a)\n-            }\n+            @TypedAnnotation {\n+                analysis: analysis\n+            } as @pprust::pp_ann\n         }\n-        _ => pprust::no_ann()\n+        _ => @pprust::no_ann::new() as @pprust::pp_ann,\n     };\n \n     let src = sess.codemap.get_filemap(source_name(input)).src;\n     do io::with_str_reader(src) |rdr| {\n-        pprust::print_crate(sess.codemap, token::get_ident_interner(),\n-                            sess.span_diagnostic, crate,\n+        pprust::print_crate(sess.codemap,\n+                            token::get_ident_interner(),\n+                            sess.span_diagnostic,\n+                            crate,\n                             source_name(input),\n-                            rdr, io::stdout(),\n-                            annotation, is_expanded);\n+                            rdr,\n+                            io::stdout(),\n+                            annotation,\n+                            is_expanded);\n     }\n }\n \n@@ -554,8 +589,8 @@ static architecture_abis : &'static [(&'static str, abi::Architecture)] = &'stat\n     (\"mips\",   abi::Mips)];\n \n pub fn build_target_config(sopts: @session::options,\n-                           demitter: diagnostic::Emitter)\n-                        -> @session::config {\n+                           demitter: @diagnostic::Emitter)\n+                           -> @session::config {\n     let os = match get_os(sopts.target_triple) {\n       Some(os) => os,\n       None => early_error(demitter, ~\"unknown operating system\")\n@@ -603,8 +638,8 @@ pub fn host_triple() -> ~str {\n \n pub fn build_session_options(binary: @str,\n                              matches: &getopts::Matches,\n-                             demitter: diagnostic::Emitter)\n-                          -> @session::options {\n+                             demitter: @diagnostic::Emitter)\n+                             -> @session::options {\n     let crate_type = if matches.opt_present(\"lib\") {\n         session::lib_crate\n     } else if matches.opt_present(\"bin\") {\n@@ -777,8 +812,8 @@ pub fn build_session_options(binary: @str,\n     return sopts;\n }\n \n-pub fn build_session(sopts: @session::options,\n-                     demitter: diagnostic::Emitter) -> Session {\n+pub fn build_session(sopts: @session::options, demitter: @diagnostic::Emitter)\n+                     -> Session {\n     let codemap = @codemap::CodeMap::new();\n     let diagnostic_handler =\n         diagnostic::mk_handler(Some(demitter));\n@@ -789,9 +824,9 @@ pub fn build_session(sopts: @session::options,\n \n pub fn build_session_(sopts: @session::options,\n                       cm: @codemap::CodeMap,\n-                      demitter: diagnostic::Emitter,\n+                      demitter: @diagnostic::Emitter,\n                       span_diagnostic_handler: @mut diagnostic::span_handler)\n-                   -> Session {\n+                      -> Session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n@@ -1000,8 +1035,8 @@ pub fn build_output_filenames(input: &input,\n     }\n }\n \n-pub fn early_error(emitter: diagnostic::Emitter, msg: ~str) -> ! {\n-    emitter(None, msg, diagnostic::fatal);\n+pub fn early_error(emitter: @diagnostic::Emitter, msg: ~str) -> ! {\n+    emitter.emit(None, msg, diagnostic::fatal);\n     fail!();\n }\n \n@@ -1030,8 +1065,12 @@ mod test {\n               Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", f.to_err_msg())\n             };\n         let sessopts = build_session_options(\n-            @\"rustc\", matches, diagnostic::emit);\n-        let sess = build_session(sessopts, diagnostic::emit);\n+            @\"rustc\",\n+            matches,\n+            @diagnostic::DefaultEmitter as @diagnostic::Emitter);\n+        let sess = build_session(sessopts,\n+                                 @diagnostic::DefaultEmitter as\n+                                    @diagnostic::Emitter);\n         let cfg = build_configuration(sess);\n         assert!((attr::contains_name(cfg, \"test\")));\n     }\n@@ -1048,8 +1087,12 @@ mod test {\n               }\n             };\n         let sessopts = build_session_options(\n-            @\"rustc\", matches, diagnostic::emit);\n-        let sess = build_session(sessopts, diagnostic::emit);\n+            @\"rustc\",\n+            matches,\n+            @diagnostic::DefaultEmitter as @diagnostic::Emitter);\n+        let sess = build_session(sessopts,\n+                                 @diagnostic::DefaultEmitter as\n+                                    @diagnostic::Emitter);\n         let cfg = build_configuration(sess);\n         let mut test_items = cfg.iter().filter(|m| \"test\" == m.name());\n         assert!(test_items.next().is_some());"}, {"sha": "fc1b034de97e1a86d90ed3142e50d73fd5d80fa0", "filename": "src/librustc/front/assign_node_ids.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,9 +11,22 @@\n use driver::session::Session;\n \n use syntax::ast;\n-use syntax::ast_util;\n+use syntax::fold::ast_fold;\n+\n+struct NodeIdAssigner {\n+    sess: Session,\n+}\n+\n+impl ast_fold for NodeIdAssigner {\n+    fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n+        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+        self.sess.next_node_id()\n+    }\n+}\n \n pub fn assign_node_ids(sess: Session, crate: @ast::Crate) -> @ast::Crate {\n-    let fold = ast_util::node_id_assigner(|| sess.next_node_id());\n+    let fold = NodeIdAssigner {\n+        sess: sess,\n+    };\n     @fold.fold_crate(crate)\n }"}, {"sha": "efaebcca011280c2dcc8e46b1ccf9f29bd6470e0", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 73, "deletions": 63, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,13 +9,11 @@\n // except according to those terms.\n \n \n-use std::option;\n+use syntax::fold::ast_fold;\n use syntax::{ast, fold, attr};\n \n-type in_cfg_pred = @fn(attrs: &[ast::Attribute]) -> bool;\n-\n-struct Context {\n-    in_cfg: in_cfg_pred\n+struct Context<'self> {\n+    in_cfg: &'self fn(attrs: &[ast::Attribute]) -> bool,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n@@ -26,43 +24,55 @@ pub fn strip_unconfigured_items(crate: @ast::Crate) -> @ast::Crate {\n     }\n }\n \n-pub fn strip_items(crate: &ast::Crate, in_cfg: in_cfg_pred)\n-    -> @ast::Crate {\n-\n-    let ctxt = @Context { in_cfg: in_cfg };\n+impl<'self> fold::ast_fold for Context<'self> {\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        fold_mod(self, module)\n+    }\n+    fn fold_block(&self, block: &ast::Block) -> ast::Block {\n+        fold_block(self, block)\n+    }\n+    fn fold_foreign_mod(&self, foreign_module: &ast::foreign_mod)\n+                        -> ast::foreign_mod {\n+        fold_foreign_mod(self, foreign_module)\n+    }\n+    fn fold_item_underscore(&self, item: &ast::item_) -> ast::item_ {\n+        fold_item_underscore(self, item)\n+    }\n+}\n \n-    let precursor = @fold::AstFoldFns {\n-          fold_mod: |a,b| fold_mod(ctxt, a, b),\n-          fold_block: |a,b| fold_block(ctxt, a, b),\n-          fold_foreign_mod: |a,b| fold_foreign_mod(ctxt, a, b),\n-          fold_item_underscore: |a,b| fold_item_underscore(ctxt, a, b),\n-          .. *fold::default_ast_fold()\n+pub fn strip_items(crate: &ast::Crate,\n+                   in_cfg: &fn(attrs: &[ast::Attribute]) -> bool)\n+                   -> @ast::Crate {\n+    let ctxt = Context {\n+        in_cfg: in_cfg,\n     };\n-\n-    let fold = fold::make_fold(precursor);\n-    @fold.fold_crate(crate)\n+    @ctxt.fold_crate(crate)\n }\n \n-fn filter_item(cx: @Context, item: @ast::item) ->\n-   Option<@ast::item> {\n-    if item_in_cfg(cx, item) { option::Some(item) } else { option::None }\n+fn filter_item(cx: &Context, item: @ast::item) -> Option<@ast::item> {\n+    if item_in_cfg(cx, item) {\n+        Some(item)\n+    } else {\n+        None\n+    }\n }\n \n-fn filter_view_item<'r>(cx: @Context, view_item: &'r ast::view_item)-> Option<&'r ast::view_item> {\n+fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n+                        -> Option<&'r ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n-        option::Some(view_item)\n+        Some(view_item)\n     } else {\n-        option::None\n+        None\n     }\n }\n \n-fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n-    let filtered_items = do  m.items.iter().filter_map |a| {\n-        filter_item(cx, *a).and_then(|x| fld.fold_item(x))\n+fn fold_mod(cx: &Context, m: &ast::_mod) -> ast::_mod {\n+    let filtered_items = do m.items.iter().filter_map |a| {\n+        filter_item(cx, *a).and_then(|x| cx.fold_item(x))\n     }.collect();\n     let filtered_view_items = do m.view_items.iter().filter_map |a| {\n         do filter_view_item(cx, a).map_move |x| {\n-            fld.fold_view_item(x)\n+            cx.fold_view_item(x)\n         }\n     }.collect();\n     ast::_mod {\n@@ -71,22 +81,23 @@ fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n     }\n }\n \n-fn filter_foreign_item(cx: @Context, item: @ast::foreign_item) ->\n-   Option<@ast::foreign_item> {\n+fn filter_foreign_item(cx: &Context, item: @ast::foreign_item)\n+                       -> Option<@ast::foreign_item> {\n     if foreign_item_in_cfg(cx, item) {\n-        option::Some(item)\n-    } else { option::None }\n+        Some(item)\n+    } else {\n+        None\n+    }\n }\n \n-fn fold_foreign_mod(\n-    cx: @Context,\n-    nm: &ast::foreign_mod,\n-    fld: @fold::ast_fold\n-) -> ast::foreign_mod {\n-    let filtered_items = nm.items.iter().filter_map(|a| filter_foreign_item(cx, *a)).collect();\n+fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n+    let filtered_items = nm.items\n+                           .iter()\n+                           .filter_map(|a| filter_foreign_item(cx, *a))\n+                           .collect();\n     let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n         do filter_view_item(cx, a).map_move |x| {\n-            fld.fold_view_item(x)\n+            cx.fold_view_item(x)\n         }\n     }.collect();\n     ast::foreign_mod {\n@@ -97,80 +108,78 @@ fn fold_foreign_mod(\n     }\n }\n \n-fn fold_item_underscore(cx: @Context, item: &ast::item_,\n-                        fld: @fold::ast_fold) -> ast::item_ {\n+fn fold_item_underscore(cx: &Context, item: &ast::item_) -> ast::item_ {\n     let item = match *item {\n         ast::item_impl(ref a, ref b, ref c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n                 .map(|x| *x).collect();\n             ast::item_impl((*a).clone(), (*b).clone(), (*c).clone(), methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n-            let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )\n-                .map(|x| (*x).clone()).collect();\n+            let methods = methods.iter()\n+                                 .filter(|m| trait_method_in_cfg(cx, *m) )\n+                                 .map(|x| (*x).clone())\n+                                 .collect();\n             ast::item_trait((*a).clone(), (*b).clone(), methods)\n         }\n         ref item => (*item).clone(),\n     };\n \n-    fold::noop_fold_item_underscore(&item, fld)\n+    fold::noop_fold_item_underscore(&item, cx)\n }\n \n-fn filter_stmt(cx: @Context, stmt: @ast::Stmt) ->\n-   Option<@ast::Stmt> {\n+fn filter_stmt(cx: &Context, stmt: @ast::Stmt) -> Option<@ast::Stmt> {\n     match stmt.node {\n       ast::StmtDecl(decl, _) => {\n         match decl.node {\n           ast::DeclItem(item) => {\n             if item_in_cfg(cx, item) {\n-                option::Some(stmt)\n-            } else { option::None }\n+                Some(stmt)\n+            } else {\n+                None\n+            }\n           }\n-          _ => option::Some(stmt)\n+          _ => Some(stmt)\n         }\n       }\n-      _ => option::Some(stmt)\n+      _ => Some(stmt),\n     }\n }\n \n-fn fold_block(\n-    cx: @Context,\n-    b: &ast::Block,\n-    fld: @fold::ast_fold\n-) -> ast::Block {\n+fn fold_block(cx: &Context, b: &ast::Block) -> ast::Block {\n     let resulting_stmts = do b.stmts.iter().filter_map |a| {\n-        filter_stmt(cx, *a).and_then(|stmt| fld.fold_stmt(stmt))\n+        filter_stmt(cx, *a).and_then(|stmt| cx.fold_stmt(stmt))\n     }.collect();\n     let filtered_view_items = do b.view_items.iter().filter_map |a| {\n-        filter_view_item(cx, a).map(|x| fld.fold_view_item(*x))\n+        filter_view_item(cx, a).map(|x| cx.fold_view_item(*x))\n     }.collect();\n     ast::Block {\n         view_items: filtered_view_items,\n         stmts: resulting_stmts,\n-        expr: b.expr.map(|x| fld.fold_expr(*x)),\n+        expr: b.expr.map(|x| cx.fold_expr(*x)),\n         id: b.id,\n         rules: b.rules,\n         span: b.span,\n     }\n }\n \n-fn item_in_cfg(cx: @Context, item: @ast::item) -> bool {\n+fn item_in_cfg(cx: &Context, item: @ast::item) -> bool {\n     return (cx.in_cfg)(item.attrs);\n }\n \n-fn foreign_item_in_cfg(cx: @Context, item: @ast::foreign_item) -> bool {\n+fn foreign_item_in_cfg(cx: &Context, item: @ast::foreign_item) -> bool {\n     return (cx.in_cfg)(item.attrs);\n }\n \n-fn view_item_in_cfg(cx: @Context, item: &ast::view_item) -> bool {\n+fn view_item_in_cfg(cx: &Context, item: &ast::view_item) -> bool {\n     return (cx.in_cfg)(item.attrs);\n }\n \n-fn method_in_cfg(cx: @Context, meth: @ast::method) -> bool {\n+fn method_in_cfg(cx: &Context, meth: @ast::method) -> bool {\n     return (cx.in_cfg)(meth.attrs);\n }\n \n-fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n+fn trait_method_in_cfg(cx: &Context, meth: &ast::trait_method) -> bool {\n     match *meth {\n         ast::required(ref meth) => (cx.in_cfg)(meth.attrs),\n         ast::provided(@ref meth) => (cx.in_cfg)(meth.attrs)\n@@ -182,3 +191,4 @@ fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n fn in_cfg(cfg: &[@ast::MetaItem], attrs: &[ast::Attribute]) -> bool {\n     attr::test_cfg(cfg, attrs.iter().map(|x| *x))\n }\n+"}, {"sha": "ab407806bcc678755e7c83c1a3d4df059e0e8317", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 96, "deletions": 83, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -16,6 +16,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::dummy_sp;\n use syntax::codemap;\n+use syntax::fold::ast_fold;\n use syntax::fold;\n use syntax::opt_vec;\n \n@@ -38,91 +39,103 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n \n-fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n-    fn spanned<T>(x: T) -> codemap::Spanned<T> {\n-        codemap::Spanned { node: x, span: dummy_sp() }\n+fn spanned<T>(x: T) -> codemap::Spanned<T> {\n+    codemap::Spanned {\n+        node: x,\n+        span: dummy_sp(),\n     }\n+}\n \n-    let precursor = @fold::AstFoldFns {\n-        fold_crate: |crate, fld| {\n-            let n1 = ast::DUMMY_NODE_ID;\n-            let vi1 = ast::view_item {\n-                node: ast::view_item_extern_mod(\n-                        sess.ident_of(\"std\"), None, ~[], n1),\n-                attrs: ~[\n-                    attr::mk_attr(\n-                        attr::mk_name_value_item_str(@\"vers\", STD_VERSION.to_managed()))\n-                ],\n-                vis: ast::private,\n-                span: dummy_sp()\n-            };\n-\n-            let vis = vec::append(~[vi1], crate.module.view_items);\n-            let mut new_module = ast::_mod {\n-                view_items: vis,\n-                ..crate.module.clone()\n-            };\n-\n-            if !no_prelude(crate.attrs) {\n-                // only add `use std::prelude::*;` if there wasn't a\n-                // `#[no_implicit_prelude];` at the crate level.\n-                new_module = fld.fold_mod(&new_module);\n-            }\n-\n-            // FIXME #2543: Bad copy.\n-            ast::Crate {\n-                module: new_module,\n-                ..(*crate).clone()\n-            }\n-        },\n-        fold_item: |item, fld| {\n-            if !no_prelude(item.attrs) {\n-                // only recur if there wasn't `#[no_implicit_prelude];`\n-                // on this item, i.e. this means that the prelude is not\n-                // implicitly imported though the whole subtree\n-                fold::noop_fold_item(item, fld)\n-            } else {\n-                Some(item)\n-            }\n-        },\n-        fold_mod: |module, fld| {\n-            let n2 = ast::DUMMY_NODE_ID;\n-\n-            let prelude_path = ast::Path {\n-                span: dummy_sp(),\n-                global: false,\n-                segments: ~[\n-                    ast::PathSegment {\n-                        identifier: sess.ident_of(\"std\"),\n-                        lifetime: None,\n-                        types: opt_vec::Empty,\n-                    },\n-                    ast::PathSegment {\n-                        identifier: sess.ident_of(\"prelude\"),\n-                        lifetime: None,\n-                        types: opt_vec::Empty,\n-                    },\n-                ],\n-            };\n-\n-            let vp = @spanned(ast::view_path_glob(prelude_path, n2));\n-            let vi2 = ast::view_item { node: ast::view_item_use(~[vp]),\n-                                        attrs: ~[],\n-                                        vis: ast::private,\n-                                        span: dummy_sp() };\n-\n-            let vis = vec::append(~[vi2], module.view_items);\n-\n-            // FIXME #2543: Bad copy.\n-            let new_module = ast::_mod {\n-                view_items: vis,\n-                ..(*module).clone()\n-            };\n-            fold::noop_fold_mod(&new_module, fld)\n-        },\n-        ..*fold::default_ast_fold()\n-    };\n+struct StandardLibraryInjector {\n+    sess: Session,\n+}\n \n-    let fold = fold::make_fold(precursor);\n+impl fold::ast_fold for StandardLibraryInjector {\n+    fn fold_crate(&self, crate: &ast::Crate) -> ast::Crate {\n+        let version = STD_VERSION.to_managed();\n+        let vi1 = ast::view_item {\n+            node: ast::view_item_extern_mod(self.sess.ident_of(\"std\"),\n+                                            None,\n+                                            ~[],\n+                                            ast::DUMMY_NODE_ID),\n+            attrs: ~[\n+                attr::mk_attr(attr::mk_name_value_item_str(@\"vers\", version))\n+            ],\n+            vis: ast::private,\n+            span: dummy_sp()\n+        };\n+\n+        let vis = vec::append(~[vi1], crate.module.view_items);\n+        let mut new_module = ast::_mod {\n+            view_items: vis,\n+            ..crate.module.clone()\n+        };\n+\n+        if !no_prelude(crate.attrs) {\n+            // only add `use std::prelude::*;` if there wasn't a\n+            // `#[no_implicit_prelude];` at the crate level.\n+            new_module = self.fold_mod(&new_module);\n+        }\n+\n+        // FIXME #2543: Bad copy.\n+        ast::Crate {\n+            module: new_module,\n+            ..(*crate).clone()\n+        }\n+    }\n+\n+    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+        if !no_prelude(item.attrs) {\n+            // only recur if there wasn't `#[no_implicit_prelude];`\n+            // on this item, i.e. this means that the prelude is not\n+            // implicitly imported though the whole subtree\n+            fold::noop_fold_item(item, self)\n+        } else {\n+            Some(item)\n+        }\n+    }\n+\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        let prelude_path = ast::Path {\n+            span: dummy_sp(),\n+            global: false,\n+            segments: ~[\n+                ast::PathSegment {\n+                    identifier: self.sess.ident_of(\"std\"),\n+                    lifetime: None,\n+                    types: opt_vec::Empty,\n+                },\n+                ast::PathSegment {\n+                    identifier: self.sess.ident_of(\"prelude\"),\n+                    lifetime: None,\n+                    types: opt_vec::Empty,\n+                },\n+            ],\n+        };\n+\n+        let vp = @spanned(ast::view_path_glob(prelude_path,\n+                                              ast::DUMMY_NODE_ID));\n+        let vi2 = ast::view_item {\n+            node: ast::view_item_use(~[vp]),\n+            attrs: ~[],\n+            vis: ast::private,\n+            span: dummy_sp(),\n+        };\n+\n+        let vis = vec::append(~[vi2], module.view_items);\n+\n+        // FIXME #2543: Bad copy.\n+        let new_module = ast::_mod {\n+            view_items: vis,\n+            ..(*module).clone()\n+        };\n+        fold::noop_fold_mod(&new_module, self)\n+    }\n+}\n+\n+fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n+    let fold = StandardLibraryInjector {\n+        sess: sess,\n+    };\n     @fold.fold_crate(crate)\n }"}, {"sha": "18998015e95b48689f08fedc73f7ff23fe30f5ca", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 87, "deletions": 90, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -21,13 +21,12 @@ use syntax::attr;\n use syntax::codemap::{dummy_sp, Span, ExpnInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n+use syntax::fold::ast_fold;\n use syntax::fold;\n use syntax::opt_vec;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n \n-type node_id_gen = @fn() -> ast::NodeId;\n-\n struct Test {\n     span: Span,\n     path: ~[ast::Ident],\n@@ -61,9 +60,89 @@ pub fn modify_for_testing(sess: session::Session,\n     }\n }\n \n-fn generate_test_harness(sess: session::Session,\n-                         crate: @ast::Crate)\n-                      -> @ast::Crate {\n+struct TestHarnessGenerator {\n+    cx: @mut TestCtxt,\n+}\n+\n+impl fold::ast_fold for TestHarnessGenerator {\n+    fn fold_crate(&self, c: &ast::Crate) -> ast::Crate {\n+        let folded = fold::noop_fold_crate(c, self);\n+\n+        // Add a special __test module to the crate that will contain code\n+        // generated for the test harness\n+        ast::Crate {\n+            module: add_test_module(self.cx, &folded.module),\n+            .. folded\n+        }\n+    }\n+\n+    fn fold_item(&self, i: @ast::item) -> Option<@ast::item> {\n+        self.cx.path.push(i.ident);\n+        debug!(\"current path: %s\",\n+               ast_util::path_name_i(self.cx.path.clone()));\n+\n+        if is_test_fn(self.cx, i) || is_bench_fn(i) {\n+            match i.node {\n+                ast::item_fn(_, purity, _, _, _)\n+                    if purity == ast::unsafe_fn => {\n+                    let sess = self.cx.sess;\n+                    sess.span_fatal(i.span,\n+                                    \"unsafe functions cannot be used for \\\n+                                     tests\");\n+                }\n+                _ => {\n+                    debug!(\"this is a test function\");\n+                    let test = Test {\n+                        span: i.span,\n+                        path: self.cx.path.clone(),\n+                        bench: is_bench_fn(i),\n+                        ignore: is_ignored(self.cx, i),\n+                        should_fail: should_fail(i)\n+                    };\n+                    self.cx.testfns.push(test);\n+                    // debug!(\"have %u test/bench functions\",\n+                    //        cx.testfns.len());\n+                }\n+            }\n+        }\n+\n+        let res = fold::noop_fold_item(i, self);\n+        self.cx.path.pop();\n+        return res;\n+    }\n+\n+    fn fold_mod(&self, m: &ast::_mod) -> ast::_mod {\n+        // Remove any #[main] from the AST so it doesn't clash with\n+        // the one we're going to add. Only if compiling an executable.\n+\n+        fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n+            if !*cx.sess.building_library {\n+                @ast::item {\n+                    attrs: do item.attrs.iter().filter_map |attr| {\n+                        if \"main\" != attr.name() {\n+                            Some(*attr)\n+                        } else {\n+                            None\n+                        }\n+                    }.collect(),\n+                    .. (*item).clone()\n+                }\n+            } else {\n+                item\n+            }\n+        }\n+\n+        let mod_nomain = ast::_mod {\n+            view_items: m.view_items.clone(),\n+            items: m.items.iter().map(|i| nomain(self.cx, *i)).collect(),\n+        };\n+\n+        fold::noop_fold_mod(&mod_nomain, self)\n+    }\n+}\n+\n+fn generate_test_harness(sess: session::Session, crate: @ast::Crate)\n+                         -> @ast::Crate {\n     let cx: @mut TestCtxt = @mut TestCtxt {\n         sess: sess,\n         crate: crate,\n@@ -81,12 +160,9 @@ fn generate_test_harness(sess: session::Session,\n         }\n     });\n \n-    let precursor = @fold::AstFoldFns {\n-        fold_crate: |a,b| fold_crate(cx, a, b),\n-        fold_item: |a,b| fold_item(cx, a, b),\n-        fold_mod: |a,b| fold_mod(cx, a, b),.. *fold::default_ast_fold()};\n-\n-    let fold = fold::make_fold(precursor);\n+    let fold = TestHarnessGenerator {\n+        cx: cx\n+    };\n     let res = @fold.fold_crate(&*crate);\n     ext_cx.bt_pop();\n     return res;\n@@ -101,85 +177,6 @@ fn strip_test_functions(crate: &ast::Crate) -> @ast::Crate {\n     }\n }\n \n-fn fold_mod(cx: @mut TestCtxt,\n-            m: &ast::_mod,\n-            fld: @fold::ast_fold)\n-         -> ast::_mod {\n-    // Remove any #[main] from the AST so it doesn't clash with\n-    // the one we're going to add. Only if compiling an executable.\n-\n-    fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n-        if !*cx.sess.building_library {\n-            @ast::item {\n-                attrs: do item.attrs.iter().filter_map |attr| {\n-                    if \"main\" != attr.name() {\n-                        Some(*attr)\n-                    } else {\n-                        None\n-                    }\n-                }.collect(),\n-                .. (*item).clone()\n-            }\n-        } else {\n-            item\n-        }\n-    }\n-\n-    let mod_nomain = ast::_mod {\n-        view_items: m.view_items.clone(),\n-        items: m.items.iter().map(|i| nomain(cx, *i)).collect(),\n-    };\n-\n-    fold::noop_fold_mod(&mod_nomain, fld)\n-}\n-\n-fn fold_crate(cx: @mut TestCtxt, c: &ast::Crate, fld: @fold::ast_fold)\n-              -> ast::Crate {\n-    let folded = fold::noop_fold_crate(c, fld);\n-\n-    // Add a special __test module to the crate that will contain code\n-    // generated for the test harness\n-    ast::Crate {\n-        module: add_test_module(cx, &folded.module),\n-        .. folded\n-    }\n-}\n-\n-\n-fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n-          -> Option<@ast::item> {\n-    cx.path.push(i.ident);\n-    debug!(\"current path: %s\",\n-           ast_util::path_name_i(cx.path.clone()));\n-\n-    if is_test_fn(cx, i) || is_bench_fn(i) {\n-        match i.node {\n-          ast::item_fn(_, purity, _, _, _) if purity == ast::unsafe_fn => {\n-            let sess = cx.sess;\n-            sess.span_fatal(\n-                i.span,\n-                \"unsafe functions cannot be used for tests\");\n-          }\n-          _ => {\n-            debug!(\"this is a test function\");\n-            let test = Test {\n-                span: i.span,\n-                path: cx.path.clone(),\n-                bench: is_bench_fn(i),\n-                ignore: is_ignored(cx, i),\n-                should_fail: should_fail(i)\n-            };\n-            cx.testfns.push(test);\n-            // debug!(\"have %u test/bench functions\", cx.testfns.len());\n-          }\n-        }\n-    }\n-\n-    let res = fold::noop_fold_item(i, fld);\n-    cx.path.pop();\n-    return res;\n-}\n-\n fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs, \"test\");\n "}, {"sha": "b94a43e07a1984c7fb13dd1336a290e9f1b335b5", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -95,8 +95,7 @@ pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n \n-fn parse_ident_(st: &mut PState, is_last: @fn(char) -> bool) ->\n-   ast::Ident {\n+fn parse_ident_(st: &mut PState, is_last: &fn(char) -> bool) -> ast::Ident {\n     let rslt = scan(st, is_last, str::from_utf8);\n     return st.tcx.sess.ident_of(rslt);\n }"}, {"sha": "417a6dae7bea08cdaa7e08084bbf05feaba255fb", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -26,7 +26,7 @@ use syntax::print::pprust::*;\n pub struct ctxt {\n     diag: @mut span_handler,\n     // Def -> str Callback:\n-    ds: @fn(DefId) -> ~str,\n+    ds: extern \"Rust\" fn(DefId) -> ~str,\n     // The type context.\n     tcx: ty::ctxt,\n     abbrevs: abbrev_ctxt"}, {"sha": "683fbba09cc524c1a2f0b08010f339c80da0393a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 79, "deletions": 45, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -24,6 +24,7 @@ use middle;\n use util::ppaux::ty_to_str;\n \n use std::at_vec;\n+use std::libc;\n use extra::ebml::reader;\n use extra::ebml;\n use extra::serialize;\n@@ -287,26 +288,24 @@ fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n     ebml_w.end_tag();\n }\n \n-// Produces a simplified copy of the AST which does not include things\n-// that we do not need to or do not want to export.  For example, we\n-// do not include any nested items: if these nested items are to be\n-// inlined, their AST will be exported separately (this only makes\n-// sense because, in Rust, nested items are independent except for\n-// their visibility).\n-//\n-// As it happens, trans relies on the fact that we do not export\n-// nested items, as otherwise it would get confused when translating\n-// inlined items.\n-fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n-    fn drop_nested_items(blk: &ast::Block, fld: @fold::ast_fold) -> ast::Block {\n+struct NestedItemsDropper {\n+    contents: (),\n+}\n+\n+impl fold::ast_fold for NestedItemsDropper {\n+    fn fold_block(&self, blk: &ast::Block) -> ast::Block {\n         let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n             match stmt.node {\n-              ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n-              ast::StmtDecl(@codemap::Spanned { node: ast::DeclLocal(_), span: _}, _)\n-                => Some(*stmt),\n-              ast::StmtDecl(@codemap::Spanned { node: ast::DeclItem(_), span: _}, _)\n-                => None,\n-              ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n+                ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n+                ast::StmtDecl(@codemap::Spanned {\n+                    node: ast::DeclLocal(_),\n+                    span: _\n+                }, _) => Some(*stmt),\n+                ast::StmtDecl(@codemap::Spanned {\n+                    node: ast::DeclItem(_),\n+                    span: _\n+                }, _) => None,\n+                ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n         }.collect();\n         let blk_sans_items = ast::Block {\n@@ -318,13 +317,24 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n             rules: blk.rules,\n             span: blk.span,\n         };\n-        fold::noop_fold_block(&blk_sans_items, fld)\n+        fold::noop_fold_block(&blk_sans_items, self)\n     }\n+}\n \n-    let fld = fold::make_fold(@fold::AstFoldFns {\n-        fold_block: drop_nested_items,\n-        .. *fold::default_ast_fold()\n-    });\n+// Produces a simplified copy of the AST which does not include things\n+// that we do not need to or do not want to export.  For example, we\n+// do not include any nested items: if these nested items are to be\n+// inlined, their AST will be exported separately (this only makes\n+// sense because, in Rust, nested items are independent except for\n+// their visibility).\n+//\n+// As it happens, trans relies on the fact that we do not export\n+// nested items, as otherwise it would get confused when translating\n+// inlined items.\n+fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n+    let fld = NestedItemsDropper {\n+        contents: (),\n+    };\n \n     match *ii {\n         //hack: we're not dropping items\n@@ -341,14 +351,24 @@ fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     Decodable::decode(&mut d)\n }\n \n+struct AstRenumberer {\n+    xcx: @ExtendedDecodeContext,\n+}\n+\n+impl fold::ast_fold for AstRenumberer {\n+    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n+        self.xcx.tr_id(id)\n+    }\n+    fn new_span(&self, span: Span) -> Span {\n+        self.xcx.tr_span(span)\n+    }\n+}\n+\n fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n     -> ast::inlined_item {\n-    let fld = fold::make_fold(@fold::AstFoldFns{\n-        new_id: |a| xcx.tr_id(a),\n-        new_span: |a| xcx.tr_span(a),\n-        .. *fold::default_ast_fold()\n-    });\n-\n+    let fld = AstRenumberer {\n+        xcx: xcx,\n+    };\n     match ii {\n         ast::ii_item(i) => ast::ii_item(fld.fold_item(i).unwrap()),\n         ast::ii_method(d, is_provided, m) =>\n@@ -830,29 +850,43 @@ impl write_tag_and_id for writer::Encoder {\n     }\n }\n \n+struct SideTableEncodingIdVisitor {\n+    ecx_ptr: *libc::c_void,\n+    new_ebml_w: writer::Encoder,\n+    maps: Maps,\n+}\n+\n+impl ast_util::IdVisitingOperation for SideTableEncodingIdVisitor {\n+    fn visit_id(&self, id: ast::NodeId) {\n+        // Note: this will cause a copy of ebml_w, which is bad as\n+        // it is mutable. But I believe it's harmless since we generate\n+        // balanced EBML.\n+        let mut new_ebml_w = self.new_ebml_w.clone();\n+        // See above\n+        let ecx: &e::EncodeContext = unsafe {\n+            cast::transmute(self.ecx_ptr)\n+        };\n+        encode_side_tables_for_id(ecx, self.maps, &mut new_ebml_w, id)\n+    }\n+}\n+\n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n                              ii: &ast::inlined_item) {\n     ebml_w.start_tag(c::tag_table as uint);\n     let new_ebml_w = (*ebml_w).clone();\n \n-    // Because the ast visitor uses @fn, I can't pass in\n-    // ecx directly, but /I/ know that it'll be fine since\n-    // the lifetime is tied to the CrateContext that\n-    // lives this entire section.\n-    let ecx_ptr : *() = unsafe { cast::transmute(ecx) };\n-    ast_util::visit_ids_for_inlined_item(\n-        ii,\n-        |id: ast::NodeId| {\n-            // Note: this will cause a copy of ebml_w, which is bad as\n-            // it is mutable. But I believe it's harmless since we generate\n-            // balanced EBML.\n-            let mut new_ebml_w = new_ebml_w.clone();\n-            // See above\n-            let ecx : &e::EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n-            encode_side_tables_for_id(ecx, maps, &mut new_ebml_w, id)\n-        });\n+    // Because the ast visitor uses @IdVisitingOperation, I can't pass in\n+    // ecx directly, but /I/ know that it'll be fine since the lifetime is\n+    // tied to the CrateContext that lives throughout this entire section.\n+    ast_util::visit_ids_for_inlined_item(ii, @SideTableEncodingIdVisitor {\n+        ecx_ptr: unsafe {\n+            cast::transmute(ecx)\n+        },\n+        new_ebml_w: new_ebml_w,\n+        maps: maps,\n+    } as @ast_util::IdVisitingOperation);\n     ebml_w.end_tag();\n }\n "}, {"sha": "1af39f02d82b00dd936b3c678e3e0691cf3dea88", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -87,6 +87,42 @@ struct LoopScope<'self> {\n     break_bits: ~[uint]\n }\n \n+impl<O:DataFlowOperator> pprust::pp_ann for DataFlowContext<O> {\n+    fn pre(&self, node: pprust::ann_node) {\n+        let (ps, id) = match node {\n+            pprust::node_expr(ps, expr) => (ps, expr.id),\n+            pprust::node_block(ps, blk) => (ps, blk.id),\n+            pprust::node_item(ps, _) => (ps, 0),\n+            pprust::node_pat(ps, pat) => (ps, pat.id)\n+        };\n+\n+        if self.nodeid_to_bitset.contains_key(&id) {\n+            let (start, end) = self.compute_id_range_frozen(id);\n+            let on_entry = self.on_entry.slice(start, end);\n+            let entry_str = bits_to_str(on_entry);\n+\n+            let gens = self.gens.slice(start, end);\n+            let gens_str = if gens.iter().any(|&u| u != 0) {\n+                fmt!(\" gen: %s\", bits_to_str(gens))\n+            } else {\n+                ~\"\"\n+            };\n+\n+            let kills = self.kills.slice(start, end);\n+            let kills_str = if kills.iter().any(|&u| u != 0) {\n+                fmt!(\" kill: %s\", bits_to_str(kills))\n+            } else {\n+                ~\"\"\n+            };\n+\n+            let comment_str = fmt!(\"id %d: %s%s%s\",\n+                                   id, entry_str, gens_str, kills_str);\n+            pprust::synth_comment(ps, comment_str);\n+            pp::space(ps.s);\n+        }\n+    }\n+}\n+\n impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn new(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n@@ -319,46 +355,9 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n     }\n \n     fn pretty_print_to(@self, wr: @io::Writer, blk: &ast::Block) {\n-        let pre: @fn(pprust::ann_node) = |node| {\n-            let (ps, id) = match node {\n-                pprust::node_expr(ps, expr) => (ps, expr.id),\n-                pprust::node_block(ps, blk) => (ps, blk.id),\n-                pprust::node_item(ps, _) => (ps, 0),\n-                pprust::node_pat(ps, pat) => (ps, pat.id)\n-            };\n-\n-            if self.nodeid_to_bitset.contains_key(&id) {\n-                let (start, end) = self.compute_id_range_frozen(id);\n-                let on_entry = self.on_entry.slice(start, end);\n-                let entry_str = bits_to_str(on_entry);\n-\n-                let gens = self.gens.slice(start, end);\n-                let gens_str = if gens.iter().any(|&u| u != 0) {\n-                    fmt!(\" gen: %s\", bits_to_str(gens))\n-                } else {\n-                    ~\"\"\n-                };\n-\n-                let kills = self.kills.slice(start, end);\n-                let kills_str = if kills.iter().any(|&u| u != 0) {\n-                    fmt!(\" kill: %s\", bits_to_str(kills))\n-                } else {\n-                    ~\"\"\n-                };\n-\n-                let comment_str = fmt!(\"id %d: %s%s%s\",\n-                                       id, entry_str, gens_str, kills_str);\n-                pprust::synth_comment(ps, comment_str);\n-                pp::space(ps.s);\n-            }\n-        };\n-\n-        let post: @fn(pprust::ann_node) = |_| {\n-        };\n-\n-        let ps = pprust::rust_printer_annotated(\n-            wr, self.tcx.sess.intr(),\n-            pprust::pp_ann {pre:pre, post:post});\n+        let ps = pprust::rust_printer_annotated(wr,\n+                                                self.tcx.sess.intr(),\n+                                                self as @pprust::pp_ann);\n         pprust::cbox(ps, pprust::indent_unit);\n         pprust::ibox(ps, 0u);\n         pprust::print_block(ps, blk);"}, {"sha": "1b3224a2217f0ba799416e9be3ecfb702e4485d5", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -218,14 +218,25 @@ fn with_appropriate_checker(cx: Context, id: NodeId,\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::get(fty).sty {\n-        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, bounds: bounds, _}) => {\n+        ty::ty_closure(ty::ClosureTy {\n+            sigil: OwnedSigil,\n+            bounds: bounds,\n+            _\n+        }) => {\n             b(|cx, fv| check_for_uniq(cx, fv, bounds))\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, bounds: bounds, _}) => {\n-            b(|cx, fv| check_for_box(cx, fv, bounds))\n+        ty::ty_closure(ty::ClosureTy {\n+            sigil: ManagedSigil,\n+            _\n+        }) => {\n+            // can't happen\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, bounds: bounds,\n-                                      region: region, _}) => {\n+        ty::ty_closure(ty::ClosureTy {\n+            sigil: BorrowedSigil,\n+            bounds: bounds,\n+            region: region,\n+            _\n+        }) => {\n             b(|cx, fv| check_for_block(cx, fv, bounds, region))\n         }\n         ty::ty_bare_fn(_) => {"}, {"sha": "c29a5159e811bb255b0e7b75789ad72e594ec81f", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1228,17 +1228,27 @@ fn lint_unused_mut() -> @mut OuterLint {\n     @mut UnusedMutLintVisitor{ stopping_on_items: false } as @mut OuterLint\n }\n \n-fn lint_session(cx: @mut Context) -> @mut visit::Visitor<()> {\n-    ast_util::id_visitor(|id| {\n-        match cx.tcx.sess.lints.pop(&id) {\n-            None => {},\n+struct LintReportingIdVisitor {\n+    cx: @mut Context,\n+}\n+\n+impl ast_util::IdVisitingOperation for LintReportingIdVisitor {\n+    fn visit_id(&self, id: ast::NodeId) {\n+        match self.cx.tcx.sess.lints.pop(&id) {\n+            None => {}\n             Some(l) => {\n                 for (lint, span, msg) in l.move_iter() {\n-                    cx.span_lint(lint, span, msg)\n+                    self.cx.span_lint(lint, span, msg)\n                 }\n             }\n         }\n-    }, false)\n+    }\n+}\n+\n+fn lint_session(cx: @mut Context) -> @mut visit::Visitor<()> {\n+    ast_util::id_visitor(@LintReportingIdVisitor {\n+        cx: cx,\n+    } as @ast_util::IdVisitingOperation, false)\n }\n \n struct UnnecessaryAllocationLintVisitor { stopping_on_items: bool }"}, {"sha": "9cc95b873d25d1114b3b10a06b9b3f4b031981dd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -187,8 +187,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_ptr(gc_ptr(m)))\n         }\n \n-        ty::ty_estr(ty::vstore_box) |\n-        ty::ty_closure(ty::ClosureTy {sigil: ast::ManagedSigil, _}) => {\n+        ty::ty_estr(ty::vstore_box) => {\n             Some(deref_ptr(gc_ptr(ast::MutImmutable)))\n         }\n \n@@ -515,7 +514,8 @@ impl mem_categorization_ctxt {\n                           (ast::BorrowedSigil, ast::Once) => true,\n                           // Heap closures always capture by copy/move, and can\n                           // move out iff they are once.\n-                          (ast::OwnedSigil, _) | (ast::ManagedSigil, _) => false,\n+                          (ast::OwnedSigil, _) |\n+                          (ast::ManagedSigil, _) => false,\n \n                       };\n                       if var_is_refd {"}, {"sha": "5388e64348c6efa50efd9b44b724ffac87e97256", "filename": "src/librustc/middle/stack_check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -116,8 +116,7 @@ fn stack_check_fn<'a>(v: StackCheckVisitor,\n         visit::fk_anon(*) | visit::fk_fn_block => {\n             match ty::get(ty::node_id_to_type(in_cx.tcx, id)).sty {\n                 ty::ty_bare_fn(*) |\n-                ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) |\n-                ty::ty_closure(ty::ClosureTy {sigil: ast::ManagedSigil, _}) => {\n+                ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n                     false\n                 }\n                 _ => {"}, {"sha": "0de01bced1f7ca4ecc7a9c995c32eeeccf40c814", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -533,7 +533,7 @@ fn enter_default<'r>(bcx: @mut Block,\n                      m: &[Match<'r>],\n                      col: uint,\n                      val: ValueRef,\n-                     chk: Option<mk_fail>)\n+                     chk: FailureHandler)\n                       -> ~[Match<'r>] {\n     debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n@@ -567,7 +567,7 @@ fn enter_default<'r>(bcx: @mut Block,\n     // we don't need any default cases. If the check *isn't* nonexhaustive\n     // (because chk is Some), then we need the defaults anyways.\n     let is_exhaustive = match matches.last_opt() {\n-        Some(m) if m.data.arm.guard.is_some() && chk.is_none() => true,\n+        Some(m) if m.data.arm.guard.is_some() && chk.is_infallible() => true,\n         _ => false\n     };\n \n@@ -1185,7 +1185,62 @@ fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     }\n }\n \n-type mk_fail = @fn() -> BasicBlockRef;\n+trait CustomFailureHandler {\n+    fn handle_fail(&self) -> BasicBlockRef;\n+}\n+\n+struct DynamicFailureHandler {\n+    bcx: @mut Block,\n+    sp: Span,\n+    msg: @str,\n+    finished: @mut Option<BasicBlockRef>,\n+}\n+\n+impl CustomFailureHandler for DynamicFailureHandler {\n+    fn handle_fail(&self) -> BasicBlockRef {\n+        match *self.finished {\n+            Some(bb) => return bb,\n+            _ => (),\n+        }\n+\n+        let fail_cx = sub_block(self.bcx, \"case_fallthrough\");\n+        controlflow::trans_fail(fail_cx, Some(self.sp), self.msg);\n+        *self.finished = Some(fail_cx.llbb);\n+        fail_cx.llbb\n+    }\n+}\n+\n+/// What to do when the pattern match fails.\n+enum FailureHandler {\n+    Infallible,\n+    JumpToBasicBlock(BasicBlockRef),\n+    CustomFailureHandlerClass(@CustomFailureHandler),\n+}\n+\n+impl FailureHandler {\n+    fn is_infallible(&self) -> bool {\n+        match *self {\n+            Infallible => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_fallible(&self) -> bool {\n+        !self.is_infallible()\n+    }\n+\n+    fn handle_fail(&self) -> BasicBlockRef {\n+        match *self {\n+            Infallible => {\n+                fail!(\"attempted to fail in infallible failure handler!\")\n+            }\n+            JumpToBasicBlock(basic_block) => basic_block,\n+            CustomFailureHandlerClass(custom_failure_handler) => {\n+                custom_failure_handler.handle_fail()\n+            }\n+        }\n+    }\n+}\n \n fn pick_col(m: &[Match]) -> uint {\n     fn score(p: &ast::Pat) -> uint {\n@@ -1347,7 +1402,7 @@ fn compile_guard(bcx: @mut Block,\n                      data: &ArmData,\n                      m: &[Match],\n                      vals: &[ValueRef],\n-                     chk: Option<mk_fail>)\n+                     chk: FailureHandler)\n                   -> @mut Block {\n     debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%s)\",\n            bcx.to_str(),\n@@ -1400,9 +1455,9 @@ fn compile_guard(bcx: @mut Block,\n }\n \n fn compile_submatch(bcx: @mut Block,\n-                        m: &[Match],\n-                        vals: &[ValueRef],\n-                        chk: Option<mk_fail>) {\n+                    m: &[Match],\n+                    vals: &[ValueRef],\n+                    chk: FailureHandler) {\n     debug!(\"compile_submatch(bcx=%s, m=%s, vals=%s)\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -1412,11 +1467,11 @@ fn compile_submatch(bcx: @mut Block,\n     /*\n       For an empty match, a fall-through case must exist\n      */\n-    assert!((m.len() > 0u || chk.is_some()));\n+    assert!((m.len() > 0u || chk.is_fallible()));\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     if m.len() == 0u {\n-        Br(bcx, chk.unwrap()());\n+        Br(bcx, chk.handle_fail());\n         return;\n     }\n     if m[0].pats.len() == 0u {\n@@ -1454,7 +1509,7 @@ fn compile_submatch(bcx: @mut Block,\n fn compile_submatch_continue(mut bcx: @mut Block,\n                              m: &[Match],\n                              vals: &[ValueRef],\n-                             chk: Option<mk_fail>,\n+                             chk: FailureHandler,\n                              col: uint,\n                              val: ValueRef) {\n     let tcx = bcx.tcx();\n@@ -1617,7 +1672,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val, chk);\n-    let exhaustive = chk.is_none() && defaults.len() == 0u;\n+    let exhaustive = chk.is_infallible() && defaults.len() == 0u;\n     let len = opts.len();\n \n     // Compile subtrees for each option\n@@ -1721,7 +1776,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n \n                   // If none of these subcases match, move on to the\n                   // next condition.\n-                  branch_chk = Some::<mk_fail>(|| bcx.llbb);\n+                  branch_chk = JumpToBasicBlock(bcx.llbb);\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               _ => ()\n@@ -1860,11 +1915,15 @@ fn trans_match_inner(scope_cx: @mut Block,\n         if ty::type_is_empty(tcx, t) {\n             // Special case for empty types\n             let fail_cx = @mut None;\n-            let f: mk_fail = || mk_fail(scope_cx, discr_expr.span,\n-                            @\"scrutinizing value that can't exist\", fail_cx);\n-            Some(f)\n+            let fail_handler = @DynamicFailureHandler {\n+                bcx: scope_cx,\n+                sp: discr_expr.span,\n+                msg: @\"scrutinizing value that can't exist\",\n+                finished: fail_cx,\n+            } as @CustomFailureHandler;\n+            CustomFailureHandlerClass(fail_handler)\n         } else {\n-            None\n+            Infallible\n         }\n     };\n     let lldiscr = discr_datum.to_zeroable_ref_llval(bcx);\n@@ -1892,15 +1951,6 @@ fn trans_match_inner(scope_cx: @mut Block,\n \n     bcx = controlflow::join_blocks(scope_cx, arm_cxs);\n     return bcx;\n-\n-    fn mk_fail(bcx: @mut Block, sp: Span, msg: @str,\n-               finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n-        match *finished { Some(bb) => return bb, _ => () }\n-        let fail_cx = sub_block(bcx, \"case_fallthrough\");\n-        controlflow::trans_fail(fail_cx, Some(sp), msg);\n-        *finished = Some(fail_cx.llbb);\n-        return fail_cx.llbb;\n-    }\n }\n \n enum IrrefutablePatternBindingMode {\n@@ -1913,7 +1963,7 @@ enum IrrefutablePatternBindingMode {\n pub fn store_local(bcx: @mut Block,\n                    pat: @ast::Pat,\n                    opt_init_expr: Option<@ast::Expr>)\n-                               -> @mut Block {\n+                   -> @mut Block {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`."}, {"sha": "67aee43bc46b472cec2e3fe4bb622e460e009df3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1320,7 +1320,7 @@ pub fn trans_block_cleanups_(bcx: @mut Block,\n                 // Some types don't need to be cleaned up during\n                 // landing pads because they can be freed en mass later\n                 if cleanup_type == normal_exit_and_unwind || !is_lpad {\n-                    bcx = cfn(bcx);\n+                    bcx = cfn.clean(bcx);\n                 }\n             }\n         }"}, {"sha": "b5b181e22a6ebfa62e897cbb8976694fd1e5a89c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -172,7 +172,7 @@ pub fn allocate_cbox(bcx: @mut Block, sigil: ast::Sigil, cdata_ty: ty::t)\n     // Allocate and initialize the box:\n     match sigil {\n         ast::ManagedSigil => {\n-            malloc_raw(bcx, cdata_ty, heap_managed)\n+            tcx.sess.bug(\"trying to trans allocation of @fn\")\n         }\n         ast::OwnedSigil => {\n             malloc_raw(bcx, cdata_ty, heap_for_unique_closure(bcx, cdata_ty))\n@@ -197,7 +197,8 @@ pub struct ClosureResult {\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment(bcx: @mut Block,\n                          bound_values: ~[EnvValue],\n-                         sigil: ast::Sigil) -> ClosureResult {\n+                         sigil: ast::Sigil)\n+                         -> ClosureResult {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx;\n@@ -444,27 +445,6 @@ pub fn make_closure_glue(\n     }\n }\n \n-pub fn make_opaque_cbox_take_glue(\n-    bcx: @mut Block,\n-    sigil: ast::Sigil,\n-    cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n-    -> @mut Block {\n-    // Easy cases:\n-    let _icx = push_ctxt(\"closure::make_opaque_cbox_take_glue\");\n-    match sigil {\n-        ast::BorrowedSigil => {\n-            return bcx;\n-        }\n-        ast::ManagedSigil => {\n-            glue::incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n-            return bcx;\n-        }\n-        ast::OwnedSigil => {\n-            fail!(\"unique closures are not copyable\")\n-        }\n-    }\n-}\n-\n pub fn make_opaque_cbox_drop_glue(\n     bcx: @mut Block,\n     sigil: ast::Sigil,\n@@ -474,9 +454,7 @@ pub fn make_opaque_cbox_drop_glue(\n     match sigil {\n         ast::BorrowedSigil => bcx,\n         ast::ManagedSigil => {\n-            glue::decr_refcnt_maybe_free(\n-                bcx, Load(bcx, cboxptr), Some(cboxptr),\n-                ty::mk_opaque_closure_ptr(bcx.tcx(), sigil))\n+            bcx.tcx().sess.bug(\"trying to trans drop glue of @fn\")\n         }\n         ast::OwnedSigil => {\n             glue::free_ty(\n@@ -516,12 +494,8 @@ pub fn make_opaque_cbox_free_glue(\n                                     abi::tydesc_field_drop_glue, None);\n \n         // Free the ty descr (if necc) and the box itself\n-        match sigil {\n-            ast::ManagedSigil => glue::trans_free(bcx, cbox),\n-            ast::OwnedSigil => glue::trans_exchange_free(bcx, cbox),\n-            ast::BorrowedSigil => {\n-                bcx.sess().bug(\"impossible\")\n-            }\n-        }\n+        glue::trans_exchange_free(bcx, cbox);\n+\n+        bcx\n     }\n }"}, {"sha": "377144b38e78cd1efb6ececcf8a7f084d4ce08da", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 119, "deletions": 22, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -294,9 +294,85 @@ pub enum cleantype {\n     normal_exit_and_unwind\n }\n \n+// Cleanup functions\n+\n+/// A cleanup function: a built-in destructor.\n+pub trait CleanupFunction {\n+    fn clean(&self, block: @mut Block) -> @mut Block;\n+}\n+\n+/// A cleanup function that calls the \"drop glue\" (destructor function) on\n+/// a typed value.\n+pub struct TypeDroppingCleanupFunction {\n+    val: ValueRef,\n+    t: ty::t,\n+}\n+\n+impl CleanupFunction for TypeDroppingCleanupFunction {\n+    fn clean(&self, block: @mut Block) -> @mut Block {\n+        glue::drop_ty(block, self.val, self.t)\n+    }\n+}\n+\n+/// A cleanup function that calls the \"drop glue\" (destructor function) on\n+/// an immediate typed value.\n+pub struct ImmediateTypeDroppingCleanupFunction {\n+    val: ValueRef,\n+    t: ty::t,\n+}\n+\n+impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n+    fn clean(&self, block: @mut Block) -> @mut Block {\n+        glue::drop_ty_immediate(block, self.val, self.t)\n+    }\n+}\n+\n+/// A cleanup function that releases a write guard, returning a value to\n+/// mutable status.\n+pub struct WriteGuardReleasingCleanupFunction {\n+    root_key: root_map_key,\n+    frozen_val_ref: ValueRef,\n+    bits_val_ref: ValueRef,\n+    filename_val: ValueRef,\n+    line_val: ValueRef,\n+}\n+\n+impl CleanupFunction for WriteGuardReleasingCleanupFunction {\n+    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+        write_guard::return_to_mut(bcx,\n+                                   self.root_key,\n+                                   self.frozen_val_ref,\n+                                   self.bits_val_ref,\n+                                   self.filename_val,\n+                                   self.line_val)\n+    }\n+}\n+\n+/// A cleanup function that frees some memory in the garbage-collected heap.\n+pub struct GCHeapFreeingCleanupFunction {\n+    ptr: ValueRef,\n+}\n+\n+impl CleanupFunction for GCHeapFreeingCleanupFunction {\n+    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+        glue::trans_free(bcx, self.ptr)\n+    }\n+}\n+\n+/// A cleanup function that frees some memory in the exchange heap.\n+pub struct ExchangeHeapFreeingCleanupFunction {\n+    ptr: ValueRef,\n+}\n+\n+impl CleanupFunction for ExchangeHeapFreeingCleanupFunction {\n+    fn clean(&self, bcx: @mut Block) -> @mut Block {\n+        glue::trans_exchange_free(bcx, self.ptr)\n+    }\n+}\n+\n pub enum cleanup {\n-    clean(@fn(@mut Block) -> @mut Block, cleantype),\n-    clean_temp(ValueRef, @fn(@mut Block) -> @mut Block, cleantype),\n+    clean(@CleanupFunction, cleantype),\n+    clean_temp(ValueRef, @CleanupFunction, cleantype),\n }\n \n // Can't use deriving(Clone) because of the managed closure.\n@@ -337,13 +413,19 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n }\n \n pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n-    if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n+    if !ty::type_needs_drop(bcx.tcx(), t) {\n+        return\n+    }\n \n     debug!(\"add_clean(%s, %s, %s)\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx, None) |scope_info| {\n-        scope_info.cleanups.push(clean(|a| glue::drop_ty(a, val, t), cleanup_type));\n+        scope_info.cleanups.push(clean(@TypeDroppingCleanupFunction {\n+            val: val,\n+            t: t,\n+        } as @CleanupFunction,\n+        cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -355,9 +437,12 @@ pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx, None) |scope_info| {\n-        scope_info.cleanups.push(\n-            clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n-                       cleanup_type));\n+        scope_info.cleanups.push(clean_temp(val,\n+            @ImmediateTypeDroppingCleanupFunction {\n+                val: val,\n+                t: ty,\n+            } as @CleanupFunction,\n+            cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -381,7 +466,12 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeI\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx, scope_id) |scope_info| {\n-        scope_info.cleanups.push(clean_temp(val, |a| glue::drop_ty(a, val, t), cleanup_type));\n+        scope_info.cleanups.push(clean_temp(val,\n+            @TypeDroppingCleanupFunction {\n+                val: val,\n+                t: t,\n+            } as @CleanupFunction,\n+            cleanup_type));\n         grow_scope_clean(scope_info);\n     }\n }\n@@ -405,29 +495,36 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n     do in_scope_cx(bcx, Some(scope_id)) |scope_info| {\n-        scope_info.cleanups.push(\n-            clean_temp(\n+        scope_info.cleanups.push(clean_temp(\n                 frozen_val_ref,\n-                |bcx| write_guard::return_to_mut(bcx, root_key, frozen_val_ref, bits_val_ref,\n-                                                 filename_val, line_val),\n+                @WriteGuardReleasingCleanupFunction {\n+                    root_key: root_key,\n+                    frozen_val_ref: frozen_val_ref,\n+                    bits_val_ref: bits_val_ref,\n+                    filename_val: filename_val,\n+                    line_val: line_val,\n+                } as @CleanupFunction,\n                 normal_exit_only));\n         grow_scope_clean(scope_info);\n     }\n }\n pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n-      heap_managed | heap_managed_unique => {\n-        let f: @fn(@mut Block) -> @mut Block = |a| glue::trans_free(a, ptr);\n-        f\n-      }\n-      heap_exchange | heap_exchange_closure => {\n-        let f: @fn(@mut Block) -> @mut Block = |a| glue::trans_exchange_free(a, ptr);\n-        f\n-      }\n+        heap_managed | heap_managed_unique => {\n+            @GCHeapFreeingCleanupFunction {\n+                ptr: ptr,\n+            } as @CleanupFunction\n+        }\n+        heap_exchange | heap_exchange_closure => {\n+            @ExchangeHeapFreeingCleanupFunction {\n+                ptr: ptr,\n+            } as @CleanupFunction\n+        }\n     };\n     do in_scope_cx(cx, None) |scope_info| {\n-        scope_info.cleanups.push(clean_temp(ptr, free_fn,\n-                                      normal_exit_and_unwind));\n+        scope_info.cleanups.push(clean_temp(ptr,\n+                                            free_fn,\n+                                            normal_exit_and_unwind));\n         grow_scope_clean(scope_info);\n     }\n }"}, {"sha": "91f6169b419f92e50cbfc2a3c362b4070f113c8e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 199, "deletions": 131, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1086,6 +1086,36 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     return ptr_metadata;\n }\n \n+trait MemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription];\n+}\n+\n+struct StructMemberDescriptionFactory {\n+    fields: ~[ty::field],\n+    span: Span,\n+}\n+\n+impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription] {\n+        do self.fields.map |field| {\n+            let name = if field.ident.name == special_idents::unnamed_field.name {\n+                @\"\"\n+            } else {\n+                token::ident_to_str(&field.ident)\n+            };\n+\n+            MemberDescription {\n+                name: name,\n+                llvm_type: type_of::type_of(cx, field.mt.ty),\n+                type_metadata: type_metadata(cx, field.mt.ty, self.span),\n+                offset: ComputedMemberOffset,\n+            }\n+        }\n+    }\n+}\n+\n fn prepare_struct_metadata(cx: &mut CrateContext,\n                            struct_type: ty::t,\n                            def_id: ast::DefId,\n@@ -1114,22 +1144,10 @@ fn prepare_struct_metadata(cx: &mut CrateContext,\n         metadata_stub: struct_metadata_stub,\n         llvm_type: struct_llvm_type,\n         file_metadata: file_metadata,\n-        member_description_factory: |cx| {\n-            do fields.map |field| {\n-                let name = if field.ident.name == special_idents::unnamed_field.name {\n-                    @\"\"\n-                } else {\n-                    token::ident_to_str(&field.ident)\n-                };\n-\n-                MemberDescription {\n-                    name: name,\n-                    llvm_type: type_of::type_of(cx, field.mt.ty),\n-                    type_metadata: type_metadata(cx, field.mt.ty, span),\n-                    offset: ComputedMemberOffset,\n-                }\n-            }\n-        }\n+        member_description_factory: @StructMemberDescriptionFactory {\n+            fields: fields,\n+            span: span,\n+        } as @MemberDescriptionFactory,\n     }\n }\n \n@@ -1139,7 +1157,7 @@ enum RecursiveTypeDescription {\n         metadata_stub: DICompositeType,\n         llvm_type: Type,\n         file_metadata: DIFile,\n-        member_description_factory: @fn(cx: &mut CrateContext) -> ~[MemberDescription],\n+        member_description_factory: @MemberDescriptionFactory,\n     },\n     FinalMetadata(DICompositeType)\n }\n@@ -1167,7 +1185,8 @@ impl RecursiveTypeDescription {\n                 debug_context(cx).created_types.insert(cache_id, metadata_stub);\n \n                 // ... then create the member descriptions ...\n-                let member_descriptions = member_description_factory(cx);\n+                let member_descriptions = member_description_factory.\n+                    create_member_descriptions(cx);\n \n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n@@ -1182,6 +1201,25 @@ impl RecursiveTypeDescription {\n     }\n }\n \n+struct TupleMemberDescriptionFactory {\n+    component_types: ~[ty::t],\n+    span: Span,\n+}\n+\n+impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription] {\n+        do self.component_types.map |&component_type| {\n+            MemberDescription {\n+                name: @\"\",\n+                llvm_type: type_of::type_of(cx, component_type),\n+                type_metadata: type_metadata(cx, component_type, self.span),\n+                offset: ComputedMemberOffset,\n+            }\n+        }\n+    }\n+}\n+\n fn prepare_tuple_metadata(cx: &mut CrateContext,\n                           tuple_type: ty::t,\n                           component_types: &[ty::t],\n@@ -1192,8 +1230,6 @@ fn prepare_tuple_metadata(cx: &mut CrateContext,\n \n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n-    // Needs to be copied for closure below :(\n-    let component_types = component_types.to_owned();\n \n     UnfinishedMetadata {\n         cache_id: cache_id_for_type(tuple_type),\n@@ -1205,17 +1241,147 @@ fn prepare_tuple_metadata(cx: &mut CrateContext,\n                                           span),\n         llvm_type: tuple_llvm_type,\n         file_metadata: file_metadata,\n-        member_description_factory: |cx| {\n-            do component_types.map |&component_type| {\n+        member_description_factory: @TupleMemberDescriptionFactory {\n+            component_types: component_types.to_owned(),\n+            span: span,\n+        } as @MemberDescriptionFactory\n+    }\n+}\n+\n+struct GeneralMemberDescriptionFactory {\n+    type_rep: @adt::Repr,\n+    variants: @~[@ty::VariantInfo],\n+    discriminant_type_metadata: ValueRef,\n+    containing_scope: DIScope,\n+    file_metadata: DIFile,\n+    span: Span,\n+}\n+\n+impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription] {\n+        // Capture type_rep, so we don't have to copy the struct_defs array\n+        let struct_defs = match *self.type_rep {\n+            adt::General(ref struct_defs) => struct_defs,\n+            _ => cx.sess.bug(\"unreachable\")\n+        };\n+\n+        do struct_defs\n+            .iter()\n+            .enumerate()\n+            .map |(i, struct_def)| {\n+                let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n+                    describe_variant(cx,\n+                                     struct_def,\n+                                     self.variants[i],\n+                                     Some(self.discriminant_type_metadata),\n+                                     self.containing_scope,\n+                                     self.file_metadata,\n+                                     self.span);\n+\n+                let member_descriptions =\n+                    member_desc_factory.create_member_descriptions(cx);\n+\n+                set_members_of_composite_type(cx,\n+                                              variant_type_metadata,\n+                                              variant_llvm_type,\n+                                              member_descriptions,\n+                                              self.file_metadata,\n+                                              codemap::dummy_sp());\n                 MemberDescription {\n                     name: @\"\",\n-                    llvm_type: type_of::type_of(cx, component_type),\n-                    type_metadata: type_metadata(cx, component_type, span),\n-                    offset: ComputedMemberOffset,\n+                    llvm_type: variant_llvm_type,\n+                    type_metadata: variant_type_metadata,\n+                    offset: FixedMemberOffset { bytes: 0 },\n                 }\n+        }.collect()\n+    }\n+}\n+\n+struct EnumVariantMemberDescriptionFactory {\n+    args: ~[(@str, ty::t)],\n+    discriminant_type_metadata: Option<DIType>,\n+    span: Span,\n+}\n+\n+impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n+    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+                                  -> ~[MemberDescription] {\n+        do self.args.iter().enumerate().map |(i, &(name, ty))| {\n+            MemberDescription {\n+                name: name,\n+                llvm_type: type_of::type_of(cx, ty),\n+                type_metadata: match self.discriminant_type_metadata {\n+                    Some(metadata) if i == 0 => metadata,\n+                    _ => type_metadata(cx, ty, self.span)\n+                },\n+                offset: ComputedMemberOffset,\n+            }\n+        }.collect()\n+    }\n+}\n+\n+fn describe_variant(cx: &mut CrateContext,\n+                    struct_def: &adt::Struct,\n+                    variant_info: &ty::VariantInfo,\n+                    discriminant_type_metadata: Option<DIType>,\n+                    containing_scope: DIScope,\n+                    file_metadata: DIFile,\n+                    span: Span)\n+                 -> (DICompositeType, Type, @MemberDescriptionFactory) {\n+    let variant_name = token::ident_to_str(&variant_info.name);\n+    let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n+                                          struct_def.packed);\n+    // Could some consistency checks here: size, align, field count, discr type\n+\n+    // Find the source code location of the variant's definition\n+    let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n+        match cx.tcx.items.find(&variant_info.id.node) {\n+            Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n+            ref node => {\n+                cx.sess.span_warn(span,\n+                    fmt!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n+                          type: %?. This is a bug.\", node));\n+                codemap::dummy_sp()\n             }\n         }\n+    } else {\n+        // For definitions from other crates we have no location information available.\n+        codemap::dummy_sp()\n+    };\n+\n+    let metadata_stub = create_struct_stub(cx,\n+                                           variant_llvm_type,\n+                                           variant_name,\n+                                           containing_scope,\n+                                           file_metadata,\n+                                           variant_definition_span);\n+\n+    // Get the argument names from the enum variant info\n+    let mut arg_names = match variant_info.arg_names {\n+        Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n+        None => do variant_info.args.map |_| { @\"\" }\n+    };\n+\n+    // If this is not a univariant enum, there is also the (unnamed) discriminant field\n+    if discriminant_type_metadata.is_some() {\n+        arg_names.insert(0, @\"\");\n     }\n+\n+    // Build an array of (field name, field type) pairs to be captured in the factory closure.\n+    let args: ~[(@str, ty::t)] = arg_names.iter()\n+        .zip(struct_def.fields.iter())\n+        .map(|(&s, &t)| (s, t))\n+        .collect();\n+\n+    let member_description_factory =\n+        @EnumVariantMemberDescriptionFactory {\n+            args: args,\n+            discriminant_type_metadata: discriminant_type_metadata,\n+            span: span,\n+        } as @MemberDescriptionFactory;\n+\n+    (metadata_stub, variant_llvm_type, member_description_factory)\n }\n \n fn prepare_enum_metadata(cx: &mut CrateContext,\n@@ -1336,42 +1502,14 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                 metadata_stub: enum_metadata,\n                 llvm_type: enum_llvm_type,\n                 file_metadata: file_metadata,\n-                member_description_factory: |cx| {\n-                    // Capture type_rep, so we don't have to copy the struct_defs array\n-                    let struct_defs = match *type_rep {\n-                        adt::General(ref struct_defs) => struct_defs,\n-                        _ => cx.sess.bug(\"unreachable\")\n-                    };\n-\n-                    do struct_defs\n-                        .iter()\n-                        .enumerate()\n-                        .map |(i, struct_def)| {\n-                            let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n-                                describe_variant(cx,\n-                                                 struct_def,\n-                                                 variants[i],\n-                                                 Some(discriminant_type_metadata),\n-                                                 containing_scope,\n-                                                 file_metadata,\n-                                                 span);\n-\n-                            let member_descriptions = member_desc_factory(cx);\n-\n-                            set_members_of_composite_type(cx,\n-                                                          variant_type_metadata,\n-                                                          variant_llvm_type,\n-                                                          member_descriptions,\n-                                                          file_metadata,\n-                                                          codemap::dummy_sp());\n-                            MemberDescription {\n-                                name: @\"\",\n-                                llvm_type: variant_llvm_type,\n-                                type_metadata: variant_type_metadata,\n-                                offset: FixedMemberOffset { bytes: 0 },\n-                            }\n-                    }.collect()\n-                }\n+                member_description_factory: @GeneralMemberDescriptionFactory {\n+                    type_rep: type_rep,\n+                    variants: variants,\n+                    discriminant_type_metadata: discriminant_type_metadata,\n+                    containing_scope: containing_scope,\n+                    file_metadata: file_metadata,\n+                    span: span,\n+                } as @MemberDescriptionFactory,\n             }\n         }\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, _ } => {\n@@ -1393,76 +1531,6 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n             }\n         }\n     };\n-\n-    fn describe_variant(cx: &mut CrateContext,\n-                        struct_def: &adt::Struct,\n-                        variant_info: &ty::VariantInfo,\n-                        discriminant_type_metadata: Option<DIType>,\n-                        containing_scope: DIScope,\n-                        file_metadata: DIFile,\n-                        span: Span)\n-                     -> (DICompositeType, Type, @fn(&mut CrateContext) -> ~[MemberDescription]) {\n-        let variant_name = token::ident_to_str(&variant_info.name);\n-        let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n-                                              struct_def.packed);\n-        // Could some consistency checks here: size, align, field count, discr type\n-\n-        // Find the source code location of the variant's definition\n-        let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n-            match cx.tcx.items.find(&variant_info.id.node) {\n-                Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n-                ref node => {\n-                    cx.sess.span_warn(span,\n-                        fmt!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n-                              type: %?. This is a bug.\", node));\n-                    codemap::dummy_sp()\n-                }\n-            }\n-        } else {\n-            // For definitions from other crates we have no location information available.\n-            codemap::dummy_sp()\n-        };\n-\n-        let metadata_stub = create_struct_stub(cx,\n-                                               variant_llvm_type,\n-                                               variant_name,\n-                                               containing_scope,\n-                                               file_metadata,\n-                                               variant_definition_span);\n-\n-        // Get the argument names from the enum variant info\n-        let mut arg_names = match variant_info.arg_names {\n-            Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n-            None => do variant_info.args.map |_| { @\"\" }\n-        };\n-\n-        // If this is not a univariant enum, there is also the (unnamed) discriminant field\n-        if discriminant_type_metadata.is_some() {\n-            arg_names.insert(0, @\"\");\n-        }\n-\n-        // Build an array of (field name, field type) pairs to be captured in the factory closure.\n-        let args: ~[(@str, ty::t)] = arg_names.iter()\n-            .zip(struct_def.fields.iter())\n-            .map(|(&s, &t)| (s, t))\n-            .collect();\n-\n-        let member_description_factory: @fn(cx: &mut CrateContext) -> ~[MemberDescription] = |cx| {\n-            do args.iter().enumerate().map |(i, &(name, ty))| {\n-                MemberDescription {\n-                    name: name,\n-                    llvm_type: type_of::type_of(cx, ty),\n-                    type_metadata: match discriminant_type_metadata {\n-                        Some(metadata) if i == 0 => metadata,\n-                        _ => type_metadata(cx, ty, span)\n-                    },\n-                    offset: ComputedMemberOffset,\n-                }\n-            }.collect()\n-        };\n-\n-        (metadata_stub, variant_llvm_type, member_description_factory)\n-    }\n }\n \n enum MemberOffset {"}, {"sha": "a760801d73ad8b0cef446aeb5457f030434ef54d", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -581,11 +581,7 @@ pub fn make_take_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n       | ty::ty_estr(ty::vstore_slice(_)) => {\n         bcx\n       }\n-      ty::ty_closure(ty::ClosureTy { sigil: ast::BorrowedSigil, _ }) |\n-      ty::ty_closure(ty::ClosureTy { sigil: ast::ManagedSigil, _ }) => {\n-        closure::make_closure_glue(bcx, v, t, take_ty)\n-      }\n-      ty::ty_closure(ty::ClosureTy { sigil: ast::OwnedSigil, _ }) => bcx,\n+      ty::ty_closure(_) => bcx,\n       ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]));\n         incr_refcnt_of_boxed(bcx, llbox);\n@@ -606,9 +602,7 @@ pub fn make_take_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n                                 None);\n           bcx\n       }\n-      ty::ty_opaque_closure_ptr(ck) => {\n-        closure::make_opaque_cbox_take_glue(bcx, ck, v)\n-      }\n+      ty::ty_opaque_closure_ptr(_) => bcx,\n       ty::ty_struct(did, _) => {\n         let tcx = bcx.tcx();\n         let bcx = iter_structural_ty(bcx, v, t, take_ty);"}, {"sha": "bcf4de0807339f2966cfdda9bd23b54429b02f10", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -2308,12 +2308,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             ast::Many => TC_NONE\n         };\n         // Prevent noncopyable types captured in the environment from being copied.\n-        let ct = if cty.sigil == ast::ManagedSigil {\n-            TC_NONE\n-        } else {\n-            TC_NONCOPY_TRAIT\n-        };\n-        st + rt + ot + ct\n+        st + rt + ot + TC_NONCOPY_TRAIT\n     }\n \n     fn trait_contents(store: TraitStore, mutbl: ast::Mutability,"}, {"sha": "024010e40dfada55226c70d7f92d6da169a36b43", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -400,6 +400,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope + Clone + 'static>(\n                                             bf.abis, &bf.lifetimes, &bf.decl))\n       }\n       ast::ty_closure(ref f) => {\n+        if f.sigil == ast::ManagedSigil {\n+            tcx.sess.span_err(ast_ty.span,\n+                              \"managed closures are not supported\");\n+        }\n+\n           let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n               // Use corresponding trait store to figure out default bounds\n               // if none were specified."}, {"sha": "f1f7a7bf2d6b5d5acdcd5738ab5cd4bc27c1724d", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -33,6 +33,7 @@ use driver::driver::{compile_input};\n use driver::session;\n use middle::lint;\n \n+use std::comm;\n use std::io;\n use std::num;\n use std::os;\n@@ -43,6 +44,7 @@ use std::vec;\n use extra::getopts::groups;\n use extra::getopts;\n use syntax::codemap;\n+use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n \n pub mod middle {\n@@ -191,7 +193,7 @@ pub fn describe_debug_flags() {\n     }\n }\n \n-pub fn run_compiler(args: &[~str], demitter: diagnostic::Emitter) {\n+pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     ::std::logging::console_off();\n \n@@ -291,6 +293,23 @@ pub enum monitor_msg {\n     done,\n }\n \n+struct RustcEmitter {\n+    ch_capture: comm::SharedChan<monitor_msg>\n+}\n+\n+impl diagnostic::Emitter for RustcEmitter {\n+    fn emit(&self,\n+            cmsp: Option<(@codemap::CodeMap, codemap::Span)>,\n+            msg: &str,\n+            lvl: diagnostic::level) {\n+        if lvl == diagnostic::fatal {\n+            self.ch_capture.send(fatal)\n+        }\n+\n+        diagnostic::DefaultEmitter.emit(cmsp, msg, lvl)\n+    }\n+}\n+\n /*\n This is a sanity check that any failure of the compiler is performed\n through the diagnostic module and reported properly - we shouldn't be calling\n@@ -303,7 +322,7 @@ diagnostic emitter which records when we hit a fatal error. If the task\n fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n-pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n+pub fn monitor(f: ~fn(@diagnostic::Emitter)) {\n     use std::comm::*;\n \n     // XXX: This is a hack for newsched since it doesn't support split stacks.\n@@ -324,18 +343,11 @@ pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n \n     match do task_builder.try {\n         let ch = ch_capture.clone();\n-        let ch_capture = ch.clone();\n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n-        let demitter: @fn(Option<(@codemap::CodeMap, codemap::Span)>,\n-                          &str,\n-                          diagnostic::level) =\n-                          |cmsp, msg, lvl| {\n-            if lvl == diagnostic::fatal {\n-                ch_capture.send(fatal);\n-            }\n-            diagnostic::emit(cmsp, msg, lvl);\n-        };\n+        let demitter = @RustcEmitter {\n+            ch_capture: ch.clone(),\n+        } as @diagnostic::Emitter;\n \n         struct finally {\n             ch: SharedChan<monitor_msg>,\n@@ -357,7 +369,7 @@ pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n         result::Err(_) => {\n             // Task failed without emitting a fatal diagnostic\n             if p.recv() == done {\n-                diagnostic::emit(\n+                diagnostic::DefaultEmitter.emit(\n                     None,\n                     diagnostic::ice_msg(\"unexpected failure\"),\n                     diagnostic::error);\n@@ -370,7 +382,9 @@ pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n                      to github.com/mozilla/rust/issues\"\n                 ];\n                 for note in xs.iter() {\n-                    diagnostic::emit(None, *note, diagnostic::note)\n+                    diagnostic::DefaultEmitter.emit(None,\n+                                                    *note,\n+                                                    diagnostic::note)\n                 }\n             }\n             // Fail so the process returns a failure code"}, {"sha": "8337354724a44058ced9957eb89e78b6f5d96360", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -60,12 +60,12 @@ pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::Expr] {\n     fields.map(|f| f.expr)\n }\n \n-struct LoopQueryVisitor {\n-    p: @fn(&ast::Expr_) -> bool\n+struct LoopQueryVisitor<'self> {\n+    p: &'self fn(&ast::Expr_) -> bool\n }\n \n-impl Visitor<@mut bool> for LoopQueryVisitor {\n-    fn visit_expr(&mut self, e:@ast::Expr, flag:@mut bool) {\n+impl<'self> Visitor<@mut bool> for LoopQueryVisitor<'self> {\n+    fn visit_expr(&mut self, e: @ast::Expr, flag: @mut bool) {\n         *flag |= (self.p)(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n@@ -78,29 +78,33 @@ impl Visitor<@mut bool> for LoopQueryVisitor {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::Block, p: @fn(&ast::Expr_) -> bool) -> bool {\n+pub fn loop_query(b: &ast::Block, p: &fn(&ast::Expr_) -> bool) -> bool {\n     let rs = @mut false;\n-    let mut v = LoopQueryVisitor { p: p };\n+    let mut v = LoopQueryVisitor {\n+        p: p,\n+    };\n     visit::walk_block(&mut v, b, rs);\n     return *rs;\n }\n \n-struct BlockQueryVisitor {\n-    p: @fn(@ast::Expr) -> bool\n+struct BlockQueryVisitor<'self> {\n+    p: &'self fn(@ast::Expr) -> bool\n }\n \n-impl Visitor<@mut bool> for BlockQueryVisitor {\n-    fn visit_expr(&mut self, e:@ast::Expr, flag:@mut bool) {\n+impl<'self> Visitor<@mut bool> for BlockQueryVisitor<'self> {\n+    fn visit_expr(&mut self, e: @ast::Expr, flag: @mut bool) {\n         *flag |= (self.p)(e);\n         visit::walk_expr(self, e, flag)\n     }\n }\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: &ast::Block, p: @fn(@ast::Expr) -> bool) -> bool {\n+pub fn block_query(b: &ast::Block, p: &fn(@ast::Expr) -> bool) -> bool {\n     let rs = @mut false;\n-    let mut v = BlockQueryVisitor { p: p };\n+    let mut v = BlockQueryVisitor {\n+        p: p,\n+    };\n     visit::walk_block(&mut v, b, rs);\n     return *rs;\n }"}, {"sha": "8a7bb1f934615ba4f10e5e174ea24645c5b32627", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,9 +11,10 @@\n use rustc;\n use rustc::{driver, middle};\n \n-use syntax;\n-use syntax::parse;\n use syntax::ast;\n+use syntax::diagnostic;\n+use syntax::parse;\n+use syntax;\n \n use std::os;\n use std::local_data;\n@@ -48,9 +49,11 @@ fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n     let span_diagnostic_handler =\n         syntax::diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n \n-    let sess = driver::driver::build_session_(sessopts, parsesess.cm,\n-                                                  syntax::diagnostic::emit,\n-                                                  span_diagnostic_handler);\n+    let sess = driver::driver::build_session_(sessopts,\n+                                              parsesess.cm,\n+                                              @diagnostic::DefaultEmitter as\n+                                                @diagnostic::Emitter,\n+                                              span_diagnostic_handler);\n \n     let mut cfg = build_configuration(sess);\n     cfg.push(@dummy_spanned(ast::MetaWord(@\"stage2\")));"}, {"sha": "462c0a29236331c09451dd558fb726afdb0e3846", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -72,12 +72,14 @@ extern mod syntax;\n \n use std::{libc, io, os, task};\n use std::cell::Cell;\n+use extra::rl::CompletionCb;\n use extra::rl;\n \n use rustc::driver::{driver, session};\n use rustc::back::link::jit;\n-use syntax::{ast, diagnostic};\n+use syntax::{ast, codemap, diagnostic};\n use syntax::ast_util::*;\n+use syntax::diagnostic::Emitter;\n use syntax::parse::token;\n use syntax::print::pprust;\n \n@@ -107,6 +109,28 @@ enum CmdAction {\n     action_run_line(~str),\n }\n \n+struct EncodableWarningEmitter;\n+\n+impl diagnostic::Emitter for EncodableWarningEmitter {\n+    fn emit(&self,\n+            cm: Option<(@codemap::CodeMap, codemap::Span)>,\n+            msg: &str,\n+            lvl: diagnostic::level) {\n+        diagnostic::DefaultEmitter.emit(cm, msg, lvl);\n+        if msg.contains(\"failed to find an implementation of trait\") &&\n+           msg.contains(\"extra::serialize::Encodable\") {\n+            diagnostic::DefaultEmitter.emit(cm,\n+                                            \"Currrently rusti serializes \\\n+                                             bound locals between different \\\n+                                             lines of input. This means that \\\n+                                             all values of local variables \\\n+                                             need to be encodable, and this \\\n+                                             type isn't encodable\",\n+                                            diagnostic::note);\n+        }\n+    }\n+}\n+\n /// Run an input string in a Repl, returning the new Repl.\n fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n        input: ~str) -> (~Program, Option<~jit::Engine>)\n@@ -124,18 +148,9 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     // extra helpful information if the error crops up. Otherwise people are\n     // bound to be very confused when they find out code is running that they\n     // never typed in...\n-    let sess = driver::build_session(options, |cm, msg, lvl| {\n-        diagnostic::emit(cm, msg, lvl);\n-        if msg.contains(\"failed to find an implementation of trait\") &&\n-           msg.contains(\"extra::serialize::Encodable\") {\n-            diagnostic::emit(cm,\n-                             \"Currrently rusti serializes bound locals between \\\n-                              different lines of input. This means that all \\\n-                              values of local variables need to be encodable, \\\n-                              and this type isn't encodable\",\n-                             diagnostic::note);\n-        }\n-    });\n+    let sess = driver::build_session(options,\n+                                     @EncodableWarningEmitter as\n+                                        @diagnostic::Emitter);\n     let intr = token::get_ident_interner();\n \n     //\n@@ -243,7 +258,9 @@ fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n     let input = driver::str_input(code.to_managed());\n     let cfg = driver::build_configuration(sess);\n     let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n-    let sess = driver::build_session(options, diagnostic::emit);\n+    let sess = driver::build_session(options,\n+                                     @diagnostic::DefaultEmitter as\n+                                        @diagnostic::Emitter);\n \n     let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n     let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n@@ -305,7 +322,9 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n             .. (*session::basic_options()).clone()\n         };\n         let input = driver::file_input(src_path.clone());\n-        let sess = driver::build_session(options, diagnostic::emit);\n+        let sess = driver::build_session(options,\n+                                         @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter);\n         *sess.building_library = true;\n         let cfg = driver::build_configuration(sess);\n         let outputs = driver::build_output_filenames(\n@@ -502,6 +521,19 @@ pub fn main() {\n     main_args(args);\n }\n \n+struct Completer;\n+\n+impl CompletionCb for Completer {\n+    fn complete(&self, line: ~str, suggest: &fn(~str)) {\n+        if line.starts_with(\":\") {\n+            suggest(~\":clear\");\n+            suggest(~\":exit\");\n+            suggest(~\":help\");\n+            suggest(~\":load\");\n+        }\n+    }\n+}\n+\n pub fn main_args(args: &[~str]) {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -525,13 +557,8 @@ pub fn main_args(args: &[~str]) {\n         println(\"unstable. If you encounter problems, please use the\");\n         println(\"compiler instead. Type :help for help.\");\n \n-        do rl::complete |line, suggest| {\n-            if line.starts_with(\":\") {\n-                suggest(~\":clear\");\n-                suggest(~\":exit\");\n-                suggest(~\":help\");\n-                suggest(~\":load\");\n-            }\n+        unsafe {\n+            rl::complete(@Completer as @CompletionCb)\n         }\n     }\n "}, {"sha": "904594fdfb8f5a94f27de907997660ae4c79c233", "filename": "src/librusti/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -15,11 +15,11 @@ use syntax::print::pprust;\n use syntax::parse::token;\n use syntax::visit;\n \n-struct EachBindingVisitor {\n-    f: @fn(&ast::Path, ast::NodeId)\n+struct EachBindingVisitor<'self> {\n+    f: &'self fn(&ast::Path, ast::NodeId)\n }\n \n-impl visit::Visitor<()> for EachBindingVisitor {\n+impl<'self> visit::Visitor<()> for EachBindingVisitor<'self> {\n     fn visit_pat(&mut self, pat:@ast::Pat, _:()) {\n                 match pat.node {\n                     ast::PatIdent(_, ref path, _) => {\n@@ -32,7 +32,7 @@ impl visit::Visitor<()> for EachBindingVisitor {\n     }\n }\n \n-pub fn each_binding(l: @ast::Local, f: @fn(&ast::Path, ast::NodeId)) {\n+pub fn each_binding(l: @ast::Local, f: &fn(&ast::Path, ast::NodeId)) {\n     use syntax::visit::Visitor;\n \n     let mut vt = EachBindingVisitor{ f: f };"}, {"sha": "25d0802b9ad5148e261ab4cd36901ddd4d235e35", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -110,7 +110,9 @@ impl<'self> PkgScript<'self> {\n             .. (*session::basic_options()).clone()\n         };\n         let input = driver::file_input(script.clone());\n-        let sess = driver::build_session(options, diagnostic::emit);\n+        let sess = driver::build_session(options,\n+                                         @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter);\n         let cfg = driver::build_configuration(sess);\n         let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n         let crate = driver::phase_2_configure_and_expand(sess, cfg.clone(), crate);"}, {"sha": "79f137de853a3cc7b5f0f85a92858258948c8fe4", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1567,8 +1567,11 @@ fn test_linker_build() {\n     let matches = getopts([], optgroups());\n     let options = build_session_options(@\"rustpkg\",\n                                         matches.get_ref(),\n-                                        diagnostic::emit);\n-    let sess = build_session(options, diagnostic::emit);\n+                                        @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter);\n+    let sess = build_session(options,\n+                             @diagnostic::DefaultEmitter as\n+                                @diagnostic::Emitter);\n     command_line_test([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"--linker\","}, {"sha": "5d5e895a5adae88384ad695e3383bfd55c9ae04a", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 89, "deletions": 46, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -16,8 +16,11 @@ use extra::getopts::groups::getopts;\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, Spanned};\n use syntax::ext::base::ExtCtxt;\n-use syntax::{ast, attr, codemap, diagnostic, fold};\n+use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n+use syntax::fold::ast_fold;\n+use syntax::visit::Visitor;\n+use rustc::back::link::output_type_exe;\n use rustc::back::link;\n use rustc::driver::session::{lib_crate, bin_crate};\n use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n@@ -26,6 +29,7 @@ use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n use path_util::{installed_library_in_workspace, U_RWX, rust_path, system_library, target_build_dir};\n use messages::error;\n+use conditions::nonexistent_package::cond;\n \n pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n use workcache_support::{digest_file_with_date, digest_only_date};\n@@ -70,9 +74,8 @@ struct ReadyCtx {\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(_ctx: @mut ReadyCtx,\n-            m: &ast::_mod,\n-            fold: @fold::ast_fold) -> ast::_mod {\n+fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n+            -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: do item.attrs.iter().filter_map |attr| {\n@@ -94,9 +97,8 @@ fn fold_mod(_ctx: @mut ReadyCtx,\n     }, fold)\n }\n \n-fn fold_item(ctx: @mut ReadyCtx,\n-             item: @ast::item,\n-             fold: @fold::ast_fold) -> Option<@ast::item> {\n+fn fold_item(ctx: @mut ReadyCtx, item: @ast::item, fold: &CrateSetup)\n+             -> Option<@ast::item> {\n     ctx.path.push(item.ident);\n \n     let mut cmds = ~[];\n@@ -134,6 +136,19 @@ fn fold_item(ctx: @mut ReadyCtx,\n     res\n }\n \n+struct CrateSetup {\n+    ctx: @mut ReadyCtx,\n+}\n+\n+impl fold::ast_fold for CrateSetup {\n+    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+        fold_item(self.ctx, item, self)\n+    }\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        fold_mod(self.ctx, module, self)\n+    }\n+}\n+\n /// Generate/filter main function, add the list of commands, etc.\n pub fn ready_crate(sess: session::Session,\n                    crate: @ast::Crate) -> @ast::Crate {\n@@ -144,15 +159,9 @@ pub fn ready_crate(sess: session::Session,\n         path: ~[],\n         fns: ~[]\n     };\n-    let precursor = @fold::AstFoldFns {\n-        // fold_crate: fold::wrap(|a, b| fold_crate(ctx, a, b)),\n-        fold_item: |a, b| fold_item(ctx, a, b),\n-        fold_mod: |a, b| fold_mod(ctx, a, b),\n-        .. *fold::default_ast_fold()\n+    let fold = CrateSetup {\n+        ctx: ctx,\n     };\n-\n-    let fold = fold::make_fold(precursor);\n-\n     @fold.fold_crate(crate)\n }\n \n@@ -225,7 +234,10 @@ pub fn compile_input(context: &BuildContext,\n         maybe_sysroot: Some(sysroot_to_use),\n         addl_lib_search_paths: @mut (~[]),\n         output_type: output_type,\n-        .. (*driver::build_session_options(binary, &matches, diagnostic::emit)).clone()\n+        .. (*driver::build_session_options(binary,\n+                                           &matches,\n+                                           @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter)).clone()\n     };\n \n     let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n@@ -240,7 +252,9 @@ pub fn compile_input(context: &BuildContext,\n         }\n     }\n \n-    let sess = driver::build_session(options, diagnostic::emit);\n+    let sess = driver::build_session(options,\n+                                     @diagnostic::DefaultEmitter as\n+                                        @diagnostic::Emitter);\n \n     // Infer dependencies that rustpkg needs to build, by scanning for\n     // `extern mod` directives.\n@@ -383,31 +397,28 @@ pub fn compile_crate(ctxt: &BuildContext,\n     compile_input(ctxt, exec, pkg_id, crate, workspace, flags, cfgs, opt, what)\n }\n \n+struct ViewItemVisitor<'self> {\n+    context: &'self BuildContext,\n+    parent: &'self PkgId,\n+    sess: session::Session,\n+    exec: &'self mut workcache::Exec,\n+    c: &'self ast::Crate,\n+    save: &'self fn(Path),\n+}\n \n-/// Collect all `extern mod` directives in `c`, then\n-/// try to install their targets, failing if any target\n-/// can't be found.\n-pub fn find_and_install_dependencies(context: &BuildContext,\n-                                     parent: &PkgId,\n-                                     sess: session::Session,\n-                                     exec: &mut workcache::Exec,\n-                                     c: &ast::Crate,\n-                                     save: @fn(Path)\n-                                     ) {\n-    use conditions::nonexistent_package::cond;\n-\n-    do c.each_view_item() |vi: &ast::view_item| {\n+impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n+    fn visit_view_item(&mut self, vi: &ast::view_item, env: ()) {\n         debug!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n             ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n                 let lib_name = match path_opt {\n                     Some(p) => p,\n-                    None => sess.str_of(lib_ident)\n+                    None => self.sess.str_of(lib_ident)\n                 };\n                 debug!(\"Finding and installing... %s\", lib_name);\n                 // Check standard Rust library path first\n-                match system_library(&context.sysroot(), lib_name) {\n+                match system_library(&self.context.sysroot(), lib_name) {\n                     Some(ref installed_path) => {\n                         debug!(\"It exists: %s\", installed_path.to_str());\n                         // Say that [path for c] has a discovered dependency on\n@@ -416,44 +427,54 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                         // I'm not sure what the right thing is.\n                         // Now we know that this crate has a discovered dependency on\n                         // installed_path\n-                        exec.discover_input(\"binary\", installed_path.to_str(),\n-                                                      digest_only_date(installed_path));\n+                        self.exec.discover_input(\"binary\",\n+                                                 installed_path.to_str(),\n+                                                 digest_only_date(installed_path));\n                     }\n                     None => {\n                         // FIXME #8711: need to parse version out of path_opt\n                         debug!(\"Trying to install library %s, rebuilding it\",\n                                lib_name.to_str());\n                         // Try to install it\n                         let pkg_id = PkgId::new(lib_name);\n-                        let workspaces = pkg_parent_workspaces(&context.context, &pkg_id);\n+                        let workspaces = pkg_parent_workspaces(&self.context.context,\n+                                                               &pkg_id);\n                         let dep_workspace = if workspaces.is_empty() {\n                             error(fmt!(\"Couldn't find package %s, which is needed by %s, \\\n                                             in any of the workspaces in the RUST_PATH (%?)\",\n-                                            lib_name, parent.to_str(), rust_path()));\n+                                            lib_name,\n+                                            self.parent.to_str(),\n+                                            rust_path()));\n                             cond.raise((pkg_id.clone(), ~\"Dependency not found\"))\n                         }\n                         else {\n                             workspaces[0]\n                         };\n                         let (outputs_disc, inputs_disc) =\n-                            context.install(PkgSrc::new(dep_workspace.clone(),\n-                                false, pkg_id), &JustOne(Path(lib_crate_filename)));\n+                            self.context.install(PkgSrc::new(dep_workspace.clone(),\n+                                                             false,\n+                                                             pkg_id),\n+                                                 &JustOne(Path(\n+                                                    lib_crate_filename)));\n                         debug!(\"Installed %s, returned %? dependencies and \\\n                                %? transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n                         for dep in outputs_disc.iter() {\n                             debug!(\"Discovering a binary input: %s\", dep.to_str());\n-                            exec.discover_input(\"binary\", dep.to_str(),\n-                                                digest_only_date(dep));\n+                            self.exec.discover_input(\"binary\",\n+                                                     dep.to_str(),\n+                                                     digest_only_date(dep));\n                         }\n                         for &(ref what, ref dep) in inputs_disc.iter() {\n                             if *what == ~\"file\" {\n-                                exec.discover_input(*what, *dep,\n-                                                    digest_file_with_date(&Path(*dep)));\n+                                self.exec.discover_input(*what,\n+                                                         *dep,\n+                                                         digest_file_with_date(&Path(*dep)));\n                             }\n                             else if *what == ~\"binary\" {\n-                                exec.discover_input(*what, *dep,\n-                                                    digest_only_date(&Path(*dep)));\n+                                self.exec.discover_input(*what,\n+                                                         *dep,\n+                                                         digest_only_date(&Path(*dep)));\n                             }\n                             else {\n                                 fail!(\"Bad kind: %s\", *what);\n@@ -468,14 +489,36 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                         let install_dir = installed_library.pop();\n                         debug!(\"Installed %s into %s [%?]\", lib_name, install_dir.to_str(),\n                                datestamp(&installed_library));\n-                        save(install_dir);\n+                        (self.save)(install_dir);\n                     }\n                 }}\n             // Ignore `use`s\n             _ => ()\n         }\n-        true\n+\n+        visit::walk_view_item(self, vi, env)\n+    }\n+}\n+\n+/// Collect all `extern mod` directives in `c`, then\n+/// try to install their targets, failing if any target\n+/// can't be found.\n+pub fn find_and_install_dependencies(context: &BuildContext,\n+                                     parent: &PkgId,\n+                                     sess: session::Session,\n+                                     exec: &mut workcache::Exec,\n+                                     c: &ast::Crate,\n+                                     save: &fn(Path)) {\n+    debug!(\"In find_and_install_dependencies...\");\n+    let mut visitor = ViewItemVisitor {\n+        context: context,\n+        parent: parent,\n+        sess: sess,\n+        exec: exec,\n+        c: c,\n+        save: save,\n     };\n+    visit::walk_crate(&mut visitor, c, ())\n }\n \n pub fn mk_string_lit(s: @str) -> ast::lit {"}, {"sha": "ab8af22e1165ef0b0aeb8054e8e9fd7d9a28bd5a", "filename": "src/libstd/io.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1846,31 +1846,38 @@ pub mod fsync {\n     pub struct Arg<t> {\n         val: t,\n         opt_level: Option<Level>,\n-        fsync_fn: @fn(f: &t, Level) -> int,\n+        fsync_fn: extern \"Rust\" fn(f: &t, Level) -> int,\n     }\n \n     // fsync file after executing blk\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n-    pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n+    pub fn FILE_res_sync(file: &FILERes,\n+                         opt_level: Option<Level>,\n                          blk: &fn(v: Res<*libc::FILE>)) {\n         blk(Res::new(Arg {\n-            val: file.f, opt_level: opt_level,\n-            fsync_fn: |file, l| fsync_fd(fileno(*file), l)\n+            val: file.f,\n+            opt_level: opt_level,\n+            fsync_fn: fsync_FILE,\n         }));\n \n         fn fileno(stream: *libc::FILE) -> libc::c_int {\n             #[fixed_stack_segment]; #[inline(never)];\n             unsafe { libc::fileno(stream) }\n         }\n+\n+        fn fsync_FILE(stream: &*libc::FILE, level: Level) -> int {\n+            fsync_fd(fileno(*stream), level)\n+        }\n     }\n \n     // fsync fd after executing blk\n     pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n                        blk: &fn(v: Res<fd_t>)) {\n         blk(Res::new(Arg {\n-            val: fd.fd, opt_level: opt_level,\n-            fsync_fn: |fd, l| fsync_fd(*fd, l)\n+            val: fd.fd,\n+            opt_level: opt_level,\n+            fsync_fn: fsync_fd_helper,\n         }));\n     }\n \n@@ -1880,17 +1887,26 @@ pub mod fsync {\n         os::fsync_fd(fd, level) as int\n     }\n \n+    fn fsync_fd_helper(fd_ptr: &libc::c_int, level: Level) -> int {\n+        fsync_fd(*fd_ptr, level)\n+    }\n+\n     // Type of objects that may want to fsync\n     pub trait FSyncable { fn fsync(&self, l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n     pub fn obj_sync(o: @FSyncable, opt_level: Option<Level>,\n                     blk: &fn(v: Res<@FSyncable>)) {\n         blk(Res::new(Arg {\n-            val: o, opt_level: opt_level,\n-            fsync_fn: |o, l| (*o).fsync(l)\n+            val: o,\n+            opt_level: opt_level,\n+            fsync_fn: obj_fsync_fn,\n         }));\n     }\n+\n+    fn obj_fsync_fn(o: &@FSyncable, level: Level) -> int {\n+        (*o).fsync(level)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "833a9f5ed82568ed0b7d246aba661a82458b7e28", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -485,9 +485,11 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n-        self.align_to::<@fn()>();\n-        if ! self.inner.visit_closure_ptr(ck) { return false; }\n-        self.bump_past::<@fn()>();\n+        self.align_to::<~fn()>();\n+        if ! self.inner.visit_closure_ptr(ck) {\n+            return false\n+        }\n+        self.bump_past::<~fn()>();\n         true\n     }\n }"}, {"sha": "e8a91b49c8ee4cb31aa4ecd70cfe0ccadbad551f", "filename": "src/libstd/routine.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Froutine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Froutine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Froutine.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn add(n: int) -> @fn(int) -> int {\n-    let result: @fn(int) -> int = |m| m + n;\n-    result\n-}\n-\n-pub fn main()\n-{\n-    assert_eq!(add(3)(4), 7);\n+/*!\n+ * Routines are like closures except that they own their arguments and can\n+ * only run once.\n+ */\n \n-    let add1 : @fn(int)->int = add(1);\n-    assert_eq!(add1(6), 7);\n+/// A routine that takes no arguments and returns nothing.\n+pub trait Runnable {\n+    /// The entry point for the routine.\n+    fn run(~self);\n+}\n \n-    let add2 : &(@fn(int)->int) = &add(2);\n-    assert_eq!((*add2)(5), 7);\n+/// A convenience routine that does nothing.\n+pub struct NoOpRunnable;\n \n-    let add3 : &fn(int)->int = add(3);\n-    assert_eq!(add3(4), 7);\n+impl Runnable for NoOpRunnable {\n+    fn run(~self) {}\n }\n+", "previous_filename": "src/test/run-pass/fn-assign-managed-to-bare-2.rs"}, {"sha": "5c1bac7418e6f330ca2d92c478edcdc0cc97fa08", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -189,7 +189,7 @@ pub mod reflect;\n pub mod condition;\n pub mod logging;\n pub mod util;\n-\n+pub mod routine;\n \n /* Unsupported interfaces */\n "}, {"sha": "4d53dd7d7bfff63c36355dc1e011260e9d11d137", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -158,11 +158,14 @@ pub mod ct {\n \n     // A fragment of the output sequence\n     #[deriving(Eq)]\n-    pub enum Piece { PieceString(~str), PieceConv(Conv), }\n+    pub enum Piece {\n+        PieceString(~str),\n+        PieceConv(Conv),\n+    }\n \n-    pub type ErrorFn = @fn(&str) -> !;\n+    pub type ErrorFn<'self> = &'self fn(&str) -> !;\n \n-    pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n+    pub fn parse_fmt_string<'a>(s: &str, err: ErrorFn<'a>) -> ~[Piece] {\n         fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n             if to > from {\n                 ps.push(PieceString(s.slice(from, to).to_owned()));\n@@ -185,7 +188,10 @@ pub mod ct {\n                     i += 1;\n                 } else {\n                     push_slice(&mut pieces, s, h, i - 1);\n-                    let Parsed {val, next} = parse_conversion(s, i, lim, err);\n+                    let Parsed {\n+                        val,\n+                        next\n+                    } = parse_conversion(s, i, lim, |s| err(s));\n                     pieces.push(val);\n                     i = next;\n                 }\n@@ -224,8 +230,8 @@ pub mod ct {\n         }\n     }\n \n-    pub fn parse_conversion(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n-        Parsed<Piece> {\n+    pub fn parse_conversion<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n+                                -> Parsed<Piece> {\n         let param = parse_parameter(s, i, lim);\n         // avoid copying ~[Flag] by destructuring\n         let Parsed {val: flags_val, next: flags_next} = parse_flags(s,\n@@ -308,8 +314,8 @@ pub mod ct {\n         }\n     }\n \n-    pub fn parse_type(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n-        Parsed<Ty> {\n+    pub fn parse_type<'a>(s: &str, i: uint, lim: uint, err: ErrorFn<'a>)\n+                          -> Parsed<Ty> {\n         if i >= lim { err(\"missing type in conversion\"); }\n \n         // FIXME (#2249): Do we really want two signed types here?"}, {"sha": "ba5986aa4ab9db3fa81bf6e371879c235f32421e", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -55,7 +55,6 @@ impl<'self,T> Finally<T> for &'self fn() -> T {\n }\n \n finally_fn!(~fn() -> T)\n-finally_fn!(@fn() -> T)\n finally_fn!(extern \"Rust\" fn() -> T)\n \n struct Finallyalizer<'self> {\n@@ -119,14 +118,3 @@ fn test_owned() {\n     spawn_with_finalizer(owned);\n }\n \n-#[test]\n-fn test_managed() {\n-    let i = @mut 10;\n-    let managed: @fn() -> int = || {\n-        let r = *i;\n-        *i += 10;\n-        r\n-    };\n-    assert_eq!(do managed.finally {}, 10);\n-    assert_eq!(*i, 20);\n-}"}, {"sha": "ac88fc835d50d51bce7bad9a4a1fc1478f2851e1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,7 +12,6 @@ use ast::*;\n use ast;\n use ast_util;\n use codemap::{Span, dummy_sp};\n-use fold;\n use opt_vec;\n use parse::token;\n use visit::Visitor;\n@@ -371,21 +370,6 @@ pub fn empty_generics() -> Generics {\n               ty_params: opt_vec::Empty}\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Assigning node ids\n-\n-fn node_id_assigner(next_id: @fn() -> ast::NodeId) -> @fold::ast_fold {\n-    let precursor = @fold::AstFoldFns {\n-        new_id: |old_id| {\n-            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-            next_id()\n-        },\n-        ..*fold::default_ast_fold()\n-    };\n-\n-    fold::make_fold(precursor)\n-}\n-\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n@@ -413,29 +397,33 @@ impl id_range {\n     }\n }\n \n-pub fn id_visitor(vfn: @fn(NodeId), pass_through_items: bool)\n+pub fn id_visitor(operation: @IdVisitingOperation, pass_through_items: bool)\n                   -> @mut Visitor<()> {\n     let visitor = @mut IdVisitor {\n-        visit_callback: vfn,\n+        operation: operation,\n         pass_through_items: pass_through_items,\n         visited_outermost: false,\n     };\n     visitor as @mut Visitor<()>\n }\n \n+pub trait IdVisitingOperation {\n+    fn visit_id(&self, node_id: NodeId);\n+}\n+\n pub struct IdVisitor {\n-    visit_callback: @fn(NodeId),\n+    operation: @IdVisitingOperation,\n     pass_through_items: bool,\n     visited_outermost: bool,\n }\n \n impl IdVisitor {\n     fn visit_generics_helper(&self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {\n-            (self.visit_callback)(type_parameter.id)\n+            self.operation.visit_id(type_parameter.id)\n         }\n         for lifetime in generics.lifetimes.iter() {\n-            (self.visit_callback)(lifetime.id)\n+            self.operation.visit_id(lifetime.id)\n         }\n     }\n }\n@@ -446,26 +434,26 @@ impl Visitor<()> for IdVisitor {\n                  _: Span,\n                  node_id: NodeId,\n                  env: ()) {\n-        (self.visit_callback)(node_id);\n+        self.operation.visit_id(node_id);\n         visit::walk_mod(self, module, env)\n     }\n \n     fn visit_view_item(&mut self, view_item: &view_item, env: ()) {\n         match view_item.node {\n             view_item_extern_mod(_, _, _, node_id) => {\n-                (self.visit_callback)(node_id)\n+                self.operation.visit_id(node_id)\n             }\n             view_item_use(ref view_paths) => {\n                 for view_path in view_paths.iter() {\n                     match view_path.node {\n                         view_path_simple(_, _, node_id) |\n                         view_path_glob(_, node_id) => {\n-                            (self.visit_callback)(node_id)\n+                            self.operation.visit_id(node_id)\n                         }\n                         view_path_list(_, ref paths, node_id) => {\n-                            (self.visit_callback)(node_id);\n+                            self.operation.visit_id(node_id);\n                             for path in paths.iter() {\n-                                (self.visit_callback)(path.node.id)\n+                                self.operation.visit_id(path.node.id)\n                             }\n                         }\n                     }\n@@ -476,7 +464,7 @@ impl Visitor<()> for IdVisitor {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: @foreign_item, env: ()) {\n-        (self.visit_callback)(foreign_item.id);\n+        self.operation.visit_id(foreign_item.id);\n         visit::walk_foreign_item(self, foreign_item, env)\n     }\n \n@@ -489,11 +477,11 @@ impl Visitor<()> for IdVisitor {\n             }\n         }\n \n-        (self.visit_callback)(item.id);\n+        self.operation.visit_id(item.id);\n         match item.node {\n             item_enum(ref enum_definition, _) => {\n                 for variant in enum_definition.variants.iter() {\n-                    (self.visit_callback)(variant.node.id)\n+                    self.operation.visit_id(variant.node.id)\n                 }\n             }\n             _ => {}\n@@ -505,22 +493,22 @@ impl Visitor<()> for IdVisitor {\n     }\n \n     fn visit_local(&mut self, local: @Local, env: ()) {\n-        (self.visit_callback)(local.id);\n+        self.operation.visit_id(local.id);\n         visit::walk_local(self, local, env)\n     }\n \n     fn visit_block(&mut self, block: &Block, env: ()) {\n-        (self.visit_callback)(block.id);\n+        self.operation.visit_id(block.id);\n         visit::walk_block(self, block, env)\n     }\n \n     fn visit_stmt(&mut self, statement: @Stmt, env: ()) {\n-        (self.visit_callback)(ast_util::stmt_id(statement));\n+        self.operation.visit_id(ast_util::stmt_id(statement));\n         visit::walk_stmt(self, statement, env)\n     }\n \n     fn visit_pat(&mut self, pattern: @Pat, env: ()) {\n-        (self.visit_callback)(pattern.id);\n+        self.operation.visit_id(pattern.id);\n         visit::walk_pat(self, pattern, env)\n     }\n \n@@ -529,17 +517,17 @@ impl Visitor<()> for IdVisitor {\n         {\n             let optional_callee_id = expression.get_callee_id();\n             for callee_id in optional_callee_id.iter() {\n-                (self.visit_callback)(*callee_id)\n+                self.operation.visit_id(*callee_id)\n             }\n         }\n-        (self.visit_callback)(expression.id);\n+        self.operation.visit_id(expression.id);\n         visit::walk_expr(self, expression, env)\n     }\n \n     fn visit_ty(&mut self, typ: &Ty, env: ()) {\n-        (self.visit_callback)(typ.id);\n+        self.operation.visit_id(typ.id);\n         match typ.node {\n-            ty_path(_, _, id) => (self.visit_callback)(id),\n+            ty_path(_, _, id) => self.operation.visit_id(id),\n             _ => {}\n         }\n         visit::walk_ty(self, typ, env)\n@@ -565,21 +553,21 @@ impl Visitor<()> for IdVisitor {\n             }\n         }\n \n-        (self.visit_callback)(node_id);\n+        self.operation.visit_id(node_id);\n \n         match *function_kind {\n             visit::fk_item_fn(_, generics, _, _) => {\n                 self.visit_generics_helper(generics)\n             }\n             visit::fk_method(_, generics, method) => {\n-                (self.visit_callback)(method.self_id);\n+                self.operation.visit_id(method.self_id);\n                 self.visit_generics_helper(generics)\n             }\n             visit::fk_anon(_) | visit::fk_fn_block => {}\n         }\n \n         for argument in function_declaration.inputs.iter() {\n-            (self.visit_callback)(argument.id)\n+            self.operation.visit_id(argument.id)\n         }\n \n         visit::walk_fn(self,\n@@ -599,25 +587,36 @@ impl Visitor<()> for IdVisitor {\n     }\n \n     fn visit_struct_field(&mut self, struct_field: @struct_field, env: ()) {\n-        (self.visit_callback)(struct_field.node.id);\n+        self.operation.visit_id(struct_field.node.id);\n         visit::walk_struct_field(self, struct_field, env)\n     }\n }\n \n-pub fn visit_ids_for_inlined_item(item: &inlined_item, vfn: @fn(NodeId)) {\n+pub fn visit_ids_for_inlined_item(item: &inlined_item,\n+                                  operation: @IdVisitingOperation) {\n     let mut id_visitor = IdVisitor {\n-        visit_callback: vfn,\n+        operation: operation,\n         pass_through_items: true,\n         visited_outermost: false,\n     };\n     item.accept((), &mut id_visitor);\n }\n \n-pub fn compute_id_range(visit_ids_fn: &fn(@fn(NodeId))) -> id_range {\n-    let result = @mut id_range::max();\n-    do visit_ids_fn |id| {\n-        result.add(id);\n+struct IdRangeComputingVisitor {\n+    result: @mut id_range,\n+}\n+\n+impl IdVisitingOperation for IdRangeComputingVisitor {\n+    fn visit_id(&self, id: NodeId) {\n+        self.result.add(id)\n     }\n+}\n+\n+pub fn compute_id_range(visit_ids_fn: &fn(@IdVisitingOperation)) -> id_range {\n+    let result = @mut id_range::max();\n+    visit_ids_fn(@IdRangeComputingVisitor {\n+        result: result,\n+    } as @IdVisitingOperation);\n     *result\n }\n "}, {"sha": "aa06e1bee4141371406c19bf6eab5d9ae61f4aec", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -15,9 +15,12 @@ use std::io;\n use std::local_data;\n use extra::term;\n \n-pub type Emitter = @fn(cmsp: Option<(@codemap::CodeMap, Span)>,\n-                       msg: &str,\n-                       lvl: level);\n+pub trait Emitter {\n+    fn emit(&self,\n+            cmsp: Option<(@codemap::CodeMap, Span)>,\n+            msg: &str,\n+            lvl: level);\n+}\n \n // a handler deals with errors; certain errors\n // (fatal, bug, unimpl) may cause immediate exit,\n@@ -55,7 +58,7 @@ pub trait span_handler {\n \n struct HandlerT {\n     err_count: uint,\n-    emit: Emitter,\n+    emit: @Emitter,\n }\n \n struct CodemapT {\n@@ -91,11 +94,11 @@ impl span_handler for CodemapT {\n \n impl handler for HandlerT {\n     fn fatal(@mut self, msg: &str) -> ! {\n-        (self.emit)(None, msg, fatal);\n+        self.emit.emit(None, msg, fatal);\n         fail!();\n     }\n     fn err(@mut self, msg: &str) {\n-        (self.emit)(None, msg, error);\n+        self.emit.emit(None, msg, error);\n         self.bump_err_count();\n     }\n     fn bump_err_count(@mut self) {\n@@ -120,10 +123,10 @@ impl handler for HandlerT {\n         self.fatal(s);\n     }\n     fn warn(@mut self, msg: &str) {\n-        (self.emit)(None, msg, warning);\n+        self.emit.emit(None, msg, warning);\n     }\n     fn note(@mut self, msg: &str) {\n-        (self.emit)(None, msg, note);\n+        self.emit.emit(None, msg, note);\n     }\n     fn bug(@mut self, msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n@@ -135,7 +138,7 @@ impl handler for HandlerT {\n             cmsp: Option<(@codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: level) {\n-        (self.emit)(cmsp, msg, lvl);\n+        self.emit.emit(cmsp, msg, lvl);\n     }\n }\n \n@@ -145,19 +148,22 @@ pub fn ice_msg(msg: &str) -> ~str {\n \n pub fn mk_span_handler(handler: @mut handler, cm: @codemap::CodeMap)\n                     -> @mut span_handler {\n-    @mut CodemapT { handler: handler, cm: cm } as @mut span_handler\n+    @mut CodemapT {\n+        handler: handler,\n+        cm: cm,\n+    } as @mut span_handler\n }\n \n-pub fn mk_handler(emitter: Option<Emitter>) -> @mut handler {\n-    let emit: Emitter = match emitter {\n+pub fn mk_handler(emitter: Option<@Emitter>) -> @mut handler {\n+    let emit: @Emitter = match emitter {\n         Some(e) => e,\n-        None => {\n-            let emit: Emitter = |cmsp, msg, t| emit(cmsp, msg, t);\n-            emit\n-        }\n+        None => @DefaultEmitter as @Emitter\n     };\n \n-    @mut HandlerT { err_count: 0, emit: emit } as @mut handler\n+    @mut HandlerT {\n+        err_count: 0,\n+        emit: emit,\n+    } as @mut handler\n }\n \n #[deriving(Eq)]\n@@ -230,31 +236,30 @@ fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n     print_maybe_styled(fmt!(\"%s\\n\", msg), term::attr::Bold);\n }\n \n-pub fn collect(messages: @mut ~[~str])\n-            -> @fn(Option<(@codemap::CodeMap, Span)>, &str, level) {\n-    let f: @fn(Option<(@codemap::CodeMap, Span)>, &str, level) =\n-        |_o, msg: &str, _l| { messages.push(msg.to_str()); };\n-    f\n-}\n+pub struct DefaultEmitter;\n \n-pub fn emit(cmsp: Option<(@codemap::CodeMap, Span)>, msg: &str, lvl: level) {\n-    match cmsp {\n-      Some((cm, sp)) => {\n-        let sp = cm.adjust_span(sp);\n-        let ss = cm.span_to_str(sp);\n-        let lines = cm.span_to_lines(sp);\n-        print_diagnostic(ss, lvl, msg);\n-        highlight_lines(cm, sp, lvl, lines);\n-        print_macro_backtrace(cm, sp);\n-      }\n-      None => {\n-        print_diagnostic(\"\", lvl, msg);\n-      }\n+impl Emitter for DefaultEmitter {\n+    fn emit(&self,\n+            cmsp: Option<(@codemap::CodeMap, Span)>,\n+            msg: &str,\n+            lvl: level) {\n+        match cmsp {\n+            Some((cm, sp)) => {\n+                let sp = cm.adjust_span(sp);\n+                let ss = cm.span_to_str(sp);\n+                let lines = cm.span_to_lines(sp);\n+                print_diagnostic(ss, lvl, msg);\n+                highlight_lines(cm, sp, lvl, lines);\n+                print_macro_backtrace(cm, sp);\n+            }\n+            None => print_diagnostic(\"\", lvl, msg),\n+        }\n     }\n }\n \n fn highlight_lines(cm: @codemap::CodeMap,\n-                   sp: Span, lvl: level,\n+                   sp: Span,\n+                   lvl: level,\n                    lines: @codemap::FileLines) {\n     let fm = lines.file;\n "}, {"sha": "48eb9a350f1357c4abcce7a52ff79ca10d1ccedb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 160, "deletions": 79, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -33,62 +33,120 @@ pub struct MacroDef {\n     ext: SyntaxExtension\n }\n \n-// No context arg for an Item Decorator macro, simply because\n-// adding it would require adding a ctxt field to all items.\n-// we could do this if it turns out to be useful.\n-\n-pub type ItemDecoratorFun = @fn(@ExtCtxt,\n-                             Span,\n-                             @ast::MetaItem,\n-                             ~[@ast::item])\n-                          -> ~[@ast::item];\n-\n-pub type SyntaxExpanderTTFun = @fn(@ExtCtxt,\n-                                   Span,\n-                                   &[ast::token_tree],\n-                                   ast::SyntaxContext)\n-                                -> MacResult;\n-\n-pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n-                                       Span,\n-                                       ast::Ident,\n-                                       ~[ast::token_tree],\n-                                       ast::SyntaxContext)\n-                                    -> MacResult;\n-\n-// oog... in order to make the presentation of builtin_normal_tt_no_ctxt\n-// and builtin_ident_tt_no_ctxt palatable, we need one-off types for\n-// functions that don't consume a ctxt:\n-\n-pub type SyntaxExpanderTTFunNoCtxt = @fn(@ExtCtxt,\n-                                   Span,\n-                                   &[ast::token_tree])\n-                                -> MacResult;\n-\n-pub type SyntaxExpanderTTItemFunNoCtxt = @fn(@ExtCtxt,\n-                                       Span,\n-                                       ast::Ident,\n-                                       ~[ast::token_tree])\n-                                    -> MacResult;\n+pub type ItemDecorator = extern \"Rust\" fn(@ExtCtxt,\n+                                          Span,\n+                                          @ast::MetaItem,\n+                                          ~[@ast::item])\n+                                          -> ~[@ast::item];\n+\n+pub struct SyntaxExpanderTT {\n+    expander: SyntaxExpanderTTExpander,\n+    span: Option<Span>\n+}\n+\n+pub trait SyntaxExpanderTTTrait {\n+    fn expand(&self,\n+              ecx: @ExtCtxt,\n+              span: Span,\n+              token_tree: &[ast::token_tree],\n+              context: ast::SyntaxContext)\n+              -> MacResult;\n+}\n+\n+pub type SyntaxExpanderTTFunNoCtxt =\n+    extern \"Rust\" fn(ecx: @ExtCtxt,\n+                     span: codemap::Span,\n+                     token_tree: &[ast::token_tree])\n+                     -> MacResult;\n+\n+enum SyntaxExpanderTTExpander {\n+    SyntaxExpanderTTExpanderWithoutContext(SyntaxExpanderTTFunNoCtxt),\n+}\n+\n+impl SyntaxExpanderTTTrait for SyntaxExpanderTT {\n+    fn expand(&self,\n+              ecx: @ExtCtxt,\n+              span: Span,\n+              token_tree: &[ast::token_tree],\n+              _: ast::SyntaxContext)\n+              -> MacResult {\n+        match self.expander {\n+            SyntaxExpanderTTExpanderWithoutContext(f) => {\n+                f(ecx, span, token_tree)\n+            }\n+        }\n+    }\n+}\n \n+enum SyntaxExpanderTTItemExpander {\n+    SyntaxExpanderTTItemExpanderWithContext(SyntaxExpanderTTItemFun),\n+    SyntaxExpanderTTItemExpanderWithoutContext(SyntaxExpanderTTItemFunNoCtxt),\n+}\n \n+pub struct SyntaxExpanderTTItem {\n+    expander: SyntaxExpanderTTItemExpander,\n+    span: Option<Span>\n+}\n+\n+pub trait SyntaxExpanderTTItemTrait {\n+    fn expand(&self,\n+              cx: @ExtCtxt,\n+              sp: Span,\n+              ident: ast::Ident,\n+              token_tree: ~[ast::token_tree],\n+              context: ast::SyntaxContext)\n+              -> MacResult;\n+}\n+\n+impl SyntaxExpanderTTItemTrait for SyntaxExpanderTTItem {\n+    fn expand(&self,\n+              cx: @ExtCtxt,\n+              sp: Span,\n+              ident: ast::Ident,\n+              token_tree: ~[ast::token_tree],\n+              context: ast::SyntaxContext)\n+              -> MacResult {\n+        match self.expander {\n+            SyntaxExpanderTTItemExpanderWithContext(fun) => {\n+                fun(cx, sp, ident, token_tree, context)\n+            }\n+            SyntaxExpanderTTItemExpanderWithoutContext(fun) => {\n+                fun(cx, sp, ident, token_tree)\n+            }\n+        }\n+    }\n+}\n+\n+pub type SyntaxExpanderTTItemFun = extern \"Rust\" fn(@ExtCtxt,\n+                                                    Span,\n+                                                    ast::Ident,\n+                                                    ~[ast::token_tree],\n+                                                    ast::SyntaxContext)\n+                                                    -> MacResult;\n+\n+pub type SyntaxExpanderTTItemFunNoCtxt =\n+    extern \"Rust\" fn(@ExtCtxt, Span, ast::Ident, ~[ast::token_tree])\n+                     -> MacResult;\n+\n+pub trait AnyMacro {\n+    fn make_expr(&self) -> @ast::Expr;\n+    fn make_item(&self) -> Option<@ast::item>;\n+    fn make_stmt(&self) -> @ast::Stmt;\n+}\n \n pub enum MacResult {\n     MRExpr(@ast::Expr),\n     MRItem(@ast::item),\n-    MRAny(@fn() -> @ast::Expr,\n-          @fn() -> Option<@ast::item>,\n-          @fn() -> @ast::Stmt),\n-    MRDef(MacroDef)\n+    MRAny(@AnyMacro),\n+    MRDef(MacroDef),\n }\n \n pub enum SyntaxExtension {\n-\n     // #[auto_encode] and such\n-    ItemDecorator(ItemDecoratorFun),\n+    ItemDecorator(ItemDecorator),\n \n     // Token-tree expanders\n-    NormalTT(SyntaxExpanderTTFun, Option<Span>),\n+    NormalTT(@SyntaxExpanderTTTrait, Option<Span>),\n \n     // An IdentTT is a macro that has an\n     // identifier in between the name of the\n@@ -98,7 +156,7 @@ pub enum SyntaxExtension {\n \n     // perhaps macro_rules! will lose its odd special identifier argument,\n     // and this can go away also\n-    IdentTT(SyntaxExpanderTTItemFun, Option<Span>),\n+    IdentTT(@SyntaxExpanderTTItemTrait, Option<Span>),\n }\n \n \n@@ -133,16 +191,22 @@ type RenameList = ~[(ast::Ident,Name)];\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n-    // that ignore their contexts\n-    fn builtin_normal_tt_no_ctxt(f: SyntaxExpanderTTFunNoCtxt) -> @Transformer {\n-        let wrapped_expander : SyntaxExpanderTTFun = |a,b,c,_d|{f(a,b,c)};\n-        @SE(NormalTT(wrapped_expander, None))\n+    fn builtin_normal_tt_no_ctxt(f: SyntaxExpanderTTFunNoCtxt)\n+                                 -> @Transformer {\n+        @SE(NormalTT(@SyntaxExpanderTT{\n+            expander: SyntaxExpanderTTExpanderWithoutContext(f),\n+            span: None,\n+        } as @SyntaxExpanderTTTrait,\n+        None))\n     }\n     // utility function to simplify creating IdentTT syntax extensions\n     // that ignore their contexts\n     fn builtin_item_tt_no_ctxt(f: SyntaxExpanderTTItemFunNoCtxt) -> @Transformer {\n-        let wrapped_expander : SyntaxExpanderTTItemFun = |a,b,c,d,_e|{f(a,b,c,d)};\n-        @SE(IdentTT(wrapped_expander, None))\n+        @SE(IdentTT(@SyntaxExpanderTTItem {\n+            expander: SyntaxExpanderTTItemExpanderWithoutContext(f),\n+            span: None,\n+        } as @SyntaxExpanderTTItemTrait,\n+        None))\n     }\n     let mut syntax_expanders = HashMap::new();\n     // NB identifier starts with space, and can't conflict with legal idents\n@@ -152,79 +216,96 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 pending_renames : @mut ~[]\n                             }));\n     syntax_expanders.insert(intern(&\"macro_rules\"),\n-                            @SE(IdentTT(ext::tt::macro_rules::add_new_extension, None)));\n+                            @SE(IdentTT(@SyntaxExpanderTTItem {\n+                                expander: SyntaxExpanderTTItemExpanderWithContext(\n+                                    ext::tt::macro_rules::add_new_extension),\n+                                span: None,\n+                            } as @SyntaxExpanderTTItemTrait,\n+                            None)));\n     syntax_expanders.insert(intern(&\"fmt\"),\n-                            builtin_normal_tt_no_ctxt(ext::fmt::expand_syntax_ext));\n+                            builtin_normal_tt_no_ctxt(\n+                                ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"format_args\"),\n-                            builtin_normal_tt_no_ctxt(ext::format::expand_args));\n+                            builtin_normal_tt_no_ctxt(\n+                                ext::format::expand_args));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n     syntax_expanders.insert(\n         intern(&\"auto_decode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n     syntax_expanders.insert(intern(&\"env\"),\n-                            builtin_normal_tt_no_ctxt(ext::env::expand_env));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::env::expand_env));\n     syntax_expanders.insert(intern(&\"option_env\"),\n-                            builtin_normal_tt_no_ctxt(ext::env::expand_option_env));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::env::expand_option_env));\n     syntax_expanders.insert(intern(\"bytes\"),\n-                            builtin_normal_tt_no_ctxt(ext::bytes::expand_syntax_ext));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::bytes::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"concat_idents\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::concat_idents::expand_syntax_ext));\n+                                    ext::concat_idents::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"log_syntax\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::log_syntax::expand_syntax_ext));\n+                                    ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"deriving\"),\n                             @SE(ItemDecorator(\n                                 ext::deriving::expand_meta_deriving)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(intern(&\"quote_tokens\"),\n-                            builtin_normal_tt_no_ctxt(\n-                                ext::quote::expand_quote_tokens));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_tokens));\n     syntax_expanders.insert(intern(&\"quote_expr\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_expr));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_expr));\n     syntax_expanders.insert(intern(&\"quote_ty\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_ty));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_ty));\n     syntax_expanders.insert(intern(&\"quote_item\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_item));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_item));\n     syntax_expanders.insert(intern(&\"quote_pat\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_pat));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_pat));\n     syntax_expanders.insert(intern(&\"quote_stmt\"),\n-                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_stmt));\n+                       builtin_normal_tt_no_ctxt(\n+                            ext::quote::expand_quote_stmt));\n \n     syntax_expanders.insert(intern(&\"line\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_line));\n+                                    ext::source_util::expand_line));\n     syntax_expanders.insert(intern(&\"col\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_col));\n+                                    ext::source_util::expand_col));\n     syntax_expanders.insert(intern(&\"file\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_file));\n+                                    ext::source_util::expand_file));\n     syntax_expanders.insert(intern(&\"stringify\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_stringify));\n+                                    ext::source_util::expand_stringify));\n     syntax_expanders.insert(intern(&\"include\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_include));\n+                                    ext::source_util::expand_include));\n     syntax_expanders.insert(intern(&\"include_str\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_include_str));\n+                                    ext::source_util::expand_include_str));\n     syntax_expanders.insert(intern(&\"include_bin\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_include_bin));\n+                                    ext::source_util::expand_include_bin));\n     syntax_expanders.insert(intern(&\"module_path\"),\n                             builtin_normal_tt_no_ctxt(\n-                                ext::source_util::expand_mod));\n+                                    ext::source_util::expand_mod));\n     syntax_expanders.insert(intern(&\"asm\"),\n-                            builtin_normal_tt_no_ctxt(ext::asm::expand_asm));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::asm::expand_asm));\n     syntax_expanders.insert(intern(&\"cfg\"),\n-                            builtin_normal_tt_no_ctxt(ext::cfg::expand_cfg));\n-    syntax_expanders.insert(\n-        intern(&\"trace_macros\"),\n-        builtin_normal_tt_no_ctxt(ext::trace_macros::expand_trace_macros));\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::cfg::expand_cfg));\n+    syntax_expanders.insert(intern(&\"trace_macros\"),\n+                            builtin_normal_tt_no_ctxt(\n+                                    ext::trace_macros::expand_trace_macros));\n     MapChain::new(~syntax_expanders)\n }\n "}, {"sha": "ba2342d78279edab38d59b71aaced149787833d3", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -15,6 +15,7 @@ use ast_util;\n use codemap::{Span, respan, dummy_sp};\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n+use fold;\n use opt_vec;\n use opt_vec::OptVec;\n \n@@ -862,3 +863,32 @@ impl AstBuilder for @ExtCtxt {\n                                 ast::view_path_glob(self.path(sp, path), ast::DUMMY_NODE_ID))])\n     }\n }\n+\n+struct Duplicator {\n+    cx: @ExtCtxt,\n+}\n+\n+impl fold::ast_fold for Duplicator {\n+    fn new_id(&self, _: NodeId) -> NodeId {\n+        ast::DUMMY_NODE_ID\n+    }\n+}\n+\n+pub trait Duplicate {\n+    //\n+    // Duplication functions\n+    //\n+    // These functions just duplicate AST nodes.\n+    //\n+\n+    fn duplicate(&self, cx: @ExtCtxt) -> Self;\n+}\n+\n+impl Duplicate for @ast::Expr {\n+    fn duplicate(&self, cx: @ExtCtxt) -> @ast::Expr {\n+        let folder = @Duplicator {\n+            cx: cx,\n+        } as @fold::ast_fold;\n+        folder.fold_expr(*self)\n+    }\n+}"}, {"sha": "004a889fb4df77632d7cdec207c3c2112e0edaed", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 327, "deletions": 162, "changes": 489, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -10,7 +10,7 @@\n \n use ast::{Block, Crate, DeclLocal, Expr_, ExprMac, SyntaxContext};\n use ast::{Local, Ident, mac_invoc_tt};\n-use ast::{item_mac, Mrk, Stmt_, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n+use ast::{item_mac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::{token_tree};\n use ast;\n use ast_util::{mtwt_outer_mark, new_rename, new_mark};\n@@ -21,6 +21,7 @@ use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan};\n use ext::base::*;\n use fold::*;\n+use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n@@ -32,12 +33,10 @@ use std::vec;\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n-                   e: &Expr_,\n-                   span: Span,\n-                   fld: @ast_fold,\n-                   orig: @fn(&Expr_, Span, @ast_fold) -> (Expr_, Span))\n-                -> (Expr_, Span) {\n-    match *e {\n+                   e: @ast::Expr,\n+                   fld: &MacroExpander)\n+                   -> @ast::Expr {\n+    match e.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ExprMac(ref mac) => {\n@@ -66,7 +65,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         }\n                         Some(@SE(NormalTT(expandfun, exp_span))) => {\n                             cx.bt_push(ExpnInfo {\n-                                call_site: span,\n+                                call_site: e.span,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n                                     span: exp_span,\n@@ -84,10 +83,12 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             let mac_span = original_span(cx);\n \n                             let expanded =\n-                                match expandfun(cx, mac_span.call_site,\n-                                                marked_before, marked_ctxt) {\n+                                match expandfun.expand(cx,\n+                                                       mac_span.call_site,\n+                                                       marked_before,\n+                                                       marked_ctxt) {\n                                     MRExpr(e) => e,\n-                                    MRAny(expr_maker,_,_) => expr_maker(),\n+                                    MRAny(any_macro) => any_macro.make_expr(),\n                                     _ => {\n                                         cx.span_fatal(\n                                             pth.span,\n@@ -101,12 +102,19 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             // mark after:\n                             let marked_after = mark_expr(expanded,fm);\n \n-                            //keep going, outside-in\n+                            // Keep going, outside-in.\n+                            //\n+                            // XXX(pcwalton): Is it necessary to clone the\n+                            // node here?\n                             let fully_expanded =\n                                 fld.fold_expr(marked_after).node.clone();\n                             cx.bt_pop();\n \n-                            (fully_expanded, span)\n+                            @ast::Expr {\n+                                id: ast::DUMMY_NODE_ID,\n+                                node: fully_expanded,\n+                                span: e.span,\n+                            }\n                         }\n                         _ => {\n                             cx.span_fatal(\n@@ -125,8 +133,48 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         ast::ExprForLoop(src_pat, src_expr, ref src_loop_block, opt_ident) => {\n             // Expand any interior macros etc.\n             // NB: we don't fold pats yet. Curious.\n-            let src_expr = fld.fold_expr(src_expr);\n-            let src_loop_block = fld.fold_block(src_loop_block);\n+            let src_expr = fld.fold_expr(src_expr).clone();\n+            let src_loop_block = fld.fold_block(src_loop_block).clone();\n+\n+            let span = e.span;\n+\n+            pub fn mk_expr(_: @ExtCtxt, span: Span, node: Expr_)\n+                           -> @ast::Expr {\n+                @ast::Expr {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: node,\n+                    span: span,\n+                }\n+            }\n+\n+            fn mk_block(_: @ExtCtxt,\n+                        stmts: &[@ast::Stmt],\n+                        expr: Option<@ast::Expr>,\n+                        span: Span)\n+                        -> ast::Block {\n+                ast::Block {\n+                    view_items: ~[],\n+                    stmts: stmts.to_owned(),\n+                    expr: expr,\n+                    id: ast::DUMMY_NODE_ID,\n+                    rules: ast::DefaultBlock,\n+                    span: span,\n+                }\n+            }\n+\n+            fn mk_simple_path(ident: ast::Ident, span: Span) -> ast::Path {\n+                ast::Path {\n+                    span: span,\n+                    global: false,\n+                    segments: ~[\n+                        ast::PathSegment {\n+                            identifier: ident,\n+                            lifetime: None,\n+                            types: opt_vec::Empty,\n+                        }\n+                    ],\n+                }\n+            }\n \n             // to:\n             //\n@@ -182,10 +230,14 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                  ~[iter_decl_stmt],\n                                  Some(loop_expr));\n \n-            (ast::ExprBlock(block), span)\n+            @ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                node: ast::ExprBlock(block),\n+                span: span,\n+            }\n         }\n \n-        _ => orig(e, span, fld)\n+        _ => noop_fold_expr(e, fld)\n     }\n }\n \n@@ -201,12 +253,10 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n                         cx: @ExtCtxt,\n                         module_: &ast::_mod,\n-                        fld: @ast_fold,\n-                        orig: @fn(&ast::_mod, @ast_fold) -> ast::_mod)\n-                     -> ast::_mod {\n-\n+                        fld: &MacroExpander)\n+                        -> ast::_mod {\n     // Fold the contents first:\n-    let module_ = orig(module_, fld);\n+    let module_ = noop_fold_mod(module_, fld);\n \n     // For each item, look through the attributes.  If any of them are\n     // decorated with \"item decorators\", then use that function to transform\n@@ -233,7 +283,10 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n         }\n     };\n \n-    ast::_mod { items: new_items, ..module_ }\n+    ast::_mod {\n+        items: new_items,\n+        ..module_\n+    }\n }\n \n // eval $e with a new exts frame:\n@@ -256,19 +309,20 @@ static special_block_name : &'static str = \" block\";\n pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n                    it: @ast::item,\n-                   fld: @ast_fold,\n-                   orig: @fn(@ast::item, @ast_fold) -> Option<@ast::item>)\n-                -> Option<@ast::item> {\n+                   fld: &MacroExpander)\n+                   -> Option<@ast::item> {\n     match it.node {\n         ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n         ast::item_mod(_) | ast::item_foreign_mod(_) => {\n             cx.mod_push(it.ident);\n             let macro_escape = contains_macro_escape(it.attrs);\n-            let result = with_exts_frame!(extsbox,macro_escape,orig(it,fld));\n+            let result = with_exts_frame!(extsbox,\n+                                          macro_escape,\n+                                          noop_fold_item(it, fld));\n             cx.mod_pop();\n             result\n         },\n-        _ => orig(it,fld)\n+        _ => noop_fold_item(it, fld)\n     }\n }\n \n@@ -280,11 +334,15 @@ pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n-                       cx: @ExtCtxt, it: @ast::item,\n-                       fld: @ast_fold)\n-                    -> Option<@ast::item> {\n+                       cx: @ExtCtxt,\n+                       it: @ast::item,\n+                       fld: &MacroExpander)\n+                       -> Option<@ast::item> {\n     let (pth, tts, ctxt) = match it.node {\n-        item_mac(codemap::Spanned { node: mac_invoc_tt(ref pth, ref tts, ctxt), _}) => {\n+        item_mac(codemap::Spanned {\n+            node: mac_invoc_tt(ref pth, ref tts, ctxt),\n+            _\n+        }) => {\n             (pth, (*tts).clone(), ctxt)\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n@@ -314,7 +372,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_before = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            expander(cx, it.span, marked_before, marked_ctxt)\n+            expander.expand(cx, it.span, marked_before, marked_ctxt)\n         }\n         Some(@SE(IdentTT(expander, span))) => {\n             if it.ident.name == parse::token::special_idents::invalid.name {\n@@ -332,7 +390,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             // mark before expansion:\n             let marked_tts = mark_tts(tts,fm);\n             let marked_ctxt = new_mark(fm,ctxt);\n-            expander(cx, it.span, it.ident, marked_tts, marked_ctxt)\n+            expander.expand(cx, it.span, it.ident, marked_tts, marked_ctxt)\n         }\n         _ => cx.span_fatal(\n             it.span, fmt!(\"%s! is not legal in item position\", extnamestr))\n@@ -346,10 +404,10 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         MRExpr(_) => {\n             cx.span_fatal(pth.span, fmt!(\"expr macro in item position: %s\", extnamestr))\n         }\n-        MRAny(_, item_maker, _) => {\n-            item_maker()\n-                .and_then(|i| mark_item(i,fm))\n-                .and_then(|i| fld.fold_item(i))\n+        MRAny(any_macro) => {\n+            any_macro.make_item()\n+                     .and_then(|i| mark_item(i,fm))\n+                     .and_then(|i| fld.fold_item(i))\n         }\n         MRDef(ref mdef) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n@@ -382,40 +440,39 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n-                   s: &Stmt_,\n-                   sp: Span,\n-                   fld: @ast_fold,\n-                   orig: @fn(&Stmt_, Span, @ast_fold)\n-                             -> (Option<Stmt_>, Span))\n-                -> (Option<Stmt_>, Span) {\n+                   s: &Stmt,\n+                   fld: &MacroExpander)\n+                   -> Option<@Stmt> {\n     // why the copying here and not in expand_expr?\n     // looks like classic changed-in-only-one-place\n-    let (pth, tts, semi, ctxt) = match *s {\n+    let (pth, tts, semi, ctxt) = match s.node {\n         StmtMac(ref mac, semi) => {\n             match mac.node {\n                 mac_invoc_tt(ref pth, ref tts, ctxt) => {\n                     (pth, (*tts).clone(), semi, ctxt)\n                 }\n             }\n         }\n-        _ => return expand_non_macro_stmt(*extsbox,s,sp,fld,orig)\n+        _ => return expand_non_macro_stmt(*extsbox, s, fld)\n     };\n     if (pth.segments.len() > 1u) {\n-        cx.span_fatal(\n-            pth.span,\n-            fmt!(\"expected macro name without module \\\n-                  separators\"));\n+        cx.span_fatal(pth.span,\n+                      \"expected macro name without module separators\");\n     }\n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n-    let (fully_expanded, sp) = match (*extsbox).find(&extname.name) {\n-        None =>\n-            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", extnamestr)),\n+    let fully_expanded: @ast::Stmt = match (*extsbox).find(&extname.name) {\n+        None => {\n+            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", extnamestr))\n+        }\n \n         Some(@SE(NormalTT(expandfun, exp_span))) => {\n             cx.bt_push(ExpnInfo {\n-                call_site: sp,\n-                callee: NameAndSpan { name: extnamestr, span: exp_span }\n+                call_site: s.span,\n+                callee: NameAndSpan {\n+                    name: extnamestr,\n+                    span: exp_span,\n+                }\n             });\n             let fm = fresh_mark();\n             // mark before expansion:\n@@ -426,32 +483,40 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             // not the current mac.span.\n             let mac_span = original_span(cx);\n \n-            let expanded = match expandfun(cx, mac_span.call_site,\n-                                           marked_tts, marked_ctxt) {\n-                MRExpr(e) =>\n-                    @codemap::Spanned { node: StmtExpr(e, ast::DUMMY_NODE_ID),\n-                                        span: e.span},\n-                MRAny(_,_,stmt_mkr) => stmt_mkr(),\n+            let expanded = match expandfun.expand(cx,\n+                                                  mac_span.call_site,\n+                                                  marked_tts,\n+                                                  marked_ctxt) {\n+                MRExpr(e) => {\n+                    @codemap::Spanned {\n+                        node: StmtExpr(e, ast::DUMMY_NODE_ID),\n+                        span: e.span,\n+                    }\n+                }\n+                MRAny(any_macro) => any_macro.make_stmt(),\n                 _ => cx.span_fatal(\n                     pth.span,\n                     fmt!(\"non-stmt macro in stmt pos: %s\", extnamestr))\n             };\n             let marked_after = mark_stmt(expanded,fm);\n \n-            //keep going, outside-in\n+            // Keep going, outside-in.\n             let fully_expanded = match fld.fold_stmt(marked_after) {\n                 Some(stmt) => {\n                     let fully_expanded = &stmt.node;\n                     cx.bt_pop();\n-                    (*fully_expanded).clone()\n+                    @Spanned {\n+                        span: stmt.span,\n+                        node: (*fully_expanded).clone(),\n+                    }\n                 }\n                 None => {\n                     cx.span_fatal(pth.span,\n                                   \"macro didn't expand to a statement\")\n                 }\n             };\n \n-            (fully_expanded, sp)\n+            fully_expanded\n         }\n \n         _ => {\n@@ -460,24 +525,28 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n         }\n     };\n \n-    (match fully_expanded {\n-        StmtExpr(e, stmt_id) if semi => Some(StmtSemi(e, stmt_id)),\n-        _ => { Some(fully_expanded) } /* might already have a semi */\n-    }, sp)\n-\n+    match fully_expanded.node {\n+        StmtExpr(e, stmt_id) if semi => {\n+            Some(@Spanned {\n+                span: fully_expanded.span,\n+                node: StmtSemi(e, stmt_id),\n+            })\n+        }\n+        _ => Some(fully_expanded), /* might already have a semi */\n+    }\n }\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n // expand_stmt, above.\n-fn expand_non_macro_stmt (exts: SyntaxEnv,\n-                          s: &Stmt_,\n-                          sp: Span,\n-                          fld: @ast_fold,\n-                          orig: @fn(&Stmt_, Span, @ast_fold) -> (Option<Stmt_>, Span))\n-    -> (Option<Stmt_>,Span) {\n+fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n+                         -> Option<@Stmt> {\n     // is it a let?\n-    match *s {\n-        StmtDecl(@Spanned{node: DeclLocal(ref local), span: stmt_span}, node_id) => {\n+    match s.node {\n+        StmtDecl(@Spanned {\n+            node: DeclLocal(ref local),\n+            span: stmt_span\n+        },\n+        node_id) => {\n             let block_info = get_block_info(exts);\n             let pending_renames = block_info.pending_renames;\n \n@@ -515,19 +584,24 @@ fn expand_non_macro_stmt (exts: SyntaxEnv,\n             // also, don't forget to expand the init:\n             let new_init_opt = init.map(|e| fld.fold_expr(*e));\n             let rewritten_local =\n-                @Local{is_mutbl:is_mutbl,\n-                       ty:ty,\n-                       pat:rewritten_pat,\n-                       init:new_init_opt,\n-                       id:id,\n-                       span:span};\n-            (Some(StmtDecl(@Spanned{node:DeclLocal(rewritten_local),\n-                                     span: stmt_span},node_id)),\n-             sp)\n+                @Local {\n+                    is_mutbl: is_mutbl,\n+                    ty: ty,\n+                    pat: rewritten_pat,\n+                    init: new_init_opt,\n+                    id: id,\n+                    span: span,\n+                };\n+            Some(@Spanned {\n+                node: StmtDecl(@Spanned {\n+                        node: DeclLocal(rewritten_local),\n+                        span: stmt_span\n+                    },\n+                    node_id),\n+                span: span\n+            })\n         },\n-        _ => {\n-            orig(s, sp, fld)\n-        }\n+        _ => noop_fold_stmt(s, fld),\n     }\n }\n \n@@ -628,18 +702,18 @@ pub fn new_path_finder(paths: @mut ~[ast::Path]) -> @mut Visitor<()> {\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n pub fn expand_block(extsbox: @mut SyntaxEnv,\n-                    _cx: @ExtCtxt,\n+                    _: @ExtCtxt,\n                     blk: &Block,\n-                    fld: @ast_fold,\n-                    _orig: @fn(&Block, @ast_fold) -> Block)\n-                 -> Block {\n+                    fld: &MacroExpander)\n+                    -> Block {\n     // see note below about treatment of exts table\n     with_exts_frame!(extsbox,false,\n                      expand_block_elts(*extsbox, blk, fld))\n }\n \n // expand the elements of a block.\n-pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: @ast_fold) -> Block {\n+pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n+                         -> Block {\n     let block_info = get_block_info(exts);\n     let pending_renames = block_info.pending_renames;\n     let rename_fld = renames_to_fold(pending_renames);\n@@ -680,9 +754,47 @@ fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n     }\n }\n \n+struct IdentRenamer {\n+    renames: @mut ~[(ast::Ident,ast::Name)],\n+}\n+\n+impl ast_fold for IdentRenamer {\n+    fn fold_ident(&self, id: ast::Ident) -> ast::Ident {\n+        let new_ctxt = self.renames.iter().fold(id.ctxt, |ctxt, &(from, to)| {\n+            new_rename(from, to, ctxt)\n+        });\n+        ast::Ident {\n+            name: id.name,\n+            ctxt: new_ctxt,\n+        }\n+    }\n+}\n+\n+// given a mutable list of renames, return a tree-folder that applies those\n+// renames.\n+pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n+    @IdentRenamer {\n+        renames: renames,\n+    } as @ast_fold\n+}\n+\n+// perform a bunch of renames\n+fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n+    match folder.fold_stmt(&stmt) {\n+        Some(s) => s,\n+        None => fail!(fmt!(\"renaming of stmt produced None\"))\n+    }\n+}\n+\n+\n+\n pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n-    return Span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n+    Span {\n+        lo: sp.lo,\n+        hi: sp.hi,\n+        expn_info: cx.backtrace(),\n+    }\n }\n \n // FIXME (#2247): this is a moderately bad kludge to inject some macros into\n@@ -1025,10 +1137,28 @@ pub fn std_macros() -> @str {\n }\";\n }\n \n+struct Injector {\n+    sm: @ast::item,\n+}\n+\n+impl ast_fold for Injector {\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        // Just inject the standard macros at the start of the first module\n+        // in the crate: that is, at the start of the crate file itself.\n+        let items = vec::append(~[ self.sm ], module.items);\n+        ast::_mod {\n+            items: items,\n+            ..(*module).clone() // FIXME #2543: Bad copy.\n+        }\n+    }\n+}\n+\n // add a bunch of macros as though they were placed at the head of the\n // program (ick). This should run before cfg stripping.\n pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n-                         cfg: ast::CrateConfig, c: &Crate) -> @Crate {\n+                         cfg: ast::CrateConfig,\n+                         c: @Crate)\n+                         -> @Crate {\n     let sm = match parse_item_from_source_str(@\"<std-macros>\",\n                                               std_macros(),\n                                               cfg.clone(),\n@@ -1038,48 +1168,80 @@ pub fn inject_std_macros(parse_sess: @mut parse::ParseSess,\n         None => fail!(\"expected core macros to parse correctly\")\n     };\n \n-    let injecter = @AstFoldFns {\n-        fold_mod: |modd, _| {\n-            // just inject the std macros at the start of the first\n-            // module in the crate (i.e the crate file itself.)\n-            let items = vec::append(~[sm], modd.items);\n-            ast::_mod {\n-                items: items,\n-                // FIXME #2543: Bad copy.\n-                .. (*modd).clone()\n-            }\n-        },\n-        .. *default_ast_fold()\n-    };\n-    @make_fold(injecter).fold_crate(c)\n+    let injector = @Injector {\n+        sm: sm,\n+    } as @ast_fold;\n+    @injector.fold_crate(c)\n+}\n+\n+struct NoOpFolder {\n+    contents: (),\n+}\n+\n+impl ast_fold for NoOpFolder {}\n+\n+struct MacroExpander {\n+    extsbox: @mut SyntaxEnv,\n+    cx: @ExtCtxt,\n+}\n+\n+impl ast_fold for MacroExpander {\n+    fn fold_expr(&self, expr: @ast::Expr) -> @ast::Expr {\n+        expand_expr(self.extsbox,\n+                    self.cx,\n+                    expr,\n+                    self)\n+    }\n+\n+    fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n+        expand_mod_items(self.extsbox,\n+                         self.cx,\n+                         module,\n+                         self)\n+    }\n+\n+    fn fold_item(&self, item: @ast::item) -> Option<@ast::item> {\n+        expand_item(self.extsbox,\n+                    self.cx,\n+                    item,\n+                    self)\n+    }\n+\n+    fn fold_stmt(&self, stmt: &ast::Stmt) -> Option<@ast::Stmt> {\n+        expand_stmt(self.extsbox,\n+                    self.cx,\n+                    stmt,\n+                    self)\n+    }\n+\n+    fn fold_block(&self, block: &ast::Block) -> ast::Block {\n+        expand_block(self.extsbox,\n+                     self.cx,\n+                     block,\n+                     self)\n+    }\n+\n+    fn new_span(&self, span: Span) -> Span {\n+        new_span(self.cx, span)\n+    }\n }\n \n pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n-                    cfg: ast::CrateConfig, c: &Crate) -> @Crate {\n+                    cfg: ast::CrateConfig,\n+                    c: &Crate) -> @Crate {\n     // adding *another* layer of indirection here so that the block\n     // visitor can swap out one exts table for another for the duration\n     // of the block.  The cleaner alternative would be to thread the\n     // exts table through the fold, but that would require updating\n     // every method/element of AstFoldFns in fold.rs.\n-    let extsbox = @mut syntax_expander_table();\n-    let afp = default_ast_fold();\n+    let extsbox = syntax_expander_table();\n     let cx = ExtCtxt::new(parse_sess, cfg.clone());\n-    let f_pre = @AstFoldFns {\n-        fold_expr: |expr,span,recur|\n-            expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),\n-        fold_mod: |modd,recur|\n-            expand_mod_items(extsbox, cx, modd, recur, afp.fold_mod),\n-        fold_item: |item,recur|\n-            expand_item(extsbox, cx, item, recur, afp.fold_item),\n-        fold_stmt: |stmt,span,recur|\n-            expand_stmt(extsbox, cx, stmt, span, recur, afp.fold_stmt),\n-        fold_block: |blk,recur|\n-            expand_block(extsbox, cx, blk, recur, afp.fold_block),\n-        new_span: |a| new_span(cx, a),\n-        .. *afp};\n-    let f = make_fold(f_pre);\n-\n-    let ret = @f.fold_crate(c);\n+    let expander = @MacroExpander {\n+        extsbox: @mut extsbox,\n+        cx: cx,\n+    } as @ast_fold;\n+\n+    let ret = @expander.fold_crate(c);\n     parse_sess.span_diagnostic.handler().abort_if_errors();\n     return ret;\n }\n@@ -1145,53 +1307,56 @@ impl CtxtFn for Repainter {\n     }\n }\n \n-// given a function from ctxts to ctxts, produce\n-// an ast_fold that applies that function to all ctxts:\n-pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n-    let afp = default_ast_fold();\n-    let fi : @fn(ast::Ident, @ast_fold) -> ast::Ident =\n-        |ast::Ident{name, ctxt}, _| {\n-        ast::Ident{name:name,ctxt:cf.f(ctxt)}\n-    };\n-    let fm : @fn(&ast::mac_, Span, @ast_fold) -> (ast::mac_,Span) =\n-        |m, sp, fld| {\n-        match *m {\n-            mac_invoc_tt(ref path, ref tts, ctxt) =>\n-            (mac_invoc_tt(fld.fold_path(path),\n-                          fold_tts(*tts,fld),\n-                          cf.f(ctxt)),\n-            sp)\n-        }\n+pub struct ContextWrapper {\n+    context_function: @CtxtFn,\n+}\n \n-    };\n-    @AstFoldFns{\n-        fold_ident : fi,\n-        fold_mac : fm,\n-        .. *afp\n+impl ast_fold for ContextWrapper {\n+    fn fold_ident(&self, id: ast::Ident) -> ast::Ident {\n+        let ast::Ident {\n+            name,\n+            ctxt\n+        } = id;\n+        ast::Ident {\n+            name: name,\n+            ctxt: self.context_function.f(ctxt),\n+        }\n+    }\n+    fn fold_mac(&self, m: &ast::mac) -> ast::mac {\n+        let macro = match m.node {\n+            mac_invoc_tt(ref path, ref tts, ctxt) => {\n+                mac_invoc_tt(self.fold_path(path),\n+                             fold_tts(*tts, self),\n+                             self.context_function.f(ctxt))\n+            }\n+        };\n+        Spanned {\n+            node: macro,\n+            span: m.span,\n+        }\n     }\n }\n \n-\n-\n-// given a mutable list of renames, return a tree-folder that applies those\n-// renames.\n-// FIXME #4536: currently pub to allow testing\n-pub fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @AstFoldFns {\n-    fun_to_ctxt_folder(@MultiRenamer{renames : renames})\n+// given a function from ctxts to ctxts, produce\n+// an ast_fold that applies that function to all ctxts:\n+pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @ContextWrapper {\n+    @ContextWrapper {\n+        context_function: cf as @CtxtFn,\n+    }\n }\n \n // just a convenience:\n-pub fn new_mark_folder(m : Mrk) -> @AstFoldFns {\n+pub fn new_mark_folder(m: Mrk) -> @ContextWrapper {\n     fun_to_ctxt_folder(@Marker{mark:m})\n }\n \n-pub fn new_rename_folder(from : ast::Ident, to : ast::Name) -> @AstFoldFns {\n+pub fn new_rename_folder(from: ast::Ident, to: ast::Name) -> @ContextWrapper {\n     fun_to_ctxt_folder(@Renamer{from:from,to:to})\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n-    fold_tts(tts,new_mark_folder(m) as @ast_fold)\n+    fold_tts(tts,new_mark_folder(m))\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n@@ -1359,7 +1524,7 @@ mod test {\n         let ident_str = @\"x\";\n         let tts = string_to_tts(ident_str);\n         let fm = fresh_mark();\n-        let marked_once = fold::fold_tts(tts,new_mark_folder(fm) as @fold::ast_fold);\n+        let marked_once = fold::fold_tts(tts,new_mark_folder(fm));\n         assert_eq!(marked_once.len(),1);\n         let marked_once_ctxt =\n             match marked_once[0] {"}, {"sha": "d48fa03c0ef258fbeb4ddf6142d7578c57da76b9", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -38,7 +38,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     fn parse_fmt_err_(cx: @ExtCtxt, sp: Span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n-    let parse_fmt_err: @fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n+    let parse_fmt_err: &fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n     let pieces = parse_fmt_string(fmt, parse_fmt_err);\n     MRExpr(pieces_to_expr(cx, sp, pieces, args))\n }"}, {"sha": "3fd394b3652a3674483ffd14ff1e6e3629a67541", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 125, "deletions": 16, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,9 +12,9 @@ use ast::{Ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n use codemap::{Span, Spanned, dummy_sp};\n-use ext::base::{ExtCtxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n+use ext::base::{AnyMacro, ExtCtxt, MacResult, MRAny, MRDef, MacroDef};\n+use ext::base::{NormalTT, SyntaxExpanderTTTrait};\n use ext::base;\n-use ext::expand;\n use ext::tt::macro_parser::{error};\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else, success, failure};\n@@ -24,17 +24,121 @@ use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_st\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n+struct ParserAnyMacro {\n+    parser: @Parser,\n+}\n+\n+impl AnyMacro for ParserAnyMacro {\n+    fn make_expr(&self) -> @ast::Expr {\n+        self.parser.parse_expr()\n+    }\n+    fn make_item(&self) -> Option<@ast::item> {\n+        self.parser.parse_item(~[])     // no attrs\n+    }\n+    fn make_stmt(&self) -> @ast::Stmt {\n+        self.parser.parse_stmt(~[])     // no attrs\n+    }\n+}\n+\n+struct MacroRulesSyntaxExpanderTTFun {\n+    name: Ident,\n+    lhses: @~[@named_match],\n+    rhses: @~[@named_match],\n+}\n+\n+impl SyntaxExpanderTTTrait for MacroRulesSyntaxExpanderTTFun {\n+    fn expand(&self,\n+              cx: @ExtCtxt,\n+              sp: Span,\n+              arg: &[ast::token_tree],\n+              _: ast::SyntaxContext)\n+              -> MacResult {\n+        generic_extension(cx, sp, self.name, arg, *self.lhses, *self.rhses)\n+    }\n+}\n+\n+// Given `lhses` and `rhses`, this is the new macro we create\n+fn generic_extension(cx: @ExtCtxt,\n+                     sp: Span,\n+                     name: Ident,\n+                     arg: &[ast::token_tree],\n+                     lhses: &[@named_match],\n+                     rhses: &[@named_match])\n+                     -> MacResult {\n+    if cx.trace_macros() {\n+        printfln!(\"%s! { %s }\",\n+                  cx.str_of(name),\n+                  print::pprust::tt_to_str(\n+                      &ast::tt_delim(@mut arg.to_owned()),\n+                      get_ident_interner()));\n+    }\n+\n+    // Which arm's failure should we report? (the one furthest along)\n+    let mut best_fail_spot = dummy_sp();\n+    let mut best_fail_msg = ~\"internal error: ran no matchers\";\n+\n+    let s_d = cx.parse_sess().span_diagnostic;\n+\n+    for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n+        match *lhs {\n+          @matched_nonterminal(nt_matchers(ref mtcs)) => {\n+            // `none` is because we're not interpolating\n+            let arg_rdr = new_tt_reader(\n+                s_d,\n+                None,\n+                arg.to_owned()\n+            ) as @mut reader;\n+            match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n+              success(named_matches) => {\n+                let rhs = match rhses[i] {\n+                    // okay, what's your transcriber?\n+                    @matched_nonterminal(nt_tt(@ref tt)) => {\n+                        match (*tt) {\n+                            // cut off delimiters; don't parse 'em\n+                            tt_delim(ref tts) => {\n+                                (*tts).slice(1u,(*tts).len()-1u).to_owned()\n+                            }\n+                            _ => cx.span_fatal(\n+                                sp, \"macro rhs must be delimited\")\n+                        }\n+                    },\n+                    _ => cx.span_bug(sp, \"bad thing in rhs\")\n+                };\n+                // rhs has holes ( `$id` and `$(...)` that need filled)\n+                let trncbr = new_tt_reader(s_d, Some(named_matches),\n+                                           rhs);\n+                let p = @Parser(cx.parse_sess(),\n+                                cx.cfg(),\n+                                trncbr as @mut reader);\n+\n+                // Let the context choose how to interpret the result.\n+                // Weird, but useful for X-macros.\n+                return MRAny(@ParserAnyMacro {\n+                    parser: p,\n+                } as @AnyMacro)\n+              }\n+              failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n+                best_fail_spot = sp;\n+                best_fail_msg = (*msg).clone();\n+              },\n+              error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n+            }\n+          }\n+          _ => cx.bug(\"non-matcher found in parsed lhses\")\n+        }\n+    }\n+    cx.span_fatal(best_fail_spot, best_fail_msg);\n+}\n+\n // this procedure performs the expansion of the\n // macro_rules! macro. It parses the RHS and adds\n // an extension to the current context.\n pub fn add_new_extension(cx: @ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n                          arg: ~[ast::token_tree],\n-                         stx_ctxt: ast::SyntaxContext)\n-                      -> base::MacResult {\n-    let arg = expand::mtwt_cancel_outer_mark(arg,stx_ctxt);\n-    // Wrap a matcher_ in a spanned to produce a matcher.\n+                         _: ast::SyntaxContext)\n+                         -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n         Spanned {\n@@ -82,11 +186,13 @@ pub fn add_new_extension(cx: @ExtCtxt,\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: @ExtCtxt, sp: Span, name: Ident,\n+    fn generic_extension(cx: @ExtCtxt,\n+                         sp: Span,\n+                         name: Ident,\n                          arg: &[ast::token_tree],\n-                         lhses: &[@named_match], rhses: &[@named_match])\n-    -> MacResult {\n-\n+                         lhses: &[@named_match],\n+                         rhses: &[@named_match])\n+                         -> MacResult {\n         if cx.trace_macros() {\n             printfln!(\"%s! { %s }\",\n                       cx.str_of(name),\n@@ -135,9 +241,9 @@ pub fn add_new_extension(cx: @ExtCtxt,\n \n                     // Let the context choose how to interpret the result.\n                     // Weird, but useful for X-macros.\n-                    return MRAny(|| p.parse_expr(),\n-                                  || p.parse_item(~[/* no attrs*/]),\n-                                  || p.parse_stmt(~[/* no attrs*/]));\n+                    return MRAny(@ParserAnyMacro {\n+                        parser: p\n+                    } as @AnyMacro);\n                   }\n                   failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                     best_fail_spot = sp;\n@@ -152,10 +258,13 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(@ExtCtxt, Span, &[ast::token_tree], ctxt: ast::SyntaxContext) -> MacResult =\n-        |cx, sp, arg, _ctxt| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n+    let exp = @MacroRulesSyntaxExpanderTTFun {\n+        name: name,\n+        lhses: lhses,\n+        rhses: rhses,\n+    } as @SyntaxExpanderTTTrait;\n \n-    return MRDef(MacroDef{\n+    return MRDef(MacroDef {\n         name: ident_to_str(&name),\n         ext: NormalTT(exp, Some(sp))\n     });"}, {"sha": "a25f267c45891832cc18a25d12a725607ba25fe6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 629, "deletions": 826, "changes": 1455, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -14,227 +14,434 @@ use codemap::{Span, Spanned};\n use parse::token;\n use opt_vec::OptVec;\n \n-// this file defines an ast_fold trait for objects that can perform\n-// a \"fold\" on Rust ASTs. It also contains a structure that implements\n-// that trait, and a \"default_fold\" whose fields contain closures\n-// that perform \"default traversals\", visiting all of the sub-elements\n-// and re-assembling the result. The \"fun_to_ident_folder\" in the\n-// test module provides a simple example of creating a very simple\n-// fold that only looks at identifiers.\n-\n+// We may eventually want to be able to fold over type parameters, too.\n pub trait ast_fold {\n-    fn fold_crate(@self, &Crate) -> Crate;\n-    fn fold_view_item(@self, &view_item) -> view_item;\n-    fn fold_foreign_item(@self, @foreign_item) -> @foreign_item;\n-    fn fold_item(@self, @item) -> Option<@item>;\n-    fn fold_struct_field(@self, @struct_field) -> @struct_field;\n-    fn fold_item_underscore(@self, &item_) -> item_;\n-    fn fold_type_method(@self, m: &TypeMethod) -> TypeMethod;\n-    fn fold_method(@self, @method) -> @method;\n-    fn fold_block(@self, &Block) -> Block;\n-    fn fold_stmt(@self, &Stmt) -> Option<@Stmt>;\n-    fn fold_arm(@self, &Arm) -> Arm;\n-    fn fold_pat(@self, @Pat) -> @Pat;\n-    fn fold_decl(@self, @Decl) -> Option<@Decl>;\n-    fn fold_expr(@self, @Expr) -> @Expr;\n-    fn fold_ty(@self, &Ty) -> Ty;\n-    fn fold_mod(@self, &_mod) -> _mod;\n-    fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n-    fn fold_variant(@self, &variant) -> variant;\n-    fn fold_ident(@self, Ident) -> Ident;\n-    fn fold_path(@self, &Path) -> Path;\n-    fn fold_local(@self, @Local) -> @Local;\n-    fn fold_mac(@self, &mac) -> mac;\n-    fn map_exprs(@self, @fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr];\n-    fn new_id(@self, NodeId) -> NodeId;\n-    fn new_span(@self, Span) -> Span;\n-\n-    // New style, using default methods:\n-\n-    fn fold_variant_arg(@self, va: &variant_arg) -> variant_arg {\n-        variant_arg {\n-            ty: self.fold_ty(&va.ty),\n-            id: self.new_id(va.id)\n-        }\n-    }\n-\n-    fn fold_spanned<T>(@self, s: &Spanned<T>, f: &fn(&T) -> T) -> Spanned<T> {\n-        Spanned {\n-            node: f(&s.node),\n-            span: self.new_span(s.span)\n-        }\n+    fn fold_crate(&self, c: &Crate) -> Crate {\n+        noop_fold_crate(c, self)\n     }\n \n-    fn fold_view_path(@self, vp: &view_path) -> view_path {\n-        self.fold_spanned(vp, |v| self.fold_view_path_(v))\n+    fn fold_meta_items(&self, meta_items: &[@MetaItem]) -> ~[@MetaItem] {\n+        meta_items.map(|x| fold_meta_item_(*x, self))\n     }\n \n-    fn fold_view_paths(@self, vps: &[@view_path]) -> ~[@view_path] {\n-        vps.map(|vp| @self.fold_view_path(*vp))\n+    fn fold_view_paths(&self, view_paths: &[@view_path]) -> ~[@view_path] {\n+        view_paths.map(|view_path| {\n+            let inner_view_path = match view_path.node {\n+                view_path_simple(ref ident, ref path, node_id) => {\n+                    view_path_simple(ident.clone(),\n+                                     self.fold_path(path),\n+                                     self.new_id(node_id))\n+                }\n+                view_path_glob(ref path, node_id) => {\n+                    view_path_glob(self.fold_path(path), self.new_id(node_id))\n+                }\n+                view_path_list(ref path, ref path_list_idents, node_id) => {\n+                    view_path_list(self.fold_path(path),\n+                                   path_list_idents.map(|path_list_ident| {\n+                                    let id = self.new_id(path_list_ident.node\n+                                                                        .id);\n+                                    Spanned {\n+                                        node: path_list_ident_ {\n+                                            name: path_list_ident.node\n+                                                                 .name\n+                                                                 .clone(),\n+                                            id: id,\n+                                        },\n+                                        span: self.new_span(\n+                                            path_list_ident.span)\n+                                   }\n+                                  }),\n+                                  self.new_id(node_id))\n+                }\n+            };\n+            @Spanned {\n+                node: inner_view_path,\n+                span: self.new_span(view_path.span),\n+            }\n+        })\n     }\n \n-    fn fold_view_path_(@self, vp: &view_path_) -> view_path_ {\n-        match *vp {\n-            view_path_simple(ident, ref path, node_id) => {\n-                view_path_simple(self.fold_ident(ident),\n-                                 self.fold_path(path),\n-                                 self.new_id(node_id))\n-            }\n-            view_path_glob(ref path, node_id) => {\n-                view_path_glob(self.fold_path(path),\n-                               self.new_id(node_id))\n+    fn fold_view_item(&self, vi: &view_item) -> view_item {\n+        let inner_view_item = match vi.node {\n+            view_item_extern_mod(ref ident,\n+                                 string,\n+                                 ref meta_items,\n+                                 node_id) => {\n+                view_item_extern_mod(ident.clone(),\n+                                     string,\n+                                     self.fold_meta_items(*meta_items),\n+                                     self.new_id(node_id))\n             }\n-            view_path_list(ref path, ref idents, node_id) => {\n-                view_path_list(self.fold_path(path),\n-                               self.fold_path_list_idents(*idents),\n-                               self.new_id(node_id))\n+            view_item_use(ref view_paths) => {\n+                view_item_use(self.fold_view_paths(*view_paths))\n             }\n+        };\n+        view_item {\n+            node: inner_view_item,\n+            attrs: vi.attrs.map(|a| fold_attribute_(*a, self)),\n+            vis: vi.vis,\n+            span: self.new_span(vi.span),\n+        }\n+    }\n+\n+    fn fold_foreign_item(&self, ni: @foreign_item) -> @foreign_item {\n+        let fold_attribute = |x| fold_attribute_(x, self);\n+\n+        @ast::foreign_item {\n+            ident: self.fold_ident(ni.ident),\n+            attrs: ni.attrs.map(|x| fold_attribute(*x)),\n+            node:\n+                match ni.node {\n+                    foreign_item_fn(ref fdec, ref generics) => {\n+                        foreign_item_fn(\n+                            ast::fn_decl {\n+                                inputs: fdec.inputs.map(|a| fold_arg_(a,\n+                                                                      self)),\n+                                output: self.fold_ty(&fdec.output),\n+                                cf: fdec.cf,\n+                            },\n+                            fold_generics(generics, self))\n+                    }\n+                    foreign_item_static(ref t, m) => {\n+                        foreign_item_static(self.fold_ty(t), m)\n+                    }\n+                },\n+            id: self.new_id(ni.id),\n+            span: self.new_span(ni.span),\n+            vis: ni.vis,\n         }\n     }\n \n-    fn fold_path_list_idents(@self, idents: &[path_list_ident]) -> ~[path_list_ident] {\n-        idents.map(|i| self.fold_path_list_ident(i))\n+    fn fold_item(&self, i: @item) -> Option<@item> {\n+        noop_fold_item(i, self)\n     }\n \n-    fn fold_path_list_ident(@self, ident: &path_list_ident) -> path_list_ident {\n-        self.fold_spanned(ident, |i| self.fold_path_list_ident_(i))\n-    }\n+    fn fold_struct_field(&self, sf: @struct_field) -> @struct_field {\n+        let fold_attribute = |x| fold_attribute_(x, self);\n \n-    fn fold_path_list_ident_(@self, ident: &path_list_ident_) -> path_list_ident_ {\n-        path_list_ident_ {\n-            name: self.fold_ident(ident.name),\n-            id: self.new_id(ident.id)\n+        @Spanned {\n+            node: ast::struct_field_ {\n+                kind: sf.node.kind,\n+                id: self.new_id(sf.node.id),\n+                ty: self.fold_ty(&sf.node.ty),\n+                attrs: sf.node.attrs.map(|e| fold_attribute(*e))\n+            },\n+            span: self.new_span(sf.span)\n         }\n     }\n \n-    fn fold_arg(@self, a: &arg) -> arg {\n-        arg {\n-            is_mutbl: a.is_mutbl,\n-            ty: self.fold_ty(&a.ty),\n-            pat: self.fold_pat(a.pat),\n-            id: self.new_id(a.id),\n+    fn fold_item_underscore(&self, i: &item_) -> item_ {\n+        noop_fold_item_underscore(i, self)\n+    }\n+\n+    fn fold_type_method(&self, m: &TypeMethod) -> TypeMethod {\n+        noop_fold_type_method(m, self)\n+    }\n+\n+    fn fold_method(&self, m: @method) -> @method {\n+        @ast::method {\n+            ident: self.fold_ident(m.ident),\n+            attrs: m.attrs.map(|a| fold_attribute_(*a, self)),\n+            generics: fold_generics(&m.generics, self),\n+            explicit_self: m.explicit_self,\n+            purity: m.purity,\n+            decl: fold_fn_decl(&m.decl, self),\n+            body: self.fold_block(&m.body),\n+            id: self.new_id(m.id),\n+            span: self.new_span(m.span),\n+            self_id: self.new_id(m.self_id),\n+            vis: m.vis,\n         }\n     }\n \n-    fn fold_trait_ref(@self, p: &trait_ref) -> trait_ref {\n-        trait_ref {\n-            path: self.fold_path(&p.path),\n-            ref_id: self.new_id(p.ref_id),\n+    fn fold_block(&self, b: &Block) -> Block {\n+        noop_fold_block(b, self)\n+    }\n+\n+    fn fold_stmt(&self, s: &Stmt) -> Option<@Stmt> {\n+        noop_fold_stmt(s, self)\n+    }\n+\n+    fn fold_arm(&self, a: &Arm) -> Arm {\n+        Arm {\n+            pats: a.pats.map(|x| self.fold_pat(*x)),\n+            guard: a.guard.map_move(|x| self.fold_expr(x)),\n+            body: self.fold_block(&a.body),\n         }\n     }\n \n-    fn fold_ty_param_bound(@self, tpb: &TyParamBound) -> TyParamBound {\n-        match *tpb {\n-            TraitTyParamBound(ref ty) => {\n-                TraitTyParamBound(self.fold_trait_ref(ty))\n+    fn fold_pat(&self, p: @Pat) -> @Pat {\n+        let node = match p.node {\n+            PatWild => PatWild,\n+            PatIdent(binding_mode, ref pth, ref sub) => {\n+                PatIdent(binding_mode,\n+                         self.fold_path(pth),\n+                         sub.map_move(|x| self.fold_pat(x)))\n+            }\n+            PatLit(e) => PatLit(self.fold_expr(e)),\n+            PatEnum(ref pth, ref pats) => {\n+                PatEnum(self.fold_path(pth),\n+                        pats.map(|pats| pats.map(|x| self.fold_pat(*x))))\n             }\n-            RegionTyParamBound => {\n-                RegionTyParamBound\n+            PatStruct(ref pth, ref fields, etc) => {\n+                let pth_ = self.fold_path(pth);\n+                let fs = do fields.map |f| {\n+                    ast::FieldPat {\n+                        ident: f.ident,\n+                        pat: self.fold_pat(f.pat)\n+                    }\n+                };\n+                PatStruct(pth_, fs, etc)\n             }\n+            PatTup(ref elts) => PatTup(elts.map(|x| self.fold_pat(*x))),\n+            PatBox(inner) => PatBox(self.fold_pat(inner)),\n+            PatUniq(inner) => PatUniq(self.fold_pat(inner)),\n+            PatRegion(inner) => PatRegion(self.fold_pat(inner)),\n+            PatRange(e1, e2) => {\n+                PatRange(self.fold_expr(e1), self.fold_expr(e2))\n+            },\n+            PatVec(ref before, ref slice, ref after) => {\n+                PatVec(before.map(|x| self.fold_pat(*x)),\n+                       slice.map_move(|x| self.fold_pat(x)),\n+                       after.map(|x| self.fold_pat(*x)))\n+            }\n+        };\n+\n+        @Pat {\n+            id: self.new_id(p.id),\n+            span: self.new_span(p.span),\n+            node: node,\n         }\n     }\n \n-    fn fold_ty_param(@self, tp: &TyParam) -> TyParam {\n-        TyParam {\n-            ident: self.fold_ident(tp.ident),\n-            id: self.new_id(tp.id),\n-            bounds: tp.bounds.map(|x| self.fold_ty_param_bound(x))\n+    fn fold_decl(&self, d: @Decl) -> Option<@Decl> {\n+        let node = match d.node {\n+            DeclLocal(ref l) => Some(DeclLocal(self.fold_local(*l))),\n+            DeclItem(it) => {\n+                match self.fold_item(it) {\n+                    Some(it_folded) => Some(DeclItem(it_folded)),\n+                    None => None,\n+                }\n+            }\n+        };\n+\n+        node.map_move(|node| {\n+            @Spanned {\n+                node: node,\n+                span: d.span,\n+            }\n+        })\n+    }\n+\n+    fn fold_expr(&self, e: @Expr) -> @Expr {\n+        noop_fold_expr(e, self)\n+    }\n+\n+    fn fold_ty(&self, t: &Ty) -> Ty {\n+        let node = match t.node {\n+            ty_nil | ty_bot | ty_infer => t.node.clone(),\n+            ty_box(ref mt) => ty_box(fold_mt(mt, self)),\n+            ty_uniq(ref mt) => ty_uniq(fold_mt(mt, self)),\n+            ty_vec(ref mt) => ty_vec(fold_mt(mt, self)),\n+            ty_ptr(ref mt) => ty_ptr(fold_mt(mt, self)),\n+            ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, self)),\n+            ty_closure(ref f) => {\n+                ty_closure(@TyClosure {\n+                    sigil: f.sigil,\n+                    purity: f.purity,\n+                    region: f.region,\n+                    onceness: f.onceness,\n+                    bounds: fold_opt_bounds(&f.bounds, self),\n+                    decl: fold_fn_decl(&f.decl, self),\n+                    lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n+                })\n+            }\n+            ty_bare_fn(ref f) => {\n+                ty_bare_fn(@TyBareFn {\n+                    lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n+                    purity: f.purity,\n+                    abis: f.abis,\n+                    decl: fold_fn_decl(&f.decl, self)\n+                })\n+            }\n+            ty_tup(ref tys) => ty_tup(tys.map(|ty| self.fold_ty(ty))),\n+            ty_path(ref path, ref bounds, id) => {\n+                ty_path(self.fold_path(path),\n+                        fold_opt_bounds(bounds, self),\n+                        self.new_id(id))\n+            }\n+            ty_fixed_length_vec(ref mt, e) => {\n+                ty_fixed_length_vec(fold_mt(mt, self), self.fold_expr(e))\n+            }\n+            ty_mac(ref mac) => ty_mac(self.fold_mac(mac)),\n+            ty_typeof(expr) => ty_typeof(self.fold_expr(expr)),\n+        };\n+        Ty {\n+            id: self.new_id(t.id),\n+            span: self.new_span(t.span),\n+            node: node,\n         }\n     }\n \n-    fn fold_ty_params(@self, tps: &OptVec<TyParam>) -> OptVec<TyParam> {\n-        tps.map(|tp| self.fold_ty_param(tp))\n+    fn fold_mod(&self, m: &_mod) -> _mod {\n+        noop_fold_mod(m, self)\n     }\n \n-    fn fold_lifetime(@self, l: &Lifetime) -> Lifetime {\n-        Lifetime {\n-            id: self.new_id(l.id),\n-            span: self.new_span(l.span),\n-            ident: l.ident, // Folding this ident causes hygiene errors - ndm\n+    fn fold_foreign_mod(&self, nm: &foreign_mod) -> foreign_mod {\n+        ast::foreign_mod {\n+            sort: nm.sort,\n+            abis: nm.abis,\n+            view_items: nm.view_items\n+                          .iter()\n+                          .map(|x| self.fold_view_item(x))\n+                          .collect(),\n+            items: nm.items\n+                     .iter()\n+                     .map(|x| self.fold_foreign_item(*x))\n+                     .collect(),\n         }\n     }\n \n-    fn fold_lifetimes(@self, lts: &OptVec<Lifetime>) -> OptVec<Lifetime> {\n-        lts.map(|l| self.fold_lifetime(l))\n+    fn fold_variant(&self, v: &variant) -> variant {\n+        let kind;\n+        match v.node.kind {\n+            tuple_variant_kind(ref variant_args) => {\n+                kind = tuple_variant_kind(variant_args.map(|x|\n+                    fold_variant_arg_(x, self)))\n+            }\n+            struct_variant_kind(ref struct_def) => {\n+                kind = struct_variant_kind(@ast::struct_def {\n+                    fields: struct_def.fields.iter()\n+                        .map(|f| self.fold_struct_field(*f)).collect(),\n+                    ctor_id: struct_def.ctor_id.map(|c| self.new_id(*c))\n+                })\n+            }\n+        }\n+\n+        let fold_attribute = |x| fold_attribute_(x, self);\n+        let attrs = v.node.attrs.map(|x| fold_attribute(*x));\n+\n+        let de = match v.node.disr_expr {\n+          Some(e) => Some(self.fold_expr(e)),\n+          None => None\n+        };\n+        let node = ast::variant_ {\n+            name: v.node.name,\n+            attrs: attrs,\n+            kind: kind,\n+            id: self.new_id(v.node.id),\n+            disr_expr: de,\n+            vis: v.node.vis,\n+        };\n+        Spanned {\n+            node: node,\n+            span: self.new_span(v.span),\n+        }\n     }\n \n+    fn fold_ident(&self, i: Ident) -> Ident {\n+        i\n+    }\n \n-    fn fold_meta_item(@self, mi: &MetaItem) -> @MetaItem {\n-        @self.fold_spanned(mi, |n| match *n {\n-                MetaWord(id) => {\n-                    MetaWord(id)\n-                }\n-                MetaList(id, ref mis) => {\n-                    MetaList(id, self.fold_meta_items(*mis))\n-                }\n-                MetaNameValue(id, s) => {\n-                    MetaNameValue(id, s)\n-                }\n+    fn fold_path(&self, p: &Path) -> Path {\n+        ast::Path {\n+            span: self.new_span(p.span),\n+            global: p.global,\n+            segments: p.segments.map(|segment| ast::PathSegment {\n+                identifier: self.fold_ident(segment.identifier),\n+                lifetime: segment.lifetime,\n+                types: segment.types.map(|typ| self.fold_ty(typ)),\n             })\n+        }\n     }\n \n-    fn fold_meta_items(@self, mis: &[@MetaItem]) -> ~[@MetaItem] {\n-        mis.map(|&mi| self.fold_meta_item(mi))\n+    fn fold_local(&self, l: @Local) -> @Local {\n+        @Local {\n+            is_mutbl: l.is_mutbl,\n+            ty: self.fold_ty(&l.ty),\n+            pat: self.fold_pat(l.pat),\n+            init: l.init.map_move(|e| self.fold_expr(e)),\n+            id: self.new_id(l.id),\n+            span: self.new_span(l.span),\n+        }\n     }\n \n-    fn fold_attribute(@self, at: &Attribute) -> Attribute {\n+    fn fold_mac(&self, macro: &mac) -> mac {\n         Spanned {\n-            span: self.new_span(at.span),\n-            node: Attribute_ {\n-                style: at.node.style,\n-                value: self.fold_meta_item(at.node.value),\n-                is_sugared_doc: at.node.is_sugared_doc\n-            }\n+            node: match macro.node {\n+                mac_invoc_tt(ref p, ref tts, ctxt) => {\n+                    mac_invoc_tt(self.fold_path(p),\n+                                 fold_tts(*tts, self),\n+                                 ctxt)\n+                }\n+            },\n+            span: self.new_span(macro.span)\n         }\n     }\n \n-    fn fold_attributes(@self, attrs: &[Attribute]) -> ~[Attribute] {\n-        attrs.map(|x| self.fold_attribute(x))\n+    fn map_exprs(&self, f: &fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n+        es.map(|x| f(*x))\n+    }\n+\n+    fn new_id(&self, i: NodeId) -> NodeId {\n+        i\n+    }\n+\n+    fn new_span(&self, sp: Span) -> Span {\n+        sp\n     }\n }\n \n-// We may eventually want to be able to fold over type parameters, too\n-\n-pub struct AstFoldFns {\n-    //unlike the others, item_ is non-trivial\n-    fold_crate: @fn(&Crate, @ast_fold) -> Crate,\n-    fold_view_item: @fn(&view_item_, @ast_fold) -> view_item_,\n-    fold_foreign_item: @fn(@foreign_item, @ast_fold) -> @foreign_item,\n-    fold_item: @fn(@item, @ast_fold) -> Option<@item>,\n-    fold_struct_field: @fn(@struct_field, @ast_fold) -> @struct_field,\n-    fold_item_underscore: @fn(&item_, @ast_fold) -> item_,\n-    fold_type_method: @fn(&TypeMethod, @ast_fold) -> TypeMethod,\n-    fold_method: @fn(@method, @ast_fold) -> @method,\n-    fold_block: @fn(&Block, @ast_fold) -> Block,\n-    fold_stmt: @fn(&Stmt_, Span, @ast_fold) -> (Option<Stmt_>, Span),\n-    fold_arm: @fn(&Arm, @ast_fold) -> Arm,\n-    fold_pat: @fn(&Pat_, Span, @ast_fold) -> (Pat_, Span),\n-    fold_decl: @fn(&Decl_, Span, @ast_fold) -> (Option<Decl_>, Span),\n-    fold_expr: @fn(&Expr_, Span, @ast_fold) -> (Expr_, Span),\n-    fold_ty: @fn(&ty_, Span, @ast_fold) -> (ty_, Span),\n-    fold_mod: @fn(&_mod, @ast_fold) -> _mod,\n-    fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n-    fold_variant: @fn(&variant_, Span, @ast_fold) -> (variant_, Span),\n-    fold_ident: @fn(Ident, @ast_fold) -> Ident,\n-    fold_path: @fn(&Path, @ast_fold) -> Path,\n-    fold_local: @fn(@Local, @ast_fold) -> @Local,\n-    fold_mac: @fn(&mac_, Span, @ast_fold) -> (mac_, Span),\n-    map_exprs: @fn(@fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr],\n-    new_id: @fn(NodeId) -> NodeId,\n-    new_span: @fn(Span) -> Span\n+/* some little folds that probably aren't useful to have in ast_fold itself*/\n+\n+//used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n+fn fold_meta_item_<T:ast_fold>(mi: @MetaItem, fld: &T) -> @MetaItem {\n+    @Spanned {\n+        node:\n+            match mi.node {\n+                MetaWord(id) => MetaWord(id),\n+                MetaList(id, ref mis) => {\n+                    let fold_meta_item = |x| fold_meta_item_(x, fld);\n+                    MetaList(\n+                        id,\n+                        mis.map(|e| fold_meta_item(*e))\n+                    )\n+                }\n+                MetaNameValue(id, s) => MetaNameValue(id, s)\n+            },\n+        span: fld.new_span(mi.span) }\n }\n \n-pub type ast_fold_fns = @AstFoldFns;\n+//used in noop_fold_item and noop_fold_crate\n+fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &T) -> Attribute {\n+    Spanned {\n+        span: fld.new_span(at.span),\n+        node: ast::Attribute_ {\n+            style: at.node.style,\n+            value: fold_meta_item_(at.node.value, fld),\n+            is_sugared_doc: at.node.is_sugared_doc\n+        }\n+    }\n+}\n \n-/* some little folds that probably aren't useful to have in ast_fold itself*/\n+//used in noop_fold_foreign_item and noop_fold_fn_decl\n+fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n+    ast::arg {\n+        is_mutbl: a.is_mutbl,\n+        ty: fld.fold_ty(&a.ty),\n+        pat: fld.fold_pat(a.pat),\n+        id: fld.new_id(a.id),\n+    }\n+}\n \n-pub fn fold_tts(tts : &[token_tree], fld: @ast_fold) -> ~[token_tree] {\n+// build a new vector of tts by appling the ast_fold's fold_ident to\n+// all of the identifiers in the token trees.\n+pub fn fold_tts<T:ast_fold>(tts: &[token_tree], fld: &T) -> ~[token_tree] {\n     do tts.map |tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n             tt_tok(span,maybe_fold_ident(tok,fld)),\n-            tt_delim(ref tts) =>\n-            tt_delim(@mut fold_tts(**tts, fld)),\n+            tt_delim(ref tts) => tt_delim(@mut fold_tts(**tts, fld)),\n             tt_seq(span, ref pattern, ref sep, is_optional) =>\n             tt_seq(span,\n                    @mut fold_tts(**pattern, fld),\n@@ -247,33 +454,68 @@ pub fn fold_tts(tts : &[token_tree], fld: @ast_fold) -> ~[token_tree] {\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident(t : &token::Token, f: @ast_fold) -> token::Token {\n+fn maybe_fold_ident<T:ast_fold>(t: &token::Token, fld: &T) -> token::Token {\n     match *t {\n-        token::IDENT(id,followed_by_colons) =>\n-        token::IDENT(f.fold_ident(id),followed_by_colons),\n+        token::IDENT(id, followed_by_colons) => {\n+            token::IDENT(fld.fold_ident(id), followed_by_colons)\n+        }\n         _ => (*t).clone()\n     }\n }\n \n-pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n+pub fn fold_fn_decl<T:ast_fold>(decl: &ast::fn_decl, fld: &T)\n+                                -> ast::fn_decl {\n     ast::fn_decl {\n-        inputs: decl.inputs.map(|x| fld.fold_arg(x)),\n+        inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n         output: fld.fold_ty(&decl.output),\n         cf: decl.cf,\n     }\n }\n \n-pub fn fold_generics(generics: &Generics, fld: @ast_fold) -> Generics {\n-    Generics {ty_params: fld.fold_ty_params(&generics.ty_params),\n-              lifetimes: fld.fold_lifetimes(&generics.lifetimes)}\n+fn fold_ty_param_bound<T:ast_fold>(tpb: &TyParamBound, fld: &T)\n+                                   -> TyParamBound {\n+    match *tpb {\n+        TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n+        RegionTyParamBound => RegionTyParamBound\n+    }\n }\n \n-pub fn noop_fold_crate(c: &Crate, fld: @ast_fold) -> Crate {\n-    Crate {\n-        module: fld.fold_mod(&c.module),\n-        attrs: fld.fold_attributes(c.attrs),\n-        config: fld.fold_meta_items(c.config),\n-        span: fld.new_span(c.span),\n+pub fn fold_ty_param<T:ast_fold>(tp: &TyParam, fld: &T) -> TyParam {\n+    TyParam {\n+        ident: tp.ident,\n+        id: fld.new_id(tp.id),\n+        bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n+    }\n+}\n+\n+pub fn fold_ty_params<T:ast_fold>(tps: &OptVec<TyParam>, fld: &T)\n+                                  -> OptVec<TyParam> {\n+    tps.map(|tp| fold_ty_param(tp, fld))\n+}\n+\n+pub fn fold_lifetime<T:ast_fold>(l: &Lifetime, fld: &T) -> Lifetime {\n+    Lifetime {\n+        id: fld.new_id(l.id),\n+        span: fld.new_span(l.span),\n+        ident: l.ident\n+    }\n+}\n+\n+pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &T)\n+                                  -> OptVec<Lifetime> {\n+    lts.map(|l| fold_lifetime(l, fld))\n+}\n+\n+pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &T) -> Generics {\n+    Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n+              lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n+}\n+\n+fn fold_struct_def<T:ast_fold>(struct_def: @ast::struct_def, fld: &T)\n+                               -> @ast::struct_def {\n+    @ast::struct_def {\n+        fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n+        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(*cid)),\n     }\n }\n \n@@ -291,753 +533,333 @@ fn noop_fold_view_item(vi: &view_item_, fld: @ast_fold) -> view_item_ {\n     }\n }\n \n-fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n-    -> @foreign_item {\n-    @ast::foreign_item {\n-        ident: fld.fold_ident(ni.ident),\n-        attrs: fld.fold_attributes(ni.attrs),\n-        node:\n-            match ni.node {\n-                foreign_item_fn(ref fdec, ref generics) => {\n-                    foreign_item_fn(\n-                        ast::fn_decl {\n-                            inputs: fdec.inputs.map(|a| fld.fold_arg(a)),\n-                            output: fld.fold_ty(&fdec.output),\n-                            cf: fdec.cf,\n-                        },\n-                        fold_generics(generics, fld))\n-                }\n-                foreign_item_static(ref t, m) => {\n-                    foreign_item_static(fld.fold_ty(t), m)\n-                }\n-            },\n-        id: fld.new_id(ni.id),\n-        span: fld.new_span(ni.span),\n-        vis: ni.vis,\n+fn fold_trait_ref<T:ast_fold>(p: &trait_ref, fld: &T) -> trait_ref {\n+    ast::trait_ref {\n+        path: fld.fold_path(&p.path),\n+        ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-pub fn noop_fold_item(i: @item, fld: @ast_fold) -> Option<@item> {\n-    Some(@ast::item { ident: fld.fold_ident(i.ident),\n-                      attrs: fld.fold_attributes(i.attrs),\n-                      id: fld.new_id(i.id),\n-                      node: fld.fold_item_underscore(&i.node),\n-                      vis: i.vis,\n-                      span: fld.new_span(i.span) })\n-}\n-\n-fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n-                       -> @struct_field {\n+fn fold_struct_field<T:ast_fold>(f: @struct_field, fld: &T) -> @struct_field {\n     @Spanned {\n         node: ast::struct_field_ {\n-            kind: sf.node.kind,\n-            id: fld.new_id(sf.node.id),\n-            ty: fld.fold_ty(&sf.node.ty),\n-            attrs: fld.fold_attributes(sf.node.attrs),\n+            kind: f.node.kind,\n+            id: fld.new_id(f.node.id),\n+            ty: fld.fold_ty(&f.node.ty),\n+            attrs: f.node.attrs.map(|a| fold_attribute_(*a, fld)),\n         },\n-        span: sf.span\n+        span: fld.new_span(f.span),\n     }\n }\n \n-pub fn noop_fold_type_method(m: &TypeMethod, fld: @ast_fold) -> TypeMethod {\n-    TypeMethod {\n-        ident: fld.fold_ident(m.ident),\n-        attrs: fld.fold_attributes(m.attrs),\n-        purity: m.purity,\n-        decl: fold_fn_decl(&m.decl, fld),\n-        generics: fold_generics(&m.generics, fld),\n-        explicit_self: m.explicit_self,\n-        id: fld.new_id(m.id),\n-        span: fld.new_span(m.span),\n+fn fold_field_<T:ast_fold>(field: Field, folder: &T) -> Field {\n+    ast::Field {\n+        ident: folder.fold_ident(field.ident),\n+        expr: folder.fold_expr(field.expr),\n+        span: folder.new_span(field.span),\n     }\n }\n \n-pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n+fn fold_mt<T:ast_fold>(mt: &mt, folder: &T) -> mt {\n+    mt {\n+        ty: ~folder.fold_ty(mt.ty),\n+        mutbl: mt.mutbl,\n+    }\n+}\n+\n+fn fold_field<T:ast_fold>(f: TypeField, folder: &T) -> TypeField {\n+    ast::TypeField {\n+        ident: folder.fold_ident(f.ident),\n+        mt: fold_mt(&f.mt, folder),\n+        span: folder.new_span(f.span),\n+    }\n+}\n+\n+fn fold_opt_bounds<T:ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &T)\n+                               -> Option<OptVec<TyParamBound>> {\n+    do b.map |bounds| {\n+        do bounds.map |bound| {\n+            fold_ty_param_bound(bound, folder)\n+        }\n+    }\n+}\n+\n+fn fold_variant_arg_<T:ast_fold>(va: &variant_arg, folder: &T)\n+                                 -> variant_arg {\n+    ast::variant_arg {\n+        ty: folder.fold_ty(&va.ty),\n+        id: folder.new_id(va.id)\n+    }\n+}\n+\n+pub fn noop_fold_block<T:ast_fold>(b: &Block, folder: &T) -> Block {\n+    let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n+    let mut stmts = ~[];\n+    for stmt in b.stmts.iter() {\n+        match folder.fold_stmt(*stmt) {\n+            None => {}\n+            Some(stmt) => stmts.push(stmt)\n+        }\n+    }\n+    ast::Block {\n+        view_items: view_items,\n+        stmts: stmts,\n+        expr: b.expr.map(|x| folder.fold_expr(*x)),\n+        id: folder.new_id(b.id),\n+        rules: b.rules,\n+        span: folder.new_span(b.span),\n+    }\n+}\n+\n+pub fn noop_fold_item_underscore<T:ast_fold>(i: &item_, folder: &T) -> item_ {\n     match *i {\n         item_static(ref t, m, e) => {\n-            item_static(fld.fold_ty(t), m, fld.fold_expr(e))\n+            item_static(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             item_fn(\n-                fold_fn_decl(decl, fld),\n+                fold_fn_decl(decl, folder),\n                 purity,\n                 abi,\n-                fold_generics(generics, fld),\n-                fld.fold_block(body)\n+                fold_generics(generics, folder),\n+                folder.fold_block(body)\n             )\n         }\n-        item_mod(ref m) => {\n-            item_mod(fld.fold_mod(m))\n-        }\n+        item_mod(ref m) => item_mod(folder.fold_mod(m)),\n         item_foreign_mod(ref nm) => {\n-            item_foreign_mod(fld.fold_foreign_mod(nm))\n+            item_foreign_mod(folder.fold_foreign_mod(nm))\n         }\n         item_ty(ref t, ref generics) => {\n-            item_ty(fld.fold_ty(t), fold_generics(generics, fld))\n+            item_ty(folder.fold_ty(t),\n+                    fold_generics(generics, folder))\n         }\n         item_enum(ref enum_definition, ref generics) => {\n             item_enum(\n                 ast::enum_def {\n                     variants: do enum_definition.variants.map |x| {\n-                        fld.fold_variant(x)\n+                        folder.fold_variant(x)\n                     },\n                 },\n-                fold_generics(generics, fld))\n+                fold_generics(generics, folder))\n         }\n         item_struct(ref struct_def, ref generics) => {\n-            let struct_def = fold_struct_def(*struct_def, fld);\n-            item_struct(struct_def, fold_generics(generics, fld))\n+            let struct_def = fold_struct_def(*struct_def, folder);\n+            item_struct(struct_def, fold_generics(generics, folder))\n         }\n         item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n-            item_impl(\n-                fold_generics(generics, fld),\n-                ifce.map(|p| fld.fold_trait_ref(p)),\n-                fld.fold_ty(ty),\n-                methods.map(|x| fld.fold_method(*x))\n+            item_impl(fold_generics(generics, folder),\n+                      ifce.map(|p| fold_trait_ref(p, folder)),\n+                      folder.fold_ty(ty),\n+                      methods.map(|x| folder.fold_method(*x))\n             )\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             let methods = do methods.map |method| {\n                 match *method {\n-                    required(ref m) => required(fld.fold_type_method(m)),\n-                    provided(method) => provided(fld.fold_method(method))\n+                    required(ref m) => required(folder.fold_type_method(m)),\n+                    provided(method) => provided(folder.fold_method(method))\n                 }\n             };\n-            item_trait(\n-                fold_generics(generics, fld),\n-                traits.map(|p| fld.fold_trait_ref(p)),\n-                methods\n-            )\n-        }\n-        item_mac(ref m) => {\n-            item_mac(fld.fold_mac(m))\n+            item_trait(fold_generics(generics, folder),\n+                       traits.map(|p| fold_trait_ref(p, folder)),\n+                       methods)\n         }\n+        item_mac(ref m) => item_mac(folder.fold_mac(m)),\n     }\n }\n \n-fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n-                -> @ast::struct_def {\n-    @ast::struct_def {\n-        fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n-        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(*cid)),\n-    }\n-}\n-\n-fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n-    @Spanned {\n-        node: ast::struct_field_ {\n-            kind: f.node.kind,\n-            id: fld.new_id(f.node.id),\n-            ty: fld.fold_ty(&f.node.ty),\n-            attrs: fld.fold_attributes(f.node.attrs),\n-        },\n-        span: fld.new_span(f.span),\n-    }\n-}\n-\n-fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n-    @ast::method {\n+pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n+                                         -> TypeMethod {\n+    TypeMethod {\n         ident: fld.fold_ident(m.ident),\n-        attrs: fld.fold_attributes(m.attrs),\n-        generics: fold_generics(&m.generics, fld),\n-        explicit_self: m.explicit_self,\n+        attrs: m.attrs.map(|a| fold_attribute_(*a, fld)),\n         purity: m.purity,\n         decl: fold_fn_decl(&m.decl, fld),\n-        body: fld.fold_block(&m.body),\n+        generics: fold_generics(&m.generics, fld),\n+        explicit_self: m.explicit_self,\n         id: fld.new_id(m.id),\n         span: fld.new_span(m.span),\n-        self_id: fld.new_id(m.self_id),\n-        vis: m.vis,\n-    }\n-}\n-\n-\n-pub fn noop_fold_block(b: &Block, fld: @ast_fold) -> Block {\n-    let view_items = b.view_items.map(|x| fld.fold_view_item(x));\n-    let mut stmts = ~[];\n-    for stmt in b.stmts.iter() {\n-        match fld.fold_stmt(*stmt) {\n-            None => {}\n-            Some(stmt) => stmts.push(stmt)\n-        }\n-    }\n-    ast::Block {\n-        view_items: view_items,\n-        stmts: stmts,\n-        expr: b.expr.map(|x| fld.fold_expr(*x)),\n-        id: fld.new_id(b.id),\n-        rules: b.rules,\n-        span: b.span,\n     }\n }\n \n-fn noop_fold_stmt(s: &Stmt_, fld: @ast_fold) -> Option<Stmt_> {\n-    match *s {\n-        StmtDecl(d, nid) => {\n-            match fld.fold_decl(d) {\n-                Some(d) => Some(StmtDecl(d, fld.new_id(nid))),\n-                None => None,\n-            }\n-        }\n-        StmtExpr(e, nid) => {\n-            Some(StmtExpr(fld.fold_expr(e), fld.new_id(nid)))\n-        }\n-        StmtSemi(e, nid) => {\n-            Some(StmtSemi(fld.fold_expr(e), fld.new_id(nid)))\n-        }\n-        StmtMac(ref mac, semi) => Some(StmtMac(fld.fold_mac(mac), semi))\n+pub fn noop_fold_mod<T:ast_fold>(m: &_mod, folder: &T) -> _mod {\n+    ast::_mod {\n+        view_items: m.view_items\n+                     .iter()\n+                     .map(|x| folder.fold_view_item(x)).collect(),\n+        items: m.items.iter().filter_map(|x| folder.fold_item(*x)).collect(),\n     }\n }\n \n-fn noop_fold_arm(a: &Arm, fld: @ast_fold) -> Arm {\n-    Arm {\n-        pats: a.pats.map(|x| fld.fold_pat(*x)),\n-        guard: a.guard.map_move(|x| fld.fold_expr(x)),\n-        body: fld.fold_block(&a.body),\n-    }\n-}\n+pub fn noop_fold_crate<T:ast_fold>(c: &Crate, folder: &T) -> Crate {\n+    let fold_meta_item = |x| fold_meta_item_(x, folder);\n+    let fold_attribute = |x| fold_attribute_(x, folder);\n \n-pub fn noop_fold_pat(p: &Pat_, fld: @ast_fold) -> Pat_ {\n-    match *p {\n-        PatWild => PatWild,\n-        PatIdent(binding_mode, ref pth, ref sub) => {\n-            PatIdent(\n-                binding_mode,\n-                fld.fold_path(pth),\n-                sub.map_move(|x| fld.fold_pat(x))\n-            )\n-        }\n-        PatLit(e) => PatLit(fld.fold_expr(e)),\n-        PatEnum(ref pth, ref pats) => {\n-            PatEnum(\n-                fld.fold_path(pth),\n-                pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n-            )\n-        }\n-        PatStruct(ref pth, ref fields, etc) => {\n-            let pth_ = fld.fold_path(pth);\n-            let fs = do fields.map |f| {\n-                ast::FieldPat {\n-                    ident: f.ident,\n-                    pat: fld.fold_pat(f.pat)\n-                }\n-            };\n-            PatStruct(pth_, fs, etc)\n-        }\n-        PatTup(ref elts) => PatTup(elts.map(|x| fld.fold_pat(*x))),\n-        PatBox(inner) => PatBox(fld.fold_pat(inner)),\n-        PatUniq(inner) => PatUniq(fld.fold_pat(inner)),\n-        PatRegion(inner) => PatRegion(fld.fold_pat(inner)),\n-        PatRange(e1, e2) => {\n-            PatRange(fld.fold_expr(e1), fld.fold_expr(e2))\n-        },\n-        PatVec(ref before, ref slice, ref after) => {\n-            PatVec(\n-                before.map(|x| fld.fold_pat(*x)),\n-                slice.map_move(|x| fld.fold_pat(x)),\n-                after.map(|x| fld.fold_pat(*x))\n-            )\n-        }\n+    Crate {\n+        module: folder.fold_mod(&c.module),\n+        attrs: c.attrs.map(|x| fold_attribute(*x)),\n+        config: c.config.map(|x| fold_meta_item(*x)),\n+        span: folder.new_span(c.span),\n     }\n }\n \n-fn noop_fold_decl(d: &Decl_, fld: @ast_fold) -> Option<Decl_> {\n-    match *d {\n-        DeclLocal(ref l) => Some(DeclLocal(fld.fold_local(*l))),\n-        DeclItem(it) => {\n-            match fld.fold_item(it) {\n-                Some(it_folded) => Some(DeclItem(it_folded)),\n-                None => None,\n-            }\n-        }\n-    }\n-}\n+pub fn noop_fold_item<T:ast_fold>(i: @ast::item, folder: &T)\n+                                  -> Option<@ast::item> {\n+    let fold_attribute = |x| fold_attribute_(x, folder);\n \n-// lift a function in ast-thingy X fold -> ast-thingy to a function\n-// in (ast-thingy X span X fold) -> (ast-thingy X span). Basically,\n-// carries the span around.\n-// It seems strange to me that the call to new_fold doesn't happen\n-// here but instead in the impl down below.... probably just an\n-// accident?\n-pub fn wrap<T>(f: @fn(&T, @ast_fold) -> T)\n-            -> @fn(&T, Span, @ast_fold) -> (T, Span) {\n-    let result: @fn(&T, Span, @ast_fold) -> (T, Span) = |x, s, fld| {\n-        (f(x, fld), s)\n-    };\n-    result\n+    Some(@ast::item {\n+        ident: folder.fold_ident(i.ident),\n+        attrs: i.attrs.map(|e| fold_attribute(*e)),\n+        id: folder.new_id(i.id),\n+        node: folder.fold_item_underscore(&i.node),\n+        vis: i.vis,\n+        span: folder.new_span(i.span)\n+    })\n }\n \n-pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n-    fn fold_field_(field: Field, fld: @ast_fold) -> Field {\n-        ast::Field {\n-            ident: fld.fold_ident(field.ident),\n-            expr: fld.fold_expr(field.expr),\n-            span: fld.new_span(field.span),\n-        }\n-    }\n-    let fold_field = |x| fold_field_(x, fld);\n+pub fn noop_fold_expr<T:ast_fold>(e: @ast::Expr, folder: &T) -> @ast::Expr {\n+    let fold_field = |x| fold_field_(x, folder);\n \n-    match *e {\n+    let node = match e.node {\n         ExprVstore(e, v) => {\n-            ExprVstore(fld.fold_expr(e), v)\n+            ExprVstore(folder.fold_expr(e), v)\n         }\n         ExprVec(ref exprs, mutt) => {\n-            ExprVec(fld.map_exprs(|x| fld.fold_expr(x), *exprs), mutt)\n+            ExprVec(folder.map_exprs(|x| folder.fold_expr(x), *exprs), mutt)\n         }\n         ExprRepeat(expr, count, mutt) => {\n-            ExprRepeat(fld.fold_expr(expr), fld.fold_expr(count), mutt)\n+            ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count), mutt)\n         }\n-        ExprTup(ref elts) => ExprTup(elts.map(|x| fld.fold_expr(*x))),\n+        ExprTup(ref elts) => ExprTup(elts.map(|x| folder.fold_expr(*x))),\n         ExprCall(f, ref args, blk) => {\n-            ExprCall(\n-                fld.fold_expr(f),\n-                fld.map_exprs(|x| fld.fold_expr(x), *args),\n-                blk\n-            )\n+            ExprCall(folder.fold_expr(f),\n+                     folder.map_exprs(|x| folder.fold_expr(x), *args),\n+                     blk)\n         }\n         ExprMethodCall(callee_id, f, i, ref tps, ref args, blk) => {\n             ExprMethodCall(\n-                fld.new_id(callee_id),\n-                fld.fold_expr(f),\n-                fld.fold_ident(i),\n-                tps.map(|x| fld.fold_ty(x)),\n-                fld.map_exprs(|x| fld.fold_expr(x), *args),\n+                folder.new_id(callee_id),\n+                folder.fold_expr(f),\n+                folder.fold_ident(i),\n+                tps.map(|x| folder.fold_ty(x)),\n+                folder.map_exprs(|x| folder.fold_expr(x), *args),\n                 blk\n             )\n         }\n         ExprBinary(callee_id, binop, lhs, rhs) => {\n-            ExprBinary(\n-                fld.new_id(callee_id),\n-                binop,\n-                fld.fold_expr(lhs),\n-                fld.fold_expr(rhs)\n-            )\n+            ExprBinary(folder.new_id(callee_id),\n+                       binop,\n+                       folder.fold_expr(lhs),\n+                       folder.fold_expr(rhs))\n         }\n         ExprUnary(callee_id, binop, ohs) => {\n-            ExprUnary(\n-                fld.new_id(callee_id),\n-                binop,\n-                fld.fold_expr(ohs)\n-            )\n+            ExprUnary(folder.new_id(callee_id), binop, folder.fold_expr(ohs))\n         }\n-        ExprDoBody(f) => ExprDoBody(fld.fold_expr(f)),\n-        ExprLit(_) => (*e).clone(),\n+        ExprDoBody(f) => ExprDoBody(folder.fold_expr(f)),\n+        ExprLit(_) => e.node.clone(),\n         ExprCast(expr, ref ty) => {\n-            ExprCast(fld.fold_expr(expr), fld.fold_ty(ty))\n+            ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n         }\n-        ExprAddrOf(m, ohs) => ExprAddrOf(m, fld.fold_expr(ohs)),\n+        ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n         ExprIf(cond, ref tr, fl) => {\n-            ExprIf(\n-                fld.fold_expr(cond),\n-                fld.fold_block(tr),\n-                fl.map_move(|x| fld.fold_expr(x))\n-            )\n+            ExprIf(folder.fold_expr(cond),\n+                   folder.fold_block(tr),\n+                   fl.map_move(|x| folder.fold_expr(x)))\n         }\n         ExprWhile(cond, ref body) => {\n-            ExprWhile(fld.fold_expr(cond), fld.fold_block(body))\n+            ExprWhile(folder.fold_expr(cond), folder.fold_block(body))\n         }\n-        ExprForLoop(pat, iter, ref body, opt_ident) => {\n-            ExprForLoop(fld.fold_pat(pat),\n-                        fld.fold_expr(iter),\n-                        fld.fold_block(body),\n-                        opt_ident.map_move(|x| fld.fold_ident(x)))\n+        ExprForLoop(pat, iter, ref body, ref maybe_ident) => {\n+            ExprForLoop(folder.fold_pat(pat),\n+                        folder.fold_expr(iter),\n+                        folder.fold_block(body),\n+                        maybe_ident.map_move(|i| folder.fold_ident(i)))\n         }\n         ExprLoop(ref body, opt_ident) => {\n-            ExprLoop(\n-                fld.fold_block(body),\n-                opt_ident.map_move(|x| fld.fold_ident(x))\n-            )\n+            ExprLoop(folder.fold_block(body),\n+                     opt_ident.map_move(|x| folder.fold_ident(x)))\n         }\n         ExprMatch(expr, ref arms) => {\n-            ExprMatch(\n-                fld.fold_expr(expr),\n-                arms.map(|x| fld.fold_arm(x))\n-            )\n+            ExprMatch(folder.fold_expr(expr),\n+                      arms.map(|x| folder.fold_arm(x)))\n         }\n         ExprFnBlock(ref decl, ref body) => {\n             ExprFnBlock(\n-                fold_fn_decl(decl, fld),\n-                fld.fold_block(body)\n+                fold_fn_decl(decl, folder),\n+                folder.fold_block(body)\n             )\n         }\n-        ExprBlock(ref blk) => ExprBlock(fld.fold_block(blk)),\n+        ExprBlock(ref blk) => ExprBlock(folder.fold_block(blk)),\n         ExprAssign(el, er) => {\n-            ExprAssign(fld.fold_expr(el), fld.fold_expr(er))\n+            ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n         }\n         ExprAssignOp(callee_id, op, el, er) => {\n-            ExprAssignOp(\n-                fld.new_id(callee_id),\n-                op,\n-                fld.fold_expr(el),\n-                fld.fold_expr(er)\n-            )\n+            ExprAssignOp(folder.new_id(callee_id),\n+                         op,\n+                         folder.fold_expr(el),\n+                         folder.fold_expr(er))\n         }\n         ExprField(el, id, ref tys) => {\n-            ExprField(\n-                fld.fold_expr(el), fld.fold_ident(id),\n-                tys.map(|x| fld.fold_ty(x))\n-            )\n+            ExprField(folder.fold_expr(el), folder.fold_ident(id),\n+                      tys.map(|x| folder.fold_ty(x)))\n         }\n         ExprIndex(callee_id, el, er) => {\n-            ExprIndex(\n-                fld.new_id(callee_id),\n-                fld.fold_expr(el),\n-                fld.fold_expr(er)\n-            )\n+            ExprIndex(folder.new_id(callee_id),\n+                      folder.fold_expr(el),\n+                      folder.fold_expr(er))\n         }\n-        ExprPath(ref pth) => ExprPath(fld.fold_path(pth)),\n+        ExprPath(ref pth) => ExprPath(folder.fold_path(pth)),\n         ExprSelf => ExprSelf,\n-        ExprBreak(ref opt_ident) => {\n-            // FIXME #6993: add fold_name to fold.... then cut out the\n-            // bogus Name->Ident->Name conversion.\n-            ExprBreak(opt_ident.map_move(|x| {\n-                // FIXME #9129: Assigning the new ident to a temporary to work around codegen bug\n-                let newx = Ident::new(x);\n-                fld.fold_ident(newx).name\n-            }))\n-        }\n-        ExprAgain(ref opt_ident) => {\n-            // FIXME #6993: add fold_name to fold....\n-            ExprAgain(opt_ident.map_move(|x| {\n-                // FIXME #9129: Assigning the new ident to a temporary to work around codegen bug\n-                let newx = Ident::new(x);\n-                fld.fold_ident(newx).name\n-            }))\n-        }\n+        ExprLogLevel => ExprLogLevel,\n+        ExprBreak(opt_ident) => ExprBreak(opt_ident),\n+        ExprAgain(opt_ident) => ExprAgain(opt_ident),\n         ExprRet(ref e) => {\n-            ExprRet(e.map_move(|x| fld.fold_expr(x)))\n+            ExprRet(e.map_move(|x| folder.fold_expr(x)))\n         }\n-        ExprLogLevel => ExprLogLevel,\n         ExprInlineAsm(ref a) => {\n             ExprInlineAsm(inline_asm {\n-                inputs: a.inputs.map(|&(c, input)| (c, fld.fold_expr(input))),\n-                outputs: a.outputs.map(|&(c, out)| (c, fld.fold_expr(out))),\n+                inputs: a.inputs.map(|&(c, input)| (c, folder.fold_expr(input))),\n+                outputs: a.outputs.map(|&(c, out)| (c, folder.fold_expr(out))),\n                 .. (*a).clone()\n             })\n         }\n-        ExprMac(ref mac) => ExprMac(fld.fold_mac(mac)),\n+        ExprMac(ref mac) => ExprMac(folder.fold_mac(mac)),\n         ExprStruct(ref path, ref fields, maybe_expr) => {\n-            ExprStruct(\n-                fld.fold_path(path),\n-                fields.map(|x| fold_field(*x)),\n-                maybe_expr.map_move(|x| fld.fold_expr(x))\n-            )\n+            ExprStruct(folder.fold_path(path),\n+                       fields.map(|x| fold_field(*x)),\n+                       maybe_expr.map_move(|x| folder.fold_expr(x)))\n         },\n-        ExprParen(ex) => ExprParen(fld.fold_expr(ex))\n-    }\n-}\n-\n-pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n-    fn fold_mt(mt: &mt, fld: @ast_fold) -> mt {\n-        mt {\n-            ty: ~fld.fold_ty(mt.ty),\n-            mutbl: mt.mutbl,\n-        }\n-    }\n-    fn fold_field(f: TypeField, fld: @ast_fold) -> TypeField {\n-        ast::TypeField {\n-            ident: fld.fold_ident(f.ident),\n-            mt: fold_mt(&f.mt, fld),\n-            span: fld.new_span(f.span),\n-        }\n-    }\n-    fn fold_opt_bounds(b: &Option<OptVec<TyParamBound>>, fld: @ast_fold)\n-                        -> Option<OptVec<TyParamBound>> {\n-        do b.map |bounds| {\n-            do bounds.map |bound| { fld.fold_ty_param_bound(bound) }\n-        }\n-    }\n-    match *t {\n-        ty_nil | ty_bot | ty_infer => (*t).clone(),\n-        ty_box(ref mt) => ty_box(fold_mt(mt, fld)),\n-        ty_uniq(ref mt) => ty_uniq(fold_mt(mt, fld)),\n-        ty_vec(ref mt) => ty_vec(fold_mt(mt, fld)),\n-        ty_ptr(ref mt) => ty_ptr(fold_mt(mt, fld)),\n-        ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, fld)),\n-        ty_closure(ref f) => {\n-            ty_closure(@TyClosure {\n-                sigil: f.sigil,\n-                purity: f.purity,\n-                region: f.region,\n-                onceness: f.onceness,\n-                bounds: fold_opt_bounds(&f.bounds, fld),\n-                decl: fold_fn_decl(&f.decl, fld),\n-                lifetimes: fld.fold_lifetimes(&f.lifetimes)\n-            })\n-        }\n-        ty_bare_fn(ref f) => {\n-            ty_bare_fn(@TyBareFn {\n-                lifetimes: fld.fold_lifetimes(&f.lifetimes),\n-                purity: f.purity,\n-                abis: f.abis,\n-                decl: fold_fn_decl(&f.decl, fld)\n-            })\n-        }\n-        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(ty))),\n-        ty_path(ref path, ref bounds, id) =>\n-            ty_path(fld.fold_path(path), fold_opt_bounds(bounds, fld), fld.new_id(id)),\n-        ty_fixed_length_vec(ref mt, e) => {\n-            ty_fixed_length_vec(\n-                fold_mt(mt, fld),\n-                fld.fold_expr(e)\n-            )\n-        }\n-        ty_typeof(e) => ty_typeof(fld.fold_expr(e)),\n-        ty_mac(ref mac) => ty_mac(fld.fold_mac(mac))\n-    }\n-}\n-\n-// ...nor do modules\n-pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n-    ast::_mod {\n-        view_items: m.view_items.iter().map(|x| fld.fold_view_item(x)).collect(),\n-        items: m.items.iter().filter_map(|x| fld.fold_item(*x)).collect(),\n-    }\n-}\n-\n-fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n-    ast::foreign_mod {\n-        sort: nm.sort,\n-        abis: nm.abis,\n-        view_items: nm.view_items.iter().map(|x| fld.fold_view_item(x)).collect(),\n-        items: nm.items.iter().map(|x| fld.fold_foreign_item(*x)).collect(),\n-    }\n-}\n-\n-fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n-    let kind = match v.kind {\n-        tuple_variant_kind(ref variant_args) => {\n-            tuple_variant_kind(variant_args.map(|x| fld.fold_variant_arg(x)))\n-        }\n-        struct_variant_kind(ref struct_def) => {\n-            struct_variant_kind(@ast::struct_def {\n-                fields: struct_def.fields.iter()\n-                    .map(|f| fld.fold_struct_field(*f)).collect(),\n-                ctor_id: struct_def.ctor_id.map(|c| fld.new_id(*c))\n-            })\n-        }\n-    };\n-\n-    let attrs = fld.fold_attributes(v.attrs);\n-\n-    let de = match v.disr_expr {\n-      Some(e) => Some(fld.fold_expr(e)),\n-      None => None\n+        ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n     };\n-    ast::variant_ {\n-        name: v.name,\n-        attrs: attrs,\n-        kind: kind,\n-        id: fld.new_id(v.id),\n-        disr_expr: de,\n-        vis: v.vis,\n-    }\n-}\n-\n-fn noop_fold_ident(i: Ident, _fld: @ast_fold) -> Ident {\n-    i\n-}\n \n-fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n-    ast::Path {\n-        span: fld.new_span(p.span),\n-        global: p.global,\n-        segments: p.segments.map(|segment| ast::PathSegment {\n-            identifier: fld.fold_ident(segment.identifier),\n-            lifetime: segment.lifetime,\n-            types: segment.types.map(|typ| fld.fold_ty(typ)),\n-        })\n+    @Expr {\n+        id: folder.new_id(e.id),\n+        node: node,\n+        span: folder.new_span(e.span),\n     }\n }\n \n-fn noop_fold_local(l: @Local, fld: @ast_fold) -> @Local {\n-    @Local {\n-        is_mutbl: l.is_mutbl,\n-        ty: fld.fold_ty(&l.ty),\n-        pat: fld.fold_pat(l.pat),\n-        init: l.init.map_move(|e| fld.fold_expr(e)),\n-        id: fld.new_id(l.id),\n-        span: fld.new_span(l.span),\n-    }\n-}\n-\n-// the default macro traversal. visit the path\n-// using fold_path, and the tts using fold_tts,\n-// and the span using new_span\n-fn noop_fold_mac(m: &mac_, fld: @ast_fold) -> mac_ {\n-    match *m {\n-        mac_invoc_tt(ref p,ref tts,ctxt) =>\n-        mac_invoc_tt(fld.fold_path(p),\n-                     fold_tts(*tts,fld),\n-                     ctxt)\n-    }\n-}\n-\n-\n-/* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n-   value */\n-fn noop_map_exprs(f: @fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n-    es.map(|x| f(*x))\n-}\n-\n-fn noop_id(i: NodeId) -> NodeId { return i; }\n-\n-fn noop_span(sp: Span) -> Span { return sp; }\n-\n-pub fn default_ast_fold() -> ast_fold_fns {\n-    @AstFoldFns {\n-        fold_crate: noop_fold_crate,\n-        fold_view_item: noop_fold_view_item,\n-        fold_foreign_item: noop_fold_foreign_item,\n-        fold_item: noop_fold_item,\n-        fold_struct_field: noop_fold_struct_field,\n-        fold_item_underscore: noop_fold_item_underscore,\n-        fold_type_method: noop_fold_type_method,\n-        fold_method: noop_fold_method,\n-        fold_block: noop_fold_block,\n-        fold_stmt: |x, s, fld| (noop_fold_stmt(x, fld), s),\n-        fold_arm: noop_fold_arm,\n-        fold_pat: wrap(noop_fold_pat),\n-        fold_decl: |x, s, fld| (noop_fold_decl(x, fld), s),\n-        fold_expr: wrap(noop_fold_expr),\n-        fold_ty: wrap(noop_fold_ty),\n-        fold_mod: noop_fold_mod,\n-        fold_foreign_mod: noop_fold_foreign_mod,\n-        fold_variant: wrap(noop_fold_variant),\n-        fold_ident: noop_fold_ident,\n-        fold_path: noop_fold_path,\n-        fold_local: noop_fold_local,\n-        fold_mac: wrap(noop_fold_mac),\n-        map_exprs: noop_map_exprs,\n-        new_id: noop_id,\n-        new_span: noop_span,\n-    }\n-}\n-\n-impl ast_fold for AstFoldFns {\n-    /* naturally, a macro to write these would be nice */\n-    fn fold_crate(@self, c: &Crate) -> Crate {\n-        (self.fold_crate)(c, self as @ast_fold)\n-    }\n-    fn fold_view_item(@self, x: &view_item) -> view_item {\n-        ast::view_item {\n-            node: (self.fold_view_item)(&x.node, self as @ast_fold),\n-            attrs: self.fold_attributes(x.attrs),\n-            vis: x.vis,\n-            span: (self.new_span)(x.span),\n-        }\n-    }\n-    fn fold_foreign_item(@self, x: @foreign_item) -> @foreign_item {\n-        (self.fold_foreign_item)(x, self as @ast_fold)\n-    }\n-    fn fold_item(@self, i: @item) -> Option<@item> {\n-        (self.fold_item)(i, self as @ast_fold)\n-    }\n-    fn fold_struct_field(@self, sf: @struct_field) -> @struct_field {\n-        @Spanned {\n-            node: ast::struct_field_ {\n-                kind: sf.node.kind,\n-                id: (self.new_id)(sf.node.id),\n-                ty: self.fold_ty(&sf.node.ty),\n-                attrs: self.fold_attributes(sf.node.attrs),\n-            },\n-            span: (self.new_span)(sf.span),\n-        }\n-    }\n-    fn fold_item_underscore(@self, i: &item_) -> item_ {\n-        (self.fold_item_underscore)(i, self as @ast_fold)\n-    }\n-    fn fold_type_method(@self, m: &TypeMethod) -> TypeMethod {\n-        (self.fold_type_method)(m, self as @ast_fold)\n-    }\n-    fn fold_method(@self, x: @method) -> @method {\n-        (self.fold_method)(x, self as @ast_fold)\n-    }\n-    fn fold_block(@self, x: &Block) -> Block {\n-        (self.fold_block)(x, self as @ast_fold)\n-    }\n-    fn fold_stmt(@self, x: &Stmt) -> Option<@Stmt> {\n-        let (n_opt, s) = (self.fold_stmt)(&x.node, x.span, self as @ast_fold);\n-        match n_opt {\n-            Some(n) => Some(@Spanned { node: n, span: (self.new_span)(s) }),\n-            None => None,\n-        }\n-    }\n-    fn fold_arm(@self, x: &Arm) -> Arm {\n-        (self.fold_arm)(x, self as @ast_fold)\n-    }\n-    fn fold_pat(@self, x: @Pat) -> @Pat {\n-        let (n, s) =  (self.fold_pat)(&x.node, x.span, self as @ast_fold);\n-        @Pat {\n-            id: (self.new_id)(x.id),\n-            node: n,\n-            span: (self.new_span)(s),\n-        }\n-    }\n-    fn fold_decl(@self, x: @Decl) -> Option<@Decl> {\n-        let (n_opt, s) = (self.fold_decl)(&x.node, x.span, self as @ast_fold);\n-        match n_opt {\n-            Some(n) => Some(@Spanned { node: n, span: (self.new_span)(s) }),\n-            None => None,\n+pub fn noop_fold_stmt<T:ast_fold>(s: &Stmt, folder: &T) -> Option<@Stmt> {\n+    let node = match s.node {\n+        StmtDecl(d, nid) => {\n+            match folder.fold_decl(d) {\n+                Some(d) => Some(StmtDecl(d, folder.new_id(nid))),\n+                None => None,\n+            }\n         }\n-    }\n-    fn fold_expr(@self, x: @Expr) -> @Expr {\n-        let (n, s) = (self.fold_expr)(&x.node, x.span, self as @ast_fold);\n-        @Expr {\n-            id: (self.new_id)(x.id),\n-            node: n,\n-            span: (self.new_span)(s),\n+        StmtExpr(e, nid) => {\n+            Some(StmtExpr(folder.fold_expr(e), folder.new_id(nid)))\n         }\n-    }\n-    fn fold_ty(@self, x: &Ty) -> Ty {\n-        let (n, s) = (self.fold_ty)(&x.node, x.span, self as @ast_fold);\n-        Ty {\n-            id: (self.new_id)(x.id),\n-            node: n,\n-            span: (self.new_span)(s),\n+        StmtSemi(e, nid) => {\n+            Some(StmtSemi(folder.fold_expr(e), folder.new_id(nid)))\n         }\n-    }\n-    fn fold_mod(@self, x: &_mod) -> _mod {\n-        (self.fold_mod)(x, self as @ast_fold)\n-    }\n-    fn fold_foreign_mod(@self, x: &foreign_mod) -> foreign_mod {\n-        (self.fold_foreign_mod)(x, self as @ast_fold)\n-    }\n-    fn fold_variant(@self, x: &variant) -> variant {\n-        let (n, s) = (self.fold_variant)(&x.node, x.span, self as @ast_fold);\n-        Spanned { node: n, span: (self.new_span)(s) }\n-    }\n-    fn fold_ident(@self, x: Ident) -> Ident {\n-        (self.fold_ident)(x, self as @ast_fold)\n-    }\n-    fn fold_path(@self, x: &Path) -> Path {\n-        (self.fold_path)(x, self as @ast_fold)\n-    }\n-    fn fold_local(@self, x: @Local) -> @Local {\n-        (self.fold_local)(x, self as @ast_fold)\n-    }\n-    fn fold_mac(@self, x: &mac) -> mac {\n-        let (n, s) = (self.fold_mac)(&x.node, x.span, self as @ast_fold);\n-        Spanned { node: n, span: (self.new_span)(s) }\n-    }\n-    fn map_exprs(@self,\n-                 f: @fn(@Expr) -> @Expr,\n-                 e: &[@Expr])\n-              -> ~[@Expr] {\n-        (self.map_exprs)(f, e)\n-    }\n-    fn new_id(@self, node_id: ast::NodeId) -> NodeId {\n-        (self.new_id)(node_id)\n-    }\n-    fn new_span(@self, span: Span) -> Span {\n-        (self.new_span)(span)\n-    }\n-}\n+        StmtMac(ref mac, semi) => Some(StmtMac(folder.fold_mac(mac), semi))\n+    };\n \n-// brson agrees with me that this function's existence is probably\n-// not a good or useful thing.\n-pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n-    afp as @ast_fold\n+    node.map_move(|node| @Spanned {\n+        node: node,\n+        span: folder.new_span(s.span),\n+    })\n }\n \n #[cfg(test)]\n@@ -1048,27 +870,18 @@ mod test {\n     use print::pprust;\n     use super::*;\n \n-    // taken from expand\n-    // given a function from idents to idents, produce\n-    // an ast_fold that applies that function:\n-    pub fn fun_to_ident_folder(f: @fn(ast::Ident)->ast::Ident) -> @ast_fold{\n-        let afp = default_ast_fold();\n-        let f_pre = @AstFoldFns{\n-            fold_ident : |id, _| f(id),\n-            .. *afp\n-        };\n-        make_fold(f_pre)\n-    }\n-\n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: @pprust::ps, crate: &ast::Crate) {\n         pprust::print_mod(s, &crate.module, crate.attrs);\n     }\n \n     // change every identifier to \"zz\"\n-    pub fn to_zz() -> @fn(ast::Ident)->ast::Ident {\n-        let zz_id = token::str_to_ident(\"zz\");\n-        |_id| {zz_id}\n+    struct ToZzIdentFolder;\n+\n+    impl ast_fold for ToZzIdentFolder {\n+        fn fold_ident(&self, _: ast::Ident) -> ast::Ident {\n+            token::str_to_ident(\"zz\")\n+        }\n     }\n \n     // maybe add to expand.rs...\n@@ -1088,7 +901,7 @@ mod test {\n \n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n-        let zz_fold = fun_to_ident_folder(to_zz());\n+        let zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n@@ -1099,7 +912,7 @@ mod test {\n \n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n-        let zz_fold = fun_to_ident_folder(to_zz());\n+        let zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(@\"macro_rules! a {(b $c:expr $(d $e:token)f+\n => (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n@@ -1108,15 +921,5 @@ mod test {\n                                     token::get_ident_interner()),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }\n-\n-    // and in cast expressions... this appears to be an existing bug.\n-    #[test] fn ident_transformation_in_types () {\n-        let zz_fold = fun_to_ident_folder(to_zz());\n-        let ast = string_to_crate(@\"fn a() {let z = 13 as int;}\");\n-        assert_pred!(matches_codepattern,\n-                     \"matches_codepattern\",\n-                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n-                                    token::get_ident_interner()),\n-                     ~\"fn zz(){let zz=13 as zz;}\");\n-    }\n }\n+"}, {"sha": "91ef55c78f6af106d9d9fa0847b6be0fbfd13664", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -45,7 +45,7 @@ pub struct ParseSess {\n     included_mod_stack: ~[Path],\n }\n \n-pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n+pub fn new_parse_sess(demitter: Option<@Emitter>) -> @mut ParseSess {\n     let cm = @CodeMap::new();\n     @mut ParseSess {\n         cm: cm,"}, {"sha": "867e4fe416b1d35ec5fda6f577dcde43e314754e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -37,16 +37,26 @@ pub enum ann_node<'self> {\n     node_expr(@ps, &'self ast::Expr),\n     node_pat(@ps, &'self ast::Pat),\n }\n-pub struct pp_ann {\n-    pre: @fn(ann_node),\n-    post: @fn(ann_node)\n+\n+pub trait pp_ann {\n+    fn pre(&self, _node: ann_node) {}\n+    fn post(&self, _node: ann_node) {}\n+}\n+\n+pub struct no_ann {\n+    contents: (),\n }\n \n-pub fn no_ann() -> pp_ann {\n-    fn ignore(_node: ann_node) { }\n-    return pp_ann {pre: ignore, post: ignore};\n+impl no_ann {\n+    pub fn new() -> no_ann {\n+        no_ann {\n+            contents: (),\n+        }\n+    }\n }\n \n+impl pp_ann for no_ann {}\n+\n pub struct CurrentCommentAndLiteral {\n     cur_cmnt: uint,\n     cur_lit: uint,\n@@ -60,7 +70,7 @@ pub struct ps {\n     literals: Option<~[comments::lit]>,\n     cur_cmnt_and_lit: @mut CurrentCommentAndLiteral,\n     boxes: @mut ~[pp::breaks],\n-    ann: pp_ann\n+    ann: @pp_ann\n }\n \n pub fn ibox(s: @ps, u: uint) {\n@@ -74,12 +84,13 @@ pub fn end(s: @ps) {\n }\n \n pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n-    return rust_printer_annotated(writer, intr, no_ann());\n+    return rust_printer_annotated(writer, intr, @no_ann::new() as @pp_ann);\n }\n \n pub fn rust_printer_annotated(writer: @io::Writer,\n                               intr: @ident_interner,\n-                              ann: pp_ann) -> @ps {\n+                              ann: @pp_ann)\n+                              -> @ps {\n     return @ps {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None::<@CodeMap>,\n@@ -109,7 +120,7 @@ pub fn print_crate(cm: @CodeMap,\n                    filename: @str,\n                    input: @io::Reader,\n                    out: @io::Writer,\n-                   ann: pp_ann,\n+                   ann: @pp_ann,\n                    is_expanded: bool) {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n         span_diagnostic,\n@@ -484,7 +495,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n-    (s.ann.pre)(ann_node);\n+    s.ann.pre(ann_node);\n     match item.node {\n       ast::item_static(ref ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n@@ -635,7 +646,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         end(s);\n       }\n     }\n-    (s.ann.post)(ann_node);\n+    s.ann.post(ann_node);\n }\n \n fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n@@ -958,7 +969,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n     }\n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n-    (s.ann.pre)(ann_node);\n+    s.ann.pre(ann_node);\n     match embedded {\n       block_block_fn => end(s),\n       block_normal => bopen(s)\n@@ -979,7 +990,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n       _ => ()\n     }\n     bclose_maybe_open(s, blk.span, indented, close_box);\n-    (s.ann.post)(ann_node);\n+    s.ann.post(ann_node);\n }\n \n pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n@@ -1121,7 +1132,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n-    (s.ann.pre)(ann_node);\n+    s.ann.pre(ann_node);\n     match expr.node {\n         ast::ExprVstore(e, v) => {\n             print_expr_vstore(s, v);\n@@ -1456,7 +1467,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n           pclose(s);\n       }\n     }\n-    (s.ann.post)(ann_node);\n+    s.ann.post(ann_node);\n     end(s);\n }\n \n@@ -1578,7 +1589,7 @@ pub fn print_bounded_path(s: @ps, path: &ast::Path,\n pub fn print_pat(s: @ps, pat: &ast::Pat) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n-    (s.ann.pre)(ann_node);\n+    s.ann.pre(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n@@ -1678,7 +1689,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n         word(s.s, \"]\");\n       }\n     }\n-    (s.ann.post)(ann_node);\n+    s.ann.post(ann_node);\n }\n \n pub fn explicit_self_to_str(explicit_self: &ast::explicit_self_, intr: @ident_interner) -> ~str {\n@@ -2254,17 +2265,6 @@ pub fn print_fn_header_info(s: @ps,\n     print_opt_sigil(s, opt_sigil);\n }\n \n-pub fn opt_sigil_to_str(opt_p: Option<ast::Sigil>) -> &'static str {\n-    match opt_p {\n-      None => \"fn\",\n-      Some(p) => match p {\n-          ast::BorrowedSigil => \"fn&\",\n-          ast::OwnedSigil => \"fn~\",\n-          ast::ManagedSigil => \"fn@\"\n-      }\n-    }\n-}\n-\n pub fn purity_to_str(p: ast::purity) -> &'static str {\n     match p {\n       ast::impure_fn => \"impure\","}, {"sha": "350bd09826fad67c7d66950fd6ee060e63a8289c", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -14,7 +14,7 @@ pub struct Entry<A,B> {\n }\n \n pub struct alist<A,B> {\n-    eq_fn: @fn(A,A) -> bool,\n+    eq_fn: extern \"Rust\" fn(A,A) -> bool,\n     data: @mut ~[Entry<A,B>]\n }\n "}, {"sha": "cd90c9b06c4ce0ad5649fa1cb9f68812e96584dc", "filename": "src/test/auxiliary/issue4516_ty_param_lib.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn to_closure<A:'static + Clone>(x: A) -> @fn() -> A {\n-    let result: @fn() -> A = || x.clone();\n-    result\n-}"}, {"sha": "991c102e9f0b0387d2ff42457726d7849c5068fa", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -46,7 +46,6 @@ type nillist = List<()>;\n struct State {\n     box: @nillist,\n     unique: ~nillist,\n-    fn_box: @fn() -> @nillist,\n     tuple: (@nillist, ~nillist),\n     vec: ~[@nillist],\n     res: r\n@@ -79,19 +78,15 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n             State {\n                 box: @Nil,\n                 unique: ~Nil,\n-                fn_box: || @Nil::<()>,\n                 tuple: (@Nil, ~Nil),\n                 vec: ~[@Nil],\n                 res: r(@Nil)\n             }\n           }\n           Some(st) => {\n-            let fn_box = st.fn_box;\n-\n             State {\n                 box: @Cons((), st.box),\n                 unique: ~Cons((), @*st.unique),\n-                fn_box: || @Cons((), fn_box()),\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n                 vec: st.vec + &[@Cons((), *st.vec.last())],"}, {"sha": "83baedc78927718371cb00840480a1c6c4532ca9", "filename": "src/test/compile-fail/borrowck-addr-of-upvar.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-addr-of-upvar.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn foo(x: @int) -> @fn() -> &'static int {\n-    let result: @fn() -> &'static int = || &*x;  //~ ERROR cannot root\n-    result\n-}\n-\n-fn bar(x: @int) -> @fn() -> &int {\n-    let result: @fn() -> &int = || &*x; //~ ERROR cannot root\n-    result\n-}\n-\n-fn zed(x: @int) -> @fn() -> int {\n-    let result: @fn() -> int = || *&*x;\n-    result\n-}\n-\n-fn main() {\n-}"}, {"sha": "5994b9e85d5ae97e6a3021fb012c384f6ada4d62", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1,13 +1,13 @@\n pub fn main() {\n     let foo = ~3;\n     let _pfoo = &foo;\n-    let _f: @fn() -> int = || *foo + 5;\n+    let _f: ~fn() -> int = || *foo + 5;\n     //~^ ERROR cannot move `foo`\n \n     // FIXME(#2202) - Due to the way that borrowck treats closures,\n     // you get two error reports here.\n     let bar = ~3;\n     let _g = || { //~ ERROR capture of moved value\n-        let _h: @fn() -> int = || *bar; //~ ERROR capture of moved value\n+        let _h: ~fn() -> int = || *bar; //~ ERROR capture of moved value\n     };\n }"}, {"sha": "525f8f4a932b17a50ffd96978e6531d79d6d31e7", "filename": "src/test/compile-fail/closure-bounds-cant-promote-superkind-in-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n struct X {\n-    field: @fn:Send(),\n+    field: ~fn:Send(),\n }\n \n-fn foo(blk: @fn:()) -> X {\n+fn foo(blk: ~fn:()) -> X {\n     return X { field: blk }; //~ ERROR expected bounds `Send` but found no bounds\n }\n "}, {"sha": "b6976b2c35545b9c7f84f308044cd9cc0a643f7d", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1,3 +1,8 @@\n+// xfail-test\n+\n+// xfail'd because the lint pass doesn't know to ignore standard library\n+// stuff.\n+\n // -*- rust -*-\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at"}, {"sha": "1bffdaa682cdcd5c1ee13f78c9dd7f99074abf4e", "filename": "src/test/compile-fail/do2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(f: @fn(int) -> bool) -> bool { f(10i) }\n+fn f(f: &fn(int) -> bool) -> bool { f(10i) }\n \n fn main() {\n     assert!(do f() |i| { i == 10i } == 10i);"}, {"sha": "ab5591900346e3e273bab99489ea4d121a8b5dd5", "filename": "src/test/compile-fail/fn-variance-2.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Ffn-variance-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Ffn-variance-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-2.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn reproduce<T>(t: T) -> @fn() -> T {\n-    let result: @fn() -> T = || t;\n-    result\n-}\n-\n-fn main() {\n-    // type of x is the variable X,\n-    // with the lower bound @mut int\n-    let x = @mut 3;\n-\n-    // type of r is @fn() -> X\n-    let r = reproduce(x);\n-\n-    // Requires that X be a subtype of\n-    // @mut int.\n-    let f: @mut int = r();\n-\n-    // Bad.\n-    let h: @int = r(); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "e42c6b658e4f7b87b5307935c361bc1702e3f940", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn mk_identity<T>() -> @fn(T) -> T {\n-    let result: @fn(t: T) -> T = |t| t;\n-    result\n-}\n-\n-fn main() {\n-    // type of r is @fn(X) -> X\n-    // for some fresh X\n-    let r = mk_identity();\n-\n-    // @mut int <: X\n-    r(@mut 3);\n-\n-    // @int <: X\n-    //\n-    // Here the type check fails because @const is gone and there is no\n-    // supertype.\n-    r(@3);  //~ ERROR mismatched types\n-\n-    // Here the type check succeeds.\n-    *r(@mut 3) = 4;\n-}"}, {"sha": "0d8acaa44647bcaf14e29b56033ec4398645bf3b", "filename": "src/test/compile-fail/issue-1451.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fissue-1451.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fissue-1451.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1451.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n // xfail-test\n-struct T { f: @fn() };\n-struct S { f: @fn() };\n+struct T { f: extern \"Rust\" fn() };\n+struct S { f: extern \"Rust\" fn() };\n \n fn fooS(t: S) {\n }\n@@ -22,11 +22,11 @@ fn bar() {\n }\n \n fn main() {\n-    let x: @fn() = bar;\n+    let x: extern \"Rust\" fn() = bar;\n     fooS(S {f: x});\n     fooS(S {f: bar});\n \n-    let x: @fn() = bar;\n+    let x: extern \"Rust\" fn() = bar;\n     fooT(T {f: x});\n     fooT(T {f: bar});\n }"}, {"sha": "4750f68d59b34454e9a438bd062246e562974ae4", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we require managed closures to be rooted when borrowed.\n-\n-struct boxedFn<'self> { theFn: &'self fn() -> uint }\n-\n-fn createClosure (closedUint: uint) -> boxedFn {\n-    let theFn: @fn() -> uint = || closedUint;\n-    boxedFn {theFn: theFn} //~ ERROR cannot root\n-}\n-\n-fn main () {\n-    let aFn: boxedFn = createClosure(10);\n-\n-    let myInt: uint = (aFn.theFn)();\n-\n-    assert_eq!(myInt, 10);\n-}"}, {"sha": "7815fca16c69bd72898cd336f5822f0af744bd0c", "filename": "src/test/compile-fail/issue-2074.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fissue-2074.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fissue-2074.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2074.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -10,11 +10,11 @@\n \n // xfail-test\n fn main() {\n-    let one: @fn() -> uint = || {\n+    let one: &fn() -> uint = || {\n         enum r { a };\n         a as uint\n     };\n-    let two = @fn() -> uint = || {\n+    let two = &fn() -> uint = || {\n         enum r { a };\n         a as uint\n     };"}, {"sha": "c39c258c701f9001aef7428f841938fda7289479", "filename": "src/test/compile-fail/issue-897-2.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897-2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1,3 +1,7 @@\n+// xfail-test\n+// xfail'd because the lint pass doesn't know to ignore standard library\n+// stuff.\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "8df73aef6109dfd9be3967192e4fff000e479911", "filename": "src/test/compile-fail/issue-897.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fissue-897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-897.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT."}, {"sha": "2dfdb2629f7f4f2374dda3ff41f63db30922c1d1", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn copy1<T:Clone>(t: T) -> @fn() -> T {\n-    let result: @fn() -> T = || t.clone();  //~ ERROR does not fulfill `'static`\n-    result\n-}\n-\n-fn copy2<T:Clone + 'static>(t: T) -> @fn() -> T {\n-    let result: @fn() -> T = || t.clone();\n-    result\n-}\n-\n-fn main() {\n-    let x = &3;\n-    copy2(&x); //~ ERROR does not fulfill `'static`\n-\n-    copy2(@3);\n-    copy2(@&x); //~ ERROR value may contain borrowed pointers\n-    //~^ ERROR does not fulfill `'static`\n-}"}, {"sha": "bfd1e12f3a6e05fce6d9ebcceae5876474ab2396", "filename": "src/test/compile-fail/lambda-mutate-nested.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Make sure that nesting a block within a @fn doesn't let us\n-// mutate upvars from a @fn.\n-fn f2(x: &fn()) { x(); }\n-\n-fn main() {\n-    let i = 0;\n-    let ctr: @fn() -> int = || { f2(|| i = i + 1 ); i };\n-    //~^ ERROR cannot assign\n-    error!(ctr());\n-    error!(ctr());\n-    error!(ctr());\n-    error!(ctr());\n-    error!(ctr());\n-    error!(i);\n-}"}, {"sha": "a848d8698a3d6d07cbe70cfc4c86f66610cac7b8", "filename": "src/test/compile-fail/lambda-mutate.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Make sure we can't write to upvars from @fns\n-fn main() {\n-    let i = 0;\n-    let ctr: @fn() -> int = || { i = i + 1; i };\n-    //~^ ERROR cannot assign\n-    error!(ctr());\n-    error!(ctr());\n-    error!(ctr());\n-    error!(ctr());\n-    error!(ctr());\n-    error!(i);\n-}"}, {"sha": "7054cb0d901ce54a9cf3d27ed224c1545e7bea0e", "filename": "src/test/compile-fail/liveness-init-in-called-fn-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-called-fn-expr.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let j: @fn() -> int = || {\n+    let j: &fn() -> int = || {\n         let i: int;\n         i //~ ERROR use of possibly uninitialized variable: `i`\n     };"}, {"sha": "b6c7895235b1009755f573ef98f536f1bffa223d", "filename": "src/test/compile-fail/liveness-init-in-fn-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-init-in-fn-expr.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let f: @fn() -> int = || {\n+    let f: &fn() -> int = || {\n         let i: int;\n         i //~ ERROR use of possibly uninitialized variable: `i`\n     };"}, {"sha": "5928d31a66860479ad0b0523a4cb8e946c8cbf96", "filename": "src/test/compile-fail/regions-fn-subtyping.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn of<T>() -> @fn(T) { fail!(); }\n-fn subtype<T>(x: @fn(T)) { fail!(); }\n+fn of<T>() -> &fn(T) { fail!(); }\n+fn subtype<T>(x: &fn(T)) { fail!(); }\n \n fn test_fn<'x,'y,'z,T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n     // Here, x, y, and z are free.  Other letters\n@@ -40,18 +40,6 @@ fn test_fn<'x,'y,'z,T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n \n     subtype::<&fn<'x,'y>(&'x T, &'y T)>(\n         of::<&fn<'a,'b>(&'a T, &'b T)>()); //~ ERROR mismatched types\n-\n-    subtype::<&fn<'x,'a>(&'x T) -> @fn(&'a T)>(\n-        of::<&fn<'x,'a>(&'x T) -> @fn(&'a T)>());\n-\n-    subtype::<&fn<'a>(&'a T) -> @fn(&'a T)>(\n-        of::<&fn<'a,'b>(&'a T) -> @fn(&'b T)>()); //~ ERROR mismatched types\n-\n-    subtype::<&fn<'a>(&'a T) -> @fn(&'a T)>(\n-        of::<&fn<'x,'b>(&'x T) -> @fn(&'b T)>()); //~ ERROR mismatched types\n-\n-    subtype::<&fn<'a,'b>(&'a T) -> @fn(&'b T)>(\n-        of::<&fn<'a>(&'a T) -> @fn(&'a T)>());\n }\n \n fn main() {}"}, {"sha": "715261d816a4e3f6998ec6d0fd36e35921b9259c", "filename": "src/test/compile-fail/regions-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,7 +12,7 @@\n // we reported errors in this case:\n \n fn not_ok<'b>(a: &uint, b: &'b uint) {\n-    let mut g: @fn(x: &uint) = |x: &'b uint| {};\n+    let mut g: &fn(x: &uint) = |x: &'b uint| {};\n     //~^ ERROR mismatched types\n     g(a);\n }"}, {"sha": "3ddae976ce317409f9ebc6223f519e695baa02c1", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -13,11 +13,11 @@ struct parameterized1<'self> {\n }\n \n struct not_parameterized1 {\n-    g: @fn()\n+    g: &'static fn()\n }\n \n struct not_parameterized2 {\n-    g: @fn()\n+    g: &'static fn()\n }\n \n fn take1(p: parameterized1) -> parameterized1 { p }"}, {"sha": "3fcc5184b4a7c8404df6c416ffc032249090ba4b", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-ret.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -14,7 +14,7 @@\n // the normal case.\n \n struct contravariant<'self> {\n-    f: @fn() -> &'self int\n+    f: &'static fn() -> &'self int\n }\n \n fn to_same_lifetime<'r>(bi: contravariant<'r>) {"}, {"sha": "4b26e6b60216372277337a5e10f8133b174a1339", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-arg.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -13,7 +13,7 @@\n // You can upcast to a *larger region* but not a smaller one.\n \n struct covariant<'self> {\n-    f: @fn(x: &'self int) -> int\n+    f: &'static fn(x: &'self int) -> int\n }\n \n fn to_same_lifetime<'r>(bi: covariant<'r>) {"}, {"sha": "6e322b170e8c33e48481b586fa9d4338105f6559", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct invariant<'self> {\n-    f: @fn(x: @mut &'self int)\n+    f: &'static fn(x: @mut &'self int)\n }\n \n fn to_same_lifetime<'r>(bi: invariant<'r>) {"}, {"sha": "380e9b27ff9c700ae1edce8abe343dfe999460fa", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct invariant<'self> {\n-    f: @fn() -> @mut &'self int\n+    f: &'static fn() -> @mut &'self int\n }\n \n fn to_same_lifetime<'r>(bi: invariant<'r>) {"}, {"sha": "47c1f7a5757dea49dcf1a0bc0ef2caf7504401fd", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -14,12 +14,12 @@ struct direct<'self> {\n \n struct indirect1 {\n     // Here the lifetime parameter of direct is bound by the fn()\n-    g: @fn(direct)\n+    g: &'static fn(direct)\n }\n \n struct indirect2<'self> {\n     // But here it is set to 'self\n-    g: @fn(direct<'self>)\n+    g: &'static fn(direct<'self>)\n }\n \n fn take_direct(p: direct) -> direct { p } //~ ERROR mismatched types"}, {"sha": "609439d7b8e2b6205978287311074e724512579b", "filename": "src/test/compile-fail/sendfn-is-not-a-lambda.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsendfn-is-not-a-lambda.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn test(f: @fn(uint) -> uint) -> uint {\n-    return f(22u);\n-}\n-\n-fn main() {\n-    let f: ~fn(x: uint) -> uint = |x| 4u;\n-    info!(test(f)); //~ ERROR expected @ closure, found ~ closure\n-}"}, {"sha": "96da78a9192983cf69aea31f57807d4f48ec1c80", "filename": "src/test/debug-info/lexical-scope-in-managed-closure.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fdebug-info%2Flexical-scope-in-managed-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fdebug-info%2Flexical-scope-in-managed-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-managed-closure.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags:-Z extra-debug-info\n-// debugger:rbreak zzz\n-// debugger:run\n-\n-// debugger:finish\n-// debugger:print x\n-// check:$1 = false\n-// debugger:continue\n-\n-// debugger:finish\n-// debugger:print x\n-// check:$2 = false\n-// debugger:continue\n-\n-// debugger:finish\n-// debugger:print x\n-// check:$3 = 1000\n-// debugger:continue\n-\n-// debugger:finish\n-// debugger:print x\n-// check:$4 = 2.5\n-// debugger:continue\n-\n-// debugger:finish\n-// debugger:print x\n-// check:$5 = true\n-// debugger:continue\n-\n-// debugger:finish\n-// debugger:print x\n-// check:$6 = false\n-// debugger:continue\n-\n-fn main() {\n-\n-    let x = false;\n-\n-    zzz();\n-    sentinel();\n-\n-    let managed_closure: @fn(int) = |x| {\n-        zzz();\n-        sentinel();\n-\n-        let x = 2.5;\n-\n-        zzz();\n-        sentinel();\n-\n-        let x = true;\n-\n-        zzz();\n-        sentinel();\n-    };\n-\n-    zzz();\n-    sentinel();\n-\n-    managed_closure(1000);\n-\n-    zzz();\n-    sentinel();\n-}\n-\n-fn zzz() {()}\n-fn sentinel() {()}"}, {"sha": "b20f40378d3964f7430097adf2313cae94f9a0f6", "filename": "src/test/debug-info/var-captured-in-managed-closure.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags:-Z extra-debug-info\n-// debugger:rbreak zzz\n-// debugger:run\n-// debugger:finish\n-\n-// debugger:print constant\n-// check:$1 = 1\n-// debugger:print a_struct\n-// check:$2 = {a = -2, b = 3.5, c = 4}\n-// debugger:print *owned\n-// check:$3 = 5\n-// debugger:print managed->val\n-// check:$4 = 6\n-\n-#[allow(unused_variable)];\n-\n-struct Struct {\n-    a: int,\n-    b: float,\n-    c: uint\n-}\n-\n-fn main() {\n-    let constant = 1;\n-\n-    let a_struct = Struct {\n-        a: -2,\n-        b: 3.5,\n-        c: 4\n-    };\n-\n-    let owned = ~5;\n-    let managed = @6;\n-\n-    let closure: @fn() = || {\n-        zzz();\n-        do_something(&constant, &a_struct.a, owned, managed);\n-    };\n-\n-    closure();\n-}\n-\n-fn do_something(_: &int, _:&int, _:&int, _:&int) {\n-}\n-\n-fn zzz() {()}"}, {"sha": "c0f173a1a0d6a751d16c7bd7993aa1bbc58b481c", "filename": "src/test/pretty/block-arg-disambig.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn blk1(_b: &fn()) -> @fn() { return || { }; }\n-fn test1() { (do blk1 { info!(\"hi\"); })(); }"}, {"sha": "751aedb39a3a8a00ddb2f0cb72d538ac701f5c9d", "filename": "src/test/pretty/do1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fpretty%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fpretty%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdo1.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -10,6 +10,6 @@\n \n // pp-exact\n \n-fn f(f: @fn(int)) { f(10) }\n+fn f(f: &fn(int)) { f(10) }\n \n fn main() { do f |i| { assert!(i == 10) } }"}, {"sha": "b000c9f9137ae51447e544d65e1f2173aa48389b", "filename": "src/test/pretty/fn-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fpretty%2Ffn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Fpretty%2Ffn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffn-types.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,6 +12,5 @@\n \n fn from_foreign_fn(_x: extern \"Rust\" fn()) { }\n fn from_stack_closure(_x: &fn()) { }\n-fn from_box_closure(_x: @fn()) { }\n fn from_unique_closure(_x: ~fn()) { }\n fn main() { }"}, {"sha": "a94f904c4921ab21c86818f5130207dc7da4956f", "filename": "src/test/run-fail/unwind-box-fn.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-fail%2Funwind-box-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-fail%2Funwind-box-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-fn.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:fail\n-\n-fn failfn() {\n-    fail!();\n-}\n-\n-fn main() {\n-    let y = ~0;\n-    let x: @@fn() = @|| {\n-        error!(y.clone());\n-    };\n-    failfn();\n-    error!(x);\n-}"}, {"sha": "5ea71c94e14685b09b09d49fbb034309edf1f87d", "filename": "src/test/run-fail/unwind-closure.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-fail%2Funwind-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-fail%2Funwind-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-closure.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:fail\n-\n-fn f(_a: @int) {\n-    fail!();\n-}\n-\n-fn main() {\n-    let b = @0;\n-    let g: @fn() = || f(b);\n-    g();\n-}"}, {"sha": "65d9fce5ff5dc8acf74499eeef0a9f1641083c16", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let cheese = ~\"roquefort\";\n     let carrots = @~\"crunchy\";\n \n-    let result: @fn(@~str, &fn(~str)) = (|tasties, macerate| {\n+    let result: &'static fn(@~str, &fn(~str)) = (|tasties, macerate| {\n         macerate((*tasties).clone());\n     });\n     result(carrots, |food| {"}, {"sha": "4352c139b620bdf8bedfb7ebb0edfd98ecdb789a", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,13 +12,30 @@ struct pair<A,B> {\n     a: A, b: B\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n-    let result: @fn() -> (A, u16) = || (a.clone(), b);\n-    result\n+trait Invokable<A> {\n+    fn f(&self) -> (A, u16);\n+}\n+\n+struct Invoker<A> {\n+    a: A,\n+    b: u16,\n+}\n+\n+impl<A:Clone> Invokable<A> for Invoker<A> {\n+    fn f(&self) -> (A, u16) {\n+        (self.a.clone(), self.b)\n+    }\n+}\n+\n+fn f<A:Clone + 'static>(a: A, b: u16) -> @Invokable<A> {\n+    @Invoker {\n+        a: a,\n+        b: b,\n+    } as @Invokable<A>\n }\n \n pub fn main() {\n-    let (a, b) = f(22_u64, 44u16)();\n+    let (a, b) = f(22_u64, 44u16).f();\n     info!(\"a=%? b=%?\", a, b);\n     assert_eq!(a, 22u64);\n     assert_eq!(b, 44u16);"}, {"sha": "9bf95968a9a211af58eab3cc663133a436a9a324", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -23,21 +23,38 @@ fn make_cycle<A:'static>(a: A) {\n     g.rec = Some(g);\n }\n \n+struct Invoker<A,B> {\n+    a: A,\n+    b: B,\n+}\n+\n+trait Invokable<A,B> {\n+    fn f(&self) -> (A, B);\n+}\n+\n+impl<A:Clone,B:Clone> Invokable<A,B> for Invoker<A,B> {\n+    fn f(&self) -> (A, B) {\n+        (self.a.clone(), self.b.clone())\n+    }\n+}\n+\n fn f<A:Send + Clone + 'static,\n      B:Send + Clone + 'static>(\n      a: A,\n      b: B)\n-     -> @fn() -> (A, B) {\n-    let result: @fn() -> (A, B) = || (a.clone(), b.clone());\n-    result\n+     -> @Invokable<A,B> {\n+    @Invoker {\n+        a: a,\n+        b: b,\n+    } as @Invokable<A,B>\n }\n \n pub fn main() {\n     let x = 22_u8;\n     let y = 44_u64;\n     let z = f(~x, y);\n     make_cycle(z);\n-    let (a, b) = z();\n+    let (a, b) = z.f();\n     info!(\"a=%u b=%u\", *a as uint, b as uint);\n     assert_eq!(*a, x);\n     assert_eq!(b, y);"}, {"sha": "6a59278982ad3fddbe30930bdf194b5900df4641", "filename": "src/test/run-pass/block-arg-call-as.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -14,19 +14,13 @@ fn asSendfn( f : ~fn()->uint ) -> uint {\n    return f();\n }\n \n-fn asLambda( f : @fn()->uint ) -> uint {\n-   return f();\n-}\n-\n fn asBlock( f : &fn()->uint ) -> uint {\n    return f();\n }\n \n pub fn main() {\n    let x = asSendfn(|| 22u);\n    assert_eq!(x, 22u);\n-   let x = asLambda(|| 22u);\n-   assert_eq!(x, 22u);\n    let x = asBlock(|| 22u);\n    assert_eq!(x, 22u);\n }"}, {"sha": "34fa7e36d973f4ad6453b11766f27b44f212f40c", "filename": "src/test/run-pass/block-arg-used-as-lambda.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn to_lambda(f: @fn(uint) -> uint) -> @fn(uint) -> uint {\n-    return f;\n-}\n-\n-pub fn main() {\n-    let x: @fn(uint) -> uint = to_lambda(|x| x * 2u );\n-    let y = to_lambda(x);\n-\n-    let x_r = x(22u);\n-    let y_r = y(x_r);\n-\n-    assert_eq!(x_r, 44u);\n-    assert_eq!(y_r, 88u);\n-}"}, {"sha": "f6328c8c65822cd8eb8ff0d574601076ce281d0d", "filename": "src/test/run-pass/borrowck-move-by-capture-ok.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-move-by-capture-ok.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -1,5 +1,5 @@\n pub fn main() {\n     let bar = ~3;\n-    let h: @fn() -> int = || *bar;\n+    let h: ~fn() -> int = || *bar;\n     assert_eq!(h(), 3);\n }"}, {"sha": "16728dffd19b17d5d3d7677b73f3945a82560b4d", "filename": "src/test/run-pass/call-closure-from-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcall-closure-from-overloaded-op.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n fn foo() -> int { 22 }\n \n pub fn main() {\n-    let mut x: ~[@fn() -> int] = ~[];\n+    let mut x: ~[extern \"Rust\" fn() -> int] = ~[];\n     x.push(foo);\n     assert_eq!((x[0])(), 22);\n }"}, {"sha": "64be8dab6e7021be8904b75de0e80a0b43da13ed", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,16 +11,6 @@\n use std::ptr;\n \n pub fn main() {\n-    let x = ~1;\n-    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n-    let lam_move: @fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n-    assert_eq!(lam_move(), y);\n-\n-    let x = ~2;\n-    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n-    let lam_move: @fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n-    assert_eq!(lam_move(), y);\n-\n     let x = ~3;\n     let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n     let snd_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;"}, {"sha": "8b7967ac1501e5bfdf3ee73cd6ef846fb6c3e82a", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -16,13 +16,30 @@ struct Pair<A,B> {\n     a: A, b: B\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n-    let result: @fn() -> (A, u16) = || (a.clone(), b);\n-    result\n+struct Invoker<A> {\n+    a: A,\n+    b: u16,\n+}\n+\n+trait Invokable<A> {\n+    fn f(&self) -> (A, u16);\n+}\n+\n+impl<A:Clone> Invokable<A> for Invoker<A> {\n+    fn f(&self) -> (A, u16) {\n+        (self.a.clone(), self.b)\n+    }\n+}\n+\n+fn f<A:Clone + 'static>(a: A, b: u16) -> @Invokable<A> {\n+    @Invoker {\n+        a: a,\n+        b: b,\n+    } as @Invokable<A>\n }\n \n pub fn main() {\n-    let (a, b) = f(22_u64, 44u16)();\n+    let (a, b) = f(22_u64, 44u16).f();\n     info!(\"a=%? b=%?\", a, b);\n     assert_eq!(a, 22u64);\n     assert_eq!(b, 44u16);"}, {"sha": "46c0c52e0c7187831d9aa91edf52c4981b5c1e18", "filename": "src/test/run-pass/cycle-collection2.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,13 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct foo { z: @fn() }\n+struct foo {\n+    z: Option<@Invokable>,\n+}\n+\n+struct Thing {\n+    w: @mut foo,\n+}\n+\n+trait Invokable {\n+    fn f(&self);\n+}\n+\n+impl Invokable for Thing {\n+    fn f(&self) {\n+        nop_foo(self.w);\n+    }\n+}\n \n fn nop() { }\n fn nop_foo(_x : @mut foo) { }\n \n pub fn main() {\n-    let w = @mut foo{ z: || nop() };\n-    let x: @fn() = || nop_foo(w);\n-    w.z = x;\n+    let w = @mut foo {\n+        z: None,\n+    };\n+    let x = @Thing {\n+        w: w,\n+    } as @Invokable;\n+    w.z = Some(x);\n }"}, {"sha": "8b613093944c5feff2bd4e98ac1c4303522a976f", "filename": "src/test/run-pass/cycle-collection4.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct foo { z : @fn() }\n-\n-fn nop() { }\n-fn nop_foo(_y: ~[int], _x : @mut foo) { }\n-\n-pub fn main() {\n-    let w = @mut foo{ z: || nop() };\n-    let x : @fn() = || nop_foo(~[], w);\n-    w.z = x;\n-}"}, {"sha": "f724a86555c76992106028014dd18b96a1849f95", "filename": "src/test/run-pass/cycle-collection5.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection5.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct foo { z: @fn() }\n-\n-fn nop() { }\n-fn nop_foo(_y: @int, _x: @mut foo) { }\n-\n-fn o() -> @int { @10 }\n-\n-pub fn main() {\n-    let w = @mut foo { z: || nop() };\n-    let x : @fn() = || nop_foo(o(), w);\n-    w.z = x;\n-}"}, {"sha": "1f725ffb3576a3858e424767642b6077771b246b", "filename": "src/test/run-pass/do-no-args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fdo-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fdo-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-no-args.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -10,9 +10,9 @@\n \n // Testing that we can drop the || in do exprs\n \n-fn f(_f: @fn() -> bool) -> bool { true }\n+fn f(_f: &fn() -> bool) -> bool { true }\n \n-fn d(_f: @fn()) { }\n+fn d(_f: &fn()) { }\n \n pub fn main() {\n     do d { }"}, {"sha": "0444b269cb34f2225cca898ef585c98eea6abc8f", "filename": "src/test/run-pass/do1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo1.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(f: @fn(int)) { f(10) }\n+fn f(f: &fn(int)) { f(10) }\n \n pub fn main() {\n     do f() |i| { assert!(i == 10) }"}, {"sha": "9feededc9800b68587a00323526e19e988f692a7", "filename": "src/test/run-pass/do2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(f: @fn(int) -> int) -> int { f(10) }\n+fn f(f: &fn(int) -> int) -> int { f(10) }\n \n pub fn main() {\n     assert_eq!(do f() |i| { i }, 10);"}, {"sha": "eeb983b455792826b08a748cc17ef504e3eae27c", "filename": "src/test/run-pass/do3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fdo3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fdo3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo3.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(f: @fn(int) -> int) -> int { f(10) }\n+fn f(f: &fn(int) -> int) -> int { f(10) }\n \n pub fn main() {\n     assert_eq!(do f |i| { i }, 10);"}, {"sha": "63e5c7688d345a38150a67c4753290ea546a1459", "filename": "src/test/run-pass/expr-block-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n \n \n fn test_fn() {\n-    type t = @fn() -> int;\n+    type t = &'static fn() -> int;\n     fn ten() -> int { return 10; }\n     let rs: t = { ten };\n     assert!((rs() == 10));"}, {"sha": "12b387b7eae5e6a634c61635b66d8ae4ad5178a0", "filename": "src/test/run-pass/expr-block-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,7 +12,7 @@\n \n \n // -*- rust -*-\n-type compare<T> = @fn(@T, @T) -> bool;\n+type compare<T> = &'static fn(@T, @T) -> bool;\n \n fn test_generic<T>(expected: @T, eq: compare<T>) {\n     let actual: @T = { expected };"}, {"sha": "cfa59d68635de986173715c850d726784bd63fc2", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n \n // xfail-fast\n \n-type compare<T> = @fn(T, T) -> bool;\n+type compare<'self, T> = &'self fn(T, T) -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "3f9c101761f8d211003d7790efa2123c042e803b", "filename": "src/test/run-pass/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n \n \n // -*- rust -*-\n-type compare<T> = @fn(~T, ~T) -> bool;\n+type compare<'self, T> = &'self fn(~T, ~T) -> bool;\n \n fn test_generic<T:Clone>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = { expected.clone() };"}, {"sha": "3484a4f7f5a1c307c24028e0c129f3e436fceae8", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // -*- rust -*-\n \n-type compare<T> = @fn(T, T) -> bool;\n+type compare<'self, T> = &'self fn(T, T) -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "2f379602c6bd1cb54ab7ef9e3fd3bf62b6127abb", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -13,7 +13,7 @@\n // xfail-fast\n \n // Tests for standalone blocks as expressions with dynamic type sizes\n-type compare<T> = @fn(T, T) -> bool;\n+type compare<'self, T> = &'self fn(T, T) -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "8bf6e658408cb8b1b9770e015c313340f7b630f5", "filename": "src/test/run-pass/expr-if-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,7 +12,7 @@\n \n \n // -*- rust -*-\n-type compare<T> = @fn(@T, @T) -> bool;\n+type compare<T> = &'static fn(@T, @T) -> bool;\n \n fn test_generic<T>(expected: @T, not_expected: @T, eq: compare<T>) {\n     let actual: @T = if true { expected } else { not_expected };"}, {"sha": "2c4707a87d5c5369fcfa974896c2caa7c7a02836", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // -*- rust -*-\n \n-type compare<T> = @fn(T, T) -> bool;\n+type compare<T> = &'static fn(T, T) -> bool;\n \n fn test_generic<T:Clone>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected.clone() } else { not_expected };"}, {"sha": "1bbf3a537db282083366ff501e53becde2b8f834", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,7 +12,7 @@\n // -*- rust -*-\n \n // Tests for if as expressions with dynamic type sizes\n-type compare<T> = @fn(T, T) -> bool;\n+type compare<T> = &'static fn(T, T) -> bool;\n \n fn test_generic<T:Clone>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected.clone() } else { not_expected };"}, {"sha": "064e33436205047e61e289bfae458ad686fc2b40", "filename": "src/test/run-pass/expr-match-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box1.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,7 +12,7 @@\n \n \n // -*- rust -*-\n-type compare<T> = @fn(@T, @T) -> bool;\n+type compare<T> = &'static fn(@T, @T) -> bool;\n \n fn test_generic<T>(expected: @T, eq: compare<T>) {\n     let actual: @T = match true { true => { expected }, _ => fail!() };"}, {"sha": "bca06ebdbb5f3405f5757b836d0badffad7bfba4", "filename": "src/test/run-pass/expr-match-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // -*- rust -*-\n \n-type compare<T> = @fn(T, T) -> bool;\n+type compare<T> = &'static fn(T, T) -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = match true { true => { expected.clone() }, _ => fail!(\"wat\") };"}, {"sha": "7371f8fd89b9ce28c193edbc0cb9ad7e2c4c8d05", "filename": "src/test/run-pass/expr-match-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique1.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n \n \n // -*- rust -*-\n-type compare<T> = @fn(~T, ~T) -> bool;\n+type compare<T> = &'static fn(~T, ~T) -> bool;\n \n fn test_generic<T:Clone>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = match true {"}, {"sha": "d07d40e675766c2ddae974844d25a8a507adb62e", "filename": "src/test/run-pass/expr-match-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // -*- rust -*-\n \n-type compare<T> = @fn(T, T) -> bool;\n+type compare<'self, T> = &'self fn(T, T) -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = match true {"}, {"sha": "b43085d346f30416b2e89a06c56c904afd2ae165", "filename": "src/test/run-pass/expr-match-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n // -*- rust -*-\n \n-type compare<T> = @fn(T, T) -> bool;\n+type compare<T> = extern \"Rust\" fn(T, T) -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n   let actual: T = match true { true => { expected.clone() }, _ => fail!(\"wat\") };"}, {"sha": "4c28151224c6d26a9e9e16461c7a35fd3eca5146", "filename": "src/test/run-pass/fixed-point-bind-box.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-\n-fn fix_help<A, B>(f: extern fn(@fn(A) -> B, A) -> B, x: A) -> B {\n-    return f( |a| fix_help(f, a), x);\n-}\n-\n-fn fix<A, B>(f: extern fn(@fn(A) -> B, A) -> B) -> @fn(A) -> B {\n-    return |a| fix_help(f, a);\n-}\n-\n-fn fact_(f: @fn(v: int) -> int, n: int) -> int {\n-    // fun fact 0 = 1\n-    return if n == 0 { 1 } else { n * f(n - 1) };\n-}\n-\n-pub fn main() {\n-    let fact = fix(fact_);\n-    assert_eq!(fact(5), 120);\n-    assert_eq!(fact(2), 2);\n-}"}, {"sha": "c7b64fde3fd5af2f4154eb31e719dce8e12ffc99", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-\n-fn fix_help<A:'static,B:Send>(f: extern fn(@fn(A) -> B, A) -> B, x: A) -> B {\n-    return f(|a| fix_help(f, a), x);\n-}\n-\n-fn fix<A:'static,B:Send>(f: extern fn(@fn(A) -> B, A) -> B) -> @fn(A) -> B {\n-    return |a| fix_help(f, a);\n-}\n-\n-fn fact_(f: @fn(v: int) -> int, n: int) -> int {\n-    // fun fact 0 = 1\n-    return if n == 0 { 1 } else { n * f(n - 1) };\n-}\n-\n-pub fn main() {\n-    let fact = fix(fact_);\n-    assert_eq!(fact(5), 120);\n-    assert_eq!(fact(2), 2);\n-}"}, {"sha": "dece77595bcd984943205b43bcdb56c69c10639e", "filename": "src/test/run-pass/fn-assign-managed-to-bare-1.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn add(n: int) -> @fn(int) -> int {\n-    let result: @fn(int) -> int = |m| m + n;\n-    result\n-}\n-\n-pub fn main() {\n-      assert_eq!(add(3)(4), 7);\n-      let add3 : &fn(int)->int = add(3);\n-      assert_eq!(add3(4), 7);\n-}"}, {"sha": "853b44ed76cb67d7df58f7924afab8d011eab57f", "filename": "src/test/run-pass/fn-bare-coerce-to-shared.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-shared.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn bare() {}\n-\n-fn likes_shared(f: @fn()) { f() }\n-\n-pub fn main() {\n-    likes_shared(bare);\n-}"}, {"sha": "ae2e353f913ba5631ece94819717d0c14250a9a1", "filename": "src/test/run-pass/fn-coerce-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct r {\n-    field: @fn()\n+struct r<'self> {\n+    field: &'self fn()\n }\n \n pub fn main() {"}, {"sha": "09e7ababa6cb6d6acff9075392e24796345f6130", "filename": "src/test/run-pass/fn-type-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Ffn-type-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Ffn-type-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-type-infer.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,7 +11,7 @@\n #[allow(unused_variable)];\n \n pub fn main() {\n-    // We should be able to type infer inside of @fns.\n+    // We should be able to type infer inside of &fns.\n     let _f = || {\n         let i = 10;\n     };"}, {"sha": "5011998f92949beb460cd00a4f30c1350804c788", "filename": "src/test/run-pass/fun-call-variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,7 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn ho(f: @fn(int) -> int) -> int { let n: int = f(3); return n; }\n+fn ho(f: &fn(int) -> int) -> int { let n: int = f(3); return n; }\n \n fn direct(x: int) -> int { return x + 1; }\n "}, {"sha": "15286a85c01b270746b85c50bc02ff328744cdf6", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -24,7 +24,7 @@ mod map_reduce {\n     use std::str;\n     use std::task;\n \n-    pub type putter = @fn(~str, ~str);\n+    pub type putter<'self> = &'self fn(~str, ~str);\n \n     pub type mapper = extern fn(~str, putter);\n "}, {"sha": "6f2fd54bc9cbc499af7613e7eb68a38c7c521d0c", "filename": "src/test/run-pass/infer-with-expected.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfer-with-expected.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Tests the passing down of expected types through boxing and\n-// wrapping in a record or tuple. (The a.x would complain about 'this\n-// type must be known in this context' if the passing down doesn't\n-// happen.)\n-\n-fn eat_tup(_r: ~@(int, @fn(Pair) -> int)) {}\n-fn eat_rec(_r: ~Rec) {}\n-\n-struct Rec<'self> { a: int, b: &'self fn(Pair) -> int }\n-struct Pair { x: int, y: int }\n-\n-pub fn main() {\n-    eat_tup(~@(10, |a| a.x ));\n-    eat_rec(~Rec{a: 10, b: |a| a.x });\n-}"}, {"sha": "4b73d83595e64c6c2ac33d71c8c46b8e75c0360f", "filename": "src/test/run-pass/issue-1516.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-1516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-1516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1516.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub fn main() {\n-    let early_error: @fn(&str) -> !  = |_msg| { fail!() };\n+    let early_error: &'static fn(&str) -> !  = |_msg| { fail!() };\n }"}, {"sha": "a1ea1b9080954d03560f92487abc63425973fe13", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -18,11 +18,11 @@\n //\n // Running /usr/local/bin/rustc:\n // issue-2185.rs:24:0: 26:1 error: conflicting implementations for a trait\n-// issue-2185.rs:24 impl iterable<uint> for @fn(&fn(uint)) {\n+// issue-2185.rs:24 impl iterable<uint> for &'static fn(&fn(uint)) {\n // issue-2185.rs:25     fn iter(&self, blk: &fn(v: uint)) { self( |i| blk(i) ) }\n // issue-2185.rs:26 }\n // issue-2185.rs:20:0: 22:1 note: note conflicting implementation here\n-// issue-2185.rs:20 impl<A> iterable<A> for @fn(&fn(A)) {\n+// issue-2185.rs:20 impl<A> iterable<A> for &'static fn(&fn(A)) {\n // issue-2185.rs:21     fn iter(&self, blk: &fn(A)) { self(blk); }\n // issue-2185.rs:22 }\n //\n@@ -42,15 +42,17 @@ trait iterable<A> {\n     fn iter(&self, blk: &fn(A));\n }\n \n-impl<A> iterable<A> for @fn(&fn(A)) {\n+impl<A> iterable<A> for &'static fn(&fn(A)) {\n     fn iter(&self, blk: &fn(A)) { self(blk); }\n }\n \n-impl iterable<uint> for @fn(&fn(uint)) {\n+impl iterable<uint> for &'static fn(&fn(uint)) {\n     fn iter(&self, blk: &fn(v: uint)) { self( |i| blk(i) ) }\n }\n \n-fn filter<A,IA:iterable<A>>(self: IA, prd: @fn(A) -> bool, blk: &fn(A)) {\n+fn filter<A,IA:iterable<A>>(self: IA,\n+                            prd: &'static fn(A) -> bool,\n+                            blk: &fn(A)) {\n     do self.iter |a| {\n         if prd(a) { blk(a) }\n     }\n@@ -73,8 +75,8 @@ fn range(lo: uint, hi: uint, it: &fn(uint)) {\n }\n \n pub fn main() {\n-    let range: @fn(&fn(uint)) = |a| range(0u, 1000u, a);\n-    let filt: @fn(&fn(v: uint)) = |a| filter(\n+    let range: &'static fn(&fn(uint)) = |a| range(0u, 1000u, a);\n+    let filt: &'static fn(&fn(v: uint)) = |a| filter(\n         range,\n         |&&n: uint| n % 3u != 0u && n % 5u != 0u,\n         a);"}, {"sha": "bde18d77b9add6edf023e34e56a14b11f636ff50", "filename": "src/test/run-pass/issue-2633.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-2633.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-2633.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2633.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,12 +9,16 @@\n // except according to those terms.\n \n struct cat {\n-    meow: @fn(),\n+    meow: extern \"Rust\" fn(),\n+}\n+\n+fn meow() {\n+    error!(\"meow\")\n }\n \n fn cat() -> cat {\n     cat {\n-        meow: || error!(\"meow\")\n+        meow: meow,\n     }\n }\n "}, {"sha": "cb1ffc389089808ca828cb83c859c636b5813363", "filename": "src/test/run-pass/issue-3052.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-3052.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-3052.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3052.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type Connection = @fn(~[u8]);\n+type Connection = &'static fn(~[u8]);\n \n fn f() -> Option<Connection> {\n     let mock_connection: Connection = |_| {};"}, {"sha": "fc493485b794e752751e9de07c5dc4ce781203dd", "filename": "src/test/run-pass/issue-3429.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-3429.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fissue-3429.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3429.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -10,6 +10,6 @@\n \n pub fn main() {\n   let x = 1;\n-  let y: @fn() -> int = || x;\n+  let y: &fn() -> int = || x;\n   let _z = y();\n }"}, {"sha": "5803c3da6cc9c5f2553a7268e2be2049159be610", "filename": "src/test/run-pass/issue-4929.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fissue-4929.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fissue-4929.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4929.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn make_adder(x: int) -> @fn(int) -> int { |y| x + y }\n-pub fn main() { }"}, {"sha": "7f988dc6489345b60b68eb156a83b215a41cbaee", "filename": "src/test/run-pass/issue-5783.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fissue-5783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fissue-5783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5783.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Issue #5783\n-// Nondeterministic behavior when referencing a closure more than once\n-\n-fn main() {\n-    let a: &fn(int) -> @fn(int) -> int = |x:int| |y:int| -> int x + y;\n-    let b = a(2);\n-    assert!(a(2)(3) == 5);\n-    assert!(b(6) == 8);\n-}"}, {"sha": "35df47df036712f6f04317148127ef10e6d98b06", "filename": "src/test/run-pass/issue4516_ty_param.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fissue4516_ty_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fissue4516_ty_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue4516_ty_param.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast - check-fast doesn't understand aux-build\n-// aux-build:issue4516_ty_param_lib.rs\n-\n-// Trigger a bug concerning inlining of generic functions.\n-// The def-ids in type parameters were not being correctly\n-// resolved and hence when we checked the type of the closure\n-// variable (see the library mod) to determine if the value\n-// should be moved into the closure, trans failed to find\n-// the relevant kind bounds.\n-\n-extern mod issue4516_ty_param_lib;\n-use issue4516_ty_param_lib::to_closure;\n-pub fn main() {\n-    to_closure(22)();\n-}"}, {"sha": "d55150e448e81a12d137a7172d8ee79711ce6168", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n // This should typecheck even though the type of e is not fully\n-// resolved when we finish typechecking the @fn.\n+// resolved when we finish typechecking the &fn.\n \n \n struct Refs { refs: ~[int], n: int }\n \n pub fn main() {\n     let e = @mut Refs{refs: ~[], n: 0};\n-    let _f: @fn() = || error!(e.n);\n+    let _f: &fn() = || error!(e.n);\n     e.refs.push(1);\n }"}, {"sha": "e19503240f024977fbd60ace033139df77e13362", "filename": "src/test/run-pass/lambda-no-leak.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Make sure we don't leak @fns in silly ways.\n-fn force(f: @fn()) { f() }\n-pub fn main() {\n-    let x = 7;\n-    let _f: @fn() = || error!(x);\n-    force(|| error!(x));\n-}"}, {"sha": "d014a3cf1a15cf4d1b4ed4e4aa8feaa86d903b89", "filename": "src/test/run-pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -12,10 +12,10 @@\n \n struct A { a: ~int }\n \n-fn foo() -> @fn() -> int {\n+fn foo() -> &'static fn() -> int {\n     let k = ~22;\n     let _u = A {a: k.clone()};\n-    let result: @fn() -> int = || 22;\n+    let result: &'static fn() -> int = || 22;\n     result\n }\n "}, {"sha": "079d2374a29ffe75f98df5aaa3c59452e8ee233c", "filename": "src/test/run-pass/last-use-is-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -13,7 +13,7 @@\n struct A { a: ~int }\n \n pub fn main() {\n-    fn invoke(f: @fn()) { f(); }\n+    fn invoke(f: &fn()) { f(); }\n     let k = ~22;\n     let _u = A {a: k.clone()};\n     invoke(|| error!(k.clone()) )"}, {"sha": "8e36b1138bd432074669521cddb0f4827eccdccd", "filename": "src/test/run-pass/monomorphize-trait-in-fn-at.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fmonomorphize-trait-in-fn-at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fmonomorphize-trait-in-fn-at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphize-trait-in-fn-at.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// test that invoking functions which require\n-// dictionaries from inside an @fn works\n-// (at one point, it didn't)\n-\n-fn mk_nil<C:ty_ops>(cx: C) -> uint {\n-    cx.mk()\n-}\n-\n-trait ty_ops {\n-    fn mk(&self) -> uint;\n-}\n-\n-impl ty_ops for () {\n-    fn mk(&self) -> uint { 22u }\n-}\n-\n-pub fn main() {\n-    let fn_env: @fn() -> uint = || mk_nil(());\n-    assert_eq!(fn_env(), 22u);\n-}"}, {"sha": "87281c2fd225314787432a573e661d0ae0348f36", "filename": "src/test/run-pass/move-nullary-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-nullary-fn.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n // Issue #922\n-fn f2(_thing: @fn()) { }\n+fn f2(_thing: &fn()) { }\n \n-fn f(thing: @fn()) {\n+fn f(thing: &fn()) {\n     f2(thing);\n }\n "}, {"sha": "919b4b59dca8e5a9abe5563a3f5046c65fe2cb6f", "filename": "src/test/run-pass/nested-enum-same-names.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fnested-enum-same-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fnested-enum-same-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-enum-same-names.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -30,20 +30,4 @@ impl Foo {\n     }\n }\n \n-/*\n-#2074 duplicate symbols with enum in boxed closure\n-*/\n-\n-fn foo() {\n-    let one: @fn() -> uint = || {\n-        enum r { a }\n-        a as uint\n-    };\n-    let two: @fn() -> uint = || {\n-        enum r { a }\n-        a as uint\n-    };\n-    one(); two();\n-}\n-\n fn main() {}"}, {"sha": "6d6757890ad3e6e0d8af6dc9c2399b4626e840e0", "filename": "src/test/run-pass/newlambdas-ret-infer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,8 +11,6 @@\n // Test that the lambda kind is inferred correctly as a return\n // expression\n \n-fn shared() -> @fn() { return || (); }\n-\n fn unique() -> ~fn() { return || (); }\n \n pub fn main() {"}, {"sha": "17ff8ce94d90ff1841bbe694186bd97bca788528", "filename": "src/test/run-pass/newlambdas-ret-infer2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -11,8 +11,6 @@\n // Test that the lambda kind is inferred correctly as a return\n // expression\n \n-fn shared() -> @fn() { || () }\n-\n fn unique() -> ~fn() { || () }\n \n pub fn main() {"}, {"sha": "d9d0daa7138cdf76873eb74e76549097d5420b4e", "filename": "src/test/run-pass/newlambdas.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fnewlambdas.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fnewlambdas.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -14,16 +14,9 @@ fn f(i: int, f: &fn(int) -> int) -> int { f(i) }\n \n fn g(_g: &fn()) { }\n \n-fn ff() -> @fn(int) -> int {\n-    return |x| x + 1;\n-}\n-\n pub fn main() {\n     assert_eq!(f(10, |a| a), 10);\n     g(||());\n     assert_eq!(do f(10) |a| { a }, 10);\n     do g() { }\n-    let _x: @fn() -> int = || 10;\n-    let _y: @fn(int) -> int = |a| a;\n-    assert_eq!(ff()(10), 11);\n }"}, {"sha": "f8f824cd596030e8e342ffec32a0b91b3da22747", "filename": "src/test/run-pass/propagate-expected-type-through-block.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fpropagate-expected-type-through-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d8446739f9633897a3d728d265ee6ac59c8fb/src%2Ftest%2Frun-pass%2Fpropagate-expected-type-through-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpropagate-expected-type-through-block.rs?ref=348d8446739f9633897a3d728d265ee6ac59c8fb", "patch": "@@ -1,12 +0,0 @@\n-// Test that expected type propagates through `{}` expressions.  If it\n-// did not, then the type of `x` would not be known and a compilation\n-// error would result.\n-\n-pub fn main() {\n-    let y = ~3;\n-    let foo: @fn(&int) -> int = {\n-        let y = y.clone();\n-        |x| *x + *y\n-    };\n-    assert_eq!(foo(@22), 25);\n-}"}, {"sha": "cf6f12a06e5f803dfe518644402bc237d46cf822", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -460,9 +460,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n-        self.align_to::<@fn()>();\n+        self.align_to::<(uint,uint)>();\n         if ! self.inner.visit_closure_ptr(ck) { return false; }\n-        self.bump_past::<@fn()>();\n+        self.bump_past::<(uint,uint)>();\n         true\n     }\n }"}, {"sha": "06c8aca4741645da3756fb932d864bc51d94732f", "filename": "src/test/run-pass/regions-fn-subtyping.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -14,21 +14,21 @@\n #[allow(unused_variable)];\n \n // Should pass region checking.\n-fn ok(f: @fn(x: &uint)) {\n+fn ok(f: &fn(x: &uint)) {\n     // Here, g is a function that can accept a uint pointer with\n     // lifetime r, and f is a function that can accept a uint pointer\n     // with any lifetime.  The assignment g = f should be OK (i.e.,\n     // f's type should be a subtype of g's type), because f can be\n     // used in any context that expects g's type.  But this currently\n     // fails.\n-    let mut g: @fn<'r>(y: &'r uint) = |x| { };\n+    let mut g: &fn<'r>(y: &'r uint) = |x| { };\n     g = f;\n }\n \n // This version is the same as above, except that here, g's type is\n // inferred.\n-fn ok_inferred(f: @fn(x: &uint)) {\n-    let mut g: @fn<'r>(x: &'r uint) = |_| {};\n+fn ok_inferred(f: &fn(x: &uint)) {\n+    let mut g: &fn<'r>(x: &'r uint) = |_| {};\n     g = f;\n }\n "}, {"sha": "6a87a6502d211f37b90d32201f5410dd476442d0", "filename": "src/test/run-pass/rl-human-test.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frl-human-test.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -22,6 +22,20 @@ use extra::rl;\n \n static HISTORY_FILE: &'static str = \"rl-human-test-history.txt\";\n \n+struct TestCompleter;\n+\n+impl rl::CompletionCb for TestCompleter {\n+    fn complete(&self, line: ~str, suggest: &fn(~str)) {\n+        if line.is_empty() {\n+            suggest(~\"empty\")\n+        } else {\n+            for c in line.rev_iter().take(3) {\n+                suggest(format!(\"{0}{1}{1}{1}\", line, c))\n+            }\n+        }\n+    }\n+}\n+\n fn main() {\n     // don't run this in robot mode, but still typecheck it.\n     if !cfg!(robot_mode) {\n@@ -42,14 +56,8 @@ The bool return values of each step are printed.\",\n \n         println!(\"restricting history length: {}\", rl::set_history_max_len(3));\n \n-        do rl::complete |line, suggest| {\n-            if line.is_empty() {\n-                suggest(~\"empty\")\n-            } else {\n-                for c in line.rev_iter().take(3) {\n-                    suggest(format!(\"{0}{1}{1}{1}\", line, c))\n-                }\n-            }\n+        unsafe {\n+            rl::complete(@TestCompleter as @rl::CompletionCb);\n         }\n \n         println!(\"adding 'one': {}\", rl::add_history(\"one\"));"}, {"sha": "662121a09931fbc50658319a1f8701b9e99a9c1f", "filename": "src/test/run-pass/unused-move-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Funused-move-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d062de8aa48083439237cb338b38c25306bf6c94/src%2Ftest%2Frun-pass%2Funused-move-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funused-move-capture.rs?ref=d062de8aa48083439237cb338b38c25306bf6c94", "patch": "@@ -10,6 +10,6 @@\n \n pub fn main() {\n     let _x = ~1;\n-    let lam_move: @fn() = || {};\n+    let lam_move: &fn() = || {};\n     lam_move();\n }"}]}