{"sha": "05eb6f36f1e17aa00ef286c2dacc9d890fdc899c", "node_id": "C_kwDOAAsO6NoAKDA1ZWI2ZjM2ZjFlMTdhYTAwZWYyODZjMmRhY2M5ZDg5MGZkYzg5OWM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-19T21:08:14Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-19T21:10:09Z"}, "message": "Cleanup dead code in hir::map::blocks.", "tree": {"sha": "51e8168d31a118f4b1f634761dbbee2fdf9cff3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51e8168d31a118f4b1f634761dbbee2fdf9cff3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05eb6f36f1e17aa00ef286c2dacc9d890fdc899c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05eb6f36f1e17aa00ef286c2dacc9d890fdc899c", "html_url": "https://github.com/rust-lang/rust/commit/05eb6f36f1e17aa00ef286c2dacc9d890fdc899c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05eb6f36f1e17aa00ef286c2dacc9d890fdc899c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2452de12046850b8d4c00ce361569b24ad3ad8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2452de12046850b8d4c00ce361569b24ad3ad8d", "html_url": "https://github.com/rust-lang/rust/commit/c2452de12046850b8d4c00ce361569b24ad3ad8d"}], "stats": {"total": 186, "additions": 14, "deletions": 172}, "files": [{"sha": "1ba205903dcffcfe978ab3fe6c2ec804a2764c7d", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 14, "deletions": 172, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/05eb6f36f1e17aa00ef286c2dacc9d890fdc899c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05eb6f36f1e17aa00ef286c2dacc9d890fdc899c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=05eb6f36f1e17aa00ef286c2dacc9d890fdc899c", "patch": "@@ -11,12 +11,9 @@\n //! nested within a uniquely determined `FnLike`), and users can ask\n //! for the `Code` associated with a particular NodeId.\n \n-use crate::hir::map::Map;\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Expr, FnDecl, Node};\n-use rustc_span::symbol::Ident;\n-use rustc_span::Span;\n+use rustc_hir::Node;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl\n /// and a body (as well as a NodeId, a span, etc).\n@@ -33,139 +30,21 @@ pub struct FnLikeNode<'a> {\n     node: Node<'a>,\n }\n \n-/// MaybeFnLike wraps a method that indicates if an object\n-/// corresponds to some FnLikeNode.\n-trait MaybeFnLike {\n-    fn is_fn_like(&self) -> bool;\n-}\n-\n-impl MaybeFnLike for hir::Item<'_> {\n-    fn is_fn_like(&self) -> bool {\n-        matches!(self.kind, hir::ItemKind::Fn(..))\n-    }\n-}\n-\n-impl MaybeFnLike for hir::ImplItem<'_> {\n-    fn is_fn_like(&self) -> bool {\n-        matches!(self.kind, hir::ImplItemKind::Fn(..))\n-    }\n-}\n-\n-impl MaybeFnLike for hir::TraitItem<'_> {\n-    fn is_fn_like(&self) -> bool {\n-        matches!(self.kind, hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)))\n-    }\n-}\n-\n-impl MaybeFnLike for hir::Expr<'_> {\n-    fn is_fn_like(&self) -> bool {\n-        matches!(self.kind, hir::ExprKind::Closure(..))\n-    }\n-}\n-\n-/// Carries either an FnLikeNode or an Expr, as these are the two\n-/// constructs that correspond to \"code\" (as in, something from which\n-/// we can construct a control-flow graph).\n-#[derive(Copy, Clone)]\n-pub enum Code<'a> {\n-    FnLike(FnLikeNode<'a>),\n-    Expr(&'a Expr<'a>),\n-}\n-\n-impl<'a> Code<'a> {\n-    pub fn id(&self) -> hir::HirId {\n-        match *self {\n-            Code::FnLike(node) => node.id(),\n-            Code::Expr(block) => block.hir_id,\n-        }\n-    }\n-\n-    /// Attempts to construct a Code from presumed FnLike or Expr node input.\n-    pub fn from_node(map: &Map<'a>, id: hir::HirId) -> Option<Code<'a>> {\n-        match map.get(id) {\n-            Node::Block(_) => {\n-                //  Use the parent, hopefully an expression node.\n-                Code::from_node(map, map.get_parent_node(id))\n-            }\n-            Node::Expr(expr) => Some(Code::Expr(expr)),\n-            node => FnLikeNode::from_node(node).map(Code::FnLike),\n-        }\n-    }\n-}\n-\n-/// These are all the components one can extract from a fn item for\n-/// use when implementing FnLikeNode operations.\n-struct ItemFnParts<'a> {\n-    ident: Ident,\n-    decl: &'a hir::FnDecl<'a>,\n-    header: hir::FnHeader,\n-    vis: &'a hir::Visibility<'a>,\n-    generics: &'a hir::Generics<'a>,\n-    body: hir::BodyId,\n-    id: hir::HirId,\n-    span: Span,\n-}\n-\n-/// These are all the components one can extract from a closure expr\n-/// for use when implementing FnLikeNode operations.\n-struct ClosureParts<'a> {\n-    decl: &'a FnDecl<'a>,\n-    body: hir::BodyId,\n-    id: hir::HirId,\n-    span: Span,\n-}\n-\n-impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl<'a>, b: hir::BodyId, id: hir::HirId, s: Span) -> Self {\n-        ClosureParts { decl: d, body: b, id, span: s }\n-    }\n-}\n-\n impl<'a> FnLikeNode<'a> {\n     /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n     pub fn from_node(node: Node<'_>) -> Option<FnLikeNode<'_>> {\n         let fn_like = match node {\n-            Node::Item(item) => item.is_fn_like(),\n-            Node::TraitItem(tm) => tm.is_fn_like(),\n-            Node::ImplItem(it) => it.is_fn_like(),\n-            Node::Expr(e) => e.is_fn_like(),\n+            Node::Item(item) => matches!(item.kind, hir::ItemKind::Fn(..)),\n+            Node::TraitItem(tm) => {\n+                matches!(tm.kind, hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)))\n+            }\n+            Node::ImplItem(it) => matches!(it.kind, hir::ImplItemKind::Fn(..)),\n+            Node::Expr(e) => matches!(e.kind, hir::ExprKind::Closure(..)),\n             _ => false,\n         };\n         fn_like.then_some(FnLikeNode { node })\n     }\n \n-    pub fn body(self) -> hir::BodyId {\n-        self.handle(\n-            |i: ItemFnParts<'a>| i.body,\n-            |_, _, _: &'a hir::FnSig<'a>, _, body: hir::BodyId, _| body,\n-            |c: ClosureParts<'a>| c.body,\n-        )\n-    }\n-\n-    pub fn decl(self) -> &'a FnDecl<'a> {\n-        self.handle(\n-            |i: ItemFnParts<'a>| &*i.decl,\n-            |_, _, sig: &'a hir::FnSig<'a>, _, _, _| &sig.decl,\n-            |c: ClosureParts<'a>| c.decl,\n-        )\n-    }\n-\n-    pub fn span(self) -> Span {\n-        self.handle(\n-            |i: ItemFnParts<'_>| i.span,\n-            |_, _, _: &'a hir::FnSig<'a>, _, _, span| span,\n-            |c: ClosureParts<'_>| c.span,\n-        )\n-    }\n-\n-    pub fn id(self) -> hir::HirId {\n-        self.handle(\n-            |i: ItemFnParts<'_>| i.id,\n-            |id, _, _: &'a hir::FnSig<'a>, _, _, _| id,\n-            |c: ClosureParts<'_>| c.id,\n-        )\n-    }\n-\n     pub fn constness(self) -> hir::Constness {\n         self.kind().header().map_or(hir::Constness::NotConst, |header| header.constness)\n     }\n@@ -174,63 +53,26 @@ impl<'a> FnLikeNode<'a> {\n         self.kind().header().map_or(hir::IsAsync::NotAsync, |header| header.asyncness)\n     }\n \n-    pub fn unsafety(self) -> hir::Unsafety {\n-        self.kind().header().map_or(hir::Unsafety::Normal, |header| header.unsafety)\n-    }\n-\n     pub fn kind(self) -> FnKind<'a> {\n-        let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n-            FnKind::ItemFn(p.ident, p.generics, p.header, p.vis)\n-        };\n-        let closure = |_: ClosureParts<'a>| FnKind::Closure;\n-        let method =\n-            |_, ident: Ident, sig: &'a hir::FnSig<'a>, vis, _, _| FnKind::Method(ident, sig, vis);\n-        self.handle(item, method, closure)\n-    }\n-\n-    fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A\n-    where\n-        I: FnOnce(ItemFnParts<'a>) -> A,\n-        M: FnOnce(\n-            hir::HirId,\n-            Ident,\n-            &'a hir::FnSig<'a>,\n-            Option<&'a hir::Visibility<'a>>,\n-            hir::BodyId,\n-            Span,\n-        ) -> A,\n-        C: FnOnce(ClosureParts<'a>) -> A,\n-    {\n         match self.node {\n             Node::Item(i) => match i.kind {\n-                hir::ItemKind::Fn(ref sig, ref generics, block) => item_fn(ItemFnParts {\n-                    id: i.hir_id(),\n-                    ident: i.ident,\n-                    decl: &sig.decl,\n-                    body: block,\n-                    vis: &i.vis,\n-                    span: i.span,\n-                    header: sig.header,\n-                    generics,\n-                }),\n+                hir::ItemKind::Fn(ref sig, ref generics, _) => {\n+                    FnKind::ItemFn(i.ident, generics, sig.header, &i.vis)\n+                }\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             Node::TraitItem(ti) => match ti.kind {\n-                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    method(ti.hir_id(), ti.ident, sig, None, body, ti.span)\n+                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(_)) => {\n+                    FnKind::Method(ti.ident, sig, None)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             Node::ImplItem(ii) => match ii.kind {\n-                hir::ImplItemKind::Fn(ref sig, body) => {\n-                    method(ii.hir_id(), ii.ident, sig, Some(&ii.vis), body, ii.span)\n-                }\n+                hir::ImplItemKind::Fn(ref sig, _) => FnKind::Method(ii.ident, sig, Some(&ii.vis)),\n                 _ => bug!(\"impl method FnLikeNode that is not fn-like\"),\n             },\n             Node::Expr(e) => match e.kind {\n-                hir::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) => {\n-                    closure(ClosureParts::new(&decl, block, e.hir_id, e.span))\n-                }\n+                hir::ExprKind::Closure(..) => FnKind::Closure,\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}]}