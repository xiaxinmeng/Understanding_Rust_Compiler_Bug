{"sha": "3b272bf3102afd739d3e7284b898fa42fa1bd64e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMjcyYmYzMTAyYWZkNzM5ZDNlNzI4NGI4OThmYTQyZmExYmQ2NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-06T23:45:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-06T23:45:41Z"}, "message": "Auto merge of #36303 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 8 pull requests\n\n- Successful merges: #36121, #36128, #36241, #36243, #36263, #36267, #36273, #36298\n- Failed merges:", "tree": {"sha": "9f67bd69a4b367cf1917eeecab56f048fc55994b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f67bd69a4b367cf1917eeecab56f048fc55994b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b272bf3102afd739d3e7284b898fa42fa1bd64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b272bf3102afd739d3e7284b898fa42fa1bd64e", "html_url": "https://github.com/rust-lang/rust/commit/3b272bf3102afd739d3e7284b898fa42fa1bd64e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b272bf3102afd739d3e7284b898fa42fa1bd64e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "923bac45964940c56ab1075fb7980896de1eb620", "url": "https://api.github.com/repos/rust-lang/rust/commits/923bac45964940c56ab1075fb7980896de1eb620", "html_url": "https://github.com/rust-lang/rust/commit/923bac45964940c56ab1075fb7980896de1eb620"}, {"sha": "20cce247e11f5fd84edc4861f59d614d805362e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/20cce247e11f5fd84edc4861f59d614d805362e3", "html_url": "https://github.com/rust-lang/rust/commit/20cce247e11f5fd84edc4861f59d614d805362e3"}], "stats": {"total": 252, "additions": 155, "deletions": 97}, "files": [{"sha": "4c0f93c3703a59259014e294ee1acaa9faa4b1d6", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -151,6 +151,10 @@ Some common make targets are:\n   command above as we only build the stage1 compiler, not the entire thing).\n   You can also leave off the `-rpass` to run all stage1 test types.\n - `make check-stage1-coretest` - Run stage1 tests in `libcore`.\n+- `make tidy` - Check that the source code is in compliance with Rust's style\n+  guidelines. There is no official document describing Rust's full guidelines \n+  as of yet, but basic rules like 4 spaces for indentation and no more than 99\n+  characters in a single line should be kept in mind when writing code.\n \n ## Pull Requests\n \n@@ -177,6 +181,15 @@ you\u2019re adding something to the standard library, try\n \n This will not rebuild the compiler, but will run the tests.\n \n+Please make sure your pull request is in compliance with Rust's style\n+guidelines by running\n+\n+    $ make tidy\n+\n+Make this check before every pull request (and every new commit in a pull\n+request) ; you can add [git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)\n+before every push to make sure you never forget to make this check.\n+\n All pull requests are reviewed by another person. We have a bot,\n @rust-highfive, that will automatically assign a random person to review your\n request."}, {"sha": "adede0ec911171be9fa22081c08fdfdadf398599", "filename": "src/doc/nomicon/safe-unsafe-meaning.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -26,10 +26,6 @@ can therefore be trusted. You can use `unsafe` on a trait implementation\n to declare that the implementation of that trait has adhered to whatever\n contracts the trait's documentation requires.\n \n-There is also the `#[unsafe_no_drop_flag]` attribute, which exists for\n-historic reasons and is being phased out. See the section on [drop flags]\n-for details.\n-\n The standard library has a number of unsafe functions, including:\n \n * `slice::get_unchecked`, which performs unchecked indexing, allowing"}, {"sha": "f29cdf6b08035cebb38704c5c286bab7866cf864", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -2059,10 +2059,6 @@ macro scope.\n   outside of its dynamic extent), and thus this attribute has the word\n   \"unsafe\" in its name. To use this, the\n   `unsafe_destructor_blind_to_params` feature gate must be enabled.\n-- `unsafe_no_drop_flag` - on structs, remove the flag that prevents\n-  destructors from being run twice. Destructors might be run multiple times on\n-  the same object with this attribute. To use this, the `unsafe_no_drop_flag` feature\n-  gate must be enabled.\n - `doc` - Doc comments such as `/// foo` are equivalent to `#[doc = \"foo\"]`.\n - `rustc_on_unimplemented` - Write a custom note to be shown along with the error\n    when the trait is found to be unimplemented on a type.\n@@ -2458,12 +2454,6 @@ The currently implemented features of the reference compiler are:\n * `unboxed_closures` - Rust's new closure design, which is currently a work in\n                        progress feature with many known bugs.\n \n-* `unsafe_no_drop_flag` - Allows use of the `#[unsafe_no_drop_flag]` attribute,\n-                          which removes hidden flag added to a type that\n-                          implements the `Drop` trait. The design for the\n-                          `Drop` flag is subject to change, and this feature\n-                          may be removed in the future.\n-\n * `unmarked_api` - Allows use of items within a `#![staged_api]` crate\n                    which have not been marked with a stability marker.\n                    Such items should not be allowed by the compiler to exist,"}, {"sha": "624083a8eaf350fde080e20959f8a5a07d7e8063", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -56,8 +56,12 @@ use self::Entry::*;\n /// however, performance is excellent.\n ///\n /// It is a logic error for a key to be modified in such a way that the key's ordering relative to\n-/// any other key, as determined by the `Ord` trait, changes while it is in the map. This is\n-/// normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+/// any other key, as determined by the [`Ord`] trait, changes while it is in the map. This is\n+/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n+///\n+/// [`Ord`]: ../../std/cmp/trait.Ord.html\n+/// [`Cell`]: ../../std/cell/struct.Cell.html\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n ///\n /// # Examples\n ///\n@@ -2020,7 +2024,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n         self.key\n     }\n \n-    /// Sets the value of the entry with the VacantEntry's key,\n+    /// Sets the value of the entry with the `VacantEntry`'s key,\n     /// and returns a mutable reference to it.\n     ///\n     /// # Examples\n@@ -2192,7 +2196,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.handle.into_kv_mut().1\n     }\n \n-    /// Sets the value of the entry with the OccupiedEntry's key,\n+    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n     /// and returns the entry's old value.\n     ///\n     /// # Examples"}, {"sha": "8ba52cdb64f5fd83a6c274f2dfa3720f676fdfdd", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -42,7 +42,9 @@ struct CheckAttrVisitor<'a> {\n impl<'a> CheckAttrVisitor<'a> {\n     fn check_inline(&self, attr: &ast::Attribute, target: Target) {\n         if target != Target::Fn {\n-            span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\");\n+            struct_span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\")\n+                .span_label(attr.span, &format!(\"requires a function\"))\n+                .emit();\n         }\n     }\n \n@@ -56,18 +58,20 @@ impl<'a> CheckAttrVisitor<'a> {\n \n         let mut conflicting_reprs = 0;\n         for word in words {\n+\n             let name = match word.name() {\n                 Some(word) => word,\n                 None => continue,\n             };\n \n-            let message = match &*name {\n+            let (message, label) = match &*name {\n                 \"C\" => {\n                     conflicting_reprs += 1;\n                     if target != Target::Struct &&\n                             target != Target::Union &&\n                             target != Target::Enum {\n-                        \"attribute should be applied to struct, enum or union\"\n+                                (\"attribute should be applied to struct, enum or union\",\n+                                 \"a struct, enum or union\")\n                     } else {\n                         continue\n                     }\n@@ -77,15 +81,17 @@ impl<'a> CheckAttrVisitor<'a> {\n                     // can be used to modify another repr hint\n                     if target != Target::Struct &&\n                             target != Target::Union {\n-                        \"attribute should be applied to struct or union\"\n+                                (\"attribute should be applied to struct or union\",\n+                                 \"a struct or union\")\n                     } else {\n                         continue\n                     }\n                 }\n                 \"simd\" => {\n                     conflicting_reprs += 1;\n                     if target != Target::Struct {\n-                        \"attribute should be applied to struct\"\n+                        (\"attribute should be applied to struct\",\n+                         \"a struct\")\n                     } else {\n                         continue\n                     }\n@@ -95,15 +101,17 @@ impl<'a> CheckAttrVisitor<'a> {\n                 \"isize\" | \"usize\" => {\n                     conflicting_reprs += 1;\n                     if target != Target::Enum {\n-                        \"attribute should be applied to enum\"\n+                        (\"attribute should be applied to enum\",\n+                         \"an enum\")\n                     } else {\n                         continue\n                     }\n                 }\n                 _ => continue,\n             };\n-\n-            span_err!(self.sess, attr.span, E0517, \"{}\", message);\n+            struct_span_err!(self.sess, attr.span, E0517, \"{}\", message)\n+                .span_label(attr.span, &format!(\"requires {}\", label))\n+                .emit();\n         }\n         if conflicting_reprs > 1 {\n             span_warn!(self.sess, attr.span, E0566,"}, {"sha": "334b7a5063a3a0902383479c94ccf927a62b1487", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -1769,8 +1769,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n             hir::TyTypeof(ref _e) => {\n-                span_err!(tcx.sess, ast_ty.span, E0516,\n-                      \"`typeof` is a reserved keyword but unimplemented\");\n+                struct_span_err!(tcx.sess, ast_ty.span, E0516,\n+                                 \"`typeof` is a reserved keyword but unimplemented\")\n+                    .span_label(ast_ty.span, &format!(\"reserved keyword\"))\n+                    .emit();\n+\n                 tcx.types.err\n             }\n             hir::TyInfer => {"}, {"sha": "17fb68339198242133bcdc7dfd5e98a7288cd086", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -233,9 +233,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let min_len = before.len() + after.len();\n                         if slice.is_none() {\n                             if min_len != size {\n-                                span_err!(tcx.sess, pat.span, E0527,\n-                                          \"pattern requires {} elements but array has {}\",\n-                                          min_len, size);\n+                                struct_span_err!(\n+                                    tcx.sess, pat.span, E0527,\n+                                    \"pattern requires {} elements but array has {}\",\n+                                    min_len, size)\n+                                    .span_label(pat.span, &format!(\"expected {} elements\",size))\n+                                    .emit();\n                             }\n                             (inner_ty, tcx.types.err)\n                         } else if let Some(rest) = size.checked_sub(min_len) {"}, {"sha": "b059c2ab9f3a8d0f6f41b45d5c9b4f941275749e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -118,7 +118,6 @@ use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, Span};\n-use errors::DiagnosticBuilder;\n \n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n@@ -2959,7 +2958,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }, expr_t);\n             match expr_t.sty {\n                 ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n-                    Self::suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n+                    if let Some(suggested_field_name) =\n+                        Self::suggest_field_name(def.struct_variant(), field, vec![]) {\n+                        err.span_help(field.span,\n+                                      &format!(\"did you mean `{}`?\", suggested_field_name));\n+                    };\n                 }\n                 ty::TyRawPtr(..) => {\n                     err.note(&format!(\"`{0}` is a native pointer; perhaps you need to deref with \\\n@@ -2972,11 +2975,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // displays hints about the closest matches in field names\n-    fn suggest_field_names(err: &mut DiagnosticBuilder,\n-                           variant: ty::VariantDef<'tcx>,\n-                           field: &Spanned<ast::Name>,\n-                           skip : Vec<InternedString>) {\n+    // Return an hint about the closest match in field names\n+    fn suggest_field_name(variant: ty::VariantDef<'tcx>,\n+                          field: &Spanned<ast::Name>,\n+                          skip : Vec<InternedString>)\n+                          -> Option<InternedString> {\n         let name = field.node.as_str();\n         let names = variant.fields.iter().filter_map(|field| {\n             // ignore already set fields and private fields from non-local crates\n@@ -2989,10 +2992,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         });\n \n         // only find fits with at least one matching letter\n-        if let Some(name) = find_best_match_for_name(names, &name, Some(name.len())) {\n-            err.span_help(field.span,\n-                          &format!(\"did you mean `{}`?\", name));\n-        }\n+        find_best_match_for_name(names, &name, Some(name.len()))\n     }\n \n     // Check tuple index expressions\n@@ -3086,7 +3086,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty);\n         // prevent all specified fields from being suggested\n         let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n-        Self::suggest_field_names(&mut err, variant, &field.name, skip_fields.collect());\n+        if let Some(field_name) = Self::suggest_field_name(variant,\n+                                                           &field.name,\n+                                                           skip_fields.collect()) {\n+            err.span_label(field.name.span,&format!(\"did you mean `{}`?\",field_name));\n+        };\n         err.emit();\n     }\n "}, {"sha": "4eb2c8f064414733e3869044c4511fdffce0d78f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -206,7 +206,7 @@ fn test_resize_policy() {\n /// require this behavior you can create your own hashing function using\n /// [BuildHasherDefault](../hash/struct.BuildHasherDefault.html).\n ///\n-/// It is required that the keys implement the `Eq` and `Hash` traits, although\n+/// It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n /// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n /// If you implement these yourself, it is important that the following\n /// property holds:\n@@ -218,9 +218,9 @@ fn test_resize_policy() {\n /// In other words, if two keys are equal, their hashes must be equal.\n ///\n /// It is a logic error for a key to be modified in such a way that the key's\n-/// hash, as determined by the `Hash` trait, or its equality, as determined by\n-/// the `Eq` trait, changes while it is in the map. This is normally only\n-/// possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+/// hash, as determined by the [`Hash`] trait, or its equality, as determined by\n+/// the [`Eq`] trait, changes while it is in the map. This is normally only\n+/// possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n /// Relevant papers/articles:\n ///\n@@ -298,8 +298,14 @@ fn test_resize_policy() {\n /// *stat += random_stat_buff();\n /// ```\n ///\n-/// The easiest way to use `HashMap` with a custom type as key is to derive `Eq` and `Hash`.\n-/// We must also derive `PartialEq`.\n+/// The easiest way to use `HashMap` with a custom type as key is to derive [`Eq`] and [`Hash`].\n+/// We must also derive [`PartialEq`].\n+///\n+/// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Cell`]: ../../std/cell/struct.Cell.html\n ///\n /// ```\n /// use std::collections::HashMap;\n@@ -525,7 +531,7 @@ impl<K, V, S> HashMap<K, V, S>\n }\n \n impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n-    /// Creates an empty HashMap.\n+    /// Creates an empty `HashMap`.\n     ///\n     /// # Examples\n     ///\n@@ -539,7 +545,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n \n-    /// Creates an empty hash map with the given initial capacity.\n+    /// Creates an empty `HashMap` with the given initial capacity.\n     ///\n     /// # Examples\n     ///\n@@ -557,7 +563,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n impl<K, V, S> HashMap<K, V, S>\n     where K: Eq + Hash, S: BuildHasher\n {\n-    /// Creates an empty hashmap which will use the given hash builder to hash\n+    /// Creates an empty `HashMap` which will use the given hash builder to hash\n     /// keys.\n     ///\n     /// The created map has the default initial capacity.\n@@ -587,7 +593,7 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Creates an empty HashMap with space for at least `capacity`\n+    /// Creates an empty `HashMap` with space for at least `capacity`\n     /// elements, using `hasher` to hash the keys.\n     ///\n     /// Warning: `hasher` is normally randomly generated, and\n@@ -677,7 +683,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Resizes the internal vectors to a new capacity. It's your responsibility to:\n     ///   1) Make sure the new capacity is enough for all the elements, accounting\n     ///      for the load factor.\n-    ///   2) Ensure new_capacity is a power of two or zero.\n+    ///   2) Ensure `new_capacity` is a power of two or zero.\n     fn resize(&mut self, new_capacity: usize) {\n         assert!(self.table.size() <= new_capacity);\n         assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n@@ -1040,9 +1046,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1063,9 +1072,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Returns true if the map contains a value for the specified key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1086,9 +1098,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1143,9 +1158,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// was previously in the map.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1904,12 +1922,15 @@ impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\n     }\n }\n \n-/// `RandomState` is the default state for `HashMap` types.\n+/// `RandomState` is the default state for [`HashMap`] types.\n ///\n /// A particular instance `RandomState` will create the same instances of\n-/// `Hasher`, but the hashers created by two different `RandomState`\n+/// [`Hasher`], but the hashers created by two different `RandomState`\n /// instances are unlikely to produce the same result for the same values.\n ///\n+/// [`HashMap`]: struct.HashMap.html\n+/// [`Hasher`]: ../../hash/trait.Hasher.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -1980,10 +2001,13 @@ impl BuildHasher for RandomState {\n     }\n }\n \n-/// The default `Hasher` used by `RandomState`.\n+/// The default [`Hasher`] used by [`RandomState`].\n ///\n /// The internal algorithm is not specified, and so it and its hashes should\n /// not be relied upon over releases.\n+///\n+/// [`RandomState`]: struct.RandomState.html\n+/// [`Hasher`]: ../../hash/trait.Hasher.html\n #[unstable(feature = \"hashmap_default_hasher\", issue = \"0\")]\n pub struct DefaultHasher(SipHasher13);\n "}, {"sha": "d8e021bb04ff9d9aeaead09365b762e20c7401cf", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -135,29 +135,24 @@\n //!\n //! ## Thread-local storage\n //!\n-//! This module also provides an implementation of thread local storage for Rust\n-//! programs. Thread local storage is a method of storing data into a global\n-//! variable which each thread in the program will have its own copy of.\n+//! This module also provides an implementation of thread-local storage for Rust\n+//! programs. Thread-local storage is a method of storing data into a global\n+//! variable that each thread in the program will have its own copy of.\n //! Threads do not share this data, so accesses do not need to be synchronized.\n //!\n-//! At a high level, this module provides two variants of storage:\n-//!\n-//! * Owned thread-local storage. This is a type of thread local key which\n-//!   owns the value that it contains, and will destroy the value when the\n-//!   thread exits. This variant is created with the `thread_local!` macro and\n-//!   can contain any value which is `'static` (no borrowed pointers).\n-//!\n-//! * Scoped thread-local storage. This type of key is used to store a reference\n-//!   to a value into local storage temporarily for the scope of a function\n-//!   call. There are no restrictions on what types of values can be placed\n-//!   into this key.\n-//!\n-//! Both forms of thread local storage provide an accessor function, `with`,\n-//! which will yield a shared reference to the value to the specified\n-//! closure. Thread-local keys only allow shared access to values as there is no\n-//! way to guarantee uniqueness if a mutable borrow was allowed. Most values\n+//! A thread-local key owns the value it contains and will destroy the value when the\n+//! thread exits. It is created with the [`thread_local!`] macro and can contain any\n+//! value that is `'static` (no borrowed pointers). It provides an accessor function,\n+//! [`with`], that yields a shared reference to the value to the specified\n+//! closure. Thread-local keys allow only shared access to values, as there would be no\n+//! way to guarantee uniqueness if mutable borrows were allowed. Most values\n //! will want to make use of some form of **interior mutability** through the\n-//! `Cell` or `RefCell` types.\n+//! [`Cell`] or [`RefCell`] types.\n+//!\n+//! [`Cell`]: ../cell/struct.Cell.html\n+//! [`RefCell`]: ../cell/struct.RefCell.html\n+//! [`thread_local!`]: ../macro.thread_local!.html\n+//! [`with`]: struct.LocalKey.html#method.with\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "be2b89c5f396eb05f943c50ac6ed11bd76b6c9a8", "filename": "src/test/compile-fail/E0516.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0516.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let x: typeof(92) = 92; //~ ERROR E0516\n+                            //~| reserved keyword\n }"}, {"sha": "b79cb2c44af3958e610d3e353c05b17a1da70007", "filename": "src/test/compile-fail/E0517.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0517.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0517.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0517.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -9,15 +9,19 @@\n // except according to those terms.\n \n #[repr(C)] //~ ERROR E0517\n+           //~| requires a struct, enum or union\n type Foo = u8;\n \n #[repr(packed)] //~ ERROR E0517\n+                //~| requires a struct\n enum Foo2 {Bar, Baz}\n \n #[repr(u8)] //~ ERROR E0517\n+            //~| requires an enum\n struct Foo3 {bar: bool, baz: bool}\n \n #[repr(C)] //~ ERROR E0517\n+           //~| requires a struct, enum or union\n impl Foo3 {\n }\n "}, {"sha": "f9494e0bcb5310bcd385c879d095c9cbce4cb007", "filename": "src/test/compile-fail/E0518.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0518.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0518.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0518.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -9,9 +9,11 @@\n // except according to those terms.\n \n #[inline(always)] //~ ERROR E0518\n+                  //~| requires a function\n struct Foo;\n \n #[inline(never)] //~ ERROR E0518\n+                 //~| requires a function\n impl Foo {\n }\n "}, {"sha": "0b664094a40d7f0d1c5d9a8c8e6d5359b76fcd96", "filename": "src/test/compile-fail/E0527.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0527.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0527.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0527.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -13,7 +13,9 @@\n fn main() {\n     let r = &[1, 2, 3, 4];\n     match r {\n-        &[a, b] => { //~ ERROR E0527\n+        &[a, b] => {\n+            //~^ ERROR E0527\n+            //~| NOTE expected 4 elements\n             println!(\"a={}, b={}\", a, b);\n         }\n     }"}, {"sha": "aeeeae42228138cd473ea090cb2f1a7b51d9cf16", "filename": "src/test/compile-fail/E0559.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2FE0559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0559.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -13,5 +13,7 @@ enum Field {\n }\n \n fn main() {\n-    let s = Field::Fool { joke: 0 }; //~ ERROR E0559\n+    let s = Field::Fool { joke: 0 };\n+    //~^ ERROR E0559\n+    //~| NOTE did you mean `x`?\n }"}, {"sha": "f25f01af33fd1f5e63f87ee6ab29e74fbc2626a0", "filename": "src/test/compile-fail/struct-fields-hints-no-dupe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -17,8 +17,9 @@ struct A {\n fn main() {\n     let a = A {\n         foo : 5,\n-        bar : 42,//~ ERROR struct `A` has no field named `bar`\n-        //~^ HELP did you mean `barr`?\n+        bar : 42,\n+        //~^ ERROR struct `A` has no field named `bar`\n+        //~| NOTE did you mean `barr`?\n         car : 9,\n     };\n }"}, {"sha": "62ec6e6b0d2494b24d3d5e61e0562957877f01ea", "filename": "src/test/compile-fail/struct-fields-hints.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -17,7 +17,8 @@ struct A {\n fn main() {\n     let a = A {\n         foo : 5,\n-        bar : 42,//~ ERROR struct `A` has no field named `bar`\n-        //~^ HELP did you mean `car`?\n+        bar : 42,\n+        //~^ ERROR struct `A` has no field named `bar`\n+        //~| NOTE did you mean `car`?\n     };\n }"}, {"sha": "906bfc78498e43ef1e2c5ad837c86a0fb16aa56c", "filename": "src/test/compile-fail/suggest-private-fields.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -22,16 +22,20 @@ struct A {\n fn main () {\n     // external crate struct\n     let k = B {\n-        aa: 20, //~ ERROR struct `xc::B` has no field named `aa`\n-        //~^ HELP did you mean `a`?\n-        bb: 20, //~ ERROR struct `xc::B` has no field named `bb`\n-        //~^ HELP did you mean `a`?\n+        aa: 20,\n+        //~^ ERROR struct `xc::B` has no field named `aa`\n+        //~| NOTE did you mean `a`?\n+        bb: 20,\n+        //~^ ERROR struct `xc::B` has no field named `bb`\n+        //~| NOTE did you mean `a`?\n     };\n     // local crate struct\n     let l = A {\n-        aa: 20, //~ ERROR struct `A` has no field named `aa`\n-        //~^ HELP did you mean `a`?\n-        bb: 20, //~ ERROR struct `A` has no field named `bb`\n-        //~^ HELP did you mean `b`?\n+        aa: 20,\n+        //~^ ERROR struct `A` has no field named `aa`\n+        //~| NOTE did you mean `a`?\n+        bb: 20,\n+        //~^ ERROR struct `A` has no field named `bb`\n+        //~| NOTE did you mean `b`?\n     };\n }"}, {"sha": "92811b6b5be117e99407981cbb119e0cbf707536", "filename": "src/test/compile-fail/union/union-suggest-field.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b272bf3102afd739d3e7284b898fa42fa1bd64e/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs?ref=3b272bf3102afd739d3e7284b898fa42fa1bd64e", "patch": "@@ -19,8 +19,9 @@ impl U {\n }\n \n fn main() {\n-    let u = U { principle: 0 }; //~ ERROR union `U` has no field named `principle`\n-                                //~^ HELP did you mean `principal`?\n+    let u = U { principle: 0 };\n+    //~^ ERROR union `U` has no field named `principle`\n+    //~| NOTE did you mean `principal`?\n     let w = u.principial; //~ ERROR attempted access of field `principial` on type `U`\n                           //~^ HELP did you mean `principal`?\n "}]}