{"sha": "0255bf30ea86d0c925403ad3cb3d4c2c662ad424", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNTViZjMwZWE4NmQwYzkyNTQwM2FkM2NiM2Q0YzJjNjYyYWQ0MjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-06T17:35:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-06T17:35:44Z"}, "message": "continue refactoring to remove commutativity assumption\nand introduce more indirection where it may be needed", "tree": {"sha": "9118e0491b6844d6544d0289d55358e59e1384b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9118e0491b6844d6544d0289d55358e59e1384b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0255bf30ea86d0c925403ad3cb3d4c2c662ad424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0255bf30ea86d0c925403ad3cb3d4c2c662ad424", "html_url": "https://github.com/rust-lang/rust/commit/0255bf30ea86d0c925403ad3cb3d4c2c662ad424", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0255bf30ea86d0c925403ad3cb3d4c2c662ad424/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "586b072eef6354d1c7b5e0a8fba43842826074c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/586b072eef6354d1c7b5e0a8fba43842826074c6", "html_url": "https://github.com/rust-lang/rust/commit/586b072eef6354d1c7b5e0a8fba43842826074c6"}], "stats": {"total": 440, "additions": 275, "deletions": 165}, "files": [{"sha": "80d7411e15b2ae1a8a4ba5c5dedb029da06db8d7", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 275, "deletions": 165, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/0255bf30ea86d0c925403ad3cb3d4c2c662ad424/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0255bf30ea86d0c925403ad3cb3d4c2c662ad424/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=0255bf30ea86d0c925403ad3cb3d4c2c662ad424", "patch": "@@ -175,11 +175,11 @@ impl of st for ty::t {\n     }\n \n     fn lub(infcx: infer_ctxt, b: ty::t) -> cres<ty::t> {\n-        lub(infcx).c_tys(self, b)\n+        lub(infcx).tys(self, b)\n     }\n \n     fn glb(infcx: infer_ctxt, b: ty::t) -> cres<ty::t> {\n-        glb(infcx).c_tys(self, b)\n+        glb(infcx).tys(self, b)\n     }\n }\n \n@@ -189,11 +189,11 @@ impl of st for ty::region {\n     }\n \n     fn lub(infcx: infer_ctxt, b: ty::region) -> cres<ty::region> {\n-        lub(infcx).c_regions(self, b)\n+        lub(infcx).regions(self, b)\n     }\n \n     fn glb(infcx: infer_ctxt, b: ty::region) -> cres<ty::region> {\n-        glb(infcx).c_regions(self, b)\n+        glb(infcx).regions(self, b)\n     }\n }\n \n@@ -489,7 +489,7 @@ impl unify_methods for infer_ctxt {\n               }\n \n               _ {\n-                lub(self).c_regions(a, b).chain {|r|\n+                lub(self).regions(a, b).chain {|r|\n                     if b == r {\n                         self.uok()\n                     } else {\n@@ -949,7 +949,7 @@ impl resolve_methods for infer_ctxt {\n //\n // The `c_X()` top-level items work for *both LUB and GLB*: any\n // operation which varies between LUB and GLB will be dynamically\n-// dispatched using a `self.c_Y()` operation.\n+// dispatched using a `self.Y()` operation.\n //\n // In principle, the subtyping relation computed above could be built\n // on the combine framework---this would result in less code but would\n@@ -966,38 +966,50 @@ iface combine {\n     fn tag() -> str;\n     fn bnd<V:copy>(b: bounds<V>) -> option<V>;\n     fn with_bnd<V:copy>(b: bounds<V>, v: V) -> bounds<V>;\n-    fn c_bot_ty(b: ty::t) -> cres<ty::t>;\n-    fn c_ty_bot(b: ty::t) -> cres<ty::t>;\n-    fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n-    fn c_contratys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n-    fn c_tys(t1: ty::t, t2: ty::t) -> cres<ty::t>;\n-    fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto>;\n-    fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n+\n+    fn bot_ty(b: ty::t) -> cres<ty::t>;\n+    fn ty_bot(b: ty::t) -> cres<ty::t>;\n+    fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n+    fn contratys(a: ty::t, b: ty::t) -> cres<ty::t>;\n+    fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n+    fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]>;\n+    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty>;\n+    fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n+    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n+    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n+    fn protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto>;\n+    fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style>;\n+    fn tvars(a: ty::ty_vid, b: ty::ty_vid) -> cres<ty::t>;\n+    fn tvar_ty(a: ty::ty_vid, b: ty::t) -> cres<ty::t>;\n+    fn ty_tvar(a: ty::t, b: ty::ty_vid) -> cres<ty::t>;\n \n     // Combining regions (along with some specific cases that are\n     // different for LUB/GLB):\n-    fn c_contraregions(\n+    fn contraregions(\n         a: ty::region, b: ty::region) -> cres<ty::region>;\n-    fn c_regions(\n+    fn regions(\n         a: ty::region, b: ty::region) -> cres<ty::region>;\n-    fn c_regions_static_r(r: ty::region) -> cres<ty::region>;\n-    fn c_regions_r_static(r: ty::region) -> cres<ty::region>;\n-    fn c_regions_scope_scope(\n+    fn regions_static_r(r: ty::region) -> cres<ty::region>;\n+    fn regions_r_static(r: ty::region) -> cres<ty::region>;\n+    fn regions_scope_scope(\n         a: ty::region, a_id: ast::node_id,\n         b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n-    fn c_regions_scope_free(\n+    fn regions_scope_free(\n         a: ty::region, a_id: ast::node_id,\n         b: ty::region, b_id: ast::node_id, b_br: ty::bound_region)\n         -> cres<ty::region>;\n-    fn c_regions_free_scope(\n+    fn regions_free_scope(\n         a: ty::region, a_id: ast::node_id, a_br: ty::bound_region,\n         b: ty::region, b_id: ast::node_id) -> cres<ty::region>;\n+    fn rvars(a: ty::region_vid, b: ty::region_vid) -> cres<ty::region>;\n+    fn rvar_r(a: ty::region_vid, b: ty::region) -> cres<ty::region>;\n+    fn r_rvar(a: ty::region, b: ty::region_vid) -> cres<ty::region>;\n }\n \n enum lub = infer_ctxt;\n enum glb = infer_ctxt;\n \n-fn c_vars<V:copy vid, C:combine, T:copy to_str st>(\n+fn super_vars<V:copy vid, C:combine, T:copy to_str st>(\n     self: C, vb: vals_and_bindings<V, T>,\n     a_t: T, a_vid: V, b_vid: V,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n@@ -1010,7 +1022,7 @@ fn c_vars<V:copy vid, C:combine, T:copy to_str st>(\n     let {root: a_vid, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n     let {root: b_vid, bounds: b_bounds} = self.infcx().get(vb, b_vid);\n \n-    #debug[\"%s.c_vars(%s=%s <: %s=%s)\",\n+    #debug[\"%s.vars(%s=%s <: %s=%s)\",\n            self.tag(),\n            a_vid.to_str(), a_bounds.to_str(self.infcx()),\n            b_vid.to_str(), b_bounds.to_str(self.infcx())];\n@@ -1039,7 +1051,7 @@ fn c_vars<V:copy vid, C:combine, T:copy to_str st>(\n     }\n }\n \n-fn c_var_t<V:copy vid, C:combine, T:copy to_str st>(\n+fn super_var_t<V:copy vid, C:combine, T:copy to_str st>(\n     self: C, vb: vals_and_bindings<V, T>,\n     a_vid: V, b: T,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n@@ -1049,7 +1061,7 @@ fn c_var_t<V:copy vid, C:combine, T:copy to_str st>(\n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    #debug[\"%s.c_var_ty(%s=%s <: %s)\",\n+    #debug[\"%s.var_ty(%s=%s <: %s)\",\n            self.tag(),\n            a_id.to_str(), a_bounds.to_str(self.infcx()),\n            b.to_str(self.infcx())];\n@@ -1073,78 +1085,64 @@ fn c_var_t<V:copy vid, C:combine, T:copy to_str st>(\n     }\n }\n \n-fn c_tuptys<C:combine>(self: C, as: [ty::t], bs: [ty::t])\n+fn super_tps<C:combine>(\n+    self: C, as: [ty::t], bs: [ty::t])\n     -> cres<[ty::t]> {\n \n-    if check vec::same_length(as, bs) {\n-        map2(as, bs) {|a, b| self.c_tys(a, b) }\n-    } else {\n-        err(ty::terr_tuple_size(bs.len(), as.len()))\n-    }\n-}\n-\n-fn c_tps<C:combine>(self: C, _did: ast::def_id, as: [ty::t], bs: [ty::t])\n-    -> cres<[ty::t]> {\n     self.infcx().tps(as, bs).then {||\n         ok(as)\n     }\n }\n \n-fn c_fieldvecs<C:combine>(self: C, as: [ty::field], bs: [ty::field])\n-    -> cres<[ty::field]> {\n+fn super_flds<C:combine>(\n+    self: C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n-    if check vec::same_length(as, bs) {\n-        map2(as, bs) {|a,b| c_flds(self, a, b) }\n-    } else {\n-        err(ty::terr_record_size(bs.len(), as.len()))\n-    }\n-}\n-\n-fn c_flds<C:combine>(self: C, a: ty::field, b: ty::field) -> cres<ty::field> {\n     if a.ident == b.ident {\n-        self.c_mts(a.mt, b.mt).chain {|mt|\n+        self.mts(a.mt, b.mt).chain {|mt|\n             ok({ident: a.ident, mt: mt})\n         }\n     } else {\n         err(ty::terr_record_fields(b.ident, a.ident))\n     }\n }\n \n-fn c_modes<C:combine>(self: C, a: ast::mode, b: ast::mode)\n+fn super_modes<C:combine>(\n+    self: C, a: ast::mode, b: ast::mode)\n     -> cres<ast::mode> {\n \n     let tcx = self.infcx().tcx;\n     ty::unify_mode(tcx, a, b)\n }\n \n-fn c_args<C:combine>(self: C, a: ty::arg, b: ty::arg)\n+fn super_args<C:combine>(\n+    self: C, a: ty::arg, b: ty::arg)\n     -> cres<ty::arg> {\n \n-    c_modes(self, a.mode, b.mode).chain {|m|\n+    self.modes(a.mode, b.mode).chain {|m|\n         // Note: contravariant\n-        self.c_contratys(b.ty, a.ty).chain {|t|\n+        self.contratys(b.ty, a.ty).chain {|t|\n             ok({mode: m, ty: t})\n         }\n     }\n }\n \n-fn c_argvecs<C:combine>(\n-    self: C, a_args: [ty::arg], b_args: [ty::arg]) -> cres<[ty::arg]> {\n+fn super_fns<C:combine>(\n+    self: C, a_f: ty::fn_ty, b_f: ty::fn_ty) -> cres<ty::fn_ty> {\n \n-    if check vec::same_length(a_args, b_args) {\n-        map2(a_args, b_args) {|a, b| c_args(self, a, b) }\n-    } else {\n-        err(ty::terr_arg_count)\n-    }\n-}\n+    fn argvecs<C:combine>(\n+        self: C, a_args: [ty::arg], b_args: [ty::arg]) -> cres<[ty::arg]> {\n \n-fn c_fns<C:combine>(\n-    self: C, a_f: ty::fn_ty, b_f: ty::fn_ty) -> cres<ty::fn_ty> {\n+        if check vec::same_length(a_args, b_args) {\n+            map2(a_args, b_args) {|a, b| self.args(a, b) }\n+        } else {\n+            err(ty::terr_arg_count)\n+        }\n+    }\n \n-    self.c_protos(a_f.proto, b_f.proto).chain {|p|\n-        self.c_ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n-            c_argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n-                self.c_tys(a_f.output, b_f.output).chain {|output|\n+    self.protos(a_f.proto, b_f.proto).chain {|p|\n+        self.ret_styles(a_f.ret_style, b_f.ret_style).chain {|rs|\n+            argvecs(self, a_f.inputs, b_f.inputs).chain {|inputs|\n+                self.tys(a_f.output, b_f.output).chain {|output|\n                     //FIXME self.infcx().constrvecs(a_f.constraints,\n                     //FIXME                         b_f.constraints).then {||\n                         ok({proto: p,\n@@ -1159,12 +1157,12 @@ fn c_fns<C:combine>(\n     }\n }\n \n-fn c_tys<C:combine>(\n+fn super_tys<C:combine>(\n     self: C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     let tcx = self.infcx().tcx;\n \n-    #debug(\"%s.c_tys(%s, %s)\",\n+    #debug(\"%s.tys(%s, %s)\",\n            self.tag(),\n            ty_to_str(tcx, a),\n            ty_to_str(tcx, b));\n@@ -1174,25 +1172,24 @@ fn c_tys<C:combine>(\n \n     indent {||\n     alt (ty::get(a).struct, ty::get(b).struct) {\n-      (ty::ty_bot, _) { self.c_ty_bot(b) }\n-      (_, ty::ty_bot) { self.c_bot_ty(b) }\n+      (ty::ty_bot, _) {\n+        self.ty_bot(b)\n+      }\n+\n+      (_, ty::ty_bot) {\n+        self.bot_ty(b)\n+      }\n \n       (ty::ty_var(a_id), ty::ty_var(b_id)) {\n-        c_vars(self, self.infcx().vb,\n-               a, a_id, b_id,\n-               {|x, y| self.c_tys(x, y) })\n+        self.tvars(a_id, b_id)\n       }\n \n-      // Note that the LUB/GLB operations are commutative:\n       (ty::ty_var(v_id), _) {\n-        c_var_t(self, self.infcx().vb,\n-                v_id, b,\n-                {|x, y| self.c_tys(x, y) })\n+        self.tvar_ty(v_id, b)\n       }\n+\n       (_, ty::ty_var(v_id)) {\n-        c_var_t(self, self.infcx().vb,\n-                v_id, a,\n-                {|x, y| self.c_tys(x, y) })\n+        self.ty_tvar(a, v_id)\n       }\n \n       (ty::ty_nil, _) |\n@@ -1215,86 +1212,94 @@ fn c_tys<C:combine>(\n \n       (ty::ty_enum(a_id, a_tps), ty::ty_enum(b_id, b_tps))\n       if a_id == b_id {\n-        c_tps(self, a_id, a_tps, b_tps).chain {|tps|\n+        self.tps(a_tps, b_tps).chain {|tps|\n             ok(ty::mk_enum(tcx, a_id, tps))\n         }\n       }\n \n       (ty::ty_iface(a_id, a_tps), ty::ty_iface(b_id, b_tps))\n       if a_id == b_id {\n-        c_tps(self, a_id, a_tps, b_tps).chain {|tps|\n+        self.tps(a_tps, b_tps).chain {|tps|\n             ok(ty::mk_iface(tcx, a_id, tps))\n         }\n       }\n \n       (ty::ty_class(a_id, a_tps), ty::ty_class(b_id, b_tps))\n       if a_id == b_id {\n-        c_tps(self, a_id, a_tps, b_tps).chain {|tps|\n+        self.tps(a_tps, b_tps).chain {|tps|\n             ok(ty::mk_class(tcx, a_id, tps))\n         }\n       }\n \n       (ty::ty_box(a_mt), ty::ty_box(b_mt)) {\n-        self.c_mts(a_mt, b_mt).chain {|mt|\n+        self.mts(a_mt, b_mt).chain {|mt|\n             ok(ty::mk_box(tcx, mt))\n         }\n       }\n \n       (ty::ty_uniq(a_mt), ty::ty_uniq(b_mt)) {\n-        self.c_mts(a_mt, b_mt).chain {|mt|\n+        self.mts(a_mt, b_mt).chain {|mt|\n             ok(ty::mk_uniq(tcx, mt))\n         }\n       }\n \n       (ty::ty_vec(a_mt), ty::ty_vec(b_mt)) {\n-        self.c_mts(a_mt, b_mt).chain {|mt|\n+        self.mts(a_mt, b_mt).chain {|mt|\n             ok(ty::mk_vec(tcx, mt))\n         }\n       }\n \n       (ty::ty_ptr(a_mt), ty::ty_ptr(b_mt)) {\n-        self.c_mts(a_mt, b_mt).chain {|mt|\n+        self.mts(a_mt, b_mt).chain {|mt|\n             ok(ty::mk_ptr(tcx, mt))\n         }\n       }\n \n       (ty::ty_rptr(a_r, a_mt), ty::ty_rptr(b_r, b_mt)) {\n-        self.c_contraregions(a_r, b_r).chain {|r|\n-            self.c_mts(a_mt, b_mt).chain {|mt|\n+        self.contraregions(a_r, b_r).chain {|r|\n+            self.mts(a_mt, b_mt).chain {|mt|\n                 ok(ty::mk_rptr(tcx, r, mt))\n             }\n         }\n       }\n \n       (ty::ty_res(a_id, a_t, a_tps), ty::ty_res(b_id, b_t, b_tps))\n       if a_id == b_id {\n-        self.c_tys(a_t, b_t).chain {|t|\n-            c_tps(self, a_id, a_tps, b_tps).chain {|tps|\n+        self.tys(a_t, b_t).chain {|t|\n+            self.tps(a_tps, b_tps).chain {|tps|\n                 ok(ty::mk_res(tcx, a_id, t, tps))\n             }\n         }\n       }\n \n-      (ty::ty_rec(a_fields), ty::ty_rec(b_fields)) {\n-        c_fieldvecs(self, a_fields, b_fields).chain {|fs|\n-            ok(ty::mk_rec(tcx, fs))\n+      (ty::ty_rec(as), ty::ty_rec(bs)) {\n+        if check vec::same_length(as, bs) {\n+            map2(as, bs) {|a,b| self.flds(a, b) }.chain {|flds|\n+                ok(ty::mk_rec(tcx, flds))\n+            }\n+        } else {\n+            err(ty::terr_record_size(bs.len(), as.len()))\n         }\n       }\n \n-      (ty::ty_tup(a_tys), ty::ty_tup(b_tys)) {\n-        c_tuptys(self, a_tys, b_tys).chain {|ts|\n-            ok(ty::mk_tup(tcx, ts))\n+      (ty::ty_tup(as), ty::ty_tup(bs)) {\n+        if check vec::same_length(as, bs) {\n+            map2(as, bs) {|a, b| self.tys(a, b) }.chain {|ts|\n+                ok(ty::mk_tup(tcx, ts))\n+            }\n+        } else {\n+            err(ty::terr_tuple_size(bs.len(), as.len()))\n         }\n       }\n \n       (ty::ty_fn(a_fty), ty::ty_fn(b_fty)) {\n-        c_fns(self, a_fty, b_fty).chain {|fty|\n+        self.fns(a_fty, b_fty).chain {|fty|\n             ok(ty::mk_fn(tcx, fty))\n         }\n       }\n \n       (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n-        self.c_tys(a_t, b_t).chain {|t|\n+        self.tys(a_t, b_t).chain {|t|\n             self.infcx().constrvecs(a_constrs, b_constrs).then {||\n                 ok(ty::mk_constr(tcx, t, a_constrs))\n             }\n@@ -1306,47 +1311,46 @@ fn c_tys<C:combine>(\n     }\n }\n \n-fn c_regions<C:combine>(\n+fn super_regions<C:combine>(\n     self: C, a: ty::region, b: ty::region) -> cres<ty::region> {\n \n-    #debug[\"%s.c_regions(%?, %?)\",\n+    #debug[\"%s.regions(%?, %?)\",\n            self.tag(),\n            a.to_str(self.infcx()),\n            b.to_str(self.infcx())];\n \n     indent {||\n     alt (a, b) {\n       (ty::re_static, r) {\n-        self.c_regions_static_r(r)\n+        self.regions_static_r(r)\n       }\n \n       (r, ty::re_static) {\n-        self.c_regions_r_static(r)\n+        self.regions_r_static(r)\n       }\n \n       (ty::re_var(a_id), ty::re_var(b_id)) {\n-        c_vars(self, self.infcx().rb,\n-               a, a_id, b_id,\n-               {|x, y| self.c_regions(x, y) })\n+        self.rvars(a_id, b_id)\n       }\n \n-      (ty::re_var(v_id), r) |\n-      (r, ty::re_var(v_id)) {\n-        c_var_t(self, self.infcx().rb,\n-                v_id, r,\n-                {|x, y| self.c_regions(x, y) })\n+      (ty::re_var(v_id), _) {\n+        self.rvar_r(v_id, b)\n+      }\n+\n+      (_, ty::re_var(v_id)) {\n+        self.r_rvar(a, v_id)\n       }\n \n       (ty::re_free(a_id, a_br), ty::re_scope(b_id)) {\n-        self.c_regions_free_scope(a, a_id, a_br, b, b_id)\n+        self.regions_free_scope(a, a_id, a_br, b, b_id)\n       }\n \n       (ty::re_scope(a_id), ty::re_free(b_id, b_br)) {\n-        self.c_regions_scope_free(b, b_id, b, b_id, b_br)\n+        self.regions_scope_free(b, b_id, b, b_id, b_br)\n       }\n \n       (ty::re_scope(a_id), ty::re_scope(b_id)) {\n-        self.c_regions_scope_scope(a, a_id, b, b_id)\n+        self.regions_scope_scope(a, a_id, b, b_id)\n       }\n \n       // For these types, we cannot define any additional relationship:\n@@ -1392,18 +1396,18 @@ impl of combine for lub {\n         {ub: some(v) with b}\n     }\n \n-    fn c_bot_ty(b: ty::t) -> cres<ty::t> {\n+    fn bot_ty(b: ty::t) -> cres<ty::t> {\n         ok(b)\n     }\n \n-    fn c_ty_bot(b: ty::t) -> cres<ty::t> {\n-        self.c_bot_ty(b) // LUB is commutative\n+    fn ty_bot(b: ty::t) -> cres<ty::t> {\n+        self.bot_ty(b) // LUB is commutative\n     }\n \n-    fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+    fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx().tcx;\n \n-        #debug(\"%s.c_mts(%s, %s)\",\n+        #debug(\"%s.mts(%s, %s)\",\n                self.tag(),\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n@@ -1416,7 +1420,7 @@ impl of combine for lub {\n \n         alt m {\n           ast::m_imm | ast::m_const {\n-            self.c_tys(a.ty, b.ty).chain {|t|\n+            self.tys(a.ty, b.ty).chain {|t|\n                 ok({ty: t, mutbl: m})\n             }\n           }\n@@ -1427,23 +1431,19 @@ impl of combine for lub {\n                     ok({ty: a.ty, mutbl: m})\n                 }\n             }.chain_err {|_e|\n-                self.c_tys(a.ty, b.ty).chain {|t|\n+                self.tys(a.ty, b.ty).chain {|t|\n                     ok({ty: t, mutbl: ast::m_const})\n                 }\n             }\n           }\n         }\n     }\n \n-    fn c_contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        glb(self.infcx()).c_tys(a, b)\n+    fn contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        glb(self.infcx()).tys(a, b)\n     }\n \n-    fn c_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        c_tys(self, a, b)\n-    }\n-\n-    fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto> {\n+    fn protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto> {\n         if p1 == ast::proto_bare {\n             ok(p2)\n         } else if p2 == ast::proto_bare {\n@@ -1455,7 +1455,7 @@ impl of combine for lub {\n         }\n     }\n \n-    fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n+    fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n         alt (r1, r2) {\n           (ast::return_val, _) |\n           (_, ast::return_val) {\n@@ -1467,24 +1467,20 @@ impl of combine for lub {\n         }\n     }\n \n-    fn c_regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        ret c_regions(self, a, b);\n-    }\n-\n-    fn c_contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        ret glb(self.infcx()).c_regions(a, b);\n+    fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        ret glb(self.infcx()).regions(a, b);\n     }\n \n-    fn c_regions_static_r(_r: ty::region) -> cres<ty::region> {\n+    fn regions_static_r(_r: ty::region) -> cres<ty::region> {\n         // nothing lives longer than static\n         ret ok(ty::re_static);\n     }\n \n-    fn c_regions_r_static(r: ty::region) -> cres<ty::region> {\n-        self.c_regions_static_r(r) // LUB is commutative\n+    fn regions_r_static(r: ty::region) -> cres<ty::region> {\n+        self.regions_static_r(r) // LUB is commutative\n     }\n \n-    fn c_regions_free_scope(\n+    fn regions_free_scope(\n         a: ty::region, _a_id: ast::node_id, _a_br: ty::bound_region,\n         _b: ty::region, _b_id: ast::node_id) -> cres<ty::region> {\n \n@@ -1493,16 +1489,16 @@ impl of combine for lub {\n         ret ok(a); // NDM--not so for nested functions\n     }\n \n-    fn c_regions_scope_free(\n+    fn regions_scope_free(\n         a: ty::region, a_id: ast::node_id,\n         b: ty::region, b_id: ast::node_id, b_br: ty::bound_region)\n         -> cres<ty::region> {\n \n         // LUB is commutative:\n-        self.c_regions_free_scope(b, b_id, b_br, a, a_id)\n+        self.regions_free_scope(b, b_id, b_br, a, a_id)\n     }\n \n-    fn c_regions_scope_scope(a: ty::region, a_id: ast::node_id,\n+    fn regions_scope_scope(a: ty::region, a_id: ast::node_id,\n                              b: ty::region, b_id: ast::node_id)\n         -> cres<ty::region> {\n \n@@ -1514,6 +1510,67 @@ impl of combine for lub {\n           _ { err(ty::terr_regions_differ(b, a)) }\n         }\n     }\n+\n+    fn tvars(a: ty::ty_vid, b: ty::ty_vid) -> cres<ty::t> {\n+        super_vars(self, self.infcx().vb,\n+                   ty::mk_var(self.infcx().tcx, a), a, b,\n+                   {|x, y| self.tys(x, y) })\n+    }\n+\n+    fn tvar_ty(a: ty::ty_vid, b: ty::t) -> cres<ty::t> {\n+        super_var_t(self, self.infcx().vb, a, b,\n+                    {|x, y| self.tys(x, y) })\n+    }\n+\n+    fn ty_tvar(a: ty::t, b: ty::ty_vid) -> cres<ty::t> {\n+        self.tvar_ty(b, a) // commutative\n+    }\n+\n+    fn rvars(a: ty::region_vid, b: ty::region_vid) -> cres<ty::region> {\n+        super_vars(self, self.infcx().rb,\n+                   ty::re_var(a), a, b,\n+                   {|x, y| self.regions(x, y) })\n+    }\n+\n+    fn rvar_r(a: ty::region_vid, b: ty::region) -> cres<ty::region> {\n+        super_var_t(self, self.infcx().rb,\n+                    a, b,\n+                    {|x, y| self.regions(x, y) })\n+    }\n+\n+    fn r_rvar(a: ty::region, b: ty::region_vid) -> cres<ty::region> {\n+        self.rvar_r(b, a) // commutative\n+    }\n+\n+    // Traits please:\n+\n+    fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        super_tys(self, a, b)\n+    }\n+\n+    fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        super_regions(self, a, b)\n+    }\n+\n+    fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n+        super_flds(self, a, b)\n+    }\n+\n+    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n+        super_modes(self, a, b)\n+    }\n+\n+    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+        super_args(self, a, b)\n+    }\n+\n+    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n+        super_fns(self, a, b)\n+    }\n+\n+    fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n+        super_tps(self, as, bs)\n+    }\n }\n \n impl of combine for glb {\n@@ -1530,18 +1587,18 @@ impl of combine for glb {\n         {lb: some(v) with b}\n     }\n \n-    fn c_bot_ty(_b: ty::t) -> cres<ty::t> {\n+    fn bot_ty(_b: ty::t) -> cres<ty::t> {\n         ok(ty::mk_bot(self.infcx().tcx))\n     }\n \n-    fn c_ty_bot(b: ty::t) -> cres<ty::t> {\n-        self.c_bot_ty(b) // GLB is commutative\n+    fn ty_bot(b: ty::t) -> cres<ty::t> {\n+        self.bot_ty(b) // GLB is commutative\n     }\n \n-    fn c_mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+    fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx().tcx;\n \n-        #debug(\"%s.c_mts(%s, %s)\",\n+        #debug(\"%s.mts(%s, %s)\",\n                self.tag(),\n                mt_to_str(tcx, a),\n                mt_to_str(tcx, b));\n@@ -1570,15 +1627,15 @@ impl of combine for glb {\n           (ast::m_imm, ast::m_const) |\n           (ast::m_const, ast::m_imm) |\n           (ast::m_imm, ast::m_imm) {\n-            self.c_tys(a.ty, b.ty).chain {|t|\n+            self.tys(a.ty, b.ty).chain {|t|\n                 ok({ty: t, mutbl: ast::m_imm})\n             }\n           }\n \n           // If both sides are const, then we can use GLB of both\n           // sides and mutbl of only `m_const`.\n           (ast::m_const, ast::m_const) {\n-            self.c_tys(a.ty, b.ty).chain {|t|\n+            self.tys(a.ty, b.ty).chain {|t|\n                 ok({ty: t, mutbl: ast::m_const})\n             }\n           }\n@@ -1591,15 +1648,11 @@ impl of combine for glb {\n         }\n     }\n \n-    fn c_contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        lub(self.infcx()).c_tys(a, b)\n+    fn contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        lub(self.infcx()).tys(a, b)\n     }\n \n-    fn c_tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        c_tys(self, a, b)\n-    }\n-\n-    fn c_protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto> {\n+    fn protos(p1: ast::proto, p2: ast::proto) -> cres<ast::proto> {\n         if p1 == ast::proto_any {\n             ok(p2)\n         } else if p2 == ast::proto_any {\n@@ -1611,7 +1664,7 @@ impl of combine for glb {\n         }\n     }\n \n-    fn c_ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n+    fn ret_styles(r1: ret_style, r2: ret_style) -> cres<ret_style> {\n         alt (r1, r2) {\n           (ast::return_val, ast::return_val) {\n             ok(ast::return_val)\n@@ -1623,24 +1676,24 @@ impl of combine for glb {\n         }\n     }\n \n-    fn c_regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        ret c_regions(self, a, b);\n+    fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        super_regions(self, a, b)\n     }\n \n-    fn c_contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        ret lub(self.infcx()).c_regions(a, b);\n+    fn contraregions(a: ty::region, b: ty::region) -> cres<ty::region> {\n+        lub(self.infcx()).regions(a, b)\n     }\n \n-    fn c_regions_static_r(r: ty::region) -> cres<ty::region> {\n+    fn regions_static_r(r: ty::region) -> cres<ty::region> {\n         // static lives longer than everything else\n         ret ok(r);\n     }\n \n-    fn c_regions_r_static(r: ty::region) -> cres<ty::region> {\n-        self.c_regions_static_r(r) // GLB is commutative\n+    fn regions_r_static(r: ty::region) -> cres<ty::region> {\n+        self.regions_static_r(r) // GLB is commutative\n     }\n \n-    fn c_regions_free_scope(\n+    fn regions_free_scope(\n         _a: ty::region, _a_id: ast::node_id, _a_br: ty::bound_region,\n         b: ty::region, _b_id: ast::node_id) -> cres<ty::region> {\n \n@@ -1650,16 +1703,16 @@ impl of combine for glb {\n         ret ok(b); // NDM--not so for nested functions\n     }\n \n-    fn c_regions_scope_free(\n+    fn regions_scope_free(\n         a: ty::region, a_id: ast::node_id,\n         b: ty::region, b_id: ast::node_id, b_br: ty::bound_region)\n         -> cres<ty::region> {\n \n         // GLB is commutative:\n-        self.c_regions_free_scope(b, b_id, b_br, a, a_id)\n+        self.regions_free_scope(b, b_id, b_br, a, a_id)\n     }\n \n-    fn c_regions_scope_scope(a: ty::region, a_id: ast::node_id,\n+    fn regions_scope_scope(a: ty::region, a_id: ast::node_id,\n                              b: ty::region, b_id: ast::node_id)\n         -> cres<ty::region> {\n \n@@ -1673,4 +1726,61 @@ impl of combine for glb {\n           _ { err(ty::terr_regions_differ(b, a)) }\n         }\n     }\n+\n+    fn tvars(a: ty::ty_vid, b: ty::ty_vid) -> cres<ty::t> {\n+        super_vars(self, self.infcx().vb,\n+                   ty::mk_var(self.infcx().tcx, a), a, b,\n+                   {|x, y| self.tys(x, y) })\n+    }\n+\n+    fn tvar_ty(a: ty::ty_vid, b: ty::t) -> cres<ty::t> {\n+        super_var_t(self, self.infcx().vb, a, b,\n+                    {|x, y| self.tys(x, y) })\n+    }\n+\n+    fn ty_tvar(a: ty::t, b: ty::ty_vid) -> cres<ty::t> {\n+        self.tvar_ty(b, a) // commutative\n+    }\n+\n+    fn rvars(a: ty::region_vid, b: ty::region_vid) -> cres<ty::region> {\n+        super_vars(self, self.infcx().rb,\n+                   ty::re_var(a), a, b,\n+                   {|x, y| self.regions(x, y) })\n+    }\n+\n+    fn rvar_r(a: ty::region_vid, b: ty::region) -> cres<ty::region> {\n+        super_var_t(self, self.infcx().rb,\n+                    a, b,\n+                    {|x, y| self.regions(x, y) })\n+    }\n+\n+    fn r_rvar(a: ty::region, b: ty::region_vid) -> cres<ty::region> {\n+        self.rvar_r(b, a) // commutative\n+    }\n+\n+    // Traits please:\n+\n+    fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+        super_tys(self, a, b)\n+    }\n+\n+    fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n+        super_flds(self, a, b)\n+    }\n+\n+    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n+        super_modes(self, a, b)\n+    }\n+\n+    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+        super_args(self, a, b)\n+    }\n+\n+    fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty> {\n+        super_fns(self, a, b)\n+    }\n+\n+    fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n+        super_tps(self, as, bs)\n+    }\n }"}]}