{"sha": "0660dd10d203cba4069b48d00d02ec9935a916f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NjBkZDEwZDIwM2NiYTQwNjliNDhkMDBkMDJlYzk5MzVhOTE2ZjA=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-15T13:37:30Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-16T17:38:19Z"}, "message": "Fix performance problem", "tree": {"sha": "9d8178c3d4e0ce851298f0922fb77d1cab2abb5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d8178c3d4e0ce851298f0922fb77d1cab2abb5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0660dd10d203cba4069b48d00d02ec9935a916f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0660dd10d203cba4069b48d00d02ec9935a916f0", "html_url": "https://github.com/rust-lang/rust/commit/0660dd10d203cba4069b48d00d02ec9935a916f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0660dd10d203cba4069b48d00d02ec9935a916f0/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6ec4a329fedb354e64c0e0dea9b7651cab78960", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ec4a329fedb354e64c0e0dea9b7651cab78960", "html_url": "https://github.com/rust-lang/rust/commit/e6ec4a329fedb354e64c0e0dea9b7651cab78960"}], "stats": {"total": 69, "additions": 37, "deletions": 32}, "files": [{"sha": "1328e4349b56f4ae1eb1cfddfe95d5b07578606d", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0660dd10d203cba4069b48d00d02ec9935a916f0/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0660dd10d203cba4069b48d00d02ec9935a916f0/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=0660dd10d203cba4069b48d00d02ec9935a916f0", "patch": "@@ -11,40 +11,45 @@ use rustc_hash::FxHashMap;\n use crate::{ExpandError, ExpandResult};\n \n pub(crate) fn expand(rules: &crate::MacroRules, input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n-    let (mut result, mut unmatched_tokens, mut unmatched_patterns, mut err) = (\n-        tt::Subtree::default(),\n-        usize::max_value(),\n-        usize::max_value(),\n-        Some(ExpandError::NoMatchingRule),\n-    );\n-    for rule in &rules.rules {\n-        let ((res, tokens, patterns), e) = expand_rule(rule, input);\n-        if e.is_none() {\n+    expand_rules(&rules.rules, input)\n+}\n+\n+fn expand_rules(rules: &[crate::Rule], input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+    let mut match_: Option<(matcher::Match, &crate::Rule)> = None;\n+    let mut err = Some(ExpandError::NoMatchingRule);\n+    for rule in rules {\n+        let (new_match, bindings_err) = matcher::match_(&rule.lhs, input);\n+        if bindings_err.is_none() {\n             // if we find a rule that applies without errors, we're done\n-            return (res, None);\n+            eprintln!(\"match without errors: {:?}\", new_match);\n+            let (res, transcribe_err) = transcriber::transcribe(&rule.rhs, &new_match.bindings);\n+            eprintln!(\"transcribe_err = {:?}\", transcribe_err);\n+            if transcribe_err.is_none() {\n+                return (res, None);\n+            }\n         }\n         // use the rule if we matched more tokens, or had fewer patterns left\n-        if tokens < unmatched_tokens || tokens == unmatched_tokens && patterns < unmatched_patterns\n-        {\n-            result = res;\n-            err = e;\n-            unmatched_tokens = tokens;\n-            unmatched_patterns = patterns;\n+        if let Some((prev_match, _)) = &match_ {\n+            if new_match.unmatched_tokens < prev_match.unmatched_tokens\n+                || new_match.unmatched_tokens == prev_match.unmatched_tokens\n+                    && new_match.unmatched_patterns < prev_match.unmatched_patterns\n+                || err.is_some() && bindings_err.is_none()\n+            {\n+                match_ = Some((new_match, rule));\n+                err = bindings_err;\n+            }\n+        } else {\n+            match_ = Some((new_match, rule));\n+            err = bindings_err;\n         }\n     }\n-    (result, err)\n-}\n-\n-fn expand_rule(\n-    rule: &crate::Rule,\n-    input: &tt::Subtree,\n-) -> ExpandResult<(tt::Subtree, usize, usize)> {\n-    let (match_result, bindings_err) = matcher::match_(&rule.lhs, input);\n-    let (res, transcribe_err) = transcriber::transcribe(&rule.rhs, &match_result.bindings);\n-    (\n-        (res, match_result.unmatched_tokens, match_result.unmatched_patterns),\n-        bindings_err.or(transcribe_err),\n-    )\n+    if let Some((match_, rule)) = match_ {\n+        // if we got here, there was no match without errors\n+        let (result, transcribe_err) = transcriber::transcribe(&rule.rhs, &match_.bindings);\n+        (result, err.or(transcribe_err))\n+    } else {\n+        (tt::Subtree::default(), err)\n+    }\n }\n \n /// The actual algorithm for expansion is not too hard, but is pretty tricky.\n@@ -167,7 +172,7 @@ mod tests {\n         let (invocation_tt, _) =\n             ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n \n-        let expanded = expand_rule(&rules.rules[0], &invocation_tt);\n-        ((expanded.0).0, expanded.1)\n+        let expanded = expand_rules(&rules.rules, &invocation_tt);\n+        (expanded.0, expanded.1)\n     }\n }"}, {"sha": "faf88c1b1cfe9ccb0dae88cfc5578894ef860d00", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0660dd10d203cba4069b48d00d02ec9935a916f0/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0660dd10d203cba4069b48d00d02ec9935a916f0/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=0660dd10d203cba4069b48d00d02ec9935a916f0", "patch": "@@ -1663,5 +1663,5 @@ fn test_expand_bad_literal() {\n         macro_rules! foo { ($i:literal) => {}; }\n     \"#,\n     )\n-    .assert_expand_err(r#\"foo!(&k\");\"#, &ExpandError::NoMatchingRule);\n+    .assert_expand_err(r#\"foo!(&k\");\"#, &ExpandError::BindingError(\"\".to_string()));\n }"}]}