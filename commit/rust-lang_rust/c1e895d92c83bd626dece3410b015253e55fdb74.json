{"sha": "c1e895d92c83bd626dece3410b015253e55fdb74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZTg5NWQ5MmM4M2JkNjI2ZGVjZTM0MTBiMDE1MjUzZTU1ZmRiNzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-22T18:20:12Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-06-01T17:31:11Z"}, "message": "remove `layout_cache` and fix `-Z print-type-sizes`\n\nnow we grow the type-sizes info during execution, rather than walking\nthe cache after the fact", "tree": {"sha": "25e6854fe0806cc66df6549291bff3d8e8966f74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25e6854fe0806cc66df6549291bff3d8e8966f74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1e895d92c83bd626dece3410b015253e55fdb74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e895d92c83bd626dece3410b015253e55fdb74", "html_url": "https://github.com/rust-lang/rust/commit/c1e895d92c83bd626dece3410b015253e55fdb74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1e895d92c83bd626dece3410b015253e55fdb74/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fb0f0dc2e7f50b12272e274b084c16b048510db", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb0f0dc2e7f50b12272e274b084c16b048510db", "html_url": "https://github.com/rust-lang/rust/commit/5fb0f0dc2e7f50b12272e274b084c16b048510db"}], "stats": {"total": 440, "additions": 240, "deletions": 200}, "files": [{"sha": "c83f73bff6949ba0d14dec923c232896ec1d6c63", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c1e895d92c83bd626dece3410b015253e55fdb74", "patch": "@@ -519,9 +519,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n-    /// Cache for layouts computed from types.\n-    pub layout_cache: RefCell<FxHashMap<Ty<'tcx>, &'tcx Layout>>,\n-\n     /// Used to prevent layout from recursing too deeply.\n     pub layout_depth: Cell<usize>,\n \n@@ -718,7 +715,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n-            layout_cache: RefCell::new(FxHashMap()),\n             layout_interner: RefCell::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),"}, {"sha": "c37fb0f5a778d9adbfb86ab5cc4c89b6366569cd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 215, "deletions": 2, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c1e895d92c83bd626dece3410b015253e55fdb74", "patch": "@@ -12,10 +12,10 @@ pub use self::Integer::*;\n pub use self::Layout::*;\n pub use self::Primitive::*;\n \n-use session::Session;\n+use session::{self, DataTypeKind, Session};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions, ReprFlags};\n \n-use syntax::ast::{FloatTy, IntTy, UintTy};\n+use syntax::ast::{self, FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n \n@@ -1690,6 +1690,219 @@ impl<'a, 'tcx> Layout {\n             }\n         }\n     }\n+\n+    /// This is invoked by the `layout_raw` query to record the final\n+    /// layout of each type.\n+    #[inline]\n+    pub fn record_layout_for_printing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      ty: Ty<'tcx>,\n+                                      param_env: ty::ParamEnv<'tcx>,\n+                                      layout: &Layout) {\n+        // If we are running with `-Zprint-type-sizes`, record layouts for\n+        // dumping later. Ignore layouts that are done with non-empty\n+        // environments or non-monomorphic layouts, as the user only wants\n+        // to see the stuff resulting from the final trans session.\n+        if\n+            !tcx.sess.opts.debugging_opts.print_type_sizes ||\n+            ty.has_param_types() ||\n+            ty.has_self_ty() ||\n+            !param_env.caller_bounds.is_empty()\n+        {\n+            return;\n+        }\n+\n+        Self::record_layout_for_printing_outlined(tcx, ty, param_env, layout)\n+    }\n+\n+    fn record_layout_for_printing_outlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                           ty: Ty<'tcx>,\n+                                           param_env: ty::ParamEnv<'tcx>,\n+                                           layout: &Layout) {\n+        // (delay format until we actually need it)\n+        let record = |kind, opt_discr_size, variants| {\n+            let type_desc = format!(\"{:?}\", ty);\n+            let overall_size = layout.size(tcx);\n+            let align = layout.align(tcx);\n+            tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n+                                                              type_desc,\n+                                                              align,\n+                                                              overall_size,\n+                                                              opt_discr_size,\n+                                                              variants);\n+        };\n+\n+        let (adt_def, substs) = match ty.sty {\n+            ty::TyAdt(ref adt_def, substs) => {\n+                debug!(\"print-type-size t: `{:?}` process adt\", ty);\n+                (adt_def, substs)\n+            }\n+\n+            ty::TyClosure(..) => {\n+                debug!(\"print-type-size t: `{:?}` record closure\", ty);\n+                record(DataTypeKind::Closure, None, vec![]);\n+                return;\n+            }\n+\n+            _ => {\n+                debug!(\"print-type-size t: `{:?}` skip non-nominal\", ty);\n+                return;\n+            }\n+        };\n+\n+        let adt_kind = adt_def.adt_kind();\n+\n+        let build_field_info = |(field_name, field_ty): (ast::Name, Ty<'tcx>), offset: &Size| {\n+            let layout = field_ty.layout(tcx, param_env);\n+            match layout {\n+                Err(_) => bug!(\"no layout found for field {} type: `{:?}`\", field_name, field_ty),\n+                Ok(field_layout) => {\n+                    session::FieldInfo {\n+                        name: field_name.to_string(),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size(tcx).bytes(),\n+                        align: field_layout.align(tcx).abi(),\n+                    }\n+                }\n+            }\n+        };\n+\n+        let build_primitive_info = |name: ast::Name, value: &Primitive| {\n+            session::VariantInfo {\n+                name: Some(name.to_string()),\n+                kind: session::SizeKind::Exact,\n+                align: value.align(tcx).abi(),\n+                size: value.size(tcx).bytes(),\n+                fields: vec![],\n+            }\n+        };\n+\n+        enum Fields<'a> {\n+            WithDiscrim(&'a Struct),\n+            NoDiscrim(&'a Struct),\n+        }\n+\n+        let build_variant_info = |n: Option<ast::Name>,\n+                                  flds: &[(ast::Name, Ty<'tcx>)],\n+                                  layout: Fields| {\n+            let (s, field_offsets) = match layout {\n+                Fields::WithDiscrim(s) => (s, &s.offsets[1..]),\n+                Fields::NoDiscrim(s) => (s, &s.offsets[0..]),\n+            };\n+            let field_info: Vec<_> = flds.iter()\n+                                         .zip(field_offsets.iter())\n+                                         .map(|(&field_name_ty, offset)| build_field_info(field_name_ty, offset))\n+                                         .collect();\n+\n+            session::VariantInfo {\n+                name: n.map(|n|n.to_string()),\n+                kind: if s.sized {\n+                    session::SizeKind::Exact\n+                } else {\n+                    session::SizeKind::Min\n+                },\n+                align: s.align.abi(),\n+                size: s.min_size.bytes(),\n+                fields: field_info,\n+            }\n+        };\n+\n+        match *layout {\n+            Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n+                                                   nndiscr,\n+                                                   discrfield: _,\n+                                                   discrfield_source: _ } => {\n+                debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n+                       ty, nndiscr, variant_layout);\n+                let variant_def = &adt_def.variants[nndiscr as usize];\n+                let fields: Vec<_> = variant_def.fields.iter()\n+                                                       .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                                                       .collect();\n+                record(adt_kind.into(),\n+                       None,\n+                       vec![build_variant_info(Some(variant_def.name),\n+                                               &fields,\n+                                               Fields::NoDiscrim(variant_layout))]);\n+            }\n+            Layout::RawNullablePointer { nndiscr, value } => {\n+                debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n+                       ty, nndiscr, value);\n+                let variant_def = &adt_def.variants[nndiscr as usize];\n+                record(adt_kind.into(), None,\n+                       vec![build_primitive_info(variant_def.name, &value)]);\n+            }\n+            Layout::Univariant { variant: ref variant_layout, non_zero: _ } => {\n+                let variant_names = || {\n+                    adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n+                };\n+                debug!(\"print-type-size t: `{:?}` adt univariant {:?} variants: {:?}\",\n+                       ty, variant_layout, variant_names());\n+                assert!(adt_def.variants.len() <= 1,\n+                        \"univariant with variants {:?}\", variant_names());\n+                if adt_def.variants.len() == 1 {\n+                    let variant_def = &adt_def.variants[0];\n+                    let fields: Vec<_> = variant_def.fields.iter()\n+                                                           .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                                                           .collect();\n+                    record(adt_kind.into(),\n+                           None,\n+                           vec![build_variant_info(Some(variant_def.name),\n+                                                   &fields,\n+                                                   Fields::NoDiscrim(variant_layout))]);\n+                } else {\n+                    // (This case arises for *empty* enums; so give it\n+                    // zero variants.)\n+                    record(adt_kind.into(), None, vec![]);\n+                }\n+            }\n+\n+            Layout::General { ref variants, discr, .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt general variants def {} layouts {} {:?}\",\n+                       ty, adt_def.variants.len(), variants.len(), variants);\n+                let variant_infos: Vec<_> = adt_def.variants.iter()\n+                                                            .zip(variants.iter())\n+                                                            .map(|(variant_def, variant_layout)| {\n+                                                                let fields: Vec<_> = variant_def.fields.iter()\n+                                                                                                       .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                                                                                                       .collect();\n+                                                                build_variant_info(Some(variant_def.name),\n+                                                                                   &fields,\n+                                                                                   Fields::WithDiscrim(variant_layout))\n+                                                            })\n+                                                            .collect();\n+                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+            }\n+\n+            Layout::UntaggedUnion { ref variants } => {\n+                debug!(\"print-type-size t: `{:?}` adt union variants {:?}\",\n+                       ty, variants);\n+                // layout does not currently store info about each\n+                // variant...\n+                record(adt_kind.into(), None, Vec::new());\n+            }\n+\n+            Layout::CEnum { discr, .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt c-like enum\", ty);\n+                let variant_infos: Vec<_> =\n+                    adt_def.variants.iter()\n+                                    .map(|variant_def| {\n+                                        build_primitive_info(variant_def.name,\n+                                                             &Primitive::Int(discr))\n+                                    })\n+                                    .collect();\n+                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+            }\n+\n+            // other cases provide little interesting (i.e. adjustable\n+            // via representation tweaks) size info beyond total size.\n+            Layout::Scalar { .. } |\n+            Layout::Vector { .. } |\n+            Layout::Array { .. } |\n+            Layout::FatPointer { .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt other\", ty);\n+                record(adt_kind.into(), None, Vec::new())\n+            }\n+        }\n+    }\n }\n \n /// Type size \"skeleton\", i.e. the only information determining a type's size."}, {"sha": "ec4ca54d6f5eddedb7c9f3ca1299d2bb269b7be5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c1e895d92c83bd626dece3410b015253e55fdb74", "patch": "@@ -799,9 +799,22 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         param_env: ty::ParamEnv<'tcx>)\n                         -> Result<&'tcx Layout, LayoutError<'tcx>> {\n         let ty = tcx.erase_regions(&self);\n-        tcx.layout_raw(param_env.reveal_all().and(ty))\n+        let layout = tcx.layout_raw(param_env.reveal_all().and(ty));\n+\n+        // NB: This recording is normally disabled; when enabled, it\n+        // can however trigger recursive invocations of `layout()`.\n+        // Therefore, we execute it *after* the main query has\n+        // completed, to avoid problems around recursive structures\n+        // and the like. (Admitedly, I wasn't able to reproduce a problem\n+        // here, but it seems like the right thing to do. -nmatsakis)\n+        if let Ok(l) = layout {\n+            Layout::record_layout_for_printing(tcx, ty, param_env, l);\n+        }\n+\n+        layout\n     }\n \n+\n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n     pub fn is_representable(&'tcx self,\n@@ -1084,6 +1097,7 @@ fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.layout_depth.set(depth+1);\n     let layout = Layout::compute_uncached(tcx, param_env, ty);\n     tcx.layout_depth.set(depth);\n+\n     layout\n }\n "}, {"sha": "88c30cd86659920184abaa67789e2f1a9283669e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 193, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c1e895d92c83bd626dece3410b015253e55fdb74", "patch": "@@ -44,7 +44,7 @@ use rustc::middle::cstore::LinkMeta;\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::session::config::{self, NoDebugInfo};\n-use rustc::session::{self, DataTypeKind, Session};\n+use rustc::session::Session;\n use rustc_incremental::IncrementalHashesMap;\n use abi;\n use mir::lvalue::LvalueRef;\n@@ -80,7 +80,6 @@ use std::i32;\n use syntax_pos::Span;\n use syntax::attr;\n use rustc::hir;\n-use rustc::ty::layout::{self, Layout};\n use syntax::ast;\n \n use mir::lvalue::Alignment;\n@@ -1287,10 +1286,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             &exported_symbols);\n     });\n \n-    if tcx.sess.opts.debugging_opts.print_type_sizes {\n-        gather_type_sizes(tcx);\n-    }\n-\n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n         create_imps(sess, &llvm_modules);\n@@ -1322,193 +1317,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let layout_cache = tcx.layout_cache.borrow();\n-    for (ty, layout) in layout_cache.iter() {\n-\n-        // (delay format until we actually need it)\n-        let record = |kind, opt_discr_size, variants| {\n-            let type_desc = format!(\"{:?}\", ty);\n-            let overall_size = layout.size(tcx);\n-            let align = layout.align(tcx);\n-            tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n-                                                              type_desc,\n-                                                              align,\n-                                                              overall_size,\n-                                                              opt_discr_size,\n-                                                              variants);\n-        };\n-\n-        let (adt_def, substs) = match ty.sty {\n-            ty::TyAdt(ref adt_def, substs) => {\n-                debug!(\"print-type-size t: `{:?}` process adt\", ty);\n-                (adt_def, substs)\n-            }\n-\n-            ty::TyClosure(..) => {\n-                debug!(\"print-type-size t: `{:?}` record closure\", ty);\n-                record(DataTypeKind::Closure, None, vec![]);\n-                continue;\n-            }\n-\n-            _ => {\n-                debug!(\"print-type-size t: `{:?}` skip non-nominal\", ty);\n-                continue;\n-            }\n-        };\n-\n-        let adt_kind = adt_def.adt_kind();\n-\n-        let build_field_info = |(field_name, field_ty): (ast::Name, Ty), offset: &layout::Size| {\n-            match layout_cache.get(&field_ty) {\n-                None => bug!(\"no layout found for field {} type: `{:?}`\", field_name, field_ty),\n-                Some(field_layout) => {\n-                    session::FieldInfo {\n-                        name: field_name.to_string(),\n-                        offset: offset.bytes(),\n-                        size: field_layout.size(tcx).bytes(),\n-                        align: field_layout.align(tcx).abi(),\n-                    }\n-                }\n-            }\n-        };\n-\n-        let build_primitive_info = |name: ast::Name, value: &layout::Primitive| {\n-            session::VariantInfo {\n-                name: Some(name.to_string()),\n-                kind: session::SizeKind::Exact,\n-                align: value.align(tcx).abi(),\n-                size: value.size(tcx).bytes(),\n-                fields: vec![],\n-            }\n-        };\n-\n-        enum Fields<'a> {\n-            WithDiscrim(&'a layout::Struct),\n-            NoDiscrim(&'a layout::Struct),\n-        }\n-\n-        let build_variant_info = |n: Option<ast::Name>, flds: &[(ast::Name, Ty)], layout: Fields| {\n-            let (s, field_offsets) = match layout {\n-                Fields::WithDiscrim(s) => (s, &s.offsets[1..]),\n-                Fields::NoDiscrim(s) => (s, &s.offsets[0..]),\n-            };\n-            let field_info: Vec<_> = flds.iter()\n-                .zip(field_offsets.iter())\n-                .map(|(&field_name_ty, offset)| build_field_info(field_name_ty, offset))\n-                .collect();\n-\n-            session::VariantInfo {\n-                name: n.map(|n|n.to_string()),\n-                kind: if s.sized {\n-                    session::SizeKind::Exact\n-                } else {\n-                    session::SizeKind::Min\n-                },\n-                align: s.align.abi(),\n-                size: s.min_size.bytes(),\n-                fields: field_info,\n-            }\n-        };\n-\n-        match **layout {\n-            Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n-                                                   nndiscr,\n-                                                   discrfield: _,\n-                                                   discrfield_source: _ } => {\n-                debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n-                       ty, nndiscr, variant_layout);\n-                let variant_def = &adt_def.variants[nndiscr as usize];\n-                let fields: Vec<_> = variant_def.fields.iter()\n-                    .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n-                    .collect();\n-                record(adt_kind.into(),\n-                       None,\n-                       vec![build_variant_info(Some(variant_def.name),\n-                                               &fields,\n-                                               Fields::NoDiscrim(variant_layout))]);\n-            }\n-            Layout::RawNullablePointer { nndiscr, value } => {\n-                debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n-                       ty, nndiscr, value);\n-                let variant_def = &adt_def.variants[nndiscr as usize];\n-                record(adt_kind.into(), None,\n-                       vec![build_primitive_info(variant_def.name, &value)]);\n-            }\n-            Layout::Univariant { variant: ref variant_layout, non_zero: _ } => {\n-                let variant_names = || {\n-                    adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n-                };\n-                debug!(\"print-type-size t: `{:?}` adt univariant {:?} variants: {:?}\",\n-                       ty, variant_layout, variant_names());\n-                assert!(adt_def.variants.len() <= 1,\n-                        \"univariant with variants {:?}\", variant_names());\n-                if adt_def.variants.len() == 1 {\n-                    let variant_def = &adt_def.variants[0];\n-                    let fields: Vec<_> = variant_def.fields.iter()\n-                        .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n-                        .collect();\n-                    record(adt_kind.into(),\n-                           None,\n-                           vec![build_variant_info(Some(variant_def.name),\n-                                                   &fields,\n-                                                   Fields::NoDiscrim(variant_layout))]);\n-                } else {\n-                    // (This case arises for *empty* enums; so give it\n-                    // zero variants.)\n-                    record(adt_kind.into(), None, vec![]);\n-                }\n-            }\n-\n-            Layout::General { ref variants, discr, .. } => {\n-                debug!(\"print-type-size t: `{:?}` adt general variants def {} layouts {} {:?}\",\n-                       ty, adt_def.variants.len(), variants.len(), variants);\n-                let variant_infos: Vec<_> = adt_def.variants.iter()\n-                    .zip(variants.iter())\n-                    .map(|(variant_def, variant_layout)| {\n-                        let fields: Vec<_> = variant_def.fields.iter()\n-                            .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n-                            .collect();\n-                        build_variant_info(Some(variant_def.name),\n-                                           &fields,\n-                                           Fields::WithDiscrim(variant_layout))\n-                    })\n-                    .collect();\n-                record(adt_kind.into(), Some(discr.size()), variant_infos);\n-            }\n-\n-            Layout::UntaggedUnion { ref variants } => {\n-                debug!(\"print-type-size t: `{:?}` adt union variants {:?}\",\n-                       ty, variants);\n-                // layout does not currently store info about each\n-                // variant...\n-                record(adt_kind.into(), None, Vec::new());\n-            }\n-\n-            Layout::CEnum { discr, .. } => {\n-                debug!(\"print-type-size t: `{:?}` adt c-like enum\", ty);\n-                let variant_infos: Vec<_> = adt_def.variants.iter()\n-                    .map(|variant_def| {\n-                        build_primitive_info(variant_def.name,\n-                                             &layout::Primitive::Int(discr))\n-                    })\n-                    .collect();\n-                record(adt_kind.into(), Some(discr.size()), variant_infos);\n-            }\n-\n-            // other cases provide little interesting (i.e. adjustable\n-            // via representation tweaks) size info beyond total size.\n-            Layout::Scalar { .. } |\n-            Layout::Vector { .. } |\n-            Layout::Array { .. } |\n-            Layout::FatPointer { .. } => {\n-                debug!(\"print-type-size t: `{:?}` adt other\", ty);\n-                record(adt_kind.into(), None, Vec::new())\n-            }\n-        }\n-    }\n-}\n-\n #[inline(never)] // give this a place in the profiler\n fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n     where I: Iterator<Item=&'a TransItem<'tcx>>"}, {"sha": "2591d7bcbaef4e2cc73e50bc17ff70ae97d4f000", "filename": "src/test/ui/issue-26548.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Ftest%2Fui%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Ftest%2Fui%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-26548.rs?ref=c1e895d92c83bd626dece3410b015253e55fdb74", "previous_filename": "src/test/compile-fail/issue-26548.rs"}, {"sha": "8bfe4ac733b6d91c97d783b55e6a20fa95af4f4f", "filename": "src/test/ui/issue-26548.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Ftest%2Fui%2Fissue-26548.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1e895d92c83bd626dece3410b015253e55fdb74/src%2Ftest%2Fui%2Fissue-26548.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-26548.stderr?ref=c1e895d92c83bd626dece3410b015253e55fdb74", "patch": "@@ -0,0 +1,9 @@\n+error[E0391]: unsupported cyclic reference between types/traits detected\n+  |\n+note: the cycle begins when computing layout of `S`...\n+note: ...which then requires computing layout of `std::option::Option<<S as Mirror>::It>`...\n+note: ...which then requires computing layout of `<S as Mirror>::It`...\n+  = note: ...which then again requires computing layout of `S`, completing the cycle.\n+\n+error: aborting due to previous error\n+"}]}