{"sha": "d3465a8f210403b922d5796b1f24b536f4defedc", "node_id": "C_kwDOAAsO6NoAKGQzNDY1YThmMjEwNDAzYjkyMmQ1Nzk2YjFmMjRiNTM2ZjRkZWZlZGM", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-06-04T09:34:02Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-06-04T09:43:02Z"}, "message": "keep using poll as fast path and only use fcntl as fallback\n\nthis minimizes the amount of syscalls performed during startup", "tree": {"sha": "0fd35067327633f3c2d43a862dc02153a2c9fef0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fd35067327633f3c2d43a862dc02153a2c9fef0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3465a8f210403b922d5796b1f24b536f4defedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3465a8f210403b922d5796b1f24b536f4defedc", "html_url": "https://github.com/rust-lang/rust/commit/d3465a8f210403b922d5796b1f24b536f4defedc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3465a8f210403b922d5796b1f24b536f4defedc/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0a53ed63ab9132b031153d1e69591195e97a59b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0a53ed63ab9132b031153d1e69591195e97a59b", "html_url": "https://github.com/rust-lang/rust/commit/e0a53ed63ab9132b031153d1e69591195e97a59b"}], "stats": {"total": 84, "additions": 65, "deletions": 19}, "files": [{"sha": "55a97be43e25cfb524e189a37ab639fd3255044c", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3465a8f210403b922d5796b1f24b536f4defedc/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3465a8f210403b922d5796b1f24b536f4defedc/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=d3465a8f210403b922d5796b1f24b536f4defedc", "patch": "@@ -239,6 +239,7 @@\n #![feature(dropck_eyepatch)]\n #![feature(exhaustive_patterns)]\n #![feature(intra_doc_pointers)]\n+#![feature(label_break_value)]\n #![feature(lang_items)]\n #![feature(let_chains)]\n #![feature(linkage)]"}, {"sha": "0f06811a1d6f06036e7cfaac972e20484f74c253", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d3465a8f210403b922d5796b1f24b536f4defedc/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3465a8f210403b922d5796b1f24b536f4defedc/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=d3465a8f210403b922d5796b1f24b536f4defedc", "patch": "@@ -67,25 +67,70 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     args::init(argc, argv);\n \n     unsafe fn sanitize_standard_fds() {\n-        cfg_if::cfg_if! {\n-            if #[cfg(not(any(\n-                // The standard fds are always available in Miri.\n-                miri,\n-                target_os = \"emscripten\",\n-                target_os = \"fuchsia\",\n-                target_os = \"vxworks\",\n-                target_os = \"l4re\",\n-            )))] {\n-                use crate::sys::os::errno;\n-                for fd in 0..3 {\n-                    if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n-                        if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n-                            // If the stream is closed but we failed to reopen it, abort the\n-                            // process. Otherwise we wouldn't preserve the safety of\n-                            // operations on the corresponding Rust object Stdin, Stdout, or\n-                            // Stderr.\n-                            libc::abort();\n-                        }\n+        // fast path with a single syscall for systems with poll()\n+        #[cfg(not(any(\n+            miri,\n+            target_os = \"emscripten\",\n+            target_os = \"fuchsia\",\n+            target_os = \"vxworks\",\n+            // The poll on Darwin doesn't set POLLNVAL for closed fds.\n+            target_os = \"macos\",\n+            target_os = \"ios\",\n+            target_os = \"redox\",\n+            target_os = \"l4re\",\n+        )))]\n+        'poll: {\n+            use crate::sys::os::errno;\n+            let pfds: &mut [_] = &mut [\n+                libc::pollfd { fd: 0, events: 0, revents: 0 },\n+                libc::pollfd { fd: 1, events: 0, revents: 0 },\n+                libc::pollfd { fd: 2, events: 0, revents: 0 },\n+            ];\n+\n+            while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n+                if errno() == libc::EINTR {\n+                    continue;\n+                }\n+                if errno() == libc::EINVAL {\n+                    // RLIMIT_NOFILE may be preventing use of poll()\n+                    break 'poll;\n+                }\n+                libc::abort();\n+            }\n+            for pfd in pfds {\n+                if pfd.revents & libc::POLLNVAL == 0 {\n+                    continue;\n+                }\n+                if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                    // If the stream is closed but we failed to reopen it, abort the\n+                    // process. Otherwise we wouldn't preserve the safety of\n+                    // operations on the corresponding Rust object Stdin, Stdout, or\n+                    // Stderr.\n+                    libc::abort();\n+                }\n+            }\n+            return;\n+        }\n+\n+        // fallback in case poll isn't available or limited by RLIMIT_NOFILE\n+        #[cfg(not(any(\n+            // The standard fds are always available in Miri.\n+            miri,\n+            target_os = \"emscripten\",\n+            target_os = \"fuchsia\",\n+            target_os = \"vxworks\",\n+            target_os = \"l4re\",\n+        )))]\n+        {\n+            use crate::sys::os::errno;\n+            for fd in 0..3 {\n+                if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n+                    if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                        // If the stream is closed but we failed to reopen it, abort the\n+                        // process. Otherwise we wouldn't preserve the safety of\n+                        // operations on the corresponding Rust object Stdin, Stdout, or\n+                        // Stderr.\n+                        libc::abort();\n                     }\n                 }\n             }"}]}