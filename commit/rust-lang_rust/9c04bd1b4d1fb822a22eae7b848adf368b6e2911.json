{"sha": "9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMDRiZDFiNGQxZmI4MjJhMjJlYWU3Yjg0OGFkZjM2OGI2ZTI5MTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-24T18:20:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-24T18:20:01Z"}, "message": "Rollup merge of #65627 - varkor:const-generics-forbid-non-structural_match, r=petrochenkov\n\nForbid non-`structural_match` types in const generics\n\nFixes https://github.com/rust-lang/rust/issues/60286.", "tree": {"sha": "0ec3a321d0c27fababd84e31c7ff04397ed88c39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ec3a321d0c27fababd84e31c7ff04397ed88c39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdsetRCRBK7hj4Ov3rIwAAdHIIAKpa2nTQaXawEK9SUlK7aBz7\nCSXgGsvfvAhWP1gLiPLEngQEHU9kIt1AwidHJ1N65M0KjSHaQz7nN3UNjGwowJKN\nGdvuWcny1v7JHYuU2T4MC5PboucLUdWhwXApQlzHa8JFA6bSQMGnQpR0mI/cSXtm\n17qiBx6pLfkx7GiOgFQCtDKq1sUZyKhXlW78eJxQwcKcCL/ipKY6RIfSQ0QnqrLC\nmTNuDTwETJCEWc8LIU8+QZyaFy7Lat/0bPdAT9vNX50uW4o0VCLQWOP/MmN5oW38\nnaasZVg/Y/7blU05kzg0tFopcNMJ3FD9X7TMQZfXARogzYZRwBnFEaEu5SRzLYk=\n=pwat\n-----END PGP SIGNATURE-----\n", "payload": "tree 0ec3a321d0c27fababd84e31c7ff04397ed88c39\nparent cdb7634f0c87d7bd25773b7a0a0fde3bc26322de\nparent 2dda8ad98a8d5089335b2d09307f1bfd085499f9\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571941201 +0200\ncommitter GitHub <noreply@github.com> 1571941201 +0200\n\nRollup merge of #65627 - varkor:const-generics-forbid-non-structural_match, r=petrochenkov\n\nForbid non-`structural_match` types in const generics\n\nFixes https://github.com/rust-lang/rust/issues/60286.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "html_url": "https://github.com/rust-lang/rust/commit/9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de", "html_url": "https://github.com/rust-lang/rust/commit/cdb7634f0c87d7bd25773b7a0a0fde3bc26322de"}, {"sha": "2dda8ad98a8d5089335b2d09307f1bfd085499f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dda8ad98a8d5089335b2d09307f1bfd085499f9", "html_url": "https://github.com/rust-lang/rust/commit/2dda8ad98a8d5089335b2d09307f1bfd085499f9"}], "stats": {"total": 437, "additions": 230, "deletions": 207}, "files": [{"sha": "4660e8025d48ef9a1a0a048121b646dff50be094", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 125, "deletions": 2, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -4,7 +4,7 @@ pub use self::Variance::*;\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n-pub use self::fold::TypeFoldable;\n+pub use self::fold::{TypeFoldable, TypeVisitor};\n \n use crate::hir::{map as hir_map, GlobMap, TraitMap};\n use crate::hir::Node;\n@@ -51,7 +51,7 @@ use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n \n use smallvec;\n-use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -3395,6 +3395,129 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n+pub enum NonStructuralMatchTy<'tcx> {\n+    Adt(&'tcx AdtDef),\n+    Param,\n+}\n+\n+/// This method traverses the structure of `ty`, trying to find an\n+/// instance of an ADT (i.e. struct or enum) that was declared without\n+/// the `#[structural_match]` attribute, or a generic type parameter\n+/// (which cannot be determined to be `structural_match`).\n+///\n+/// The \"structure of a type\" includes all components that would be\n+/// considered when doing a pattern match on a constant of that\n+/// type.\n+///\n+///  * This means this method descends into fields of structs/enums,\n+///    and also descends into the inner type `T` of `&T` and `&mut T`\n+///\n+///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n+///    `*mut T`), and it does not visit the type arguments of an\n+///    instantiated generic like `PhantomData<T>`.\n+///\n+/// The reason we do this search is Rust currently require all ADTs\n+/// reachable from a constant's type to be annotated with\n+/// `#[structural_match]`, an attribute which essentially says that\n+/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n+/// comparison against the unfolded structure.\n+///\n+/// For more background on why Rust has this requirement, and issues\n+/// that arose when the requirement was not enforced completely, see\n+/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n+pub fn search_for_structural_match_violation<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<NonStructuralMatchTy<'tcx>> {\n+    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n+    ty.visit_with(&mut search);\n+    return search.found;\n+\n+    struct Search<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+\n+        // Records the first ADT or type parameter we find without `#[structural_match`.\n+        found: Option<NonStructuralMatchTy<'tcx>>,\n+\n+        // Tracks ADTs previously encountered during search, so that\n+        // we will not recurse on them again.\n+        seen: FxHashSet<hir::def_id::DefId>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            debug!(\"Search visiting ty: {:?}\", ty);\n+\n+            let (adt_def, substs) = match ty.kind {\n+                ty::Adt(adt_def, substs) => (adt_def, substs),\n+                ty::Param(_) => {\n+                    self.found = Some(NonStructuralMatchTy::Param);\n+                    return true; // Stop visiting.\n+                }\n+                ty::RawPtr(..) => {\n+                    // `#[structural_match]` ignores substructure of\n+                    // `*const _`/`*mut _`, so skip super_visit_with\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::FnDef(..) | ty::FnPtr(..) => {\n+                    // types of formals and return in `fn(_) -> _` are also irrelevant\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n+                => {\n+                    // rust-lang/rust#62336: ignore type of contents\n+                    // for empty array.\n+                    return false;\n+                }\n+                _ => {\n+                    ty.super_visit_with(self);\n+                    return false;\n+                }\n+            };\n+\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n+                self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n+                debug!(\"Search found adt_def: {:?}\", adt_def);\n+                return true; // Stop visiting.\n+            }\n+\n+            if !self.seen.insert(adt_def.did) {\n+                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+                // let caller continue its search\n+                return false;\n+            }\n+\n+            // `#[structural_match]` does not care about the\n+            // instantiation of the generics in an ADT (it\n+            // instead looks directly at its fields outside\n+            // this match), so we skip super_visit_with.\n+            //\n+            // (Must not recur on substs for `PhantomData<T>` cf\n+            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+            // want to skip substs when only uses of generic are\n+            // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+            // even though we skip super_visit_with, we must recur on\n+            // fields of ADT.\n+            let tcx = self.tcx;\n+            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                if field_ty.visit_with(self) {\n+                    // found an ADT without `#[structural_match]`; halt visiting!\n+                    assert!(self.found.is_some());\n+                    return true;\n+                }\n+            }\n+\n+            // Even though we do not want to recur on substs, we do\n+            // want our caller to continue its own search.\n+            false\n+        }\n+    }\n+}\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);"}, {"sha": "1da65f4b51d36d083e7697d5cc6c135c61e3ba7c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -557,10 +557,9 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         x.val\n     };\n \n-    // Currently, the values that can be unified are those that\n-    // implement both `PartialEq` and `Eq`, corresponding to\n-    // `structural_match` types.\n-    // FIXME(const_generics): check for `structural_match` synthetic attribute.\n+    // Currently, the values that can be unified are primitive types,\n+    // and those that derive both `PartialEq` and `Eq`, corresponding\n+    // to `structural_match` types.\n     let new_const_val = match (eagerly_eval(a), eagerly_eval(b)) {\n         (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n             // The caller should handle these cases!"}, {"sha": "98e286e61e942d54c7e293f34ebf2e01680da233", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 15, "deletions": 129, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -25,7 +25,6 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::ptr::P;\n \n use rustc_index::vec::Idx;\n-use rustc_data_structures::fx::FxHashSet;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -1000,15 +999,21 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         if self.include_lint_checks && !saw_error {\n             // If we were able to successfully convert the const to some pat, double-check\n             // that the type of the const obeys `#[structural_match]` constraint.\n-            if let Some(adt_def) = search_for_adt_without_structural_match(self.tcx, cv.ty) {\n-\n-                let path = self.tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path,\n-                    path,\n-                );\n+            if let Some(non_sm_ty) = ty::search_for_structural_match_violation(self.tcx, cv.ty) {\n+                let msg = match non_sm_ty {\n+                    ty::NonStructuralMatchTy::Adt(adt_def) => {\n+                        let path = self.tcx.def_path_str(adt_def.did);\n+                        format!(\n+                            \"to use a constant of type `{}` in a pattern, \\\n+                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                            path,\n+                            path,\n+                        )\n+                    }\n+                    ty::NonStructuralMatchTy::Param => {\n+                        bug!(\"use of constant whose type is a parameter inside a pattern\");\n+                    }\n+                };\n \n                 // before issuing lint, double-check there even *is* a\n                 // semantic PartialEq for us to dispatch to.\n@@ -1169,125 +1174,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     }\n }\n \n-/// This method traverses the structure of `ty`, trying to find an\n-/// instance of an ADT (i.e. struct or enum) that was declared without\n-/// the `#[structural_match]` attribute.\n-///\n-/// The \"structure of a type\" includes all components that would be\n-/// considered when doing a pattern match on a constant of that\n-/// type.\n-///\n-///  * This means this method descends into fields of structs/enums,\n-///    and also descends into the inner type `T` of `&T` and `&mut T`\n-///\n-///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n-///    `*mut T`), and it does not visit the type arguments of an\n-///    instantiated generic like `PhantomData<T>`.\n-///\n-/// The reason we do this search is Rust currently require all ADT's\n-/// reachable from a constant's type to be annotated with\n-/// `#[structural_match]`, an attribute which essentially says that\n-/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n-/// comparison against the unfolded structure.\n-///\n-/// For more background on why Rust has this requirement, and issues\n-/// that arose when the requirement was not enforced completely, see\n-/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n-fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n-                                                 ty: Ty<'tcx>)\n-                                                 -> Option<&'tcx AdtDef>\n-{\n-    // Import here (not mod level), because `TypeFoldable::fold_with`\n-    // conflicts with `PatternFoldable::fold_with`\n-    use crate::rustc::ty::fold::TypeVisitor;\n-    use crate::rustc::ty::TypeFoldable;\n-\n-    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n-    ty.visit_with(&mut search);\n-    return search.found;\n-\n-    struct Search<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        // records the first ADT we find without `#[structural_match`\n-        found: Option<&'tcx AdtDef>,\n-\n-        // tracks ADT's previously encountered during search, so that\n-        // we will not recur on them again.\n-        seen: FxHashSet<hir::def_id::DefId>,\n-    }\n-\n-    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-            debug!(\"Search visiting ty: {:?}\", ty);\n-\n-            let (adt_def, substs) = match ty.kind {\n-                ty::Adt(adt_def, substs) => (adt_def, substs),\n-                ty::RawPtr(..) => {\n-                    // `#[structural_match]` ignores substructure of\n-                    // `*const _`/`*mut _`, so skip super_visit_with\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::FnDef(..) | ty::FnPtr(..) => {\n-                    // types of formals and return in `fn(_) -> _` are also irrelevant\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n-                => {\n-                    // rust-lang/rust#62336: ignore type of contents\n-                    // for empty array.\n-                    return false;\n-                }\n-                _ => {\n-                    ty.super_visit_with(self);\n-                    return false;\n-                }\n-            };\n-\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n-                self.found = Some(&adt_def);\n-                debug!(\"Search found adt_def: {:?}\", adt_def);\n-                return true // Halt visiting!\n-            }\n-\n-            if !self.seen.insert(adt_def.did) {\n-                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-                // let caller continue its search\n-                return false;\n-            }\n-\n-            // `#[structural_match]` does not care about the\n-            // instantiation of the generics in an ADT (it\n-            // instead looks directly at its fields outside\n-            // this match), so we skip super_visit_with.\n-            //\n-            // (Must not recur on substs for `PhantomData<T>` cf\n-            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n-            // want to skip substs when only uses of generic are\n-            // behind unsafe pointers `*const T`/`*mut T`.)\n-\n-            // even though we skip super_visit_with, we must recur on\n-            // fields of ADT.\n-            let tcx = self.tcx;\n-            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-                if field_ty.visit_with(self) {\n-                    // found an ADT without `#[structural_match]`; halt visiting!\n-                    assert!(self.found.is_some());\n-                    return true;\n-                }\n-            }\n-\n-            // Even though we do not want to recur on substs, we do\n-            // want our caller to continue its own search.\n-            false\n-        }\n-    }\n-}\n-\n impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx"}, {"sha": "7634093fbefbac29bbbb8f0336bc92a40ed95011", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -367,16 +367,6 @@ impl<'a> Resolver<'a> {\n                     span, \"`Self` in type parameter default\".to_string());\n                 err\n             }\n-            ResolutionError::ConstParamDependentOnTypeParam => {\n-                let mut err = struct_span_err!(\n-                    self.session,\n-                    span,\n-                    E0671,\n-                    \"const parameters cannot depend on type parameters\"\n-                );\n-                err.span_label(span, format!(\"const parameter depends on type parameter\"));\n-                err\n-            }\n         }\n     }\n "}, {"sha": "9883a64a1e896e6600b26fad803a275bfeaa7d8d", "filename": "src/librustc_resolve/error_codes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -1880,13 +1880,14 @@ fn main() {\n \"##,\n \n E0671: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n Const parameters cannot depend on type parameters.\n The following is therefore invalid:\n-```compile_fail,E0671\n+```compile_fail,E0741\n #![feature(const_generics)]\n \n-fn const_id<T, const N: T>() -> T { // error: const parameter\n-                                    // depends on type parameter\n+fn const_id<T, const N: T>() -> T { // error\n     N\n }\n ```"}, {"sha": "136ab1f0444fa87cc334f1d77b862042e32bf51a", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -111,9 +111,6 @@ crate enum RibKind<'a> {\n     /// from the default of a type parameter because they're not declared\n     /// before said type parameter. Also see the `visit_generics` override.\n     ForwardTyParamBanRibKind,\n-\n-    /// We forbid the use of type parameters as the types of const parameters.\n-    TyParamAsConstParamTy,\n }\n \n impl RibKind<'_> {\n@@ -128,8 +125,7 @@ impl RibKind<'_> {\n             | MacroDefinition(_) => false,\n             AssocItemRibKind\n             | ItemRibKind(_)\n-            | ForwardTyParamBanRibKind\n-            | TyParamAsConstParamTy => true,\n+            | ForwardTyParamBanRibKind => true,\n         }\n     }\n }\n@@ -483,18 +479,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             default_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n         }\n \n-        // We also ban access to type parameters for use as the types of const parameters.\n-        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n-        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n-            .filter(|param| {\n-                if let GenericParamKind::Type { .. } = param.kind {\n-                    true\n-                } else {\n-                    false\n-                }\n-            })\n-            .map(|param| (Ident::with_dummy_span(param.ident.name), Res::Err)));\n-\n         for param in &generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n@@ -513,15 +497,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                     default_ban_rib.bindings.remove(&Ident::with_dummy_span(param.ident.name));\n                 }\n                 GenericParamKind::Const { ref ty } => {\n-                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n-\n                     for bound in &param.bounds {\n                         self.visit_param_bound(bound);\n                     }\n-\n                     self.visit_ty(ty);\n-\n-                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n                 }\n             }\n         }"}, {"sha": "92392806347244ce9e65f93f4b61b85494b04afd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -215,8 +215,6 @@ enum ResolutionError<'a> {\n     ForwardDeclaredTyParam, // FIXME(const_generics:defaults)\n     /// Error E0735: type parameters with a default cannot use `Self`\n     SelfInTyParamDefault,\n-    /// Error E0671: const parameter cannot depend on type parameter.\n-    ConstParamDependentOnTypeParam,\n }\n \n // A minimal representation of a path segment. We use this in resolve because\n@@ -2205,15 +2203,6 @@ impl<'a> Resolver<'a> {\n             return Res::Err;\n         }\n \n-        // An invalid use of a type parameter as the type of a const parameter.\n-        if let TyParamAsConstParamTy = all_ribs[rib_index].kind {\n-            if record_used {\n-                self.report_error(span, ResolutionError::ConstParamDependentOnTypeParam);\n-            }\n-            assert_eq!(res, Res::Err);\n-            return Res::Err;\n-        }\n-\n         match res {\n             Res::Local(_) => {\n                 use ResolutionError::*;\n@@ -2222,7 +2211,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) |\n-                        ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n+                        ForwardTyParamBanRibKind => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n@@ -2256,7 +2245,7 @@ impl<'a> Resolver<'a> {\n                     let has_generic_params = match rib.kind {\n                         NormalRibKind | AssocItemRibKind |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n-                        ConstantItemRibKind | TyParamAsConstParamTy => {\n+                        ConstantItemRibKind => {\n                             // Nothing to do. Continue.\n                             continue;\n                         }"}, {"sha": "00435d67184a356b9ae6835769163c3171b1a182", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -1532,6 +1532,17 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                         );\n                     };\n                 }\n+                if ty::search_for_structural_match_violation(tcx, ty).is_some() {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"the types of const generic parameters must derive `PartialEq` and `Eq`\",\n+                    ).span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                    ).emit();\n+                }\n                 ty\n             }\n             x => {"}, {"sha": "75b508a1bbf0ff6961d2631aabbb7229b143cf3a", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -5005,6 +5005,30 @@ the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n [RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n \"##,\n \n+E0741: r##\"\n+Only `structural_match` types (that is, types that derive `PartialEq` and `Eq`)\n+may be used as the types of const generic parameters.\n+\n+```compile_fail,E0741\n+#![feature(const_generics)]\n+\n+struct A;\n+\n+struct B<const X: A>; // error!\n+```\n+\n+To fix this example, we derive `PartialEq` and `Eq`.\n+\n+```\n+#![feature(const_generics)]\n+\n+#[derive(PartialEq, Eq)]\n+struct A;\n+\n+struct B<const X: A>; // ok!\n+```\n+\"##,\n+\n ;\n //  E0035, merged into E0087/E0089\n //  E0036, merged into E0087/E0089"}, {"sha": "2d506787b3b8038a6269bc2a6a92157ec67a8321", "filename": "src/test/rustdoc/const-generics/const-impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -4,6 +4,7 @@\n \n #![crate_name = \"foo\"]\n \n+#[derive(PartialEq, Eq)]\n pub enum Order {\n     Sorted,\n     Unsorted,"}, {"sha": "78bd549ba791a456739aa62a60d2462aa4d8082f", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -1,6 +1,6 @@\n use std::marker::PhantomData;\n \n struct B<T, const N: T>(PhantomData<[T; N]>); //~ ERROR const generics are unstable\n-//~^ ERROR const parameters cannot depend on type parameters\n+//~^ ERROR the types of const generic parameters must derive `PartialEq` and `Eq`\n \n fn main() {}"}, {"sha": "a2872ab982da49ed13519285ddc23608e86c2405", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -1,9 +1,3 @@\n-error[E0671]: const parameters cannot depend on type parameters\n-  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n-   |\n-LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n-   |                      ^ const parameter depends on type parameter\n-\n error[E0658]: const generics are unstable\n   --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:19\n    |\n@@ -13,7 +7,13 @@ LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n    = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n    = help: add `#![feature(const_generics)]` to the crate attributes to enable\n \n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/const-param-type-depends-on-type-param-ungated.rs:3:22\n+   |\n+LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n+   |                      ^ `T` doesn't derive both `PartialEq` and `Eq`\n+\n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0658, E0671.\n+Some errors have detailed explanations: E0658, E0741.\n For more information about an error, try `rustc --explain E0658`."}, {"sha": "b76209571b05cba8633f4f2606ee23bcc1071d5a", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -7,7 +7,6 @@\n // details.\n \n pub struct Dependent<T, const X: T>([(); X]);\n-//~^ ERROR const parameters cannot depend on type parameters\n-//~^^ ERROR parameter `T` is never used\n+//~^ ERROR the types of const generic parameters must derive `PartialEq` and `Eq`\n \n fn main() {}"}, {"sha": "c9d6db7e2c2200928a1462015bdda3918cd752a0", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param.stderr?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -1,9 +1,3 @@\n-error[E0671]: const parameters cannot depend on type parameters\n-  --> $DIR/const-param-type-depends-on-type-param.rs:9:34\n-   |\n-LL | pub struct Dependent<T, const X: T>([(); X]);\n-   |                                  ^ const parameter depends on type parameter\n-\n warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n   --> $DIR/const-param-type-depends-on-type-param.rs:1:12\n    |\n@@ -12,15 +6,12 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0392]: parameter `T` is never used\n-  --> $DIR/const-param-type-depends-on-type-param.rs:9:22\n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/const-param-type-depends-on-type-param.rs:9:34\n    |\n LL | pub struct Dependent<T, const X: T>([(); X]);\n-   |                      ^ unused parameter\n-   |\n-   = help: consider removing `T`, referring to it in a field, or using a marker such as `std::marker::PhantomData`\n+   |                                  ^ `T` doesn't derive both `PartialEq` and `Eq`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0392, E0671.\n-For more information about an error, try `rustc --explain E0392`.\n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "7bc4f3986eb754ba7160739f6dadc49142f7282b", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -0,0 +1,13 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+#[derive(PartialEq, Eq)]\n+struct A;\n+\n+struct B<const X: A>; // ok\n+\n+struct C;\n+\n+struct D<const X: C>; //~ ERROR the types of const generic parameters must derive\n+\n+fn main() {}"}, {"sha": "0fd9e0599e80e47c91e987687af38b0f160810ce", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c04bd1b4d1fb822a22eae7b848adf368b6e2911/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.stderr?ref=9c04bd1b4d1fb822a22eae7b848adf368b6e2911", "patch": "@@ -0,0 +1,17 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/forbid-non-structural_match-types.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0741]: the types of const generic parameters must derive `PartialEq` and `Eq`\n+  --> $DIR/forbid-non-structural_match-types.rs:11:19\n+   |\n+LL | struct D<const X: C>;\n+   |                   ^ `C` doesn't derive both `PartialEq` and `Eq`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0741`."}]}