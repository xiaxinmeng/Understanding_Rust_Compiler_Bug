{"sha": "62f866108446ededb50b77d7e053d9e07f56da4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZjg2NjEwODQ0NmVkZWRiNTBiNzdkN2UwNTNkOWUwN2Y1NmRhNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-21T02:31:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-21T02:31:38Z"}, "message": "auto merge of #11486 : Matthias247/rust/doc, r=cmr\n\nI wrote a chapter for the FFI tutorial that describes how to perform callbacks from C code to Rust and gives some hints about what to consider and synchronization.\r\n\r\nI just needed that for my own wrapper and thought it would be helpful for others.", "tree": {"sha": "5faad44086f2e5a4b5025be839a979ba3f4b999f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5faad44086f2e5a4b5025be839a979ba3f4b999f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62f866108446ededb50b77d7e053d9e07f56da4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62f866108446ededb50b77d7e053d9e07f56da4a", "html_url": "https://github.com/rust-lang/rust/commit/62f866108446ededb50b77d7e053d9e07f56da4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62f866108446ededb50b77d7e053d9e07f56da4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94236fc078474a48fe516394b472027d6b7f66d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/94236fc078474a48fe516394b472027d6b7f66d4", "html_url": "https://github.com/rust-lang/rust/commit/94236fc078474a48fe516394b472027d6b7f66d4"}, {"sha": "112d01a9510192c1e410c6e51e2b2f4d36bc6b63", "url": "https://api.github.com/repos/rust-lang/rust/commits/112d01a9510192c1e410c6e51e2b2f4d36bc6b63", "html_url": "https://github.com/rust-lang/rust/commit/112d01a9510192c1e410c6e51e2b2f4d36bc6b63"}], "stats": {"total": 137, "additions": 137, "deletions": 0}, "files": [{"sha": "236da56588e901f7c57a3d84e7790677c99257be", "filename": "doc/guide-ffi.md", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/62f866108446ededb50b77d7e053d9e07f56da4a/doc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/62f866108446ededb50b77d7e053d9e07f56da4a/doc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-ffi.md?ref=62f866108446ededb50b77d7e053d9e07f56da4a", "patch": "@@ -249,6 +249,143 @@ fn main() {\n }\n ~~~~\n \n+# Callbacks from C code to Rust functions\n+\n+Some external libraries require the usage of callbacks to report back their\n+current state or intermediate data to the caller.\n+It is possible to pass functions defined in Rust to an external library.\n+The requirement for this is that the callback function is marked as `extern`\n+with the correct calling convention to make it callable from C code.\n+\n+The callback function that can then be sent to through a registration call\n+to the C library and afterwards be invoked from there.\n+\n+A basic example is:\n+\n+Rust code:\n+~~~~ {.xfail-test}\n+extern fn callback(a:i32) {\n+    println!(\"I'm called from C with value {0}\", a);\n+}\n+\n+#[link(name = \"extlib\")]\n+extern {\n+   fn register_callback(cb: extern \"C\" fn(i32)) -> i32;\n+   fn trigger_callback();\n+}\n+\n+fn main() {\n+    unsafe {\n+        register_callback(callback);\n+        trigger_callback(); // Triggers the callback\n+    }\n+}\n+~~~~\n+\n+C code:\n+~~~~ {.xfail-test}\n+typedef void (*rust_callback)(int32_t);\n+rust_callback cb;\n+\n+int32_t register_callback(rust_callback callback) {\n+    cb = callback;\n+    return 1;\n+}\n+\n+void trigger_callback() {\n+  cb(7); // Will call callback(7) in Rust\n+}\n+~~~~\n+\n+In this example will Rust's `main()` will call `do_callback()` in C,\n+which would call back to `callback()` in Rust.\n+\n+\n+## Targetting callbacks to Rust objects\n+\n+The former example showed how a global function can be called from C-Code.\n+However it is often desired that the callback is targetted to a special\n+Rust object. This could be the object that represents the wrapper for the\n+respective C object. \n+\n+This can be achieved by passing an unsafe pointer to the object down to the\n+C library. The C library can then include the pointer to the Rust object in\n+the notification. This will provide a unsafe possibility to access the \n+referenced Rust object in callback.\n+\n+Rust code:\n+~~~~ {.xfail-test}\n+\n+struct RustObject {\n+    a: i32,\n+    // other members\n+}\n+\n+extern fn callback(target: *RustObject, a:i32) {\n+    println!(\"I'm called from C with value {0}\", a);\n+    (*target).a = a; // Update the value in RustObject with the value received from the callback\n+}\n+\n+#[link(name = \"extlib\")]\n+extern {\n+   fn register_callback(target: *RustObject, cb: extern \"C\" fn(*RustObject, i32)) -> i32;\n+   fn trigger_callback();\n+}\n+\n+fn main() {\n+    // Create the object that will be referenced in the callback\n+    let rust_object = ~RustObject{a: 5, ...};\n+     \n+    unsafe {\n+        // Gets a raw pointer to the object\n+        let target_addr:*RustObject = ptr::to_unsafe_ptr(rust_object);\n+        register_callback(target_addr, callback);\n+        trigger_callback(); // Triggers the callback\n+    }\n+}\n+~~~~\n+\n+C code:\n+~~~~ {.xfail-test}\n+typedef void (*rust_callback)(int32_t);\n+void* cb_target;\n+rust_callback cb;\n+\n+int32_t register_callback(void* callback_target, rust_callback callback) {\n+    cb_target = callback_target;\n+    cb = callback;\n+    return 1;\n+}\n+\n+void trigger_callback() {\n+  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust\n+}\n+~~~~\n+\n+## Asynchronous callbacks\n+\n+In the already given examples the callbacks are invoked as a direct reaction\n+to a function call to the external C library.\n+The control over the current thread switched from Rust to C to Rust for the\n+execution of the callback, but in the end the callback is executed on the\n+same thread (and Rust task) that lead called the function which triggered\n+the callback.\n+\n+Things get more complicated when the external library spawns it's own threads\n+and invokes callbacks from there.\n+In these cases access to Rust data structures inside he callbacks is\n+especially unsafe and proper synchronization mechanisms must be used.\n+Besides classical synchronization mechanisms like mutexes one possibility in\n+Rust is to use channels (in `std::comm`) to forward data from the C thread\n+that invoked the callback into a Rust task.\n+\n+If an asychronous callback targets a special object in the Rust address space\n+it is also absolutely necessary that no more callbacks are performed by the \n+C library after the respective Rust object get's destroyed. \n+This can be achieved by unregistering the callback it the object's\n+destructor and designing the library in a way that guarantees that no\n+callback will be performed after unregistration.\n+\n # Linking\n \n The `link` attribute on `extern` blocks provides the basic building block for"}]}