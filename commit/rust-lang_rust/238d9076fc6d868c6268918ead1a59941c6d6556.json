{"sha": "238d9076fc6d868c6268918ead1a59941c6d6556", "node_id": "C_kwDOAAsO6NoAKDIzOGQ5MDc2ZmM2ZDg2OGM2MjY4OTE4ZWFkMWE1OTk0MWM2ZDY1NTY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-05T06:34:46Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-06T00:23:06Z"}, "message": "Call `compute_locs` once per rule.\n\nCurrently it's called in `parse_tt` every time a match rule is invoked.\nThis commit moves it so it's called instead once per match rule, in\n`compile_declarative_macro. This is a performance win.\n\nThe commit also moves `compute_locs` out of `TtParser`, because there's\nno longer any reason for it to be in there.", "tree": {"sha": "708647b972aad3f6bb55315e0580d6039a0023b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/708647b972aad3f6bb55315e0580d6039a0023b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/238d9076fc6d868c6268918ead1a59941c6d6556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/238d9076fc6d868c6268918ead1a59941c6d6556", "html_url": "https://github.com/rust-lang/rust/commit/238d9076fc6d868c6268918ead1a59941c6d6556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/238d9076fc6d868c6268918ead1a59941c6d6556/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7300bd6a38376ead250f766a470594943fd9bb80", "url": "https://api.github.com/repos/rust-lang/rust/commits/7300bd6a38376ead250f766a470594943fd9bb80", "html_url": "https://github.com/rust-lang/rust/commit/7300bd6a38376ead250f766a470594943fd9bb80"}], "stats": {"total": 237, "additions": 123, "deletions": 114}, "files": [{"sha": "ffe8b10e6877a97c56c9eaf6766e28673158e9f7", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 89, "deletions": 97, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/238d9076fc6d868c6268918ead1a59941c6d6556/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/238d9076fc6d868c6268918ead1a59941c6d6556/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=238d9076fc6d868c6268918ead1a59941c6d6556", "patch": "@@ -106,7 +106,7 @@ rustc_data_structures::static_assert_size!(NamedMatchVec, 48);\n ///\n /// This means a matcher can be represented by `&[MatcherLoc]`, and traversal mostly involves\n /// simply incrementing the current matcher position index by one.\n-enum MatcherLoc {\n+pub(super) enum MatcherLoc {\n     Token {\n         token: Token,\n     },\n@@ -138,6 +138,78 @@ enum MatcherLoc {\n     Eof,\n }\n \n+pub(super) fn compute_locs(sess: &ParseSess, matcher: &[TokenTree]) -> Vec<MatcherLoc> {\n+    fn inner(\n+        sess: &ParseSess,\n+        tts: &[TokenTree],\n+        locs: &mut Vec<MatcherLoc>,\n+        next_metavar: &mut usize,\n+        seq_depth: usize,\n+    ) {\n+        for tt in tts {\n+            match tt {\n+                TokenTree::Token(token) => {\n+                    locs.push(MatcherLoc::Token { token: token.clone() });\n+                }\n+                TokenTree::Delimited(_, delimited) => {\n+                    locs.push(MatcherLoc::Delimited);\n+                    inner(sess, &delimited.all_tts, locs, next_metavar, seq_depth);\n+                }\n+                TokenTree::Sequence(_, seq) => {\n+                    // We can't determine `idx_first_after` and construct the final\n+                    // `MatcherLoc::Sequence` until after `inner()` is called and the sequence end\n+                    // pieces are processed. So we push a dummy value (`Eof` is cheapest to\n+                    // construct) now, and overwrite it with the proper value below.\n+                    let dummy = MatcherLoc::Eof;\n+                    locs.push(dummy);\n+\n+                    let next_metavar_orig = *next_metavar;\n+                    let op = seq.kleene.op;\n+                    let idx_first = locs.len();\n+                    let idx_seq = idx_first - 1;\n+                    inner(sess, &seq.tts, locs, next_metavar, seq_depth + 1);\n+\n+                    if let Some(separator) = &seq.separator {\n+                        locs.push(MatcherLoc::SequenceSep { separator: separator.clone() });\n+                        locs.push(MatcherLoc::SequenceKleeneOpAfterSep { idx_first });\n+                    } else {\n+                        locs.push(MatcherLoc::SequenceKleeneOpNoSep { op, idx_first });\n+                    }\n+\n+                    // Overwrite the dummy value pushed above with the proper value.\n+                    locs[idx_seq] = MatcherLoc::Sequence {\n+                        op,\n+                        num_metavar_decls: seq.num_captures,\n+                        idx_first_after: locs.len(),\n+                        next_metavar: next_metavar_orig,\n+                        seq_depth,\n+                    };\n+                }\n+                &TokenTree::MetaVarDecl(span, bind, kind) => {\n+                    locs.push(MatcherLoc::MetaVarDecl {\n+                        span,\n+                        bind,\n+                        kind,\n+                        next_metavar: *next_metavar,\n+                        seq_depth,\n+                    });\n+                    *next_metavar += 1;\n+                }\n+                TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n+            }\n+        }\n+    }\n+\n+    let mut locs = vec![];\n+    let mut next_metavar = 0;\n+    inner(sess, matcher, &mut locs, &mut next_metavar, /* seq_depth */ 0);\n+\n+    // A final entry is needed for eof.\n+    locs.push(MatcherLoc::Eof);\n+\n+    locs\n+}\n+\n /// A single matcher position, representing the state of matching.\n struct MatcherPos {\n     /// The index into `TtParser::locs`, which represents the \"dot\".\n@@ -301,9 +373,6 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n pub struct TtParser {\n     macro_name: Ident,\n \n-    /// The matcher of the current rule.\n-    locs: Vec<MatcherLoc>,\n-\n     /// The set of current mps to be processed. This should be empty by the end of a successful\n     /// execution of `parse_tt_inner`.\n     cur_mps: Vec<MatcherPos>,\n@@ -324,92 +393,13 @@ impl TtParser {\n     pub(super) fn new(macro_name: Ident) -> TtParser {\n         TtParser {\n             macro_name,\n-            locs: vec![],\n             cur_mps: vec![],\n             next_mps: vec![],\n             bb_mps: vec![],\n             empty_matches: Lrc::new(smallvec![]),\n         }\n     }\n \n-    /// Convert a `&[TokenTree]` to a `&[MatcherLoc]`. Note: this conversion happens every time the\n-    /// macro is called, which may be many times if there are many call sites or if it is\n-    /// recursive. This conversion is fairly cheap and the representation is sufficiently better\n-    /// for matching than `&[TokenTree]` that it's a clear performance win even with the overhead.\n-    /// But it might be possible to move the conversion outwards so it only occurs once per macro.\n-    fn compute_locs(&mut self, sess: &ParseSess, matcher: &[TokenTree]) -> usize {\n-        fn inner(\n-            sess: &ParseSess,\n-            tts: &[TokenTree],\n-            locs: &mut Vec<MatcherLoc>,\n-            next_metavar: &mut usize,\n-            seq_depth: usize,\n-        ) {\n-            for tt in tts {\n-                match tt {\n-                    TokenTree::Token(token) => {\n-                        locs.push(MatcherLoc::Token { token: token.clone() });\n-                    }\n-                    TokenTree::Delimited(_, delimited) => {\n-                        locs.push(MatcherLoc::Delimited);\n-                        inner(sess, &delimited.all_tts, locs, next_metavar, seq_depth);\n-                    }\n-                    TokenTree::Sequence(_, seq) => {\n-                        // We can't determine `idx_first_after` and construct the final\n-                        // `MatcherLoc::Sequence` until after `inner()` is called and the sequence\n-                        // end pieces are processed. So we push a dummy value (`Eof` is cheapest to\n-                        // construct) now, and overwrite it with the proper value below.\n-                        let dummy = MatcherLoc::Eof;\n-                        locs.push(dummy);\n-\n-                        let next_metavar_orig = *next_metavar;\n-                        let op = seq.kleene.op;\n-                        let idx_first = locs.len();\n-                        let idx_seq = idx_first - 1;\n-                        inner(sess, &seq.tts, locs, next_metavar, seq_depth + 1);\n-\n-                        if let Some(separator) = &seq.separator {\n-                            locs.push(MatcherLoc::SequenceSep { separator: separator.clone() });\n-                            locs.push(MatcherLoc::SequenceKleeneOpAfterSep { idx_first });\n-                        } else {\n-                            locs.push(MatcherLoc::SequenceKleeneOpNoSep { op, idx_first });\n-                        }\n-\n-                        // Overwrite the dummy value pushed above with the proper value.\n-                        locs[idx_seq] = MatcherLoc::Sequence {\n-                            op,\n-                            num_metavar_decls: seq.num_captures,\n-                            idx_first_after: locs.len(),\n-                            next_metavar: next_metavar_orig,\n-                            seq_depth,\n-                        };\n-                    }\n-                    &TokenTree::MetaVarDecl(span, bind, kind) => {\n-                        locs.push(MatcherLoc::MetaVarDecl {\n-                            span,\n-                            bind,\n-                            kind,\n-                            next_metavar: *next_metavar,\n-                            seq_depth,\n-                        });\n-                        *next_metavar += 1;\n-                    }\n-                    TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n-                }\n-            }\n-        }\n-\n-        self.locs.clear();\n-        let mut next_metavar = 0;\n-        inner(sess, matcher, &mut self.locs, &mut next_metavar, /* seq_depth */ 0);\n-\n-        // A final entry is needed for eof.\n-        self.locs.push(MatcherLoc::Eof);\n-\n-        // This is the number of metavar decls.\n-        next_metavar\n-    }\n-\n     /// Process the matcher positions of `cur_mps` until it is empty. In the process, this will\n     /// produce more mps in `next_mps` and `bb_mps`.\n     ///\n@@ -420,15 +410,15 @@ impl TtParser {\n     fn parse_tt_inner(\n         &mut self,\n         sess: &ParseSess,\n-        num_metavar_decls: usize,\n+        matcher: &[MatcherLoc],\n         token: &Token,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n         // modified if `token == Eof`.\n         let mut eof_mps = EofMatcherPositions::None;\n \n         while let Some(mut mp) = self.cur_mps.pop() {\n-            match &self.locs[mp.idx] {\n+            match &matcher[mp.idx] {\n                 MatcherLoc::Token { token: t } => {\n                     // If it's a doc comment, we just ignore it and move on to the next tt in the\n                     // matcher. This is a bug, but #95267 showed that existing programs rely on\n@@ -536,7 +526,7 @@ impl TtParser {\n                 }\n                 MatcherLoc::Eof => {\n                     // We are past the matcher's end, and not in a sequence. Try to end things.\n-                    debug_assert_eq!(mp.idx, self.locs.len() - 1);\n+                    debug_assert_eq!(mp.idx, matcher.len() - 1);\n                     if *token == token::Eof {\n                         eof_mps = match eof_mps {\n                             EofMatcherPositions::None => EofMatcherPositions::One(mp),\n@@ -554,11 +544,10 @@ impl TtParser {\n         if *token == token::Eof {\n             Some(match eof_mps {\n                 EofMatcherPositions::One(mut eof_mp) => {\n-                    assert_eq!(eof_mp.matches.len(), num_metavar_decls);\n                     // Need to take ownership of the matches from within the `Lrc`.\n                     Lrc::make_mut(&mut eof_mp.matches);\n                     let matches = Lrc::try_unwrap(eof_mp.matches).unwrap().into_iter();\n-                    self.nameize(sess, matches)\n+                    self.nameize(sess, matcher, matches)\n                 }\n                 EofMatcherPositions::Multiple => {\n                     Error(token.span, \"ambiguity: multiple successful parses\".to_string())\n@@ -580,10 +569,8 @@ impl TtParser {\n     pub(super) fn parse_tt(\n         &mut self,\n         parser: &mut Cow<'_, Parser<'_>>,\n-        matcher: &[TokenTree],\n+        matcher: &[MatcherLoc],\n     ) -> NamedParseResult {\n-        let num_metavar_decls = self.compute_locs(parser.sess, matcher);\n-\n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `matcher`.\n         // `parse_tt_inner` then processes all of these possible matcher positions and produces\n@@ -598,7 +585,7 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            if let Some(res) = self.parse_tt_inner(&parser.sess, num_metavar_decls, &parser.token) {\n+            if let Some(res) = self.parse_tt_inner(&parser.sess, matcher, &parser.token) {\n                 return res;\n             }\n \n@@ -626,7 +613,7 @@ impl TtParser {\n                 (0, 1) => {\n                     // We need to call the black-box parser to get some nonterminal.\n                     let mut mp = self.bb_mps.pop().unwrap();\n-                    let loc = &self.locs[mp.idx];\n+                    let loc = &matcher[mp.idx];\n                     if let &MatcherLoc::MetaVarDecl {\n                         span,\n                         kind: Some(kind),\n@@ -664,19 +651,23 @@ impl TtParser {\n \n                 (_, _) => {\n                     // Too many possibilities!\n-                    return self.ambiguity_error(parser.token.span);\n+                    return self.ambiguity_error(matcher, parser.token.span);\n                 }\n             }\n \n             assert!(!self.cur_mps.is_empty());\n         }\n     }\n \n-    fn ambiguity_error(&self, token_span: rustc_span::Span) -> NamedParseResult {\n+    fn ambiguity_error(\n+        &self,\n+        matcher: &[MatcherLoc],\n+        token_span: rustc_span::Span,\n+    ) -> NamedParseResult {\n         let nts = self\n             .bb_mps\n             .iter()\n-            .map(|mp| match &self.locs[mp.idx] {\n+            .map(|mp| match &matcher[mp.idx] {\n                 MatcherLoc::MetaVarDecl { bind, kind: Some(kind), .. } => {\n                     format!(\"{} ('{}')\", kind, bind)\n                 }\n@@ -702,12 +693,13 @@ impl TtParser {\n     fn nameize<I: Iterator<Item = NamedMatch>>(\n         &self,\n         sess: &ParseSess,\n+        matcher: &[MatcherLoc],\n         mut res: I,\n     ) -> NamedParseResult {\n         // Make that each metavar has _exactly one_ binding. If so, insert the binding into the\n         // `NamedParseResult`. Otherwise, it's an error.\n         let mut ret_val = FxHashMap::default();\n-        for loc in self.locs.iter() {\n+        for loc in matcher {\n             if let &MatcherLoc::MetaVarDecl { span, bind, kind, .. } = loc {\n                 if kind.is_some() {\n                     match ret_val.entry(MacroRulesNormalizedIdent::new(bind)) {"}, {"sha": "27fe78516a4944b3182d628567a01bf26ab51cca", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/238d9076fc6d868c6268918ead1a59941c6d6556/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/238d9076fc6d868c6268918ead1a59941c6d6556/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=238d9076fc6d868c6268918ead1a59941c6d6556", "patch": "@@ -4,7 +4,7 @@ use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstF\n use crate::mbe;\n use crate::mbe::macro_check;\n use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success, TtParser};\n-use crate::mbe::macro_parser::{MatchedSeq, MatchedTokenTree};\n+use crate::mbe::macro_parser::{MatchedSeq, MatchedTokenTree, MatcherLoc};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast as ast;\n@@ -159,7 +159,7 @@ struct MacroRulesMacroExpander {\n     name: Ident,\n     span: Span,\n     transparency: Transparency,\n-    lhses: Vec<mbe::TokenTree>,\n+    lhses: Vec<Vec<MatcherLoc>>,\n     rhses: Vec<mbe::TokenTree>,\n     valid: bool,\n     is_local: bool,\n@@ -210,7 +210,7 @@ fn generic_extension<'cx, 'tt>(\n     name: Ident,\n     transparency: Transparency,\n     arg: TokenStream,\n-    lhses: &'tt [mbe::TokenTree],\n+    lhses: &'tt [Vec<MatcherLoc>],\n     rhses: &'tt [mbe::TokenTree],\n     is_local: bool,\n ) -> Box<dyn MacResult + 'cx> {\n@@ -245,14 +245,6 @@ fn generic_extension<'cx, 'tt>(\n     // this situation.)\n     let parser = parser_from_cx(sess, arg.clone());\n \n-    // A matcher is always delimited, but the delimiters are ignored.\n-    let delimited_inner_tts = |tt: &'tt mbe::TokenTree| -> &'tt [mbe::TokenTree] {\n-        match tt {\n-            mbe::TokenTree::Delimited(_, delimited) => delimited.inner_tts(),\n-            _ => cx.span_bug(sp, \"malformed macro lhs\"),\n-        }\n-    };\n-\n     // Try each arm's matchers.\n     let mut tt_parser = TtParser::new(name);\n     for (i, lhs) in lhses.iter().enumerate() {\n@@ -262,13 +254,19 @@ fn generic_extension<'cx, 'tt>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), delimited_inner_tts(lhs)) {\n+        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n-                let rhs = delimited_inner_tts(&rhses[i]).to_vec().clone();\n+                // Ignore the delimiters on the RHS.\n+                let rhs = match &rhses[i] {\n+                    mbe::TokenTree::Delimited(_, delimited) => {\n+                        delimited.inner_tts().to_vec().clone()\n+                    }\n+                    _ => cx.span_bug(sp, \"malformed macro rhs\"),\n+                };\n                 let arm_span = rhses[i].span();\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n@@ -346,10 +344,8 @@ fn generic_extension<'cx, 'tt>(\n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n     if let Some((arg, comma_span)) = arg.add_comma() {\n         for lhs in lhses {\n-            if let Success(_) = tt_parser.parse_tt(\n-                &mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())),\n-                delimited_inner_tts(lhs),\n-            ) {\n+            let parser = parser_from_cx(sess, arg.clone());\n+            if let Success(_) = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs) {\n                 if comma_span.is_dummy() {\n                     err.note(\"you might be missing a comma\");\n                 } else {\n@@ -440,6 +436,8 @@ pub fn compile_declarative_macro(\n             }),\n         ),\n     ];\n+    // Convert it into `MatcherLoc` form.\n+    let argument_gram = mbe::macro_parser::compute_locs(&sess.parse_sess, &argument_gram);\n \n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let mut tt_parser = TtParser::new(def.ident);\n@@ -536,6 +534,25 @@ pub fn compile_declarative_macro(\n         None => {}\n     }\n \n+    // Convert the lhses into `MatcherLoc` form, which is better for doing the\n+    // actual matching. Unless the matcher is invalid.\n+    let lhses = if valid {\n+        lhses\n+            .iter()\n+            .map(|lhs| {\n+                // Ignore the delimiters around the matcher.\n+                match lhs {\n+                    mbe::TokenTree::Delimited(_, delimited) => {\n+                        mbe::macro_parser::compute_locs(&sess.parse_sess, delimited.inner_tts())\n+                    }\n+                    _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"malformed macro lhs\"),\n+                }\n+            })\n+            .collect()\n+    } else {\n+        vec![]\n+    };\n+\n     mk_syn_ext(Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         span: def.span,"}]}