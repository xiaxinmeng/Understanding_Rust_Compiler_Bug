{"sha": "4ac7d1c3ab519c72bf10521f0675060b12b0bb0a", "node_id": "C_kwDOAAsO6NoAKDRhYzdkMWMzYWI1MTljNzJiZjEwNTIxZjA2NzUwNjBiMTJiMGJiMGE", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-04T04:32:15Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-05T16:51:16Z"}, "message": "Formatting", "tree": {"sha": "69b43620d23fe412e1189f1074ce88bfb567a7e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69b43620d23fe412e1189f1074ce88bfb567a7e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ac7d1c3ab519c72bf10521f0675060b12b0bb0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac7d1c3ab519c72bf10521f0675060b12b0bb0a", "html_url": "https://github.com/rust-lang/rust/commit/4ac7d1c3ab519c72bf10521f0675060b12b0bb0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ac7d1c3ab519c72bf10521f0675060b12b0bb0a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc8d8619062278046e678bbc08401b733a17236", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc8d8619062278046e678bbc08401b733a17236", "html_url": "https://github.com/rust-lang/rust/commit/9cc8d8619062278046e678bbc08401b733a17236"}], "stats": {"total": 262, "additions": 135, "deletions": 127}, "files": [{"sha": "41bbe2d15c16fbf00dc8b15d07cce76f2a403ef7", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 135, "deletions": 127, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/4ac7d1c3ab519c72bf10521f0675060b12b0bb0a/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac7d1c3ab519c72bf10521f0675060b12b0bb0a/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=4ac7d1c3ab519c72bf10521f0675060b12b0bb0a", "patch": "@@ -294,143 +294,151 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let id = map.get_parent_item(hir_id);\n         let hir_id: hir::HirId = id.into();\n \n-        if let Some(node) = map.find(hir_id) && let Some(body_id) = node.body_id() {\n-            let body = map.body(body_id);\n-            expr_finder.visit_expr(body.value);\n-            let mut eraser = TypeEraser { tcx };\n-            let mut prev = eraser.fold_ty(ty);\n-            let mut prev_span = None;\n-\n-            for binding in expr_finder.uses {\n-                // In every expression where the binding is referenced, we will look at that\n-                // expression's type and see if it is where the incorrect found type was fully\n-                // \"materialized\" and point at it. We will also try to provide a suggestion there.\n-                let parent = map.get_parent_node(binding.hir_id);\n-                if let Some(hir::Node::Expr(expr))\n-                | Some(hir::Node::Stmt(hir::Stmt {\n-                    kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n-                    ..\n-                })) = &map.find(parent)\n-                    && let hir::ExprKind::MethodCall(s, rcvr, args, _span) = expr.kind\n-                    && rcvr.hir_id == binding.hir_id\n-                    && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n-                {\n-                    // We special case methods, because they can influence inference through the\n-                    // call's arguments and we can provide a more explicit span.\n-                    let sig = self.tcx.fn_sig(def_id);\n-                    let def_self_ty = sig.input(0).skip_binder();\n-                    let rcvr_ty = self.node_ty(rcvr.hir_id);\n-                    // Get the evaluated type *after* calling the method call, so that the influence\n-                    // of the arguments can be reflected in the receiver type. The receiver\n-                    // expression has the type *before* theis analysis is done.\n-                    let ty = match self.lookup_probe(s.ident, rcvr_ty, expr, probe::ProbeScope::TraitsInScope) {\n-                        Ok(pick) => pick.self_ty,\n-                        Err(_) => rcvr_ty,\n-                    };\n-                    // Remove one layer of references to account for `&mut self` and\n-                    // `&self`, so that we can compare it against the binding.\n-                    let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n-                        (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n-                        _ => (ty, def_self_ty),\n-                    };\n-                    let mut param_args = FxHashMap::default();\n-                    let mut param_expected = FxHashMap::default();\n-                    let mut param_found = FxHashMap::default();\n-                    if self.can_eq(self.param_env, ty, found).is_ok() {\n-                        // We only point at the first place where the found type was inferred.\n-                        for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n-                            if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n-                                // We found an argument that references a type parameter in `Self`,\n-                                // so we assume that this is the argument that caused the found\n-                                // type, which we know already because of `can_eq` above was first\n-                                // inferred in this method call.\n-                                let arg = &args[i];\n-                                let arg_ty = self.node_ty(arg.hir_id);\n-                                err.span_label(\n-                                    arg.span,\n-                                    &format!(\n-                                        \"this is of type `{arg_ty}`, which makes `{ident}` to be \\\n-                                         inferred as `{ty}`\",\n-                                    ),\n-                                );\n-                                param_args.insert(param_ty, (arg, arg_ty));\n-                            }\n+        let Some(node) = map.find(hir_id) else { return false; };\n+        let Some(body_id) = node.body_id() else { return false; };\n+        let body = map.body(body_id);\n+        expr_finder.visit_expr(body.value);\n+        let mut eraser = TypeEraser { tcx };\n+        let mut prev = eraser.fold_ty(ty);\n+        let mut prev_span = None;\n+\n+        for binding in expr_finder.uses {\n+            // In every expression where the binding is referenced, we will look at that\n+            // expression's type and see if it is where the incorrect found type was fully\n+            // \"materialized\" and point at it. We will also try to provide a suggestion there.\n+            let parent = map.get_parent_node(binding.hir_id);\n+            if let Some(hir::Node::Expr(expr))\n+            | Some(hir::Node::Stmt(hir::Stmt {\n+                kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n+                ..\n+            })) = &map.find(parent)\n+                && let hir::ExprKind::MethodCall(segment, rcvr, args, _span) = expr.kind\n+                && rcvr.hir_id == binding.hir_id\n+                && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n+            {\n+                // We special case methods, because they can influence inference through the\n+                // call's arguments and we can provide a more explicit span.\n+                let sig = self.tcx.fn_sig(def_id);\n+                let def_self_ty = sig.input(0).skip_binder();\n+                let rcvr_ty = self.node_ty(rcvr.hir_id);\n+                // Get the evaluated type *after* calling the method call, so that the influence\n+                // of the arguments can be reflected in the receiver type. The receiver\n+                // expression has the type *before* theis analysis is done.\n+                let ty = match self.lookup_probe(\n+                    segment.ident,\n+                    rcvr_ty,\n+                    expr,\n+                    probe::ProbeScope::TraitsInScope,\n+                ) {\n+                    Ok(pick) => pick.self_ty,\n+                    Err(_) => rcvr_ty,\n+                };\n+                // Remove one layer of references to account for `&mut self` and\n+                // `&self`, so that we can compare it against the binding.\n+                let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n+                    (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n+                    _ => (ty, def_self_ty),\n+                };\n+                let mut param_args = FxHashMap::default();\n+                let mut param_expected = FxHashMap::default();\n+                let mut param_found = FxHashMap::default();\n+                if self.can_eq(self.param_env, ty, found).is_ok() {\n+                    // We only point at the first place where the found type was inferred.\n+                    for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n+                        if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n+                            // We found an argument that references a type parameter in `Self`,\n+                            // so we assume that this is the argument that caused the found\n+                            // type, which we know already because of `can_eq` above was first\n+                            // inferred in this method call.\n+                            let arg = &args[i];\n+                            let arg_ty = self.node_ty(arg.hir_id);\n+                            err.span_label(\n+                                arg.span,\n+                                &format!(\n+                                    \"this is of type `{arg_ty}`, which makes `{ident}` to be \\\n+                                     inferred as `{ty}`\",\n+                                ),\n+                            );\n+                            param_args.insert(param_ty, (arg, arg_ty));\n                         }\n                     }\n+                }\n \n-                    // Here we find, for a type param `T`, the type that `T` is in the current\n-                    // method call *and* in the original expected type. That way, we can see if we\n-                    // can give any structured suggestion for the function argument.\n-                    let mut c = CollectAllMismatches {\n-                        infcx: &self.infcx,\n-                        param_env: self.param_env,\n-                        errors: vec![],\n-                    };\n-                    let _ = c.relate(def_self_ty, ty);\n-                    for error in c.errors {\n-                        if let TypeError::Sorts(error) = error {\n-                            param_found.insert(error.expected, error.found);\n-                        }\n-                    }\n-                    c.errors = vec![];\n-                    let _ = c.relate(def_self_ty, expected);\n-                    for error in c.errors {\n-                        if let TypeError::Sorts(error) = error {\n-                            param_expected.insert(error.expected, error.found);\n-                        }\n+                // Here we find, for a type param `T`, the type that `T` is in the current\n+                // method call *and* in the original expected type. That way, we can see if we\n+                // can give any structured suggestion for the function argument.\n+                let mut c = CollectAllMismatches {\n+                    infcx: &self.infcx,\n+                    param_env: self.param_env,\n+                    errors: vec![],\n+                };\n+                let _ = c.relate(def_self_ty, ty);\n+                for error in c.errors {\n+                    if let TypeError::Sorts(error) = error {\n+                        param_found.insert(error.expected, error.found);\n                     }\n-                    for (param, (arg,arg_ty)) in param_args.iter() {\n-                        let Some(expected) = param_expected.get(param) else { continue; };\n-                        let Some(found) = param_found.get(param) else { continue; };\n-                        if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n-                        self.suggest_deref_ref_or_into(err, arg, *expected, *found, None);\n+                }\n+                c.errors = vec![];\n+                let _ = c.relate(def_self_ty, expected);\n+                for error in c.errors {\n+                    if let TypeError::Sorts(error) = error {\n+                        param_expected.insert(error.expected, error.found);\n                     }\n+                }\n+                for (param, (arg,arg_ty)) in param_args.iter() {\n+                    let Some(expected) = param_expected.get(param) else { continue; };\n+                    let Some(found) = param_found.get(param) else { continue; };\n+                    if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n+                    self.suggest_deref_ref_or_into(err, arg, *expected, *found, None);\n+                }\n \n-                    let ty = eraser.fold_ty(ty);\n-                    if ty.references_error() {\n-                        break;\n-                    }\n-                    if ty != prev\n-                        && param_args.is_empty()\n-                        && self.can_eq(self.param_env, ty, found).is_ok()\n-                    {\n-                        // We only point at the first place where the found type was inferred.\n-                        err.span_label(\n-                            s.ident.span,\n-                            with_forced_trimmed_paths!(format!(\n-                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                            )),\n-                        );\n-                        break;\n-                    }\n-                    prev = ty;\n-                } else {\n-                    let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n-                    if ty.references_error() {\n-                        break;\n-                    }\n-                    if ty != prev && let Some(span) = prev_span && self.can_eq(self.param_env, ty, found).is_ok() {\n-                        // We only point at the first place where the found type was inferred.\n-                        // We use the *previous* span because if the type is known *here* it means\n-                        // it was *evaluated earlier*. We don't do this for method calls because we\n-                        // evaluate the method's self type eagerly, but not in any other case.\n-                        err.span_label(\n-                            span,\n-                            with_forced_trimmed_paths!(format!(\n-                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                            )),\n-                        );\n-                        break;\n-                    }\n-                    prev = ty;\n+                let ty = eraser.fold_ty(ty);\n+                if ty.references_error() {\n+                    break;\n                 }\n-                if binding.hir_id == expr.hir_id {\n-                    // Do not look at expressions that come after the expression we were originally\n-                    // evaluating and had a type error.\n+                if ty != prev\n+                    && param_args.is_empty()\n+                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                {\n+                    // We only point at the first place where the found type was inferred.\n+                    err.span_label(\n+                        segment.ident.span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                        )),\n+                    );\n                     break;\n                 }\n-                prev_span = Some(binding.span);\n+                prev = ty;\n+            } else {\n+                let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n+                if ty.references_error() {\n+                    break;\n+                }\n+                if ty != prev\n+                    && let Some(span) = prev_span\n+                    && self.can_eq(self.param_env, ty, found).is_ok()\n+                {\n+                    // We only point at the first place where the found type was inferred.\n+                    // We use the *previous* span because if the type is known *here* it means\n+                    // it was *evaluated earlier*. We don't do this for method calls because we\n+                    // evaluate the method's self type eagerly, but not in any other case.\n+                    err.span_label(\n+                        span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                        )),\n+                    );\n+                    break;\n+                }\n+                prev = ty;\n+            }\n+            if binding.hir_id == expr.hir_id {\n+                // Do not look at expressions that come after the expression we were originally\n+                // evaluating and had a type error.\n+                break;\n             }\n+            prev_span = Some(binding.span);\n         }\n         true\n     }"}]}