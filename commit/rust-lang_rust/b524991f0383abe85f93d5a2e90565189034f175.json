{"sha": "b524991f0383abe85f93d5a2e90565189034f175", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MjQ5OTFmMDM4M2FiZTg1ZjkzZDVhMmU5MDU2NTE4OTAzNGYxNzU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-24T01:59:22Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:33Z"}, "message": "Refactor astconv.rs (part ii)", "tree": {"sha": "f120c5067b1b99137c9308600982690ec26ba736", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f120c5067b1b99137c9308600982690ec26ba736"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b524991f0383abe85f93d5a2e90565189034f175", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b524991f0383abe85f93d5a2e90565189034f175", "html_url": "https://github.com/rust-lang/rust/commit/b524991f0383abe85f93d5a2e90565189034f175", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b524991f0383abe85f93d5a2e90565189034f175/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d07db436db3a3c1bf3e3940423ee91d2ca368c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d07db436db3a3c1bf3e3940423ee91d2ca368c7", "html_url": "https://github.com/rust-lang/rust/commit/5d07db436db3a3c1bf3e3940423ee91d2ca368c7"}], "stats": {"total": 186, "additions": 117, "deletions": 69}, "files": [{"sha": "ccea902e4b601a8e40f4456a980430253bcb213f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 116, "deletions": 67, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/b524991f0383abe85f93d5a2e90565189034f175/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b524991f0383abe85f93d5a2e90565189034f175/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b524991f0383abe85f93d5a2e90565189034f175", "patch": "@@ -13,12 +13,13 @@\n //! is parameterized by an instance of `AstConv`.\n \n use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::array_vec::ArrayVec;\n use hir::{self, GenericArg};\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::GenericParamDefKind;\n@@ -270,85 +271,133 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             false\n         };\n \n-        let self_offset = self_ty.is_some() as usize;\n-        let substs = Substs::for_item(tcx, def_id, |param, substs| {\n-            if param.index == 0 {\n-                if let Some(ty) = self_ty {\n-                    if let GenericParamDefKind::Type { .. } = param.kind {\n-                        // Handle `Self` first.\n-                        return ty.into();\n+        // Collect the segments of the path: we need to substitute arguments\n+        // for parameters throughout the entire path (wherever there are\n+        // generic parameters).\n+        let mut parent_defs = self.tcx().generics_of(def_id);\n+        let count = parent_defs.count();\n+        let mut stack = vec![(def_id, parent_defs)];\n+        while let Some(def_id) = parent_defs.parent {\n+            parent_defs = self.tcx().generics_of(def_id);\n+            stack.push((def_id, parent_defs));\n+        }\n+\n+        // We manually build up the substitution, rather than using convenience\n+        // methods in subst.rs so that we can iterate over the arguments and\n+        // parameters in lock-step linearly, rather than trying to match each pair.\n+        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n+            AccumulateVec::Array(ArrayVec::new())\n+        } else {\n+            AccumulateVec::Heap(Vec::with_capacity(count))\n+        };\n+        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n+            match substs {\n+                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n+                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n+            }\n+        }\n+\n+        // Iterate over each segment of the path.\n+        while let Some((_, defs)) = stack.pop() {\n+            let mut params = defs.params.iter();\n+            let mut next_param = params.next();\n+\n+            // `Self` is handled first.\n+            if let Some(ty) = self_ty {\n+                if let Some(param) = next_param {\n+                    if param.index == 0 {\n+                        if let GenericParamDefKind::Type { .. } = param.kind {\n+                            push_kind(&mut substs, ty.into());\n+                            next_param = params.next();\n+                        }\n                     }\n                 }\n             }\n \n-            let inferred_lifetimes = if lt_provided == 0 {\n-                lt_accepted\n-            } else {\n-                0\n-            };\n-\n-            let param_idx = (param.index as usize - self_offset).saturating_sub(inferred_lifetimes);\n-\n-            if let Some(arg) = generic_args.args.get(param_idx) {\n-                match param.kind {\n-                    GenericParamDefKind::Lifetime => match arg {\n-                        GenericArg::Lifetime(lt) => {\n-                            return self.ast_region_to_region(lt, Some(param)).into();\n+            let args = &generic_args.args;\n+            'args: for arg in args {\n+                while let Some(param) = next_param {\n+                    match param.kind {\n+                        GenericParamDefKind::Lifetime => match arg {\n+                            GenericArg::Lifetime(lt) => {\n+                                push_kind(&mut substs,\n+                                    self.ast_region_to_region(&lt, Some(param)).into());\n+                                next_param = params.next();\n+                                continue 'args;\n+                            }\n+                            GenericArg::Type(_) => {\n+                                // We expected a lifetime argument, but got a type\n+                                // argument. That means we're inferring the lifetimes.\n+                                push_kind(&mut substs, tcx.types.re_static.into());\n+                                next_param = params.next();\n+                            }\n+                        }\n+                        GenericParamDefKind::Type { .. } => match arg {\n+                            GenericArg::Type(ty) => {\n+                                push_kind(&mut substs, self.ast_ty_to_ty(&ty).into());\n+                                next_param = params.next();\n+                                continue 'args;\n+                            }\n+                            GenericArg::Lifetime(_) => {\n+                                break 'args;\n+                            }\n                         }\n-                        _ => {}\n-                    }\n-                    GenericParamDefKind::Type { .. } => match arg {\n-                        GenericArg::Type(ty) => return self.ast_ty_to_ty(ty).into(),\n-                        _ => {}\n                     }\n                 }\n             }\n \n-            match param.kind {\n-                GenericParamDefKind::Lifetime => tcx.types.re_static.into(),\n-                GenericParamDefKind::Type { has_default, .. } => {\n-                    if infer_types {\n-                        // No type parameters were provided, we can infer all.\n-                        if !default_needs_object_self(param) {\n-                            self.ty_infer_for_def(param, span).into()\n-                        } else {\n-                            self.ty_infer(span).into()\n-                        }\n-                    } else if has_default {\n-                        // No type parameter provided, but a default exists.\n-\n-                        // If we are converting an object type, then the\n-                        // `Self` parameter is unknown. However, some of the\n-                        // other type parameters may reference `Self` in their\n-                        // defaults. This will lead to an ICE if we are not\n-                        // careful!\n-                        if default_needs_object_self(param) {\n-                            struct_span_err!(tcx.sess, span, E0393,\n-                                                \"the type parameter `{}` must be explicitly \\\n-                                                specified\",\n-                                                param.name)\n-                                .span_label(span,\n-                                            format!(\"missing reference to `{}`\", param.name))\n-                                .note(&format!(\"because of the default `Self` reference, \\\n-                                                type parameters must be specified on object \\\n-                                                types\"))\n-                                .emit();\n-                            tcx.types.err.into()\n+            while let Some(param) = next_param {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        push_kind(&mut substs, tcx.types.re_static.into());\n+                    }\n+                    GenericParamDefKind::Type { has_default, .. } => {\n+                        if infer_types {\n+                            // No type parameters were provided, we can infer all.\n+                            push_kind(&mut substs, if !default_needs_object_self(param) {\n+                                self.ty_infer_for_def(param, span).into()\n+                            } else {\n+                                self.ty_infer(span).into()\n+                            });\n+                        } else if has_default {\n+                            // No type parameter provided, but a default exists.\n+\n+                            // If we are converting an object type, then the\n+                            // `Self` parameter is unknown. However, some of the\n+                            // other type parameters may reference `Self` in their\n+                            // defaults. This will lead to an ICE if we are not\n+                            // careful!\n+                            if default_needs_object_self(param) {\n+                                struct_span_err!(tcx.sess, span, E0393,\n+                                                    \"the type parameter `{}` must be explicitly \\\n+                                                    specified\",\n+                                                    param.name)\n+                                    .span_label(span,\n+                                                format!(\"missing reference to `{}`\", param.name))\n+                                    .note(&format!(\"because of the default `Self` reference, \\\n+                                                    type parameters must be specified on object \\\n+                                                    types\"))\n+                                    .emit();\n+                                push_kind(&mut substs, tcx.types.err.into());\n+                            } else {\n+                                // This is a default type parameter.\n+                                let kind = self.normalize_ty(\n+                                    span,\n+                                    tcx.at(span).type_of(param.def_id)\n+                                        .subst_spanned(tcx, &substs, Some(span))\n+                                ).into();\n+                                push_kind(&mut substs, kind);\n+                            }\n                         } else {\n-                            // This is a default type parameter.\n-                            self.normalize_ty(\n-                                span,\n-                                tcx.at(span).type_of(param.def_id)\n-                                    .subst_spanned(tcx, substs, Some(span))\n-                            ).into()\n+                            // We've already errored above about the mismatch.\n+                            push_kind(&mut substs, tcx.types.err.into());\n                         }\n-                    } else {\n-                        // We've already errored above about the mismatch.\n-                        tcx.types.err.into()\n                     }\n-                }\n+                };\n+                next_param = params.next();\n             }\n-        });\n+        }\n+        let substs = self.tcx().intern_substs(&substs);\n \n         let assoc_bindings = generic_args.bindings.iter().map(|binding| {\n             ConvertedBinding {"}, {"sha": "3b0eedae14c1d43c004408703244cf846462da15", "filename": "src/test/ui/error-codes/E0107.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b524991f0383abe85f93d5a2e90565189034f175/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b524991f0383abe85f93d5a2e90565189034f175/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0107.rs?ref=b524991f0383abe85f93d5a2e90565189034f175", "patch": "@@ -29,5 +29,4 @@ struct Baz<'a, 'b, 'c> {\n     //~| 2 unexpected lifetime parameters\n }\n \n-fn main() {\n-}\n+fn main() {}"}]}