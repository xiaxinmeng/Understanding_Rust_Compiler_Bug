{"sha": "dad2db7c83de71063b9311eb3e41bdf4027616f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZDJkYjdjODNkZTcxMDYzYjkzMTFlYjNlNDFiZGY0MDI3NjE2ZjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-17T13:07:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-21T16:32:36Z"}, "message": "Change method lookup infrastructure to use the trait methods. Instead\nof tracking individual candidates per impl, we just track one\ncandidate for the extension trait itself, and let the trait resolution\nhandle walking the individual impls and so forth. Also change the\ninterface to report back a richer notion of error.", "tree": {"sha": "c6a25441b841f140e5edd80f7a97345825f49743", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6a25441b841f140e5edd80f7a97345825f49743"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dad2db7c83de71063b9311eb3e41bdf4027616f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dad2db7c83de71063b9311eb3e41bdf4027616f6", "html_url": "https://github.com/rust-lang/rust/commit/dad2db7c83de71063b9311eb3e41bdf4027616f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dad2db7c83de71063b9311eb3e41bdf4027616f6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1562d8cbd890d39640d98afa59424cc8002ea85a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1562d8cbd890d39640d98afa59424cc8002ea85a", "html_url": "https://github.com/rust-lang/rust/commit/1562d8cbd890d39640d98afa59424cc8002ea85a"}], "stats": {"total": 1301, "additions": 640, "deletions": 661}, "files": [{"sha": "71855f38ba206e97999fef6fc28a5ce93daa7bb8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dad2db7c83de71063b9311eb3e41bdf4027616f6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad2db7c83de71063b9311eb3e41bdf4027616f6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dad2db7c83de71063b9311eb3e41bdf4027616f6", "patch": "@@ -120,6 +120,13 @@ impl ImplOrTraitItem {\n             TypeTraitItem(ref associated_type) => associated_type.container,\n         }\n     }\n+\n+    pub fn as_opt_method(&self) -> Option<Rc<Method>> {\n+        match *self {\n+            MethodTraitItem(ref m) => Some((*m).clone()),\n+            TypeTraitItem(_) => None\n+        }\n+    }\n }\n \n #[deriving(Clone)]\n@@ -1240,6 +1247,10 @@ impl Generics {\n }\n \n impl TraitRef {\n+    pub fn new(def_id: ast::DefId, substs: Substs) -> TraitRef {\n+        TraitRef { def_id: def_id, substs: substs }\n+    }\n+\n     pub fn self_ty(&self) -> ty::t {\n         self.substs.self_ty().unwrap()\n     }"}, {"sha": "4560c5194649410e769d79f98de7a3972b2d211a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 608, "deletions": 626, "changes": 1234, "blob_url": "https://github.com/rust-lang/rust/blob/dad2db7c83de71063b9311eb3e41bdf4027616f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad2db7c83de71063b9311eb3e41bdf4027616f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=dad2db7c83de71063b9311eb3e41bdf4027616f6", "patch": "@@ -81,30 +81,31 @@ obtained the type `Foo`, we would never match this method.\n \n \n use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, SelfSpace};\n use middle::traits;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n use middle::typeck::check::{impl_self_ty};\n+use middle::typeck::check::vtable2::select_fcx_obligations_where_possible;\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{MethodCall, MethodCallee};\n use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::TypeAndSubsts;\n+use middle::ty_fold::TypeFoldable;\n use util::common::indenter;\n use util::ppaux;\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast::{DefId, MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token;\n \n #[deriving(PartialEq)]\n pub enum CheckTraitsFlag {\n@@ -118,26 +119,31 @@ pub enum AutoderefReceiverFlag {\n     DontAutoderefReceiver,\n }\n \n-#[deriving(PartialEq)]\n-pub enum StaticMethodsFlag {\n-    ReportStaticMethods,\n-    IgnoreStaticMethods,\n+pub enum MethodError {\n+    // Did not find an applicable method, but we did find various\n+    // static methods that may apply.\n+    NoMatch(Vec<CandidateSource>),\n+\n+    // Multiple methods might apply.\n+    Ambiguity(Vec<CandidateSource>),\n }\n \n+pub type MethodResult = Result<MethodCallee, MethodError>;\n+\n pub fn lookup<'a, 'tcx>(\n-        fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-        // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: &ast::Expr,                   // The expression `a.b(...)`.\n-        self_expr: &'a ast::Expr,           // The expression `a`.\n-        m_name: ast::Name,                  // The name `b`.\n-        self_ty: ty::t,                     // The type of `a`.\n-        supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n-        deref_args: check::DerefArgs,       // Whether we autopointer first.\n-        check_traits: CheckTraitsFlag,      // Whether we check traits only.\n-        autoderef_receiver: AutoderefReceiverFlag,\n-        report_statics: StaticMethodsFlag)\n-     -> Option<MethodCallee> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+\n+    // In a call `a.b::<X, Y, ...>(...)`:\n+    expr: &ast::Expr,                   // The expression `a.b(...)`.\n+    self_expr: &'a ast::Expr,           // The expression `a`.\n+    m_name: ast::Name,                  // The name `b`.\n+    self_ty: ty::t,                     // The type of `a`.\n+    supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n+    deref_args: check::DerefArgs,       // Whether we autopointer first.\n+    check_traits: CheckTraitsFlag,      // Whether we check traits only.\n+    autoderef_receiver: AutoderefReceiverFlag)\n+    -> MethodResult\n+{\n     let mut lcx = LookupContext {\n         fcx: fcx,\n         span: expr.span,\n@@ -147,10 +153,10 @@ pub fn lookup<'a, 'tcx>(\n         impl_dups: HashSet::new(),\n         inherent_candidates: Vec::new(),\n         extension_candidates: Vec::new(),\n+        static_candidates: Vec::new(),\n         deref_args: deref_args,\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n-        report_statics: report_statics,\n     };\n \n     debug!(\"method lookup(self_ty={}, expr={}, self_expr={})\",\n@@ -166,16 +172,17 @@ pub fn lookup<'a, 'tcx>(\n }\n \n pub fn lookup_in_trait<'a, 'tcx>(\n-        fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-        // In a call `a.b::<X, Y, ...>(...)`:\n-        span: Span,                         // The expression `a.b(...)`'s span.\n-        self_expr: Option<&'a ast::Expr>,   // The expression `a`, if available.\n-        m_name: ast::Name,                  // The name `b`.\n-        trait_did: DefId,                   // The trait to limit the lookup to.\n-        self_ty: ty::t,                     // The type of `a`.\n-        supplied_tps: &'a [ty::t])          // The list of types X, Y, ... .\n-     -> Option<MethodCallee> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+\n+    // In a call `a.b::<X, Y, ...>(...)`:\n+    span: Span,                         // The expression `a.b(...)`'s span.\n+    self_expr: Option<&'a ast::Expr>,   // The expression `a`, if available.\n+    m_name: ast::Name,                  // The name `b`.\n+    trait_did: DefId,                   // The trait to limit the lookup to.\n+    self_ty: ty::t,                     // The type of `a`.\n+    supplied_tps: &'a [ty::t])          // The list of types X, Y, ... .\n+    -> Option<MethodCallee>\n+{\n     let mut lcx = LookupContext {\n         fcx: fcx,\n         span: span,\n@@ -185,18 +192,107 @@ pub fn lookup_in_trait<'a, 'tcx>(\n         impl_dups: HashSet::new(),\n         inherent_candidates: Vec::new(),\n         extension_candidates: Vec::new(),\n+        static_candidates: Vec::new(),\n         deref_args: check::DoDerefArgs,\n         check_traits: CheckTraitsOnly,\n         autoderef_receiver: DontAutoderefReceiver,\n-        report_statics: IgnoreStaticMethods,\n     };\n \n-    debug!(\"method lookup_in_trait(self_ty={}, self_expr={})\",\n-           self_ty.repr(fcx.tcx()), self_expr.map(|e| e.repr(fcx.tcx())));\n+    debug!(\"method lookup_in_trait(self_ty={}, self_expr={}, m_name={}, trait_did={})\",\n+           self_ty.repr(fcx.tcx()),\n+           self_expr.repr(fcx.tcx()),\n+           m_name.repr(fcx.tcx()),\n+           trait_did.repr(fcx.tcx()));\n \n     lcx.push_bound_candidates(self_ty, Some(trait_did));\n     lcx.push_extension_candidate(trait_did);\n-    lcx.search(self_ty)\n+\n+    // when doing a trait search, ambiguity can't really happen except\n+    // as part of the trait-lookup in general\n+    match lcx.search(self_ty) {\n+        Ok(callee) => Some(callee),\n+        Err(_) => None\n+    }\n+}\n+\n+pub fn report_error(fcx: &FnCtxt,\n+                    span: Span,\n+                    rcvr_ty: ty::t,\n+                    method_name: ast::Name,\n+                    error: MethodError)\n+{\n+    match error {\n+        NoMatch(static_sources) => {\n+            fcx.type_error_message(\n+                span,\n+                |actual| {\n+                    format!(\"type `{}` does not implement any \\\n+                             method in scope named `{}`\",\n+                            actual,\n+                            method_name.user_string(fcx.tcx()))\n+                },\n+                rcvr_ty,\n+                None);\n+\n+            if static_sources.len() > 0 {\n+                fcx.tcx().sess.fileline_note(\n+                    span,\n+                    \"found defined static methods, maybe a `self` is missing?\");\n+\n+                report_candidates(fcx, span, method_name, static_sources);\n+            }\n+        }\n+\n+        Ambiguity(sources) => {\n+            span_err!(fcx.sess(), span, E0034,\n+                      \"multiple applicable methods in scope\");\n+\n+            report_candidates(fcx, span, method_name, sources);\n+        }\n+    }\n+\n+    fn report_candidates(fcx: &FnCtxt,\n+                         span: Span,\n+                         method_name: ast::Name,\n+                         mut sources: Vec<CandidateSource>) {\n+        sources.sort();\n+        sources.dedup();\n+\n+        for (idx, source) in sources.iter().enumerate() {\n+            match *source {\n+                ImplSource(impl_did) => {\n+                    // Provide the best span we can. Use the method, if local to crate, else\n+                    // the impl, if local to crate (method may be defaulted), else the call site.\n+                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n+                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n+\n+                    let impl_ty = impl_self_ty(fcx, span, impl_did).ty;\n+\n+                    let insertion = match impl_trait_ref(fcx.tcx(), impl_did) {\n+                        None => format!(\"\"),\n+                        Some(trait_ref) => format!(\" of the trait `{}`\",\n+                                                   ty::item_path_str(fcx.tcx(),\n+                                                                     trait_ref.def_id)),\n+                    };\n+\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n+                               idx + 1u,\n+                               insertion,\n+                               impl_ty.user_string(fcx.tcx()));\n+                }\n+                TraitSource(trait_did) => {\n+                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n+                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n+                    span_note!(fcx.sess(), method_span,\n+                               \"candidate #{} is defined in the trait `{}`\",\n+                               idx + 1u,\n+                               ty::item_path_str(fcx.tcx(), trait_did));\n+                }\n+            }\n+        }\n+    }\n }\n \n // Determine the index of a method in the list of all methods belonging\n@@ -228,75 +324,6 @@ fn get_method_index(tcx: &ty::ctxt,\n     method_count + n_method\n }\n \n-fn construct_transformed_self_ty_for_object(\n-    tcx: &ty::ctxt,\n-    span: Span,\n-    trait_def_id: ast::DefId,\n-    rcvr_substs: &subst::Substs,\n-    rcvr_bounds: ty::ExistentialBounds,\n-    method_ty: &ty::Method)\n-    -> ty::t\n-{\n-    /*!\n-     * This is a bit tricky. We have a match against a trait method\n-     * being invoked on an object, and we want to generate the\n-     * self-type. As an example, consider a trait\n-     *\n-     *     trait Foo {\n-     *         fn r_method<'a>(&'a self);\n-     *         fn u_method(Box<self>);\n-     *     }\n-     *\n-     * Now, assuming that `r_method` is being called, we want the\n-     * result to be `&'a Foo`. Assuming that `u_method` is being\n-     * called, we want the result to be `Box<Foo>`. Of course,\n-     * this transformation has already been done as part of\n-     * `method_ty.fty.sig.inputs[0]`, but there the type\n-     * is expressed in terms of `Self` (i.e., `&'a Self`, `Box<Self>`).\n-     * Because objects are not standalone types, we can't just substitute\n-     * `s/Self/Foo/`, so we must instead perform this kind of hokey\n-     * match below.\n-     */\n-\n-    let mut obj_substs = rcvr_substs.clone();\n-\n-    // The subst we get in has Err as the \"Self\" type. For an object\n-    // type, we don't put any type into the Self paramspace, so let's\n-    // make a copy of rcvr_substs that has the Self paramspace empty.\n-    obj_substs.types.pop(subst::SelfSpace).unwrap();\n-\n-    match method_ty.explicit_self {\n-        StaticExplicitSelfCategory => {\n-            tcx.sess.span_bug(span, \"static method for object type receiver\");\n-        }\n-        ByValueExplicitSelfCategory => {\n-            let tr = ty::mk_trait(tcx, trait_def_id, obj_substs, rcvr_bounds);\n-            ty::mk_uniq(tcx, tr)\n-        }\n-        ByReferenceExplicitSelfCategory(..) | ByBoxExplicitSelfCategory => {\n-            let transformed_self_ty = method_ty.fty.sig.inputs[0];\n-            match ty::get(transformed_self_ty).sty {\n-                ty::ty_rptr(r, mt) => { // must be SelfRegion\n-                    let r = r.subst(tcx, rcvr_substs); // handle Early-Bound lifetime\n-                    let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                          rcvr_bounds);\n-                    ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: mt.mutbl })\n-                }\n-                ty::ty_uniq(_) => { // must be SelfUniq\n-                    let tr = ty::mk_trait(tcx, trait_def_id, obj_substs,\n-                                          rcvr_bounds);\n-                    ty::mk_uniq(tcx, tr)\n-                }\n-                _ => {\n-                    tcx.sess.span_bug(span,\n-                        format!(\"'impossible' transformed_self_ty: {}\",\n-                                transformed_self_ty.repr(tcx)).as_slice());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n struct LookupContext<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n@@ -311,42 +338,45 @@ struct LookupContext<'a, 'tcx: 'a> {\n     supplied_tps: &'a [ty::t],\n     impl_dups: HashSet<DefId>,\n     inherent_candidates: Vec<Candidate>,\n-    extension_candidates: Vec<Candidate>,\n+    extension_candidates: Vec<ExtensionCandidate>,\n+    static_candidates: Vec<CandidateSource>,\n     deref_args: check::DerefArgs,\n     check_traits: CheckTraitsFlag,\n     autoderef_receiver: AutoderefReceiverFlag,\n-    report_statics: StaticMethodsFlag,\n }\n \n-/**\n- * A potential method that might be called, assuming the receiver\n- * is of a suitable type.\n- */\n+// A method that the user may be trying to invoke. Initially, we\n+// construct candidates only for inherent methods; for extension\n+// traits, we use an ExtensionCandidate.\n #[deriving(Clone)]\n struct Candidate {\n-    rcvr_match_condition: RcvrMatchCondition,\n+    xform_self_ty: ty::t,\n     rcvr_substs: subst::Substs,\n     method_ty: Rc<ty::Method>,\n     origin: MethodOrigin,\n }\n \n-/// This type represents the conditions under which the receiver is\n-/// considered to \"match\" a given method candidate. Typically the test\n-/// is whether the receiver is of a particular type. However, this\n-/// type is the type of the receiver *after accounting for the\n-/// method's self type* (e.g., if the method is an `Box<self>` method, we\n-/// have *already verified* that the receiver is of some type `Box<T>` and\n-/// now we must check that the type `T` is correct).  Unfortunately,\n-/// because traits are not types, this is a pain to do.\n-#[deriving(Clone)]\n-pub enum RcvrMatchCondition {\n-    RcvrMatchesIfObject(ast::DefId),\n-    RcvrMatchesIfSubtype(ty::t),\n-    RcvrMatchesIfEqtype(ty::t)\n+// A variation on a candidate that just stores the data needed\n+// extension trait matching.  Once we pick the trait that matches,\n+// we'll construct a normal candidate from that. There is no deep\n+// reason for this, the code just worked out a bit cleaner.\n+struct ExtensionCandidate {\n+    obligation: traits::Obligation,\n+    xform_self_ty: ty::t,\n+    method_ty: Rc<ty::Method>,\n+    method_num: uint,\n+}\n+\n+// A pared down enum describing just the places from which a method\n+// candidate can arise. Used for error reporting only.\n+#[deriving(PartialOrd, Ord, PartialEq, Eq)]\n+pub enum CandidateSource {\n+    ImplSource(ast::DefId),\n+    TraitSource(/* trait id */ ast::DefId),\n }\n \n impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n-    fn search(&self, self_ty: ty::t) -> Option<MethodCallee> {\n+    fn search(self, self_ty: ty::t) -> MethodResult {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let self_expr_id = self.self_expr.map(|e| e.id);\n \n@@ -356,18 +386,33 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 |self_ty, autoderefs| self.search_step(self_ty, autoderefs));\n \n         match result {\n-            Some(Some(result)) => {\n+            Some(Some(Ok(result))) => {\n                 self.fixup_derefs_on_method_receiver_if_necessary(&result);\n-                Some(result)\n+                Ok(result)\n+            }\n+            Some(Some(Err(err))) => {\n+                Err(err)\n+            }\n+            None | Some(None) => {\n+                Err(NoMatch(self.static_candidates))\n             }\n-            _ => None\n         }\n     }\n \n     fn search_step(&self,\n                    self_ty: ty::t,\n                    autoderefs: uint)\n-                   -> Option<Option<MethodCallee>> {\n+                   -> Option<Option<MethodResult>>\n+    {\n+        // Oh my, what a return type!\n+        //\n+        // Returning:\n+        // - `None` => autoderef more, keep searching\n+        // - `Some(None)` => stop searching, found nothing\n+        // - `Some(Some(_))` => stop searching, found either callee/error\n+        //   - `Some(Some(Ok(_)))` => found a callee\n+        //   - `Some(Some(Err(_)))` => found an error (ambiguity, etc)\n+\n         debug!(\"search_step: self_ty={} autoderefs={}\",\n                self.ty_to_string(self_ty), autoderefs);\n \n@@ -418,7 +463,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         self.self_expr.is_none()\n     }\n \n-    // ______________________________________________________________________\n+    ///////////////////////////////////////////////////////////////////////////\n     // Candidate collection (see comment at start of file)\n \n     fn push_inherent_candidates(&mut self, self_ty: ty::t) {\n@@ -435,8 +480,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         check::autoderef(self.fcx, span, self_ty, None, NoPreference, |self_ty, _| {\n             match get(self_ty).sty {\n                 ty_trait(box TyTrait { def_id, ref substs, bounds, .. }) => {\n-                    self.push_inherent_candidates_from_object(\n-                        def_id, substs, bounds);\n+                    self.push_inherent_candidates_from_object(self_ty, def_id, substs, bounds);\n                     self.push_inherent_impl_candidates_for_type(def_id);\n                 }\n                 ty_enum(did, _) |\n@@ -465,10 +509,6 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n                 }\n-                ty_unboxed_closure(closure_did, _) => {\n-                    self.push_unboxed_closure_call_candidates_if_applicable(\n-                        closure_did);\n-                }\n                 _ => { /* No bound methods in these types */ }\n             }\n \n@@ -481,152 +521,128 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         });\n     }\n \n-    fn push_extension_candidate(&mut self, trait_did: DefId) {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n-\n-        // Look for explicit implementations.\n-        let impl_items = self.tcx().impl_items.borrow();\n-        for impl_infos in self.tcx().trait_impls.borrow().find(&trait_did).iter() {\n-            for impl_did in impl_infos.borrow().iter() {\n-                let items = &(*impl_items)[*impl_did];\n-                self.push_candidates_from_impl(*impl_did,\n-                                               items.as_slice(),\n-                                               true);\n-            }\n-        }\n-    }\n-\n     fn push_extension_candidates(&mut self, expr_id: ast::NodeId) {\n-        // If the method being called is associated with a trait, then\n-        // find all the impls of that trait.  Each of those are\n-        // candidates.\n+        debug!(\"push_extension_candidates(expr_id={})\", expr_id);\n+\n+        let mut duplicates = HashSet::new();\n         let opt_applicable_traits = self.fcx.ccx.trait_map.find(&expr_id);\n         for applicable_traits in opt_applicable_traits.into_iter() {\n-            for trait_did in applicable_traits.iter() {\n-                debug!(\"push_extension_candidates() found trait: {}\",\n-                       if trait_did.krate == ast::LOCAL_CRATE {\n-                           self.fcx.ccx.tcx.map.node_to_string(trait_did.node)\n-                       } else {\n-                           \"(external)\".to_string()\n-                       });\n-                self.push_extension_candidate(*trait_did);\n+            for &trait_did in applicable_traits.iter() {\n+                if duplicates.insert(trait_did) {\n+                    self.push_extension_candidate(trait_did);\n+                }\n             }\n         }\n     }\n \n-    fn push_unboxed_closure_call_candidate_if_applicable(\n-            &mut self,\n-            trait_did: DefId,\n-            closure_did: DefId,\n-            closure_function_type: &ClosureTy) {\n-        let trait_item = (*ty::trait_items(self.tcx(), trait_did))[0]\n-                                                               .clone();\n-        let method = match trait_item {\n-            ty::MethodTraitItem(method) => method,\n-            ty::TypeTraitItem(_) => {\n-                self.tcx().sess.bug(\n-                    \"push_unboxed_closure_call_candidates_if_applicable(): \\\n-                     unexpected associated type in function trait\")\n-            }\n+    fn push_extension_candidate(&mut self, trait_def_id: DefId) {\n+        debug!(\"push_extension_candidates: trait_def_id={}\", trait_def_id);\n+\n+        // Check whether `trait_def_id` defines a method with suitable name:\n+        let trait_items =\n+            ty::trait_items(self.tcx(), trait_def_id);\n+        let matching_index =\n+            trait_items.iter()\n+                       .position(|item| item.ident().name == self.m_name);\n+        let matching_index = match matching_index {\n+            Some(i) => i,\n+            None => { return; }\n+        };\n+        let method = match (&*trait_items)[matching_index].as_opt_method() {\n+            Some(m) => m,\n+            None => { return; }\n         };\n \n-        // Make sure it has the right name!\n-        if method.ident.name != self.m_name {\n-            return\n+        // Check whether `trait_def_id` defines a method with suitable name:\n+        if !self.has_applicable_self(&*method) {\n+            debug!(\"method has inapplicable self\");\n+            return self.record_static_candidate(TraitSource(trait_def_id));\n         }\n \n-        // Get the tupled type of the arguments.\n-        let arguments_type = closure_function_type.sig.inputs[0];\n-        let return_type = closure_function_type.sig.output;\n-\n-        let closure_region =\n-            self.fcx.infcx().next_region_var(infer::MiscVariable(self.span));\n-        let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),\n-                                                          closure_did,\n-                                                          closure_region);\n-        self.extension_candidates.push(Candidate {\n-            rcvr_match_condition:\n-                RcvrMatchesIfSubtype(unboxed_closure_type),\n-            rcvr_substs: subst::Substs::new_trait(\n-                vec![arguments_type, return_type],\n-                vec![],\n-                self.fcx.infcx().next_ty_vars(1)[0]),\n+        // Otherwise, construct the receiver type.\n+        let self_ty =\n+            self.fcx.infcx().next_ty_var();\n+        let trait_def =\n+            ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let substs =\n+            self.fcx.infcx().fresh_substs_for_trait(self.span,\n+                                                    &trait_def.generics,\n+                                                    self_ty);\n+        let xform_self_ty =\n+            self.xform_self_ty(&method, &substs);\n+\n+        // Construct the obligation which must match.\n+        let trait_ref =\n+            Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+        let obligation =\n+            traits::Obligation::misc(self.span, trait_ref);\n+\n+        debug!(\"extension-candidate(xform_self_ty={} obligation={})\",\n+               self.infcx().ty_to_string(xform_self_ty),\n+               obligation.repr(self.tcx()));\n+\n+        self.extension_candidates.push(ExtensionCandidate {\n+            obligation: obligation,\n+            xform_self_ty: xform_self_ty,\n             method_ty: method,\n-            origin: MethodStaticUnboxedClosure(closure_did),\n+            method_num: matching_index,\n         });\n     }\n \n-    fn push_unboxed_closure_call_candidates_if_applicable(\n-            &mut self,\n-            closure_did: DefId) {\n-        match self.tcx().unboxed_closures.borrow().find(&closure_did) {\n-            None => {}  // Fall through to try inherited.\n-            Some(closure) => {\n-                let tcx = self.tcx();\n-                self.push_unboxed_closure_call_candidate_if_applicable(\n-                    closure.kind.trait_did(tcx),\n-                    closure_did,\n-                    &closure.closure_type);\n-                return\n-            }\n-        }\n-\n-        match self.fcx.inh.unboxed_closures.borrow().find(&closure_did) {\n-            Some(closure) => {\n-                let tcx = self.tcx();\n-                self.push_unboxed_closure_call_candidate_if_applicable(\n-                    closure.kind.trait_did(tcx),\n-                    closure_did,\n-                    &closure.closure_type);\n-                return\n-            }\n-            None => {}\n-        }\n-\n-        self.tcx().sess.bug(\"didn't find unboxed closure type in tcx map or \\\n-                             inherited map, so there\")\n-    }\n-\n     fn push_inherent_candidates_from_object(&mut self,\n+                                            self_ty: ty::t,\n                                             did: DefId,\n                                             substs: &subst::Substs,\n-                                            bounds: ty::ExistentialBounds) {\n-        debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n-               self.did_to_string(did),\n-               substs.repr(self.tcx()));\n+                                            _bounds: ty::ExistentialBounds) {\n+        debug!(\"push_inherent_candidates_from_object(self_ty={})\",\n+               self_ty.repr(self.tcx()));\n+\n         let tcx = self.tcx();\n-        let span = self.span;\n \n         // It is illegal to invoke a method on a trait instance that\n-        // refers to the `self` type. An error will be reported by\n-        // `enforce_object_limitations()` if the method refers\n-        // to the `Self` type. Substituting ty_err here allows\n-        // compiler to soldier on.\n-        //\n-        // `confirm_candidate()` also relies upon this substitution\n-        // for Self. (fix)\n-        let rcvr_substs = substs.with_self_ty(ty::mk_err());\n+        // refers to the `Self` type. An error will be reported by\n+        // `enforce_object_limitations()` if the method refers to the\n+        // `Self` type anywhere other than the receiver. Here, we use\n+        // a substitution that replaces `Self` with the object type\n+        // itself. Hence, a `&self` method will wind up with an\n+        // argument type like `&Trait`.\n+        let rcvr_substs = substs.with_self_ty(self_ty);\n         let trait_ref = Rc::new(TraitRef {\n             def_id: did,\n             substs: rcvr_substs.clone()\n         });\n \n         self.push_inherent_candidates_from_bounds_inner(\n             &[trait_ref.clone()],\n-            |_this, new_trait_ref, m, method_num| {\n+            |this, new_trait_ref, m, method_num| {\n                 let vtable_index =\n                     get_method_index(tcx, &*new_trait_ref,\n                                      trait_ref.clone(), method_num);\n-                let mut m = (*m).clone();\n-                // We need to fix up the transformed self type.\n-                *m.fty.sig.inputs.get_mut(0) =\n-                    construct_transformed_self_ty_for_object(\n-                        tcx, span, did, &rcvr_substs, bounds, &m);\n+\n+                // FIXME Hacky. By-value `self` methods in objects ought to be\n+                // just a special case of passing ownership of a DST value\n+                // as a parameter. *But* we currently hack them in and tie them to\n+                // the particulars of the `Box` type. So basically for a `fn foo(self,...)`\n+                // method invoked on an object, we don't want the receiver type to be\n+                // `TheTrait`, but rather `Box<TheTrait>`. Yuck.\n+                let mut m = m;\n+                match m.explicit_self {\n+                    ByValueExplicitSelfCategory => {\n+                        let mut n = (*m).clone();\n+                        let self_ty = n.fty.sig.inputs[0];\n+                        *n.fty.sig.inputs.get_mut(0) = ty::mk_uniq(tcx, self_ty);\n+                        m = Rc::new(n);\n+                    }\n+                    _ => { }\n+                }\n+\n+                let xform_self_ty =\n+                    this.xform_self_ty(&m, &new_trait_ref.substs);\n \n                 Some(Candidate {\n-                    rcvr_match_condition: RcvrMatchesIfObject(did),\n+                    xform_self_ty: xform_self_ty,\n                     rcvr_substs: new_trait_ref.substs.clone(),\n-                    method_ty: Rc::new(m),\n+                    method_ty: m,\n                     origin: MethodTraitObject(MethodObject {\n                         trait_ref: new_trait_ref,\n                         object_trait_id: did,\n@@ -650,9 +666,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             restrict_to);\n     }\n \n-\n     fn push_inherent_candidates_from_bounds(&mut self,\n-                                            self_ty: ty::t,\n+                                            _self_ty: ty::t,\n                                             space: subst::ParamSpace,\n                                             index: uint,\n                                             restrict_to: Option<DefId>) {\n@@ -670,12 +685,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     _ => {}\n                 }\n \n-                let condition = match m.explicit_self {\n-                    ByReferenceExplicitSelfCategory(_, mt) if mt == MutMutable =>\n-                        RcvrMatchesIfEqtype(self_ty),\n-                    _ =>\n-                        RcvrMatchesIfSubtype(self_ty)\n-                };\n+                let xform_self_ty =\n+                    this.xform_self_ty(&m, &trait_ref.substs);\n \n                 debug!(\"found match: trait_ref={} substs={} m={}\",\n                        trait_ref.repr(this.tcx()),\n@@ -689,16 +700,17 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                            trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n                 assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n                            trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+\n                 Some(Candidate {\n-                    rcvr_match_condition: condition,\n+                    xform_self_ty: xform_self_ty,\n                     rcvr_substs: trait_ref.substs.clone(),\n                     method_ty: m,\n                     origin: MethodTypeParam(MethodParam {\n                         trait_ref: trait_ref,\n                         method_num: method_num,\n                     })\n                 })\n-        })\n+            })\n     }\n \n     // Do a search through a list of bounds, using a callback to actually\n@@ -720,41 +732,24 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 continue;\n             }\n \n-            let trait_items = ty::trait_items(tcx, bound_trait_ref.def_id);\n-            match trait_items.iter().position(|ti| {\n-                match *ti {\n-                    ty::MethodTraitItem(ref m) => {\n-                        m.explicit_self != ty::StaticExplicitSelfCategory &&\n-                        m.ident.name == self.m_name\n-                    }\n-                    ty::TypeTraitItem(_) => false,\n-                }\n-            }) {\n-                Some(pos) => {\n-                    let method = match (*trait_items)[pos] {\n-                        ty::MethodTraitItem(ref method) => (*method).clone(),\n-                        ty::TypeTraitItem(_) => {\n-                            tcx.sess.bug(\"typechecking associated type as \\\n-                                          though it were a method\")\n-                        }\n-                    };\n+            let (pos, method) = match trait_method(tcx, bound_trait_ref.def_id, self.m_name) {\n+                Some(v) => v,\n+                None => { continue; }\n+            };\n \n-                    match mk_cand(self,\n-                                  bound_trait_ref,\n-                                  method,\n-                                  pos) {\n-                        Some(cand) => {\n-                            debug!(\"pushing inherent candidate for param: {}\",\n-                                   cand.repr(self.tcx()));\n-                            self.inherent_candidates.push(cand);\n-                        }\n-                        None => {}\n+            if !self.has_applicable_self(&*method) {\n+                self.record_static_candidate(TraitSource(bound_trait_ref.def_id));\n+            } else {\n+                match mk_cand(self,\n+                              bound_trait_ref,\n+                              method,\n+                              pos) {\n+                    Some(cand) => {\n+                        debug!(\"pushing inherent candidate for param: {}\",\n+                               cand.repr(self.tcx()));\n+                        self.inherent_candidates.push(cand);\n                     }\n-                }\n-                None => {\n-                    debug!(\"trait doesn't contain method: {}\",\n-                        bound_trait_ref.def_id);\n-                    // check next trait or bound\n+                    None => {}\n                 }\n             }\n         }\n@@ -766,83 +761,47 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n             for impl_did in impl_infos.iter() {\n-                let items = &(*impl_items)[*impl_did];\n-                self.push_candidates_from_impl(*impl_did,\n-                                               items.as_slice(),\n-                                               false);\n+                self.push_candidates_from_inherent_impl(*impl_did);\n             }\n         }\n     }\n \n-    fn push_candidates_from_impl(&mut self,\n-                                 impl_did: DefId,\n-                                 impl_items: &[ImplOrTraitItemId],\n-                                 is_extension: bool) {\n-        let did = if self.report_statics == ReportStaticMethods {\n-            // we only want to report each base trait once\n-            match ty::impl_trait_ref(self.tcx(), impl_did) {\n-                Some(trait_ref) => trait_ref.def_id,\n-                None => impl_did\n-            }\n-        } else {\n-            impl_did\n-        };\n-\n-        if !self.impl_dups.insert(did) {\n+    fn push_candidates_from_inherent_impl(&mut self,\n+                                          impl_did: DefId) {\n+        if !self.impl_dups.insert(impl_did) {\n             return; // already visited\n         }\n \n-        debug!(\"push_candidates_from_impl: {} {}\",\n-               token::get_name(self.m_name),\n-               impl_items.iter()\n-                         .map(|&did| {\n-                             ty::impl_or_trait_item(self.tcx(),\n-                                                    did.def_id()).ident()\n-                         })\n-                         .collect::<Vec<ast::Ident>>()\n-                         .repr(self.tcx()));\n-\n-        let method = match impl_items.iter()\n-                                     .map(|&did| {\n-                                         ty::impl_or_trait_item(self.tcx(),\n-                                                                did.def_id())\n-                                     })\n-                                     .find(|m| {\n-                                         m.ident().name == self.m_name\n-                                     }) {\n-            Some(ty::MethodTraitItem(method)) => method,\n-            Some(ty::TypeTraitItem(_)) | None => {\n-                // No method with the right name.\n-                return\n-            }\n+        let method = match impl_method(self.tcx(), impl_did, self.m_name) {\n+            Some(m) => m,\n+            None => { return; } // No method with correct name on this impl\n         };\n \n-        // determine the `self` of the impl with fresh\n-        // variables for each parameter:\n+        debug!(\"push_candidates_from_inherent_impl: impl_did={} method={}\",\n+               impl_did.repr(self.tcx()),\n+               method.repr(self.tcx()));\n+\n+        if !self.has_applicable_self(&*method) {\n+            // No receiver declared. Not a candidate.\n+            return self.record_static_candidate(ImplSource(impl_did));\n+        }\n+\n+        // Determine the `self` of the impl with fresh\n+        // variables for each parameter.\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let TypeAndSubsts {\n             substs: impl_substs,\n-            ty: impl_ty\n+            ty: _impl_ty\n         } = impl_self_ty(self.fcx, span, impl_did);\n \n-        let condition = match method.explicit_self {\n-            ByReferenceExplicitSelfCategory(_, mt) if mt == MutMutable =>\n-                RcvrMatchesIfEqtype(impl_ty),\n-            _ =>\n-                RcvrMatchesIfSubtype(impl_ty)\n-        };\n-\n-        let candidates = if is_extension {\n-            &mut self.extension_candidates\n-        } else {\n-            &mut self.inherent_candidates\n-        };\n+        // Determine the receiver type that the method itself expects.\n+        let xform_self_ty =\n+            self.xform_self_ty(&method, &impl_substs);\n \n-        candidates.push(Candidate {\n-            rcvr_match_condition: condition,\n+        self.inherent_candidates.push(Candidate {\n+            xform_self_ty: xform_self_ty,\n             rcvr_substs: impl_substs,\n             origin: MethodStatic(method.def_id),\n             method_ty: method,\n@@ -855,7 +814,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn search_for_autoderefd_method(&self,\n                                     self_ty: ty::t,\n                                     autoderefs: uint)\n-                                    -> Option<MethodCallee> {\n+                                    -> Option<MethodResult> {\n         // Hacky. For overloaded derefs, there may be an adjustment\n         // added to the expression from the outside context, so we do not store\n         // an explicit adjustment, but rather we hardwire the single deref\n@@ -868,8 +827,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         let adjustment = Some((self.self_expr.unwrap().id, ty::AdjustDerefRef(auto_deref_ref)));\n \n         match self.search_for_method(self_ty) {\n-            None => None,\n-            Some(method) => {\n+            None => {\n+                None\n+            }\n+            Some(Ok(method)) => {\n                 debug!(\"(searching for autoderef'd method) writing \\\n                        adjustment {} for {}\", adjustment, self.ty_to_string(self_ty));\n                 match adjustment {\n@@ -878,7 +839,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     }\n                     None => {}\n                 }\n-                Some(method)\n+                Some(Ok(method))\n+            }\n+            Some(Err(error)) => {\n+                Some(Err(error))\n             }\n         }\n     }\n@@ -942,7 +906,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     // Takes an [T] - an unwrapped DST pointer (either ~ or &)\n     // [T] to &[T] or &&[T] (note that we started with a &[T] or ~[T] which has\n     // been implicitly derefed).\n-    fn auto_slice_vec(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n+    fn auto_slice_vec(&self, ty: ty::t, autoderefs: uint)\n+                      -> Option<MethodResult>\n+    {\n         let tcx = self.tcx();\n         debug!(\"auto_slice_vec {}\", ppaux::ty_to_string(tcx, ty));\n \n@@ -973,7 +939,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     }\n \n     // [T, ..len] -> [T] or &[T] or &&[T]\n-    fn auto_unsize_vec(&self, ty: ty::t, autoderefs: uint, len: uint) -> Option<MethodCallee> {\n+    fn auto_unsize_vec(&self, ty: ty::t, autoderefs: uint, len: uint) -> Option<MethodResult> {\n         let tcx = self.tcx();\n         debug!(\"auto_unsize_vec {}\", ppaux::ty_to_string(tcx, ty));\n \n@@ -1009,7 +975,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             })\n     }\n \n-    fn auto_slice_str(&self, autoderefs: uint) -> Option<MethodCallee> {\n+    fn auto_slice_str(&self, autoderefs: uint) -> Option<MethodResult> {\n         let tcx = self.tcx();\n         debug!(\"auto_slice_str\");\n \n@@ -1031,7 +997,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     }\n \n     // Coerce Box/&Trait instances to &Trait.\n-    fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodCallee> {\n+    fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodResult> {\n         debug!(\"auto_slice_trait\");\n         match ty::get(ty).sty {\n             ty_trait(box ty::TyTrait {\n@@ -1055,7 +1021,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn search_for_autofatptrd_method(&self,\n                                      self_ty: ty::t,\n                                      autoderefs: uint)\n-                                     -> Option<MethodCallee> {\n+                                     -> Option<MethodResult>\n+    {\n         /*!\n          * Searches for a candidate by converting things like\n          * `~[]` to `&[]`.\n@@ -1082,7 +1049,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     }\n \n     fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n-                                  -> Option<MethodCallee> {\n+                                  -> Option<MethodResult>\n+    {\n         /*!\n          *\n          * Converts any type `T` to `&M T` where `M` is an\n@@ -1116,12 +1084,13 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     }\n \n     fn search_for_some_kind_of_autorefd_method(\n-            &self,\n-            kind: |Region, ast::Mutability| -> ty::AutoRef,\n-            autoderefs: uint,\n-            mutbls: &[ast::Mutability],\n-            mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n-            -> Option<MethodCallee> {\n+        &self,\n+        kind: |Region, ast::Mutability| -> ty::AutoRef,\n+        autoderefs: uint,\n+        mutbls: &[ast::Mutability],\n+        mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n+        -> Option<MethodResult>\n+    {\n         // Hacky. For overloaded derefs, there may be an adjustment\n         // added to the expression from the outside context, so we do not store\n         // an explicit adjustment, but rather we hardwire the single deref\n@@ -1164,7 +1133,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         None\n     }\n \n-    fn search_for_method(&self, rcvr_ty: ty::t) -> Option<MethodCallee> {\n+    fn search_for_method(&self, rcvr_ty: ty::t) -> Option<MethodResult> {\n         debug!(\"search_for_method(rcvr_ty={})\", self.ty_to_string(rcvr_ty));\n         let _indenter = indenter();\n \n@@ -1181,49 +1150,26 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n \n         debug!(\"searching extension candidates\");\n-        self.consider_candidates(rcvr_ty, self.extension_candidates.as_slice())\n+        self.consider_extension_candidates(rcvr_ty)\n     }\n \n     fn consider_candidates(&self, rcvr_ty: ty::t,\n                            candidates: &[Candidate])\n-                           -> Option<MethodCallee> {\n+                           -> Option<MethodResult> {\n         let relevant_candidates = self.filter_candidates(rcvr_ty, candidates);\n \n         if relevant_candidates.len() == 0 {\n             return None;\n         }\n \n-        if self.report_statics == ReportStaticMethods {\n-            // lookup should only be called with ReportStaticMethods if a regular lookup failed\n-            assert!(relevant_candidates.iter()\n-                                       .all(|c| {\n-                c.method_ty.explicit_self == ty::StaticExplicitSelfCategory\n-            }));\n-\n-            self.tcx().sess.fileline_note(self.span,\n-                                \"found defined static methods, maybe a `self` is missing?\");\n-\n-            for (idx, candidate) in relevant_candidates.iter().enumerate() {\n-                self.report_candidate(idx, &candidate.origin);\n-            }\n-\n-            // return something so we don't get errors for every mutability\n-            return Some(MethodCallee {\n-                origin: relevant_candidates[0].origin.clone(),\n-                ty: ty::mk_err(),\n-                substs: subst::Substs::empty()\n-            });\n-        }\n-\n         if relevant_candidates.len() > 1 {\n-            span_err!(self.tcx().sess, self.span, E0034,\n-                \"multiple applicable methods in scope\");\n-            for (idx, candidate) in relevant_candidates.iter().enumerate() {\n-                self.report_candidate(idx, &candidate.origin);\n-            }\n+            let sources = relevant_candidates.iter()\n+                                             .map(|candidate| candidate.to_source())\n+                                             .collect();\n+            return Some(Err(Ambiguity(sources)));\n         }\n \n-        Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n+        Some(Ok(self.confirm_candidate(rcvr_ty, &relevant_candidates[0])))\n     }\n \n     fn filter_candidates(&self, rcvr_ty: ty::t, candidates: &[Candidate]) -> Vec<Candidate> {\n@@ -1250,13 +1196,110 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     _ => false\n                 }\n             }) {\n-                relevant_candidates.push(candidate_a.clone());\n+                relevant_candidates.push((*candidate_a).clone());\n             }\n         }\n \n         relevant_candidates\n     }\n \n+    fn consider_extension_candidates(&self, rcvr_ty: ty::t)\n+                                     -> Option<MethodResult>\n+    {\n+        let mut selcx = traits::SelectionContext::new(self.infcx(),\n+                                                      &self.fcx.inh.param_env,\n+                                                      self.fcx);\n+\n+        let extension_evaluations: Vec<_> =\n+            self.extension_candidates.iter()\n+            .map(|ext| self.probe_extension_candidate(&mut selcx, rcvr_ty, ext))\n+            .collect();\n+\n+        // How many traits can apply?\n+        let applicable_evaluations_count =\n+            extension_evaluations.iter()\n+                                 .filter(|eval| eval.may_apply())\n+                                 .count();\n+\n+        // Determine whether there are multiple traits that could apply.\n+        if applicable_evaluations_count > 1 {\n+            let sources =\n+                self.extension_candidates.iter()\n+                    .zip(extension_evaluations.iter())\n+                    .filter(|&(_, eval)| eval.may_apply())\n+                    .map(|(ext, _)| ext.to_source())\n+                    .collect();\n+            return Some(Err(Ambiguity(sources)));\n+        }\n+\n+        // Determine whether there are no traits that could apply.\n+        if applicable_evaluations_count == 0 {\n+            return None;\n+        }\n+\n+        // Exactly one trait applies. It itself could *still* be ambiguous thanks\n+        // to coercions.\n+        let applicable_evaluation = extension_evaluations.iter()\n+                                                         .position(|eval| eval.may_apply())\n+                                                         .unwrap();\n+        let match_data = match extension_evaluations[applicable_evaluation] {\n+            traits::MethodMatched(data) => data,\n+            traits::MethodAmbiguous(ref impl_def_ids) => {\n+                let sources = impl_def_ids.iter().map(|&d| ImplSource(d)).collect();\n+                return Some(Err(Ambiguity(sources)));\n+            }\n+            traits::MethodDidNotMatch => {\n+                self.bug(\"Method did not match and yet may_apply() is true\")\n+            }\n+        };\n+\n+        let extension = &self.extension_candidates[applicable_evaluation];\n+\n+        debug!(\"picked extension={}\", extension.repr(self.tcx()));\n+\n+        // We have to confirm the method match. This will cause the type variables\n+        // in the obligation to be appropriately unified based on the subtyping/coercion\n+        // between `rcvr_ty` and `extension.xform_self_ty`.\n+        selcx.confirm_method_match(rcvr_ty, extension.xform_self_ty,\n+                                   &extension.obligation, match_data);\n+\n+        // Finally, construct the candidate, now that everything is\n+        // known, and confirm *that*. Note that whatever we pick\n+        // (impl, whatever) we can always use the same kind of origin\n+        // (trait-based method dispatch).\n+        let candidate = Candidate {\n+            xform_self_ty: extension.xform_self_ty,\n+            rcvr_substs: extension.obligation.trait_ref.substs.clone(),\n+            method_ty: extension.method_ty.clone(),\n+            origin: MethodTypeParam(MethodParam{trait_ref: extension.obligation.trait_ref.clone(),\n+                                                method_num: extension.method_num})\n+        };\n+\n+        // Confirming the candidate will do the final work of\n+        // instantiating late-bound variables, unifying things, and\n+        // registering trait obligations (including\n+        // `extension.obligation`, which should be a requirement of\n+        // the `Self` trait).\n+        let callee = self.confirm_candidate(rcvr_ty, &candidate);\n+\n+        select_fcx_obligations_where_possible(self.fcx);\n+\n+        Some(Ok(callee))\n+    }\n+\n+    fn probe_extension_candidate(&self,\n+                                 selcx: &mut traits::SelectionContext,\n+                                 rcvr_ty: ty::t,\n+                                 candidate: &ExtensionCandidate)\n+                                 -> traits::MethodMatchResult\n+    {\n+        debug!(\"probe_extension_candidate(rcvr_ty={}, candidate.obligation={})\",\n+               rcvr_ty.repr(self.tcx()),\n+               candidate.obligation.repr(self.tcx()));\n+\n+        selcx.evaluate_method_obligation(rcvr_ty, candidate.xform_self_ty, &candidate.obligation)\n+    }\n+\n     fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n                          -> MethodCallee\n     {\n@@ -1273,12 +1316,17 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                self.ty_to_string(rcvr_ty),\n                candidate.repr(self.tcx()));\n \n-        self.enforce_object_limitations(candidate);\n-        self.enforce_drop_trait_limitations(candidate);\n+        let mut rcvr_substs = candidate.rcvr_substs.clone();\n+\n+        if !self.enforce_object_limitations(candidate) {\n+            // Here we change `Self` from `Trait` to `err` in the case that\n+            // this is an illegal object method. This is necessary to prevent\n+            // the user from getting strange, derivative errors when the method\n+            // takes an argument/return-type of type `Self` etc.\n+            rcvr_substs.types.get_mut_slice(SelfSpace)[0] = ty::mk_err();\n+        }\n \n-        // static methods should never have gotten this far:\n-        assert!(candidate.method_ty.explicit_self !=\n-                ty::StaticExplicitSelfCategory);\n+        self.enforce_drop_trait_limitations(candidate);\n \n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -1310,7 +1358,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 self.span,\n                 candidate.method_ty.generics.regions.get_slice(subst::FnSpace));\n \n-        let all_substs = candidate.rcvr_substs.clone().with_method(m_types, m_regions);\n+        let all_substs = rcvr_substs.with_method(m_types, m_regions);\n \n         let ref bare_fn_ty = candidate.method_ty.fty;\n \n@@ -1319,33 +1367,14 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                bare_fn_ty.repr(tcx),\n                all_substs.repr(tcx));\n \n-        let fn_sig = &bare_fn_ty.sig;\n-        let inputs = match candidate.origin {\n-            MethodTraitObject(..) => {\n-                // For annoying reasons, we've already handled the\n-                // substitution of self for object calls.\n-                let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n-                    t.subst(tcx, &all_substs)\n-                });\n-                Some(fn_sig.inputs[0]).into_iter().chain(args).collect()\n-            }\n-            _ => fn_sig.inputs.subst(tcx, &all_substs)\n-        };\n-        let fn_sig = ty::FnSig {\n-            binder_id: fn_sig.binder_id,\n-            inputs: inputs,\n-            output: fn_sig.output.subst(tcx, &all_substs),\n-            variadic: fn_sig.variadic\n-        };\n+        let fn_sig = bare_fn_ty.sig.subst(tcx, &all_substs);\n \n         debug!(\"after subst, fty={}\", fn_sig.repr(tcx));\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(\n-            tcx, &fn_sig,\n-            |br| self.fcx.infcx().next_region_var(\n-                infer::LateBoundRegion(self.span, br)));\n+        let fn_sig =\n+            self.replace_late_bound_regions_with_fresh_var(fn_sig.binder_id, &fn_sig);\n         let transformed_self_ty = fn_sig.inputs[0];\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n@@ -1371,10 +1400,35 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             }\n         }\n \n-        self.fcx.add_obligations_for_parameters(\n-            traits::ObligationCause::misc(self.span),\n-            &all_substs,\n-            &candidate.method_ty.generics);\n+        // FIXME(DST). Super hack. For a method on a trait object\n+        // `Trait`, the generic signature requires that\n+        // `Self:Trait`. Since, for an object, we bind `Self` to the\n+        // type `Trait`, this leads to an obligation\n+        // `Trait:Trait`. Until such time we DST is fully implemented,\n+        // that obligation is not necessarily satisfied. (In the\n+        // future, it would be.)\n+        //\n+        // To sidestep this, we overwrite the binding for `Self` with\n+        // `err` (just for trait objects) when we generate the\n+        // obligations.  This causes us to generate the obligation\n+        // `err:Trait`, and the error type is considered to implement\n+        // all traits, so we're all good. Hack hack hack.\n+        match candidate.origin {\n+            MethodTraitObject(..) => {\n+                let mut temp_substs = all_substs.clone();\n+                temp_substs.types.get_mut_slice(SelfSpace)[0] = ty::mk_err();\n+                self.fcx.add_obligations_for_parameters(\n+                    traits::ObligationCause::misc(self.span),\n+                    &temp_substs,\n+                    &candidate.method_ty.generics);\n+            }\n+            _ => {\n+                self.fcx.add_obligations_for_parameters(\n+                    traits::ObligationCause::misc(self.span),\n+                    &all_substs,\n+                    &candidate.method_ty.generics);\n+            }\n+        }\n \n         MethodCallee {\n             origin: candidate.origin.clone(),\n@@ -1480,7 +1534,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n     }\n \n-    fn enforce_object_limitations(&self, candidate: &Candidate) {\n+    fn enforce_object_limitations(&self, candidate: &Candidate) -> bool {\n         /*!\n          * There are some limitations to calling functions through an\n          * object, because (a) the self type is not known\n@@ -1493,7 +1547,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             MethodStatic(..) |\n             MethodTypeParam(..) |\n             MethodStaticUnboxedClosure(..) => {\n-                return; // not a call to a trait instance\n+                return true; // not a call to a trait instance\n             }\n             MethodTraitObject(..) => {}\n         }\n@@ -1504,6 +1558,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     self.span,\n                     \"cannot call a method without a receiver \\\n                      through an object\");\n+                return false;\n             }\n \n             ty::ByValueExplicitSelfCategory |\n@@ -1512,51 +1567,50 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n \n         // reason (a) above\n-        let check_for_self_ty = |ty| {\n+        let check_for_self_ty = |ty| -> bool {\n             if ty::type_has_self(ty) {\n                 span_err!(self.tcx().sess, self.span, E0038,\n                     \"cannot call a method whose type contains a \\\n                      self-type through an object\");\n-                true\n-            } else {\n                 false\n+            } else {\n+                true\n             }\n         };\n         let ref sig = candidate.method_ty.fty.sig;\n-        let mut found_self_ty = false;\n-        for &input_ty in sig.inputs.iter() {\n-            if check_for_self_ty(input_ty) {\n-                found_self_ty = true;\n-                break;\n+        for &input_ty in sig.inputs[1..].iter() {\n+            if !check_for_self_ty(input_ty) {\n+                return false;\n             }\n         }\n-        if !found_self_ty {\n-            check_for_self_ty(sig.output);\n+        if !check_for_self_ty(sig.output) {\n+            return false;\n         }\n \n         if candidate.method_ty.generics.has_type_params(subst::FnSpace) {\n             // reason (b) above\n             span_err!(self.tcx().sess, self.span, E0039,\n                 \"cannot call a generic method through an object\");\n+            return false;\n         }\n+\n+        true\n     }\n \n     fn enforce_drop_trait_limitations(&self, candidate: &Candidate) {\n         // No code can call the finalize method explicitly.\n-        let bad;\n-        match candidate.origin {\n+        let bad = match candidate.origin {\n             MethodStatic(method_id) => {\n-                bad = self.tcx().destructors.borrow().contains(&method_id);\n+                self.tcx().destructors.borrow().contains(&method_id)\n+            }\n+            MethodStaticUnboxedClosure(_) => {\n+                false\n             }\n-            MethodStaticUnboxedClosure(_) => bad = false,\n-            // FIXME: does this properly enforce this on everything now\n-            // that self has been merged in? -sully\n             MethodTypeParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n             MethodTraitObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n-                bad = self.tcx().destructor_for_type.borrow()\n-                          .contains_key(&trait_ref.def_id);\n+                Some(trait_ref.def_id) == self.tcx().lang_items.drop_trait()\n             }\n-        }\n+        };\n \n         if bad {\n             span_err!(self.tcx().sess, self.span, E0040,\n@@ -1570,213 +1624,141 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         debug!(\"is_relevant(rcvr_ty={}, candidate={})\",\n                self.ty_to_string(rcvr_ty), candidate.repr(self.tcx()));\n \n-        return match candidate.method_ty.explicit_self {\n-            StaticExplicitSelfCategory => {\n-                debug!(\"(is relevant?) explicit self is static\");\n-                self.report_statics == ReportStaticMethods\n-            }\n-\n-            ByValueExplicitSelfCategory => {\n-                debug!(\"(is relevant?) explicit self is by-value\");\n-                match ty::get(rcvr_ty).sty {\n-                    ty::ty_uniq(typ) => {\n-                        match ty::get(typ).sty {\n-                            ty::ty_trait(box ty::TyTrait {\n-                                def_id: self_did,\n-                                ..\n-                            }) => {\n-                                rcvr_matches_object(self_did, candidate) ||\n-                                    rcvr_matches_ty(self.fcx,\n-                                                    rcvr_ty,\n-                                                    candidate)\n-                            }\n-                            _ => {\n-                                rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n-                            }\n-                        }\n-                    }\n-                    _ => rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n-                }\n-            }\n-\n-            ByReferenceExplicitSelfCategory(_, m) => {\n-                debug!(\"(is relevant?) explicit self is a region\");\n-                match ty::get(rcvr_ty).sty {\n-                    ty::ty_rptr(_, mt) => {\n-                        match ty::get(mt.ty).sty {\n-                            ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n-                                mutability_matches(mt.mutbl, m) &&\n-                                rcvr_matches_object(self_did, candidate)\n-                            }\n-                            _ => mutability_matches(mt.mutbl, m) &&\n-                                 rcvr_matches_ty(self.fcx, mt.ty, candidate)\n-                        }\n-                    }\n-\n-                    _ => false\n-                }\n-            }\n-\n-            ByBoxExplicitSelfCategory => {\n-                debug!(\"(is relevant?) explicit self is a unique pointer\");\n-                match ty::get(rcvr_ty).sty {\n-                    ty::ty_uniq(typ) => {\n-                        match ty::get(typ).sty {\n-                            ty::ty_trait(box ty::TyTrait { def_id: self_did, .. }) => {\n-                                rcvr_matches_object(self_did, candidate)\n-                            }\n-                            _ => rcvr_matches_ty(self.fcx, typ, candidate),\n-                        }\n-                    }\n+        infer::can_mk_subty(self.infcx(), rcvr_ty, candidate.xform_self_ty).is_ok()\n+    }\n \n-                    _ => false\n-                }\n-            }\n-        };\n+    fn infcx(&'a self) -> &'a infer::InferCtxt<'a, 'tcx> {\n+        &self.fcx.inh.infcx\n+    }\n \n-        fn rcvr_matches_object(self_did: ast::DefId,\n-                               candidate: &Candidate) -> bool {\n-            match candidate.rcvr_match_condition {\n-                RcvrMatchesIfObject(desired_did) => {\n-                    self_did == desired_did\n-                }\n-                RcvrMatchesIfSubtype(_) | RcvrMatchesIfEqtype(_) => {\n-                    false\n-                }\n-            }\n-        }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n+    }\n \n-        fn rcvr_matches_ty(fcx: &FnCtxt,\n-                           rcvr_ty: ty::t,\n-                           candidate: &Candidate) -> bool {\n-            match candidate.rcvr_match_condition {\n-                RcvrMatchesIfObject(_) => {\n-                    false\n-                }\n-                RcvrMatchesIfSubtype(of_type) => {\n-                    fcx.can_mk_subty(rcvr_ty, of_type).is_ok()\n-                }\n-                RcvrMatchesIfEqtype(of_type) => {\n-                    fcx.can_mk_eqty(rcvr_ty, of_type).is_ok()\n-                }\n-            }\n-        }\n+    fn ty_to_string(&self, t: ty::t) -> String {\n+        self.fcx.infcx().ty_to_string(t)\n+    }\n \n-        fn mutability_matches(self_mutbl: ast::Mutability,\n-                              candidate_mutbl: ast::Mutability)\n-                              -> bool {\n-            //! True if `self_mutbl <: candidate_mutbl`\n-            self_mutbl == candidate_mutbl\n-        }\n+    fn bug(&self, s: &str) -> ! {\n+        self.tcx().sess.span_bug(self.span, s)\n     }\n \n-    fn report_candidate(&self, idx: uint, origin: &MethodOrigin) {\n-        match *origin {\n-            MethodStatic(impl_did) => {\n-                let did = if self.report_statics == ReportStaticMethods {\n-                    // If we're reporting statics, we want to report the trait\n-                    // definition if possible, rather than an impl\n-                    match ty::trait_item_of_item(self.tcx(), impl_did) {\n-                        None | Some(TypeTraitItemId(_)) => {\n-                            debug!(\"(report candidate) No trait method \\\n-                                    found\");\n-                            impl_did\n-                        }\n-                        Some(MethodTraitItemId(trait_did)) => {\n-                            debug!(\"(report candidate) Found trait ref\");\n-                            trait_did\n-                        }\n-                    }\n-                } else {\n-                    // If it is an instantiated default method, use the original\n-                    // default method for error reporting.\n-                    match provided_source(self.tcx(), impl_did) {\n-                        None => impl_did,\n-                        Some(did) => did\n-                    }\n-                };\n-                self.report_static_candidate(idx, did)\n-            }\n-            MethodStaticUnboxedClosure(did) => {\n-                self.report_static_candidate(idx, did)\n-            }\n-            MethodTypeParam(ref mp) => {\n-                self.report_param_candidate(idx, mp.trait_ref.def_id)\n+    fn has_applicable_self(&self, method: &ty::Method) -> bool {\n+        // \"fast track\" -- check for usage of sugar\n+        match method.explicit_self {\n+            StaticExplicitSelfCategory => {\n+                // fallthrough\n             }\n-            MethodTraitObject(ref mo) => {\n-                self.report_trait_candidate(idx, mo.trait_ref.def_id)\n+            ByValueExplicitSelfCategory |\n+            ByReferenceExplicitSelfCategory(..) |\n+            ByBoxExplicitSelfCategory => {\n+                return true;\n             }\n         }\n-    }\n \n-    fn report_static_candidate(&self, idx: uint, did: DefId) {\n-        let span = if did.krate == ast::LOCAL_CRATE {\n-            self.tcx().map.span(did.node)\n-        } else {\n-            self.span\n-        };\n-        span_note!(self.tcx().sess, span,\n-            \"candidate #{} is `{}`\",\n-            idx + 1u, ty::item_path_str(self.tcx(), did));\n-    }\n-\n-    fn report_param_candidate(&self, idx: uint, did: DefId) {\n-        span_note!(self.tcx().sess, self.span,\n-            \"candidate #{} derives from the bound `{}`\",\n-            idx + 1u, ty::item_path_str(self.tcx(), did));\n+        // FIXME -- check for types that deref to `Self`,\n+        // like `Rc<Self>` and so on.\n+        //\n+        // Note also that the current code will break if this type\n+        // includes any of the type parameters defined on the method\n+        // -- but this could be overcome.\n+        return false;\n     }\n \n-    fn report_trait_candidate(&self, idx: uint, did: DefId) {\n-        span_note!(self.tcx().sess, self.span,\n-            \"candidate #{} derives from the type of the receiver, \\\n-            which is the trait `{}`\",\n-            idx + 1u, ty::item_path_str(self.tcx(), did));\n+    fn record_static_candidate(&mut self, source: CandidateSource) {\n+        self.static_candidates.push(source);\n     }\n \n-    fn infcx(&'a self) -> &'a infer::InferCtxt<'a, 'tcx> {\n-        &self.fcx.inh.infcx\n+    fn xform_self_ty(&self, method: &Rc<ty::Method>, substs: &subst::Substs) -> ty::t {\n+        let xform_self_ty = method.fty.sig.inputs[0].subst(self.tcx(), substs);\n+        self.replace_late_bound_regions_with_fresh_var(method.fty.sig.binder_id, &xform_self_ty)\n     }\n \n-    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.fcx.tcx()\n+    fn replace_late_bound_regions_with_fresh_var<T>(&self, binder_id: ast::NodeId, value: &T) -> T\n+        where T : TypeFoldable + Repr\n+    {\n+        let (_, value) = replace_late_bound_regions(\n+            self.fcx.tcx(),\n+            binder_id,\n+            value,\n+            |br| self.fcx.infcx().next_region_var(infer::LateBoundRegion(self.span, br)));\n+        value\n     }\n+}\n \n-    fn ty_to_string(&self, t: ty::t) -> String {\n-        self.fcx.infcx().ty_to_string(t)\n-    }\n+fn trait_method(tcx: &ty::ctxt,\n+                trait_def_id: ast::DefId,\n+                method_name: ast::Name)\n+                -> Option<(uint, Rc<ty::Method>)>\n+{\n+    /*!\n+     * Find method with name `method_name` defined in `trait_def_id` and return it,\n+     * along with its index (or `None`, if no such method).\n+     */\n \n-    fn did_to_string(&self, did: DefId) -> String {\n-        ty::item_path_str(self.tcx(), did)\n-    }\n+    let trait_items = ty::trait_items(tcx, trait_def_id);\n+    trait_items\n+        .iter()\n+        .enumerate()\n+        .find(|&(_, ref item)| item.ident().name == method_name)\n+        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+}\n \n-    fn bug(&self, s: &str) -> ! {\n-        self.tcx().sess.span_bug(self.span, s)\n-    }\n+fn impl_method(tcx: &ty::ctxt,\n+               impl_def_id: ast::DefId,\n+               method_name: ast::Name)\n+               -> Option<Rc<ty::Method>>\n+{\n+    let impl_items = tcx.impl_items.borrow();\n+    let impl_items = impl_items.find(&impl_def_id).unwrap();\n+    impl_items\n+        .iter()\n+        .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n+        .find(|m| m.ident().name == method_name)\n+        .and_then(|item| item.as_opt_method())\n }\n \n impl Repr for Candidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, \\\n-                 origin={})\",\n-                self.rcvr_match_condition.repr(tcx),\n+        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, method_ty={}, origin={})\",\n+                self.xform_self_ty.repr(tcx),\n                 self.rcvr_substs.repr(tcx),\n                 self.method_ty.repr(tcx),\n                 self.origin)\n     }\n }\n \n-impl Repr for RcvrMatchCondition {\n+impl Repr for ExtensionCandidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n-        match *self {\n-            RcvrMatchesIfObject(d) => {\n-                format!(\"RcvrMatchesIfObject({})\", d.repr(tcx))\n+        format!(\"ExtensionCandidate(obligation={}, xform_self_ty={}, method_ty={}, method_num={})\",\n+                self.obligation.repr(tcx),\n+                self.xform_self_ty.repr(tcx),\n+                self.method_ty.repr(tcx),\n+                self.method_num)\n+    }\n+}\n+\n+impl Candidate {\n+    fn to_source(&self) -> CandidateSource {\n+        match self.origin {\n+            MethodStatic(def_id) => {\n+                ImplSource(def_id)\n+            }\n+            MethodStaticUnboxedClosure(..) => {\n+                fail!(\"MethodStaticUnboxedClosure only used in trans\")\n             }\n-            RcvrMatchesIfSubtype(t) => {\n-                format!(\"RcvrMatchesIfSubtype({})\", t.repr(tcx))\n+            MethodTypeParam(ref param) => {\n+                TraitSource(param.trait_ref.def_id)\n             }\n-            RcvrMatchesIfEqtype(t) => {\n-                format!(\"RcvrMatchesIfEqtype({})\", t.repr(tcx))\n+            MethodTraitObject(ref obj) => {\n+                TraitSource(obj.trait_ref.def_id)\n             }\n         }\n     }\n }\n+\n+impl ExtensionCandidate {\n+    fn to_source(&self) -> CandidateSource {\n+        TraitSource(self.obligation.trait_ref.def_id)\n+    }\n+}"}, {"sha": "5f7b31e573adedad4ccc1e554de5bd66ddecf34d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dad2db7c83de71063b9311eb3e41bdf4027616f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad2db7c83de71063b9311eb3e41bdf4027616f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=dad2db7c83de71063b9311eb3e41bdf4027616f6", "patch": "@@ -77,6 +77,7 @@ type parameter).\n */\n \n \n+use driver::session::Session;\n use middle::const_eval;\n use middle::def;\n use middle::lang_items::IteratorItem;\n@@ -2924,46 +2925,24 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                 fcx.expr_ty(&*rcvr));\n \n         let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n-        let fn_ty = match method::lookup(fcx, expr, &*rcvr,\n+        let fn_ty = match method::lookup(fcx,\n+                                         expr,\n+                                         &*rcvr,\n                                          method_name.node.name,\n-                                         expr_t, tps.as_slice(),\n+                                         expr_t,\n+                                         tps.as_slice(),\n                                          DontDerefArgs,\n                                          CheckTraitsAndInherentMethods,\n-                                         AutoderefReceiver, IgnoreStaticMethods) {\n-            Some(method) => {\n+                                         AutoderefReceiver) {\n+            Ok(method) => {\n                 let method_ty = method.ty;\n                 let method_call = MethodCall::expr(expr.id);\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n                 method_ty\n             }\n-            None => {\n-                debug!(\"(checking method call) failing expr is {}\", expr.id);\n-\n-                fcx.type_error_message(method_name.span,\n-                  |actual| {\n-                      format!(\"type `{}` does not implement any \\\n-                               method in scope named `{}`\",\n-                              actual,\n-                              token::get_ident(method_name.node))\n-                  },\n-                  expr_t,\n-                  None);\n-\n-                // Add error type for the result\n+            Err(error) => {\n+                method::report_error(fcx, method_name.span, expr_t, method_name.node.name, error);\n                 fcx.write_error(expr.id);\n-\n-                // Check for potential static matches (missing self parameters)\n-                method::lookup(fcx,\n-                               expr,\n-                               &*rcvr,\n-                               method_name.node.name,\n-                               expr_t,\n-                               tps.as_slice(),\n-                               DontDerefArgs,\n-                               CheckTraitsAndInherentMethods,\n-                               DontAutoderefReceiver,\n-                               ReportStaticMethods);\n-\n                 ty::mk_err()\n             }\n         };\n@@ -3466,9 +3445,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              tps.as_slice(),\n                              DontDerefArgs,\n                              CheckTraitsAndInherentMethods,\n-                             AutoderefReceiver,\n-                             IgnoreStaticMethods) {\n-            Some(_) => {\n+                             AutoderefReceiver) {\n+            Ok(_) => {\n                 fcx.type_error_message(\n                     field.span,\n                     |actual| {\n@@ -3481,7 +3459,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     \"maybe a missing `()` to call it? If not, try an anonymous function.\");\n             }\n \n-            None => {\n+            Err(_) => {\n                 fcx.type_error_message(\n                     expr.span,\n                     |actual| {"}, {"sha": "b82a4a0b9971852dd8bc181d420b7d98ef2aacb3", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dad2db7c83de71063b9311eb3e41bdf4027616f6/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dad2db7c83de71063b9311eb3e41bdf4027616f6/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=dad2db7c83de71063b9311eb3e41bdf4027616f6", "patch": "@@ -536,6 +536,14 @@ impl<'ast> Map<'ast> {\n             .unwrap_or_else(|| fail!(\"AstMap.span: could not find span for id {}\", id))\n     }\n \n+    pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n+        if def_id.krate == LOCAL_CRATE {\n+            self.span(def_id.node)\n+        } else {\n+            fallback\n+        }\n+    }\n+\n     pub fn node_to_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id)\n     }"}]}