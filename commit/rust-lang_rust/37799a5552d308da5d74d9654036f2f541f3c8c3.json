{"sha": "37799a5552d308da5d74d9654036f2f541f3c8c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Nzk5YTU1NTJkMzA4ZGE1ZDc0ZDk2NTQwMzZmMmY1NDFmM2M4YzM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-11T19:03:44Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-06-12T10:38:27Z"}, "message": "rustc: replace `TyCtxt<'a, 'gcx, 'tcx>` with `TyCtxt<'tcx, 'gcx, 'tcx>`.", "tree": {"sha": "f50866c051bcb3543a04dbc694bc24bb92c130f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f50866c051bcb3543a04dbc694bc24bb92c130f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37799a5552d308da5d74d9654036f2f541f3c8c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37799a5552d308da5d74d9654036f2f541f3c8c3", "html_url": "https://github.com/rust-lang/rust/commit/37799a5552d308da5d74d9654036f2f541f3c8c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37799a5552d308da5d74d9654036f2f541f3c8c3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f511ade5b0bc42028e42b81392feec770d90ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f511ade5b0bc42028e42b81392feec770d90ead", "html_url": "https://github.com/rust-lang/rust/commit/3f511ade5b0bc42028e42b81392feec770d90ead"}], "stats": {"total": 3662, "additions": 1824, "deletions": 1838}, "files": [{"sha": "0bff16334db090b237fe9f88251b3f3f86525e34", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -8,7 +8,7 @@ use crate::hir::{self, PatKind};\n use crate::hir::def_id::DefId;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     owner_def_id: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     graph: CFGGraph,\n@@ -30,7 +30,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break`\n }\n \n-pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn construct<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                            body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);"}, {"sha": "57a63f3bd734840213d7d2457066395c68dec56a", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -12,7 +12,7 @@ pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n pub struct LabelledCFG<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n     /// `labelled_edges` controls whether we emit labels on the edges"}, {"sha": "e2144c20e929067826735ef47b5b8b8694b3eebb", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -49,7 +49,7 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n-    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                          body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }"}, {"sha": "01dcdbf0ce54505dfe227a5ab3023baf012ab7cc", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -204,7 +204,7 @@ macro_rules! define_dep_nodes {\n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n             #[inline(always)]\n-            pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                        dep: DepConstructor<'gcx>)\n                                        -> DepNode\n                 where 'gcx: 'a + 'tcx,\n@@ -442,49 +442,49 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n ]);\n \n pub trait RecoverKey<'tcx>: Sized {\n-    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self>;\n+    fn recover(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self>;\n }\n \n impl RecoverKey<'tcx> for CrateNum {\n-    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx).map(|id| id.krate)\n     }\n }\n \n impl RecoverKey<'tcx> for DefId {\n-    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx)\n     }\n }\n \n impl RecoverKey<'tcx> for DefIndex {\n-    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx).map(|id| id.index)\n     }\n }\n \n-trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n+trait DepNodeParams<'gcx: 'tcx, 'tcx>: fmt::Debug {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n     /// Not all DepNodeParams support being turned into a Fingerprint (they\n     /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n+    fn to_fingerprint(&self, _: TyCtxt<'tcx, 'gcx, 'tcx>) -> Fingerprint {\n         panic!(\"Not implemented. Accidentally called on anonymous node?\")\n     }\n \n-    fn to_debug_str(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, _: TyCtxt<'tcx, 'gcx, 'tcx>) -> String {\n         format!(\"{:?}\", self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'a>> + fmt::Debug\n+impl<'gcx: 'tcx, 'tcx, T> DepNodeParams<'gcx, 'tcx> for T\n+    where T: HashStable<StableHashingContext<'tcx>> + fmt::Debug\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n-    default fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n+    default fn to_fingerprint(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Fingerprint {\n         let mut hcx = tcx.create_stable_hashing_context();\n         let mut hasher = StableHasher::new();\n \n@@ -493,36 +493,36 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n         hasher.finish()\n     }\n \n-    default fn to_debug_str(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    default fn to_debug_str(&self, _: TyCtxt<'tcx, 'gcx, 'tcx>) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefId {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> String {\n         tcx.def_path_str(*self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for DefIndex {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n         tcx.hir().definitions().def_path_hash(*self).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> String {\n         tcx.def_path_str(DefId::local(*self))\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for CrateNum {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n@@ -533,12 +533,12 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for CrateNum {\n         tcx.def_path_hash(def_id).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> String {\n         tcx.crate_name(*self).as_str().to_string()\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n@@ -553,7 +553,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, De\n         def_path_hash_0.0.combine(def_path_hash_1.0)\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> String {\n         let (def_id_0, def_id_1) = *self;\n \n         format!(\"({}, {})\",\n@@ -562,7 +562,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, De\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this"}, {"sha": "a9598e9d4342aa8eaba4adc47df85bf0423a853c", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -604,7 +604,7 @@ impl DepGraph {\n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n     fn try_mark_previous_green<'tcx>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         data: &DepGraphData,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode\n@@ -791,7 +791,7 @@ impl DepGraph {\n     #[inline(never)]\n     fn emit_diagnostics<'tcx>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         data: &DepGraphData,\n         dep_node_index: DepNodeIndex,\n         did_allocation: bool,\n@@ -842,7 +842,7 @@ impl DepGraph {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n         let green_nodes: Vec<DepNode> = {\n             let data = self.data.as_ref().unwrap();\n             data.colors.values.indices().filter_map(|prev_index| {"}, {"sha": "eb77e4ce4350a17e9dddb621e4a1b33fb8c16565", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -33,7 +33,7 @@ impl DepGraphSafe for DefId {\n \n /// The type context itself can be used to access all kinds of tracked\n /// state, but those accesses should always generate read events.\n-impl<'a, 'gcx, 'tcx> DepGraphSafe for TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DepGraphSafe for TyCtxt<'tcx, 'gcx, 'tcx> {\n }\n \n /// Tuples make it easy to build up state."}, {"sha": "5b517677a43f060a6c75d56c8333736e86fa180b", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -87,11 +87,11 @@ impl Target {\n     }\n }\n \n-struct CheckAttrVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct CheckAttrVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n+impl CheckAttrVisitor<'tcx> {\n     /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n@@ -310,7 +310,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -347,7 +347,7 @@ fn is_c_like_enum(item: &hir::Item) -> bool {\n     }\n }\n \n-fn check_mod_attrs<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_attrs<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CheckAttrVisitor { tcx }.as_deep_visitor()"}, {"sha": "8c92a0f5d77137693ed1df9d16c80e1bfb7348ea", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -55,7 +55,7 @@ impl Visitor<'tcx> for LocalCollector {\n }\n \n struct CaptureCollector<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     locals: &'a FxHashSet<HirId>,\n     upvars: FxIndexMap<HirId, hir::Upvar>,\n }"}, {"sha": "535c61df1c527657a942edc03f610fb450a05c92", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -205,8 +205,8 @@ for &'b mut T {\n     }\n }\n \n-impl<'a, 'gcx, 'lcx> StableHashingContextProvider<'a> for TyCtxt<'a, 'gcx, 'lcx> {\n-    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n+impl StableHashingContextProvider<'lcx> for TyCtxt<'lcx, 'gcx, 'lcx> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'lcx> {\n         (*self).create_stable_hashing_context()\n     }\n }"}, {"sha": "f24f7f05a1fa615b00dbf6719014f9af334a3524", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -277,7 +277,7 @@ impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n \n struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     variables: SmallVec<[CanonicalVarInfo; 8]>,\n     query_state: &'cx mut OriginalQueryValues<'tcx>,\n     // Note that indices is only used once `var_values` is big enough to be\n@@ -290,7 +290,7 @@ struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -501,7 +501,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     fn canonicalize<V>(\n         value: &V,\n         infcx: Option<&InferCtxt<'_, 'gcx, 'tcx>>,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalize_region_mode: &dyn CanonicalizeRegionMode,\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'gcx, V>"}, {"sha": "1d630d10a3cb849b850e90f52b70dcdabd001356", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -478,7 +478,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n     /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n     /// we'll return a substitution `subst` with:\n     /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n-    pub fn make_identity<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    pub fn make_identity<'a>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Self {\n         use crate::ty::subst::UnpackedKind;\n \n         CanonicalVarValues {"}, {"sha": "7defbac7e545bf741cb69ad4bbdd9bb18ddcf7da", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -29,7 +29,7 @@ use crate::ty::subst::{Kind, UnpackedKind};\n use crate::ty::{self, BoundVar, InferConst, Lift, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n-impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n     /// canonical key `canonical_key`, this method will create a new\n     /// inference context, instantiate the key, and run your operation\n@@ -647,7 +647,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n /// Given the region obligations and constraints scraped from the infcx,\n /// creates query region constraints.\n pub fn make_query_outlives<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> Vec<QueryRegionConstraint<'tcx>> {"}, {"sha": "43f6f62bc4880072031af6b25e5959da4e39b94a", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -14,7 +14,11 @@ use crate::ty::{self, TyCtxt};\n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n-    pub fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    pub fn substitute(\n+        &self,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n+        var_values: &CanonicalVarValues<'tcx>,\n+    ) -> V\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -29,7 +33,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     /// V, replacing each of the canonical variables.\n     pub fn substitute_projected<T>(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         var_values: &CanonicalVarValues<'tcx>,\n         projection_fn: impl FnOnce(&V) -> &T,\n     ) -> T\n@@ -46,7 +50,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n /// must be values for the set of canonical variables that appear in\n /// `value`.\n pub(super) fn substitute_value<'a, 'tcx, T>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     var_values: &CanonicalVarValues<'tcx>,\n     value: &'a T,\n ) -> T"}, {"sha": "10a53767f5370ef13c02f59d54c38a290c1bfc33", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -63,7 +63,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n                                 a: Ty<'tcx>,\n                                 b: Ty<'tcx>)\n                                 -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'infcx, 'gcx, 'tcx>\n+        where R: TypeRelation<'gcx, 'tcx>\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -123,7 +123,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n     where\n-        R: TypeRelation<'infcx, 'gcx, 'tcx>,\n+        R: TypeRelation<'gcx, 'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -207,7 +207,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n }\n \n impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -413,8 +413,8 @@ struct Generalization<'tcx> {\n     needs_wf: bool,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+impl TypeRelation<'gcx, 'tcx> for Generalizer<'_, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "d74a05fddbcf8b5002d7fff575ca18c7790cbb2d", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -24,12 +24,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Equate<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Equate<'combine, 'infcx, 'gcx, 'tcx>\n-{\n+impl TypeRelation<'gcx, 'tcx> for Equate<'combine, 'infcx, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "415490488510ae5fb9196ff9f27f1ddd8397a47f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -67,7 +67,7 @@ mod need_type_info;\n \n pub mod nice_region_error;\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(\n         self,\n         region_scope_tree: &region::ScopeTree,\n@@ -445,13 +445,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         use ty::print::Printer;\n         use ty::subst::Kind;\n \n-        struct AbsolutePathPrinter<'a, 'gcx, 'tcx> {\n-            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        struct AbsolutePathPrinter<'gcx, 'tcx> {\n+            tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         }\n \n         struct NonTrivialPath;\n \n-        impl<'gcx, 'tcx> Printer<'gcx, 'tcx> for AbsolutePathPrinter<'_, 'gcx, 'tcx> {\n+        impl<'gcx, 'tcx> Printer<'gcx, 'tcx> for AbsolutePathPrinter<'gcx, 'tcx> {\n             type Error = NonTrivialPath;\n \n             type Path = Vec<String>;\n@@ -460,7 +460,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type DynExistential = !;\n             type Const = !;\n \n-            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+            fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n                 self.tcx\n             }\n "}, {"sha": "b384a97f38d79642dadb23cc2fbc261094c9b05e", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -81,8 +81,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n // walk the types like &mut Vec<&u8> and &u8 looking for the HIR\n // where that lifetime appears. This allows us to highlight the\n // specific part of the type in the error message.\n-struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct FindNestedTypeVisitor<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     // The bound_region corresponding to the Refree(freeregion)\n     // associated with the anonymous region we are looking for.\n     bound_region: ty::BoundRegion,\n@@ -92,7 +92,7 @@ struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     current_index: ty::DebruijnIndex,\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n+impl Visitor<'gcx> for FindNestedTypeVisitor<'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -208,14 +208,14 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n // and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n // where that lifetime appears. This allows us to highlight the\n // specific part of the type in the error message.\n-struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct TyPathVisitor<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     found_it: bool,\n     bound_region: ty::BoundRegion,\n     current_index: ty::DebruijnIndex,\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n+impl Visitor<'gcx> for TyPathVisitor<'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }"}, {"sha": "bd7fc9554e8d514757e122bf48f6bf45c724037a", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -56,7 +56,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         Self { infcx, error: None, regions: Some((span, sub, sup)), tables }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "c9bda63aa75ccf0c8e0ac32b9bb1d015a94a28cb", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -321,14 +321,14 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n     ) {\n         // HACK(eddyb) maybe move this in a more central location.\n         #[derive(Copy, Clone)]\n-        struct Highlighted<'a, 'gcx, 'tcx, T> {\n-            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        struct Highlighted<'gcx, 'tcx, T> {\n+            tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n             highlight: RegionHighlightMode,\n             value: T,\n         }\n \n-        impl<'a, 'gcx, 'tcx, T> Highlighted<'a, 'gcx, 'tcx, T> {\n-            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'a, 'gcx, 'tcx, U> {\n+        impl<'gcx, 'tcx, T> Highlighted<'gcx, 'tcx, T> {\n+            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'gcx, 'tcx, U> {\n                 Highlighted {\n                     tcx: self.tcx,\n                     highlight: self.highlight,\n@@ -337,8 +337,8 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             }\n         }\n \n-        impl<'a, 'gcx, 'tcx, T> fmt::Display for Highlighted<'a, 'gcx, 'tcx, T>\n-            where T: for<'b, 'c> Print<'gcx, 'tcx,\n+        impl<'gcx, 'tcx, T> fmt::Display for Highlighted<'gcx, 'tcx, T>\n+            where T: for<'a, 'b, 'c> Print<'gcx, 'tcx,\n                 FmtPrinter<'a, 'gcx, 'tcx, &'b mut fmt::Formatter<'c>>,\n                 Error = fmt::Error,\n             >,"}, {"sha": "ed8b0ff54c8d82bc04bb1763797310175b30034e", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "ebab1f8f2f6d952be4e18886c6cdd40ee35e7c98", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -143,7 +143,7 @@ pub struct InferenceFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "f84ab59fdae605499dbb1ad614ab9649070c0295", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -21,12 +21,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Glb<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Glb<'combine, 'infcx, 'gcx, 'tcx>\n-{\n+impl TypeRelation<'gcx, 'tcx> for Glb<'combine, 'infcx, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "6f76ee9e26dc9f11f96e5c65a421218266485b49", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -27,7 +27,7 @@ use crate::ty::TyVar;\n use crate::ty::{self, Ty};\n use crate::ty::relate::{RelateResult, TypeRelation};\n \n-pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n+pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'gcx, 'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n \n     fn cause(&self) -> &ObligationCause<'tcx>;"}, {"sha": "5d83cdcb176ded44d9aa7f870cc69a304ad767a6", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -103,7 +103,7 @@ struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.region_rels.tcx\n     }\n \n@@ -136,7 +136,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n     /// Initially, the value for all variables is set to `'empty`, the\n     /// empty region. The `expansion` phase will grow this larger.\n-    fn construct_var_data(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n+    fn construct_var_data(&self, tcx: TyCtxt<'tcx, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n             values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars())\n@@ -785,7 +785,7 @@ impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n }\n \n impl<'tcx> LexicalRegionResolutions<'tcx> {\n-    fn normalize<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    fn normalize<T>(&self, tcx: TyCtxt<'tcx, '_, 'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "f123690ada4d92e30b85d3aa566f4bb52b36422f", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -21,12 +21,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Lub<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Lub<'combine, 'infcx, 'gcx, 'tcx>\n-{\n+impl TypeRelation<'gcx, 'tcx> for Lub<'combine, 'infcx, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "8c2ca633497ed9efdafcb8689c15d7c617c0c32e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -102,8 +102,8 @@ impl SuppressRegionErrors {\n     }\n }\n \n-pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct InferCtxt<'a, 'gcx, 'tcx> {\n+    pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n \n     /// During type-checking/inference of a body, `in_progress_tables`\n     /// contains a reference to the tables being built up, which are\n@@ -465,21 +465,21 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n /// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n /// Necessary because we can't write the following bound:\n /// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>)`.\n-pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+pub struct InferCtxtBuilder<'gcx, 'tcx> {\n+    global_tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n-    pub fn infer_ctxt(self) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+impl TyCtxt<'gcx, 'gcx, 'gcx> {\n+    pub fn infer_ctxt<'tcx>(self) -> InferCtxtBuilder<'gcx, 'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n             fresh_tables: None,\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n     pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n@@ -498,7 +498,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         &'tcx mut self,\n         span: Span,\n         canonical: &Canonical<'tcx, T>,\n-        f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n+        f: impl for<'a> FnOnce(InferCtxt<'a, 'gcx, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n     ) -> R\n     where\n         T: TypeFoldable<'tcx>,\n@@ -510,7 +510,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn enter<R>(&'tcx mut self, f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R) -> R {\n+    pub fn enter<R>(&'tcx mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'gcx, 'tcx>) -> R) -> R {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref fresh_tables,\n@@ -1600,7 +1600,7 @@ impl<'a, 'gcx, 'tcx> ShallowResolver<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ShallowResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -1641,7 +1641,7 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n         }\n     }\n \n-    pub fn dummy(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: ObligationCause::dummy(),\n             values: Types(ExpectedFound {"}, {"sha": "6ac087027ac6eeb4d968b0bd3a6216eb9f863eef", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -494,11 +494,11 @@ impl VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n     }\n }\n \n-impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n+impl<D> TypeRelation<'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -823,11 +823,11 @@ where\n     universe: ty::UniverseIndex,\n }\n \n-impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n+impl<D> TypeRelation<'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "a054869874af9ae2c997cdcd84954928be992435", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -552,8 +552,8 @@ impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, '_, 'tcx>\n     }\n }\n \n-struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+struct ReverseMapper<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n \n     /// If errors have already been reported in this fn, we suppress\n     /// our own errors because they are sometimes derivative.\n@@ -567,9 +567,9 @@ struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     hidden_ty: Option<Ty<'tcx>>,\n }\n \n-impl<'cx, 'gcx, 'tcx> ReverseMapper<'cx, 'gcx, 'tcx> {\n+impl ReverseMapper<'gcx, 'tcx> {\n     fn new(\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         tainted_by_errors: bool,\n         opaque_type_def_id: DefId,\n         map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n@@ -599,8 +599,8 @@ impl<'cx, 'gcx, 'tcx> ReverseMapper<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+impl TypeFolder<'gcx, 'tcx> for ReverseMapper<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "308c510d0eabbaca87152dfdb8a128432e47b326", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -29,7 +29,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     /// avoid making arbitrary choices. See\n     /// `TransitiveRelation::postdom_upper_bound` for more details.\n     pub fn lub_free_regions<'a, 'gcx>(&self,\n-                                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                      tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                       r_a: Region<'tcx>,\n                                       r_b: Region<'tcx>)\n                                       -> Region<'tcx> {\n@@ -90,7 +90,7 @@ impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n \n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n         self.relation.maybe_map(|&fr| tcx.lift(&fr))\n                      .map(|relation| FreeRegionMap { relation })\n     }"}, {"sha": "86384f511c68240924ef9c4e48ec306cf22cad5c", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -233,7 +233,7 @@ where\n     // See the comments on `process_registered_region_obligations` for the meaning\n     // of these fields.\n     delegate: D,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     verify_bound: VerifyBoundCx<'cx, 'gcx, 'tcx>,\n }\n \n@@ -260,7 +260,7 @@ where\n {\n     pub fn new(\n         delegate: D,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "154d0612d7d1195dddd35c14956ed5a7a872198e", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -13,15 +13,15 @@ use crate::util::captures::Captures;\n /// accrues them into the `region_obligations` code, but for NLL we\n /// use something else.\n pub struct VerifyBoundCx<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "fa6bbdbbbe724a430dab14e98a64ba81c5b84028", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -22,7 +22,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// refactor the constraint set.\n     pub fn leak_check(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         overly_polymorphic: bool,\n         placeholder_map: &PlaceholderMap<'tcx>,\n         _snapshot: &CombinedSnapshot<'_, 'tcx>,\n@@ -109,7 +109,7 @@ impl<'tcx> TaintSet<'tcx> {\n \n     fn fixed_point(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         undo_log: &[UndoLog<'tcx>],\n         verifys: &[Verify<'tcx>],\n     ) {"}, {"sha": "f63860f5390141b0d6ec102ece78ff0187a67d0a", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -700,7 +700,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn lub_regions(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -722,7 +722,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn glb_regions(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -744,7 +744,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn opportunistic_resolve_var(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         rid: RegionVid,\n     ) -> ty::Region<'tcx> {\n         let vid = self.unification_table.probe_value(rid).min_vid;\n@@ -760,7 +760,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     fn combine_vars(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         t: CombineMapType,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -850,7 +850,7 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n             GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),"}, {"sha": "ea9d8dbbb1e896330da01292c8c6c7475acda4ab", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'gcx, 'tcx> OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -61,7 +61,7 @@ impl<'a, 'gcx, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -177,7 +177,7 @@ struct FullTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "4f73f229423c3195a49b2a053f1f240af1692699", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -31,11 +31,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Sub<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Sub<'combine, 'infcx, 'gcx, 'tcx>\n-{\n+impl TypeRelation<'gcx, 'tcx> for Sub<'combine, 'infcx, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R"}, {"sha": "4d9c236598acc82b61d0b78694d77afce2f0d920", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -10,7 +10,7 @@ use std::marker::PhantomData;\n use std::cell::RefMut;\n \n pub trait ToType {\n-    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx>;\n }\n \n impl UnifyKey for ty::IntVid {\n@@ -52,7 +52,7 @@ impl UnifyKey for ty::RegionVid {\n }\n \n impl ToType for IntVarValue {\n-    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n             ty::UintType(i) => tcx.mk_mach_uint(i),\n@@ -72,7 +72,7 @@ impl UnifyKey for ty::FloatVid {\n impl EqUnifyValue for FloatVarValue {}\n \n impl ToType for FloatVarValue {\n-    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(self.0)\n     }\n }"}, {"sha": "3ddf57faa709b06cd17594499f0ee0a4fe7974bf", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -509,7 +509,7 @@ impl LintStore {\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n \n     /// Side-tables for the body we are in.\n     // FIXME: Make this lazy to avoid running the TypeckTables query?\n@@ -780,11 +780,11 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     /// }\n     /// ```\n     pub fn get_def_path(&self, def_id: DefId) -> Vec<Symbol> {\n-        pub struct AbsolutePathPrinter<'a, 'tcx> {\n-            pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        pub struct AbsolutePathPrinter<'tcx> {\n+            pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         }\n \n-        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n             type Error = !;\n \n             type Path = Vec<Symbol>;\n@@ -793,7 +793,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             type DynExistential = ();\n             type Const = ();\n \n-            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+            fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n                 self.tcx\n             }\n \n@@ -1372,7 +1372,7 @@ macro_rules! late_lint_pass_impl {\n late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     module_def_id: DefId,\n     pass: T,\n ) {\n@@ -1404,7 +1404,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n }\n \n pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     module_def_id: DefId,\n     builtin_lints: T,\n ) {\n@@ -1424,7 +1424,7 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n }\n \n fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     pass: T\n ) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n@@ -1460,7 +1460,7 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n }\n \n fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     builtin_lints: T\n ) {\n     let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n@@ -1494,7 +1494,7 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n /// Performs lint checking on a crate.\n pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     builtin_lints: impl FnOnce() -> T + Send,\n ) {\n     join(|| {"}, {"sha": "676b9d81162a0c15818f34fe8126e37ef94a43a1", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -766,7 +766,7 @@ pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_, '_>, id: hir::HirId) -> bool {\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n \n-fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n+fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, cnum: CrateNum)\n     -> &'tcx LintLevelMap\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n@@ -787,12 +787,12 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n     tcx.arena.alloc(builder.levels.build_map())\n }\n \n-struct LintLevelMapBuilder<'a, 'tcx: 'a> {\n+struct LintLevelMapBuilder<'tcx> {\n     levels: levels::LintLevelsBuilder<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n+impl LintLevelMapBuilder<'tcx> {\n     fn with_lint_attrs<F>(&mut self,\n                           id: hir::HirId,\n                           attrs: &[ast::Attribute],\n@@ -808,7 +808,7 @@ impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n+impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }"}, {"sha": "d2ea26c9686fe81627c2d8bc8a8c6b358863dee3", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -264,7 +264,7 @@ macro_rules! BraceStructLiftImpl {\n         {\n             type Lifted = $lifted;\n \n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<$lifted> {\n                 $(let $field = tcx.lift(&self.$field)?;)*\n                 Some(Self::Lifted { $($field),* })\n             }\n@@ -283,7 +283,7 @@ macro_rules! EnumLiftImpl {\n         {\n             type Lifted = $lifted;\n \n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<$lifted> {\n                 EnumLiftImpl!(@Variants(self, tcx) input($($variants)*) output())\n             }\n         }"}, {"sha": "b83bc2365ec968c4b02e0801ecf241f22b5d96f9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -212,7 +212,7 @@ pub trait CrateStore {\n \n     // utility functions\n     fn encode_metadata<'a, 'tcx>(&self,\n-                                 tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                 tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                                  -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }"}, {"sha": "3343aa9169147649e498c7a2fb078cfdddaf348f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -26,7 +26,7 @@ use syntax_pos;\n // explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn should_explore<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             hir_id: hir::HirId) -> bool {\n     match tcx.hir().find_by_hir_id(hir_id) {\n         Some(Node::Item(..)) |\n@@ -41,7 +41,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<hir::HirId>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     live_symbols: FxHashSet<hir::HirId>,\n     repr_has_repr_c: bool,\n@@ -353,7 +353,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n struct LifeSeeder<'k, 'tcx: 'k> {\n     worklist: Vec<hir::HirId>,\n     krate: &'k hir::Crate,\n-    tcx: TyCtxt<'k, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     // see `MarkSymbolVisitor::struct_constructors`\n     struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n@@ -424,7 +424,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n }\n \n fn create_and_seed_worklist<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate,\n ) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n@@ -451,7 +451,7 @@ fn create_and_seed_worklist<'a, 'tcx>(\n     (life_seeder.worklist, life_seeder.struct_constructors)\n }\n \n-fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn find_live<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n                        -> FxHashSet<hir::HirId> {\n@@ -471,12 +471,12 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     symbol_visitor.live_symbols\n }\n \n-struct DeadVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct DeadVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     live_symbols: FxHashSet<hir::HirId>,\n }\n \n-impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n+impl DeadVisitor<'tcx> {\n     fn should_warn_about_item(&mut self, item: &hir::Item) -> bool {\n         let should_warn = match item.node {\n             hir::ItemKind::Static(..)\n@@ -554,7 +554,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     /// Walk nested items in place so that we don't report dead-code\n     /// on inner functions when the outer function is already getting\n     /// an error. We could do this also by checking the parents, but\n@@ -660,7 +660,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n     let krate = tcx.hir().krate();\n     let live_symbols = find_live(tcx, access_levels, krate);"}, {"sha": "684bbe443a7435db49bd113e322b70b1f4f800ad", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -81,7 +81,7 @@ pub enum Linkage {\n     Dynamic,\n }\n \n-pub fn calculate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn calculate<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     let sess = &tcx.sess;\n     let fmts = sess.crate_types.borrow().iter().map(|&ty| {\n         let linkage = calculate_type(tcx, ty);\n@@ -92,7 +92,7 @@ pub fn calculate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     sess.dependency_formats.set(fmts);\n }\n \n-fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             ty: config::CrateType) -> DependencyList {\n \n     let sess = &tcx.sess;\n@@ -267,7 +267,7 @@ fn add_library(tcx: TyCtxt<'_, '_, '_>,\n     }\n }\n \n-fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyList> {\n+fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Option<DependencyList> {\n     let sess = &tcx.sess;\n     let crates = cstore::used_crates(tcx, RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n@@ -324,7 +324,7 @@ fn activate_injected_dep(injected: Option<CrateNum>,\n \n // After the linkage for a crate has been determined we need to verify that\n // there's only going to be one allocator in the output.\n-fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n+fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, list: &[Linkage]) {\n     let sess = &tcx.sess;\n     if list.len() == 0 {\n         return"}, {"sha": "0565e05b9501982104430e7be9352802536edcfd", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     ///\n     /// See also `with_infer`, which is used *during* typeck.\n     pub fn new(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n-               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                body_owner: DefId,\n                param_env: ty::ParamEnv<'tcx>,\n                region_scope_tree: &'a region::ScopeTree,\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.consume_expr(&body.value);\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.mc.tcx\n     }\n "}, {"sha": "31fb097e54705d6ad40c75f2a347a2c49cda4f3c", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -16,7 +16,7 @@ use crate::ty::{self, TyCtxt, Region};\n /// This stuff is a bit convoluted and should be refactored, but as we\n /// transition to NLL, it'll all go away anyhow.\n pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n \n     /// The context used to fetch the region maps.\n     pub context: DefId,\n@@ -30,7 +30,7 @@ pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         context: DefId,\n         region_scope_tree: &'a region::ScopeTree,\n         free_regions: &'a FreeRegionMap<'tcx>,"}, {"sha": "1fc1f889f5b140c87e27f5aa4ac02a33c487517f", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -10,7 +10,7 @@ use syntax_pos::{Span, sym};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir;\n \n-fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut ItemVisitor { tcx }.as_deep_visitor()\n@@ -24,19 +24,19 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-struct ItemVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+struct ItemVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>\n }\n \n-struct ExprVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ExprVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     tables: &'tcx ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n /// If the type is `Option<T>`, it will return `T`, otherwise\n /// the type itself. Works on most `Option`-like types.\n-fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 ty: Ty<'tcx>)\n                                 -> Ty<'tcx> {\n     let (def, substs) = match ty.sty {\n@@ -66,7 +66,7 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty\n }\n \n-impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n+impl ExprVisitor<'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         self.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n         self.tcx.item_name(def_id) == sym::transmute\n@@ -131,7 +131,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for ItemVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n@@ -146,7 +146,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for ExprVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }"}, {"sha": "b8b1a8443027cadf0cecf03a23dd627052774b08", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -104,14 +104,14 @@ impl LanguageItems {\n     )*\n }\n \n-struct LanguageItemCollector<'a, 'tcx: 'a> {\n+struct LanguageItemCollector<'tcx> {\n     items: LanguageItems,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     /// A mapping from the name of the lang item to its order and the form it must be of.\n     item_refs: FxHashMap<&'static str, (usize, Target)>,\n }\n \n-impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n+impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some((value, span)) = extract(&item.attrs) {\n             let actual_target = Target::from_item(item);\n@@ -159,8 +159,8 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItemCollector<'a, 'tcx> {\n+impl LanguageItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> LanguageItemCollector<'tcx> {\n         let mut item_refs = FxHashMap::default();\n \n         $( item_refs.insert($name, ($variant as usize, $target)); )*\n@@ -217,7 +217,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n }\n \n /// Traverse and collect all the lang items in all crates.\n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> LanguageItems {\n     // Initialize the collector.\n     let mut collector = LanguageItemCollector::new(tcx);\n \n@@ -402,7 +402,7 @@ language_item_table! {\n     Rc,                          \"rc\",                 rc,                      Target::Struct;\n }\n \n-impl<'a, 'tcx, 'gcx> TyCtxt<'a, 'tcx, 'gcx> {\n+impl<'a, 'tcx, 'gcx> TyCtxt<'gcx, 'tcx, 'gcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally abort compilation.\n     pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {"}, {"sha": "4066fe001ffb401203e67c1c0752ffba5b9d9a3b", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -37,13 +37,13 @@ impl LibFeatures {\n     }\n }\n \n-pub struct LibFeatureCollector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct LibFeatureCollector<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     lib_features: LibFeatures,\n }\n \n-impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LibFeatureCollector<'a, 'tcx> {\n+impl LibFeatureCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> LibFeatureCollector<'tcx> {\n         LibFeatureCollector {\n             tcx,\n             lib_features: LibFeatures::new(),\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for LibFeatureCollector<'a, 'tcx> {\n+impl Visitor<'tcx> for LibFeatureCollector<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LibFeatureCollector<'a, 'tcx> {\n     }\n }\n \n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LibFeatures {\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n     intravisit::walk_crate(&mut collector, tcx.hir().krate());\n     collector.lib_features"}, {"sha": "8d82e2fbca59d73486753901c610f6cfec1d7220", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -166,7 +166,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> Strin\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n     fn visit_arm(&mut self, a: &'tcx hir::Arm) { visit_arm(self, a); }\n }\n \n-fn check_mod_liveness<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_liveness<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut IrMaps::new(tcx, module_def_id).as_deep_visitor(),\n@@ -256,8 +256,8 @@ enum VarKind {\n     CleanExit\n }\n \n-struct IrMaps<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct IrMaps<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body_owner: DefId,\n     num_live_nodes: usize,\n     num_vars: usize,\n@@ -268,8 +268,8 @@ struct IrMaps<'a, 'tcx: 'a> {\n     lnks: Vec<LiveNodeKind>,\n }\n \n-impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body_owner: DefId) -> IrMaps<'a, 'tcx> {\n+impl IrMaps<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, body_owner: DefId) -> IrMaps<'tcx> {\n         IrMaps {\n             tcx,\n             body_owner,\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n }\n \n-fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n+fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'tcx>,\n                           fk: FnKind<'tcx>,\n                           decl: &'tcx hir::FnDecl,\n                           body_id: hir::BodyId,\n@@ -374,7 +374,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n         }\n     }\n \n-    debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps<'_, '_>);\n+    debug!(\"creating fn_maps: {:p}\", &fn_maps);\n \n     let body = ir.tcx.hir().body(body_id);\n \n@@ -411,7 +411,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n-fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n+fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'tcx>, pat: &P<hir::Pat>) {\n     // For struct patterns, take note of which fields used shorthand\n     // (`x` rather than `x: x`).\n     let mut shorthand_field_ids = HirIdSet::default();\n@@ -457,19 +457,19 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n     });\n }\n \n-fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n+fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local) {\n     add_from_pat(ir, &local.pat);\n     intravisit::walk_local(ir, local);\n }\n \n-fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm) {\n     for pat in &arm.pats {\n         add_from_pat(ir, pat);\n     }\n     intravisit::walk_arm(ir, arm);\n }\n \n-fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n+fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n@@ -681,7 +681,7 @@ const ACC_WRITE: u32 = 2;\n const ACC_USE: u32 = 4;\n \n struct Liveness<'a, 'tcx: 'a> {\n-    ir: &'a mut IrMaps<'a, 'tcx>,\n+    ir: &'a mut IrMaps<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n@@ -695,7 +695,7 @@ struct Liveness<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn new(ir: &'a mut IrMaps<'a, 'tcx>, body: hir::BodyId) -> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'tcx>, body: hir::BodyId) -> Liveness<'a, 'tcx> {\n         // Special nodes and variables:\n         // - exit_ln represents the end of the fn, either by return or panic\n         // - implicit_ret_var is a pseudo-variable that represents"}, {"sha": "d1814b5fe77d2e0ed4883b2d2bcb41082ea126d3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -288,7 +288,7 @@ impl HirNode for hir::Pat {\n \n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     pub body_owner: DefId,\n     pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     pub region_scope_tree: &'a region::ScopeTree,\n@@ -400,7 +400,7 @@ impl MutabilityCategory {\n }\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                body_owner: DefId,\n                region_scope_tree: &'a region::ScopeTree,\n                tables: &'a ty::TypeckTables<'tcx>,"}, {"sha": "4be7b699932ab5902c378f6aaf5ef1f4576a6686", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -27,7 +27,7 @@ use crate::hir::intravisit;\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn item_might_be_inlined(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                          item: &hir::Item,\n                          attrs: CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n@@ -44,7 +44,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n@@ -67,7 +67,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // Information needed while computing reachability.\n struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: HirIdSet,\n@@ -335,7 +335,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n // trait items are used from inlinable code through method call syntax or UFCS, or their\n // trait is a lang item.\n struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n     worklist: &'a mut Vec<hir::HirId>,\n }\n@@ -391,7 +391,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n #[derive(Clone, HashStable)]\n pub struct ReachableSet(pub Lrc<HirIdSet>);\n \n-fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n+fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);"}, {"sha": "3c2bb07ae12c7b75b33c14e3232d1c66284dfa19", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -358,8 +358,8 @@ pub struct Context {\n     parent: Option<(Scope, ScopeDepth)>,\n }\n \n-struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct RegionResolutionVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n \n     // The number of expressions and patterns visited in the current body\n     expr_and_pat_count: usize,\n@@ -646,7 +646,7 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn early_free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                       br: &ty::EarlyBoundRegion)\n                                       -> Scope {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n@@ -677,7 +677,7 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n+    pub fn free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n                                  -> Scope {\n         let param_owner = match fr.bound_region {\n             ty::BoundRegion::BrNamed(def_id, _) => {\n@@ -734,7 +734,7 @@ impl<'tcx> ScopeTree {\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n-fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_, '_>,\n+fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_>,\n                        var_id: hir::ItemLocalId,\n                        _sp: Span) {\n     match visitor.cx.var_parent {\n@@ -748,7 +748,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_, '_>,\n     }\n }\n \n-fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk: &'tcx hir::Block) {\n+fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx hir::Block) {\n     debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n \n     let prev_cx = visitor.cx;\n@@ -816,7 +816,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir::Arm) {\n     let prev_cx = visitor.cx;\n \n     visitor.enter_scope(\n@@ -838,7 +838,7 @@ fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n+fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir::Pat) {\n     visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -855,7 +855,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n     debug!(\"resolve_pat - post-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n }\n \n-fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n+fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx hir::Stmt) {\n     let stmt_id = stmt.hir_id.local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -874,7 +874,7 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt:\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr - pre-increment {} expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n     let prev_cx = visitor.cx;\n@@ -977,7 +977,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n+fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>,\n                            pat: Option<&'tcx hir::Pat>,\n                            init: Option<&'tcx hir::Expr>) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n@@ -1128,7 +1128,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     ///        | E& as ...\n     ///        | ( E& )\n     fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n-        visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n+        visitor: &mut RegionResolutionVisitor<'tcx>,\n         expr: &hir::Expr,\n         blk_id: Option<Scope>)\n     {\n@@ -1178,7 +1178,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     ///        | <rvalue>\n     ///\n     /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n-    fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n+    fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>,\n                                      expr: &hir::Expr,\n                                      blk_scope: Option<Scope>) {\n         let mut expr = expr;\n@@ -1205,7 +1205,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     }\n }\n \n-impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> RegionResolutionVisitor<'tcx> {\n     /// Records the current parent (if any) as the parent of `child_scope`.\n     /// Returns the depth of `child_scope`.\n     fn record_child_scope(&mut self, child_scope: Scope) -> ScopeDepth {\n@@ -1235,7 +1235,7 @@ impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n@@ -1327,7 +1327,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n     }\n }\n \n-fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId)\n     -> &'tcx ScopeTree\n {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);"}, {"sha": "83c2cab74e435bfdee19e19d9807a2ef4a0abf04", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -218,7 +218,7 @@ impl_stable_hash_for!(struct crate::middle::resolve_lifetime::ResolveLifetimes {\n });\n \n struct LifetimeContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n@@ -369,7 +369,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// directly, but rather use `named_region_map`, `is_late_bound_map`,\n /// etc.\n fn resolve_lifetimes<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     for_krate: CrateNum,\n ) -> &'tcx ResolveLifetimes {\n     assert_eq!(for_krate, LOCAL_CRATE);\n@@ -398,7 +398,7 @@ fn resolve_lifetimes<'tcx>(\n     tcx.arena.alloc(rl)\n }\n \n-fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {\n+fn krate<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> NamedRegionMap {\n     let krate = tcx.hir().krate();\n     let mut map = NamedRegionMap {\n         defs: Default::default(),\n@@ -1169,7 +1169,7 @@ fn signal_shadowing_problem(\n // if one of the label shadows a lifetime or another label.\n fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     struct GatherLabels<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<ast::Ident>,\n     }"}, {"sha": "45be13a756ba83bbf3c519741bbe3abc4f11e2c1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -106,7 +106,7 @@ impl_stable_hash_for!(struct self::Index<'tcx> {\n \n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<DeprecationEntry>,\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n }\n \n struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n }\n \n@@ -390,7 +390,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Index<'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Index<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Index<'tcx> {\n         let is_staged_api =\n             tcx.sess.opts.debugging_opts.force_unstable_if_unmarked ||\n             tcx.features().staged_api;\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> Index<'tcx> {\n \n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n-fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n }\n \n@@ -501,8 +501,8 @@ pub fn deprecation_in_effect(since: &str) -> bool {\n     }\n }\n \n-struct Checker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Checker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n /// Result of `TyCtxt::eval_stability`.\n@@ -521,7 +521,7 @@ pub enum EvalResult {\n     Unmarked,\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     // See issue #38412.\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n         // Check if `def_id` is a trait method.\n@@ -752,7 +752,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n+impl Visitor<'tcx> for Checker<'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n@@ -827,7 +827,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n         self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n     }\n@@ -836,7 +836,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// Given the list of enabled features that were not language features (i.e., that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n@@ -921,7 +921,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n fn unnecessary_stable_feature_lint<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     span: Span,\n     feature: Symbol,\n     since: Symbol"}, {"sha": "2d2213672b64b522c1ce103dc0f00074a2240657", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -18,13 +18,13 @@ macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n \n struct Context<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     items: &'a mut lang_items::LanguageItems,\n }\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              items: &mut lang_items::LanguageItems) {\n     // These are never called by user code, they're generated by the compiler.\n     // They will never implicitly be added to the `missing` array unless we do\n@@ -72,7 +72,7 @@ pub fn whitelisted(tcx: TyCtxt<'_, '_, '_>, lang_item: lang_items::LangItem) ->\n     false\n }\n \n-fn verify<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn verify<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                     items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n@@ -142,7 +142,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'gcx> TyCtxt<'a, 'tcx, 'gcx> {\n+impl<'a, 'tcx, 'gcx> TyCtxt<'gcx, 'tcx, 'gcx> {\n     pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n         let lang_items = self.lang_items();\n         let did = Some(item_def_id);"}, {"sha": "7024129c9d6f0c6db531d1152db371308e6dc85e", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -76,15 +76,15 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n \n impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     pub fn struct_error(&self,\n-        tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxtAt<'gcx, 'tcx>,\n         message: &str)\n         -> Result<DiagnosticBuilder<'tcx>, ErrorHandled>\n     {\n         self.struct_generic(tcx, message, None)\n     }\n \n     pub fn report_as_error(&self,\n-        tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxtAt<'gcx, 'tcx>,\n         message: &str\n     ) -> ErrorHandled {\n         let err = self.struct_error(tcx, message);\n@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     }\n \n     pub fn report_as_lint(&self,\n-        tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxtAt<'gcx, 'tcx>,\n         message: &str,\n         lint_root: hir::HirId,\n         span: Option<Span>,\n@@ -131,7 +131,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n \n     fn struct_generic(\n         &self,\n-        tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxtAt<'gcx, 'tcx>,\n         message: &str,\n         lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n@@ -173,7 +173,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n }\n \n pub fn struct_error<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxtAt<'gcx, 'tcx>,\n     msg: &str,\n ) -> DiagnosticBuilder<'tcx> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)"}, {"sha": "3e8bbbcb5c2f03b7977c656d6e76686cb9781bd4", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -69,7 +69,7 @@ pub fn specialized_encode_alloc_id<\n     E: Encoder,\n >(\n     encoder: &mut E,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n     let alloc: GlobalAlloc<'tcx> =\n@@ -150,8 +150,7 @@ impl<'s> AllocDecodingSession<'s> {\n     pub fn decode_alloc_id<'a, 'tcx, D>(&self,\n                                         decoder: &mut D)\n                                         -> Result<AllocId, D::Error>\n-        where D: TyDecoder<'a, 'tcx>,\n-              'tcx: 'a,\n+        where D: TyDecoder<'tcx>,\n     {\n         // Read the index of the allocation\n         let idx = decoder.read_u32()? as usize;"}, {"sha": "7753c64d7e338b5e575942253722205f528a6c37", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -1241,7 +1241,7 @@ impl<'tcx> Terminator<'tcx> {\n \n impl<'tcx> TerminatorKind<'tcx> {\n     pub fn if_<'a, 'gcx>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         cond: Operand<'tcx>,\n         t: BasicBlock,\n         f: BasicBlock,\n@@ -2324,7 +2324,7 @@ impl<'tcx> Operand<'tcx> {\n     /// with given `DefId` and substs. Since this is used to synthesize\n     /// MIR, assumes `user_ty` is None.\n     pub fn function_handle<'a>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n         span: Span,"}, {"sha": "60598d1e7673a3fb0345d4ecc8bbbbba69574db5", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -48,7 +48,7 @@ pub enum MonoItem<'tcx> {\n }\n \n impl<'tcx> MonoItem<'tcx> {\n-    pub fn size_estimate<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> usize {\n+    pub fn size_estimate<'a>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> usize {\n         match *self {\n             MonoItem::Fn(instance) => {\n                 // Estimate the size of a function based on how many statements\n@@ -72,7 +72,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> SymbolName {\n+    pub fn symbol_name(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> SymbolName {\n         match *self {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => {\n@@ -88,7 +88,7 @@ impl<'tcx> MonoItem<'tcx> {\n     }\n \n     pub fn instantiation_mode(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                           -> InstantiationMode {\n         let inline_in_all_cgus =\n             tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n@@ -133,7 +133,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n+    pub fn explicit_linkage(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Option<Linkage> {\n         let def_id = match *self {\n             MonoItem::Fn(ref instance) => instance.def_id(),\n             MonoItem::Static(def_id) => def_id,\n@@ -169,7 +169,7 @@ impl<'tcx> MonoItem<'tcx> {\n     /// Similarly, if a vtable method has such a signature, and therefore can't\n     /// be used, we can just not emit it and have a placeholder (a null pointer,\n     /// which will never be accessed) in its place.\n-    pub fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+    pub fn is_instantiable(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self {\n             MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n@@ -181,7 +181,7 @@ impl<'tcx> MonoItem<'tcx> {\n         tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n     }\n \n-    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, debug: bool) -> String {\n+    pub fn to_string(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>, debug: bool) -> String {\n         return match *self {\n             MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance, debug)\n@@ -195,7 +195,7 @@ impl<'tcx> MonoItem<'tcx> {\n             }\n         };\n \n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                         prefix: &str,\n                                         instance: Instance<'tcx>,\n                                         debug: bool)\n@@ -208,7 +208,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+    pub fn local_span(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Option<Span> {\n         match *self {\n             MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir().as_local_hir_id(def.def_id())\n@@ -334,7 +334,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         base_n::encode(hash, base_n::CASE_INSENSITIVE)\n     }\n \n-    pub fn estimate_size<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    pub fn estimate_size<'a>(&mut self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n         // Estimate the size of a codegen unit as (approximately) the number of MIR\n         // statements it corresponds to.\n         self.size_estimate = Some(self.items.keys().map(|mi| mi.size_estimate(tcx)).sum());\n@@ -370,15 +370,15 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn items_in_deterministic_order<'a>(&self,\n-                                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                        tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                                         -> Vec<(MonoItem<'tcx>,\n                                                 (Linkage, Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n         pub struct ItemSortKey(Option<HirId>, SymbolName);\n \n-        fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                    item: MonoItem<'tcx>) -> ItemSortKey {\n             ItemSortKey(match item {\n                 MonoItem::Fn(ref instance) => {\n@@ -415,7 +415,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         items\n     }\n \n-    pub fn codegen_dep_node(&self, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> DepNode {\n+    pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> DepNode {\n         DepNode::new(tcx, DepConstructor::CompileCodegenUnit(self.name().clone()))\n     }\n }\n@@ -445,14 +445,13 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n     }\n }\n \n-pub struct CodegenUnitNameBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct CodegenUnitNameBuilder<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     cache: FxHashMap<CrateNum, String>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> CodegenUnitNameBuilder<'a, 'gcx, 'tcx> {\n-\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+impl CodegenUnitNameBuilder<'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Self {\n         CodegenUnitNameBuilder {\n             tcx,\n             cache: Default::default(),"}, {"sha": "30676bb6044f1d566168d34c98ba6f648141c08d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// not carry a `Ty` for `T`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n-    pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n+    pub fn field_ty(self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n     {\n         let answer = match self.ty.sty {\n             ty::Adt(adt_def, substs) => {\n@@ -57,7 +57,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// Convenience wrapper around `projection_ty_core` for\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n-    pub fn projection_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn projection_ty(self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                          elem: &PlaceElem<'tcx>)\n                          -> PlaceTy<'tcx>\n     {\n@@ -71,7 +71,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// (which should be trivial when `T` = `Ty`).\n     pub fn projection_ty_core<V, T>(\n         self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n         -> PlaceTy<'tcx>\n@@ -121,7 +121,7 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PlaceTy<'tcx>\n+    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> PlaceTy<'tcx>\n         where D: HasLocalDecls<'tcx>\n     {\n         match *self {\n@@ -141,7 +141,7 @@ pub enum RvalueInitializationState {\n }\n \n impl<'tcx> Rvalue<'tcx> {\n-    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n+    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx>\n         where D: HasLocalDecls<'tcx>\n     {\n         match *self {\n@@ -222,7 +222,7 @@ impl<'tcx> Rvalue<'tcx> {\n }\n \n impl<'tcx> Operand<'tcx> {\n-    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n+    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx>\n         where D: HasLocalDecls<'tcx>\n     {\n         match self {\n@@ -234,7 +234,7 @@ impl<'tcx> Operand<'tcx> {\n }\n \n impl<'tcx> BinOp {\n-      pub fn ty<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+      pub fn ty<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                           lhs_ty: Ty<'tcx>,\n                           rhs_ty: Ty<'tcx>)\n                           -> Ty<'tcx> {"}, {"sha": "480d76b308dee406ff1b0a0abe4de54d2b5c2c1a", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -47,12 +47,12 @@ pub struct AutoTraitInfo<'cx> {\n     pub vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n }\n \n-pub struct AutoTraitFinder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct AutoTraitFinder<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+impl<'tcx> AutoTraitFinder<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Self {\n         AutoTraitFinder { tcx }\n     }\n \n@@ -232,7 +232,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n+impl AutoTraitFinder<'tcx> {\n     // The core logic responsible for computing the bounds for our synthesized impl.\n     //\n     // To calculate the bounds, we call SelectionContext.select in a loop. Like FulfillmentContext,\n@@ -834,11 +834,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n // Replaces all ReVars in a type with ty::Region's, using the provided map\n pub struct RegionReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "d576c13844d1e9513af73a9677ef72ab8798b8ff", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -18,7 +18,7 @@ use crate::ty::fold::TypeFoldable;\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to.\n /// Assumes that this is run after the entire crate has been successfully type-checked.\n-pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                           (param_env, trait_ref):\n                                           (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>))\n                                           -> Vtable<'tcx, ()>\n@@ -74,7 +74,7 @@ pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'tcx, 'tcx, 'tcx> {\n     /// Monomorphizes a type from the AST by first applying the\n     /// in-scope substitutions and then normalizing any associated\n     /// types."}, {"sha": "db9e7fc4b6d9b757a1d0f980932270b47b24009f", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -49,7 +49,7 @@ pub fn add_placeholder_note(err: &mut errors::DiagnosticBuilder<'_>) {\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, invokes `no_overlap`.\n pub fn overlapping_impls<'gcx, F1, F2, R>(\n-    tcx: TyCtxt<'_, 'gcx, 'gcx>,\n+    tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n@@ -183,7 +183,7 @@ fn overlap_within_probe(\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n-pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                              trait_ref: ty::TraitRef<'tcx>)\n                                              -> Option<Conflict>\n {\n@@ -229,7 +229,7 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n }\n \n-pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                                          trait_ref: ty::TraitRef<'tcx>)\n                                                          -> bool {\n     trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n@@ -246,7 +246,7 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                     impl_def_id: DefId)\n                                     -> Result<(), OrphanCheckErr<'tcx>>\n {"}, {"sha": "23bbd9192b1ccce0b7f4a01b730dd10f98716fa5", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -78,7 +78,7 @@ impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n }\n \n impl dyn TraitEngine<'tcx> {\n-    pub fn new(tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+    pub fn new(tcx: TyCtxt<'tcx, '_, 'tcx>) -> Box<Self> {\n         if tcx.sess.opts.debugging_opts.chalk {\n             Box::new(ChalkFulfillmentContext::new())\n         } else {"}, {"sha": "5b3e0dde0cc7254a9916d2248ded811fa2c2ee41", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -1249,7 +1249,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                            found: ty::PolyTraitRef<'tcx>)\n         -> DiagnosticBuilder<'tcx>\n     {\n-        fn build_fn_sig_string<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        fn build_fn_sig_string<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                                trait_ref: &ty::TraitRef<'tcx>) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.sty {\n@@ -1294,7 +1294,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     pub fn recursive_type_with_infinite_size_error(self,\n                                                    type_def_id: DefId)\n                                                    -> DiagnosticBuilder<'tcx>\n@@ -1457,7 +1457,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n+            fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.infcx.tcx }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Param(ty::ParamTy {name, .. }) = ty.sty {"}, {"sha": "774150ce7ad33e4db4851d964f33921af807ecba", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -140,7 +140,7 @@ pub struct ObligationCause<'tcx> {\n }\n \n impl<'tcx> ObligationCause<'tcx> {\n-    pub fn span<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Span {\n+    pub fn span<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Span {\n         match self.code {\n             ObligationCauseCode::CompareImplMethodObligation { .. } |\n             ObligationCauseCode::MainFunctionType |\n@@ -365,7 +365,7 @@ impl<'tcx> DomainGoal<'tcx> {\n impl<'tcx> GoalKind<'tcx> {\n     pub fn from_poly_domain_goal<'a, 'gcx>(\n         domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     ) -> GoalKind<'tcx> {\n         match domain_goal.no_bound_vars() {\n             Some(p) => p.into_goal(),\n@@ -710,7 +710,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n     }\n }\n \n-fn do_normalize_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn do_normalize_predicates<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                      region_context: DefId,\n                                      cause: ObligationCause<'tcx>,\n                                      elaborated_env: ty::ParamEnv<'tcx>,\n@@ -795,7 +795,7 @@ fn do_normalize_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n // FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n-pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                               region_context: DefId,\n                                               unnormalized_env: ty::ParamEnv<'tcx>,\n                                               cause: ObligationCause<'tcx>)\n@@ -936,7 +936,7 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n /// environment. If this returns false, then either normalize\n /// encountered an error or one of the predicates did not hold. Used\n /// when creating vtables to check for unsatisfiable methods.\n-fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                            predicates: Vec<ty::Predicate<'tcx>>)\n                                            -> bool\n {\n@@ -965,7 +965,7 @@ fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result\n }\n \n-fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                       key: (DefId, SubstsRef<'tcx>))\n                                                       -> bool\n {\n@@ -984,7 +984,7 @@ fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n /// that come from `trait_ref`, including its supertraits.\n #[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n fn vtable_methods<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n     -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>]\n {\n@@ -1207,16 +1207,16 @@ where\n \n     fn lift_ex_clause_to_tcx<'a, 'gcx>(\n         ex_clause: &chalk_engine::ExClause<Self>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     ) -> Option<Self::LiftedExClause>;\n \n     fn lift_delayed_literal_to_tcx<'a, 'gcx>(\n         ex_clause: &chalk_engine::DelayedLiteral<Self>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     ) -> Option<Self::LiftedDelayedLiteral>;\n \n     fn lift_literal_to_tcx<'a, 'gcx>(\n         ex_clause: &chalk_engine::Literal<Self>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     ) -> Option<Self::LiftedLiteral>;\n }"}, {"sha": "9e8cb58e6ea77b511f801b662429ceac1c51dcb8", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -83,7 +83,7 @@ pub enum MethodViolationCode {\n     UndispatchableReceiver,\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'tcx, 'tcx, 'tcx> {\n \n     /// Returns the object safety violations that affect\n     /// astconv -- currently, `Self` in supertraits. This is needed\n@@ -703,7 +703,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-pub(super) fn is_object_safe_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(super) fn is_object_safe_provider<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                 trait_def_id: DefId) -> bool {\n     tcx.object_safety_violations(trait_def_id).is_empty()\n }"}, {"sha": "5ddc3e8fe51032fa2d278cab7b63fc6af2ea9350", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -52,7 +52,7 @@ fn parse_error(tcx: TyCtxt<'_, '_, '_>, span: Span,\n }\n \n impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n-    fn parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn parse(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                  trait_def_id: DefId,\n                  items: &[NestedMetaItem],\n                  span: Span,\n@@ -133,7 +133,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     }\n \n \n-    pub fn of_item(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn of_item(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                    trait_def_id: DefId,\n                    impl_def_id: DefId)\n                    -> Result<Option<Self>, ErrorReported>\n@@ -165,7 +165,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     }\n \n     pub fn evaluate(&self,\n-                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                     trait_ref: ty::TraitRef<'tcx>,\n                     options: &[(Symbol, Option<String>)])\n                     -> OnUnimplementedNote\n@@ -215,7 +215,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n }\n \n impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n-    fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn try_parse(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                      trait_def_id: DefId,\n                      from: LocalInternedString,\n                      err_sp: Span)\n@@ -228,7 +228,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n \n     fn verify(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         trait_def_id: DefId,\n         span: Span,\n     ) -> Result<(), ErrorReported> {\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n \n     pub fn format(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n         options: &FxHashMap<Symbol, String>,\n     ) -> String {"}, {"sha": "6f52aaa020532f69ece387be27ebf121f9e32249", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n }\n \n impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.selcx.tcx()\n     }\n \n@@ -836,7 +836,7 @@ struct Progress<'tcx> {\n }\n \n impl<'tcx> Progress<'tcx> {\n-    fn error<'a,'gcx>(tcx: TyCtxt<'a,'gcx,'tcx>) -> Self {\n+    fn error<'a,'gcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Self {\n         Progress {\n             ty: tcx.types.err,\n             obligations: vec![],"}, {"sha": "7fdf3ddceb55b57ea81eb399cfc426bd1f949c7b", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -87,7 +87,7 @@ pub struct DropckOutlivesResult<'tcx> {\n impl<'tcx> DropckOutlivesResult<'tcx> {\n     pub fn report_overflows(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         span: Span,\n         ty: Ty<'tcx>,\n     ) {\n@@ -106,7 +106,7 @@ impl<'tcx> DropckOutlivesResult<'tcx> {\n \n     pub fn into_kinds_reporting_overflows(\n         self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         span: Span,\n         ty: Ty<'tcx>,\n     ) -> Vec<Kind<'tcx>> {\n@@ -190,7 +190,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n ///\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this function does not.\n-pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's"}, {"sha": "8ee5447ab292ad364991cdfd8fc05a8a8bfd8572", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -83,7 +83,7 @@ struct QueryNormalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "6c8f0d779290d9d185c0fd78c276920cb3e1cf7a", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -10,7 +10,7 @@\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n \n-impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n+impl<'cx, 'tcx> TyCtxt<'tcx, 'tcx, 'tcx> {\n     /// Erase the regions in `value` and then fully normalize all the\n     /// types found within. The result will also have regions erased.\n     ///\n@@ -62,13 +62,13 @@ impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n     }\n }\n \n-struct NormalizeAfterErasingRegionsFolder<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+struct NormalizeAfterErasingRegionsFolder<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'cx, 'tcx> TypeFolder<'tcx, 'tcx> for NormalizeAfterErasingRegionsFolder<'cx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+impl TypeFolder<'tcx, 'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "bb6b2272c783d2cc89584cb7983612d8f74e376d", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -25,14 +25,14 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for AscribeUserType<'tcx>\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         _key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         None\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_ascribe_user_type(canonicalized)"}, {"sha": "a8e786809467d2771a740d835909e8c386e8dd74", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -18,7 +18,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Eq<'tcx>>,\n     ) -> Option<Self::QueryResponse> {\n         if key.value.a == key.value.b {\n@@ -29,7 +29,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_eq(canonicalized)"}, {"sha": "537f6ccee62b7d757d2d932b238663dee851ceae", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -18,14 +18,14 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ImpliedOutlivesBounds<\n     type QueryResponse = Vec<OutlivesBound<'tcx>>;\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         _key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         None\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         // FIXME this `unchecked_map` is only necessary because the"}, {"sha": "c1f76eb2f2f286c1a7d05162d541424e2e68b40f", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -53,7 +53,7 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n     /// actually hits the tcx cache lookup etc. Return `Some(r)` with\n     /// a final result or `None` to do the full path.\n     fn try_fast_path(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse>;\n \n@@ -64,7 +64,7 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n     /// bad, because it would create subregion relationships that are\n     /// not captured in the return value.\n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>>;\n "}, {"sha": "3fc3d9607e777e38bf0d3ae22c916ff16d3c6932", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -24,7 +24,7 @@ where\n {\n     type QueryResponse = T;\n \n-    fn try_fast_path(_tcx: TyCtxt<'_, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<T> {\n+    fn try_fast_path(_tcx: TyCtxt<'tcx, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<T> {\n         if !key.value.value.has_projections() {\n             Some(key.value.value)\n         } else {\n@@ -33,7 +33,7 @@ where\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         T::type_op_method(tcx, canonicalized)\n@@ -48,7 +48,7 @@ where\n \n pub trait Normalizable<'gcx, 'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx> + Copy {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>>;\n \n@@ -64,7 +64,7 @@ where\n     'gcx: 'tcx,\n {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_ty(canonicalized)\n@@ -82,7 +82,7 @@ where\n     'gcx: 'tcx,\n {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_predicate(canonicalized)\n@@ -100,7 +100,7 @@ where\n     'gcx: 'tcx,\n {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_poly_fn_sig(canonicalized)\n@@ -118,7 +118,7 @@ where\n     'gcx: 'tcx,\n {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_fn_sig(canonicalized)"}, {"sha": "ee5cd30bde841a343969f9e1f76ad5235c8ebc43", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -22,7 +22,7 @@ where\n     type QueryResponse = DropckOutlivesResult<'tcx>;\n \n     fn try_fast_path(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n@@ -33,7 +33,7 @@ where\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         // Subtle: note that we are not invoking"}, {"sha": "6a46ea4057562991882a817fcb97a18c632f0b4c", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -17,7 +17,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         // Proving Sized, very often on \"obviously sized\" types like\n@@ -38,7 +38,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_prove_predicate(canonicalized)"}, {"sha": "346af0dd9df07229c4c278ac334a9b62e639a0f6", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -20,7 +20,7 @@ impl<'tcx> Subtype<'tcx> {\n impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     type QueryResponse = ();\n \n-    fn try_fast_path(_tcx: TyCtxt<'_, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<()> {\n+    fn try_fast_path(_tcx: TyCtxt<'tcx, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<()> {\n         if key.value.sub == key.value.sup {\n             Some(())\n         } else {\n@@ -29,7 +29,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_subtype(canonicalized)"}, {"sha": "4643e2498fc99871ec4fc941983e69bd74a10310", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -300,7 +300,7 @@ enum SelectionCandidate<'tcx> {\n \n impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n     type Lifted = SelectionCandidate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         Some(match *self {\n             BuiltinCandidate { has_nested } => BuiltinCandidate { has_nested },\n             ImplCandidate(def_id) => ImplCandidate(def_id),\n@@ -568,7 +568,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "8043bca8e09a36416030ddf28b4e79a5091f579d", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -110,7 +110,7 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// that impl, a less specialized impl, or the trait default,\n /// whichever applies.\n pub fn find_associated_item<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     item: &ty::AssocItem,\n     substs: SubstsRef<'tcx>,\n@@ -149,7 +149,7 @@ pub fn find_associated_item<'a, 'tcx>(\n /// Specialization is determined by the sets of types to which the impls apply;\n /// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n-pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                     (impl1_def_id, impl2_def_id): (DefId, DefId))\n     -> bool\n {\n@@ -286,7 +286,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n // Query provider for `specialization_graph_of`.\n pub(super) fn specialization_graph_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     trait_id: DefId,\n ) -> &'tcx specialization_graph::Graph {\n     let mut sg = specialization_graph::Graph::new();"}, {"sha": "8b386f3c0a0f5f28af7a0b26c324f32488bd0aa4", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -84,7 +84,7 @@ enum Inserted {\n impl<'a, 'gcx, 'tcx> Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self,\n-                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                      tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                       impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> Children {\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n     fn remove_existing(&mut self,\n-                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                      tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                       impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n@@ -119,7 +119,7 @@ impl<'a, 'gcx, 'tcx> Children {\n     /// Attempt to insert an impl into this set of children, while comparing for\n     /// specialization relationships.\n     fn insert(&mut self,\n-              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+              tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n               impl_def_id: DefId,\n               simplified_self: Option<SimplifiedType>)\n               -> Result<Inserted, OverlapError>\n@@ -294,7 +294,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n     pub fn insert(&mut self,\n-                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                  tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                   impl_def_id: DefId)\n                   -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n@@ -387,7 +387,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n     pub fn record_impl_from_cstore(&mut self,\n-                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                   tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                    parent: DefId,\n                                    child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n@@ -425,8 +425,8 @@ impl<'a, 'gcx, 'tcx> Node {\n     /// Iterate over the items defined directly by the given (impl or trait) node.\n     pub fn items(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    ) -> ty::AssocItemsIterator<'a, 'gcx, 'tcx> {\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n+    ) -> ty::AssocItemsIterator<'gcx, 'tcx> {\n         tcx.associated_items(self.def_id())\n     }\n \n@@ -475,18 +475,18 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Ancestors<'gcx> {\n+impl<'gcx, 'tcx> Ancestors<'gcx> {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n     #[inline]\n     pub fn defs(\n         self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         trait_item_name: Ident,\n         trait_item_kind: ty::AssocKind,\n         trait_def_id: DefId,\n-    ) -> impl Iterator<Item = NodeItem<ty::AssocItem>> + Captures<'gcx> + Captures<'tcx> + 'a {\n+    ) -> impl Iterator<Item = NodeItem<ty::AssocItem>> + Captures<'gcx> + 'tcx {\n         self.flat_map(move |node| {\n             use crate::ty::AssocKind::*;\n             node.items(tcx).filter(move |impl_item| match (trait_item_kind, impl_item.kind) {"}, {"sha": "1591cad9ae51a21037bc10fd8796f45c2b3caf87", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -446,7 +446,7 @@ impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n     type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             super::Unimplemented => Some(super::Unimplemented),\n             super::OutputTypeParameterMismatch(a, b, ref err) => {\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n     type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             super::ReturnNoExpression => Some(super::ReturnNoExpression),\n             super::MiscObligation => Some(super::MiscObligation),\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n     type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.parent_trait_ref).and_then(|trait_ref|\n             tcx.lift(&*self.parent_code)\n                .map(|code| traits::DerivedObligationCause {\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n     type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.code).map(|code| traits::ObligationCause {\n             span: self.span,\n             body_id: self.body_id,\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n // For codegen only.\n impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     type Lifted = traits::Vtable<'tcx, ()>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.clone() {\n             traits::VtableImpl(traits::VtableImplData {\n                 impl_def_id,\n@@ -691,7 +691,7 @@ EnumLiftImpl! {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n     type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.clauses).map(|clauses| {\n             traits::Environment {\n                 clauses,\n@@ -702,7 +702,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n \n impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n     type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.environment).and_then(|environment| {\n             tcx.lift(&self.goal).map(|goal| {\n                 traits::InEnvironment {\n@@ -721,7 +721,7 @@ where\n {\n     type Lifted = C::LiftedExClause;\n \n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n     }\n }\n@@ -733,7 +733,7 @@ where\n {\n     type Lifted = C::LiftedDelayedLiteral;\n \n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n     }\n }\n@@ -745,7 +745,7 @@ where\n {\n     type Lifted = C::LiftedLiteral;\n \n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n     }\n }"}, {"sha": "3f0ac9036f8ba952ce46cad74c59a0ff76616512", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -12,7 +12,7 @@ use crate::util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                        pred: &ty::Predicate<'tcx>)\n                                        -> ty::Predicate<'tcx> {\n     match *pred {\n@@ -45,13 +45,13 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n }\n \n-struct PredicateSet<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct PredicateSet<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     set: FxHashSet<ty::Predicate<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+impl PredicateSet<'gcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Self {\n         Self { tcx: tcx, set: Default::default() }\n     }\n \n@@ -70,7 +70,7 @@ impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'a, 'gcx, 'tcx> {\n+impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'gcx, 'tcx> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         for pred in iter {\n             self.insert(pred.as_ref());\n@@ -88,39 +88,39 @@ impl<'a, 'gcx, 'tcx, T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'\n /// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n /// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n /// `T: Foo`, then we know that `T: 'static`.\n-pub struct Elaborator<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+pub struct Elaborator<'gcx, 'tcx> {\n     stack: Vec<ty::Predicate<'tcx>>,\n-    visited: PredicateSet<'a, 'gcx, 'tcx>,\n+    visited: PredicateSet<'gcx, 'tcx>,\n }\n \n pub fn elaborate_trait_ref<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Elaborator<'cx, 'gcx, 'tcx>\n+    -> Elaborator<'gcx, 'tcx>\n {\n     elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n }\n \n pub fn elaborate_trait_refs<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n-    -> Elaborator<'cx, 'gcx, 'tcx>\n+    -> Elaborator<'gcx, 'tcx>\n {\n     let predicates = trait_refs.map(|trait_ref| trait_ref.to_predicate()).collect();\n     elaborate_predicates(tcx, predicates)\n }\n \n pub fn elaborate_predicates<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>)\n-    -> Elaborator<'cx, 'gcx, 'tcx>\n+    -> Elaborator<'gcx, 'tcx>\n {\n     let mut visited = PredicateSet::new(tcx);\n     predicates.retain(|pred| visited.insert(pred));\n     Elaborator { stack: predicates, visited }\n }\n \n-impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n+impl Elaborator<'gcx, 'tcx> {\n     pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n         FilterToTraits::new(self)\n     }\n@@ -232,7 +232,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Iterator for Elaborator<'cx, 'gcx, 'tcx> {\n+impl Iterator for Elaborator<'gcx, 'tcx> {\n     type Item = ty::Predicate<'tcx>;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -254,17 +254,17 @@ impl<'cx, 'gcx, 'tcx> Iterator for Elaborator<'cx, 'gcx, 'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'cx, 'gcx, 'tcx> = FilterToTraits<Elaborator<'cx, 'gcx, 'tcx>>;\n+pub type Supertraits<'gcx, 'tcx> = FilterToTraits<Elaborator<'gcx, 'tcx>>;\n \n-pub fn supertraits<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+pub fn supertraits<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                     trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Supertraits<'cx, 'gcx, 'tcx> {\n+                                    -> Supertraits<'gcx, 'tcx> {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n-pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                           bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n-                                          -> Supertraits<'cx, 'gcx, 'tcx> {\n+                                          -> Supertraits<'gcx, 'tcx> {\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n@@ -280,8 +280,8 @@ pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n /// `Read + Write + Sync + Send`.\n /// Expansion is done via a DFS (depth-first search), and the `visited` field\n /// is used to avoid cycles.\n-pub struct TraitAliasExpander<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct TraitAliasExpander<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     stack: Vec<TraitAliasExpansionInfo<'tcx>>,\n }\n \n@@ -338,17 +338,17 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n }\n \n pub fn expand_trait_aliases<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>\n-) -> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+) -> TraitAliasExpander<'gcx, 'tcx> {\n     let items: Vec<_> = trait_refs\n         .into_iter()\n         .map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span))\n         .collect();\n     TraitAliasExpander { tcx, stack: items }\n }\n \n-impl<'cx, 'gcx, 'tcx> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> TraitAliasExpander<'gcx, 'tcx> {\n     /// If `item` is a trait alias and its predicate has not yet been visited, then expands `item`\n     /// to the definition, pushes the resulting expansion onto `self.stack`, and returns `false`.\n     /// Otherwise, immediately returns `true` if `item` is a regular trait, or `false` if it is a\n@@ -393,7 +393,7 @@ impl<'cx, 'gcx, 'tcx> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Iterator for TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> Iterator for TraitAliasExpander<'gcx, 'tcx> {\n     type Item = TraitAliasExpansionInfo<'tcx>;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -414,15 +414,15 @@ impl<'cx, 'gcx, 'tcx> Iterator for TraitAliasExpander<'cx, 'gcx, 'tcx> {\n // Iterator over def-IDs of supertraits\n ///////////////////////////////////////////////////////////////////////////\n \n-pub struct SupertraitDefIds<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct SupertraitDefIds<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     stack: Vec<DefId>,\n     visited: FxHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                            trait_def_id: DefId)\n-                                           -> SupertraitDefIds<'cx, 'gcx, 'tcx>\n+                                           -> SupertraitDefIds<'gcx, 'tcx>\n {\n     SupertraitDefIds {\n         tcx,\n@@ -431,7 +431,7 @@ pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n+impl Iterator for SupertraitDefIds<'gcx, 'tcx> {\n     type Item = DefId;\n \n     fn next(&mut self) -> Option<DefId> {\n@@ -552,7 +552,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     pub fn predicate_for_trait_def(self,\n                                    param_env: ty::ParamEnv<'tcx>,\n                                    cause: ObligationCause<'tcx>,"}, {"sha": "aca22baf7d1a7b3e3f3b05ab75299185f0db6990", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -19,19 +19,19 @@ use crate::mir::interpret::ConstValue;\n /// Like subtyping, matching is really a binary relation, so the only\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n-pub struct Match<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>\n+pub struct Match<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>\n }\n \n-impl<'a, 'gcx, 'tcx> Match<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Match<'a, 'gcx, 'tcx> {\n+impl Match<'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Match<'gcx, 'tcx> {\n         Match { tcx }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n+impl TypeRelation<'gcx, 'tcx> for Match<'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,"}, {"sha": "191a584dd64a6bd438029db744ee2951ea777118", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -104,7 +104,7 @@ pub struct OverloadedDeref<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n-    pub fn method_call(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, source: Ty<'tcx>)\n+    pub fn method_call(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, source: Ty<'tcx>)\n                        -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n             hir::MutImmutable => tcx.lang_items().deref_trait(),"}, {"sha": "ade084a2135bf4bd2a886d7bfdf24a803378afb5", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -107,9 +107,8 @@ pub fn encode_predicates<'tcx, E, C>(encoder: &mut E,\n     Ok(())\n }\n \n-pub trait TyDecoder<'a, 'tcx: 'a>: Decoder {\n-\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+pub trait TyDecoder<'tcx>: Decoder {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx>;\n \n     fn peek_byte(&self) -> u8;\n \n@@ -135,7 +134,7 @@ pub trait TyDecoder<'a, 'tcx: 'a>: Decoder {\n pub fn decode_arena_allocable<'a, 'tcx, D, T: ArenaAllocatable + Decodable>(\n     decoder: &mut D\n ) -> Result<&'tcx T, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     Ok(decoder.tcx().arena.alloc(Decodable::decode(decoder)?))\n@@ -145,15 +144,15 @@ pub fn decode_arena_allocable<'a, 'tcx, D, T: ArenaAllocatable + Decodable>(\n pub fn decode_arena_allocable_slice<'a, 'tcx, D, T: ArenaAllocatable + Decodable>(\n     decoder: &mut D\n ) -> Result<&'tcx [T], D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     Ok(decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable>::decode(decoder)?))\n }\n \n #[inline]\n pub fn decode_cnum<'a, 'tcx, D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     let cnum = CrateNum::from_u32(u32::decode(decoder)?);\n@@ -162,7 +161,7 @@ pub fn decode_cnum<'a, 'tcx, D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n \n #[inline]\n pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     // Handle shorthands first, if we have an usize > 0x80.\n@@ -183,7 +182,7 @@ pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n #[inline]\n pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n                                       -> Result<ty::GenericPredicates<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     Ok(ty::GenericPredicates {\n@@ -207,7 +206,7 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n \n #[inline]\n pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     let len = decoder.read_usize()?;\n@@ -217,7 +216,7 @@ pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D:\n \n #[inline]\n pub fn decode_region<'a, 'tcx, D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n@@ -226,7 +225,7 @@ pub fn decode_region<'a, 'tcx, D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D\n #[inline]\n pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n                                     -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     let len = decoder.read_usize()?;\n@@ -236,7 +235,7 @@ pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n #[inline]\n pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n                                    -> Result<&'tcx ty::AdtDef, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     let def_id = DefId::decode(decoder)?;\n@@ -246,7 +245,7 @@ pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n #[inline]\n pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n     -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     let len = decoder.read_usize()?;\n@@ -257,7 +256,7 @@ pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n #[inline]\n pub fn decode_canonical_var_infos<'a, 'tcx, D>(decoder: &mut D)\n     -> Result<CanonicalVarInfos<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     let len = decoder.read_usize()?;\n@@ -270,7 +269,7 @@ pub fn decode_canonical_var_infos<'a, 'tcx, D>(decoder: &mut D)\n #[inline]\n pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n                                  -> Result<&'tcx ty::Const<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n@@ -279,7 +278,7 @@ pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n #[inline]\n pub fn decode_allocation<'a, 'tcx, D>(decoder: &mut D)\n     -> Result<&'tcx Allocation, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n+    where D: TyDecoder<'tcx>,\n           'tcx: 'a,\n {\n     Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))"}, {"sha": "8cb2a9f33fba9812694c59ccd28e7c9663bcdcba", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -6,7 +6,7 @@ use syntax_pos::symbol::{sym, Symbol};\n use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'tcx, 'tcx, 'tcx> {\n     /// Whether the `def_id` counts as const fn in your current crate, considering all active\n     /// feature gates\n     pub fn is_const_fn(self, def_id: DefId) -> bool {\n@@ -69,7 +69,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n     /// only checks whether the function has a `const` modifier\n-    fn is_const_fn_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn is_const_fn_raw<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> bool {\n         let hir_id = tcx.hir().as_local_hir_id(def_id)\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n@@ -83,7 +83,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n-    fn is_promotable_const_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn is_promotable_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> bool {\n         tcx.is_const_fn(def_id) && match tcx.lookup_stability(def_id) {\n             Some(stab) => {\n                 if cfg!(debug_assertions) && stab.promotable {\n@@ -101,7 +101,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n-    fn const_fn_is_allowed_fn_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn const_fn_is_allowed_fn_ptr<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> bool {\n         tcx.is_const_fn(def_id) &&\n             tcx.lookup_stability(def_id)\n                 .map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)"}, {"sha": "9e6c63026ddebe1323a1a907c51106a5d5c17727", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -1119,7 +1119,7 @@ pub struct GlobalCtxt<'tcx> {\n     output_filenames: Arc<OutputFilenames>,\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     /// Gets the global `TyCtxt`.\n     #[inline]\n     pub fn global_tcx(self) -> TyCtxt<'gcx, 'gcx, 'gcx> {\n@@ -1131,7 +1131,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline(always)]\n-    pub fn hir(self) -> &'a hir_map::Map<'gcx> {\n+    pub fn hir(self) -> &'tcx hir_map::Map<'gcx> {\n         &self.hir_map\n     }\n \n@@ -1469,7 +1469,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline(always)]\n-    pub fn create_stable_hashing_context(self) -> StableHashingContext<'a> {\n+    pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.hir_map.forest.untracked_krate();\n \n         StableHashingContext::new(self.sess,\n@@ -1666,7 +1666,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'tcx, 'tcx, 'tcx> {\n     pub fn encode_metadata(self)\n         -> EncodedMetadata\n     {\n@@ -1725,15 +1725,15 @@ impl<'gcx> GlobalCtxt<'gcx> {\n /// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {\n     type Lifted: fmt::Debug + 'tcx;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n \n macro_rules! nop_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n                 if tcx.interners.arena.in_arena(*self as *const _) {\n                     return Some(unsafe { mem::transmute(*self) });\n                 }\n@@ -1752,7 +1752,7 @@ macro_rules! nop_list_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n             type Lifted = &'tcx List<$lifted>;\n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n                 if self.is_empty() {\n                     return Some(List::empty());\n                 }\n@@ -1978,7 +1978,7 @@ pub mod tls {\n     /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n     /// This is used in the deadlock handler.\n     pub unsafe fn with_global<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'tcx, 'gcx, 'tcx>) -> R\n     {\n         let gcx = GCX_PTR.with(|lock| *lock.lock());\n         assert!(gcx != 0);\n@@ -2030,7 +2030,7 @@ pub mod tls {\n     /// This will panic if you pass it a TyCtxt which has a different global interner from\n     /// the current ImplicitCtxt's tcx field.\n     #[inline]\n-    pub fn with_related_context<'a, 'gcx, 'tcx1, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx1>, f: F) -> R\n+    pub fn with_related_context<'gcx, 'tcx1, F, R>(tcx: TyCtxt<'tcx1, 'gcx, 'tcx1>, f: F) -> R\n         where F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R\n     {\n         with_context(|context| {\n@@ -2048,7 +2048,7 @@ pub mod tls {\n     /// This will panic if you pass it a TyCtxt which has a different global interner or\n     /// a different local interner from the current ImplicitCtxt's tcx field.\n     #[inline]\n-    pub fn with_fully_related_context<'a, 'gcx, 'tcx, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx>, f: F) -> R\n+    pub fn with_fully_related_context<'gcx, 'tcx, F, R>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>, f: F) -> R\n         where F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R\n     {\n         with_context(|context| {\n@@ -2065,7 +2065,7 @@ pub mod tls {\n     /// Panics if there is no ImplicitCtxt available\n     #[inline]\n     pub fn with<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'tcx, 'gcx, 'tcx>) -> R\n     {\n         with_context(|context| f(context.tcx))\n     }\n@@ -2074,7 +2074,7 @@ pub mod tls {\n     /// The closure is passed None if there is no ImplicitCtxt available\n     #[inline]\n     pub fn with_opt<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'tcx, 'gcx, 'tcx>>) -> R\n     {\n         with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n     }\n@@ -2151,7 +2151,7 @@ macro_rules! sty_debug_print {\n     }}\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'tcx, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n@@ -2400,7 +2400,7 @@ intern_method! {\n     ) -> List<CanonicalVarInfo>\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     /// Given a `fn` type, returns an equivalent `unsafe fn` type;\n     /// that is, a `fn` type that is equivalent in every way for being\n     /// unsafe."}, {"sha": "5f41aa9fac93742eeaa773bbeac84cc9c7c9842c", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -8,13 +8,13 @@ pub(super) fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n }\n \n-fn erase_regions_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+fn erase_regions_ty<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     // N.B., use `super_fold_with` here. If we used `fold_with`, it\n     // could invoke the `erase_regions_ty` query recursively.\n     ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     /// Returns an equivalent value with all free regions removed (note\n     /// that late-bound regions remain, because they are important for\n     /// subtyping, but they are anonymized and normalized as well)..\n@@ -32,12 +32,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct RegionEraserVisitor<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct RegionEraserVisitor<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraserVisitor<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+impl TypeFolder<'gcx, 'tcx> for RegionEraserVisitor<'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "3855b856562de7166a5c7071f36e76384b0eb596", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n }\n \n impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n-    pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> Cow<'static, str> {\n+    pub fn sort_string(&self, tcx: TyCtxt<'lcx, 'gcx, 'lcx>) -> Cow<'static, str> {\n         match self.sty {\n             ty::Bool | ty::Char | ty::Int(_) |\n             ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string().into(),\n@@ -249,7 +249,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     pub fn note_and_explain_type_err(self,\n                                      db: &mut DiagnosticBuilder<'_>,\n                                      err: &TypeError<'tcx>,"}, {"sha": "de148018b838338ac173c874f8374c66873abbc0", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -55,7 +55,7 @@ pub enum SimplifiedTypeGen<D>\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                      ty: Ty<'_>,\n                                      can_simplify_params: bool)\n                                      -> Option<SimplifiedType>"}, {"sha": "0a0ac3f2861aa92e77c5590c07a1f2841dcf6a6f", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -156,7 +156,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'gcx, 'tcx>;\n \n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n@@ -198,23 +198,23 @@ pub trait TypeVisitor<'tcx> : Sized {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F, G, H>\n+pub struct BottomUpFolder<'gcx, 'tcx, F, G, H>\n     where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n           G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n           H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     pub ty_op: F,\n     pub lt_op: G,\n     pub ct_op: H,\n }\n \n-impl<'a, 'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F, G, H>\n+impl<'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'gcx, 'tcx, F, G, H>\n     where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n           G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n           H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t = ty.super_fold_with(self);\n@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     /// Collects the free and escaping regions in `value` into `region_set`. Returns\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n@@ -362,7 +362,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// visited by `fld_r`.\n \n pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n \n     /// Stores the index of a binder *just outside* the stuff we have\n@@ -382,7 +382,7 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         skipped_regions: &'a mut bool,\n         fold_region_fn: &'a mut dyn FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n     ) -> RegionFolder<'a, 'gcx, 'tcx> {\n@@ -396,7 +396,7 @@ impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -427,7 +427,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n \n /// Replaces the escaping bound vars (late bound regions or bound types) in a type.\n struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n \n     /// As with `RegionFolder`, represents the index of a binder *just outside*\n     /// the ones we have visited.\n@@ -440,7 +440,7 @@ struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n     fn new<F, G, H>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         fld_r: &'a mut F,\n         fld_t: &'a mut G,\n         fld_c: &'a mut H,\n@@ -460,7 +460,7 @@ impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -542,7 +542,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     /// Replaces all regions bound by the given `Binder` with the\n     /// results returned by the closure; the closure is expected to\n     /// return a free region (relative to this binder), and hence the\n@@ -722,15 +722,15 @@ enum Direction {\n     Out,\n }\n \n-struct Shifter<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct Shifter<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n     direction: Direction,\n }\n \n-impl Shifter<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32, direction: Direction) -> Self {\n+impl Shifter<'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>, amount: u32, direction: Direction) -> Self {\n         Shifter {\n             tcx,\n             current_index: ty::INNERMOST,\n@@ -740,8 +740,8 @@ impl Shifter<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+impl TypeFolder<'gcx, 'tcx> for Shifter<'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -818,7 +818,7 @@ impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n }\n \n pub fn shift_region<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     region: ty::Region<'tcx>,\n     amount: u32\n ) -> ty::Region<'tcx> {\n@@ -833,7 +833,7 @@ pub fn shift_region<'a, 'gcx, 'tcx>(\n }\n \n pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     value: &T,\n     amount: u32\n ) -> T where T: TypeFoldable<'tcx> {\n@@ -844,7 +844,7 @@ pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n }\n \n pub fn shift_out_vars<'a, 'gcx, 'tcx, T>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     value: &T,\n     amount: u32\n ) -> T where T: TypeFoldable<'tcx> {"}, {"sha": "a0be4b3e7d838f51cc581715dbe6d9d883d27c04", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n     /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n-    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n+    pub fn full(tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> DefIdForest {\n         let crate_id = tcx.hir().local_def_id(CRATE_NODE_ID);\n         DefIdForest::from_id(crate_id)\n     }\n@@ -53,14 +53,14 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n \n     /// Tests whether the forest contains a given DefId.\n     pub fn contains(&self,\n-                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                     id: DefId) -> bool\n     {\n         self.root_ids.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n     }\n \n     /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn intersection<I>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                            iter: I) -> DefIdForest\n             where I: IntoIterator<Item=DefIdForest>\n     {\n@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n     }\n \n     /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn union<I>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                     iter: I) -> DefIdForest\n             where I: IntoIterator<Item=DefIdForest>\n     {"}, {"sha": "fe05a86377671b9e9b8cd95eeafe32f1b832083b", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -51,7 +51,7 @@ mod def_id_forest;\n // This code should only compile in modules where the uninhabitedness of Foo is\n // visible.\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n     /// # Example\n     /// ```rust\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>) -> DefIdForest\n     {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>,\n         adt_kind: AdtKind) -> DefIdForest\n     {\n@@ -154,7 +154,7 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>,\n         is_enum: bool,\n     ) -> DefIdForest {\n@@ -182,7 +182,7 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n \n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    fn uninhabited_from(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n             Adt(def, substs) => def.uninhabited_from(tcx, substs),"}, {"sha": "e35b7226f4941ccf42afaf5beffb29dc94e6e1af", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -44,7 +44,7 @@ pub enum InstanceDef<'tcx> {\n \n impl<'a, 'tcx> Instance<'tcx> {\n     pub fn ty(&self,\n-              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+              tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n               -> Ty<'tcx>\n     {\n         let ty = tcx.type_of(self.def.def_id());\n@@ -55,7 +55,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         )\n     }\n \n-    fn fn_sig_noadjust(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> PolyFnSig<'tcx> {\n+    fn fn_sig_noadjust(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> PolyFnSig<'tcx> {\n         let ty = self.ty(tcx);\n         match ty.sty {\n             ty::FnDef(..) |\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         let mut fn_sig = self.fn_sig_noadjust(tcx);\n         if let InstanceDef::VtableShim(..) = self.def {\n             // Modify fn(self, ...) to fn(self: *mut Self, ...)\n@@ -136,13 +136,13 @@ impl<'tcx> InstanceDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn attrs<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n+    pub fn attrs<'a>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n \n     pub fn is_inline<'a>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>\n     ) -> bool {\n         use crate::hir::map::DefPathData;\n         let def_id = match *self {\n@@ -158,7 +158,7 @@ impl<'tcx> InstanceDef<'tcx> {\n \n     pub fn requires_local<'a>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>\n     ) -> bool {\n         if self.is_inline(tcx) {\n             return true\n@@ -218,7 +218,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n         Instance { def: InstanceDef::Item(def_id), substs: substs }\n     }\n \n-    pub fn mono(tcx: TyCtxt<'a, 'tcx, 'b>, def_id: DefId) -> Instance<'tcx> {\n+    pub fn mono(tcx: TyCtxt<'b, 'tcx, 'b>, def_id: DefId) -> Instance<'tcx> {\n         Instance::new(def_id, tcx.global_tcx().empty_substs_for_def_id(def_id))\n     }\n \n@@ -245,7 +245,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     /// Presuming that coherence and type-check have succeeded, if this method is invoked\n     /// in a monomorphic context (i.e., like during codegen), then it is guaranteed to return\n     /// `Some`.\n-    pub fn resolve(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn resolve(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                    param_env: ty::ParamEnv<'tcx>,\n                    def_id: DefId,\n                    substs: SubstsRef<'tcx>) -> Option<Instance<'tcx>> {\n@@ -297,7 +297,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n         result\n     }\n \n-    pub fn resolve_for_vtable(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn resolve_for_vtable(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                               param_env: ty::ParamEnv<'tcx>,\n                               def_id: DefId,\n                               substs: SubstsRef<'tcx>) -> Option<Instance<'tcx>> {\n@@ -317,7 +317,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_closure(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         def_id: DefId,\n         substs: ty::ClosureSubsts<'tcx>,\n         requested_kind: ty::ClosureKind)\n@@ -332,7 +332,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_drop_in_place(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         ty: Ty<'tcx>)\n         -> ty::Instance<'tcx>\n     {\n@@ -342,7 +342,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     }\n \n     pub fn fn_once_adapter_instance(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         closure_did: DefId,\n         substs: ty::ClosureSubsts<'tcx>)\n         -> Instance<'tcx>\n@@ -377,7 +377,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n }\n \n fn resolve_associated_item<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     trait_item: &ty::AssocItem,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_id: DefId,"}, {"sha": "d433c3920bff2e07271537d7515ddfa8279d2650", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -31,9 +31,9 @@ use rustc_target::abi::call::{\n \n \n pub trait IntegerExt {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n     fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer;\n-    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             ty: Ty<'tcx>,\n                             repr: &ReprOptions,\n                             min: i128,\n@@ -42,7 +42,7 @@ pub trait IntegerExt {\n }\n \n impl IntegerExt for Integer {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx> {\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx> {\n         match (*self, signed) {\n             (I8, false) => tcx.types.u8,\n             (I16, false) => tcx.types.u16,\n@@ -77,7 +77,7 @@ impl IntegerExt for Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u128 values above i128::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             ty: Ty<'tcx>,\n                             repr: &ReprOptions,\n                             min: i128,\n@@ -126,11 +126,11 @@ impl IntegerExt for Integer {\n }\n \n pub trait PrimitiveExt {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx>;\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Ty<'tcx>;\n }\n \n impl PrimitiveExt for Primitive {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n             Float(FloatTy::F32) => tcx.types.f32,\n@@ -171,7 +171,7 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                         query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                         -> Result<&'tcx LayoutDetails, LayoutError<'tcx>>\n {\n@@ -226,7 +226,7 @@ enum StructKind {\n     Prefixed(Size, Align),\n }\n \n-impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx, 'tcx>> {\n     fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutDetails {\n         let dl = self.data_layout();\n         let b_align = b.value.align(dl);\n@@ -1221,7 +1221,7 @@ enum SavedLocalEligibility {\n // Also included in the layout are the upvars and the discriminant.\n // These are included as fields on the \"outer\" layout; they are not part\n // of any variant.\n-impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx, 'tcx>> {\n     /// Compute the eligibility and assignment of each local.\n     fn generator_saved_local_eligibility(&self, info: &GeneratorLayout<'tcx>)\n     -> (BitSet<GeneratorSavedLocal>, IndexVec<GeneratorSavedLocal, SavedLocalEligibility>) {\n@@ -1442,9 +1442,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n         Ok(layout)\n     }\n-}\n \n-impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline(always)]\n@@ -1607,7 +1605,7 @@ pub enum SizeSkeleton<'tcx> {\n \n impl<'a, 'tcx> SizeSkeleton<'tcx> {\n     pub fn compute(ty: Ty<'tcx>,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                    param_env: ty::ParamEnv<'tcx>)\n                    -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n         debug_assert!(!ty.has_infer_types());\n@@ -1729,21 +1727,21 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n }\n \n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx>;\n }\n \n pub trait HasParamEnv<'tcx> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n }\n \n-impl<'a, 'gcx, 'tcx> HasDataLayout for TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasDataLayout for TyCtxt<'tcx, 'gcx, 'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.data_layout\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n+impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'tcx, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'gcx, 'gcx> {\n         self.global_tcx()\n     }\n }\n@@ -1761,7 +1759,7 @@ impl<'tcx, T: HasDataLayout> HasDataLayout for LayoutCx<'tcx, T> {\n }\n \n impl<'gcx, 'tcx, T: HasTyCtxt<'gcx>> HasTyCtxt<'gcx> for LayoutCx<'tcx, T> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'gcx, 'gcx> {\n         self.tcx.tcx()\n     }\n }\n@@ -1798,7 +1796,7 @@ impl<T, E> MaybeResult<T> for Result<T, E> {\n \n pub type TyLayout<'tcx> = ::rustc_target::abi::TyLayout<'tcx, Ty<'tcx>>;\n \n-impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx, 'tcx, 'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -1825,7 +1823,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'a, 'tcx, 'tcx>> {\n+impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx, 'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -1857,7 +1855,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'a, 'tcx, 'tcx>>\n }\n \n // Helper (inherent) `layout_of` methods to avoid pushing `LayoutCx` to users.\n-impl TyCtxt<'a, 'tcx, '_> {\n+impl TyCtxt<'_, 'tcx, '_> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n@@ -1871,7 +1869,7 @@ impl TyCtxt<'a, 'tcx, '_> {\n     }\n }\n \n-impl ty::query::TyCtxtAt<'a, 'tcx, '_> {\n+impl ty::query::TyCtxtAt<'tcx, '_> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n@@ -2191,7 +2189,7 @@ struct Niche {\n impl Niche {\n     fn reserve<'a, 'tcx>(\n         &self,\n-        cx: &LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>>,\n+        cx: &LayoutCx<'tcx, TyCtxt<'tcx, 'tcx, 'tcx>>,\n         count: u128,\n     ) -> Option<(u128, Scalar)> {\n         if count > self.available {\n@@ -2207,7 +2205,7 @@ impl Niche {\n     }\n }\n \n-impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx, 'tcx>> {\n     /// Find the offset of a niche leaf field, starting from\n     /// the given type and recursing through aggregates.\n     // FIXME(eddyb) traverse already optimized enums."}, {"sha": "687de97f4ceafeb744d9f7a4db1b3ee8edec24f0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -213,7 +213,7 @@ impl AssocItem {\n         }\n     }\n \n-    pub fn signature<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+    pub fn signature<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> String {\n         match self.kind {\n             ty::AssocKind::Method => {\n                 // We skip the binder here because the binder would deanonymize all\n@@ -259,7 +259,7 @@ pub trait DefIdTree: Copy {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'tcx, 'gcx, 'tcx> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         self.def_key(id).parent.map(|index| DefId { index: index, ..id })\n     }\n@@ -934,7 +934,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n         own_counts\n     }\n \n-    pub fn requires_monomorphization(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    pub fn requires_monomorphization(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> bool {\n         if self.own_requires_monomorphization() {\n             return true;\n         }\n@@ -959,7 +959,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n \n     pub fn region_param(&'tcx self,\n                         param: &EarlyBoundRegion,\n-                        tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                        tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                         -> &'tcx GenericParamDef\n     {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n@@ -977,7 +977,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n     /// Returns the `GenericParamDef` associated with this `ParamTy`.\n     pub fn type_param(&'tcx self,\n                       param: &ParamTy,\n-                      tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                      tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                       -> &'tcx GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n@@ -994,7 +994,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n     /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n     pub fn const_param(&'tcx self,\n                        param: &ParamConst,\n-                       tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                       tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                        -> &GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n@@ -1020,21 +1020,21 @@ impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n \n impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n-    pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n+    pub fn instantiate(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n         self.instantiate_into(tcx, &mut instantiated, substs);\n         instantiated\n     }\n \n-    pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n+    pub fn instantiate_own(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n                            -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n             predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n         }\n     }\n \n-    fn instantiate_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn instantiate_into(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                         instantiated: &mut InstantiatedPredicates<'tcx>,\n                         substs: SubstsRef<'tcx>) {\n         if let Some(def_id) = self.parent {\n@@ -1045,22 +1045,22 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         );\n     }\n \n-    pub fn instantiate_identity(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+    pub fn instantiate_identity(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                                 -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n         self.instantiate_identity_into(tcx, &mut instantiated);\n         instantiated\n     }\n \n-    fn instantiate_identity_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn instantiate_identity_into(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                  instantiated: &mut InstantiatedPredicates<'tcx>) {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n         }\n         instantiated.predicates.extend(self.predicates.iter().map(|&(p, _)| p))\n     }\n \n-    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n     {\n@@ -1134,7 +1134,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions. See\n     /// lengthy comment below for details.\n-    pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn subst_supertrait(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                             trait_ref: &ty::PolyTraitRef<'tcx>)\n                             -> ty::Predicate<'tcx>\n     {\n@@ -1856,7 +1856,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n     /// remove this hack and use the constructor `DefId` everywhere.\n     pub fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         ident: Ident,\n         variant_did: Option<DefId>,\n         ctor_def_id: Option<DefId>,\n@@ -2143,7 +2143,7 @@ impl ReprOptions {\n \n }\n \n-impl<'a, 'gcx, 'tcx> AdtDef {\n+impl<'gcx, 'tcx> AdtDef {\n     /// Creates a new `AdtDef`.\n     fn new(\n         tcx: TyCtxt<'_, '_, '_>,\n@@ -2286,7 +2286,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     /// Returns `true` if this type has a destructor.\n-    pub fn has_dtor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    pub fn has_dtor(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> bool {\n         self.destructor(tcx).is_some()\n     }\n \n@@ -2297,7 +2297,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx GenericPredicates<'gcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> &'tcx GenericPredicates<'gcx> {\n         tcx.predicates_of(self.did)\n     }\n \n@@ -2351,7 +2351,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     #[inline]\n     pub fn eval_explicit_discr(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         expr_did: DefId,\n     ) -> Option<Discr<'tcx>> {\n         let param_env = ParamEnv::empty();\n@@ -2397,9 +2397,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     #[inline]\n     pub fn discriminants(\n-        &'a self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> {\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<Discr<'tcx>>;\n@@ -2428,7 +2428,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// assuming there are no constant-evaluation errors there.\n     #[inline]\n     pub fn discriminant_for_variant(&self,\n-                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                     variant_index: VariantIdx)\n                                     -> Discr<'tcx> {\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n@@ -2465,7 +2465,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         (expr_did, variant_index.as_u32() - explicit_index)\n     }\n \n-    pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {\n+    pub fn destructor(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Destructor> {\n         tcx.adt_destructor(self.did)\n     }\n \n@@ -2479,12 +2479,12 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer (e.g., issue #31299).\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n \n     fn sized_constraint_for_ty(&self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                ty: Ty<'tcx>)\n                                -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n@@ -2564,7 +2564,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n }\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n-    pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n     }\n }\n@@ -2590,7 +2590,7 @@ impl<'a, 'tcx> ClosureKind {\n     // This is the initial value used when doing upvar inference.\n     pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n \n-    pub fn trait_did(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefId {\n+    pub fn trait_did(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> DefId {\n         match *self {\n             ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n             ClosureKind::FnMut => {\n@@ -2618,7 +2618,7 @@ impl<'a, 'tcx> ClosureKind {\n \n     /// Returns the representative scalar type for this closure kind.\n     /// See `TyS::to_opt_closure_kind` for more details.\n-    pub fn to_ty(self, tcx: TyCtxt<'_, '_, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx, '_, 'tcx>) -> Ty<'tcx> {\n         match self {\n             ty::ClosureKind::Fn => tcx.types.i8,\n             ty::ClosureKind::FnMut => tcx.types.i16,\n@@ -2755,7 +2755,7 @@ pub enum ImplOverlapKind {\n     Issue33140\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n         self.typeck_tables_of(self.hir().body_owner_def_id(body))\n     }\n@@ -2765,7 +2765,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n     pub fn body_owners(\n         self,\n-    ) -> impl Iterator<Item = DefId> + Captures<'tcx> + Captures<'gcx> + 'a {\n+    ) -> impl Iterator<Item = DefId> + Captures<'gcx> + 'tcx {\n         self.hir().krate()\n                   .body_ids\n                   .iter()\n@@ -2892,7 +2892,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn associated_items(\n         self,\n         def_id: DefId,\n-    ) -> AssocItemsIterator<'a, 'gcx, 'tcx> {\n+    ) -> AssocItemsIterator<'gcx, 'tcx> {\n         // Ideally, we would use `-> impl Iterator` here, but it falls\n         // afoul of the conservative \"capture [restrictions]\" we put\n         // in place, so we use a hand-written iterator.\n@@ -3115,13 +3115,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct AssocItemsIterator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct AssocItemsIterator<'gcx, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     def_ids: &'gcx [DefId],\n     next_index: usize,\n }\n \n-impl Iterator for AssocItemsIterator<'_, '_, '_> {\n+impl Iterator for AssocItemsIterator<'_, '_> {\n     type Item = AssocItem;\n \n     fn next(&mut self) -> Option<AssocItem> {\n@@ -3131,7 +3131,7 @@ impl Iterator for AssocItemsIterator<'_, '_, '_> {\n     }\n }\n \n-fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> AssocItem {\n+fn associated_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> AssocItem {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n@@ -3176,7 +3176,7 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n ///       such.\n ///     - a Error, if a type contained itself. The representability\n ///       check should catch this case.\n-fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                   def_id: DefId)\n                                   -> AdtSizedConstraint<'tcx> {\n     let def = tcx.adt_def(def_id);\n@@ -3192,7 +3192,7 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     AdtSizedConstraint(result)\n }\n \n-fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                      def_id: DefId)\n                                      -> &'tcx [DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -3217,14 +3217,14 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn def_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Span {\n+fn def_span<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> Span {\n     tcx.hir().span_if_local(def_id).unwrap()\n }\n \n /// If the given `DefId` describes an item belonging to a trait,\n /// returns the `DefId` of the trait that the trait item belongs to;\n /// otherwise, returns `None`.\n-fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n+fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     tcx.opt_associated_item(def_id)\n         .and_then(|associated_item| {\n             match associated_item.container {\n@@ -3247,7 +3247,7 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefI\n }\n \n /// See `ParamEnv` struct definition for details.\n-fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn param_env<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                        def_id: DefId)\n                        -> ParamEnv<'tcx>\n {\n@@ -3285,26 +3285,26 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n \n-fn crate_disambiguator<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn crate_disambiguator<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                  crate_num: CrateNum) -> CrateDisambiguator {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.sess.local_crate_disambiguator()\n }\n \n-fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                  crate_num: CrateNum) -> Symbol {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.crate_name.clone()\n }\n \n-fn crate_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn crate_hash<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                         crate_num: CrateNum)\n                         -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.hir().crate_hash\n }\n \n-fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                         instance_def: InstanceDef<'tcx>)\n                                         -> usize {\n     match instance_def {\n@@ -3321,7 +3321,7 @@ fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n /// See [`ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn issue33140_self_ty<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 def_id: DefId)\n                                 -> Option<Ty<'tcx>>\n {"}, {"sha": "772886ea21cdc601eb42dc2a388e0fa5e4905f2b", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -45,7 +45,7 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn push_outlives_components(&self, ty0: Ty<'tcx>,"}, {"sha": "9954160396c734d3d4a19aa0296a9caa5a61282c", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -37,7 +37,7 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     type DynExistential;\n     type Const;\n \n-    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+    fn tcx(&'a self) -> TyCtxt<'tcx, 'gcx, 'tcx>;\n \n     fn print_def_path(\n         self,"}, {"sha": "b429539658ff243d5ab3aedb2c30e82bdce9c119", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -16,15 +16,15 @@ use syntax::ast;\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n-pub struct DefPathBasedNames<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct DefPathBasedNames<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     omit_disambiguators: bool,\n     omit_local_crate_name: bool,\n }\n \n-impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n+impl DefPathBasedNames<'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         omit_disambiguators: bool,\n         omit_local_crate_name: bool,\n     ) -> Self {"}, {"sha": "d688202381a5dacf0f34e43b7327566acab371bf", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -934,7 +934,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n pub struct FmtPrinter<'a, 'gcx, 'tcx, F>(Box<FmtPrinterData<'a, 'gcx, 'tcx, F>>);\n \n pub struct FmtPrinterData<'a, 'gcx, 'tcx, F> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     fmt: F,\n \n     empty_path: bool,\n@@ -963,7 +963,7 @@ impl<F> DerefMut for FmtPrinter<'_, '_, '_, F> {\n }\n \n impl<F> FmtPrinter<'a, 'gcx, 'tcx, F> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, fmt: F, ns: Namespace) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>, fmt: F, ns: Namespace) -> Self {\n         FmtPrinter(Box::new(FmtPrinterData {\n             tcx,\n             fmt,\n@@ -1025,7 +1025,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx(&'a self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "3e2bc7308ffbfea123206905432521751e1bef3d", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -50,11 +50,11 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _: Self::Key) -> bool {\n+    fn cache_on_disk(_: TyCtxt<'tcx, 'tcx, 'tcx>, _: Self::Key) -> bool {\n         false\n     }\n \n-    fn try_load_from_disk(_: TyCtxt<'_, 'tcx, 'tcx>,\n+    fn try_load_from_disk(_: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _: SerializedDepNodeIndex)\n                           -> Option<Self::Value> {\n         bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n@@ -82,12 +82,12 @@ macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$tcx:tt, $key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {\n             #[inline]\n-            fn cache_on_disk($tcx: TyCtxt<'_, 'tcx, 'tcx>, $key: Self::Key) -> bool {\n+            fn cache_on_disk($tcx: TyCtxt<'tcx, 'tcx, 'tcx>, $key: Self::Key) -> bool {\n                 $cond\n             }\n \n             #[inline]\n-            fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+            fn try_load_from_disk<'a>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                       id: SerializedDepNodeIndex)\n                                       -> Option<Self::Value> {\n                 tcx.queries.on_disk_cache.try_load_query_result(tcx, id)"}, {"sha": "a595f22bfb32339c3af325ab2a64e10ceedb6439", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> QueryJob<'tcx> {\n     #[cfg(parallel_compiler)]\n     pub(super) fn r#await<'lcx>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        tcx: TyCtxt<'lcx, 'tcx, 'lcx>,\n         span: Span,\n     ) -> Result<(), CycleError<'tcx>> {\n         tls::with_related_context(tcx, move |icx| {\n@@ -102,7 +102,7 @@ impl<'tcx> QueryJob<'tcx> {\n     #[cfg(not(parallel_compiler))]\n     pub(super) fn find_cycle_in_stack<'lcx>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        tcx: TyCtxt<'lcx, 'tcx, 'lcx>,\n         span: Span,\n     ) -> CycleError<'tcx> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents"}, {"sha": "088e2bc33cf4d44272610bda3fe1f49c00c5e11a", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 68, "deletions": 72, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -157,7 +157,7 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n \n     pub fn serialize<'a, 'tcx, E>(&self,\n-                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                   encoder: &mut E)\n                                   -> Result<(), E::Error>\n         where E: ty_codec::TyEncoder\n@@ -327,7 +327,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n     /// Loads a diagnostic emitted during the previous compilation session.\n     pub fn load_diagnostics<'a, 'tcx>(&self,\n-                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                       dep_node_index: SerializedDepNodeIndex)\n                                       -> Vec<Diagnostic> {\n         let diagnostics: Option<EncodedDiagnostics> = self.load_indexed(\n@@ -355,7 +355,7 @@ impl<'sess> OnDiskCache<'sess> {\n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(&self,\n-                                          tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                           dep_node_index: SerializedDepNodeIndex)\n                                           -> Option<T>\n         where T: Decodable\n@@ -383,7 +383,7 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n \n     fn load_indexed<'tcx, T>(&self,\n-                             tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                             tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              dep_node_index: SerializedDepNodeIndex,\n                              index: &FxHashMap<SerializedDepNodeIndex,\n                                                AbsoluteBytePos>,\n@@ -457,18 +457,18 @@ impl<'sess> OnDiskCache<'sess> {\n /// A decoder that can read the incr. comp. cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and\n /// eventually will also handle things that contain `Ty` instances.\n-struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    opaque: opaque::Decoder<'x>,\n-    source_map: &'x SourceMap,\n-    cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'x Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n-    file_index_to_file: &'x Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n-    file_index_to_stable_id: &'x FxHashMap<SourceFileIndex, StableSourceFileId>,\n-    alloc_decoding_session: AllocDecodingSession<'x>,\n+struct CacheDecoder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+    opaque: opaque::Decoder<'a>,\n+    source_map: &'a SourceMap,\n+    cnum_map: &'a IndexVec<CrateNum, Option<CrateNum>>,\n+    synthetic_expansion_infos: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n+    file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, StableSourceFileId>,\n+    alloc_decoding_session: AllocDecodingSession<'a>,\n }\n \n-impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n     fn file_index_to_file(&self, index: SourceFileIndex) -> Lrc<SourceFile> {\n         let CacheDecoder {\n             ref file_index_to_file,\n@@ -489,13 +489,13 @@ trait DecoderWithPosition: Decoder {\n     fn position(&self) -> usize;\n }\n \n-impl<'enc> DecoderWithPosition for opaque::Decoder<'enc> {\n+impl<'a> DecoderWithPosition for opaque::Decoder<'a> {\n     fn position(&self) -> usize {\n         self.position()\n     }\n }\n \n-impl<'a, 'tcx, 'x> DecoderWithPosition for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n     fn position(&self) -> usize {\n         self.opaque.position()\n     }\n@@ -525,10 +525,9 @@ fn decode_tagged<'a, 'tcx, D, T, V>(decoder: &mut D,\n }\n \n \n-impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx, 'x> {\n-\n+impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -584,16 +583,16 @@ impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx,\n     }\n }\n \n-implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n+implement_ty_decoder!( CacheDecoder<'a, 'tcx> );\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n         let alloc_decoding_session = self.alloc_decoding_session;\n         alloc_decoding_session.decode_alloc_id(self)\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n         let tag: u8 = Decodable::decode(self)?;\n \n@@ -656,7 +655,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n // DefIndex that is not contained in a DefId. Such a case would be problematic\n // because we would not know how to transform the DefIndex to the current\n // context.\n-impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n         bug!(\"Trying to decode DefIndex outside the context of a DefId\")\n     }\n@@ -665,7 +664,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n // Both the CrateNum and the DefIndex of a DefId can change in between two\n // compilation sessions. We use the DefPathHash, which is stable across\n // sessions, to map the old DefId to the new one.\n-impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n         // Load the DefPathHash which is was we encoded the DefId as.\n@@ -676,14 +675,14 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n         Ok(LocalDefId::from_def_id(DefId::decode(self)?))\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n         // Load the DefPathHash which is was we encoded the DefIndex as.\n         let def_path_hash = DefPathHash::decode(self)?;\n@@ -710,22 +709,22 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx, 'x>\n \n // NodeIds are not stable across compilation sessions, so we store them in their\n // HirId representation. This allows use to map them to the current NodeId.\n-impl<'a, 'tcx, 'x> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n         let hir_id = hir::HirId::decode(self)?;\n         Ok(self.tcx().hir().hir_to_node_id(hir_id))\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n         Fingerprint::decode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'tcx, 'x, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n-for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n+for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {\n         let discr = u8::decode(self)?;\n@@ -745,12 +744,9 @@ for CacheDecoder<'a, 'tcx, 'x> {\n \n //- ENCODING -------------------------------------------------------------------\n \n-struct CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder,\n-             'tcx: 'a,\n-{\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    encoder: &'enc mut E,\n+struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+    encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n     expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n@@ -760,8 +756,8 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n }\n \n-impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -787,8 +783,8 @@ impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n@@ -806,8 +802,8 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n \n@@ -862,26 +858,26 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     #[inline]\n     fn position(&self) -> usize {\n         self.encoder.position()\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n         self.emit_u32(cnum.as_u32())\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     #[inline]\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n@@ -890,9 +886,9 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'enc, 'a,\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n-    for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n+    for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n@@ -903,8 +899,8 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n@@ -921,8 +917,8 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'a\n }\n \n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n@@ -931,17 +927,17 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'enc, 'a, 'tc\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n         id.to_def_id().encode(self)\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n         bug!(\"Encoding DefIndex without context.\")\n@@ -950,8 +946,8 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'enc, 'a,\n \n // NodeIds are not stable across compilation sessions, so we store them in their\n // HirId representation. This allows use to map them to the current NodeId.\n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     #[inline]\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n@@ -960,17 +956,17 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 't\n     }\n }\n \n-impl<'enc, 'a, 'tcx> SpecializedEncoder<Fingerprint>\n-for CacheEncoder<'enc, 'a, 'tcx, opaque::Encoder>\n+impl<'a, 'tcx> SpecializedEncoder<Fingerprint>\n+for CacheEncoder<'a, 'tcx, opaque::Encoder>\n {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.encoder)\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>>\n-for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder,\n+impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>>\n+for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder,\n           T: Encodable,\n {\n     #[inline]\n@@ -997,8 +993,8 @@ macro_rules! encoder_methods {\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> Encoder for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n+    where E: 'a + ty_codec::TyEncoder\n {\n     type Error = E::Error;\n \n@@ -1051,7 +1047,7 @@ impl SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder {\n     }\n }\n \n-impl<'enc> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'enc> {\n+impl<'a> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'a> {\n     fn specialized_decode(&mut self) -> Result<IntEncodedWithFixedSize, Self::Error> {\n         let mut value: u64 = 0;\n         let start_pos = self.position();\n@@ -1068,12 +1064,12 @@ impl<'enc> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'enc>\n     }\n }\n \n-fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                              encoder: &mut CacheEncoder<'enc, 'a, 'tcx, E>,\n+fn encode_query_results<'a, 'tcx, Q, E>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+                                              encoder: &mut CacheEncoder<'a, 'tcx, E>,\n                                               query_result_index: &mut EncodedQueryResultIndex)\n                                               -> Result<(), E::Error>\n     where Q: super::config::QueryDescription<'tcx>,\n-          E: 'enc + TyEncoder,\n+          E: 'a + TyEncoder,\n           Q::Value: Encodable,\n {\n     let desc = &format!(\"encode_query_results for {}\","}, {"sha": "d2ad8861def174da0d55a1aa6df07aec7d33ac0e", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -247,7 +247,7 @@ pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     Cycle(D::Value),\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     /// Executes a job by changing the ImplicitCtxt to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n@@ -259,7 +259,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         compute: F)\n     -> R\n     where\n-        F: for<'b, 'lcx> FnOnce(TyCtxt<'b, 'gcx, 'lcx>) -> R\n+        F: for<'b, 'lcx> FnOnce(TyCtxt<'lcx, 'gcx, 'lcx>) -> R\n     {\n         // The TyCtxt stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'gcx lifetimes\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub(super) fn report_cycle(\n         self,\n         CycleError { usage, cycle: stack }: CycleError<'gcx>\n-    ) -> DiagnosticBuilder<'a>\n+    ) -> DiagnosticBuilder<'tcx>\n     {\n         assert!(!stack.is_empty());\n \n@@ -996,11 +996,11 @@ macro_rules! define_queries_inner {\n         })*\n \n         #[derive(Copy, Clone)]\n-        pub struct TyCtxtEnsure<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        pub struct TyCtxtEnsure<'gcx, 'tcx> {\n+            pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         }\n \n-        impl<'a, $tcx, 'lcx> TyCtxtEnsure<'a, $tcx, 'lcx> {\n+        impl TyCtxtEnsure<$tcx, 'lcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: $K) {\n@@ -1009,24 +1009,24 @@ macro_rules! define_queries_inner {\n         }\n \n         #[derive(Copy, Clone)]\n-        pub struct TyCtxtAt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        pub struct TyCtxtAt<'gcx, 'tcx> {\n+            pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n             pub span: Span,\n         }\n \n-        impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n-            type Target = TyCtxt<'a, 'gcx, 'tcx>;\n+        impl Deref for TyCtxtAt<'gcx, 'tcx> {\n+            type Target = TyCtxt<'tcx, 'gcx, 'tcx>;\n             #[inline(always)]\n             fn deref(&self) -> &Self::Target {\n                 &self.tcx\n             }\n         }\n \n-        impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n+        impl TyCtxt<'lcx, $tcx, 'lcx> {\n             /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n             /// are executed instead of just returing their results.\n             #[inline(always)]\n-            pub fn ensure(self) -> TyCtxtEnsure<'a, $tcx, 'lcx> {\n+            pub fn ensure(self) -> TyCtxtEnsure<$tcx, 'lcx> {\n                 TyCtxtEnsure {\n                     tcx: self,\n                 }\n@@ -1035,7 +1035,7 @@ macro_rules! define_queries_inner {\n             /// Returns a transparent wrapper for `TyCtxt` which uses\n             /// `span` as the location of queries performed through it.\n             #[inline(always)]\n-            pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n+            pub fn at(self, span: Span) -> TyCtxtAt<$tcx, 'lcx> {\n                 TyCtxtAt {\n                     tcx: self,\n                     span\n@@ -1049,7 +1049,7 @@ macro_rules! define_queries_inner {\n             })*\n         }\n \n-        impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n+        impl TyCtxtAt<$tcx, 'lcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n@@ -1090,12 +1090,12 @@ macro_rules! define_provider_struct {\n     (tcx: $tcx:tt,\n      input: ($(([$($modifiers:tt)*] [$name:ident] [$K:ty] [$R:ty]))*)) => {\n         pub struct Providers<$tcx> {\n-            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n+            $(pub $name: fn(TyCtxt<$tcx, $tcx, $tcx>, $K) -> $R,)*\n         }\n \n         impl<$tcx> Default for Providers<$tcx> {\n             fn default() -> Self {\n-                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n+                $(fn $name<$tcx>(_: TyCtxt<$tcx, $tcx, $tcx>, key: $K) -> $R {\n                     bug!(\"tcx.{}({:?}) unsupported by its crate\",\n                          stringify!($name), key);\n                 })*\n@@ -1149,7 +1149,7 @@ macro_rules! define_provider_struct {\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below.\n pub fn force_from_dep_node<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     dep_node: &DepNode\n ) -> bool {\n     use crate::dep_graph::RecoverKey;"}, {"sha": "66a6c52da3816bb2bc9acbe030891e9ea223d3ef", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -4,36 +4,36 @@ use crate::ty::util::NeedsDrop;\n use syntax::symbol::InternedString;\n \n pub(super) trait Value<'tcx>: Sized {\n-    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Self;\n }\n \n impl<'tcx, T> Value<'tcx> for T {\n-    default fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+    default fn from_cycle_error<'a>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> T {\n         tcx.sess.abort_if_errors();\n         bug!(\"Value::from_cycle_error called without errors\");\n     }\n }\n \n impl<'tcx> Value<'tcx> for Ty<'tcx> {\n-    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Ty<'tcx> {\n         tcx.types.err\n     }\n }\n \n impl<'tcx> Value<'tcx> for ty::SymbolName {\n-    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error<'a>(_: TyCtxt<'tcx, 'tcx, 'tcx>) -> Self {\n         ty::SymbolName { name: InternedString::intern(\"<error>\") }\n     }\n }\n \n impl<'tcx> Value<'tcx> for NeedsDrop {\n-    fn from_cycle_error(_: TyCtxt<'_, 'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error(_: TyCtxt<'tcx, 'tcx, 'tcx>) -> Self {\n         NeedsDrop(false)\n     }\n }\n \n impl<'tcx> Value<'tcx> for AdtSizedConstraint<'tcx> {\n-    fn from_cycle_error(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Self {\n         AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err]))\n     }\n }"}, {"sha": "288e203902a1470a8f56e09cad5a4f1a5349c0fc", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -22,8 +22,8 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n-pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+pub trait TypeRelation<'gcx: 'tcx, 'tcx> : Sized {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx>;\n \n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n@@ -96,7 +96,7 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self)\n                            -> RelateResult<'tcx, Self>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a;\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a;\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -107,7 +107,7 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n                            a: &ty::TypeAndMut<'tcx>,\n                            b: &ty::TypeAndMut<'tcx>)\n                            -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n@@ -132,7 +132,7 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                         a_subst: SubstsRef<'tcx>,\n                                         b_subst: SubstsRef<'tcx>)\n                                         -> RelateResult<'tcx, SubstsRef<'tcx>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n \n@@ -149,7 +149,7 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                            a: &ty::FnSig<'tcx>,\n                            b: &ty::FnSig<'tcx>)\n                            -> RelateResult<'tcx, ty::FnSig<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let tcx = relation.tcx();\n \n@@ -189,7 +189,7 @@ impl<'tcx> Relate<'tcx> for ast::Unsafety {\n                            a: &ast::Unsafety,\n                            b: &ast::Unsafety)\n                            -> RelateResult<'tcx, ast::Unsafety>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a != b {\n             Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n@@ -204,7 +204,7 @@ impl<'tcx> Relate<'tcx> for abi::Abi {\n                            a: &abi::Abi,\n                            b: &abi::Abi)\n                            -> RelateResult<'tcx, abi::Abi>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a == b {\n             Ok(*a)\n@@ -219,7 +219,7 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n                            a: &ty::ProjectionTy<'tcx>,\n                            b: &ty::ProjectionTy<'tcx>)\n                            -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(\n@@ -239,7 +239,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                            a: &ty::ExistentialProjection<'tcx>,\n                            b: &ty::ExistentialProjection<'tcx>)\n                            -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(\n@@ -261,7 +261,7 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n                            a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n                            b: &Vec<ty::PolyExistentialProjection<'tcx>>)\n                            -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // To be compatible, `a` and `b` must be for precisely the\n         // same set of traits and item names. We always require that\n@@ -284,7 +284,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n                            a: &ty::TraitRef<'tcx>,\n                            b: &ty::TraitRef<'tcx>)\n                            -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -301,7 +301,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n                            a: &ty::ExistentialTraitRef<'tcx>,\n                            b: &ty::ExistentialTraitRef<'tcx>)\n                            -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -327,7 +327,7 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n                            a: &GeneratorWitness<'tcx>,\n                            b: &GeneratorWitness<'tcx>)\n                            -> RelateResult<'tcx, GeneratorWitness<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n@@ -341,7 +341,7 @@ impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n                            a: &Ty<'tcx>,\n                            b: &Ty<'tcx>)\n                            -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.tys(a, b)\n     }\n@@ -354,7 +354,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                            a: Ty<'tcx>,\n                                            b: Ty<'tcx>)\n                                            -> RelateResult<'tcx, Ty<'tcx>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n     debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n@@ -556,7 +556,7 @@ pub fn super_relate_consts<'a, 'gcx, 'tcx, R>(\n     b: &'tcx ty::Const<'tcx>\n ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n where\n-    R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n \n@@ -636,7 +636,7 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n                            a: &Self,\n                            b: &Self)\n         -> RelateResult<'tcx, Self>\n-            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n+            where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n \n         if a.len() != b.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n@@ -661,7 +661,7 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n                            a: &ty::ClosureSubsts<'tcx>,\n                            b: &ty::ClosureSubsts<'tcx>)\n                            -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::ClosureSubsts { substs })\n@@ -673,7 +673,7 @@ impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n                            a: &ty::GeneratorSubsts<'tcx>,\n                            b: &ty::GeneratorSubsts<'tcx>)\n                            -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::GeneratorSubsts { substs })\n@@ -685,7 +685,7 @@ impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n                            a: &SubstsRef<'tcx>,\n                            b: &SubstsRef<'tcx>)\n                            -> RelateResult<'tcx, SubstsRef<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relate_substs(relation, None, a, b)\n     }\n@@ -696,7 +696,7 @@ impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n                            a: &ty::Region<'tcx>,\n                            b: &ty::Region<'tcx>)\n                            -> RelateResult<'tcx, ty::Region<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.regions(*a, *b)\n     }\n@@ -707,7 +707,7 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n                            a: &&'tcx ty::Const<'tcx>,\n                            b: &&'tcx ty::Const<'tcx>)\n                            -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.consts(*a, *b)\n     }\n@@ -718,7 +718,7 @@ impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n                            a: &ty::Binder<T>,\n                            b: &ty::Binder<T>)\n                            -> RelateResult<'tcx, ty::Binder<T>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.binders(a, b)\n     }\n@@ -729,7 +729,7 @@ impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n                            a: &Rc<T>,\n                            b: &Rc<T>)\n                            -> RelateResult<'tcx, Rc<T>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let a: &T = a;\n         let b: &T = b;\n@@ -742,7 +742,7 @@ impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n                            a: &Box<T>,\n                            b: &Box<T>)\n                            -> RelateResult<'tcx, Box<T>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let a: &T = a;\n         let b: &T = b;\n@@ -757,7 +757,7 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n         b: &Kind<'tcx>\n     ) -> RelateResult<'tcx, Kind<'tcx>>\n     where\n-        R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a,\n+        R: TypeRelation<'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a,\n     {\n         match (a.unpack(), b.unpack()) {\n             (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n@@ -788,7 +788,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n         a: &ty::TraitPredicate<'tcx>,\n         b: &ty::TraitPredicate<'tcx>\n     ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         Ok(ty::TraitPredicate {\n             trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)?,\n@@ -802,7 +802,7 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n         a: &ty::ProjectionPredicate<'tcx>,\n         b: &ty::ProjectionPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         Ok(ty::ProjectionPredicate {\n             projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n@@ -817,7 +817,7 @@ impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n         a: &traits::WhereClause<'tcx>,\n         b: &traits::WhereClause<'tcx>\n     ) -> RelateResult<'tcx, traits::WhereClause<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         use crate::traits::WhereClause::*;\n         match (a, b) {\n@@ -854,7 +854,7 @@ impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n         a: &traits::WellFormed<'tcx>,\n         b: &traits::WellFormed<'tcx>\n     ) -> RelateResult<'tcx, traits::WellFormed<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         use crate::traits::WellFormed::*;\n         match (a, b) {\n@@ -871,7 +871,7 @@ impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n         a: &traits::FromEnv<'tcx>,\n         b: &traits::FromEnv<'tcx>\n     ) -> RelateResult<'tcx, traits::FromEnv<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         use crate::traits::FromEnv::*;\n         match (a, b) {\n@@ -888,7 +888,7 @@ impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n         a: &traits::DomainGoal<'tcx>,\n         b: &traits::DomainGoal<'tcx>\n     ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         use crate::traits::DomainGoal::*;\n         match (a, b) {\n@@ -911,7 +911,7 @@ impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n         a: &traits::Goal<'tcx>,\n         b: &traits::Goal<'tcx>\n     ) -> RelateResult<'tcx, traits::Goal<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         use crate::traits::GoalKind::*;\n         match (a, b) {\n@@ -957,7 +957,7 @@ impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n         a: &traits::Goals<'tcx>,\n         b: &traits::Goals<'tcx>\n     ) -> RelateResult<'tcx, traits::Goals<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         if a.len() != b.len() {\n             return Err(TypeError::Mismatch);\n@@ -975,7 +975,7 @@ impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n         a: &traits::Clause<'tcx>,\n         b: &traits::Clause<'tcx>\n     ) -> RelateResult<'tcx, traits::Clause<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         use crate::traits::Clause::*;\n         match (a, b) {\n@@ -1000,7 +1000,7 @@ impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n         a: &traits::Clauses<'tcx>,\n         b: &traits::Clauses<'tcx>\n     ) -> RelateResult<'tcx, traits::Clauses<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         if a.len() != b.len() {\n             return Err(TypeError::Mismatch);\n@@ -1018,7 +1018,7 @@ impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n         a: &traits::ProgramClause<'tcx>,\n         b: &traits::ProgramClause<'tcx>\n     ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         Ok(traits::ProgramClause {\n             goal: relation.relate(&a.goal, &b.goal)?,\n@@ -1034,7 +1034,7 @@ impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n         a: &traits::Environment<'tcx>,\n         b: &traits::Environment<'tcx>\n     ) -> RelateResult<'tcx, traits::Environment<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         Ok(traits::Environment {\n             clauses: relation.relate(&a.clauses, &b.clauses)?,\n@@ -1050,7 +1050,7 @@ impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n         a: &traits::InEnvironment<'tcx, G>,\n         b: &traits::InEnvironment<'tcx, G>\n     ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+        where R: TypeRelation<'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n     {\n         Ok(traits::InEnvironment {\n             environment: relation.relate(&a.environment, &b.environment)?,\n@@ -1066,7 +1066,7 @@ pub fn expected_found<'a, 'gcx, 'tcx, R, T>(relation: &mut R,\n                                             a: &T,\n                                             b: &T)\n                                             -> ExpectedFound<T>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, T: Clone, 'gcx: 'a+'tcx, 'tcx: 'a\n+    where R: TypeRelation<'gcx, 'tcx>, T: Clone, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n }"}, {"sha": "ab090558167c3addeb74682c6aa51e0e85b560fd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -337,14 +337,14 @@ CloneTypeFoldableAndLiftImpls! {\n // FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n     }\n }\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C) {\n     type Lifted = (A::Lifted, B::Lifted, C::Lifted);\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| {\n             tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c)))\n         })\n@@ -353,7 +353,7 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C)\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             Some(ref x) => tcx.lift(x).map(Some),\n             None => Some(None)\n@@ -363,7 +363,7 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n \n impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n     type Lifted = Result<T::Lifted, E::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             Ok(ref x) => tcx.lift(x).map(Ok),\n             Err(ref e) => tcx.lift(e).map(Err)\n@@ -373,14 +373,14 @@ impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n     type Lifted = Box<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&**self).map(Box::new)\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         // type annotation needed to inform `projection_must_outlive`\n         let mut result : Vec<<T as Lift<'tcx>>::Lifted>\n             = Vec::with_capacity(self.len());\n@@ -397,14 +397,14 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self[..])\n     }\n }\n \n impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n     type Lifted = IndexVec<I, T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         self.iter()\n             .map(|e| tcx.lift(e))\n             .collect()\n@@ -413,7 +413,7 @@ impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n     type Lifted = ty::TraitRef<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| ty::TraitRef {\n             def_id: self.def_id,\n             substs,\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n     type Lifted = ty::ExistentialTraitRef<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| ty::ExistentialTraitRef {\n             def_id: self.def_id,\n             substs,\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n     type Lifted = ty::ExistentialPredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::ExistentialPredicate::Trait(x) => {\n                 tcx.lift(x).map(ty::ExistentialPredicate::Trait)\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                              -> Option<ty::TraitPredicate<'tcx>> {\n         tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n             trait_ref,\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     type Lifted = ty::SubtypePredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                              -> Option<ty::SubtypePredicate<'tcx>> {\n         tcx.lift(&(self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n             a_is_expected: self.a_is_expected,\n@@ -472,14 +472,14 @@ impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n \n impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n     type Lifted = ty::ProjectionTy<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                              -> Option<ty::ProjectionTy<'tcx>> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ProjectionTy {\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                              -> Option<ty::ProjectionPredicate<'tcx>> {\n         tcx.lift(&(self.projection_ty, self.ty)).map(|(projection_ty, ty)| {\n             ty::ProjectionPredicate {\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     type Lifted = ty::ExistentialProjection<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ExistentialProjection {\n                 substs,\n@@ -518,7 +518,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n     type Lifted = ty::Predicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::Predicate::Trait(ref binder) => {\n                 tcx.lift(binder).map(ty::Predicate::Trait)\n@@ -558,14 +558,14 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(self.skip_binder()).map(ty::Binder::bind)\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     type Lifted = ty::ParamEnv<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.caller_bounds).map(|caller_bounds| {\n             ty::ParamEnv {\n                 reveal: self.reveal,\n@@ -578,7 +578,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n \n impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n     type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.param_env).and_then(|param_env| {\n             tcx.lift(&self.value).map(|value| {\n                 ty::ParamEnvAnd {\n@@ -592,7 +592,7 @@ impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ClosureSubsts { substs }\n         })\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n     type Lifted = ty::GeneratorSubsts<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::GeneratorSubsts { substs }\n         })\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.kind).and_then(|kind| {\n             tcx.lift(&self.target).map(|target| {\n                 ty::adjustment::Adjustment { kind, target }\n@@ -621,7 +621,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n     type Lifted = ty::adjustment::Adjust<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::adjustment::Adjust::NeverToAny =>\n                 Some(ty::adjustment::Adjust::NeverToAny),\n@@ -639,7 +639,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.region).map(|region| {\n             ty::adjustment::OverloadedDeref {\n                 region,\n@@ -651,7 +651,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::adjustment::AutoBorrow::Ref(r, m) => {\n                 tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n     type Lifted = ty::GenSig<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.yield_ty, self.return_ty))\n            .map(|(yield_ty, return_ty)| {\n                ty::GenSig {\n@@ -678,7 +678,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.inputs_and_output).map(|x| {\n             ty::FnSig {\n                 inputs_and_output: x,\n@@ -692,7 +692,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     type Lifted = ty::error::ExpectedFound<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.expected).and_then(|expected| {\n             tcx.lift(&self.found).map(|found| {\n                 ty::error::ExpectedFound {\n@@ -706,7 +706,7 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n     type Lifted = ty::error::TypeError<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         use crate::ty::error::TypeError::*;\n \n         Some(match *self {\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     type Lifted = ty::InstanceDef<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::InstanceDef::Item(def_id) =>\n                 Some(ty::InstanceDef::Item(def_id)),"}, {"sha": "959031c7c9fbf3e3e9903070051ab74e04836dd2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -368,7 +368,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_kind()`.\n-    pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::ClosureKind {\n+    pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> ty::ClosureKind {\n         self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n     }\n \n@@ -377,7 +377,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_sig()`.\n-    pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n+    pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         let ty = self.closure_sig_ty(def_id, tcx);\n         match ty.sty {\n             ty::FnPtr(sig) => sig,\n@@ -465,7 +465,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n+impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// Generator have not been resumed yet\n     pub const UNRESUMED: usize = 0;\n     /// Generator has returned / is completed\n@@ -479,7 +479,7 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n \n     /// The valid variant indices of this Generator.\n     #[inline]\n-    pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Range<VariantIdx> {\n+    pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Range<VariantIdx> {\n         // FIXME requires optimized MIR\n         let num_variants = tcx.generator_layout(def_id).variant_fields.len();\n         (VariantIdx::new(0)..VariantIdx::new(num_variants))\n@@ -489,7 +489,7 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// out of range.\n     #[inline]\n     pub fn discriminant_for_variant(\n-        &self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>, variant_index: VariantIdx\n+        &self, def_id: DefId, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, variant_index: VariantIdx\n     ) -> Discr<'tcx> {\n         // Generators don't support explicit discriminant values, so they are\n         // the same as the variant index.\n@@ -501,8 +501,8 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// variant indices.\n     #[inline]\n     pub fn discriminants(\n-        &'a self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>\n-    ) -> impl Iterator<Item=(VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n+        &'tcx self, def_id: DefId, tcx: TyCtxt<'tcx, 'gcx, 'tcx>\n+    ) -> impl Iterator<Item=(VariantIdx, Discr<'tcx>)> + Captures<'gcx> {\n         self.variant_range(def_id, tcx).map(move |index| {\n             (index, Discr { val: index.as_usize() as u128, ty: self.discr_ty(tcx) })\n         })\n@@ -522,7 +522,7 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n \n     /// The type of the state discriminant used in the generator type.\n     #[inline]\n-    pub fn discr_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn discr_ty(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.types.u32\n     }\n \n@@ -533,8 +533,8 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// The locals are grouped by their variant number. Note that some locals may\n     /// be repeated in multiple variants.\n     #[inline]\n-    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a>\n+    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) ->\n+        impl Iterator<Item=impl Iterator<Item=Ty<'tcx>> + Captures<'gcx>>\n     {\n         let layout = tcx.generator_layout(def_id);\n         layout.variant_fields.iter().map(move |variant| {\n@@ -547,8 +547,8 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// This is the types of the fields of a generator which are not stored in a\n     /// variant.\n     #[inline]\n-    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'a\n+    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) ->\n+        impl Iterator<Item=Ty<'tcx>>\n     {\n         self.upvar_tys(def_id, tcx)\n     }\n@@ -593,7 +593,7 @@ pub enum ExistentialPredicate<'tcx> {\n impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n     /// Compares via an ordering that will not change if modules are reordered or other changes are\n     /// made to the tree. In particular, this ordering is preserved across incremental compilations.\n-    pub fn stable_cmp(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, other: &Self) -> Ordering {\n+    pub fn stable_cmp(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, other: &Self) -> Ordering {\n         use self::ExistentialPredicate::*;\n         match (*self, *other) {\n             (Trait(_), Trait(_)) => Ordering::Equal,\n@@ -611,7 +611,7 @@ impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match *self.skip_binder() {\n@@ -744,7 +744,7 @@ impl<'tcx> TraitRef<'tcx> {\n \n     /// Returns a `TraitRef` of the form `P0: Foo<P1..Pn>` where `Pi`\n     /// are the parameters defined on trait.\n-    pub fn identity<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n+    pub fn identity<'a, 'gcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n         TraitRef {\n             def_id,\n             substs: InternalSubsts::identity_for_item(tcx, def_id),\n@@ -764,7 +764,7 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.types()\n     }\n \n-    pub fn from_method(tcx: TyCtxt<'_, '_, 'tcx>,\n+    pub fn from_method(tcx: TyCtxt<'tcx, '_, 'tcx>,\n                        trait_id: DefId,\n                        substs: SubstsRef<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n@@ -817,7 +817,7 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n         self.substs.types()\n     }\n \n-    pub fn erase_self_ty(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn erase_self_ty(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                          trait_ref: ty::TraitRef<'tcx>)\n                          -> ty::ExistentialTraitRef<'tcx> {\n         // Assert there is a Self.\n@@ -833,7 +833,7 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>  {\n         // otherwise the escaping vars would be captured by the binder\n         // debug_assert!(!self_ty.has_escaping_bound_vars());\n@@ -856,7 +856,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'_, '_, 'tcx>,\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'tcx, '_, 'tcx>,\n                         self_ty: Ty<'tcx>)\n                         -> ty::PolyTraitRef<'tcx>  {\n         self.map_bound(|trait_ref| trait_ref.with_self_ty(tcx, self_ty))\n@@ -1125,7 +1125,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         ParamTy::new(def.index, def.name)\n     }\n \n-    pub fn to_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n \n@@ -1153,7 +1153,7 @@ impl<'a, 'gcx, 'tcx> ParamConst {\n         ParamConst::new(def.index, def.name)\n     }\n \n-    pub fn to_const(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+    pub fn to_const(self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n         tcx.mk_const_param(self.index, self.name, ty)\n     }\n }\n@@ -1421,7 +1421,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n         }\n     }\n \n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                         self_ty: Ty<'tcx>)\n                         -> ty::ProjectionPredicate<'tcx>\n     {\n@@ -1439,7 +1439,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n }\n \n impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::PolyProjectionPredicate<'tcx> {\n         self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n     }\n@@ -1687,7 +1687,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// `ty.conservative_is_privately_uninhabited` implies that any value of type `ty`\n     /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n     /// size, to account for partial initialisation. See #49298 for details.)\n-    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> bool {\n         // FIXME(varkor): we can make this less conversative by substituting concrete\n         // type arguments.\n         match self.sty {\n@@ -1799,15 +1799,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             Array(ty, _) | Slice(ty) => ty,\n             Str => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn simd_type(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             Adt(def, substs) => {\n                 def.non_enum_variant().fields[0].ty(tcx, substs)\n@@ -2036,7 +2036,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n         match self.sty {\n             FnDef(def_id, substs) => {\n                 tcx.fn_sig(def_id).subst(tcx, substs)\n@@ -2084,7 +2084,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// If the type contains variants, returns the valid range of variant indices.\n     /// FIXME This requires the optimized MIR in the case of generators.\n     #[inline]\n-    pub fn variant_range(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Range<VariantIdx>> {\n+    pub fn variant_range(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Range<VariantIdx>> {\n         match self.sty {\n             TyKind::Adt(adt, _) => Some(adt.variant_range()),\n             TyKind::Generator(def_id, substs, _) => Some(substs.variant_range(def_id, tcx)),\n@@ -2098,7 +2098,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn discriminant_for_variant(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         variant_index: VariantIdx\n     ) -> Option<Discr<'tcx>> {\n         match self.sty {\n@@ -2189,7 +2189,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     ///\n     /// Returning true means the type is known to be sized. Returning\n     /// `false` means nothing -- could be sized, might not be.\n-    pub fn is_trivially_sized(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> bool {\n+    pub fn is_trivially_sized(&self, tcx: TyCtxt<'tcx, '_, 'tcx>) -> bool {\n         match self.sty {\n             ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n             ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n@@ -2240,7 +2240,7 @@ static_assert_size!(Const<'_>, 40);\n impl<'tcx> Const<'tcx> {\n     #[inline]\n     pub fn from_scalar(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         val: Scalar,\n         ty: Ty<'tcx>,\n     ) -> &'tcx Self {\n@@ -2252,7 +2252,7 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn from_bits(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         bits: u128,\n         ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n     ) -> &'tcx Self {\n@@ -2264,24 +2264,24 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+    pub fn zero_sized(tcx: TyCtxt<'tcx, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n         Self::from_scalar(tcx, Scalar::zst(), ty)\n     }\n \n     #[inline]\n-    pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> &'tcx Self {\n+    pub fn from_bool(tcx: TyCtxt<'tcx, '_, 'tcx>, v: bool) -> &'tcx Self {\n         Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n-    pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> &'tcx Self {\n+    pub fn from_usize(tcx: TyCtxt<'tcx, '_, 'tcx>, n: u64) -> &'tcx Self {\n         Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n     #[inline]\n     pub fn to_bits(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n     ) -> Option<u128> {\n         if self.ty != ty.value {"}, {"sha": "23b04cb41f9d40ae51a5cf8e5971c48be67a1860", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> Kind<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n     type Lifted = Kind<'tcx>;\n \n-    fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n             UnpackedKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n@@ -184,7 +184,7 @@ pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n-    pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n+    pub fn identity_for_item(tcx: TyCtxt<'tcx, 'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })\n@@ -195,7 +195,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n     /// variant (which has a `DefId`).\n     pub fn bound_vars_for_item(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         def_id: DefId\n     ) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n@@ -233,7 +233,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// The closures get to observe the `InternalSubsts` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n-    pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn for_item<F>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                        def_id: DefId,\n                        mut mk_kind: F)\n                        -> SubstsRef<'tcx>\n@@ -247,7 +247,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     }\n \n     pub fn extend_to<F>(&self,\n-                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                         def_id: DefId,\n                         mut mk_kind: F)\n                         -> SubstsRef<'tcx>\n@@ -261,7 +261,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     }\n \n     fn fill_item<F>(substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n-                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                     defs: &ty::Generics,\n                     mk_kind: &mut F)\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n@@ -372,15 +372,15 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// in a different item, with `target_substs` as the base for\n     /// the target impl/trait, with the source child-specific\n     /// parameters (e.g., method parameters) on top of that base.\n-    pub fn rebase_onto(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn rebase_onto(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                        source_ancestor: DefId,\n                        target_substs: SubstsRef<'tcx>)\n                        -> SubstsRef<'tcx> {\n         let defs = tcx.generics_of(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.params.len()..]).cloned())\n     }\n \n-    pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics)\n+    pub fn truncate_to(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, generics: &ty::Generics)\n                        -> SubstsRef<'tcx> {\n         tcx.mk_substs(self.iter().take(generics.count()).cloned())\n     }\n@@ -414,19 +414,19 @@ impl<'tcx> serialize::UseSpecializedDecodable for SubstsRef<'tcx> {}\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx>: Sized {\n-    fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                        substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                substs: &[Kind<'tcx>],\n                                span: Option<Span>)\n                                -> Self;\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                substs: &[Kind<'tcx>],\n                                span: Option<Span>)\n                                -> T\n@@ -445,7 +445,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n // The actual substitution engine itself is a type folder.\n \n struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     substs: &'a [Kind<'tcx>],\n \n     /// The location for which the substitution is performed, if available.\n@@ -462,7 +462,7 @@ struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.binders_passed += 1;"}, {"sha": "fc08fc46b001e745b58bafd34dbd5da31c4f7148", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -64,14 +64,14 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         }\n     }\n \n-    pub fn ancestors(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn ancestors(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                      of_impl: DefId)\n                      -> specialization_graph::Ancestors<'gcx> {\n         specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     pub fn for_each_impl<F: FnMut(DefId)>(self, def_id: DefId, mut f: F) {\n         let impls = self.trait_impls_of(def_id);\n \n@@ -148,7 +148,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n // Query provider for `trait_impls_of`.\n-pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                 trait_id: DefId)\n                                                 -> &'tcx TraitImpls {\n     let mut impls = TraitImpls::default();"}, {"sha": "7eb57466bbdcd4a4b6fbc0dfb3a3296227fc5070", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -51,10 +51,10 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n \n impl<'tcx> Discr<'tcx> {\n     /// Adds `1` to the value and wraps around if the maximum for the type is reached.\n-    pub fn wrap_incr<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    pub fn wrap_incr<'a, 'gcx>(self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Self {\n         self.checked_add(tcx, 1).0\n     }\n-    pub fn checked_add<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, n: u128) -> (Self, bool) {\n+    pub fn checked_add<'a, 'gcx>(self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, n: u128) -> (Self, bool) {\n         let (int, signed) = match self.ty.sty {\n             Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n             Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n@@ -104,14 +104,14 @@ impl<'tcx> Discr<'tcx> {\n }\n \n pub trait IntTypeExt {\n-    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n-    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Discr<'tcx>>)\n+    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>, val: Option<Discr<'tcx>>)\n                            -> Option<Discr<'tcx>>;\n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Discr<'tcx>;\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Discr<'tcx>;\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             SignedInt(ast::IntTy::I8)       => tcx.types.i8,\n             SignedInt(ast::IntTy::I16)      => tcx.types.i16,\n@@ -128,7 +128,7 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Discr<'tcx> {\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Discr<'tcx> {\n         Discr {\n             val: 0,\n             ty: self.to_ty(tcx)\n@@ -137,7 +137,7 @@ impl IntTypeExt for attr::IntType {\n \n     fn disr_incr<'a, 'tcx>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         val: Option<Discr<'tcx>>,\n     ) -> Option<Discr<'tcx>> {\n         if let Some(val) = val {\n@@ -179,7 +179,7 @@ pub enum Representability {\n \n impl<'tcx> ty::ParamEnv<'tcx> {\n     pub fn can_type_implement_copy<'a>(self,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                        self_type: Ty<'tcx>)\n                                        -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n@@ -228,7 +228,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'tcx, 'tcx, 'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'tcx, 'gcx, 'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         if let ty::Adt(def, substs) = ty.sty {\n             for field in def.all_fields() {\n@@ -624,18 +624,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ) -> Result<Ty<'tcx>, Ty<'tcx>> {\n         use crate::ty::fold::TypeFolder;\n \n-        struct OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n+        struct OpaqueTypeExpander<'gcx, 'tcx> {\n             // Contains the DefIds of the opaque types that are currently being\n             // expanded. When we expand an opaque type we insert the DefId of\n             // that type, and when we finish expanding that type we remove the\n             // its DefId.\n             seen_opaque_tys: FxHashSet<DefId>,\n             primary_def_id: DefId,\n             found_recursion: bool,\n-            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         }\n \n-        impl<'a, 'gcx, 'tcx> OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n+        impl<'gcx, 'tcx> OpaqueTypeExpander<'gcx, 'tcx> {\n             fn expand_opaque_ty(\n                 &mut self,\n                 def_id: DefId,\n@@ -658,8 +658,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n-            fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        impl<'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpaqueTypeExpander<'gcx, 'tcx> {\n+            fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n                 self.tcx\n             }\n \n@@ -696,7 +696,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// full requirements for the `Copy` trait (cc #29149) -- this\n     /// winds up being reported as an error during NLL borrow check.\n     pub fn is_copy_modulo_regions(&'tcx self,\n-                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                   param_env: ty::ParamEnv<'tcx>,\n                                   span: Span)\n                                   -> bool {\n@@ -710,7 +710,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n     pub fn is_sized(&'tcx self,\n-                    tcx_at: TyCtxtAt<'a, 'tcx, 'tcx>,\n+                    tcx_at: TyCtxtAt<'tcx, 'tcx>,\n                     param_env: ty::ParamEnv<'tcx>)-> bool\n     {\n         tcx_at.is_sized_raw(param_env.and(self))\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n     pub fn is_freeze(&'tcx self,\n-                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                      param_env: ty::ParamEnv<'tcx>,\n                      span: Span)-> bool\n     {\n@@ -739,7 +739,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n     #[inline]\n     pub fn needs_drop(&'tcx self,\n-                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                      tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                       param_env: ty::ParamEnv<'tcx>)\n                       -> bool {\n         tcx.needs_drop_raw(param_env.and(self)).0\n@@ -761,7 +761,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n     pub fn is_representable(&'tcx self,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             sp: Span)\n                             -> Representability\n     {\n@@ -779,7 +779,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         }\n \n         fn are_inner_types_recursive<'a, 'tcx>(\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n+            tcx: TyCtxt<'tcx, 'tcx, 'tcx>, sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n             ty: Ty<'tcx>)\n@@ -839,7 +839,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         // Does the type `ty` directly (without indirection through a pointer)\n         // contain any types on stack `seen`?\n         fn is_type_structurally_recursive<'a, 'tcx>(\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+            tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n@@ -860,7 +860,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         }\n \n         fn is_type_structurally_recursive_inner<'a, 'tcx>(\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+            tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                          query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                          -> bool\n {\n@@ -953,7 +953,7 @@ fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ))\n }\n \n-fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                           -> bool\n {\n@@ -969,7 +969,7 @@ fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ))\n }\n \n-fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                            query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                            -> bool\n {\n@@ -988,7 +988,7 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n #[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n-fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                             -> NeedsDrop\n {"}, {"sha": "c6cc5030212dd3dfc114042eaa0b76b10e356dca", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -509,7 +509,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>)\n     -> Vec<ty::Region<'tcx>>\n {"}, {"sha": "ef46445952ab1cad3bc20e2d3e3a88bb01f7ce7a", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -80,8 +80,8 @@ fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'\n \n struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n-    move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n+    dfcx_loans: &'a LoanDataFlow<'tcx>,\n+    move_data: &'a move_data::FlowedMoveData<'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n     movable_generator: bool,\n }\n@@ -180,8 +180,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n }\n \n pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                     dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n-                                     move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n+                                     dfcx_loans: &LoanDataFlow<'tcx>,\n+                                     move_data: &move_data::FlowedMoveData<'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      body: &hir::Body) {\n     debug!(\"check_loans(body id={})\", body.value.hir_id);\n@@ -229,7 +229,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n }\n \n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> { self.bccx.tcx }\n \n     pub fn each_issued_loan<F>(&self, node: hir::ItemLocalId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,"}, {"sha": "8654c3704326e31b47427e17248b2f08b9765e57", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -45,7 +45,7 @@ pub enum PatternSource<'tcx> {\n ///\n /// In this latter case, this function will return `PatternSource::LetDecl`\n /// with a reference to the let\n-fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n+fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n     let parent = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n "}, {"sha": "08b8894ac89e4cd24a39a2e12cda8da155e4f079", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -251,7 +251,7 @@ fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> { self.bccx.tcx }\n \n     /// Guarantees that `cmt` is assignable, or reports an error.\n     fn guarantee_assignment_valid(&mut self,"}, {"sha": "623217f37adf61e5b9cc2ba0d28fe51f7cee7555", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -51,9 +51,9 @@ pub mod move_data;\n #[derive(Clone, Copy)]\n pub struct LoanDataFlowOperator;\n \n-pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n+pub type LoanDataFlow<'tcx> = DataFlowContext<'tcx, LoanDataFlowOperator>;\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     tcx.par_body_owners(|body_owner_def_id| {\n         tcx.ensure().borrowck(body_owner_def_id);\n     });\n@@ -67,13 +67,13 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n /// Collection of conclusions determined via borrow checker analyses.\n-pub struct AnalysisData<'a, 'tcx: 'a> {\n+pub struct AnalysisData<'tcx> {\n     pub all_loans: Vec<Loan<'tcx>>,\n-    pub loans: DataFlowContext<'a, 'tcx, LoanDataFlowOperator>,\n-    pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n+    pub loans: DataFlowContext<'tcx, LoanDataFlowOperator>,\n+    pub move_data: move_data::FlowedMoveData<'tcx>,\n }\n \n-fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n+fn borrowck<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, owner_def_id: DefId)\n     -> &'tcx BorrowCheckResult\n {\n     assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n@@ -145,7 +145,7 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n                                                  force_analysis: bool,\n                                                  body_id: hir::BodyId,\n                                                  get_cfg: F)\n-                                                 -> Option<AnalysisData<'a, 'tcx>>\n+                                                 -> Option<AnalysisData<'tcx>>\n     where F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG\n {\n     // Check the body of fn items.\n@@ -193,10 +193,10 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n /// Accessor for introspective clients inspecting `AnalysisData` and\n /// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body_id: hir::BodyId,\n     cfg: &cfg::CFG)\n-    -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n+    -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>)\n {\n     let owner_id = tcx.hir().body_owner(body_id);\n     let owner_def_id = tcx.hir().local_def_id(owner_id);\n@@ -220,8 +220,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n // ----------------------------------------------------------------------\n // Type definitions\n \n-pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct BorrowckCtxt<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n \n     // tables for the current thing we are checking; set to\n     // Some in `borrowck_fn` and cleared later\n@@ -239,13 +239,13 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n }\n \n \n-impl<'a, 'tcx: 'a> BorrowckCtxt<'a, 'tcx> {\n+impl BorrowckCtxt<'_, 'tcx> {\n     fn signal_error(&self) {\n         self.signalled_any_error.set(SignalledError::SawSomeError);\n     }\n }\n \n-impl<'a, 'b, 'tcx: 'b> BorrowckErrors<'a> for &'a BorrowckCtxt<'b, 'tcx> {\n+impl BorrowckErrors<'a> for &'a BorrowckCtxt<'_, 'tcx> {\n     fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n                                                      sp: S,\n                                                      msg: &str,\n@@ -406,8 +406,8 @@ fn closure_to_block(closure_id: LocalDefId,\n     }\n }\n \n-impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n+impl LoanPath<'tcx> {\n+    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'_, 'tcx>) -> region::Scope {\n         match self.kind {\n             LpVar(hir_id) => {\n                 bccx.region_scope_tree.var_scope(hir_id.local_id)\n@@ -577,7 +577,7 @@ pub enum MovedValueUseKind {\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n-impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n+impl BorrowckCtxt<'_, 'tcx> {\n     pub fn is_subregion_of(&self,\n                            r_sub: ty::Region<'tcx>,\n                            r_sup: ty::Region<'tcx>)"}, {"sha": "2dbc02253992cd5a8d81a5ee44bd2b05874effbc", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -39,15 +39,15 @@ pub struct MoveData<'tcx> {\n     pub path_assignments: RefCell<Vec<Assignment>>,\n }\n \n-pub struct FlowedMoveData<'a, 'tcx: 'a> {\n+pub struct FlowedMoveData<'tcx> {\n     pub move_data: MoveData<'tcx>,\n \n-    pub dfcx_moves: MoveDataFlow<'a, 'tcx>,\n+    pub dfcx_moves: MoveDataFlow<'tcx>,\n \n     // We could (and maybe should, for efficiency) combine both move\n     // and assign data flow into one, but this way it's easier to\n     // distinguish the bits that correspond to moves and assignments.\n-    pub dfcx_assign: AssignDataFlow<'a, 'tcx>\n+    pub dfcx_assign: AssignDataFlow<'tcx>\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n@@ -139,12 +139,12 @@ pub struct Assignment {\n #[derive(Clone, Copy)]\n pub struct MoveDataFlowOperator;\n \n-pub type MoveDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, MoveDataFlowOperator>;\n+pub type MoveDataFlow<'tcx> = DataFlowContext<'tcx, MoveDataFlowOperator>;\n \n #[derive(Clone, Copy)]\n pub struct AssignDataFlowOperator;\n \n-pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOperator>;\n+pub type AssignDataFlow<'tcx> = DataFlowContext<'tcx, AssignDataFlowOperator>;\n \n fn loan_path_is_precise(loan_path: &LoanPath<'_>) -> bool {\n     match loan_path.kind {\n@@ -167,7 +167,7 @@ fn loan_path_is_precise(loan_path: &LoanPath<'_>) -> bool {\n     }\n }\n \n-impl<'a, 'tcx> MoveData<'tcx> {\n+impl MoveData<'tcx> {\n     /// Returns `true` if there are no trackable assignments or moves\n     /// in this move data -- that means that there is nothing that\n     /// could cause a borrow error.\n@@ -223,7 +223,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n     /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn move_path(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                      lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         if let Some(&index) = self.path_map.borrow().get(&lp) {\n             return index;\n@@ -311,7 +311,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     }\n \n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n-    pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn add_move(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                     orig_lp: Rc<LoanPath<'tcx>>,\n                     id: hir::ItemLocalId,\n                     kind: MoveKind) {\n@@ -340,7 +340,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         self.add_move_helper(tcx, orig_lp, id, kind);\n     }\n \n-    fn add_move_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn add_move_helper(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                        lp: Rc<LoanPath<'tcx>>,\n                        id: hir::ItemLocalId,\n                        kind: MoveKind) {\n@@ -365,7 +365,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     /// Adds a new record for an assignment to `lp` that occurs at location `id` with the given\n     /// `span`.\n-    pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn add_assignment(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           lp: Rc<LoanPath<'tcx>>,\n                           assign_id: hir::ItemLocalId,\n                           span: Span) {\n@@ -395,7 +395,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         self.add_assignment_helper(tcx, lp, assign_id, span);\n     }\n \n-    fn add_assignment_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn add_assignment_helper(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              lp: Rc<LoanPath<'tcx>>,\n                              assign_id: hir::ItemLocalId,\n                              span: Span) {\n@@ -428,9 +428,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// scoping. Assignments are generated by assignment to variables and\n     /// killed by scoping. See `README.md` for more details.\n     fn add_gen_kills(&self,\n-                     bccx: &BorrowckCtxt<'a, 'tcx>,\n-                     dfcx_moves: &mut MoveDataFlow<'_, '_>,\n-                     dfcx_assign: &mut AssignDataFlow<'_, '_>) {\n+                     bccx: &BorrowckCtxt<'_, 'tcx>,\n+                     dfcx_moves: &mut MoveDataFlow<'_>,\n+                     dfcx_assign: &mut AssignDataFlow<'_>) {\n         for (i, the_move) in self.moves.borrow().iter().enumerate() {\n             dfcx_moves.add_gen(the_move.id, i);\n         }\n@@ -538,7 +538,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                   path: MovePathIndex,\n                   kill_id: hir::ItemLocalId,\n                   kill_kind: KillFrom,\n-                  dfcx_moves: &mut MoveDataFlow<'_, '_>) {\n+                  dfcx_moves: &mut MoveDataFlow<'_>) {\n         // We can only perform kills for paths that refer to a unique location,\n         // since otherwise we may kill a move from one location with an\n         // assignment referring to another location.\n@@ -555,12 +555,12 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n+impl<'tcx> FlowedMoveData<'tcx> {\n     pub fn new(move_data: MoveData<'tcx>,\n-               bccx: &BorrowckCtxt<'a, 'tcx>,\n+               bccx: &BorrowckCtxt<'_, 'tcx>,\n                cfg: &cfg::CFG,\n                body: &hir::Body)\n-               -> FlowedMoveData<'a, 'tcx> {\n+               -> FlowedMoveData<'tcx> {\n         let tcx = bccx.tcx;\n \n         let mut dfcx_moves ="}, {"sha": "ba91676ec648c47c2ee9b7ef82f9481346a447f8", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -26,8 +26,8 @@ pub enum EntryOrExit {\n }\n \n #[derive(Clone)]\n-pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct DataFlowContext<'tcx, O> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n \n     /// a name for the analysis using this dataflow instance\n     analysis_name: &'static str,\n@@ -80,8 +80,8 @@ pub trait DataFlowOperator : BitwiseOperator {\n     fn initial_value(&self) -> bool;\n }\n \n-struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O> {\n-    dfcx: &'a mut DataFlowContext<'b, 'tcx, O>,\n+struct PropagationContext<'a, 'tcx, O> {\n+    dfcx: &'a mut DataFlowContext<'tcx, O>,\n     changed: bool\n }\n \n@@ -91,14 +91,14 @@ fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n     index.get(&id).map_or(&[], |v| &v[..])\n }\n \n-impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n+impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n     fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n         assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n         self.local_id_to_index.contains_key(&n)\n     }\n }\n \n-impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n+impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n     fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) -> io::Result<()> {\n         pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n     }\n@@ -224,13 +224,13 @@ pub enum KillFrom {\n     Execution,\n }\n \n-impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                analysis_name: &'static str,\n                body: Option<&hir::Body>,\n                cfg: &cfg::CFG,\n                oper: O,\n-               bits_per_id: usize) -> DataFlowContext<'a, 'tcx, O> {\n+               bits_per_id: usize) -> DataFlowContext<'tcx, O> {\n         let usize_bits = mem::size_of::<usize>() * 8;\n         let words_per_id = (bits_per_id + usize_bits - 1) / usize_bits;\n         let num_nodes = cfg.graph.all_nodes().len();\n@@ -500,7 +500,7 @@ impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n }\n \n // N.B. `Clone + 'static` only needed for pretty printing.\n-impl<'a, 'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'a, 'tcx, O> {\n+impl<'a, 'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'tcx, O> {\n     pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Body) {\n         //! Performs the data flow analysis.\n \n@@ -537,7 +537,7 @@ impl<'a, 'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'a, 'tcx,\n     }\n }\n \n-impl<'a, 'b, 'tcx, O: DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n+impl<O: DataFlowOperator> PropagationContext<'_, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n                 nodes_po: &[CFGIndex],"}, {"sha": "69c0aa0c6f76616e9742cef670fbaa74ef4c7277", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -34,7 +34,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n     pub inner: cfg_dot::LabelledCFG<'a, 'tcx>,\n     pub variants: Vec<Variant>,\n     pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,\n-    pub analysis_data: &'a borrowck::AnalysisData<'a, 'tcx>,\n+    pub analysis_data: &'a borrowck::AnalysisData<'tcx>,\n }\n \n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n@@ -64,7 +64,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn build_set<O:DataFlowOperator, F>(&self,\n                                         e: EntryOrExit,\n                                         cfgidx: CFGIndex,\n-                                        dfcx: &DataFlowContext<'a, 'tcx, O>,\n+                                        dfcx: &DataFlowContext<'tcx, O>,\n                                         mut to_lp: F) -> String where\n         F: FnMut(usize) -> Rc<LoanPath<'tcx>>,\n     {"}, {"sha": "98e629ce046bbfd3d62c19d7d8e19c08fbf7df6f", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -5,6 +5,7 @@\n #![deny(internal)]\n #![deny(unused_lifetimes)]\n \n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "fd8ef55c77f3c1f9adc835bf8b2ee60c8142e281", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -42,7 +42,7 @@ use rustc::hir::CodegenFnAttrs;\n use crate::value::Value;\n \n pub fn write_compressed_metadata<'a, 'gcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n     metadata: &EncodedMetadata,\n     llvm_module: &mut ModuleLlvm\n ) {\n@@ -103,7 +103,7 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-pub fn compile_codegen_unit(tcx: TyCtxt<'a, 'tcx, 'tcx>, cgu_name: InternedString) {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, cgu_name: InternedString) {\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n@@ -124,7 +124,7 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'a, 'tcx, 'tcx>, cgu_name: InternedStrin\n     submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tcx, module, cost);\n \n     fn module_codegen<'ll, 'tcx>(\n-        tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n     ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);"}, {"sha": "af28f43a74f26bde18ff9a2fddbb858983189221", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -66,7 +66,7 @@ impl ty::layout::HasDataLayout for Builder<'_, '_, '_> {\n }\n \n impl ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.cx.tcx\n     }\n }"}, {"sha": "ca91814c45bf829705f0099ce815ff58094012d1", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -35,7 +35,7 @@ use crate::abi::Abi;\n /// `llvm::Context` so that several compilation units may be optimized in parallel.\n /// All other LLVM data structures in the `CodegenCx` are tied to that `llvm::Context`.\n pub struct CodegenCx<'ll, 'tcx: 'll> {\n-    pub tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     pub check_overflow: bool,\n     pub use_dll_storage_attrs: bool,\n     pub tls_model: llvm::ThreadLocalMode,\n@@ -207,7 +207,7 @@ pub unsafe fn create_module(\n }\n \n impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n-    crate fn new(tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n+    crate fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                  codegen_unit: Arc<CodegenUnit<'tcx>>,\n                  llvm_module: &'ll crate::ModuleLlvm)\n                  -> Self {\n@@ -838,7 +838,7 @@ impl HasTargetSpec for CodegenCx<'ll, 'tcx> {\n }\n \n impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n }"}, {"sha": "89c24c624a2491c5fb563da0798f60b137f3e078", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -109,23 +109,23 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n \n     fn write_compressed_metadata<'b, 'gcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n         metadata: &EncodedMetadata,\n         llvm_module: &mut ModuleLlvm\n     ) {\n         base::write_compressed_metadata(tcx, metadata, llvm_module)\n     }\n     fn codegen_allocator<'b, 'gcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n         mods: &mut ModuleLlvm,\n         kind: AllocatorKind\n     ) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n     fn compile_codegen_unit<'a, 'tcx: 'a>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n     ) {\n         base::compile_codegen_unit(tcx, cgu_name);\n@@ -286,7 +286,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n     fn codegen_crate<'b, 'tcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>"}, {"sha": "845adf0a268b116063894fe45c1e3b4cdc42b92a", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -46,7 +46,7 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExpor\n     }\n }\n \n-fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                              cnum: CrateNum)\n                                              -> &'tcx DefIdMap<SymbolExportLevel>\n {\n@@ -157,7 +157,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.arena.alloc(reachable_non_generics)\n }\n \n-fn is_reachable_non_generic_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn is_reachable_non_generic_provider_local<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                      def_id: DefId)\n                                                      -> bool {\n     let export_threshold = threshold(tcx);\n@@ -169,13 +169,13 @@ fn is_reachable_non_generic_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     }\n }\n \n-fn is_reachable_non_generic_provider_extern<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn is_reachable_non_generic_provider_extern<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                       def_id: DefId)\n                                                       -> bool {\n     tcx.reachable_non_generics(def_id.krate).contains_key(&def_id)\n }\n \n-fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                              cnum: CrateNum)\n                                              -> Arc<Vec<(ExportedSymbol<'tcx>,\n                                                          SymbolExportLevel)>>\n@@ -279,7 +279,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn upstream_monomorphizations_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     cnum: CrateNum)\n     -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>>\n {\n@@ -329,7 +329,7 @@ fn upstream_monomorphizations_provider<'a, 'tcx>(\n }\n \n fn upstream_monomorphizations_for_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId)\n     -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n {"}, {"sha": "4eff29f502257567fb5e6b74449c19483e0014a4", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -480,7 +480,7 @@ pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n \n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n     rx: mpsc::Receiver<Box<dyn Any + Send>>\n@@ -703,7 +703,7 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n     }\n }\n \n-fn assert_and_save_dep_graph<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>) {\n+fn assert_and_save_dep_graph<'ll, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     time(tcx.sess,\n          \"assert dep graph\",\n          || ::rustc_incremental::assert_dep_graph(tcx));\n@@ -850,7 +850,7 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                  cgu: &CodegenUnit<'tcx>)\n                                  -> CguReuse {\n     if !tcx.dep_graph.is_fully_enabled() {"}, {"sha": "df7c33fb2dee05ba45447be83d57f8186f91303a", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::FxHashSet;\n // any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e., type parameters) are always fully qualified.\n-pub fn compute_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn compute_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                              t: Ty<'tcx>,\n                                              qualified: bool)\n                                              -> String {\n@@ -20,7 +20,7 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n-pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                           t: Ty<'tcx>,\n                                           qualified: bool,\n                                           output: &mut String,\n@@ -208,7 +208,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    fn push_item_name(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn push_item_name(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                       def_id: DefId,\n                       qualified: bool,\n                       output: &mut String) {\n@@ -228,7 +228,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // reconstructed for items from non-local crates. For local crates, this\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n-    fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                   substs: SubstsRef<'tcx>,\n                                   output: &mut String,\n                                   visited: &mut FxHashSet<Ty<'tcx>>) {"}, {"sha": "64a4c922500ec0666f0e3ba0e536d3703327163f", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -34,19 +34,19 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n     fn new_metadata(&self, sess: TyCtxt<'_, '_, '_>, mod_name: &str) -> Self::Module;\n     fn write_compressed_metadata<'b, 'gcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n         metadata: &EncodedMetadata,\n         llvm_module: &mut Self::Module,\n     );\n     fn codegen_allocator<'b, 'gcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n         mods: &mut Self::Module,\n         kind: AllocatorKind\n     );\n     fn compile_codegen_unit<'a, 'tcx: 'a>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n     );\n     // If find_features is true this won't access `sess.crate_types` by assuming"}, {"sha": "472b88b5b66866d11ae4370463534547517c71e7", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -36,7 +36,7 @@ pub trait CodegenBackend {\n     fn provide_extern(&self, _providers: &mut Providers<'_>);\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n         rx: mpsc::Receiver<Box<dyn Any + Send>>"}, {"sha": "4df96a95e53a1652a46386a44f160a687b98a908", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -112,7 +112,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n+fn symbol_name(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n "}, {"sha": "c7729f28beb605ecef7f4d3880cd26096a6554a0", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -14,7 +14,7 @@ use std::fmt::{self, Write};\n use std::mem::{self, discriminant};\n \n pub(super) fn mangle(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     instantiating_crate: Option<CrateNum>,\n ) -> String {\n@@ -69,7 +69,7 @@ pub(super) fn mangle(\n }\n \n fn get_symbol_hash<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n \n     // instance this name will be for\n     instance: Instance<'tcx>,\n@@ -179,8 +179,8 @@ impl SymbolPath {\n     }\n }\n \n-struct SymbolPrinter<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SymbolPrinter<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     path: SymbolPath,\n \n     // When `true`, `finalize_pending_component` isn't used.\n@@ -194,7 +194,7 @@ struct SymbolPrinter<'a, 'tcx> {\n // `PrettyPrinter` aka pretty printing of e.g. types in paths,\n // symbol names should have their own printing machinery.\n \n-impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+impl Printer<'tcx, 'tcx> for SymbolPrinter<'tcx> {\n     type Error = fmt::Error;\n \n     type Path = Self;\n@@ -203,7 +203,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -360,7 +360,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     }\n }\n \n-impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'tcx> {\n     fn region_should_not_be_omitted(\n         &self,\n         _region: ty::Region<'_>,\n@@ -400,7 +400,7 @@ impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     }\n }\n \n-impl fmt::Write for SymbolPrinter<'_, '_> {\n+impl fmt::Write for SymbolPrinter<'_> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         // Name sanitation. LLVM will happily accept identifiers with weird names, but\n         // gas doesn't!"}, {"sha": "e3b12fb7f415ce7132367032bcf5fedbad6191ee", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -13,7 +13,7 @@ use std::fmt::Write;\n use std::ops::Range;\n \n pub(super) fn mangle(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     instantiating_crate: Option<CrateNum>,\n ) -> String {\n@@ -75,14 +75,14 @@ struct BinderLevel {\n     lifetime_depths: Range<u32>,\n }\n \n-struct SymbolMangler<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SymbolMangler<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     compress: Option<Box<CompressionCaches<'tcx>>>,\n     binders: Vec<BinderLevel>,\n     out: String,\n }\n \n-impl SymbolMangler<'_, 'tcx> {\n+impl SymbolMangler<'tcx> {\n     fn push(&mut self, s: &str) {\n         self.out.push_str(s);\n     }\n@@ -214,7 +214,7 @@ impl SymbolMangler<'_, 'tcx> {\n     }\n }\n \n-impl Printer<'tcx, 'tcx> for SymbolMangler<'_, 'tcx> {\n+impl Printer<'tcx, 'tcx> for SymbolMangler<'tcx> {\n     type Error = !;\n \n     type Path = Self;\n@@ -223,7 +223,7 @@ impl Printer<'tcx, 'tcx> for SymbolMangler<'_, 'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "b2d77e21200c0358f7870cd4f21e0e2620722ca4", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -11,7 +11,7 @@ use syntax::symbol::{Symbol, sym};\n const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n const DEF_PATH: Symbol = sym::rustc_def_path;\n \n-pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n@@ -25,11 +25,11 @@ pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     })\n }\n \n-struct SymbolNamesTest<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SymbolNamesTest<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n+impl SymbolNamesTest<'tcx> {\n     fn process_attrs(&mut self,\n                      hir_id: hir::HirId) {\n         let tcx = self.tcx;\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n+impl hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.hir_id);\n     }"}, {"sha": "e185fa36fb4cbea58ef74a73026545514b2ef15f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -456,7 +456,7 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n \n \n struct TypedAnnotation<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     tables: Cell<&'a ty::TypeckTables<'tcx>>,\n }\n \n@@ -618,7 +618,7 @@ impl UserIdentifiedItem {\n }\n \n fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                        code: blocks::Code<'tcx>,\n                                        mode: PpFlowGraphMode,\n                                        mut out: W)\n@@ -866,7 +866,7 @@ pub fn print_after_hir_lowering<'tcx>(\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     ppm: PpMode,\n     uii: Option<UserIdentifiedItem>,\n     ofile: Option<&Path>"}, {"sha": "78dfef1d4c6ba7055b27f2f98298c8076f185536", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -51,7 +51,7 @@ use std::io::Write;\n use syntax::ast;\n use syntax_pos::Span;\n \n-pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.debugging_opts.dump_dep_graph {\n             dump_graph(tcx);\n@@ -89,13 +89,13 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n type Sources = Vec<(Span, DefId, DepNode)>;\n type Targets = Vec<(Span, ast::Name, hir::HirId, DepNode)>;\n \n-struct IfThisChanged<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct IfThisChanged<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     if_this_changed: Sources,\n     then_this_would_need: Targets,\n }\n \n-impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n+impl IfThisChanged<'tcx> {\n     fn argument(&self, attr: &ast::Attribute) -> Option<ast::Name> {\n         let mut value = None;\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -184,7 +184,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_paths<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                          if_this_changed: &Sources,\n                          then_this_would_need: &Targets)\n {"}, {"sha": "8cffa4b8284f99222fb173d6b079fc23745cd6a5", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -35,7 +35,7 @@ const MODULE: Symbol = sym::module;\n const CFG: Symbol = sym::cfg;\n const KIND: Symbol = sym::kind;\n \n-pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.incremental.is_none() {\n             return;\n@@ -59,12 +59,12 @@ pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     })\n }\n \n-struct AssertModuleSource<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct AssertModuleSource<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     available_cgus: BTreeSet<String>,\n }\n \n-impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n+impl AssertModuleSource<'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n         let (expected_reuse, comp_kind) = if attr.check_name(ATTR_PARTITION_REUSED) {\n             (CguReuse::PreLto, ComparisonKind::AtLeast)"}, {"sha": "ffea495d3ebdb3c0857cf23c2525539fd1127889", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -2,6 +2,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(specialization)]\n "}, {"sha": "06fe5750f9d82ddc9f52545e5578bdc7644e96b4", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -206,7 +206,7 @@ impl Assertion {\n     }\n }\n \n-pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.features().rustc_attrs {\n         return;\n@@ -234,13 +234,12 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     })\n }\n \n-pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct DirtyCleanVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n-impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-\n+impl DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n     fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute)\n         -> Option<Assertion>\n@@ -518,7 +517,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.check_item(item.hir_id, item.span);\n     }\n@@ -590,14 +589,13 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> as\n // A visitor that collects all #[rustc_dirty]/#[rustc_clean] attributes from\n // the HIR. It is used to verfiy that we really ran checks for all annotated\n // nodes.\n-pub struct FindAllAttrs<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct FindAllAttrs<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     attr_names: Vec<Symbol>,\n     found_attrs: Vec<&'tcx Attribute>,\n }\n \n-impl<'a, 'tcx> FindAllAttrs<'a, 'tcx> {\n-\n+impl FindAllAttrs<'tcx> {\n     fn is_active_attr(&mut self, attr: &Attribute) -> bool {\n         for attr_name in &self.attr_names {\n             if attr.check_name(*attr_name) && check_config(self.tcx, attr) {\n@@ -618,7 +616,7 @@ impl<'a, 'tcx> FindAllAttrs<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for FindAllAttrs<'a, 'tcx> {\n+impl intravisit::Visitor<'tcx> for FindAllAttrs<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }"}, {"sha": "5146453c746659e2fd2f47e75a8a39460c636e11", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -15,7 +15,7 @@ use super::fs::*;\n use super::file_format;\n use super::work_product;\n \n-pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     if !tcx.dep_graph.is_fully_enabled() {\n         return\n     }"}, {"sha": "8e4c0133b427949d6ccf6ed965f977d53c8012a9", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -15,7 +15,7 @@ use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n \n-pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     debug!(\"save_dep_graph()\");\n     tcx.dep_graph.with_ignore(|| {\n         let sess = tcx.sess;"}, {"sha": "66a4ee8bfc35de636c28b2960bf4b550359c57c0", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -879,7 +879,7 @@ pub fn create_global_ctxt(\n /// Runs the resolution, type-checking, region checking and other\n /// miscellaneous analysis passes on the crate.\n fn analysis<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     cnum: CrateNum,\n ) -> Result<()> {\n     assert_eq!(cnum, LOCAL_CRATE);\n@@ -999,7 +999,7 @@ fn analysis<'tcx>(\n }\n \n fn encode_and_write_metadata<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     outputs: &OutputFilenames,\n ) -> (middle::cstore::EncodedMetadata, bool) {\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -1062,7 +1062,7 @@ fn encode_and_write_metadata<'tcx>(\n /// be discarded.\n pub fn start_codegen<'tcx>(\n     codegen_backend: &dyn CodegenBackend,\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     rx: mpsc::Receiver<Box<dyn Any + Send>>,\n     outputs: &OutputFilenames,\n ) -> Box<dyn Any> {"}, {"sha": "82eb2014728d48b1d5dbec98ece1982c7194936a", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -6,12 +6,12 @@ use rustc::ty::query::Providers;\n use syntax::attr;\n use syntax::symbol::sym;\n \n-pub fn find<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Option<DefId> {\n+pub fn find<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Option<DefId> {\n     tcx.proc_macro_decls_static(LOCAL_CRATE)\n }\n \n fn proc_macro_decls_static<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     cnum: CrateNum,\n ) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "59498799f19d09e2e3ee3de1bfbeef6c0da08881", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -75,7 +75,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn lint_mod<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n "}, {"sha": "13e620b6b01f30a3526351e16553ad11507aeca4", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -519,11 +519,11 @@ enum FfiResult<'tcx> {\n     },\n }\n \n-fn is_zst<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n+fn is_zst<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n     tcx.layout_of(tcx.param_env(did).and(ty)).map(|layout| layout.is_zst()).unwrap_or(false)\n }\n \n-fn ty_is_known_nonnull<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+fn ty_is_known_nonnull<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::FnPtr(_) => true,\n         ty::Ref(..) => true,\n@@ -555,7 +555,7 @@ fn ty_is_known_nonnull<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> b\n /// to function pointers, references, core::num::NonZero*,\n /// core::ptr::NonNull, and #[repr(transparent)] newtypes.\n /// FIXME: This duplicates code in codegen.\n-fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                   ty: Ty<'tcx>,\n                                   ty_def: &'tcx ty::AdtDef,\n                                   substs: SubstsRef<'tcx>)"}, {"sha": "14f46fef874db5e2f00418e140b13eed85a5de18", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -327,7 +327,7 @@ fn add_query_description_impl(\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n-                    #tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                    #tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                     #id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n                     #block\n@@ -338,7 +338,7 @@ fn add_query_description_impl(\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n-                    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                     id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n                     tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n@@ -350,7 +350,7 @@ fn add_query_description_impl(\n         quote! {\n             #[inline]\n             #[allow(unused_variables)]\n-            fn cache_on_disk(#tcx: TyCtxt<'_, 'tcx, 'tcx>, #key: Self::Key) -> bool {\n+            fn cache_on_disk(#tcx: TyCtxt<'tcx, 'tcx, 'tcx>, #key: Self::Key) -> bool {\n                 #expr\n             }\n "}, {"sha": "9ab482895d9a72159edd233d0e48dc4b1190f499", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -40,7 +40,7 @@ macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n       $($name:ident => $compute:block)*) => {\n         pub fn provide_extern<$lt>(providers: &mut Providers<$lt>) {\n-            $(fn $name<'a, $lt:$lt, T>($tcx: TyCtxt<'a, $lt, $lt>, def_id_arg: T)\n+            $(fn $name<$lt:$lt, T>($tcx: TyCtxt<$lt, $lt, $lt>, def_id_arg: T)\n                                     -> <ty::queries::$name<$lt> as\n                                         QueryConfig<$lt>>::Value\n                 where T: IntoArgs,\n@@ -551,7 +551,7 @@ impl CrateStore for cstore::CStore {\n     }\n \n     fn encode_metadata<'a, 'tcx>(&self,\n-                                 tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                 tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                                  -> EncodedMetadata\n     {\n         encoder::encode_metadata(tcx)"}, {"sha": "bcce834c282e084000002d42612b6d2a7660b3ba", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -39,7 +39,7 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'a Session>,\n-    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    tcx: Option<TyCtxt<'tcx, 'tcx, 'tcx>>,\n \n     // Cache the last used source_file for translating spans as an optimization.\n     last_source_file_index: usize,\n@@ -55,7 +55,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'a Session> { None }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n+    fn tcx(self) -> Option<TyCtxt<'tcx, 'tcx, 'tcx>> { None }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let tcx = self.tcx();\n@@ -114,14 +114,14 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'a Session) {\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx, 'tcx, 'tcx>) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n     }\n     fn cdata(self) -> Option<&'a CrateMetadata> {\n         Some(self.0)\n     }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n+    fn tcx(self) -> Option<TyCtxt<'tcx, 'tcx, 'tcx>> {\n         Some(self.1)\n     }\n }\n@@ -146,7 +146,7 @@ impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n@@ -169,10 +169,10 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx: 'a> TyDecoder<'a, 'tcx> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n \n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n@@ -547,7 +547,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn get_variant(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         item: &Entry<'_>,\n         index: DefIndex,\n         parent_did: DefId,\n@@ -590,7 +590,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_adt_def(&self,\n                        item_id: DefIndex,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                       tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                        -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n@@ -618,21 +618,21 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_predicates(&self,\n                           item_id: DefIndex,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                           -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n     }\n \n     pub fn get_predicates_defined_on(&self,\n                                    item_id: DefIndex,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                   tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                                    -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n     }\n \n     pub fn get_super_predicates(&self,\n                                 item_id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                                 -> ty::GenericPredicates<'tcx> {\n         let super_predicates = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self).super_predicates,\n@@ -650,7 +650,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(item_id).generics.unwrap().decode((self, sess))\n     }\n \n-    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Ty<'tcx> {\n         self.entry(id).ty.unwrap().decode((self, tcx))\n     }\n \n@@ -702,7 +702,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_impl_trait(&self,\n                           id: DefIndex,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                           -> Option<ty::TraitRef<'tcx>> {\n         self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn maybe_get_optimized_mir(&self,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                    id: DefIndex)\n                                    -> Option<Body<'tcx>> {\n         match self.is_proc_macro(id) {\n@@ -1136,7 +1136,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn exported_symbols(&self,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                            tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                             -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n         if self.proc_macros.is_some() {\n             // If this crate is a custom derive crate, then we're not even going to\n@@ -1194,7 +1194,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn fn_sig(&self,\n                   id: DefIndex,\n-                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                  tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                   -> ty::PolyFnSig<'tcx> {\n         let sig = match self.entry(id).kind {\n             EntryKind::Fn(data) |"}, {"sha": "7fbf50e6b5322355ebfea3a94f3ecacc0b17feed", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -40,9 +40,9 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-pub struct EncodeContext<'a, 'tcx: 'a> {\n+pub struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n \n     entries_index: Index<'tcx>,\n \n@@ -65,7 +65,7 @@ macro_rules! encoder_methods {\n     }\n }\n \n-impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n+impl<'a, 'tcx> Encoder for EncodeContext<'tcx> {\n     type Error = <opaque::Encoder as Encoder>::Error;\n \n     fn emit_unit(&mut self) -> Result<(), Self::Error> {\n@@ -95,13 +95,13 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'a, 'tcx> {\n+impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n         self.emit_lazy_distance(lazy.position, Lazy::<T>::min_size())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n+impl<'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, seq: &LazySeq<T>) -> Result<(), Self::Error> {\n         self.emit_usize(seq.len)?;\n         if seq.len == 0 {\n@@ -111,14 +111,14 @@ impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n         self.emit_u32(cnum.as_u32())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<DefId> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<DefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &DefId) -> Result<(), Self::Error> {\n         let DefId {\n@@ -131,14 +131,14 @@ impl<'a, 'tcx> SpecializedEncoder<DefId> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_index: &DefIndex) -> Result<(), Self::Error> {\n         self.emit_u32(def_index.as_u32())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n         if span.is_dummy() {\n             return TAG_INVALID_SPAN.encode(self)\n@@ -173,20 +173,20 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n         self.specialized_encode(&def_id.to_def_id())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n         ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n         let index = match self.interpret_allocs.entry(*alloc_id) {\n@@ -203,36 +203,36 @@ impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self,\n                           predicates: &ty::GenericPredicates<'tcx>)\n                           -> Result<(), Self::Error> {\n         ty_codec::encode_predicates(self, predicates, |ecx| &mut ecx.predicate_shorthands)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'tcx, T: Encodable> SpecializedEncoder<mir::ClearCrossCrate<T>>\n-for EncodeContext<'a, 'tcx> {\n+impl<'tcx, T: Encodable> SpecializedEncoder<mir::ClearCrossCrate<T>>\n+for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self,\n                           _: &mir::ClearCrossCrate<T>)\n                           -> Result<(), Self::Error> {\n         Ok(())\n     }\n }\n \n-impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n+impl<'tcx> TyEncoder for EncodeContext<'tcx> {\n     fn position(&self) -> usize {\n         self.opaque.position()\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl<'tcx> EncodeContext<'tcx> {\n \n     fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n         assert_eq!(self.lazy_state, LazyState::NoNode);\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl EncodeContext<'_, 'tcx> {\n+impl EncodeContext<'tcx> {\n     fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1648,7 +1648,7 @@ impl EncodeContext<'_, 'tcx> {\n     }\n }\n \n-impl Visitor<'tcx> for EncodeContext<'_, 'tcx> {\n+impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -1698,7 +1698,7 @@ impl Visitor<'tcx> for EncodeContext<'_, 'tcx> {\n     }\n }\n \n-impl EncodeContext<'_, 'tcx> {\n+impl EncodeContext<'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter_enumerated() {\n@@ -1817,12 +1817,12 @@ impl EncodeContext<'_, 'tcx> {\n     }\n }\n \n-struct ImplVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ImplVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     impls: FxHashMap<DefId, Vec<DefIndex>>,\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n+impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Impl(..) = item.node {\n             let impl_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n@@ -1865,7 +1865,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                                  -> EncodedMetadata\n {\n     let mut encoder = opaque::Encoder::new(vec![]);\n@@ -1909,7 +1909,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     EncodedMetadata { raw_data: result }\n }\n \n-pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {\n+pub fn get_repr_options<'tcx, 'gcx>(tcx: TyCtxt<'gcx, 'tcx, 'gcx>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n     match ty.sty {\n         ty::Adt(ref def, _) => return def.repr,"}, {"sha": "eb5a6485d25659d15887fa6dd6abcc580a94c80a", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -3,7 +3,7 @@ use rustc::hir;\n use rustc::middle::cstore::ForeignModule;\n use rustc::ty::TyCtxt;\n \n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<ForeignModule> {\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Vec<ForeignModule> {\n     let mut collector = Collector {\n         tcx,\n         modules: Vec::new(),\n@@ -12,12 +12,12 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<ForeignModule> {\n     return collector.modules\n }\n \n-struct Collector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Collector<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     modules: Vec<ForeignModule>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n             hir::ItemKind::ForeignMod(ref fm) => fm,"}, {"sha": "851c2d3ea121871d6d8e5804b72681d276ecb8a7", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n \n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Vec<String> {\n     let mut collector = Collector {\n         args: Vec::new(),\n     };"}, {"sha": "0817cce90dfea21784dc72dfda29df8390dfeb11", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -11,7 +11,7 @@ use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, struct_span_err};\n \n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n     let mut collector = Collector {\n         tcx,\n         libs: Vec::new(),\n@@ -28,12 +28,12 @@ pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     }\n }\n \n-struct Collector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Collector<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     libs: Vec<NativeLibrary>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n }\n \n-impl<'a, 'tcx> Collector<'a, 'tcx> {\n+impl Collector<'tcx> {\n     fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLibrary) {\n         if lib.name.as_ref().map(|s| s.as_str().is_empty()).unwrap_or(false) {\n             match span {"}, {"sha": "e1425ed24300d1db35a0bfbe4669f9fae670ecb8", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -122,7 +122,7 @@ impl LocalsStateAtExit {\n \n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         body: &Body<'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>\n@@ -162,7 +162,7 @@ impl<'tcx> BorrowSet<'tcx> {\n }\n \n struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,"}, {"sha": "aa298659d72f2cb03e9cf39ffea4d4d2f9564e6b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -87,7 +87,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n+fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n     let input_body = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n "}, {"sha": "a7f3022019c1a3f8410811b51a3e65b39f919df7", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -96,7 +96,7 @@ impl BorrowedContentSource<'tcx> {\n         }\n     }\n \n-    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'_, '_, 'tcx>) -> Option<Self> {\n+    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'tcx, '_, 'tcx>) -> Option<Self> {\n         match func.sty {\n             ty::FnDef(def_id, substs) => {\n                 let trait_id = tcx.trait_of_item(def_id)?;"}, {"sha": "8452d1654d8a15697dfdd593a5cc1ca86a47719f", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n }\n \n fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     local_decl: &mir::LocalDecl<'tcx>,\n ) -> (Span, String) {\n     let sp = local_decl.source_info.span;\n@@ -556,7 +556,7 @@ fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n // This implementation attempts to emulate AST-borrowck prioritization\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n@@ -623,7 +623,7 @@ fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n ///    |        ---------- use `&'a mut String` here to make mutable\n /// ```\n fn annotate_struct_field(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     field: &mir::Field,\n ) -> Option<(Span, String)> {"}, {"sha": "c0848f2afe633ec53ffd80a757e18cc6d1c4bc72", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxHashSet;\n crate fn find<'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n ) -> Option<Cause> {\n@@ -30,7 +30,7 @@ crate fn find<'tcx>(\n struct UseFinder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n     regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n }\n@@ -101,7 +101,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n \n struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     region_vid: RegionVid,\n     def_use_result: Option<DefUseResult>,\n }"}, {"sha": "143bdeb6f61e820c1f9ab6ff76572e2337030c86", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -53,7 +53,7 @@ impl BorrowExplanation {\n     }\n     pub(in crate::borrow_check) fn add_explanation_to_diagnostic<'cx, 'gcx, 'tcx>(\n         &self,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         body: &Body<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         borrow_desc: &str,"}, {"sha": "a870227c762d151b4b6fccd946c896d7678bdb46", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::{Operand, BorrowKind};\n use rustc_data_structures::graph::dominators::Dominators;\n \n pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     body: &Body<'tcx>,\n@@ -44,7 +44,7 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n }\n \n struct InvalidationGenerator<'cx, 'tcx: 'cx, 'gcx: 'tcx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n     body: &'cx Body<'tcx>,"}, {"sha": "2338d6a846674878ec07057ed89ff564604e7d85", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -194,7 +194,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// named variants.\n     fn give_name_from_error_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -303,7 +303,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn get_named_span(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         error_region: &RegionKind,\n         name: InternedString,\n     ) -> Span {\n@@ -461,7 +461,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// to highlighting that closest type instead.\n     fn give_name_if_we_can_match_hir_ty(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty,\n@@ -653,7 +653,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_upvars(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n         counter: &mut usize,"}, {"sha": "77aeb401445a0882e9533a2744596d7f84e864eb", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -10,7 +10,7 @@ use syntax_pos::symbol::Symbol;\n impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_var_name_and_span_for_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n@@ -35,7 +35,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Search the upvars (if any) to find one that references fr. Return its index.\n     crate fn get_upvar_index_for_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         fr: RegionVid,\n     ) -> Option<usize> {\n         let upvar_index = self\n@@ -69,7 +69,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// declared.\n     crate fn get_upvar_name_and_span_for_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         upvars: &[Upvar],\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n@@ -91,7 +91,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// user - in particular, index 0 is not the implicit self parameter.\n     crate fn get_argument_index_for_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         fr: RegionVid,\n     ) -> Option<usize> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();"}, {"sha": "a2213f0c7eb582a25428f1a867278e96fa170bfd", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -370,7 +370,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n-    crate fn annotate(&self, tcx: TyCtxt<'_, '_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'tcx, '_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n         self.universal_regions.annotate(tcx, err)\n     }\n \n@@ -943,7 +943,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `point`.\n     fn eval_verify_bound(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -976,7 +976,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn eval_if_eq(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -1022,7 +1022,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// higher-ranked things and so forth, and right now the inference\n     /// context is not permitted to make more inference variables. So\n     /// we use this kind of hacky solution.\n-    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'tcx, '_, 'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -1368,14 +1368,14 @@ impl<'tcx> RegionDefinition<'tcx> {\n pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n     fn apply_requirements(\n         &self,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>>;\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T\n@@ -1398,7 +1398,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n     /// requirements.\n     fn apply_requirements(\n         &self,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>> {\n@@ -1453,7 +1453,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T"}, {"sha": "381e18f60a2e04568e9f298b4a138a292aad5143", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -15,7 +15,7 @@ use syntax_pos::DUMMY_SP;\n \n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,"}, {"sha": "f4ceb36858e0755d80779708c257f950523bab5c", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -75,7 +75,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n // some region `R` in its type where `R` is not known to outlive a free\n // region (i.e., where `R` may be valid for just a subset of the fn body).\n fn compute_live_locals(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     free_regions: &FxHashSet<RegionVid>,\n     body: &Body<'tcx>,\n ) -> Vec<Local> {"}, {"sha": "75d5987af0bc1eccedeef47322b002dd813b594e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -391,7 +391,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.cx.infcx.tcx\n     }\n \n@@ -1313,7 +1313,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -2504,7 +2504,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn prove_closure_bounds(\n         &mut self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n         location: Location,"}, {"sha": "76b1acc52ba31b19157c81a5025fbcdf04bc3158", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> DefiningTy<'tcx> {\n     /// not a closure or generator, there are no upvars, and hence it\n     /// will be an empty list. The order of types in this list will\n     /// match up with the upvar order in the HIR, typesystem, and MIR.\n-    pub fn upvar_tys(self, tcx: TyCtxt<'_, '_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n+    pub fn upvar_tys(self, tcx: TyCtxt<'tcx, '_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         match self {\n             DefiningTy::Closure(def_id, substs) => Either::Left(substs.upvar_tys(def_id, tcx)),\n             DefiningTy::Generator(def_id, substs, _) => {\n@@ -218,7 +218,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// `'1: '2`, then the caller would impose the constraint that\n     /// `V[1]: V[2]`.\n     pub fn closure_mapping(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         closure_substs: SubstsRef<'tcx>,\n         expected_num_vars: usize,\n         closure_base_def_id: DefId,\n@@ -305,7 +305,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// that this region imposes on others. The methods in this file\n     /// handle the part about dumping the inference context internal\n     /// state.\n-    crate fn annotate(&self, tcx: TyCtxt<'_, '_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'tcx, '_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n         match self.defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 err.note(&format!(\n@@ -744,7 +744,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n \n     /// Replaces all free regions in `value` with region vids, as\n     /// returned by `to_region_vid`.\n-    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: &T) -> T\n+    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'tcx, '_, 'tcx>, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -757,7 +757,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n /// Iterates over the late-bound regions defined on fn_def_id and\n /// invokes `f` with the liberated form of each one.\n fn for_each_late_bound_region_defined_on<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     fn_def_id: DefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {"}, {"sha": "8377a0910a99c75e3b2ce0bd32cc687826d885c7", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -24,7 +24,7 @@ pub(super) enum Control {\n /// Encapsulates the idea of iterating over every borrow that involves a particular path\n pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     s: &mut S,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),"}, {"sha": "d0c05318d90f3bc645d89ad76188bc62e1560208", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -12,7 +12,7 @@ crate trait PlaceExt<'tcx> {\n     /// for borrows of raw pointer dereferents as well as shared references.\n     fn ignore_borrow(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n         ) -> bool;\n@@ -21,7 +21,7 @@ crate trait PlaceExt<'tcx> {\n impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n     fn ignore_borrow(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'tcx, '_, 'tcx>,\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {"}, {"sha": "cc9bcdc7f62028b93c343e7df9e2dab3b6b021ee", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -25,7 +25,7 @@ crate enum PlaceConflictBias {\n /// This is used to check for places conflicting outside of the borrow checking code (such as in\n /// dataflow).\n crate fn places_conflict<'gcx, 'tcx>(\n-    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     access_place: &Place<'tcx>,\n@@ -47,7 +47,7 @@ crate fn places_conflict<'gcx, 'tcx>(\n /// array indices, for example) should be interpreted - this depends on what the caller wants in\n /// order to make the conservative choice and preserve soundness.\n pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n-    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n@@ -84,7 +84,7 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n }\n \n fn place_components_conflict<'gcx, 'tcx>(\n-    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n     borrow_kind: BorrowKind,\n@@ -299,7 +299,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n fn place_base_conflict<'a, 'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     elem1: &PlaceBase<'tcx>,\n     elem2: &PlaceBase<'tcx>,\n ) -> Overlap {\n@@ -366,7 +366,7 @@ fn place_base_conflict<'a, 'gcx: 'tcx, 'tcx>(\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n fn place_projection_conflict<'a, 'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     pi1: &Projection<'tcx>,\n     pi2: &Projection<'tcx>,"}, {"sha": "b7af985ad494c43bb05d11590aeb18bd6b8ef484", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -39,7 +39,7 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n \n pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     kind: PrefixSet,\n     next: Option<&'cx Place<'tcx>>,\n }"}, {"sha": "aa43d161b6c18a6a5ffd452d30e83ad088b8159f", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -25,7 +25,7 @@ use syntax_pos::Span;\n use super::lints;\n \n /// Construct the MIR for a given `DefId`.\n-pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'tcx> {\n+pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> Body<'tcx> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -184,12 +184,12 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n /// A pass to lift all the types and substitutions in a MIR\n /// to the global tcx. Sadly, we don't have a \"folder\" that\n /// can change `'tcx` so we have to transmute afterwards.\n-struct GlobalizeMir<'a, 'gcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+struct GlobalizeMir<'gcx> {\n+    tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n     span: Span\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n+impl<'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'gcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         if let Some(lifted) = self.tcx.lift(ty) {\n             *ty = lifted;\n@@ -234,7 +234,7 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                             closure_expr_id: hir::HirId,\n                                             body_id: hir::BodyId)\n                                             -> Ty<'tcx> {\n@@ -551,7 +551,7 @@ macro_rules! unpack {\n     };\n }\n \n-fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                          fn_def_id: DefId,\n                                          abi: Abi)\n                                          -> bool {"}, {"sha": "eb2680f749b75e3aa172cc8adaf44f35ccd1ca83", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -43,17 +43,17 @@ const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n /// that inform us about the generic bounds of the constant. E.g., using an associated constant\n /// of a function's generic parameter will require knowledge about the bounds on the generic\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> CompileTimeEvalContext<'a, 'mir, 'tcx> {\n+) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n     InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n }\n \n-pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn eval_promoted<'mir, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -64,7 +64,7 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n }\n \n fn mplace_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n+    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     mplace: MPlaceTy<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n     let MemPlace { ptr, align, meta } = *mplace;\n@@ -84,7 +84,7 @@ fn mplace_to_const<'tcx>(\n }\n \n fn op_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n+    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: OpTy<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n     // We do not normalize just any data.  Only non-union scalars and slices.\n@@ -137,7 +137,7 @@ fn op_to_const<'tcx>(\n \n // Returns a pointer to where the result lives\n fn eval_body_using_ecx<'mir, 'tcx>(\n-    ecx: &mut CompileTimeEvalContext<'_, 'mir, 'tcx>,\n+    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -216,18 +216,18 @@ impl Error for ConstEvalError {\n }\n \n // Extra machine state for CTFE, and the Machine instance\n-pub struct CompileTimeInterpreter<'a, 'mir, 'tcx: 'a+'mir> {\n+pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// When this value is negative, it indicates the number of interpreter\n     /// steps *until* the loop detector is enabled. When it is positive, it is\n     /// the number of steps after the detector has been enabled modulo the loop\n     /// detector period.\n     pub(super) steps_since_detector_enabled: isize,\n \n     /// Extra state to detect loops.\n-    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'a, 'mir, 'tcx>,\n+    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n }\n \n-impl<'a, 'mir, 'tcx> CompileTimeInterpreter<'a, 'mir, 'tcx> {\n+impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     fn new() -> Self {\n         CompileTimeInterpreter {\n             loop_detector: Default::default(),\n@@ -297,8 +297,8 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-type CompileTimeEvalContext<'a, 'mir, 'tcx> =\n-    InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n+type CompileTimeEvalContext<'mir, 'tcx> =\n+    InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -308,8 +308,8 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n-impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n-    for CompileTimeInterpreter<'a, 'mir, 'tcx>\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx>\n+    for CompileTimeInterpreter<'mir, 'tcx>\n {\n     type MemoryKinds = !;\n     type PointerTag = ();\n@@ -323,12 +323,12 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n \n     #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n     }\n \n     fn find_fn(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n@@ -368,7 +368,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn call_intrinsic(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n@@ -384,7 +384,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn ptr_op(\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n+        _ecx: &InterpretCx<'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n@@ -396,7 +396,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n \n     fn find_foreign_static(\n         _def_id: DefId,\n-        _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        _tcx: TyCtxtAt<'tcx, 'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n@@ -421,15 +421,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn box_alloc(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n \n-    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+    fn before_terminator(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         {\n             let steps = &mut ecx.machine.steps_since_detector_enabled;\n \n@@ -455,15 +455,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n \n     #[inline(always)]\n     fn stack_push(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n     fn stack_pop(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         _extra: (),\n     ) -> InterpResult<'tcx> {\n         Ok(())\n@@ -473,8 +473,8 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n /// Extracts a field of a (variant of a) const.\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n-pub fn const_field<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn const_field<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n@@ -498,8 +498,8 @@ pub fn const_field<'a, 'tcx>(\n \n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n-pub fn const_variant_index<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn const_variant_index<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n ) -> VariantIdx {\n@@ -509,17 +509,17 @@ pub fn const_variant_index<'a, 'tcx>(\n     ecx.read_discriminant(op).unwrap().1\n }\n \n-pub fn error_to_const_error<'a, 'mir, 'tcx>(\n-    ecx: &InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+pub fn error_to_const_error<'mir, 'tcx>(\n+    ecx: &InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     mut error: InterpErrorInfo<'tcx>\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n     let stacktrace = ecx.generate_stacktrace(None);\n     ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n }\n \n-fn validate_and_turn_into_const<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn validate_and_turn_into_const<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     constant: RawConst<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n@@ -561,8 +561,8 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n     })\n }\n \n-pub fn const_eval_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn const_eval_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     // see comment in const_eval_provider for what we're doing here\n@@ -585,8 +585,8 @@ pub fn const_eval_provider<'a, 'tcx>(\n     })\n }\n \n-pub fn const_eval_raw_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn const_eval_raw_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n     // Because the constant is computed twice (once per value of `Reveal`), we are at risk of"}, {"sha": "dbe5ab902d7992c0980dde27fa92c0ebfa368f59", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -46,7 +46,7 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// is no need to maintain separate drop flags to track such state.\n //\n // FIXME: we have to do something for moving slice patterns.\n-fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                                             body: &Body<'tcx>,\n                                                             place: &mir::Place<'tcx>) -> bool {\n     let ty = place.ty(body, tcx).ty;\n@@ -73,7 +73,7 @@ fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n }\n \n pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     lookup_result: LookupResult,\n@@ -91,15 +91,15 @@ pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n }\n \n pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     move_path_index: MovePathIndex,\n     mut each_child: F)\n     where F: FnMut(MovePathIndex)\n {\n     fn is_terminal_path<'a, 'gcx, 'tcx>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex) -> bool\n@@ -109,7 +109,7 @@ pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n     }\n \n     fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         move_path_index: MovePathIndex,\n@@ -132,7 +132,7 @@ pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n }\n \n pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     path: MovePathIndex,\n@@ -155,7 +155,7 @@ pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n }\n \n pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     mut callback: F)\n@@ -172,7 +172,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n }\n \n pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     loc: Location,\n@@ -204,7 +204,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n }\n \n pub(crate) fn for_location_inits<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     loc: Location,"}, {"sha": "38cb7bd9796c6262cba5994ec65492c750180b92", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -30,7 +30,7 @@ newtype_index! {\n /// describing the borrow. These indexes are used for representing the\n /// borrows in compact bitvectors.\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n@@ -135,7 +135,7 @@ fn precompute_borrows_out_of_scope<'tcx>(\n \n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     crate fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         body: &'a Body<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,"}, {"sha": "3311353ebd3b6ca34c88a5c10585c8b5c2f72f8b", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -64,13 +64,13 @@ pub(super) mod borrows;\n /// between this data and `MaybeUninitializedPlaces` yields the set of\n /// places that would require a dynamic drop-flag at that statement.\n pub struct MaybeInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                body: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n@@ -119,13 +119,13 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx\n /// between this data and `MaybeInitializedPlaces` yields the set of\n /// places that would require a dynamic drop-flag at that statement.\n pub struct MaybeUninitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                body: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n@@ -173,13 +173,13 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 't\n /// this data and `MaybeInitializedPlaces` yields the set of places\n /// that would require a dynamic drop-flag at that statement.\n pub struct DefinitelyInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                body: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n@@ -222,13 +222,13 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, '\n /// }\n /// ```\n pub struct EverInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                body: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self"}, {"sha": "89b379b95b84cd20e836e951ba63657759fd6f11", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -121,7 +121,7 @@ pub struct MoveDataParamEnv<'gcx, 'tcx> {\n     pub(crate) param_env: ty::ParamEnv<'gcx>,\n }\n \n-pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                                  body: &'a Body<'tcx>,\n                                                  def_id: DefId,\n                                                  attributes: &[ast::Attribute],\n@@ -139,7 +139,7 @@ pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n {\n     pub(crate) fn run<P>(self,\n-                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                          def_id: DefId,\n                          attributes: &[ast::Attribute],\n                          p: P) -> DataflowResults<'tcx, BD>"}, {"sha": "76926fbd6c47677141a9c9e01399f779e841267c", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -14,13 +14,13 @@ use super::IllegalMoveOriginKind::*;\n \n struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     body: &'a Body<'tcx>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<(Place<'tcx>, MoveError<'tcx>)>,\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n-    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n         let mut init_path_map = IndexVec::new();\n@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n \n pub(super) fn gather_moves<'a, 'gcx, 'tcx>(\n     body: &Body<'tcx>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>\n ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n     let mut builder = MoveDataBuilder::new(body, tcx);\n "}, {"sha": "315f68b3a5132426a1c9becaf8b5dcfd48b5a4aa", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -306,7 +306,7 @@ impl<'tcx> MoveError<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(body: &Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+    pub fn gather_moves(body: &Body<'tcx>, tcx: TyCtxt<'tcx, 'gcx, 'tcx>)\n                         -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         builder::gather_moves(body, tcx)\n     }"}, {"sha": "e8c274177e6d07356c0977366121ea5d9c0cb165", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -11,7 +11,7 @@ crate enum LitToConstError {\n \n crate fn lit_to_const<'a, 'gcx, 'tcx>(\n     lit: &'tcx ast::LitKind,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     neg: bool,\n ) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {"}, {"sha": "e259c6171a3af93e056a5c2a7328c1be01f2aec2", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -22,7 +22,7 @@ use crate::hair::constant::{lit_to_const, LitToConstError};\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n \n     pub root_lint_level: hir::HirId,\n@@ -200,7 +200,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n }\n \n impl UserAnnotatedTyHelpers<'gcx, 'tcx> for Cx<'_, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx()\n     }\n "}, {"sha": "a13a6aaaf91943ce47e9191fe0d97631f749bfb2", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -194,11 +194,11 @@ pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx\n     cx.pattern_arena.alloc(LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat))\n }\n \n-struct LiteralExpander<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+struct LiteralExpander<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>\n }\n \n-impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n+impl LiteralExpander<'tcx> {\n     /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice.\n     ///\n     /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n@@ -239,7 +239,7 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> PatternFolder<'tcx> for LiteralExpander<'a, 'tcx> {\n+impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.sty, pat.kind);\n         match (&pat.ty.sty, &*pat.kind) {\n@@ -350,7 +350,7 @@ impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pattern<'tcx>; 2]>> for Matrix<'p, 'tc\n }\n \n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n     /// inhabited can depend on whether it was defined in the current module or\n@@ -365,7 +365,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub fn create_and_enter<F, R>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         module: DefId,\n         f: F) -> R\n@@ -827,7 +827,7 @@ struct IntRange<'tcx> {\n }\n \n impl<'tcx> IntRange<'tcx> {\n-    fn from_ctor(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    fn from_ctor(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                  ctor: &Constructor<'tcx>)\n                  -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n@@ -867,7 +867,7 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn from_pat(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    fn from_pat(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                 mut pat: &Pattern<'tcx>)\n                 -> Option<IntRange<'tcx>> {\n         let range = loop {\n@@ -889,7 +889,7 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n-    fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n+    fn signed_bias(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n             ty::Int(ity) => {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n@@ -901,7 +901,7 @@ impl<'tcx> IntRange<'tcx> {\n \n     /// Converts a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n     fn range_to_ctor(\n-        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         ty: Ty<'tcx>,\n         r: RangeInclusive<u128>,\n     ) -> Constructor<'tcx> {\n@@ -918,7 +918,7 @@ impl<'tcx> IntRange<'tcx> {\n     /// Returns a collection of ranges that spans the values covered by `ranges`, subtracted\n     /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n     fn subtract_from(self,\n-                     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                     tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                      ranges: Vec<Constructor<'tcx>>)\n                      -> Vec<Constructor<'tcx>> {\n         let ranges = ranges.into_iter().filter_map(|r| {\n@@ -988,7 +988,7 @@ enum MissingCtors<'tcx> {\n // to compute the full set.)\n fn compute_missing_ctors<'a, 'tcx: 'a>(\n     info: MissingCtorsInfo,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     all_ctors: &Vec<Constructor<'tcx>>,\n     used_ctors: &Vec<Constructor<'tcx>>,\n ) -> MissingCtors<'tcx> {\n@@ -1476,7 +1476,10 @@ fn slice_pat_covered_by_const<'tcx>(\n \n // Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n // constructor is a range or constant with an integer type.\n-fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n+fn should_treat_range_exhaustively(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+    ctor: &Constructor<'tcx>,\n+) -> bool {\n     let ty = match ctor {\n         ConstantValue(value) => value.ty,\n         ConstantRange(_, _, ty, _) => ty,\n@@ -1522,7 +1525,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n /// merging operation depicted above.)\n fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -1600,7 +1603,7 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n \n /// Checks whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &'p Pattern<'tcx>,\n ) -> Option<SmallVec<[&'p Pattern<'tcx>; 2]>> {\n@@ -1628,7 +1631,7 @@ fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n }\n \n fn constructor_covered_by_range<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &Pattern<'tcx>,\n ) -> Result<bool, ErrorReported> {"}, {"sha": "fa71611e230bfd0e59023f84be39fc4ef99a0a0b", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -26,7 +26,7 @@ use std::slice;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n-pub(crate) fn check_match<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub(crate) fn check_match<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     let body_id = if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n         tcx.hir().body_owned_by(id)\n     } else {\n@@ -48,7 +48,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n }\n \n struct MatchVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body_owner: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "00c1568ebe9147113de3f6bd594641c158be8720", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -327,15 +327,15 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n }\n \n pub struct PatternContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n     pub errors: Vec<PatternError>,\n }\n \n impl<'a, 'tcx> Pattern<'tcx> {\n-    pub fn from_hir(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn from_hir(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                     param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n                     tables: &'a ty::TypeckTables<'tcx>,\n                     pat: &'tcx hir::Pat) -> Self {\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> Pattern<'tcx> {\n }\n \n impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n                tables: &'a ty::TypeckTables<'tcx>) -> Self {\n         PatternContext {\n@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n }\n \n impl UserAnnotatedTyHelpers<'tcx, 'tcx> for PatternContext<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -1243,7 +1243,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n }\n \n pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n     ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,"}, {"sha": "32ea39e35a5e5a0fab83da163386143e1527846f", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::ty::{self, CanonicalUserType, TyCtxt, UserType};\n \n crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx>;\n \n     fn tables(&self) -> &ty::TypeckTables<'tcx>;\n "}, {"sha": "fbacdf6cd93bbf80629c9206df2a9db05788a85b", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::CastKind;\n \n use super::{InterpretCx, Machine, PlaceTy, OpTy, Immediate};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) |"}, {"sha": "f085580f68cc7e403d6bb82819aa00dcc550646b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -26,18 +26,18 @@ use super::{\n     Memory, Machine\n };\n \n-pub struct InterpretCx<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n+pub struct InterpretCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n-    pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxtAt<'tcx, 'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n \n     /// The virtual memory system.\n-    pub(crate) memory: Memory<'a, 'mir, 'tcx, M>,\n+    pub(crate) memory: Memory<'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>>,\n@@ -160,34 +160,34 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for InterpretCx<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+    for InterpretCx<'mir, 'tcx, M>\n {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'a, 'mir, 'tcx, M>\n-    where M: Machine<'a, 'mir, 'tcx>\n+impl<'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>\n {\n     #[inline]\n-    fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n+    fn tcx<'d>(&'d self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         *self.tcx\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpretCx<'a, 'mir, 'tcx, M>\n-    where M: Machine<'a, 'mir, 'tcx>\n+impl<'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpretCx<'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>\n {\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n-    for InterpretCx<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n+    for InterpretCx<'mir, 'tcx, M>\n {\n     type Ty = Ty<'tcx>;\n     type TyLayout = InterpResult<'tcx, TyLayout<'tcx>>;\n@@ -199,9 +199,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n     }\n }\n \n-impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     pub fn new(\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n     ) -> Self {\n@@ -216,12 +216,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     }\n \n     #[inline(always)]\n-    pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n+    pub fn memory(&self) -> &Memory<'mir, 'tcx, M> {\n         &self.memory\n     }\n \n     #[inline(always)]\n-    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n+    pub fn memory_mut(&mut self) -> &mut Memory<'mir, 'tcx, M> {\n         &mut self.memory\n     }\n "}, {"sha": "beb5049307117c0325145a7adefde39426d8916d", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -39,7 +39,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "5ef5899e60eef3cb0ad45735cb6fb2f35770e642", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -9,12 +9,12 @@ use rustc::hir::def_id::CrateNum;\n use std::fmt::Write;\n use rustc::mir::interpret::{Allocation, ConstValue};\n \n-struct AbsolutePathPrinter<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct AbsolutePathPrinter<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     path: String,\n }\n \n-impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n     type Error = std::fmt::Error;\n \n     type Path = Self;\n@@ -23,7 +23,7 @@ impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -167,7 +167,7 @@ impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n         }\n     }\n }\n-impl PrettyPrinter<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+impl PrettyPrinter<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n     fn region_should_not_be_omitted(\n         &self,\n         _region: ty::Region<'_>,\n@@ -204,15 +204,15 @@ impl PrettyPrinter<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n     }\n }\n \n-impl Write for AbsolutePathPrinter<'_, '_> {\n+impl Write for AbsolutePathPrinter<'_> {\n     fn write_str(&mut self, s: &str) -> std::fmt::Result {\n         Ok(self.path.push_str(s))\n     }\n }\n \n /// Produces an absolute path representation of the given type. See also the documentation on\n /// `std::any::type_name`\n-pub fn type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n+pub fn type_name<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n     let alloc = alloc_type_name(tcx, ty);\n     tcx.mk_const(ty::Const {\n         val: ConstValue::Slice {\n@@ -226,7 +226,7 @@ pub fn type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx t\n \n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n pub(super) fn alloc_type_name<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     ty: Ty<'tcx>\n ) -> &'tcx Allocation {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;"}, {"sha": "32ab29114f2cd9ea8a1b116fd4ade802d461f1c7", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -58,7 +58,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied.\n-pub trait Machine<'a, 'mir, 'tcx>: Sized {\n+pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + MayLeak + Eq + 'static;\n \n@@ -95,11 +95,11 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Whether to enforce the validity invariant\n-    fn enforce_validity(ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool;\n+    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n+    fn before_terminator(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -112,7 +112,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n     /// was used.\n     fn find_fn(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n@@ -122,7 +122,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n@@ -137,23 +137,23 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n     fn find_foreign_static(\n         def_id: DefId,\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx, 'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n     fn ptr_op(\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &InterpretCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx>;\n \n@@ -193,7 +193,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Executes a retagging operation\n     #[inline]\n     fn retag(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n@@ -202,12 +202,12 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n \n     /// Called immediately before a new stack frame got pushed\n     fn stack_push(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         extra: Self::FrameExtra,\n     ) -> InterpResult<'tcx>;\n }"}, {"sha": "8f941ed5c6235cfd34e8fdd4d11f5d410b7eac0a", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -45,7 +45,7 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n \n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g., `get`) call a `Machine` hook.\n-pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n+pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Allocations local to this instance of the miri engine. The kind\n     /// helps ensure that the same mechanism is used for allocation and\n     /// deallocation. When an allocation is not found here, it is a\n@@ -66,11 +66,11 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub(super) tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+    pub(super) tcx: TyCtxtAt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for Memory<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+    for Memory<'mir, 'tcx, M>\n {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n@@ -80,12 +80,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n \n // FIXME: Really we shouldn't clone memory, ever. Snapshot machinery should instead\n // carefully copy only the reachable parts.\n-impl<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M>\n     Clone\n for\n-    Memory<'a, 'mir, 'tcx, M>\n+    Memory<'mir, 'tcx, M>\n where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    M: Machine<'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     fn clone(&self) -> Self {\n@@ -98,8 +98,8 @@ where\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>) -> Self {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+    pub fn new(tcx: TyCtxtAt<'tcx, 'tcx>) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n@@ -312,7 +312,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Allocation accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Helper function to obtain the global (tcx) allocation for a static.\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n@@ -329,7 +329,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// another static), those inner references only exist in \"resolved\" form.\n     fn get_static_alloc(\n         id: AllocId,\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx, 'tcx>,\n         memory_extra: &M::MemoryExtra,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n@@ -623,7 +623,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Byte Accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn read_bytes(\n         &self,\n         ptr: Scalar<M::PointerTag>,\n@@ -639,9 +639,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Interning (for CTFE)\n-impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M> Memory<'mir, 'tcx, M>\n where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    M: Machine<'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n@@ -689,7 +689,7 @@ where\n }\n \n /// Reading and writing.\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn copy(\n         &mut self,\n         src: Scalar<M::PointerTag>,\n@@ -806,7 +806,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Undefined bytes\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     // FIXME: Add a fast version for the common, nonoverlapping case\n     fn copy_undef_mask(\n         &mut self,"}, {"sha": "87537ba57ae556f0f82acb0b20819b9dea9f83f6", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -211,7 +211,7 @@ pub(super) fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace("}, {"sha": "e8a691733791a70f9ce17f544110a1e0c2ca7bfb", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -7,7 +7,7 @@ use rustc::mir::interpret::{InterpResult, Scalar};\n use super::{InterpretCx, PlaceTy, Immediate, Machine, ImmTy};\n \n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -36,7 +36,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "f5d30d2aeb35147e5063b81794bb03a408f7e7a2", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -290,11 +290,11 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl<'a, 'mir, 'tcx, Tag, M> InterpretCx<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, Tag, M> InterpretCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n+    M: Machine<'mir, 'tcx, PointerTag=Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n     M::AllocExtra: AllocationExtra<Tag>,\n@@ -397,7 +397,7 @@ where\n         &self,\n         base: MPlaceTy<'tcx, Tag>,\n     ) ->\n-        InterpResult<'tcx, impl Iterator<Item=InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n+        InterpResult<'tcx, impl Iterator<Item=InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {"}, {"sha": "6e687af3119e33ab9a593995cc8154a6e02ad29e", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -28,7 +28,7 @@ use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef\n use crate::const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n-pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir> {\n+pub(crate) struct InfiniteLoopDetector<'mir, 'tcx> {\n     /// The set of all `InterpSnapshot` *hashes* observed by this detector.\n     ///\n     /// When a collision occurs in this table, we store the full snapshot in\n@@ -40,16 +40,16 @@ pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir> {\n     /// An `InterpSnapshot` will only be fully cloned once it has caused a\n     /// collision in `hashes`. As a result, the detector must observe at least\n     /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<InterpSnapshot<'a, 'mir, 'tcx>>,\n+    snapshots: FxHashSet<InterpSnapshot<'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n+impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx>\n {\n     pub fn observe_and_analyze<'b>(\n         &mut self,\n-        tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         span: Span,\n-        memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>],\n     ) -> InterpResult<'tcx, ()> {\n         // Compute stack's hash before copying anything\n@@ -373,8 +373,8 @@ impl_stable_hash_for!(struct LocalState<'tcx> {\n     layout -> _,\n });\n \n-impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n-    for Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>\n+impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n+    for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n {\n     fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n         self.get(*id).ok()\n@@ -384,15 +384,14 @@ impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n /// The virtual machine state during const-evaluation at a given point in time.\n /// We assume the `CompileTimeInterpreter` has no interesting extra state that\n /// is worth considering here.\n-struct InterpSnapshot<'a, 'mir, 'tcx: 'a + 'mir> {\n-    memory: Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+struct InterpSnapshot<'mir, 'tcx> {\n+    memory: Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx: 'a + 'mir> InterpSnapshot<'a, 'mir, 'tcx>\n-{\n+impl InterpSnapshot<'mir, 'tcx> {\n     fn new(\n-        memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>]\n     ) -> Self {\n         InterpSnapshot {\n@@ -411,8 +410,7 @@ impl<'a, 'mir, 'tcx: 'a + 'mir> InterpSnapshot<'a, 'mir, 'tcx>\n \n }\n \n-impl<'a, 'mir, 'tcx> Hash for InterpSnapshot<'a, 'mir, 'tcx>\n-{\n+impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n         let mut hcx = self.memory.tcx.get_stable_hashing_context();\n@@ -422,17 +420,15 @@ impl<'a, 'mir, 'tcx> Hash for InterpSnapshot<'a, 'mir, 'tcx>\n     }\n }\n \n-impl_stable_hash_for!(impl<> for struct InterpSnapshot<'_, 'mir, 'tcx> {\n+impl_stable_hash_for!(impl<> for struct InterpSnapshot<'mir, 'tcx> {\n     // Not hashing memory: Avoid hashing memory all the time during execution\n     memory -> _,\n     stack,\n });\n \n-impl<'a, 'mir, 'tcx> Eq for InterpSnapshot<'a, 'mir, 'tcx>\n-{}\n+impl<'mir, 'tcx> Eq for InterpSnapshot<'mir, 'tcx> {}\n \n-impl<'a, 'mir, 'tcx> PartialEq for InterpSnapshot<'a, 'mir, 'tcx>\n-{\n+impl<'mir, 'tcx> PartialEq for InterpSnapshot<'mir, 'tcx> {\n     fn eq(&self, other: &Self) -> bool {\n         // FIXME: This looks to be a *ridiculously expensive* comparison operation.\n         // Doesn't this make tons of copies?  Either `snapshot` is very badly named,"}, {"sha": "2f99973b90d4a784331004d697de927a9a9c1a02", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -35,7 +35,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     pub fn run(&mut self) -> InterpResult<'tcx> {\n         while self.step()? {}\n         Ok(())"}, {"sha": "316a95e9400b45b10a341a2520a043bf1bf916a4", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -11,7 +11,7 @@ use super::{\n     InterpretCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {"}, {"sha": "4ae0ee530553c0fe56a3b132800af053cab9916c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -4,7 +4,7 @@ use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n \n use super::{InterpretCx, InterpError, Machine, MemoryKind};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "ef11fce513cd5f0297f246d9c80598ed4274f254", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -149,17 +149,17 @@ fn wrapping_range_format(r: &RangeInclusive<u128>, max_hi: u128) -> String {\n     }\n }\n \n-struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a, 'mir, 'tcx>+'rt> {\n+struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// The `path` may be pushed to, but the part that is present when a function\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n     ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n     const_mode: bool,\n-    ecx: &'rt InterpretCx<'a, 'mir, 'tcx, M>,\n+    ecx: &'rt InterpretCx<'mir, 'tcx, M>,\n }\n \n-impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, 'mir, 'tcx, M> {\n+impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n     fn aggregate_field_path_elem(\n         &mut self,\n         layout: TyLayout<'tcx>,\n@@ -235,13 +235,13 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n     }\n }\n \n-impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n-    ValueVisitor<'a, 'mir, 'tcx, M> for ValidityVisitor<'rt, 'a, 'mir, 'tcx, M>\n+impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>>\n+    ValueVisitor<'mir, 'tcx, M> for ValidityVisitor<'rt, 'mir, 'tcx, M>\n {\n     type V = OpTy<'tcx, M::PointerTag>;\n \n     #[inline(always)]\n-    fn ecx(&self) -> &InterpretCx<'a, 'mir, 'tcx, M> {\n+    fn ecx(&self) -> &InterpretCx<'mir, 'tcx, M> {\n         &self.ecx\n     }\n \n@@ -607,7 +607,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout."}, {"sha": "accf9914e0d0e136c193044e06e5330512c26d84", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -14,15 +14,15 @@ use super::{\n // A thing that we can project into, and that has a layout.\n // This wouldn't have to depend on `Machine` but with the current type inference,\n // that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n-pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n+pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy\n {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyLayout<'tcx>;\n \n     /// Makes this into an `OpTy`.\n     fn to_op(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n@@ -31,21 +31,21 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     /// Projects to the given enum variant.\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self>;\n }\n \n // Operands and memory-places are both values.\n // Places in general are not due to `place_field` having to do `force_allocation`.\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     for OpTy<'tcx, M::PointerTag>\n {\n     #[inline(always)]\n@@ -56,7 +56,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        _ecx: &InterpretCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self)\n     }\n@@ -69,7 +69,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.operand_downcast(self, variant)\n@@ -78,13 +78,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n     }\n }\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     for MPlaceTy<'tcx, M::PointerTag>\n {\n     #[inline(always)]\n@@ -95,7 +95,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        _ecx: &InterpretCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n@@ -108,7 +108,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_downcast(self, variant)\n@@ -117,7 +117,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n@@ -127,12 +127,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n macro_rules! make_value_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         // How to traverse a value and what to do when we are at the leaves.\n-        pub trait $visitor_trait_name<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n-            type V: Value<'a, 'mir, 'tcx, M>;\n+        pub trait $visitor_trait_name<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n+            type V: Value<'mir, 'tcx, M>;\n \n             /// The visitor must have an `InterpretCx` in it.\n             fn ecx(&$($mutability)? self)\n-                -> &$($mutability)? InterpretCx<'a, 'mir, 'tcx, M>;\n+                -> &$($mutability)? InterpretCx<'mir, 'tcx, M>;\n \n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors."}, {"sha": "7e637a4130dc14c435d4ab5840518f2c18fc02b4", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -7,7 +7,7 @@ use rustc::mir::{self, Body, TerminatorKind};\n use rustc::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n \n-pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn check(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n              body: &Body<'tcx>,\n              def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -17,7 +17,7 @@ pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                         fn_kind: FnKind<'_>,\n                                         body: &Body<'tcx>,\n                                         def_id: DefId) {"}, {"sha": "87aec1a22d930c562d70161f0ec1b83f9e7b9f28", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -281,7 +281,7 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n }\n \n-pub fn collect_crate_mono_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn collect_crate_mono_items<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                           mode: MonoItemCollectionMode)\n                                           -> (FxHashSet<MonoItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n@@ -315,7 +315,7 @@ pub fn collect_crate_mono_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                            mode: MonoItemCollectionMode)\n                            -> Vec<MonoItem<'tcx>> {\n     debug!(\"Collecting roots\");\n@@ -347,7 +347,7 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n // Collect all monomorphized items reachable from `starting_point`\n-fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                    starting_point: MonoItem<'tcx>,\n                                    visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n@@ -413,7 +413,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx, true));\n }\n \n-fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              caller: MonoItem<'tcx>,\n                              callees: &[MonoItem<'tcx>],\n                              inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>) {\n@@ -429,7 +429,7 @@ fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     inlining_map.lock_mut().record_accesses(caller, accesses);\n }\n \n-fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                    instance: Instance<'tcx>,\n                                    recursion_depths: &mut DefIdMap<usize>)\n                                    -> (DefId, usize) {\n@@ -463,7 +463,7 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (def_id, recursion_depth)\n }\n \n-fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                      instance: Instance<'tcx>)\n {\n     let type_length = instance.substs.types().flat_map(|ty| ty.walk()).count();\n@@ -515,7 +515,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &'a mir::Body<'tcx>,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n     param_substs: SubstsRef<'tcx>,\n@@ -679,7 +679,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             ty: Ty<'tcx>,\n                             is_direct_call: bool,\n                             output: &mut Vec<MonoItem<'tcx>>)\n@@ -688,7 +688,7 @@ fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     visit_instance_use(tcx, instance, is_direct_call, output);\n }\n \n-fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           is_direct_call: bool,\n                           output: &mut Vec<MonoItem<'tcx>>)\n@@ -702,7 +702,7 @@ fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 instance: ty::Instance<'tcx>,\n                                 is_direct_call: bool,\n                                 output: &mut Vec<MonoItem<'tcx>>)\n@@ -741,7 +741,7 @@ fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // Returns true if we should codegen an instance in the local crate.\n // Returns false if we can just link to the upstream crate and therefore don't\n // need a mono item.\n-fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n+fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n                                          -> bool {\n     let def_id = match instance.def {\n         ty::InstanceDef::Item(def_id) => def_id,\n@@ -776,7 +776,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n     }\n     return true;\n \n-    fn is_available_upstream_generic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn is_available_upstream_generic<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                def_id: DefId,\n                                                substs: SubstsRef<'tcx>)\n                                                -> bool {\n@@ -841,7 +841,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n ///\n /// Finally, there is also the case of custom unsizing coercions, e.g., for\n /// smart pointers such as `Rc` and `Arc`.\n-fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                             source_ty: Ty<'tcx>,\n                                             target_ty: Ty<'tcx>)\n                                             -> (Ty<'tcx>, Ty<'tcx>) {\n@@ -914,7 +914,7 @@ fn create_fn_mono_item<'tcx>(instance: Instance<'tcx>) -> MonoItem<'tcx> {\n \n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n-fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                   trait_ty: Ty<'tcx>,\n                                                   impl_ty: Ty<'tcx>,\n                                                   output: &mut Vec<MonoItem<'tcx>>) {\n@@ -948,14 +948,14 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // Root Collection\n //=-----------------------------------------------------------------------------\n \n-struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct RootCollector<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     mode: MonoItemCollectionMode,\n-    output: &'b mut Vec<MonoItem<'tcx>>,\n+    output: &'a mut Vec<MonoItem<'tcx>>,\n     entry_fn: Option<(DefId, EntryFnType)>,\n }\n \n-impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n+impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemKind::ExternCrate(..) |\n@@ -1044,7 +1044,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n+impl RootCollector<'_, 'v> {\n     fn is_root(&self, def_id: DefId) -> bool {\n         !item_requires_monomorphization(self.tcx, def_id) && match self.mode {\n             MonoItemCollectionMode::Eager => {\n@@ -1107,12 +1107,12 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-fn item_requires_monomorphization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn item_requires_monomorphization<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     let generics = tcx.generics_of(def_id);\n     generics.requires_monomorphization(tcx)\n }\n \n-fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                  item: &'tcx hir::Item,\n                                                  output: &mut Vec<MonoItem<'tcx>>) {\n     match item.node {\n@@ -1177,7 +1177,7 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n /// Scan the miri alloc in order to find function calls, closures, and drop-glue\n fn collect_miri<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n@@ -1207,7 +1207,7 @@ fn collect_miri<'a, 'tcx>(\n }\n \n /// Scan the MIR in order to find function calls, closures, and drop-glue\n-fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 instance: Instance<'tcx>,\n                                 output: &mut Vec<MonoItem<'tcx>>)\n {\n@@ -1237,7 +1237,7 @@ fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                               def_id: DefId)\n                               -> String {\n     let mut output = String::new();\n@@ -1247,7 +1247,7 @@ fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn collect_const<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     constant: &'tcx ty::Const<'tcx>,\n     param_substs: SubstsRef<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,"}, {"sha": "f23d98cfe1cd411c98f53725df4e5c97dd2f1324", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -35,7 +35,7 @@ pub enum InstantiationMode {\n     LocalCopy,\n }\n \n-pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n+pub trait MonoItemExt<'tcx>: fmt::Debug {\n     fn as_mono_item(&self) -> &MonoItem<'tcx>;\n \n     fn is_generic_fn(&self) -> bool {\n@@ -48,7 +48,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n+    fn symbol_name(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> ty::SymbolName {\n         match *self.as_mono_item() {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => {\n@@ -63,7 +63,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         }\n     }\n     fn instantiation_mode(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                           -> InstantiationMode {\n         let inline_in_all_cgus =\n             tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n@@ -108,7 +108,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n+    fn explicit_linkage(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Option<Linkage> {\n         let def_id = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => instance.def_id(),\n             MonoItem::Static(def_id) => def_id,\n@@ -144,7 +144,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     /// Similarly, if a vtable method has such a signature, and therefore can't\n     /// be used, we can just not emit it and have a placeholder (a null pointer,\n     /// which will never be accessed) in its place.\n-    fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+    fn is_instantiable(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n@@ -156,7 +156,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n     }\n \n-    fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, debug: bool) -> String {\n+    fn to_string(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>, debug: bool) -> String {\n         return match *self.as_mono_item() {\n             MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance, debug)\n@@ -170,7 +170,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             }\n         };\n \n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                         prefix: &str,\n                                         instance: Instance<'tcx>,\n                                         debug: bool)\n@@ -183,7 +183,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+    fn local_span(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Option<Span> {\n         match *self.as_mono_item() {\n             MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir().as_local_hir_id(def.def_id())\n@@ -198,7 +198,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     }\n }\n \n-impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n+impl MonoItemExt<'tcx> for MonoItem<'tcx> {\n     fn as_mono_item(&self) -> &MonoItem<'tcx> {\n         self\n     }"}, {"sha": "2a349077ddb3fb6ff6c7aa1c70230c990550901b", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n pub mod collector;\n pub mod partitioning;\n \n-pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                            source_ty: Ty<'tcx>,\n                                            target_ty: Ty<'tcx>)\n                                            -> CustomCoerceUnsized {"}, {"sha": "c6826393585ac9271e7934064242b8c323beefb7", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -121,11 +121,11 @@ pub enum PartitioningStrategy {\n }\n \n // Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_, '_>) -> InternedString {\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_>) -> InternedString {\n     name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n-pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                               mono_items: I,\n                               strategy: PartitioningStrategy,\n                               inlining_map: &InliningMap<'tcx>)\n@@ -201,7 +201,7 @@ struct PostInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                              mono_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = MonoItem<'tcx>>\n@@ -276,7 +276,7 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn mono_item_linkage_and_visibility(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     mono_item: &MonoItem<'tcx>,\n     can_be_internalized: &mut bool,\n     export_generics: bool,\n@@ -294,7 +294,7 @@ fn mono_item_linkage_and_visibility(\n }\n \n fn mono_item_visibility(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     mono_item: &MonoItem<'tcx>,\n     can_be_internalized: &mut bool,\n     export_generics: bool,\n@@ -463,7 +463,7 @@ fn default_visibility(tcx: TyCtxt<'_, '_, '_>, id: DefId, is_generic: bool) -> V\n     }\n }\n \n-fn merge_codegen_units<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+fn merge_codegen_units<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n                              target_cgu_count: usize) {\n     assert!(target_cgu_count >= 1);\n@@ -585,7 +585,7 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n     }\n }\n \n-fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                  partitioning: &mut PostInliningPartitioning<'tcx>,\n                                  inlining_map: &InliningMap<'tcx>) {\n     if partitioning.codegen_units.len() == 1 {\n@@ -650,7 +650,7 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                 mono_item: MonoItem<'tcx>)\n                                                 -> Option<DefId> {\n     match mono_item {\n@@ -699,7 +699,7 @@ fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n type CguNameCache = FxHashMap<(DefId, bool), InternedString>;\n \n fn compute_codegen_unit_name(tcx: TyCtxt<'_, '_, '_>,\n-                             name_builder: &mut CodegenUnitNameBuilder<'_, '_, '_>,\n+                             name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n                              def_id: DefId,\n                              volatile: bool,\n                              cache: &mut CguNameCache)\n@@ -752,13 +752,13 @@ fn compute_codegen_unit_name(tcx: TyCtxt<'_, '_, '_>,\n     }).clone()\n }\n \n-fn numbered_codegen_unit_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_, '_>,\n+fn numbered_codegen_unit_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n                               index: usize)\n                               -> InternedString {\n     name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                label: &str,\n                                cgus: I)\n     where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n@@ -787,7 +787,7 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n #[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mono_items: I)\n+fn assert_symbols_are_distinct<'a, 'tcx: 'a, I>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, mono_items: I)\n     where I: Iterator<Item=&'a MonoItem<'tcx>>\n {\n     let mut symbols: Vec<_> = mono_items.map(|mono_item| {\n@@ -831,7 +831,7 @@ fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mono_it\n }\n \n fn collect_and_partition_mono_items<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     cnum: CrateNum,\n ) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n {"}, {"sha": "b63ddf259e8054f972f7971a7eb723b0d143b9ce", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -26,7 +26,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn make_shim<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                        instance: ty::InstanceDef<'tcx>)\n                        -> &'tcx Body<'tcx>\n {\n@@ -166,7 +166,7 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n         .collect()\n }\n \n-fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              def_id: DefId,\n                              ty: Option<Ty<'tcx>>)\n                              -> Body<'tcx>\n@@ -258,7 +258,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub struct DropShimElaborator<'a, 'tcx: 'a> {\n     pub body: &'a Body<'tcx>,\n     pub patch: MirPatch<'tcx>,\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -273,7 +273,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n     fn body(&self) -> &'a Body<'tcx> { self.body }\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> { self.tcx }\n     fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n \n     fn drop_style(&self, _path: Self::Path, mode: DropFlagMode) -> DropStyle {\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n }\n \n /// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n-fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                               def_id: DefId,\n                               self_ty: Ty<'tcx>)\n                               -> Body<'tcx>\n@@ -340,17 +340,17 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     builder.into_mir()\n }\n \n-struct CloneShimBuilder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct CloneShimBuilder<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     span: Span,\n     sig: ty::FnSig<'tcx>,\n }\n \n-impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl CloneShimBuilder<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n            def_id: DefId,\n            self_ty: Ty<'tcx>) -> Self {\n         // we must subst the self_ty because it's\n@@ -691,7 +691,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n ///\n /// If `untuple_args` is a vec of types, the second argument of the\n /// function will be untupled as these types.\n-fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              def_id: DefId,\n                              rcvr_adjustment: Adjustment,\n                              call_kind: CallKind,\n@@ -842,7 +842,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     body\n }\n \n-pub fn build_adt_ctor<'gcx>(tcx: TyCtxt<'_, 'gcx, 'gcx>, ctor_id: DefId) -> &'gcx Body<'gcx> {\n+pub fn build_adt_ctor<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, ctor_id: DefId) -> &'tcx Body<'tcx> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n     let span = tcx.hir().span_if_local(ctor_id)"}, {"sha": "59203fe586a6310b01d292759519381898824314", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -32,7 +32,7 @@ pub use self::AddCallGuards::*;\n \n impl MirPass for AddCallGuards {\n     fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         self.add_call_guards(body);"}, {"sha": "71a92f088e3822e384ca52ff595eac544931e326", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -41,7 +41,7 @@ pub struct AddMovesForPackedDrops;\n \n impl MirPass for AddMovesForPackedDrops {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>)\n     {\n@@ -51,7 +51,7 @@ impl MirPass for AddMovesForPackedDrops {\n }\n \n pub fn add_moves_for_packed_drops<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &mut Body<'tcx>,\n     def_id: DefId)\n {\n@@ -60,7 +60,7 @@ pub fn add_moves_for_packed_drops<'a, 'tcx>(\n }\n \n fn add_moves_for_packed_drops_patch<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     def_id: DefId)\n     -> MirPatch<'tcx>\n@@ -91,7 +91,7 @@ fn add_moves_for_packed_drops_patch<'a, 'tcx>(\n }\n \n fn add_move_for_packed_drop<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     patch: &mut MirPatch<'tcx>,\n     terminator: &Terminator<'tcx>,"}, {"sha": "8918a90834020fa9129bece0c6f29ecce9d9c973", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -48,7 +48,7 @@ fn is_stable<'tcx>(\n \n /// Determine whether this type may have a reference in it, recursing below compound types but\n /// not below references.\n-fn may_have_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+fn may_have_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> bool {\n     match ty.sty {\n         // Primitive types that are not references\n         ty::Bool | ty::Char |\n@@ -75,7 +75,7 @@ fn may_have_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n \n impl MirPass for AddRetag {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>)\n     {"}, {"sha": "7721cae6d1009d67cc02d7802a4782a460ceba97", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -25,7 +25,7 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n     violations: Vec<UnsafetyViolation>,\n     source_info: SourceInfo,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     /// Mark an `unsafe` block as used, so we don't lint it.\n     used_unsafe: FxHashSet<hir::HirId>,\n@@ -38,7 +38,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         min_const_fn: bool,\n         body: &'a Body<'tcx>,\n         source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         // sanity check\n@@ -480,7 +480,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n     }\n }\n \n-fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                  def_id: DefId,\n                                  used_unsafe: &FxHashSet<hir::HirId>,\n                                  unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>)\n@@ -505,7 +505,7 @@ fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     hir::intravisit::Visitor::visit_body(&mut visitor, body);\n }\n \n-fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId)\n                                    -> UnsafetyCheckResult\n {\n     debug!(\"unsafety_violations({:?})\", def_id);\n@@ -546,7 +546,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     }\n }\n \n-fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     let lint_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap_or_else(||\n         bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n \n@@ -603,7 +603,7 @@ fn report_unused_unsafe(tcx: TyCtxt<'_, '_, '_>,\n     db.emit();\n }\n \n-fn builtin_derive_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n+fn builtin_derive_def_id<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     debug!(\"builtin_derive_def_id({:?})\", def_id);\n     if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n         if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n@@ -619,7 +619,7 @@ fn builtin_derive_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -\n     }\n }\n \n-pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n     // closures are handled by their parent fn."}, {"sha": "972f05c90847764fc3d8fd6dfd81660de50a204b", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -28,7 +28,7 @@ pub struct DeleteNonCodegenStatements;\n \n impl MirPass for CleanupNonCodegenStatements {\n     fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements;"}, {"sha": "1ec3e6e52aa0116f19b50712e7d0679459b827ba", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -32,7 +32,7 @@ pub struct ConstProp;\n \n impl MirPass for ConstProp {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n@@ -83,9 +83,9 @@ impl MirPass for ConstProp {\n type Const<'tcx> = OpTy<'tcx>;\n \n /// Finds optimization opportunities on the MIR.\n-struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n-    ecx: InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ConstPropagator<'mir, 'tcx> {\n+    ecx: InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     source: MirSource<'tcx>,\n     places: IndexVec<Local, Option<Const<'tcx>>>,\n     can_const_prop: IndexVec<Local, bool>,\n@@ -95,7 +95,7 @@ struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n     promoted: IndexVec<Promoted, Body<'tcx>>,\n }\n \n-impl<'a, 'b, 'tcx> LayoutOf for ConstPropagator<'a, 'b, 'tcx> {\n+impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -104,26 +104,26 @@ impl<'a, 'b, 'tcx> LayoutOf for ConstPropagator<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> HasDataLayout for ConstPropagator<'a, 'b, 'tcx> {\n+impl<'mir, 'tcx> HasDataLayout for ConstPropagator<'mir, 'tcx> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'a, 'b, 'tcx> {\n+impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n     #[inline]\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n+impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n         body: &mut Body<'tcx>,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         source: MirSource<'tcx>,\n-    ) -> ConstPropagator<'a, 'mir, 'tcx> {\n+    ) -> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id());\n         let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id()), param_env);\n         let can_const_prop = CanConstProp::check(body);\n@@ -599,7 +599,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     }\n }\n \n-fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n@@ -668,7 +668,7 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n     }\n }\n \n-impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n+impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     fn visit_constant(\n         &mut self,\n         constant: &mut Constant<'tcx>,"}, {"sha": "9b1f110520570bd18e41180a93a704e3bd3d5573", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -31,7 +31,7 @@ pub struct CopyPropagation;\n \n impl MirPass for CopyPropagation {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         // We only run when the MIR optimization level is > 1."}, {"sha": "7c52361de06413e7defa7d27bde758d12adaf960", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -7,7 +7,7 @@ pub struct Deaggregator;\n \n impl MirPass for Deaggregator {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();"}, {"sha": "7f971d51e2650ef6e2a1a5a26353d148a0090b28", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -19,7 +19,7 @@ impl MirPass for Marker {\n     }\n \n     fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n                           _body: &mut Body<'tcx>)\n     {\n@@ -38,7 +38,7 @@ impl fmt::Display for Disambiguator {\n }\n \n \n-pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              pass_num: &dyn fmt::Display,\n                              pass_name: &str,\n                              source: MirSource<'tcx>,\n@@ -56,7 +56,7 @@ pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub fn emit_mir<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     outputs: &OutputFilenames)\n     -> io::Result<()>\n {"}, {"sha": "1d23427bbe7bbea89712250a3978aaa0ef1e39c5", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -22,7 +22,7 @@ pub struct ElaborateDrops;\n \n impl MirPass for ElaborateDrops {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>)\n     {\n@@ -78,7 +78,7 @@ impl MirPass for ElaborateDrops {\n /// to not be reachable, because they are `drop` terminators\n /// that can't drop anything.\n fn find_dead_unwinds<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     def_id: hir::def_id::DefId,\n     env: &MoveDataParamEnv<'tcx, 'tcx>)\n@@ -142,7 +142,7 @@ struct InitializationData {\n \n impl InitializationData {\n     fn apply_location<'a,'tcx>(&mut self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                body: &Body<'tcx>,\n                                env: &MoveDataParamEnv<'tcx, 'tcx>,\n                                loc: Location)\n@@ -190,7 +190,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n         self.ctxt.body\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.ctxt.tcx\n     }\n \n@@ -290,7 +290,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n }\n \n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n     flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,"}, {"sha": "9c7877e208adbae7783a1208ca4d9037371a80a1", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -10,19 +10,19 @@ use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, TyContext};\n use crate::transform::{MirPass, MirSource};\n \n-struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct EraseRegionsVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+impl EraseRegionsVisitor<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n             tcx,\n         }\n     }\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n+impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         *ty = self.tcx.erase_regions(ty);\n         self.super_ty(ty);\n@@ -51,7 +51,7 @@ pub struct EraseRegions;\n \n impl MirPass for EraseRegions {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_body(body);"}, {"sha": "8423696e64c9eee04337371db46c4a0b12eab8fb", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -168,8 +168,8 @@ struct SuspensionPoint {\n     storage_liveness: liveness::LiveVarSet,\n }\n \n-struct TransformVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct TransformVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     state_adt_ref: &'tcx AdtDef,\n     state_substs: SubstsRef<'tcx>,\n \n@@ -191,7 +191,7 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     new_ret_local: Local,\n }\n \n-impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n+impl TransformVisitor<'tcx> {\n     // Make a GeneratorState rvalue\n     fn make_state(&self, idx: VariantIdx, val: Operand<'tcx>) -> Rvalue<'tcx> {\n         let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None, None);\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n+impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -311,7 +311,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n }\n \n fn make_generator_state_argument_indirect<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                 def_id: DefId,\n                 body: &mut Body<'tcx>) {\n     let gen_ty = body.local_decls.raw[1].ty;\n@@ -336,7 +336,7 @@ fn make_generator_state_argument_indirect<'a, 'tcx>(\n }\n \n fn make_generator_state_argument_pinned<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                 body: &mut Body<'tcx>) {\n     let ref_gen_ty = body.local_decls.raw[1].ty;\n \n@@ -416,7 +416,7 @@ struct LivenessInfo {\n }\n \n fn locals_live_across_suspend_points(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n@@ -678,7 +678,7 @@ impl<'body, 'tcx: 'body, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     }\n }\n \n-fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             source: MirSource<'tcx>,\n                             upvars: &Vec<Ty<'tcx>>,\n                             interior: Ty<'tcx>,\n@@ -769,7 +769,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn insert_switch<'a, 'tcx>(body: &mut Body<'tcx>,\n                            cases: Vec<(usize, BasicBlock)>,\n-                           transform: &TransformVisitor<'a, 'tcx>,\n+                           transform: &TransformVisitor<'tcx>,\n                            default: TerminatorKind<'tcx>) {\n     let default_block = insert_term_block(body, default);\n     let (assign, discr) = transform.get_discr(body);\n@@ -797,7 +797,7 @@ fn insert_switch<'a, 'tcx>(body: &mut Body<'tcx>,\n     }\n }\n \n-fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                        def_id: DefId,\n                                        body: &mut Body<'tcx>) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n@@ -849,8 +849,8 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn create_generator_drop_shim<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                transform: &TransformVisitor<'a, 'tcx>,\n+                tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+                transform: &TransformVisitor<'tcx>,\n                 def_id: DefId,\n                 source: MirSource<'tcx>,\n                 gen_ty: Ty<'tcx>,\n@@ -939,7 +939,7 @@ fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) ->\n     term_block\n }\n \n-fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 body: &mut Body<'tcx>,\n                                 message: AssertMessage<'tcx>) -> BasicBlock {\n     let assert_block = BasicBlock::new(body.basic_blocks().len());\n@@ -970,8 +970,8 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn create_generator_resume_function<'a, 'tcx>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        transform: TransformVisitor<'a, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+        transform: TransformVisitor<'tcx>,\n         def_id: DefId,\n         source: MirSource<'tcx>,\n         body: &mut Body<'tcx>) {\n@@ -1043,7 +1043,7 @@ fn insert_clean_drop<'tcx>(body: &mut Body<'tcx>) -> BasicBlock {\n }\n \n fn create_cases<'a, 'tcx, F>(body: &mut Body<'tcx>,\n-                          transform: &TransformVisitor<'a, 'tcx>,\n+                          transform: &TransformVisitor<'tcx>,\n                           target: F) -> Vec<(usize, BasicBlock)>\n     where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n     let source_info = source_info(body);\n@@ -1084,7 +1084,7 @@ fn create_cases<'a, 'tcx, F>(body: &mut Body<'tcx>,\n \n impl MirPass for StateTransform {\n     fn run_pass<'a, 'tcx>(&self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                     source: MirSource<'tcx>,\n                     body: &mut Body<'tcx>) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {"}, {"sha": "6937e23d6d3ebfdd2bb9745f75f4cc6d9db0a4e3", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -39,7 +39,7 @@ struct CallSite<'tcx> {\n \n impl MirPass for Inline {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n@@ -48,12 +48,12 @@ impl MirPass for Inline {\n     }\n }\n \n-struct Inliner<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Inliner<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     source: MirSource<'tcx>,\n }\n \n-impl<'a, 'tcx> Inliner<'a, 'tcx> {\n+impl Inliner<'tcx> {\n     fn run_pass(&self, caller_body: &mut Body<'tcx>) {\n         // Keep a queue of callsites to try inlining on. We take\n         // advantage of the fact that queries detect cycles here to\n@@ -631,7 +631,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n     }\n }\n \n-fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())"}, {"sha": "c2bb2da85a89c539c3043ff634eec14a778978d1", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -13,7 +13,7 @@ pub struct InstCombine;\n \n impl MirPass for InstCombine {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n@@ -63,14 +63,14 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n }\n \n /// Finds optimization opportunities on the MIR.\n-struct OptimizationFinder<'b, 'a, 'tcx:'a+'b> {\n+struct OptimizationFinder<'b, 'tcx> {\n     body: &'b Body<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     optimizations: OptimizationList<'tcx>,\n }\n \n-impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n-    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> OptimizationFinder<'b, 'a, 'tcx> {\n+impl OptimizationFinder<'b, 'tcx> {\n+    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> OptimizationFinder<'b, 'tcx> {\n         OptimizationFinder {\n             body,\n             tcx,\n@@ -79,7 +79,7 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n+impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {"}, {"sha": "5a5c379027768a2d27dd868393ac49756a1bdca1", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -11,7 +11,7 @@ pub struct Lower128Bit;\n \n impl MirPass for Lower128Bit {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         let debugging_override = tcx.sess.opts.debugging_opts.lower_128bit_ops;\n@@ -25,7 +25,7 @@ impl MirPass for Lower128Bit {\n }\n \n impl Lower128Bit {\n-    fn lower_128bit_ops<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, body: &mut Body<'tcx>) {\n+    fn lower_128bit_ops<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>, body: &mut Body<'tcx>) {\n         let mut new_blocks = Vec::new();\n         let cur_len = body.basic_blocks().len();\n \n@@ -126,7 +126,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n     lhs: &Operand<'tcx>,\n     rhs: &Operand<'tcx>,\n     local_decls: &D,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n -> DefId\n     where D: HasLocalDecls<'tcx>\n {\n@@ -142,7 +142,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n     did\n }\n \n-fn lower_to<'a, 'tcx, D>(statement: &Statement<'tcx>, local_decls: &D, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+fn lower_to<'tcx, D>(statement: &Statement<'tcx>, local_decls: &D, tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n     -> Option<(LangItem, RhsKind)>\n     where D: HasLocalDecls<'tcx>\n {\n@@ -172,7 +172,7 @@ enum RhsKind {\n }\n \n impl RhsKind {\n-    fn ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn ty<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match *self {\n             RhsKind::Unchanged => None,\n             RhsKind::ForceU128 => Some(tcx.types.u128),"}, {"sha": "db0a8351119f3f1ec0661f24d5f3f566710c1b9d", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -50,13 +50,13 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     tcx.mir_keys(def_id.krate).contains(&def_id)\n }\n \n /// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n-fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n+fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, krate: CrateNum)\n                       -> &'tcx DefIdSet {\n     assert_eq!(krate, LOCAL_CRATE);\n \n@@ -68,7 +68,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n     // Additionally, tuple struct/variant constructors have MIR, but\n     // they don't have a BodyId, so we need to build them separately.\n     struct GatherCtors<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         set: &'a mut DefIdSet,\n     }\n     impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n@@ -95,7 +95,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n     tcx.arena.alloc(set)\n }\n \n-fn mir_built<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_built<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let mir = build::mir_build(tcx, def_id);\n     tcx.alloc_steal_mir(mir)\n }\n@@ -143,13 +143,13 @@ pub trait MirPass {\n     }\n \n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n                           body: &mut Body<'tcx>);\n }\n \n pub fn run_passes(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &mut Body<'tcx>,\n     instance: InstanceDef<'tcx>,\n     mir_phase: MirPhase,\n@@ -196,7 +196,7 @@ pub fn run_passes(\n     }\n }\n \n-fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_const<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n@@ -210,7 +210,7 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n     tcx.alloc_steal_mir(body)\n }\n \n-fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_validated(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind_by_hir_id(hir_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n@@ -227,7 +227,7 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     tcx.alloc_steal_mir(body)\n }\n \n-fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n+fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const"}, {"sha": "2d3823ae089ebc568c0fd4fece4b93b2110de71a", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -10,14 +10,14 @@ pub struct NoLandingPads;\n \n impl MirPass for NoLandingPads {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }\n \n-pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: &mut Body<'tcx>) {\n+pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         NoLandingPads.visit_body(body);\n     }"}, {"sha": "9c54f9f4cde340f86588e9b24687e3e14236d43e", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -148,7 +148,7 @@ pub fn collect_temps(body: &Body<'_>,\n }\n \n struct Promoter<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     source: &'a mut Body<'tcx>,\n     promoted: Body<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n }\n \n pub fn promote_candidates<'a, 'tcx>(body: &mut Body<'tcx>,\n-                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                     mut temps: IndexVec<Local, TempState>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested."}, {"sha": "1de94ff57b90ec4b3cd798ff4a3b77d65b9dafd2", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -124,7 +124,7 @@ impl<Q: Qualif, T> IndexMut<Q> for PerQualif<T> {\n }\n \n struct ConstCx<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n     body: &'a Body<'tcx>,\n@@ -652,7 +652,7 @@ impl Deref for Checker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n            def_id: DefId,\n            body: &'a Body<'tcx>,\n            mode: Mode)\n@@ -1472,7 +1472,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                               def_id: DefId)\n                               -> (u8, &'tcx BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n@@ -1493,7 +1493,7 @@ pub struct QualifyAndPromoteConstants;\n \n impl MirPass for QualifyAndPromoteConstants {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR."}, {"sha": "952d8f1ba08323bbad6bae2532a4fc3b18b8ed63", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -9,7 +9,7 @@ use syntax_pos::Span;\n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n pub fn is_min_const_fn(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n     body: &'a Body<'tcx>,\n ) -> McfResult {\n@@ -80,7 +80,7 @@ pub fn is_min_const_fn(\n }\n \n fn check_ty(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n     fn_def_id: DefId,\n@@ -129,7 +129,7 @@ fn check_ty(\n }\n \n fn check_rvalue(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     rvalue: &Rvalue<'tcx>,\n     span: Span,\n@@ -209,7 +209,7 @@ fn check_rvalue(\n }\n \n fn check_statement(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     statement: &Statement<'tcx>,\n ) -> McfResult {\n@@ -279,7 +279,7 @@ fn check_place(\n }\n \n fn check_terminator(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     terminator: &Terminator<'tcx>,\n ) -> McfResult {\n@@ -375,7 +375,7 @@ fn check_terminator(\n /// for being called from stable `const fn`s (`min_const_fn`).\n ///\n /// Adding more intrinsics requires sign-off from @rust-lang/lang.\n-fn is_intrinsic_whitelisted(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     match &tcx.item_name(def_id).as_str()[..] {\n         | \"size_of\"\n         | \"min_align_of\""}, {"sha": "11209a6d119c5eef5f83d3abd9428a73aa052dbf", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -10,7 +10,7 @@ use crate::util::patch::MirPatch;\n pub struct RemoveNoopLandingPads;\n \n pub fn remove_noop_landing_pads<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     body: &mut Body<'tcx>)\n {\n     if tcx.sess.no_landing_pads() {\n@@ -23,7 +23,7 @@ pub fn remove_noop_landing_pads<'a, 'tcx>(\n \n impl MirPass for RemoveNoopLandingPads {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         remove_noop_landing_pads(tcx, body);"}, {"sha": "ad9eab9f29be5e5064beb80dd91f28cda21e7ec6", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -25,7 +25,7 @@ use crate::dataflow::has_rustc_mir_with;\n pub struct SanityCheck;\n \n impl MirPass for SanityCheck {\n-    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n@@ -84,7 +84,7 @@ impl MirPass for SanityCheck {\n /// (If there are any calls to `rustc_peek` that do not match the\n /// expression form above, then that emits an error as well, but those\n /// errors are not intended to be used for unit tests.)\n-pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                 body: &Body<'tcx>,\n                                                 def_id: DefId,\n                                                 _attributes: &[ast::Attribute],\n@@ -101,7 +101,7 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                            body: &Body<'tcx>,\n                            results: &DataflowResults<'tcx, O>,\n                            bb: mir::BasicBlock) where\n@@ -214,7 +214,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       form `&expr`\"));\n }\n \n-fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                            terminator: &'a Option<mir::Terminator<'tcx>>)\n                            -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {"}, {"sha": "4968040182c6b87ee9772f08fc2f90d5728ecabb", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -58,7 +58,7 @@ impl MirPass for SimplifyCfg {\n     }\n \n     fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n@@ -297,7 +297,7 @@ pub struct SimplifyLocals;\n \n impl MirPass for SimplifyLocals {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         let mut marker = DeclMarker { locals: BitSet::new_empty(body.local_decls.len()) };"}, {"sha": "0cb971fd2cd85378d53920f553e6ea4a99b3f228", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -20,7 +20,7 @@ impl MirPass for SimplifyBranches {\n     }\n \n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         for block in body.basic_blocks_mut() {"}, {"sha": "add562723a5e8d4eccdcd4e4052df0c01d0e8065", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -38,7 +38,7 @@ pub struct UniformArrayMoveOut;\n \n impl MirPass for UniformArrayMoveOut {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n@@ -53,7 +53,7 @@ impl MirPass for UniformArrayMoveOut {\n struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n     body: &'a Body<'tcx>,\n     patch: &'a mut MirPatch<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n@@ -163,7 +163,7 @@ pub struct RestoreSubsliceArrayMoveOut;\n \n impl MirPass for RestoreSubsliceArrayMoveOut {\n     fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n                           body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);"}, {"sha": "c0f25de79300c0687d64e21d30728410bba932f4", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -4,7 +4,7 @@ use rustc::mir::*;\n /// Returns `true` if this place is allowed to be less aligned\n /// than its containing struct (because it is within a packed\n /// struct).\n-pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                   local_decls: &L,\n                                   param_env: ty::ParamEnv<'tcx>,\n                                   place: &Place<'tcx>)\n@@ -32,7 +32,7 @@ pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                  local_decls: &L,\n                                  place: &Place<'tcx>)\n                                  -> bool"}, {"sha": "6740fe5ff6ebdf86b15d1836b470fdedcf36b86e", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -788,25 +788,25 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> BorrowckErrors<'cx> for TyCtxt<'cx, 'gcx, 'tcx> {\n+impl BorrowckErrors<'tcx> for TyCtxt<'tcx, 'gcx, 'tcx> {\n     fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'tcx> {\n         self.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'cx> {\n+    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'tcx> {\n         self.sess.struct_span_err(sp, msg)\n     }\n \n     fn cancel_if_wrong_origin(\n         self,\n-        mut diag: DiagnosticBuilder<'cx>,\n+        mut diag: DiagnosticBuilder<'tcx>,\n         o: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'tcx> {\n         if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);\n         }"}, {"sha": "d18abeeeb15c40106ac63437cb46de067c3e3a65", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -75,7 +75,7 @@ pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n     fn body(&self) -> &'a Body<'tcx>;\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx>;\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n     fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle;\n@@ -126,7 +126,7 @@ where\n         place.ty(self.elaborator.body(), self.tcx()).ty\n     }\n \n-    fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.elaborator.tcx()\n     }\n "}, {"sha": "c77eac861ee684bdc27c830a2e47da58aeb5c95e", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -8,7 +8,7 @@ use std::io::{self, Write};\n use super::pretty::dump_mir_def_ids;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n+pub fn write_mir_graphviz<'tcx, W>(tcx: TyCtxt<'tcx, '_, 'tcx>,\n                                    single: Option<DefId>,\n                                    w: &mut W)\n                                    -> io::Result<()>\n@@ -32,7 +32,7 @@ pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n }\n \n /// Write a graphviz DOT graph of the MIR.\n-pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n+pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'tcx, '_, 'tcx>,\n                                       def_id: DefId,\n                                       body: &Body<'_>,\n                                       w: &mut W) -> io::Result<()>\n@@ -133,7 +133,7 @@ fn write_edges<W: Write>(source: BasicBlock, body: &Body<'_>, w: &mut W) -> io::\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                                def_id: DefId,\n                                                body: &Body<'_>,\n                                                w: &mut W)"}, {"sha": "33aedd065c3cae632bb1629ccf597b7c6875d3b8", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -255,7 +255,7 @@ fn block<'tcx>(\n }\n \n pub fn dump_mir<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n@@ -272,7 +272,7 @@ pub fn dump_mir<'a, 'tcx>(\n }\n \n fn dump_matched_mir_node<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource<'tcx>,\n@@ -295,7 +295,7 @@ fn dump_matched_mir_node<'a, 'tcx>(\n }\n \n pub fn write_mir_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     w: &mut dyn Write,"}, {"sha": "441ef683673ba4e18de8a17795bd739ce8f9fbe7", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -22,7 +22,7 @@ pub use self::graphviz::write_node_label as write_graphviz_node_label;\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n pub fn suggest_ref_mut<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     binding_span: Span,\n ) -> Option<(String)> {\n     let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();"}, {"sha": "4dd892ac88b7b1e57f849b9b7abc3cbebf3fb06b", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -63,7 +63,7 @@ pub enum PassWhere {\n /// - `foo & nll | bar & typeck` == match if `foo` and `nll` both appear in the name\n ///   or `typeck` and `bar` both appear in the name.\n pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n@@ -94,7 +94,7 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n }\n \n pub fn dump_enabled<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n ) -> bool {\n@@ -118,7 +118,7 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n // run while we are already attempting to evaluate `type_of`.\n \n fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     node_path: &str,\n@@ -241,7 +241,7 @@ pub(crate) fn create_dump_file(\n \n /// Write out a human-readable textual representation for the given MIR.\n pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     single: Option<DefId>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n@@ -280,7 +280,7 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n }\n \n pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     extra_data: &mut F,\n@@ -304,7 +304,7 @@ where\n \n /// Write out a human-readable textual representation for the given basic block.\n pub fn write_basic_block<'cx, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     block: BasicBlock,\n     body: &Body<'tcx>,\n     extra_data: &mut F,\n@@ -371,12 +371,12 @@ where\n /// information. There's often a lot of little things \"nuzzled up\" in\n /// a statement.\n fn write_extra<'cx, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     write: &mut dyn Write,\n     mut visit_op: F,\n ) -> io::Result<()>\n where\n-    F: FnMut(&mut ExtraComments<'cx, 'gcx, 'tcx>),\n+    F: FnMut(&mut ExtraComments<'gcx, 'tcx>),\n {\n     let mut extra_comments = ExtraComments {\n         _tcx: tcx,\n@@ -389,20 +389,20 @@ where\n     Ok(())\n }\n \n-struct ExtraComments<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    _tcx: TyCtxt<'cx, 'gcx, 'tcx>, // don't need it now, but bet we will soon\n+struct ExtraComments<'gcx, 'tcx> {\n+    _tcx: TyCtxt<'tcx, 'gcx, 'tcx>, // don't need it now, but bet we will soon\n     comments: Vec<String>,\n }\n \n-impl<'cx, 'gcx, 'tcx> ExtraComments<'cx, 'gcx, 'tcx> {\n+impl ExtraComments<'gcx, 'tcx> {\n     fn push(&mut self, lines: &str) {\n         for line in lines.split('\\n') {\n             self.comments.push(line.to_string());\n         }\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n+impl Visitor<'tcx> for ExtraComments<'gcx, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n         let Constant { span, ty, user_ty, literal } = constant;\n@@ -539,7 +539,7 @@ fn write_scope_tree(\n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'_>,\n     w: &mut dyn Write,"}, {"sha": "27888ca92ee8dfef35761588959ff954cf47cdb4", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::TyCtxt;\n use syntax::ast::Attribute;\n use syntax::symbol::sym;\n \n-pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     if tcx.features().rustc_attrs {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n         tcx.hir()\n@@ -23,11 +23,11 @@ pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-struct VarianceTest<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct VarianceTest<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n@@ -44,7 +44,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {}\n }\n \n-impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n+impl VarianceTest<'tcx> {\n     fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item, attr: &Attribute) {\n         let tcx = self.tcx;\n         let param_env = self.tcx.param_env(item_def_id);\n@@ -104,12 +104,12 @@ impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n     }\n }\n \n-struct UnwrapLayoutCx<'me, 'tcx> {\n-    tcx: TyCtxt<'me, 'tcx, 'tcx>,\n+struct UnwrapLayoutCx<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n }\n \n-impl<'me, 'tcx> LayoutOf for UnwrapLayoutCx<'me, 'tcx> {\n+impl LayoutOf for UnwrapLayoutCx<'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;\n \n@@ -118,19 +118,19 @@ impl<'me, 'tcx> LayoutOf for UnwrapLayoutCx<'me, 'tcx> {\n     }\n }\n \n-impl<'me, 'tcx> HasTyCtxt<'tcx> for UnwrapLayoutCx<'me, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+impl HasTyCtxt<'tcx> for UnwrapLayoutCx<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'me, 'tcx> HasParamEnv<'tcx> for UnwrapLayoutCx<'me, 'tcx> {\n+impl HasParamEnv<'tcx> for UnwrapLayoutCx<'tcx> {\n     fn param_env(&self) -> ParamEnv<'tcx> {\n         self.param_env\n     }\n }\n \n-impl<'me, 'tcx> HasDataLayout for UnwrapLayoutCx<'me, 'tcx> {\n+impl HasDataLayout for UnwrapLayoutCx<'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.tcx.data_layout()\n     }"}, {"sha": "bf2f7634e55a1e38e6ce9633a14a92c11d463b65", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n "}, {"sha": "6bcf4365db0a463440cbdb2e2e07ed738d3966f9", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -45,7 +45,7 @@ struct CheckLoopVisitor<'a, 'hir: 'a> {\n     cx: Context,\n }\n \n-fn check_mod_loops<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_loops<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckLoopVisitor {\n         sess: &tcx.sess,\n         hir_map: &tcx.hir(),"}, {"sha": "d6f5ed6fc03e2eaea5fade070949856db66b44fa", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -39,7 +39,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                   def_id: DefId)\n                                                   -> bool\n {\n@@ -51,7 +51,7 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n }\n \n-fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                    def_id: DefId)\n                                    -> &'tcx ItemLocalSet\n {\n@@ -81,7 +81,7 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     in_fn: bool,\n     in_static: bool,\n     mut_rvalue_borrows: HirIdSet,"}, {"sha": "31dec72c0e41b4c850c77e8e1829d9a8e3ca3c41", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -30,12 +30,12 @@ impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n }\n \n /// Finds the function marked with `#[plugin_registrar]`, if any.\n-pub fn find_plugin_registrar<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Option<DefId> {\n+pub fn find_plugin_registrar<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Option<DefId> {\n     tcx.plugin_registrar_fn(LOCAL_CRATE)\n }\n \n fn plugin_registrar_fn<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     cnum: CrateNum,\n ) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "14a4e335de6748a646aad0f097a9adfce125d70c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -4,6 +4,7 @@\n #![deny(internal)]\n #![deny(unused_lifetimes)]\n \n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n \n@@ -47,14 +48,14 @@ mod error_codes;\n /// First, it doesn't have overridable `fn visit_trait_ref`, so we have to catch trait `DefId`s\n /// manually. Second, it doesn't visit some type components like signatures of fn types, or traits\n /// in `impl Trait`, see individual comments in `DefIdVisitorSkeleton::visit_ty`.\n-trait DefIdVisitor<'a, 'tcx: 'a> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+trait DefIdVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx>;\n     fn shallow(&self) -> bool { false }\n     fn skip_assoc_tys(&self) -> bool { false }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n \n     /// Not overridden, but used to actually visit types and traits.\n-    fn skeleton(&mut self) -> DefIdVisitorSkeleton<'_, 'a, 'tcx, Self> {\n+    fn skeleton(&mut self) -> DefIdVisitorSkeleton<'_, 'tcx, Self> {\n         DefIdVisitorSkeleton {\n             def_id_visitor: self,\n             visited_opaque_tys: Default::default(),\n@@ -72,16 +73,16 @@ trait DefIdVisitor<'a, 'tcx: 'a> {\n     }\n }\n \n-struct DefIdVisitorSkeleton<'v, 'a, 'tcx, V>\n-    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+struct DefIdVisitorSkeleton<'v, 'tcx, V>\n+    where V: DefIdVisitor<'tcx> + ?Sized\n {\n     def_id_visitor: &'v mut V,\n     visited_opaque_tys: FxHashSet<DefId>,\n-    dummy: PhantomData<TyCtxt<'a, 'tcx, 'tcx>>,\n+    dummy: PhantomData<TyCtxt<'tcx, 'tcx, 'tcx>>,\n }\n \n-impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n-    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+impl<'tcx, V> DefIdVisitorSkeleton<'_, 'tcx, V>\n+    where V: DefIdVisitor<'tcx> + ?Sized\n {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n         let TraitRef { def_id, substs } = trait_ref;\n@@ -123,8 +124,8 @@ impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n     }\n }\n \n-impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n-    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+impl<'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'tcx, V>\n+    where V: DefIdVisitor<'tcx> + ?Sized\n {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let tcx = self.def_id_visitor.tcx();\n@@ -219,7 +220,7 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n     }\n }\n \n-fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId)\n                                -> (ty::Visibility, Span, &'static str) {\n     match tcx.hir().as_local_hir_id(def_id) {\n         Some(hir_id) => {\n@@ -322,15 +323,15 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n // Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n // there is no `TypeckTables` for the item).\n-fn item_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn item_tables<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                          hir_id: hir::HirId,\n                          empty_tables: &'a ty::TypeckTables<'tcx>)\n                          -> &'a ty::TypeckTables<'tcx> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n-fn min<'a, 'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+fn min<'a, 'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                  -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n@@ -341,12 +342,12 @@ fn min<'a, 'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'a, 'tc\n /// This is done so that `private_in_public` warnings can be turned into hard errors\n /// in crates that have been updated to use pub(restricted).\n ////////////////////////////////////////////////////////////////////////////////\n-struct PubRestrictedVisitor<'a, 'tcx: 'a> {\n-    tcx:  TyCtxt<'a, 'tcx, 'tcx>,\n+struct PubRestrictedVisitor<'tcx> {\n+    tcx:  TyCtxt<'tcx, 'tcx, 'tcx>,\n     has_pub_restricted: bool,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for PubRestrictedVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n@@ -360,13 +361,13 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n     min: VL,\n }\n \n-impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx, VL> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'tcx> for FindMin<'a, 'tcx, VL> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> { self.tcx }\n     fn shallow(&self) -> bool { VL::SHALLOW }\n     fn skip_assoc_tys(&self) -> bool { true }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n@@ -382,7 +383,7 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl<'a, 'tcx>(hir_id: hir::HirId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn of_impl<'a, 'tcx>(hir_id: hir::HirId, tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                          access_levels: &'a AccessLevels) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n         let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n@@ -424,8 +425,8 @@ impl VisibilityLike for Option<AccessLevel> {\n /// The embargo visitor, used to determine the exports of the AST.\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct EmbargoVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct EmbargoVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n \n     // Accessibility levels for reachable nodes.\n     access_levels: AccessLevels,\n@@ -435,13 +436,13 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     changed: bool,\n }\n \n-struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n+struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n     access_level: Option<AccessLevel>,\n     item_def_id: DefId,\n-    ev: &'b mut EmbargoVisitor<'a, 'tcx>,\n+    ev: &'a mut EmbargoVisitor<'tcx>,\n }\n \n-impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n+impl EmbargoVisitor<'tcx> {\n     fn get(&self, id: hir::HirId) -> Option<AccessLevel> {\n         self.access_levels.map.get(&id).cloned()\n     }\n@@ -460,7 +461,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn reach(&mut self, item_id: hir::HirId, access_level: Option<AccessLevel>)\n-             -> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n+             -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n             item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n@@ -506,7 +507,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -777,7 +778,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n+impl ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n         for param in &self.ev.tcx.generics_of(self.item_def_id).params {\n             match param.kind {\n@@ -813,8 +814,8 @@ impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.ev.tcx }\n+impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> { self.ev.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n             self.ev.update(hir_id, self.access_level);\n@@ -831,7 +832,7 @@ impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'\n //////////////////////////////////////////////////////////////////////////////////////\n \n struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: hir::HirId,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n@@ -958,7 +959,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n ////////////////////////////////////////////////////////////////////////////////////////////\n \n struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: DefId,\n     in_body: bool,\n@@ -1176,8 +1177,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> { self.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         self.check_def_id(def_id, kind, descr)\n     }\n@@ -1191,7 +1192,7 @@ impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////////\n \n struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n     // Set of errors produced by this obsolete visitor.\n@@ -1534,8 +1535,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n /// and traits in public interfaces.\n ///////////////////////////////////////////////////////////////////////////////\n \n-struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SearchInterfaceForPrivateItemsVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     item_id: hir::HirId,\n     item_def_id: DefId,\n     span: Span,\n@@ -1546,7 +1547,7 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     in_assoc_ty: bool,\n }\n \n-impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     fn generics(&mut self) -> &mut Self {\n         for param in &self.tcx.generics_of(self.item_def_id).params {\n             match param.kind {\n@@ -1632,22 +1633,22 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+impl DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> { self.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         self.check_def_id(def_id, kind, descr)\n     }\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     has_pub_restricted: bool,\n     old_error_set: &'a HirIdSet,\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn check(&self, item_id: hir::HirId, required_visibility: ty::Visibility)\n-             -> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+             -> SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         let mut has_old_errors = false;\n \n         // Slow path taken only if there any errors in the crate.\n@@ -1813,7 +1814,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_privacy<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     let empty_tables = ty::TypeckTables::empty(None);\n \n     // Check privacy of names not checked in previous compilation stages.\n@@ -1841,7 +1842,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n }\n \n fn privacy_access_levels<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     krate: CrateNum,\n ) -> &'tcx AccessLevels {\n     assert_eq!(krate, LOCAL_CRATE);\n@@ -1867,7 +1868,7 @@ fn privacy_access_levels<'tcx>(\n     tcx.arena.alloc(visitor.access_levels)\n }\n \n-fn check_private_in_public<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, krate: CrateNum) {\n+fn check_private_in_public<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, krate: CrateNum) {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);"}, {"sha": "e000679ffe36afc37f0520d494dcaf8a0ef66531", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -77,7 +77,7 @@ macro_rules! access_from_vis {\n \n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n-    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     dumper: &'ll mut JsonDumper<O>,\n \n     span: SpanUtils<'l>,"}, {"sha": "1e143942a791cf9bbeffcd2c452e3a14d3aa9795", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -52,7 +52,7 @@ use log::{debug, error, info};\n \n \n pub struct SaveContext<'l, 'tcx: 'l> {\n-    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     tables: &'l ty::TypeckTables<'tcx>,\n     access_levels: &'l AccessLevels,\n     span_utils: SpanUtils<'tcx>,\n@@ -1115,7 +1115,7 @@ impl<'b> SaveHandler for CallbackHandler<'b> {\n }\n \n pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n-    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     krate: &ast::Crate,\n     cratename: &str,\n     input: &'l Input,"}, {"sha": "2cf28a9fcb4ac3d233ec9a19b1f813579f20cb1c", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -50,9 +50,9 @@ crate struct ChalkArenas<'gcx> {\n }\n \n #[derive(Copy, Clone)]\n-crate struct ChalkContext<'cx, 'gcx: 'cx> {\n+crate struct ChalkContext<'gcx> {\n     _arenas: ChalkArenas<'gcx>,\n-    tcx: TyCtxt<'cx, 'gcx, 'gcx>,\n+    tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n }\n \n #[derive(Copy, Clone)]\n@@ -126,7 +126,7 @@ impl context::Context for ChalkArenas<'tcx> {\n     }\n }\n \n-impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n+impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     fn make_solution(\n         &self,\n         root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n@@ -176,7 +176,7 @@ impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     }\n }\n \n-impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n+impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     /// Returns `true` if this is a coinductive goal: basically proving that an auto trait\n     /// is implemented or proving that a trait reference is well-formed.\n     fn is_coinductive(\n@@ -508,7 +508,7 @@ type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n \n type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;\n \n-impl Debug for ChalkContext<'cx, 'gcx> {\n+impl Debug for ChalkContext<'gcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"ChalkContext\")\n     }\n@@ -527,7 +527,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_ex_clause_to_tcx(\n         ex_clause: &ChalkExClause<'a>,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>\n     ) -> Option<Self::LiftedExClause> {\n         Some(ChalkExClause {\n             subst: tcx.lift(&ex_clause.subst)?,\n@@ -539,7 +539,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_delayed_literal_to_tcx(\n         literal: &DelayedLiteral<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>\n     ) -> Option<Self::LiftedDelayedLiteral> {\n         Some(match literal {\n             DelayedLiteral::CannotProve(()) => DelayedLiteral::CannotProve(()),\n@@ -553,7 +553,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_literal_to_tcx(\n         literal: &Literal<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     ) -> Option<Self::LiftedLiteral> {\n         Some(match literal {\n             Literal::Negative(goal) => Literal::Negative(tcx.lift(goal)?),\n@@ -673,7 +673,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n crate fn evaluate_goal<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     goal: ChalkCanonicalGoal<'tcx>\n ) -> Result<\n     &'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>,"}, {"sha": "53375bd4cc9dab7cd65aab0b3f75130f578cdf4a", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -15,7 +15,7 @@ use crate::generic_types;\n /// `Implemented(ty: Trait) :- Implemented(nested: Trait)...`\n /// where `Trait` is specified by `trait_def_id`.\n fn builtin_impl_clause(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     ty: Ty<'tcx>,\n     nested: &[Kind<'tcx>],\n     trait_def_id: DefId\n@@ -43,7 +43,7 @@ fn builtin_impl_clause(\n }\n \n crate fn assemble_builtin_unsize_impls<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     unsize_def_id: DefId,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n@@ -119,7 +119,7 @@ crate fn assemble_builtin_unsize_impls<'tcx>(\n }\n \n crate fn assemble_builtin_sized_impls<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     sized_def_id: DefId,\n     ty: Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>\n@@ -223,7 +223,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n }\n \n crate fn assemble_builtin_copy_clone_impls<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     trait_def_id: DefId,\n     ty: Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>"}, {"sha": "2bd3902c74350866133361210ad6d090917dfc22", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -19,7 +19,7 @@ use self::primitive::*;\n use self::builtin::*;\n \n fn assemble_clauses_from_impls<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     trait_def_id: DefId,\n     clauses: &mut Vec<Clause<'tcx>>\n ) {\n@@ -33,7 +33,7 @@ fn assemble_clauses_from_impls<'tcx>(\n }\n \n fn assemble_clauses_from_assoc_ty_values<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     trait_def_id: DefId,\n     clauses: &mut Vec<Clause<'tcx>>\n ) {"}, {"sha": "a4c3b62a6b772a42c492cf2d02ca0270411d00d6", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -16,7 +16,7 @@ use crate::generic_types;\n use std::iter;\n \n crate fn wf_clause_for_raw_ptr<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     mutbl: hir::Mutability\n ) -> Clauses<'tcx> {\n     let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n@@ -33,7 +33,7 @@ crate fn wf_clause_for_raw_ptr<'tcx>(\n }\n \n crate fn wf_clause_for_fn_ptr<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     arity_and_output: usize,\n     variadic: bool,\n     unsafety: hir::Unsafety,\n@@ -53,7 +53,7 @@ crate fn wf_clause_for_fn_ptr<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'tcx, '_, 'tcx>) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n     let slice_ty = tcx.mk_slice(ty);\n \n@@ -83,7 +83,7 @@ crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n }\n \n crate fn wf_clause_for_array<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     length: &'tcx ty::Const<'tcx>\n ) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n@@ -115,7 +115,7 @@ crate fn wf_clause_for_array<'tcx>(\n }\n \n crate fn wf_clause_for_tuple<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     arity: usize\n ) -> Clauses<'tcx> {\n     let type_list = generic_types::type_list(tcx, arity);\n@@ -159,7 +159,7 @@ crate fn wf_clause_for_tuple<'tcx>(\n }\n \n crate fn wf_clause_for_ref<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     mutbl: hir::Mutability\n ) -> Clauses<'tcx> {\n     let region = tcx.mk_region(\n@@ -186,7 +186,7 @@ crate fn wf_clause_for_ref<'tcx>(\n }\n \n crate fn wf_clause_for_fn_def<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     def_id: DefId\n ) -> Clauses<'tcx> {\n     let fn_def = generic_types::fn_def(tcx, def_id);"}, {"sha": "d894c6c2a03e9243af5ef4c224fab00ca12f999d", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -169,8 +169,8 @@ impl AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+impl TypeRelation<'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "e7479e7ce62099b8c3f1d5cc24c52c0f7d5b4745", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -18,7 +18,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn dropck_outlives<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonical_goal: CanonicalTyGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n@@ -147,7 +147,7 @@ fn dropck_outlives<'tcx>(\n /// Returns a set of constraints that needs to be satisfied in\n /// order for `ty` to be valid for destruction.\n fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     span: Span,\n     for_ty: Ty<'tcx>,\n     depth: usize,\n@@ -280,7 +280,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n \n /// Calculates the dtorck constraint for a type.\n crate fn adt_dtorck_constraint<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n     let def = tcx.adt_def(def_id);"}, {"sha": "789da125ba91f54840257715123579026658ba3c", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -14,7 +14,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn evaluate_obligation<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n     tcx.infer_ctxt().enter_with_canonical("}, {"sha": "a9aa540acc11c16c1ceff64ff1d2d0c3b94c170d", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -6,23 +6,23 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi;\n \n-crate fn bound(tcx: TyCtxt<'_, '_, 'tcx>, index: u32) -> Ty<'tcx> {\n+crate fn bound(tcx: TyCtxt<'tcx, '_, 'tcx>, index: u32) -> Ty<'tcx> {\n     let ty = ty::Bound(\n         ty::INNERMOST,\n         ty::BoundVar::from_u32(index).into()\n     );\n     tcx.mk_ty(ty)\n }\n \n-crate fn raw_ptr(tcx: TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+crate fn raw_ptr(tcx: TyCtxt<'tcx, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     tcx.mk_ptr(ty::TypeAndMut {\n         ty: bound(tcx, 0),\n         mutbl,\n     })\n }\n \n crate fn fn_ptr(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'tcx, '_, 'tcx>,\n     arity_and_output: usize,\n     c_variadic: bool,\n     unsafety: hir::Unsafety,\n@@ -44,7 +44,7 @@ crate fn fn_ptr(\n     tcx.mk_fn_ptr(fn_sig)\n }\n \n-crate fn type_list(tcx: TyCtxt<'_, '_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n+crate fn type_list(tcx: TyCtxt<'tcx, '_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n     tcx.mk_substs(\n         (0..arity).into_iter()\n             .map(|i| ty::BoundVar::from(i))\n@@ -53,7 +53,7 @@ crate fn type_list(tcx: TyCtxt<'_, '_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n     )\n }\n \n-crate fn ref_ty(tcx: TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+crate fn ref_ty(tcx: TyCtxt<'tcx, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n@@ -64,17 +64,17 @@ crate fn ref_ty(tcx: TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     })\n }\n \n-crate fn fn_def(tcx: TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn fn_def(tcx: TyCtxt<'tcx, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_ty(ty::FnDef(def_id, InternalSubsts::bound_vars_for_item(tcx, def_id)))\n }\n \n-crate fn closure(tcx: TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn closure(tcx: TyCtxt<'tcx, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_closure(def_id, ty::ClosureSubsts {\n         substs: InternalSubsts::bound_vars_for_item(tcx, def_id),\n     })\n }\n \n-crate fn generator(tcx: TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn generator(tcx: TyCtxt<'tcx, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_generator(def_id, ty::GeneratorSubsts {\n         substs: InternalSubsts::bound_vars_for_item(tcx, def_id),\n     }, hir::GeneratorMovability::Movable)"}, {"sha": "03976ace692ea0d1b00bb75ce8907aa50c3a07b3", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -23,7 +23,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn implied_outlives_bounds<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     goal: CanonicalTyGoal<'tcx>,\n ) -> Result<\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,"}, {"sha": "81d32243e17a524d5f0500234fed3dfae4e245f7", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -11,13 +11,13 @@ use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashSet;\n \n-struct ClauseVisitor<'set, 'a, 'tcx: 'a + 'set> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    round: &'set mut FxHashSet<Clause<'tcx>>,\n+struct ClauseVisitor<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+    round: &'a mut FxHashSet<Clause<'tcx>>,\n }\n \n-impl ClauseVisitor<'set, 'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, round: &'set mut FxHashSet<Clause<'tcx>>) -> Self {\n+impl ClauseVisitor<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, round: &'a mut FxHashSet<Clause<'tcx>>) -> Self {\n         ClauseVisitor {\n             tcx,\n             round,\n@@ -128,7 +128,7 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n }\n \n crate fn program_clauses_for_env<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     environment: Environment<'tcx>,\n ) -> Clauses<'tcx> {\n     debug!(\"program_clauses_for_env(environment={:?})\", environment);\n@@ -161,7 +161,7 @@ crate fn program_clauses_for_env<'a, 'tcx>(\n }\n \n crate fn environment<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId\n ) -> Environment<'tcx> {\n     use super::{Lower, IntoFromEnvGoal};"}, {"sha": "699f1de2df2327e5a6524f8974fbb4f0e7b0a3c0", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -156,7 +156,7 @@ impl<'tcx> IntoWellFormedGoal for DomainGoal<'tcx> {\n }\n \n crate fn program_clauses_for<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Clauses<'tcx> {\n     // FIXME(eddyb) this should only be using `def_kind`.\n@@ -185,7 +185,7 @@ crate fn program_clauses_for<'a, 'tcx>(\n }\n \n fn program_clauses_for_trait<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Clauses<'tcx> {\n     // `trait Trait<P1..Pn> where WC { .. } // P0 == Self`\n@@ -300,7 +300,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     )\n }\n \n-fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+fn program_clauses_for_impl(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n         return List::empty();\n     }\n@@ -344,7 +344,7 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n }\n \n pub fn program_clauses_for_type_def<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Clauses<'tcx> {\n     // Rule WellFormed-Type\n@@ -421,7 +421,7 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n }\n \n pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     item_id: DefId,\n ) -> Clauses<'tcx> {\n     // Rule ProjectionEq-Placeholder\n@@ -559,7 +559,7 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n }\n \n pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     item_id: DefId,\n ) -> Clauses<'tcx> {\n     // Rule Normalize-From-Impl (see rustc guide)\n@@ -620,7 +620,7 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     tcx.mk_clauses(iter::once(normalize_clause))\n }\n \n-pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     if !tcx.features().rustc_attrs {\n         return;\n     }\n@@ -631,11 +631,11 @@ pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         .visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n-struct ClauseDumper<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ClauseDumper<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n+impl ClauseDumper<'tcx> {\n     fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(hir_id);\n         for attr in attrs {\n@@ -673,7 +673,7 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for ClauseDumper<'a, 'tcx> {\n+impl Visitor<'tcx> for ClauseDumper<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }"}, {"sha": "448c544afbb27c8c156d6a4278d8bcd407b1723f", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -12,7 +12,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn normalize_ty_after_erasing_regions<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Ty<'tcx> {\n     debug!(\"normalize_ty_after_erasing_regions(goal={:#?})\", goal);"}, {"sha": "a080ffcb2c1a70bbf7fea3fa8e73b1996af60bf9", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -15,7 +15,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn normalize_projection_ty<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     goal: CanonicalProjectionGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, NormalizationResult<'tcx>>>, NoSolution> {\n     debug!(\"normalize_provider(goal={:#?})\", goal);"}, {"sha": "a00e66fa56cac0e928da93c5b5fb8668aefa31ba", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -35,7 +35,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn type_op_ascribe_user_type<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserType<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -94,7 +94,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         );\n     }\n \n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -167,7 +167,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n }\n \n fn type_op_eq<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -197,39 +197,39 @@ where\n }\n \n fn type_op_normalize_ty(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Ty<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_predicate(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Predicate<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, Predicate<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_fn_sig(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<FnSig<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, FnSig<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_poly_fn_sig(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<PolyFnSig<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, PolyFnSig<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_subtype<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Subtype<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -243,7 +243,7 @@ fn type_op_subtype<'tcx>(\n }\n \n fn type_op_prove_predicate<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, ProvePredicate<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()"}, {"sha": "e2b3e9282cddc8f41aa9ea5dd5ec484ccbf86bd1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -41,7 +41,7 @@ use rustc_data_structures::fx::FxHashSet;\n pub struct PathSeg(pub DefId, pub usize);\n \n pub trait AstConv<'gcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'gcx, 'tcx>;\n \n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n@@ -462,7 +462,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n     ///   creates a suitable inference variable.\n     pub fn create_substs_for_generic_args<'a, 'b>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         def_id: DefId,\n         parent_substs: &[Kind<'tcx>],\n         has_self: bool,\n@@ -2420,7 +2420,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n     /// where-clauses). Because some of our bounds listings (e.g.,\n     /// regions) don't include the self-type, you must supply the\n     /// self-type here (the `param_ty` parameter).\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n+    pub fn predicates(&self, tcx: TyCtxt<'tcx, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n                       -> Vec<(ty::Predicate<'tcx>, Span)>\n     {\n         // If it could be sized, and is, add the `Sized` predicate."}, {"sha": "e6e6772e27eb134d11539e702494711ee14e6d30", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -240,7 +240,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n }\n \n pub fn report_autoderef_recursion_limit_error<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>, span: Span, ty: Ty<'tcx>)\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>, span: Span, ty: Ty<'tcx>)\n {\n     // We've reached the recursion limit, error gracefully.\n     let suggested_limit = *tcx.sess.recursion_limit.get() * 2;"}, {"sha": "ae9e74f37059b853af91b012b1cf3f62cf1c4099", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -23,7 +23,7 @@ use super::{Inherited, FnCtxt, potentially_plural_count};\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n \n-pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                      impl_m: &ty::AssocItem,\n                                      impl_m_span: Span,\n                                      trait_m: &ty::AssocItem,\n@@ -73,7 +73,7 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                           impl_m: &ty::AssocItem,\n                                           impl_m_span: Span,\n                                           trait_m: &ty::AssocItem,\n@@ -355,7 +355,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                 span: Span,\n                                                 impl_m: &ty::AssocItem,\n                                                 trait_m: &ty::AssocItem,\n@@ -495,7 +495,7 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n     }\n }\n \n-fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                impl_m: &ty::AssocItem,\n                                impl_m_span: Span,\n                                trait_m: &ty::AssocItem,\n@@ -581,7 +581,7 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn compare_number_of_generics<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     impl_: &ty::AssocItem,\n     _impl_span: Span,\n     trait_: &ty::AssocItem,\n@@ -695,7 +695,7 @@ fn compare_number_of_generics<'a, 'tcx>(\n     }\n }\n \n-fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                 impl_m: &ty::AssocItem,\n                                                 impl_m_span: Span,\n                                                 trait_m: &ty::AssocItem,\n@@ -779,7 +779,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(())\n }\n \n-fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                         impl_m: &ty::AssocItem,\n                                         trait_m: &ty::AssocItem)\n                                         -> Result<(), ErrorReported> {\n@@ -951,7 +951,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                     impl_c: &ty::AssocItem,\n                                     impl_c_span: Span,\n                                     trait_c: &ty::AssocItem,"}, {"sha": "672c474676925c6ced02bf76a598941ebddf7485", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -30,7 +30,7 @@ use syntax_pos::Span;\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n pub fn check_drop_impl<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n ) -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n@@ -65,7 +65,7 @@ pub fn check_drop_impl<'a, 'tcx>(\n }\n \n fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n@@ -141,7 +141,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n /// Confirms that every predicate imposed by dtor_predicates is\n /// implied by assuming the predicates attached to self_type_did.\n fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,"}, {"sha": "2554ff688d507fa8e6a023d1b8272098b3786c0c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -14,7 +14,7 @@ use rustc::hir;\n use std::iter;\n \n fn equate_intrinsic_type<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     it: &hir::ForeignItem,\n     n_tps: usize,\n     abi: Abi,\n@@ -79,7 +79,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n \n /// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, InternedString::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n@@ -400,7 +400,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n-pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = InternedString::intern(&format!(\"P{}\", n));"}, {"sha": "7101d7bba2da9493d1d093fe0f5f2fac5cf30fc9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -395,7 +395,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.method_autoderef_steps = method_autoderef_steps;\n }\n \n-fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n                                           goal: CanonicalTyGoal<'tcx>)\n                                           -> MethodAutoderefStepsResult<'gcx>\n {"}, {"sha": "aac1c2c68324af40bb6c81fe95926f3c03ca61f7", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -775,12 +775,12 @@ impl Ord for TraitInfo {\n }\n \n /// Retrieves all traits in this crate and any dependent crates.\n-pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<TraitInfo> {\n+pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Vec<TraitInfo> {\n     tcx.all_traits(LOCAL_CRATE).iter().map(|&def_id| TraitInfo { def_id }).collect()\n }\n \n /// Computes all traits in this crate and any dependent crates.\n-fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId> {\n+fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>) -> Vec<DefId> {\n     use hir::itemlikevisit;\n \n     let mut traits = vec![];\n@@ -855,16 +855,16 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     }\n }\n \n-struct UsePlacementFinder<'a, 'tcx: 'a, 'gcx: 'tcx> {\n+struct UsePlacementFinder<'tcx, 'gcx> {\n     target_module: hir::HirId,\n     span: Option<Span>,\n     found_use: bool,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx, 'gcx> UsePlacementFinder<'a, 'tcx, 'gcx> {\n+impl UsePlacementFinder<'tcx, 'gcx> {\n     fn check(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n         krate: &'tcx hir::Crate,\n         target_module: hir::HirId,\n     ) -> (Option<Span>, bool) {\n@@ -879,7 +879,7 @@ impl<'a, 'tcx, 'gcx> UsePlacementFinder<'a, 'tcx, 'gcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, 'tcx, 'gcx> {\n+impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx, 'gcx> {\n     fn visit_mod(\n         &mut self,\n         module: &'tcx hir::Mod,"}, {"sha": "830407bffefc6d9d9f8bd0aaf04c39e122c7a8b0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -588,14 +588,14 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n /// Helper type of a temporary returned by `Inherited::build(...)`.\n /// Necessary because we can't write the following bound:\n /// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Inherited<'b, 'gcx, 'tcx>)`.\n-pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>,\n+pub struct InheritedBuilder<'gcx, 'tcx> {\n+    infcx: infer::InferCtxtBuilder<'gcx, 'tcx>,\n     def_id: DefId,\n }\n \n-impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n-                 -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+impl Inherited<'_, 'gcx, 'tcx> {\n+    pub fn build(tcx: TyCtxt<'gcx, 'gcx, 'gcx>, def_id: DefId)\n+                 -> InheritedBuilder<'gcx, 'tcx> {\n         let hir_id_root = if def_id.is_local() {\n             let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n             DefId::local(hir_id.owner)\n@@ -610,16 +610,16 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> InheritedBuilder<'gcx, 'tcx> {\n     fn enter<F, R>(&'tcx mut self, f: F) -> R\n-        where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n+        where F: for<'a> FnOnce(Inherited<'a, 'gcx, 'tcx>) -> R\n     {\n         let def_id = self.def_id;\n         self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n+impl Inherited<'a, 'gcx, 'tcx> {\n     fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> Self {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().as_local_hir_id(def_id);\n@@ -685,43 +685,43 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n+struct CheckItemTypesVisitor<'tcx> { tcx: TyCtxt<'tcx, 'tcx, 'tcx> }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_type(self.tcx, i);\n     }\n     fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n }\n \n-pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n+pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n         tcx.hir().krate().par_visit_all_item_likes(&mut visit);\n     })\n }\n \n-fn check_mod_item_types<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_item_types<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n }\n \n-fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) {\n+fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, crate_num: CrateNum) {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.par_body_owners(|body_owner_def_id| {\n         tcx.ensure().typeck_tables_of(body_owner_def_id);\n     });\n }\n \n-fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     wfcheck::check_item_well_formed(tcx, def_id);\n }\n \n-fn check_trait_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn check_trait_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     wfcheck::check_trait_item(tcx, def_id);\n }\n \n-fn check_impl_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn check_impl_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     wfcheck::check_impl_item(tcx, def_id);\n }\n \n@@ -741,7 +741,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             def_id: DefId)\n                             -> Option<ty::Destructor> {\n     tcx.calculate_dtor(def_id, &mut dropck::check_drop_impl)\n@@ -756,7 +756,7 @@ fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// may not succeed. In some cases where this function returns `None`\n /// (notably closures), `typeck_tables(def_id)` would wind up\n /// redirecting to the owning function.\n-fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                              id: hir::HirId)\n                              -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n {\n@@ -797,7 +797,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                def_id: DefId)\n                                -> bool {\n     // Closures' tables come from their outermost function,\n@@ -811,13 +811,13 @@ fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     primary_body_of(tcx, id).is_some()\n }\n \n-fn used_trait_imports<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn used_trait_imports<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 def_id: DefId)\n                                 -> &'tcx DefIdSet {\n     &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n \n-fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                               def_id: DefId)\n                               -> &'tcx ty::TypeckTables<'tcx> {\n     // Closures' tables come from their outermost function,\n@@ -919,7 +919,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables\n }\n \n-fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n+fn check_abi<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, span: Span, abi: Abi) {\n     if !tcx.sess.target.target.is_abi_supported(abi) {\n         struct_span_err!(tcx.sess, span, E0570,\n             \"The ABI `{}` is not supported for the current target\", abi).emit()\n@@ -1287,7 +1287,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     (fcx, gen_ty)\n }\n \n-fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_struct<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                           id: hir::HirId,\n                           span: Span) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n@@ -1303,7 +1303,7 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_packed(tcx, span, def_id);\n }\n \n-fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_union<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                          id: hir::HirId,\n                          span: Span) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n@@ -1315,7 +1315,7 @@ fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_opaque<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n     substs: SubstsRef<'tcx>,\n     span: Span,\n@@ -1335,7 +1335,7 @@ fn check_opaque<'a, 'tcx>(\n     }\n }\n \n-pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n+pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n         it.hir_id,\n@@ -1472,15 +1472,15 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_, '_, '_>, id: DefId, span\n     }\n }\n \n-fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                     trait_def_id: DefId,\n                                     item: &hir::Item) {\n     let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     // an error would be reported if this fails.\n     let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n \n-fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                              impl_item: &hir::ImplItem,\n                                              parent_impl: DefId)\n {\n@@ -1506,7 +1506,7 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err.emit();\n }\n \n-fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                            trait_def: &ty::TraitDef,\n                                            trait_item: &ty::AssocItem,\n                                            impl_id: DefId,\n@@ -1532,7 +1532,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n }\n \n-fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n@@ -1693,7 +1693,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_representable<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                  sp: Span,\n                                  item_def_id: DefId)\n                                  -> bool {\n@@ -1718,7 +1718,7 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return true\n }\n \n-pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let t = tcx.type_of(def_id);\n     if let ty::Adt(def, substs) = t.sty {\n         if def.is_struct() {\n@@ -1747,7 +1747,7 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n     }\n }\n \n-fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+fn check_packed<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let repr = tcx.adt_def(def_id).repr;\n     if repr.packed() {\n         for attr in tcx.get_attrs(def_id).iter() {\n@@ -1771,7 +1771,7 @@ fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId)\n     }\n }\n \n-fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 def_id: DefId,\n                                 stack: &mut Vec<DefId>) -> bool {\n     let t = tcx.type_of(def_id);\n@@ -1801,7 +1801,7 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     false\n }\n \n-fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let adt = tcx.adt_def(def_id);\n     if !adt.repr.transparent() {\n         return;\n@@ -1881,7 +1881,7 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                             sp: Span,\n                             vs: &'tcx [hir::Variant],\n                             id: hir::HirId) {\n@@ -1945,7 +1945,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn report_unexpected_variant_res<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                                  res: Res,\n                                                  span: Span,\n                                                  qpath: &QPath) {\n@@ -1956,7 +1956,7 @@ fn report_unexpected_variant_res<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> { self.tcx }\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n                                  -> &'tcx ty::GenericPredicates<'tcx>\n@@ -5700,7 +5700,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                        generics: &ty::Generics,\n                                        ty: Ty<'tcx>) {\n     let own_counts = generics.own_counts();"}, {"sha": "827853c311416fc3af65fb29b495299d5dba3aee", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -25,17 +25,17 @@ use rustc::hir;\n /// ```rust\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)\n /// ```\n-struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n+struct CheckWfFcxBuilder<'gcx, 'tcx> {\n+    inherited: super::InheritedBuilder<'gcx, 'tcx>,\n     id: hir::HirId,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> CheckWfFcxBuilder<'gcx, 'tcx> {\n     fn with_fcx<F>(&'tcx mut self, f: F) where\n         F: for<'b> FnOnce(&FnCtxt<'b, 'gcx, 'tcx>,\n-                         TyCtxt<'b, 'gcx, 'gcx>) -> Vec<Ty<'tcx>>\n+                         TyCtxt<'gcx, 'gcx, 'gcx>) -> Vec<Ty<'tcx>>\n     {\n         let id = self.id;\n         let span = self.span;\n@@ -68,7 +68,7 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n-pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item_by_hir_id(hir_id);\n \n@@ -156,7 +156,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n     }\n }\n \n-pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n@@ -167,7 +167,7 @@ pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     check_associated_item(tcx, trait_item.hir_id, trait_item.span, method_sig);\n }\n \n-pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n@@ -178,7 +178,7 @@ pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n }\n \n-fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                    item_id: hir::HirId,\n                                    span: Span,\n                                    sig_if_method: Option<&hir::MethodSig>) {\n@@ -225,13 +225,13 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n-                            -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+fn for_item<'gcx: 'tcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx, 'gcx>, item: &hir::Item)\n+                            -> CheckWfFcxBuilder<'gcx, 'tcx> {\n     for_id(tcx, item.hir_id, item.span)\n }\n \n-fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: hir::HirId, span: Span)\n-                          -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+fn for_id<'gcx: 'tcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx, 'gcx>, id: hir::HirId, span: Span)\n+                          -> CheckWfFcxBuilder<'gcx, 'tcx> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n@@ -242,7 +242,7 @@ fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: hir::HirId, span: Spa\n }\n \n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 item: &hir::Item, all_sized: bool, mut lookup_fields: F)\n     where F: for<'fcx, 'gcx, 'tcx2> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx2>) -> Vec<AdtVariant<'tcx2>>\n {\n@@ -312,7 +312,7 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n }\n \n-fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+fn check_trait<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, item: &hir::Item) {\n     debug!(\"check_trait: {:?}\", item.hir_id);\n \n     let trait_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n@@ -335,7 +335,7 @@ fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     });\n }\n \n-fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, item: &hir::Item) {\n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n         let def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let sig = fcx.tcx.fn_sig(def_id);\n@@ -348,7 +348,7 @@ fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n }\n \n fn check_item_type<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     item_id: hir::HirId,\n     ty_span: Span,\n     allow_foreign_ty: bool,\n@@ -380,7 +380,7 @@ fn check_item_type<'a, 'tcx>(\n     });\n }\n \n-fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_impl<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                         item: &hir::Item,\n                         ast_self_ty: &hir::Ty,\n                         ast_trait_ref: &Option<hir::TraitRef>)\n@@ -422,7 +422,7 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n /// Checks where-clauses and inline bounds that are declared on `def_id`.\n fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n     fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     span: Span,\n     def_id: DefId,\n@@ -574,7 +574,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n     }\n }\n \n-fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n                                             fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                             span: Span,\n                                             sig: ty::PolyFnSig<'tcx>,\n@@ -617,7 +617,7 @@ fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n /// ```\n ///\n fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    tcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n     fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     fn_def_id: DefId,\n     span: Span,\n@@ -930,7 +930,7 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n     true\n }\n \n-fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                            item: &hir::Item,\n                                            hir_generics: &hir::Generics)\n {\n@@ -971,7 +971,7 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                span: Span,\n                                param_name: ast::Name)\n {\n@@ -1052,20 +1052,19 @@ fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n     fcx.select_all_obligations_or_error();\n }\n \n-pub struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct CheckTypeWellFormedVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>)\n-               -> CheckTypeWellFormedVisitor<'a, 'gcx> {\n+impl CheckTypeWellFormedVisitor<'gcx> {\n+    pub fn new(tcx: TyCtxt<'gcx, 'gcx, 'gcx>) -> CheckTypeWellFormedVisitor<'gcx> {\n         CheckTypeWellFormedVisitor {\n             tcx,\n         }\n     }\n }\n \n-impl<'a, 'tcx> ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n+impl ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n     fn visit_item(&self, i: &'tcx hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(i.hir_id);\n@@ -1134,7 +1133,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast::Name)\n+fn error_392<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, span: Span, param_name: ast::Name)\n                        -> DiagnosticBuilder<'tcx> {\n     let mut err = struct_span_err!(tcx.sess, span, E0392,\n                   \"parameter `{}` is never used\", param_name);"}, {"sha": "7683f8cfbc4a6703e599e5c71468fd37ff0ac1af", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -123,7 +123,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n@@ -789,7 +789,7 @@ impl Locatable for hir::HirId {\n // unresolved types and so forth.\n \n struct Resolver<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: &'cx dyn Locatable,\n     body: &'gcx hir::Body,\n@@ -819,7 +819,7 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "aecffd4c7d5b2ed0338aaa69dbbc1926922f7019", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -13,7 +13,7 @@ use rustc::util::nodemap::DefIdSet;\n \n use rustc_data_structures::fx::FxHashMap;\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     let mut used_trait_imports = DefIdSet::default();\n     for &body_id in tcx.hir().krate().bodies.keys() {\n         let item_def_id = tcx.hir().body_owner_def_id(body_id);\n@@ -28,7 +28,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     unused_crates_lint(tcx);\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n+impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n@@ -45,12 +45,12 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n     }\n }\n \n-struct CheckVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct CheckVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     used_trait_imports: DefIdSet,\n }\n \n-impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n+impl CheckVisitor<'tcx> {\n     fn check_import(&self, id: hir::HirId, span: Span) {\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n         if !self.tcx.maybe_unused_trait_import(def_id) {\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n     }\n }\n \n-fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n+fn unused_crates_lint<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n \n     // Collect first the crates that are completely unused.  These we\n@@ -195,7 +195,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n }\n \n struct CollectExternCrateVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     crates_to_lint: &'a mut Vec<ExternCrateToLint>,\n }\n "}, {"sha": "30ad1d32f2a2b2e2ce62d4bda1fd93324c7e01cb", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::DefId;\n use hir::Node;\n use rustc::hir::{self, ItemKind};\n \n-pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n+pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n         .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n         .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n@@ -26,14 +26,14 @@ pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n             visit_implementation_of_dispatch_from_dyn);\n }\n \n-struct Checker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Checker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     trait_def_id: DefId\n }\n \n-impl<'a, 'tcx> Checker<'a, 'tcx> {\n+impl<'tcx> Checker<'tcx> {\n     fn check<F>(&self, trait_def_id: Option<DefId>, mut f: F) -> &Self\n-        where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId)\n+        where F: FnMut(TyCtxt<'tcx, 'tcx, 'tcx>, DefId)\n     {\n         if Some(self.trait_def_id) == trait_def_id {\n             for &impl_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n@@ -45,7 +45,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n }\n \n-fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, impl_did: DefId) {\n     if let ty::Adt(..) = tcx.type_of(impl_did).sty {\n         /* do nothing */\n     } else {\n@@ -73,7 +73,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n     }\n }\n \n-fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n     let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did) {\n@@ -140,7 +140,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n     }\n }\n \n-fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\",\n            impl_did);\n \n@@ -154,7 +154,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     impl_did: DefId,\n ) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\",\n@@ -324,7 +324,7 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n     }\n }\n \n-pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n+pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'gcx, 'gcx, 'gcx>,\n                                      impl_did: DefId)\n                                      -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);"}, {"sha": "5189f4a1390957cd930782bf50e62695c342ce5f", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -17,7 +17,7 @@ use syntax::ast;\n use syntax_pos::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n-pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                       crate_num: CrateNum)\n                                       -> &'tcx CrateInherentImpls {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -32,7 +32,7 @@ pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type.\n-pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 ty_def_id: DefId)\n                                 -> &'tcx [DefId] {\n     assert!(ty_def_id.is_local());\n@@ -68,12 +68,12 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result\n }\n \n-struct InherentCollect<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct InherentCollect<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     impls_map: CrateInherentImpls,\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n+impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let ty = match item.node {\n             hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n@@ -277,7 +277,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n+impl InherentCollect<'tcx> {\n     fn check_def_id(&mut self, item: &hir::Item, def_id: DefId) {\n         if def_id.is_local() {\n             // Add the implementation to the mapping from implementation to base"}, {"sha": "56c03e20405fa563dfbb8bb6f6a8b797d8af900f", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -5,18 +5,18 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n-pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let krate = tcx.hir().krate();\n     krate.visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n }\n \n-struct InherentOverlapChecker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+struct InherentOverlapChecker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>\n }\n \n-impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n+impl InherentOverlapChecker<'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n                                        overlap: traits::OverlapResult<'_>) {\n \n@@ -83,7 +83,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n+impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemKind::Enum(..) |"}, {"sha": "e33adcbacfe124d318247a2595919bf2f254634a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -18,7 +18,7 @@ mod inherent_impls_overlap;\n mod orphan;\n mod unsafety;\n \n-fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_id: HirId) {\n+fn check_impl<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, hir_id: HirId) {\n     let impl_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n \n     // If there are no traits, then this implementation must have a\n@@ -132,7 +132,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) {\n     let impls = tcx.hir().trait_impls(def_id);\n     for &impl_id in impls {\n         check_impl(tcx, impl_id);\n@@ -143,7 +143,7 @@ fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     builtin::check_trait(tcx, def_id);\n }\n \n-pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     for &trait_def_id in tcx.hir().krate().trait_impls.keys() {\n         tcx.ensure().coherent_trait(trait_def_id);\n     }\n@@ -159,7 +159,7 @@ pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n /// Overlap: no two impls for the same trait are implemented for the\n /// same type. Likewise, no two inherent impls for a given type\n /// constructor provide a method with the same name.\n-fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_id: HirId) {\n+fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, hir_id: HirId) {\n     let impl_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n     let trait_def_id = trait_ref.def_id;"}, {"sha": "144d70cec0c024d15ab366874ed7612044f03f7d", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -6,16 +6,16 @@ use rustc::ty::{self, TyCtxt};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     let mut orphan = OrphanChecker { tcx };\n     tcx.hir().krate().visit_all_item_likes(&mut orphan);\n }\n \n-struct OrphanChecker<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+struct OrphanChecker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n+impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     /// Checks exactly one impl for orphan rules and other such\n     /// restrictions. In this fn, it can happen that multiple errors\n     /// apply to a specific impl, so just return after reporting one"}, {"sha": "43b513667101a6efb92b171af078257cf0479bc7", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -5,16 +5,16 @@ use rustc::ty::TyCtxt;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, Unsafety};\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     let mut unsafety = UnsafetyChecker { tcx };\n     tcx.hir().krate().visit_all_item_likes(&mut unsafety);\n }\n \n-struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+struct UnsafetyChecker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n+impl UnsafetyChecker<'tcx> {\n     fn check_unsafety_coherence(&mut self,\n                                 item: &'v hir::Item,\n                                 impl_generics: Option<&hir::Generics>,\n@@ -69,7 +69,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n+impl ItemLikeVisitor<'v> for UnsafetyChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.node {\n             self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);"}, {"sha": "4b2217791d028ef65eb0550649001c00cb1d7310", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 49, "deletions": 51, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -56,7 +56,7 @@ struct OnlySelfBounds(bool);\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-fn collect_mod_item_types<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn collect_mod_item_types<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CollectItemTypesVisitor { tcx }.as_deep_visitor()\n@@ -96,18 +96,18 @@ pub fn provide(providers: &mut Providers<'_>) {\n /// `ItemCtxt` is parameterized by a `DefId` that it uses to satisfy\n /// `get_type_parameter_bounds` requests, drawing the information from\n /// the AST (`hir::Generics`), recursively.\n-pub struct ItemCtxt<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct ItemCtxt<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     item_def_id: DefId,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n \n-struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct CollectItemTypesVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -160,20 +160,18 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Utility types and common code for the above passes.\n \n-impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId) -> ItemCtxt<'a, 'tcx> {\n+impl ItemCtxt<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, item_def_id: DefId) -> ItemCtxt<'tcx> {\n         ItemCtxt { tcx, item_def_id }\n     }\n-}\n \n-impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     pub fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n \n-impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+impl AstConv<'tcx, 'tcx> for ItemCtxt<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -256,7 +254,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n }\n \n fn type_param_predicates<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     (item_def_id, def_id): (DefId, DefId),\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     use rustc::hir::*;\n@@ -333,7 +331,7 @@ fn type_param_predicates<'a, 'tcx>(\n     tcx.arena.alloc(result)\n }\n \n-impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n+impl ItemCtxt<'tcx> {\n     /// Finds bounds from `hir::Generics`. This requires scanning through the\n     /// AST. We do this to avoid having to convert *all* the bounds, which\n     /// would create artificial cycles. Instead we can only convert the\n@@ -384,7 +382,7 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n fn is_param<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     ast_ty: &hir::Ty,\n     param_id: hir::HirId,\n ) -> bool {\n@@ -400,7 +398,7 @@ fn is_param<'a, 'tcx>(\n     }\n }\n \n-fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n+fn convert_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, item_id: hir::HirId) {\n     let it = tcx.hir().expect_item_by_hir_id(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n@@ -482,7 +480,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n     }\n }\n \n-fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: hir::HirId) {\n+fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, trait_item_id: hir::HirId) {\n     let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n     tcx.generics_of(def_id);\n@@ -503,7 +501,7 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: hir:\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: hir::HirId) {\n+fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, impl_item_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(impl_item_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n@@ -513,15 +511,15 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: hir::H\n     }\n }\n \n-fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ctor_id: hir::HirId) {\n+fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, ctor_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(ctor_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n     variants: &[hir::Variant],\n ) {\n@@ -573,7 +571,7 @@ fn convert_enum_variant_types<'a, 'tcx>(\n }\n \n fn convert_variant<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     variant_did: Option<DefId>,\n     ctor_did: Option<DefId>,\n     ident: Ident,\n@@ -629,7 +627,7 @@ fn convert_variant<'a, 'tcx>(\n     )\n }\n \n-fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n+fn adt_def<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n     use rustc::hir::*;\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -697,7 +695,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n fn super_predicates_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     trait_def_id: DefId,\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n@@ -750,7 +748,7 @@ fn super_predicates_of<'a, 'tcx>(\n     })\n }\n \n-fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n+fn trait_def<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item_by_hir_id(hir_id);\n \n@@ -782,16 +780,16 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n }\n \n fn has_late_bound_regions<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     node: Node<'tcx>,\n ) -> Option<Span> {\n-    struct LateBoundRegionsDetector<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    struct LateBoundRegionsDetector<'tcx> {\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         outer_index: ty::DebruijnIndex,\n         has_late_bound_regions: Option<Span>,\n     }\n \n-    impl<'a, 'tcx> Visitor<'tcx> for LateBoundRegionsDetector<'a, 'tcx> {\n+    impl Visitor<'tcx> for LateBoundRegionsDetector<'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n             NestedVisitorMap::None\n         }\n@@ -843,7 +841,7 @@ fn has_late_bound_regions<'a, 'tcx>(\n     }\n \n     fn has_late_bound_regions<'a, 'tcx>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         generics: &'tcx hir::Generics,\n         decl: &'tcx hir::FnDecl,\n     ) -> Option<Span> {\n@@ -892,7 +890,7 @@ fn has_late_bound_regions<'a, 'tcx>(\n     }\n }\n \n-fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n+fn generics_of<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n     use rustc::hir::*;\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -1135,7 +1133,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n     })\n }\n \n-fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) {\n+fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, span: Span) {\n     span_err!(\n         tcx.sess,\n         span,\n@@ -1144,7 +1142,7 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n     );\n }\n \n-fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+fn type_of<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     checked_type_of(tcx, def_id, true).unwrap()\n }\n \n@@ -1153,7 +1151,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n /// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n /// you'd better just call [`type_of`] directly.\n pub fn checked_type_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n     fail: bool,\n ) -> Option<Ty<'tcx>> {\n@@ -1482,15 +1480,15 @@ pub fn checked_type_of<'a, 'tcx>(\n }\n \n fn find_existential_constraints<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Ty<'tcx> {\n     use rustc::hir::{ImplItem, Item, TraitItem};\n \n     debug!(\"find_existential_constraints({:?})\", def_id);\n \n-    struct ConstraintLocator<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    struct ConstraintLocator<'tcx> {\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         def_id: DefId,\n         // (first found type span, actual type, mapping from the existential type's generic\n         // parameters to the concrete type's generic parameters)\n@@ -1501,7 +1499,7 @@ fn find_existential_constraints<'a, 'tcx>(\n         found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n     }\n \n-    impl<'a, 'tcx> ConstraintLocator<'a, 'tcx> {\n+    impl ConstraintLocator<'tcx> {\n         fn check(&mut self, def_id: DefId) {\n             // Don't try to check items that cannot possibly constrain the type.\n             if !self.tcx.has_typeck_tables(def_id) {\n@@ -1638,7 +1636,7 @@ fn find_existential_constraints<'a, 'tcx>(\n         }\n     }\n \n-    impl<'a, 'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'a, 'tcx> {\n+    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n@@ -1702,7 +1700,7 @@ fn find_existential_constraints<'a, 'tcx>(\n     }\n }\n \n-fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n+fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n     use rustc::hir::*;\n     use rustc::hir::Node::*;\n \n@@ -1779,7 +1777,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n }\n \n fn impl_trait_ref<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Option<ty::TraitRef<'tcx>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n@@ -1796,7 +1794,7 @@ fn impl_trait_ref<'a, 'tcx>(\n     }\n }\n \n-fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> hir::ImplPolarity {\n+fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> hir::ImplPolarity {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     match tcx.hir().expect_item_by_hir_id(hir_id).node {\n         hir::ItemKind::Impl(_, polarity, ..) => polarity,\n@@ -1809,8 +1807,8 @@ fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> hir::I\n /// the lifetimes that are declared. For fns or methods, we have to\n /// screen out those that do not appear in any where-clauses etc using\n /// `resolve_lifetime::early_bound_lifetimes`.\n-fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     generics: &'a hir::Generics,\n ) -> impl Iterator<Item = &'a hir::GenericParam> + Captures<'tcx> {\n     generics\n@@ -1828,7 +1826,7 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n /// lifetime constraints. This includes all predicates returned by `explicit_predicates_of`, plus\n /// inferred constraints concerning which regions outlive other regions.\n fn predicates_defined_on<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     debug!(\"predicates_defined_on({:?})\", def_id);\n@@ -1858,7 +1856,7 @@ fn predicates_defined_on<'a, 'tcx>(\n /// ID `def_id`. This includes all predicates returned by `predicates_defined_on`, plus\n /// `Self: Trait` predicates for traits.\n fn predicates_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     let mut result = tcx.predicates_defined_on(def_id);\n@@ -1888,7 +1886,7 @@ fn predicates_of<'a, 'tcx>(\n /// Returns a list of user-specified type predicates for the definition with ID `def_id`.\n /// N.B., this does not include any implied/inferred constraints.\n fn explicit_predicates_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     use rustc::hir::*;\n@@ -2251,7 +2249,7 @@ fn predicates_from_bound<'tcx>(\n }\n \n fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n     decl: &hir::FnDecl,\n     abi: abi::Abi,\n@@ -2295,7 +2293,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     fty\n }\n \n-fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     match tcx.hir().get_if_local(def_id) {\n         Some(Node::ForeignItem(..)) => true,\n         Some(_) => false,\n@@ -2304,7 +2302,7 @@ fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool\n }\n \n fn static_mutability<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Option<hir::Mutability> {\n     match tcx.hir().get_if_local(def_id) {\n@@ -2414,7 +2412,7 @@ fn from_target_feature(\n     }\n }\n \n-fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &str) -> Linkage {\n+fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, def_id: DefId, name: &str) -> Linkage {\n     use rustc::mir::mono::Linkage::*;\n \n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n@@ -2449,7 +2447,7 @@ fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &\n     }\n }\n \n-fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> CodegenFnAttrs {\n+fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, id: DefId) -> CodegenFnAttrs {\n     let attrs = tcx.get_attrs(id);\n \n     let mut codegen_fn_attrs = CodegenFnAttrs::new();"}, {"sha": "a0f592586b43ff940fa74674427be3515803f846", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n }\n \n-pub fn identify_constrained_generic_params<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+pub fn identify_constrained_generic_params<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                               predicates: &ty::GenericPredicates<'tcx>,\n                                               impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut FxHashSet<Parameter>)"}, {"sha": "5ffaa1eff2c19fe760bc94cc445db7131ee15013", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -49,7 +49,7 @@ use syntax_pos::Span;\n /// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n /// //   ^ 'a is unused and appears in assoc type, error\n /// ```\n-pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     // We will tag this as part of the WF check -- logically, it is,\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n@@ -58,7 +58,7 @@ pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-fn check_mod_impl_wf<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_impl_wf<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut ImplWfCheck { tcx }\n@@ -72,11 +72,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-struct ImplWfCheck<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ImplWfCheck<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.node {\n             let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n@@ -92,7 +92,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n }\n \n-fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                  impl_def_id: DefId,\n                                                  impl_item_refs: &[hir::ImplItemRef])\n {\n@@ -186,7 +186,7 @@ fn report_unused_parameter(tcx: TyCtxt<'_, '_, '_>,\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                              impl_item_refs: &[hir::ImplItemRef])\n {\n     let mut seen_type_items = FxHashMap::default();"}, {"sha": "b77c5eea49477ae535af0ce486a4eb74a8e3aa11", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -63,6 +63,7 @@ This API is completely unstable and subject to change.\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(exhaustive_patterns)]\n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n@@ -123,7 +124,7 @@ pub struct TypeAndSubsts<'tcx> {\n     ty: Ty<'tcx>,\n }\n \n-fn check_type_alias_enum_variants_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn check_type_alias_enum_variants_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n                                                           span: Span) {\n     if !tcx.features().type_alias_enum_variants {\n         let mut err = tcx.sess.struct_span_err(\n@@ -150,7 +151,7 @@ fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_, '_, '_>,\n     }\n }\n \n-fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                 cause: &ObligationCause<'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n@@ -178,7 +179,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, main_def_id: DefId) {\n+fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, main_def_id: DefId) {\n     let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n@@ -243,7 +244,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, main_def_id: DefId) {\n     }\n }\n \n-fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, start_def_id: DefId) {\n+fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, start_def_id: DefId) {\n     let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n@@ -300,7 +301,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, start_def_id: DefId)\n     }\n }\n \n-fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id),\n         Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id),\n@@ -317,7 +318,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     impl_wf_check::provide(providers);\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>)\n                              -> Result<(), ErrorReported>\n {\n     tcx.sess.profiler(|p| p.start_activity(\"type-check crate\"));\n@@ -380,7 +381,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n /// A quasi-deprecated helper used in rustdoc and clippy to get\n /// the type from a HIR node.\n-pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n+pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n@@ -391,7 +392,7 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n \n-pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n+pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n         -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in"}, {"sha": "87ba9a466a82dccc3c0f0b3c162be6f63f579d02", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -18,7 +18,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n     pub fn explicit_predicates_of(\n         &mut self,\n-        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         def_id: DefId,\n     ) -> &RequiredPredicates<'tcx> {\n         self.map.entry(def_id).or_insert_with(|| {"}, {"sha": "354be95c0500718f7158e73f6d8fc23db249f383", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -15,7 +15,7 @@ use super::utils::*;\n ///     was generated by walking the items in the crate. This will\n ///     now be filled with inferred predicates.\n pub fn infer_predicates<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n ) -> FxHashMap<DefId, RequiredPredicates<'tcx>> {\n     debug!(\"infer_predicates\");\n@@ -44,7 +44,7 @@ pub fn infer_predicates<'tcx>(\n }\n \n pub struct InferVisitor<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     global_inferred_outlives: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     predicates_added: &'cx mut bool,\n     explicit_map: &'cx mut ExplicitPredicatesMap<'tcx>,\n@@ -117,7 +117,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n }\n \n fn insert_required_predicates_to_be_wf<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     field_ty: Ty<'tcx>,\n     global_inferred_outlives: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n@@ -255,7 +255,7 @@ pub struct IgnoreSelfTy(bool);\n /// can ignore, but we will want to process `U: 'static`,\n /// applying the substitution as above.\n pub fn check_explicit_predicates<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     def_id: &DefId,\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,"}, {"sha": "da4b9c686195dcc4e0a0fd60850d9bf122bc8f6e", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -21,7 +21,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn inferred_outlives_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     item_def_id: DefId,\n ) -> &'tcx [ty::Predicate<'tcx>] {\n     let id = tcx\n@@ -71,7 +71,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n }\n \n fn inferred_outlives_crate<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     crate_num: CrateNum,\n ) -> &'tcx CratePredicatesMap<'tcx> {\n     assert_eq!(crate_num, LOCAL_CRATE);"}, {"sha": "06097349fd6a44bc761094582cf8eeef1132427c", "filename": "src/librustc_typeck/outlives/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Ftest.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -3,17 +3,17 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n use syntax::symbol::sym;\n \n-pub fn test_inferred_outlives<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn test_inferred_outlives<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     tcx.hir()\n        .krate()\n        .visit_all_item_likes(&mut OutlivesTest { tcx });\n }\n \n-struct OutlivesTest<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct OutlivesTest<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for OutlivesTest<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for OutlivesTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n "}, {"sha": "26243c765ed13e9701cebf6a0f75f478f0103b07", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -11,7 +11,7 @@ pub type RequiredPredicates<'tcx> = BTreeSet<ty::OutlivesPredicate<Kind<'tcx>, t\n /// Given a requirement `T: 'a` or `'b: 'a`, deduce the\n /// outlives_component and add it to `required_predicates`\n pub fn insert_outlives_predicate<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     kind: Kind<'tcx>,\n     outlived_region: Region<'tcx>,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n@@ -125,7 +125,7 @@ pub fn insert_outlives_predicate<'tcx>(\n     }\n }\n \n-fn is_free_region<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, region: Region<'_>) -> bool {\n+fn is_free_region<'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, region: Region<'_>) -> bool {\n     // First, screen for regions that might appear in a type header.\n     match region {\n         // These correspond to `T: 'a` relationships:"}, {"sha": "325f632ad6deedd76470119a7e989e99c63e8021", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         self.build_constraints_for_item(def_id);\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx, 'tcx> {\n         self.terms_cx.tcx\n     }\n "}, {"sha": "d850e48914539718450e850325bc2298b813427a", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -34,7 +34,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n+fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, crate_num: CrateNum)\n                              -> &'tcx CrateVariancesMap<'tcx> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let mut arena = arena::TypedArena::default();\n@@ -43,7 +43,7 @@ fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n     tcx.arena.alloc(solve::solve_constraints(constraints_cx))\n }\n \n-fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n+fn variances_of<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>, item_def_id: DefId)\n                           -> &'tcx [ty::Variance] {\n     let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {"}, {"sha": "2faae2b2a97b2890018726fb2280d2db7a7a9ed5", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -48,7 +48,7 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n // The first pass over the crate simply builds up the set of inferreds.\n \n pub struct TermsContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n     // For marker types, UnsafeCell, and other lang items where\n@@ -64,7 +64,7 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n }\n \n-pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n                                                      arena: &'a mut TypedArena<VarianceTerm<'a>>)\n                                                      -> TermsContext<'a, 'tcx> {\n     let mut terms_cx = TermsContext {"}, {"sha": "bd4e8d3fd5d7f912530e55dca3334f08cfd865c5", "filename": "src/librustc_typeck/variance/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Ftest.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -3,15 +3,15 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::TyCtxt;\n use syntax::symbol::sym;\n \n-pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn test_variance<'a, 'tcx>(tcx: TyCtxt<'tcx, 'tcx, 'tcx>) {\n     tcx.hir().krate().visit_all_item_likes(&mut VarianceTest { tcx });\n }\n \n-struct VarianceTest<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+struct VarianceTest<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n "}, {"sha": "f40cb09bde84ff58c32f56f01475d5c984c9130e", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -7,7 +7,7 @@ use super::*;\n \n pub struct AutoTraitFinder<'a, 'tcx> {\n     pub cx: &'a core::DocContext<'tcx>,\n-    pub f: auto_trait::AutoTraitFinder<'a, 'tcx>,\n+    pub f: auto_trait::AutoTraitFinder<'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n@@ -315,7 +315,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n     fn extract_for_generics<'b, 'c, 'd>(\n         &self,\n-        tcx: TyCtxt<'b, 'c, 'd>,\n+        tcx: TyCtxt<'d, 'c, 'd>,\n         pred: ty::Predicate<'d>,\n     ) -> FxHashSet<GenericParamDef> {\n         pred.walk_tys()\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // * We explcitly add a '?Sized' bound if we didn't find any 'Sized' predicates for a type\n     fn param_env_to_generics<'b, 'c, 'cx>(\n         &self,\n-        tcx: TyCtxt<'b, 'c, 'cx>,\n+        tcx: TyCtxt<'cx, 'c, 'cx>,\n         param_env_def_id: DefId,\n         param_env: ty::ParamEnv<'cx>,\n         mut existing_predicates: Vec<WherePredicate>,\n@@ -791,11 +791,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n // Replaces all ReVars in a type with ty::Region's, using the provided map\n struct RegionReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx, 'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "7e9f004684d38b4a9b456ec93d8ce48214beced2", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37799a5552d308da5d74d9654036f2f541f3c8c3/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=37799a5552d308da5d74d9654036f2f541f3c8c3", "patch": "@@ -60,7 +60,7 @@ impl CodegenBackend for TheBackend {\n \n     fn codegen_crate<'a, 'tcx>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         _metadata: EncodedMetadata,\n         _need_metadata_module: bool,\n         _rx: mpsc::Receiver<Box<Any + Send>>"}]}