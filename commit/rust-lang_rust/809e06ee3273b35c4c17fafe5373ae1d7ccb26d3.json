{"sha": "809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwOWUwNmVlMzI3M2IzNWM0YzE3ZmFmZTUzNzNhZTFkN2NjYjI2ZDM=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-11-02T02:15:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-02T02:15:38Z"}, "message": "Merge pull request #2102 from topecongiro/soft-wrapping-comments\n\nSoft wrapping for comments", "tree": {"sha": "54be8fe8711abf6f9500c8a3286219972b034e39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54be8fe8711abf6f9500c8a3286219972b034e39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJZ+n/KCRBK7hj4Ov3rIwAAdHIIAGn5FCXyaFhOA6fl37UVsUbE\n6zt6v8DdYw7/O7A+5MCyHQVFNRKXep+vGWm+K6qlRHHX5wnbBep/qRvEtWGNvd5D\no+b0IykeHtZFvnkllTqlGjOOgLgCiiqwVVFn7RcdOSMcGGt5OKOXi0QNeABo2qyv\nPVc/YAE+MC5ItO6fhE3a6dkYY6FdElcbniOfTmFvZnOluVU7SlCLXuEKTwSGKWyk\n1Nw5IvFDpnCKN7VKce0FPrfr9caXoNBEm1OXW7b3HHxXeKYc3bhAAff9e/paVJ3U\nnEkolkiCrgojLAIJdxob7AsigdiVG6RNelgtBMaCgqF/vUcj8QPjhvqlaW2SG24=\n=/Kdz\n-----END PGP SIGNATURE-----\n", "payload": "tree 54be8fe8711abf6f9500c8a3286219972b034e39\nparent be959667c15db7275cfa72100bb7e55ff577a3a0\nparent 471e9110f5eac178ff7d19d28353023ea5a7d0c5\nauthor Nick Cameron <nrc@ncameron.org> 1509588938 +1300\ncommitter GitHub <noreply@github.com> 1509588938 +1300\n\nMerge pull request #2102 from topecongiro/soft-wrapping-comments\n\nSoft wrapping for comments"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "html_url": "https://github.com/rust-lang/rust/commit/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be959667c15db7275cfa72100bb7e55ff577a3a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/be959667c15db7275cfa72100bb7e55ff577a3a0", "html_url": "https://github.com/rust-lang/rust/commit/be959667c15db7275cfa72100bb7e55ff577a3a0"}, {"sha": "471e9110f5eac178ff7d19d28353023ea5a7d0c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/471e9110f5eac178ff7d19d28353023ea5a7d0c5", "html_url": "https://github.com/rust-lang/rust/commit/471e9110f5eac178ff7d19d28353023ea5a7d0c5"}], "stats": {"total": 106, "additions": 93, "deletions": 13}, "files": [{"sha": "d3c4e8f12d7895b971e5168a14e411978a6ce8bc", "filename": "src/comment.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "patch": "@@ -287,12 +287,13 @@ fn rewrite_comment_inner(\n         .checked_sub(closer.len() + opener.len())\n         .unwrap_or(1);\n     let indent_str = shape.indent.to_string(config);\n-    let fmt = StringFormat {\n+    let fmt_indent = shape.indent + (opener.len() - line_start.len());\n+    let mut fmt = StringFormat {\n         opener: \"\",\n         closer: \"\",\n         line_start: line_start,\n         line_end: \"\",\n-        shape: Shape::legacy(max_chars, shape.indent + (opener.len() - line_start.len())),\n+        shape: Shape::legacy(max_chars, fmt_indent),\n         trim_end: true,\n         config: config,\n     };\n@@ -317,26 +318,69 @@ fn rewrite_comment_inner(\n         });\n \n     let mut result = opener.to_owned();\n+    let mut is_prev_line_multi_line = false;\n+    let comment_line_separator = format!(\"\\n{}{}\", indent_str, line_start);\n     for line in lines {\n         if result == opener {\n             if line.is_empty() {\n                 continue;\n             }\n         } else {\n-            result.push('\\n');\n-            result.push_str(&indent_str);\n-            result.push_str(line_start);\n+            if is_prev_line_multi_line && !line.is_empty() {\n+                result.push(' ')\n+            } else {\n+                result.push_str(&comment_line_separator);\n+            }\n         }\n \n-        if config.wrap_comments() && line.len() > max_chars {\n-            let rewrite = rewrite_string(line, &fmt).unwrap_or_else(|| line.to_owned());\n-            result.push_str(&rewrite);\n+        if config.wrap_comments() && line.len() > fmt.shape.width && !has_url(line) {\n+            match rewrite_string(line, &fmt, Some(max_chars)) {\n+                Some(ref s) => {\n+                    is_prev_line_multi_line = s.contains('\\n');\n+                    result.push_str(s);\n+                }\n+                None if is_prev_line_multi_line => {\n+                    // We failed to put the current `line` next to the previous `line`.\n+                    // Remove the trailing space, then start rewrite on the next line.\n+                    result.pop();\n+                    result.push_str(&comment_line_separator);\n+                    fmt.shape = Shape::legacy(max_chars, fmt_indent);\n+                    match rewrite_string(line, &fmt, Some(max_chars)) {\n+                        Some(ref s) => {\n+                            is_prev_line_multi_line = s.contains('\\n');\n+                            result.push_str(s);\n+                        }\n+                        None => {\n+                            is_prev_line_multi_line = false;\n+                            result.push_str(line);\n+                        }\n+                    }\n+                }\n+                None => {\n+                    is_prev_line_multi_line = false;\n+                    result.push_str(line);\n+                }\n+            }\n+\n+            fmt.shape = if is_prev_line_multi_line {\n+                // 1 = \" \"\n+                let offset = 1 + last_line_width(&result) - line_start.len();\n+                Shape {\n+                    width: max_chars.checked_sub(offset).unwrap_or(0),\n+                    indent: fmt_indent,\n+                    offset: fmt.shape.offset + offset,\n+                }\n+            } else {\n+                Shape::legacy(max_chars, fmt_indent)\n+            };\n         } else {\n             if line.is_empty() && result.ends_with(' ') {\n                 // Remove space if this is an empty comment or a doc comment.\n                 result.pop();\n             }\n             result.push_str(line);\n+            fmt.shape = Shape::legacy(max_chars, fmt_indent);\n+            is_prev_line_multi_line = false;\n         }\n     }\n \n@@ -349,6 +393,12 @@ fn rewrite_comment_inner(\n     Some(result)\n }\n \n+/// Returns true if the given string MAY include URLs or alike.\n+fn has_url(s: &str) -> bool {\n+    // This function may return false positive, but should get its job done in most cases.\n+    s.contains(\"https://\") || s.contains(\"http://\") || s.contains(\"ftp://\") || s.contains(\"file://\")\n+}\n+\n /// Given the span, rewrite the missing comment inside it if available.\n /// Note that the given span must only include comments (or leading/trailing whitespaces).\n pub fn rewrite_missing_comment("}, {"sha": "bb3f5e08c2c1b1cfea181a7430d430df90df4f4b", "filename": "src/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "patch": "@@ -1955,7 +1955,11 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     // Remove the quote characters.\n     let str_lit = &string_lit[1..string_lit.len() - 1];\n \n-    rewrite_string(str_lit, &StringFormat::new(shape, context.config))\n+    rewrite_string(\n+        str_lit,\n+        &StringFormat::new(shape.visual_indent(0), context.config),\n+        None,\n+    )\n }\n \n fn string_requires_rewrite("}, {"sha": "43b1ccbcb937146caa602c4781e56ed46f5f664f", "filename": "src/string.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "patch": "@@ -44,13 +44,17 @@ impl<'a> StringFormat<'a> {\n }\n \n // FIXME: simplify this!\n-pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String> {\n+pub fn rewrite_string<'a>(\n+    orig: &str,\n+    fmt: &StringFormat<'a>,\n+    max_width: Option<usize>,\n+) -> Option<String> {\n     // Strip line breaks.\n     let re = Regex::new(r\"([^\\\\](\\\\\\\\)*)\\\\[\\n\\r][[:space:]]*\").unwrap();\n     let stripped_str = re.replace_all(orig, \"$1\");\n \n     let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false).collect::<Vec<&str>>();\n-    let shape = fmt.shape.visual_indent(0);\n+    let shape = fmt.shape;\n     let indent = shape.indent.to_string(fmt.config);\n     let punctuation = \":,;.\";\n \n@@ -67,7 +71,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     let ender_length = fmt.line_end.len();\n     // If we cannot put at least a single character per line, the rewrite won't\n     // succeed.\n-    let max_chars = shape\n+    let mut max_chars = shape\n         .width\n         .checked_sub(fmt.opener.len() + ender_length + 1)? + 1;\n \n@@ -135,6 +139,10 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n \n         // The next line starts where the current line ends.\n         cur_start = cur_end;\n+\n+        if let Some(new_max_chars) = max_width {\n+            max_chars = new_max_chars.checked_sub(fmt.opener.len() + ender_length + 1)? + 1;\n+        }\n     }\n \n     result.push_str(fmt.closer);\n@@ -150,6 +158,6 @@ mod test {\n     fn issue343() {\n         let config = Default::default();\n         let fmt = StringFormat::new(Shape::legacy(2, Indent::empty()), &config);\n-        rewrite_string(\"eq_\", &fmt);\n+        rewrite_string(\"eq_\", &fmt, None);\n     }\n }"}, {"sha": "a73937673842a44a63dae3a52d08e4e62a3f3caa", "filename": "tests/source/soft-wrapping.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/tests%2Fsource%2Fsoft-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/tests%2Fsource%2Fsoft-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fsoft-wrapping.rs?ref=809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "patch": "@@ -0,0 +1,9 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 80\n+// Soft wrapping for comments.\n+\n+// #535, soft wrapping for comments\n+// Compare the lowest `f32` of both inputs for greater than or equal. The\n+// lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is\n+// ggreater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits off\n+// the result are the upper 96 bits of `a`."}, {"sha": "eb5318f83ac35e52165b838a068a7ee237eb5eaa", "filename": "tests/target/soft-wrapping.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/tests%2Ftarget%2Fsoft-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/809e06ee3273b35c4c17fafe5373ae1d7ccb26d3/tests%2Ftarget%2Fsoft-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fsoft-wrapping.rs?ref=809e06ee3273b35c4c17fafe5373ae1d7ccb26d3", "patch": "@@ -0,0 +1,9 @@\n+// rustfmt-wrap_comments: true\n+// rustfmt-max_width: 80\n+// Soft wrapping for comments.\n+\n+// #535, soft wrapping for comments\n+// Compare the lowest `f32` of both inputs for greater than or equal. The\n+// lowest 32 bits of the result will be `0xffffffff` if `a.extract(0)` is\n+// ggreater than or equal `b.extract(0)`, or `0` otherwise. The upper 96 bits\n+// off the result are the upper 96 bits of `a`."}]}