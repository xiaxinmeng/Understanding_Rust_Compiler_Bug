{"sha": "966cae384f1ca4d62a9aa619f1e74e1161ad7236", "node_id": "C_kwDOAAsO6NoAKDk2NmNhZTM4NGYxY2E0ZDYyYTlhYTYxOWYxZTc0ZTExNjFhZDcyMzY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-18T20:43:54Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-18T20:43:54Z"}, "message": "minor: Simplify", "tree": {"sha": "83f948ca0e0b6bae6e551e84ccf53e2ff93a18dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83f948ca0e0b6bae6e551e84ccf53e2ff93a18dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/966cae384f1ca4d62a9aa619f1e74e1161ad7236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/966cae384f1ca4d62a9aa619f1e74e1161ad7236", "html_url": "https://github.com/rust-lang/rust/commit/966cae384f1ca4d62a9aa619f1e74e1161ad7236", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/966cae384f1ca4d62a9aa619f1e74e1161ad7236/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f72512f1c61a915402979ffe83dd2ac09970ab27", "url": "https://api.github.com/repos/rust-lang/rust/commits/f72512f1c61a915402979ffe83dd2ac09970ab27", "html_url": "https://github.com/rust-lang/rust/commit/f72512f1c61a915402979ffe83dd2ac09970ab27"}], "stats": {"total": 184, "additions": 92, "deletions": 92}, "files": [{"sha": "711062c71327f2d55f6b1a1b15bbc86991b291f9", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/966cae384f1ca4d62a9aa619f1e74e1161ad7236/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966cae384f1ca4d62a9aa619f1e74e1161ad7236/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=966cae384f1ca4d62a9aa619f1e74e1161ad7236", "patch": "@@ -723,34 +723,32 @@ impl Attr {\n     /// to derive macros.\n     ///\n     /// Returns `None` when the attribute does not have a well-formed `#[derive]` attribute input.\n-    pub(crate) fn parse_derive(&self) -> Option<impl Iterator<Item = ModPath>> {\n-        if let Some(AttrInput::TokenTree(args, _)) = self.input.as_deref() {\n-            if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n-                return None;\n-            }\n-            let mut counter = 0;\n-            let paths = args\n-                .token_trees\n-                .iter()\n-                .group_by(move |tt| {\n-                    if let tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. })) = tt {\n-                        counter += 1;\n-                    }\n-                    counter\n-                })\n-                .into_iter()\n-                .map(|(_, tts)| {\n-                    let segments = tts.filter_map(|tt| match tt {\n-                        tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n-                        _ => None,\n-                    });\n-                    ModPath::from_segments(PathKind::Plain, segments)\n-                })\n-                .collect::<Vec<_>>();\n-\n-            return Some(paths.into_iter());\n+    pub(crate) fn parse_derive(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n+        let args = match self.input.as_deref() {\n+            Some(AttrInput::TokenTree(args, _)) => args,\n+            _ => return None,\n+        };\n+\n+        if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n+            return None;\n         }\n-        None\n+        let paths = args\n+            .token_trees\n+            .iter()\n+            .group_by(|tt| {\n+                matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. })))\n+            })\n+            .into_iter()\n+            .map(|(_, tts)| {\n+                let segments = tts.filter_map(|tt| match tt {\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n+                    _ => None,\n+                });\n+                ModPath::from_segments(PathKind::Plain, segments)\n+            })\n+            .collect::<Vec<_>>();\n+\n+        return Some(paths.into_iter());\n     }\n \n     pub fn string_value(&self) -> Option<&SmolStr> {"}, {"sha": "964af8a8a4225a4164549d066c0851764465f98a", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/966cae384f1ca4d62a9aa619f1e74e1161ad7236/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966cae384f1ca4d62a9aa619f1e74e1161ad7236/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=966cae384f1ca4d62a9aa619f1e74e1161ad7236", "patch": "@@ -226,13 +226,6 @@ enum MacroDirectiveKind {\n     Attr { ast_id: AstIdWithPath<ast::Item>, attr: Attr, mod_item: ModItem },\n }\n \n-struct DefData<'a> {\n-    id: ModuleDefId,\n-    name: &'a Name,\n-    visibility: &'a RawVisibility,\n-    has_constructor: bool,\n-}\n-\n /// Walks the tree of module recursively\n struct DefCollector<'a> {\n     db: &'a dyn DefDatabase,\n@@ -1353,19 +1346,18 @@ impl DefCollector<'_> {\n         }\n \n         for directive in &self.unresolved_imports {\n-            if let ImportSource::Import { id: import, use_tree } = &directive.import.source {\n-                if let (Some(krate), PathKind::Plain | PathKind::Abs) =\n-                    (directive.import.path.segments().first(), &directive.import.path.kind)\n-                {\n-                    if diagnosed_extern_crates.contains(krate) {\n-                        continue;\n-                    }\n+            if let ImportSource::Import { id: import, use_tree } = directive.import.source {\n+                if matches!(\n+                    (directive.import.path.segments().first(), &directive.import.path.kind),\n+                    (Some(krate), PathKind::Plain | PathKind::Abs) if diagnosed_extern_crates.contains(krate)\n+                ) {\n+                    continue;\n                 }\n \n                 self.def_map.diagnostics.push(DefDiagnostic::unresolved_import(\n                     directive.module_id,\n-                    *import,\n-                    *use_tree,\n+                    import,\n+                    use_tree,\n                 ));\n             }\n         }\n@@ -1386,6 +1378,13 @@ struct ModCollector<'a, 'b> {\n \n impl ModCollector<'_, '_> {\n     fn collect(&mut self, items: &[ModItem]) {\n+        struct DefData<'a> {\n+            id: ModuleDefId,\n+            name: &'a Name,\n+            visibility: &'a RawVisibility,\n+            has_constructor: bool,\n+        }\n+\n         let krate = self.def_collector.def_map.krate;\n \n         // Note: don't assert that inserted value is fresh: it's simply not true\n@@ -1403,18 +1402,18 @@ impl ModCollector<'_, '_> {\n         // This should be processed eagerly instead of deferred to resolving.\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n-        for item in items {\n-            let attrs = self.item_tree.attrs(self.def_collector.db, krate, (*item).into());\n+        for &item in items {\n+            let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n             if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n                 if let ModItem::ExternCrate(id) = item {\n-                    let import = self.item_tree[*id].clone();\n+                    let import = &self.item_tree[id];\n                     let attrs = self.item_tree.attrs(\n                         self.def_collector.db,\n                         krate,\n-                        ModItem::from(*id).into(),\n+                        ModItem::from(id).into(),\n                     );\n                     if attrs.by_key(\"macro_use\").exists() {\n-                        self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n+                        self.def_collector.import_macros_from_extern_crate(self.module_id, import);\n                     }\n                 }\n             }\n@@ -1656,9 +1655,7 @@ impl ModCollector<'_, '_> {\n                         let is_enabled = item_tree\n                             .top_level_attrs(db, self.def_collector.def_map.krate)\n                             .cfg()\n-                            .map_or(true, |cfg| {\n-                                self.def_collector.cfg_options.check(&cfg) != Some(false)\n-                            });\n+                            .map_or(true, |cfg| self.is_cfg_enabled(&cfg));\n                         if is_enabled {\n                             let module_id = self.push_child_module(\n                                 module.name.clone(),\n@@ -1675,12 +1672,12 @@ impl ModCollector<'_, '_> {\n                                 mod_dir,\n                             }\n                             .collect(item_tree.top_level_items());\n-                            if is_macro_use\n+                            let is_macro_use = is_macro_use\n                                 || item_tree\n                                     .top_level_attrs(db, self.def_collector.def_map.krate)\n                                     .by_key(\"macro_use\")\n-                                    .exists()\n-                            {\n+                                    .exists();\n+                            if is_macro_use {\n                                 self.import_all_legacy_macros(module_id);\n                             }\n                         }\n@@ -1714,14 +1711,17 @@ impl ModCollector<'_, '_> {\n                 ModuleOrigin::File { declaration, definition, is_mod_rs }\n             }\n         };\n+\n         let res = modules.alloc(ModuleData::new(origin, vis));\n         modules[res].parent = Some(self.module_id);\n         for (name, mac) in modules[self.module_id].scope.collect_legacy_macros() {\n             modules[res].scope.define_legacy_macro(name, mac)\n         }\n         modules[self.module_id].children.insert(name.clone(), res);\n+\n         let module = self.def_collector.def_map.module_id(res);\n-        let def: ModuleDefId = module.into();\n+        let def = ModuleDefId::from(module);\n+\n         self.def_collector.def_map.modules[self.module_id].scope.declare(def);\n         self.def_collector.update(\n             self.module_id,\n@@ -1786,30 +1786,29 @@ impl ModCollector<'_, '_> {\n     }\n \n     fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {\n-        if path.kind == PathKind::Plain {\n-            if let Some(tool_module) = path.segments().first() {\n-                let tool_module = tool_module.to_smol_str();\n-                let is_tool = builtin_attr::TOOL_MODULES\n-                    .iter()\n-                    .copied()\n-                    .chain(self.def_collector.registered_tools.iter().map(SmolStr::as_str))\n-                    .any(|m| tool_module == *m);\n-                if is_tool {\n-                    return true;\n-                }\n+        if path.kind != PathKind::Plain {\n+            return false;\n+        }\n+\n+        let segments = path.segments();\n+\n+        if let Some(name) = segments.first() {\n+            let name = name.to_smol_str();\n+            let pred = |n: &_| *n == name;\n+\n+            let registered = self.def_collector.registered_tools.iter().map(SmolStr::as_str);\n+            let is_tool = builtin_attr::TOOL_MODULES.iter().copied().chain(registered).any(pred);\n+            if is_tool {\n+                return true;\n             }\n \n-            if let Some(name) = path.as_ident() {\n-                let name = name.to_smol_str();\n-                let is_inert = builtin_attr::INERT_ATTRIBUTES\n-                    .iter()\n-                    .copied()\n-                    .chain(self.def_collector.registered_attrs.iter().map(SmolStr::as_str))\n-                    .any(|attr| name == *attr);\n+            if segments.len() == 1 {\n+                let registered = self.def_collector.registered_attrs.iter().map(SmolStr::as_str);\n+                let is_inert =\n+                    builtin_attr::INERT_ATTRIBUTES.iter().copied().chain(registered).any(pred);\n                 return is_inert;\n             }\n         }\n-\n         false\n     }\n \n@@ -1831,7 +1830,7 @@ impl ModCollector<'_, '_> {\n \n         let is_export = export_attr.exists();\n         let is_local_inner = if is_export {\n-            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n+            export_attr.tt_values().flat_map(|it| &it.token_trees).any(|it| match it {\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n                     ident.text.contains(\"local_inner_macros\")\n                 }\n@@ -1852,12 +1851,14 @@ impl ModCollector<'_, '_> {\n                     &name\n                 }\n                 None => {\n-                    match attrs.by_key(\"rustc_builtin_macro\").tt_values().next().and_then(|tt| {\n-                        match tt.token_trees.first() {\n-                            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(name))) => Some(name),\n-                            _ => None,\n-                        }\n-                    }) {\n+                    let explicit_name =\n+                        attrs.by_key(\"rustc_builtin_macro\").tt_values().next().and_then(|tt| {\n+                            match tt.token_trees.first() {\n+                                Some(tt::TokenTree::Leaf(tt::Leaf::Ident(name))) => Some(name),\n+                                _ => None,\n+                            }\n+                        });\n+                    match explicit_name {\n                         Some(ident) => {\n                             name = ident.as_name();\n                             &name\n@@ -1947,7 +1948,7 @@ impl ModCollector<'_, '_> {\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall) {\n-        let ast_id = AstIdWithPath::new(self.file_id(), mac.ast_id, (*mac.path).clone());\n+        let ast_id = AstIdWithPath::new(self.file_id(), mac.ast_id, ModPath::clone(&mac.path));\n \n         // Case 1: try to resolve in legacy scope and expand macro_rules\n         let mut error = None;"}, {"sha": "b6f1b1787021bb331bb2ce504383700a2e0b6968", "filename": "crates/hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/966cae384f1ca4d62a9aa619f1e74e1161ad7236/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/966cae384f1ca4d62a9aa619f1e74e1161ad7236/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=966cae384f1ca4d62a9aa619f1e74e1161ad7236", "patch": "@@ -24,22 +24,13 @@ impl ModDir {\n     pub(super) fn root() -> ModDir {\n         ModDir { dir_path: DirPath::empty(), root_non_dir_owner: false, depth: 0 }\n     }\n-    fn child(&self, dir_path: DirPath, root_non_dir_owner: bool) -> Option<ModDir> {\n-        let depth = self.depth + 1;\n-        if MOD_DEPTH_LIMIT.check(depth as usize).is_err() {\n-            tracing::error!(\"MOD_DEPTH_LIMIT exceeded\");\n-            cov_mark::hit!(circular_mods);\n-            return None;\n-        }\n-        Some(ModDir { dir_path, root_non_dir_owner, depth })\n-    }\n \n     pub(super) fn descend_into_definition(\n         &self,\n         name: &Name,\n         attr_path: Option<&SmolStr>,\n     ) -> Option<ModDir> {\n-        let path = match attr_path.map(|it| it.as_str()) {\n+        let path = match attr_path.map(SmolStr::as_str) {\n             None => {\n                 let mut path = self.dir_path.clone();\n                 path.push(&name.to_smol_str());\n@@ -56,6 +47,16 @@ impl ModDir {\n         self.child(path, false)\n     }\n \n+    fn child(&self, dir_path: DirPath, root_non_dir_owner: bool) -> Option<ModDir> {\n+        let depth = self.depth + 1;\n+        if MOD_DEPTH_LIMIT.check(depth as usize).is_err() {\n+            tracing::error!(\"MOD_DEPTH_LIMIT exceeded\");\n+            cov_mark::hit!(circular_mods);\n+            return None;\n+        }\n+        Some(ModDir { dir_path, root_non_dir_owner, depth })\n+    }\n+\n     pub(super) fn resolve_declaration(\n         &self,\n         db: &dyn DefDatabase,"}]}