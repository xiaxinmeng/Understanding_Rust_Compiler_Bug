{"sha": "9295454ff58cd11b00499d25d1a17b34e8fd7182", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOTU0NTRmZjU4Y2QxMWIwMDQ5OWQyNWQxYTE3YjM0ZThmZDcxODI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-05-18T13:56:13Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-14T01:20:34Z"}, "message": "rustdoc: fix fallout from using ptr::P.", "tree": {"sha": "01a0617c3ab1f87dde66afe416b8798aaa222ed8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01a0617c3ab1f87dde66afe416b8798aaa222ed8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9295454ff58cd11b00499d25d1a17b34e8fd7182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9295454ff58cd11b00499d25d1a17b34e8fd7182", "html_url": "https://github.com/rust-lang/rust/commit/9295454ff58cd11b00499d25d1a17b34e8fd7182", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9295454ff58cd11b00499d25d1a17b34e8fd7182/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b06212864f77d87779656379b3773c1096dbf9e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b06212864f77d87779656379b3773c1096dbf9e1", "html_url": "https://github.com/rust-lang/rust/commit/b06212864f77d87779656379b3773c1096dbf9e1"}], "stats": {"total": 281, "additions": 127, "deletions": 154}, "files": [{"sha": "e6fcbbe9b6ff35c800852f974919fe67c6485621", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9295454ff58cd11b00499d25d1a17b34e8fd7182", "patch": "@@ -20,6 +20,7 @@ use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::Pos;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n+use syntax::ptr::P;\n \n use rustc::back::link;\n use rustc::driver::driver;\n@@ -34,7 +35,6 @@ use rustc::middle::stability;\n \n use std::rc::Rc;\n use std::u32;\n-use std::gc::{Gc, GC};\n \n use core::DocContext;\n use doctree;\n@@ -67,7 +67,7 @@ impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n     }\n }\n \n-impl<T: 'static + Clean<U>, U> Clean<U> for Gc<T> {\n+impl<T: Clean<U>, U> Clean<U> for P<T> {\n     fn clean(&self, cx: &DocContext) -> U {\n         (**self).clean(cx)\n     }\n@@ -408,7 +408,7 @@ impl Clean<Attribute> for ast::MetaItem {\n \n impl Clean<Attribute> for ast::Attribute {\n     fn clean(&self, cx: &DocContext) -> Attribute {\n-        self.desugar_doc().node.value.clean(cx)\n+        self.with_desugared_doc(|a| a.node.value.clean(cx))\n     }\n }\n \n@@ -430,12 +430,12 @@ impl attr::AttrMetaMethods for Attribute {\n             _ => None,\n         }\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n }\n impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [Gc<ast::MetaItem>]> { None }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<ast::MetaItem>]> { None }\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n@@ -758,10 +758,10 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n         match *self {\n             ast::SelfStatic => SelfStatic,\n             ast::SelfValue(_) => SelfValue,\n-            ast::SelfRegion(lt, mt, _) => {\n+            ast::SelfRegion(ref lt, ref mt, _) => {\n                 SelfBorrowed(lt.clean(cx), mt.clean(cx))\n             }\n-            ast::SelfExplicit(typ, _) => SelfExplicit(typ.clean(cx)),\n+            ast::SelfExplicit(ref typ, _) => SelfExplicit(typ.clean(cx)),\n         }\n     }\n }\n@@ -1189,11 +1189,11 @@ impl Clean<Type> for ast::Ty {\n             TyRptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n-            TyBox(ty) => Managed(box ty.clean(cx)),\n-            TyUniq(ty) => Unique(box ty.clean(cx)),\n-            TyVec(ty) => Vector(box ty.clean(cx)),\n-            TyFixedLengthVec(ty, ref e) => FixedVector(box ty.clean(cx),\n-                                                       e.span.to_src(cx)),\n+            TyBox(ref ty) => Managed(box ty.clean(cx)),\n+            TyUniq(ref ty) => Unique(box ty.clean(cx)),\n+            TyVec(ref ty) => Vector(box ty.clean(cx)),\n+            TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n+                                                           e.span.to_src(cx)),\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(ref p, ref tpbs, id) => {\n                 resolve_type(cx, p.clean(cx), tpbs.clean(cx), id)\n@@ -1799,7 +1799,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                                                          remaining,\n                                                          b.clone());\n                             let path = syntax::codemap::dummy_spanned(path);\n-                            ret.push(convert(&ast::ViewItemUse(box(GC) path)));\n+                            ret.push(convert(&ast::ViewItemUse(P(path))));\n                         }\n                     }\n                     ast::ViewPathSimple(ident, _, id) => {\n@@ -1985,8 +1985,8 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         },\n         PatTup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().connect(\", \")),\n-        PatBox(p) => name_from_pat(&*p),\n-        PatRegion(p) => name_from_pat(&*p),\n+        PatBox(ref p) => name_from_pat(&**p),\n+        PatRegion(ref p) => name_from_pat(&**p),\n         PatLit(..) => {\n             warn!(\"tried to get argument name from PatLit, \\\n                   which is silly in function arguments\");"}, {"sha": "ddb4b994ca38e157e4d326433f13b1909f64de43", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 42, "deletions": 53, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9295454ff58cd11b00499d25d1a17b34e8fd7182", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc;\n-use rustc::{driver, middle};\n+use rustc::driver::{config, driver, session};\n use rustc::middle::{privacy, ty};\n use rustc::lint;\n use rustc::back::link;\n \n-use syntax::ast;\n+use syntax::{ast, ast_map, codemap, diagnostic};\n use syntax::parse::token;\n-use syntax;\n+use syntax::ptr::P;\n \n use std::cell::RefCell;\n-use std::gc::GC;\n use std::os;\n use std::collections::{HashMap, HashSet};\n use arena::TypedArena;\n@@ -30,15 +28,15 @@ use clean::Clean;\n \n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped<'tcx> {\n-    Typed(middle::ty::ctxt<'tcx>),\n-    NotTyped(driver::session::Session)\n+    Typed(ty::ctxt<'tcx>),\n+    NotTyped(session::Session)\n }\n \n pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n                                                 (Vec<String>, clean::TypeKind)>>>;\n \n pub struct DocContext<'tcx> {\n-    pub krate: ast::Crate,\n+    pub krate: &'tcx ast::Crate,\n     pub maybe_typed: MaybeTyped<'tcx>,\n     pub src: Path,\n     pub external_paths: ExternalPaths,\n@@ -49,7 +47,7 @@ pub struct DocContext<'tcx> {\n }\n \n impl<'tcx> DocContext<'tcx> {\n-    pub fn sess<'a>(&'a self) -> &'a driver::session::Session {\n+    pub fn sess<'a>(&'a self) -> &'a session::Session {\n         match self.maybe_typed {\n             Typed(ref tcx) => &tcx.sess,\n             NotTyped(ref sess) => sess\n@@ -80,91 +78,82 @@ pub struct CrateAnalysis {\n \n pub type Externs = HashMap<String, Vec<String>>;\n \n-/// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve<'tcx>(cpath: &Path, libs: Vec<Path>, cfgs: Vec<String>,\n-                             externs: Externs, triple: Option<String>,\n-                             type_arena: &'tcx TypedArena<ty::t_box_>)\n-                             -> (DocContext<'tcx>, CrateAnalysis) {\n-    use syntax::codemap::dummy_spanned;\n-    use rustc::driver::driver::{FileInput,\n-                                phase_1_parse_input,\n-                                phase_2_configure_and_expand,\n-                                phase_3_run_analysis_passes};\n-    use rustc::driver::config::build_configuration;\n+pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n+                cpath: &Path, triple: Option<String>)\n+                -> (clean::Crate, CrateAnalysis) {\n \n-    let input = FileInput(cpath.clone());\n+    // Parse, resolve, and typecheck the given crate.\n+\n+    let input = driver::FileInput(cpath.clone());\n \n     let warning_lint = lint::builtin::WARNINGS.name_lower();\n \n-    let sessopts = driver::config::Options {\n+    let sessopts = config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n-        crate_types: vec!(driver::config::CrateTypeRlib),\n+        crate_types: vec!(config::CrateTypeRlib),\n         lint_opts: vec!((warning_lint, lint::Allow)),\n         externs: externs,\n-        target_triple: triple.unwrap_or(driver::driver::host_triple().to_string()),\n-        ..rustc::driver::config::basic_options().clone()\n+        target_triple: triple.unwrap_or(driver::host_triple().to_string()),\n+        ..config::basic_options().clone()\n     };\n \n \n-    let codemap = syntax::codemap::CodeMap::new();\n-    let diagnostic_handler = syntax::diagnostic::default_handler(syntax::diagnostic::Auto, None);\n+    let codemap = codemap::CodeMap::new();\n+    let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n     let span_diagnostic_handler =\n-        syntax::diagnostic::mk_span_handler(diagnostic_handler, codemap);\n+        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    let sess = driver::session::build_session_(sessopts,\n-                                               Some(cpath.clone()),\n-                                               span_diagnostic_handler);\n+    let sess = session::build_session_(sessopts,\n+                                       Some(cpath.clone()),\n+                                       span_diagnostic_handler);\n \n-    let mut cfg = build_configuration(&sess);\n+    let mut cfg = config::build_configuration(&sess);\n     for cfg_ in cfgs.move_iter() {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n-        cfg.push(box(GC) dummy_spanned(ast::MetaWord(cfg_)));\n+        cfg.push(P(codemap::dummy_spanned(ast::MetaWord(cfg_))));\n     }\n \n-    let krate = phase_1_parse_input(&sess, cfg, &input);\n+    let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n \n     let name = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n                                      &input);\n \n-    let (krate, ast_map)\n-        = phase_2_configure_and_expand(&sess, krate, name.as_slice(), None)\n-            .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n+    let krate = driver::phase_2_configure_and_expand(&sess, krate, name.as_slice(), None)\n+                    .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n+\n+    let mut forest = ast_map::Forest::new(krate);\n+    let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-    let driver::driver::CrateAnalysis {\n+    let type_arena = TypedArena::new();\n+    let driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n-    } = phase_3_run_analysis_passes(sess, &krate, ast_map, type_arena, name);\n+    } = driver::phase_3_run_analysis_passes(sess, ast_map, &type_arena, name);\n \n-    debug!(\"crate: {:?}\", krate);\n-    (DocContext {\n-        krate: krate,\n+    let ctxt = DocContext {\n+        krate: ty_cx.map.krate(),\n         maybe_typed: Typed(ty_cx),\n         src: cpath.clone(),\n         external_traits: RefCell::new(Some(HashMap::new())),\n         external_typarams: RefCell::new(Some(HashMap::new())),\n         external_paths: RefCell::new(Some(HashMap::new())),\n         inlined: RefCell::new(Some(HashSet::new())),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n-    }, CrateAnalysis {\n+    };\n+    debug!(\"crate: {:?}\", ctxt.krate);\n+\n+    let analysis = CrateAnalysis {\n         exported_items: exported_items,\n         public_items: public_items,\n         external_paths: RefCell::new(None),\n         external_traits: RefCell::new(None),\n         external_typarams: RefCell::new(None),\n         inlined: RefCell::new(None),\n-    })\n-}\n-\n-pub fn run_core(libs: Vec<Path>, cfgs: Vec<String>, externs: Externs,\n-                path: &Path, triple: Option<String>)\n-                -> (clean::Crate, CrateAnalysis) {\n-    let type_arena = TypedArena::new();\n-    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs,\n-                                               triple, &type_arena);\n+    };\n \n     let krate = {\n         let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n-        v.visit(&ctxt.krate);\n+        v.visit(ctxt.krate);\n         v.clean(&ctxt)\n     };\n "}, {"sha": "72964609049bf5fa61a2aff488e5fb7c46009e5e", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=9295454ff58cd11b00499d25d1a17b34e8fd7182", "patch": "@@ -16,8 +16,7 @@ use syntax::codemap::Span;\n use syntax::ast;\n use syntax::attr;\n use syntax::ast::{Ident, NodeId};\n-\n-use std::gc::Gc;\n+use syntax::ptr::P;\n \n pub struct Module {\n     pub name: Option<Ident>,\n@@ -130,7 +129,7 @@ pub struct Function {\n }\n \n pub struct Typedef {\n-    pub ty: ast::P<ast::Ty>,\n+    pub ty: P<ast::Ty>,\n     pub gen: ast::Generics,\n     pub name: Ident,\n     pub id: ast::NodeId,\n@@ -141,9 +140,9 @@ pub struct Typedef {\n }\n \n pub struct Static {\n-    pub type_: ast::P<ast::Ty>,\n+    pub type_: P<ast::Ty>,\n     pub mutability: ast::Mutability,\n-    pub expr: Gc<ast::Expr>,\n+    pub expr: P<ast::Expr>,\n     pub name: Ident,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: ast::Visibility,\n@@ -167,7 +166,7 @@ pub struct Trait {\n pub struct Impl {\n     pub generics: ast::Generics,\n     pub trait_: Option<ast::TraitRef>,\n-    pub for_: ast::P<ast::Ty>,\n+    pub for_: P<ast::Ty>,\n     pub items: Vec<ast::ImplItem>,\n     pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,"}, {"sha": "b7c602d9d730f7bf14ecd8d338489b61f9f6e77c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9295454ff58cd11b00499d25d1a17b34e8fd7182", "patch": "@@ -11,7 +11,6 @@\n use std::cell::RefCell;\n use std::char;\n use std::dynamic_lib::DynamicLibrary;\n-use std::gc::GC;\n use std::io::{Command, TempDir};\n use std::io;\n use std::os;\n@@ -28,6 +27,7 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, dummy_spanned};\n use syntax::diagnostic;\n use syntax::parse::token;\n+use syntax::ptr::P;\n \n use core;\n use clean;\n@@ -67,15 +67,15 @@ pub fn run(input: &str,\n     let mut cfg = config::build_configuration(&sess);\n     cfg.extend(cfgs.move_iter().map(|cfg_| {\n         let cfg_ = token::intern_and_get_ident(cfg_.as_slice());\n-        box(GC) dummy_spanned(ast::MetaWord(cfg_))\n+        P(dummy_spanned(ast::MetaWord(cfg_)))\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n-    let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n-                                                          \"rustdoc-test\", None)\n+    let krate = driver::phase_2_configure_and_expand(&sess, krate,\n+                                                     \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let ctx = core::DocContext {\n-        krate: krate,\n+        krate: &krate,\n         maybe_typed: core::NotTyped(sess),\n         src: input_path,\n         external_paths: RefCell::new(Some(HashMap::new())),\n@@ -86,7 +86,7 @@ pub fn run(input: &str,\n     };\n \n     let mut v = RustdocVisitor::new(&ctx, None);\n-    v.visit(&ctx.krate);\n+    v.visit(ctx.krate);\n     let mut krate = v.clean(&ctx);\n     match crate_name {\n         Some(name) => krate.name = name,"}, {"sha": "a9e0c9cb260f65f21ad9e276034bc69e456e1ea3", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 59, "deletions": 74, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9295454ff58cd11b00499d25d1a17b34e8fd7182/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9295454ff58cd11b00499d25d1a17b34e8fd7182", "patch": "@@ -18,11 +18,10 @@ use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n+use syntax::ptr::P;\n \n use rustc::middle::stability;\n \n-use std::gc::{Gc, GC};\n-\n use core;\n use doctree::*;\n \n@@ -57,13 +56,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit(&mut self, krate: &ast::Crate) {\n-        self.attrs = krate.attrs.iter().map(|x| (*x).clone()).collect();\n+        self.attrs = krate.attrs.clone();\n \n         self.module = self.visit_mod_contents(krate.span,\n-                                              krate.attrs\n-                                                   .iter()\n-                                                   .map(|x| *x)\n-                                                   .collect(),\n+                                              krate.attrs.clone(),\n                                               ast::Public,\n                                               ast::CRATE_NODE_ID,\n                                               &krate.module,\n@@ -74,61 +70,60 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.module.is_crate = true;\n     }\n \n-    pub fn visit_struct_def(&mut self, item: &ast::Item, sd: Gc<ast::StructDef>,\n+    pub fn visit_struct_def(&mut self, item: &ast::Item,\n+                            name: ast::Ident, sd: &ast::StructDef,\n                             generics: &ast::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n         Struct {\n             id: item.id,\n             struct_type: struct_type,\n-            name: item.ident,\n+            name: name,\n             vis: item.vis,\n             stab: self.stability(item.id),\n-            attrs: item.attrs.iter().map(|x| *x).collect(),\n+            attrs: item.attrs.clone(),\n             generics: generics.clone(),\n-            fields: sd.fields.iter().map(|x| (*x).clone()).collect(),\n+            fields: sd.fields.clone(),\n             whence: item.span\n         }\n     }\n \n-    pub fn visit_enum_def(&mut self, it: &ast::Item, def: &ast::EnumDef,\n+    pub fn visit_enum_def(&mut self, it: &ast::Item,\n+                          name: ast::Ident, def: &ast::EnumDef,\n                           params: &ast::Generics) -> Enum {\n         debug!(\"Visiting enum\");\n-        let mut vars: Vec<Variant> = Vec::new();\n-        for x in def.variants.iter() {\n-            vars.push(Variant {\n-                name: x.node.name,\n-                attrs: x.node.attrs.iter().map(|x| *x).collect(),\n-                vis: x.node.vis,\n-                stab: self.stability(x.node.id),\n-                id: x.node.id,\n-                kind: x.node.kind.clone(),\n-                whence: x.span,\n-            });\n-        }\n         Enum {\n-            name: it.ident,\n-            variants: vars,\n+            name: name,\n+            variants: def.variants.iter().map(|v| Variant {\n+                name: v.node.name,\n+                attrs: v.node.attrs.clone(),\n+                vis: v.node.vis,\n+                stab: self.stability(v.node.id),\n+                id: v.node.id,\n+                kind: v.node.kind.clone(),\n+                whence: v.span,\n+            }).collect(),\n             vis: it.vis,\n             stab: self.stability(it.id),\n             generics: params.clone(),\n-            attrs: it.attrs.iter().map(|x| *x).collect(),\n+            attrs: it.attrs.clone(),\n             id: it.id,\n             whence: it.span,\n         }\n     }\n \n-    pub fn visit_fn(&mut self, item: &ast::Item, fd: &ast::FnDecl,\n+    pub fn visit_fn(&mut self, item: &ast::Item,\n+                    name: ast::Ident, fd: &ast::FnDecl,\n                     fn_style: &ast::FnStyle, _abi: &abi::Abi,\n                     gen: &ast::Generics) -> Function {\n         debug!(\"Visiting fn\");\n         Function {\n             id: item.id,\n             vis: item.vis,\n             stab: self.stability(item.id),\n-            attrs: item.attrs.iter().map(|x| *x).collect(),\n+            attrs: item.attrs.clone(),\n             decl: fd.clone(),\n-            name: item.ident,\n+            name: name,\n             whence: item.span,\n             generics: gen.clone(),\n             fn_style: *fn_style,\n@@ -150,7 +145,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.stab = self.stability(id);\n         om.id = id;\n         for i in m.items.iter() {\n-            self.visit_item(&**i, &mut om);\n+            self.visit_item(&**i, None, &mut om);\n         }\n         om\n     }\n@@ -169,7 +164,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         });\n         let item = match item.node {\n             ast::ViewItemUse(ref vpath) => {\n-                match self.visit_view_path(*vpath, om, please_inline) {\n+                match self.visit_view_path(&**vpath, om, please_inline) {\n                     None => return,\n                     Some(path) => {\n                         ast::ViewItem {\n@@ -184,9 +179,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.view_items.push(item);\n     }\n \n-    fn visit_view_path(&mut self, path: Gc<ast::ViewPath>,\n+    fn visit_view_path(&mut self, path: &ast::ViewPath,\n                        om: &mut Module,\n-                       please_inline: bool) -> Option<Gc<ast::ViewPath>> {\n+                       please_inline: bool) -> Option<P<ast::ViewPath>> {\n         match path.node {\n             ast::ViewPathSimple(dst, _, id) => {\n                 if self.resolve_id(id, Some(dst), false, om, please_inline) {\n@@ -203,10 +198,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n \n                 if mine.len() == 0 { return None }\n-                return Some(box(GC) ::syntax::codemap::Spanned {\n+                return Some(P(::syntax::codemap::Spanned {\n                     node: ast::ViewPathList(p.clone(), mine, b.clone()),\n                     span: path.span,\n-                })\n+                }))\n             }\n \n             // these are feature gated anyway\n@@ -216,7 +211,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        return Some(path);\n+        Some(P(path.clone()))\n     }\n \n     fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n@@ -236,77 +231,67 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         match tcx.map.get(def.node) {\n             ast_map::NodeItem(it) => {\n-                let it = match renamed {\n-                    Some(ident) => {\n-                        box(GC) ast::Item {\n-                            ident: ident,\n-                            ..(*it).clone()\n-                        }\n-                    }\n-                    None => it,\n-                };\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {\n                             for vi in m.view_items.iter() {\n                                 self.visit_view_item(vi, om);\n                             }\n                             for i in m.items.iter() {\n-                                self.visit_item(&**i, om);\n+                                self.visit_item(&**i, None, om);\n                             }\n                         }\n                         _ => { fail!(\"glob not mapped to a module\"); }\n                     }\n                 } else {\n-                    self.visit_item(&*it, om);\n+                    self.visit_item(it, renamed, om);\n                 }\n                 true\n             }\n             _ => false,\n         }\n     }\n \n-    pub fn visit_item(&mut self, item: &ast::Item, om: &mut Module) {\n+    pub fn visit_item(&mut self, item: &ast::Item,\n+                      renamed: Option<ast::Ident>, om: &mut Module) {\n         debug!(\"Visiting item {:?}\", item);\n+        let name = renamed.unwrap_or(item.ident);\n         match item.node {\n             ast::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n-                                                     item.attrs\n-                                                         .iter()\n-                                                         .map(|x| *x)\n-                                                         .collect(),\n+                                                     item.attrs.clone(),\n                                                      item.vis,\n                                                      item.id,\n                                                      m,\n-                                                     Some(item.ident)));\n+                                                     Some(name)));\n             },\n             ast::ItemEnum(ref ed, ref gen) =>\n-                om.enums.push(self.visit_enum_def(item, ed, gen)),\n-            ast::ItemStruct(sd, ref gen) =>\n-                om.structs.push(self.visit_struct_def(item, sd, gen)),\n+                om.enums.push(self.visit_enum_def(item, name, ed, gen)),\n+            ast::ItemStruct(ref sd, ref gen) =>\n+                om.structs.push(self.visit_struct_def(item, name, &**sd, gen)),\n             ast::ItemFn(ref fd, ref pur, ref abi, ref gen, _) =>\n-                om.fns.push(self.visit_fn(item, &**fd, pur, abi, gen)),\n-            ast::ItemTy(ty, ref gen) => {\n+                om.fns.push(self.visit_fn(item, name, &**fd, pur, abi, gen)),\n+            ast::ItemTy(ref ty, ref gen) => {\n                 let t = Typedef {\n-                    ty: ty,\n+                    ty: ty.clone(),\n                     gen: gen.clone(),\n-                    name: item.ident,\n+                    name: name,\n                     id: item.id,\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n+                    attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n                 };\n                 om.typedefs.push(t);\n             },\n-            ast::ItemStatic(ty, ref mut_, ref exp) => {\n+            ast::ItemStatic(ref ty, ref mut_, ref exp) => {\n                 let s = Static {\n-                    type_: ty,\n+                    type_: ty.clone(),\n                     mutability: mut_.clone(),\n                     expr: exp.clone(),\n                     id: item.id,\n-                    name: item.ident,\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n+                    name: name,\n+                    attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n@@ -315,25 +300,25 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             },\n             ast::ItemTrait(ref gen, _, ref b, ref items) => {\n                 let t = Trait {\n-                    name: item.ident,\n-                    items: items.iter().map(|x| (*x).clone()).collect(),\n+                    name: name,\n+                    items: items.clone(),\n                     generics: gen.clone(),\n                     bounds: b.iter().map(|x| (*x).clone()).collect(),\n                     id: item.id,\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n+                    attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n                 };\n                 om.traits.push(t);\n             },\n-            ast::ItemImpl(ref gen, ref tr, ty, ref items) => {\n+            ast::ItemImpl(ref gen, ref tr, ref ty, ref items) => {\n                 let i = Impl {\n                     generics: gen.clone(),\n                     trait_: tr.clone(),\n-                    for_: ty,\n-                    items: items.iter().map(|x| *x).collect(),\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n+                    for_: ty.clone(),\n+                    items: items.clone(),\n+                    attrs: item.attrs.clone(),\n                     id: item.id,\n                     whence: item.span,\n                     vis: item.vis,\n@@ -354,7 +339,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     fn visit_macro(&self, item: &ast::Item) -> Macro {\n         Macro {\n             id: item.id,\n-            attrs: item.attrs.iter().map(|x| *x).collect(),\n+            attrs: item.attrs.clone(),\n             name: item.ident,\n             whence: item.span,\n             stab: self.stability(item.id),"}]}