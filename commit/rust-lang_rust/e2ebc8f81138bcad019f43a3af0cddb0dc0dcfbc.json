{"sha": "e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZWJjOGY4MTEzOGJjYWQwMTlmNDNhM2FmMGNkZGIwZGMwZGNmYmM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:55:41Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:55:41Z"}, "message": "Fix rustdoc and tests.", "tree": {"sha": "1d780574526f91999a3a73bebe5112c2fb8ef136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d780574526f91999a3a73bebe5112c2fb8ef136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "html_url": "https://github.com/rust-lang/rust/commit/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02aa722aace1112ba2a7927ef76abe79ba9dae6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02aa722aace1112ba2a7927ef76abe79ba9dae6", "html_url": "https://github.com/rust-lang/rust/commit/e02aa722aace1112ba2a7927ef76abe79ba9dae6"}], "stats": {"total": 174, "additions": 71, "deletions": 103}, "files": [{"sha": "e7c1e214d070a9e6ee126a6975cd658f055ecec5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -1234,7 +1234,7 @@ mod test {\n             };\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None);\n-        let cfg = build_configuration(sess);\n+        let cfg = build_configuration(&sess);\n         assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n     }\n \n@@ -1253,7 +1253,7 @@ mod test {\n             };\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None);\n-        let cfg = build_configuration(sess);\n+        let cfg = build_configuration(&sess);\n         let mut test_items = cfg.iter().filter(|m| m.name().equiv(&(\"test\")));\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());"}, {"sha": "883883e5046467b21d2554ffd858e2d191b58443", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -1517,7 +1517,7 @@ fn test_more() {\n #[test]\n fn test_simplification() {\n     let cx = mk_ctxt();\n-    let item = quote_item!(cx,\n+    let item = quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             fn eq_int(a: int, b: int) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: Vec::new()};"}, {"sha": "2ac3834ea49d253f8099d9deadf8ec768d1c0dbd", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -684,7 +684,7 @@ impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n         debug!(\"cleaning type `{:?}`\", self);\n-        let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap;\n+        let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap();\n         debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n             TyNil => Unit,\n@@ -866,7 +866,7 @@ pub struct Span {\n \n impl Clean<Span> for syntax::codemap::Span {\n     fn clean(&self) -> Span {\n-        let cm = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap;\n+        let cm = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo);\n         let hi = cm.lookup_char_pos(self.hi);\n@@ -1180,7 +1180,7 @@ trait ToSource {\n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self) -> ~str {\n         debug!(\"converting span {:?} to snippet\", self.clean());\n-        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess().codemap.clone();\n+        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess().codemap().clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n             None    => ~\"\""}, {"sha": "91c4311ff541c4b6569b22a548fd0bc8105c5517", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -15,7 +15,6 @@ use rustc::middle::privacy;\n \n use syntax::ast;\n use syntax::parse::token;\n-use syntax::parse;\n use syntax;\n \n use std::cell::RefCell;\n@@ -60,24 +59,23 @@ fn get_ast_and_resolve(cpath: &Path,\n                                 phase_2_configure_and_expand,\n                                 phase_3_run_analysis_passes};\n \n-    let parsesess = parse::new_parse_sess();\n     let input = FileInput(cpath.clone());\n \n-    let sessopts = @driver::session::Options {\n+    let sessopts = driver::session::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(driver::session::CrateTypeDylib),\n-        .. (*rustc::driver::session::basic_options()).clone()\n+        ..rustc::driver::session::basic_options().clone()\n     };\n \n \n+    let codemap = syntax::codemap::CodeMap::new();\n     let diagnostic_handler = syntax::diagnostic::default_handler();\n     let span_diagnostic_handler =\n-        syntax::diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+        syntax::diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n     let sess = driver::driver::build_session_(sessopts,\n                                               Some(cpath.clone()),\n-                                              parsesess.cm,\n                                               span_diagnostic_handler);\n \n     let mut cfg = build_configuration(&sess);\n@@ -87,7 +85,7 @@ fn get_ast_and_resolve(cpath: &Path,\n     }\n \n     let krate = phase_1_parse_input(&sess, cfg, &input);\n-    let (krate, ast_map) = phase_2_configure_and_expand(&sess, &mut Loader::new(sess),\n+    let (krate, ast_map) = phase_2_configure_and_expand(&sess, &mut Loader::new(&sess),\n                                                         krate, &from_str(\"rustdoc\").unwrap());\n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, .."}, {"sha": "d67c7ea6505d063bc1edd9a99df31802406005e9", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -18,7 +18,6 @@ use std::io;\n \n use syntax::parse;\n use syntax::parse::lexer;\n-use syntax::diagnostic;\n use syntax::codemap::{BytePos, Span};\n \n use html::escape::Escape;\n@@ -28,13 +27,11 @@ use t = syntax::parse::token;\n /// Highlights some source code, returning the HTML output.\n pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n     let sess = parse::new_parse_sess();\n-    let handler = diagnostic::default_handler();\n-    let span_handler = diagnostic::mk_span_handler(handler, sess.cm);\n     let fm = parse::string_to_filemap(&sess, src.to_owned(), ~\"<stdin>\");\n \n     let mut out = io::MemWriter::new();\n     doit(&sess,\n-         lexer::new_string_reader(span_handler, fm),\n+         lexer::new_string_reader(&sess.span_diagnostic, fm),\n          class,\n          &mut out).unwrap();\n     str::from_utf8_lossy(out.unwrap()).into_owned()\n@@ -68,7 +65,7 @@ fn doit(sess: &parse::ParseSess, lexer: lexer::StringReader, class: Option<&str>\n         // comment. This will classify some whitespace as a comment, but that\n         // doesn't matter too much for syntax highlighting purposes.\n         if test > last {\n-            let snip = sess.cm.span_to_snippet(Span {\n+            let snip = sess.span_diagnostic.cm.span_to_snippet(Span {\n                 lo: last,\n                 hi: test,\n                 expn_info: None,\n@@ -172,7 +169,7 @@ fn doit(sess: &parse::ParseSess, lexer: lexer::StringReader, class: Option<&str>\n \n         // as mentioned above, use the original source code instead of\n         // stringifying this token\n-        let snip = sess.cm.span_to_snippet(next.sp).unwrap();\n+        let snip = sess.span_diagnostic.cm.span_to_snippet(next.sp).unwrap();\n         if klass == \"\" {\n             try!(write!(out, \"{}\", Escape(snip)));\n         } else {"}, {"sha": "e64292285d00dc774fa08fcd91474084f63bff1b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -28,7 +28,6 @@ extern crate time;\n #[phase(syntax, link)]\n extern crate log;\n \n-use std::cell::RefCell;\n use std::local_data;\n use std::io;\n use std::io::{File, MemWriter};"}, {"sha": "bd15d1b13317f9c4475ff183b4611fd5964a9169", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::{str, io};\n-use std::cell::RefCell;\n use std::vec_ng::Vec;\n \n use collections::HashSet;"}, {"sha": "0a472a0ccaf2fe88970cc0eb33e207a3bb24c483", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -23,7 +23,6 @@ use rustc::driver::driver;\n use rustc::driver::session;\n use rustc::metadata::creader::Loader;\n use syntax::diagnostic;\n-use syntax::parse;\n use syntax::codemap::CodeMap;\n \n use core;\n@@ -38,29 +37,26 @@ pub fn run(input: &str, libs: HashSet<Path>, mut test_args: ~[~str]) -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n \n-    let sessopts = @session::Options {\n+    let sessopts = session::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs.clone()),\n         crate_types: vec!(session::CrateTypeDylib),\n-        .. (*session::basic_options()).clone()\n+        ..session::basic_options().clone()\n     };\n \n \n-    let cm = @CodeMap::new();\n+    let codemap = CodeMap::new();\n     let diagnostic_handler = diagnostic::default_handler();\n     let span_diagnostic_handler =\n-        diagnostic::mk_span_handler(diagnostic_handler, cm);\n-    let parsesess = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n-                                                          cm);\n+    diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n     let sess = driver::build_session_(sessopts,\n                                       Some(input_path),\n-                                      parsesess.cm,\n                                       span_diagnostic_handler);\n \n     let cfg = driver::build_configuration(&sess);\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n-    let (krate, _) = driver::phase_2_configure_and_expand(sess, &mut Loader::new(sess), krate,\n+    let (krate, _) = driver::phase_2_configure_and_expand(&sess, &mut Loader::new(&sess), krate,\n                                                           &from_str(\"rustdoc-test\").unwrap());\n \n     let ctx = @core::DocContext {\n@@ -88,10 +84,9 @@ pub fn run(input: &str, libs: HashSet<Path>, mut test_args: ~[~str]) -> int {\n fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n            no_run: bool, loose_feature_gating: bool) {\n     let test = maketest(test, cratename, loose_feature_gating);\n-    let parsesess = parse::new_parse_sess();\n     let input = driver::StrInput(test);\n \n-    let sessopts = @session::Options {\n+    let sessopts = session::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(session::CrateTypeExecutable),\n@@ -100,7 +95,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n             prefer_dynamic: true,\n             .. session::basic_codegen_options()\n         },\n-        .. (*session::basic_options()).clone()\n+        ..session::basic_options().clone()\n     };\n \n     // Shuffle around a few input and output handles here. We're going to pass\n@@ -126,13 +121,13 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let emitter = diagnostic::EmitterWriter::new(~w2);\n \n     // Compile the code\n+    let codemap = CodeMap::new();\n     let diagnostic_handler = diagnostic::mk_handler(~emitter);\n     let span_diagnostic_handler =\n-        diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n     let sess = driver::build_session_(sessopts,\n                                       None,\n-                                      parsesess.cm,\n                                       span_diagnostic_handler);\n \n     let outdir = TempDir::new(\"rustdoctest\").expect(\"rustdoc needs a tempdir\");"}, {"sha": "75ade160380b2d6970d55d71cf4926b4c14722ca", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -1044,15 +1044,15 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            Vec::new(),sess);\n+            Vec::new(), &sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(sess,cfg,crate_ast);\n+        expand_crate(&sess,cfg,crate_ast);\n     }\n \n     // make sure that macros can leave scope for modules\n@@ -1064,15 +1064,15 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            Vec::new(),sess);\n+            Vec::new(), &sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(sess,cfg,crate_ast);\n+        expand_crate(&sess,cfg,crate_ast);\n     }\n \n     // macro_escape modules shouldn't cause macros to leave scope\n@@ -1083,15 +1083,15 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            Vec::new(), sess);\n+            Vec::new(), &sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(sess, cfg, crate_ast);\n+        expand_crate(&sess, cfg, crate_ast);\n     }\n \n     #[test] fn test_contains_flatten (){\n@@ -1127,7 +1127,7 @@ mod test {\n \n     fn expand_crate_str(crate_str: ~str) -> ast::Crate {\n         let ps = parse::new_parse_sess();\n-        let crate_ast = string_to_parser(&ps, source_str).parse_crate_mod();\n+        let crate_ast = string_to_parser(&ps, crate_str).parse_crate_mod();\n         // the cfg argument actually does matter, here...\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {"}, {"sha": "973682ea7436906280f2296eda754dfb4367d96a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -880,9 +880,9 @@ mod test {\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: &mut pprust::State,\n-                        krate: &ast::Crate) -> io::IoResult<()> {\n-        pprust::print_mod(s, &krate.module, krate.attrs.as_slice())\n+    fn fake_print_crate<A: pprust::PpAnn>(s: &mut pprust::State<A>,\n+                                          krate: &ast::Crate) -> io::IoResult<()> {\n+        s.print_mod(&krate.module, krate.attrs.as_slice())\n     }\n \n     // change every identifier to \"zz\"\n@@ -914,9 +914,10 @@ mod test {\n         let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(\n             ~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n+        let folded_crate = zz_fold.fold_crate(ast);\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate),\n+                     pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n                      ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n     }\n \n@@ -926,9 +927,10 @@ mod test {\n         let ast = string_to_crate(\n             ~\"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n               (g $(d $d $e)+))} \");\n+        let folded_crate = zz_fold.fold_crate(ast);\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate),\n+                     pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }\n }"}, {"sha": "546aefc1297c9ae3d9cc73e8e34a2bd0cba595db", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 30, "deletions": 54, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -1007,28 +1007,24 @@ mod test {\n     use std::io::util;\n     use std::vec_ng::Vec;\n \n-    // represents a testing reader (incl. both reader and interner)\n-    struct Env {\n-        string_reader: StringReader\n+    fn mk_sh() -> diagnostic::SpanHandler {\n+        let emitter = diagnostic::EmitterWriter::new(~util::NullWriter);\n+        let handler = diagnostic::mk_handler(~emitter);\n+        diagnostic::mk_span_handler(handler, CodeMap::new())\n     }\n \n     // open a string reader for the given string\n-    fn setup(teststr: ~str) -> Env {\n-        let cm = CodeMap::new();\n-        let fm = cm.new_filemap(~\"zebra.rs\", teststr);\n-        let writer = ~util::NullWriter;\n-        let emitter = diagnostic::EmitterWriter::new(writer);\n-        let handler = diagnostic::mk_handler(~emitter);\n-        let span_handler = diagnostic::mk_span_handler(handler, cm);\n-        Env {\n-            string_reader: new_string_reader(span_handler,fm)\n-        }\n+    fn setup<'a>(span_handler: &'a diagnostic::SpanHandler,\n+                 teststr: ~str) -> StringReader<'a> {\n+        let fm = span_handler.cm.new_filemap(~\"zebra.rs\", teststr);\n+        new_string_reader(span_handler, fm)\n     }\n \n     #[test] fn t1 () {\n-        let Env {string_reader} =\n-            setup(~\"/* my source file */ \\\n-                    fn main() { println!(\\\"zebra\\\"); }\\n\");\n+        let span_handler = mk_sh();\n+        let string_reader = setup(&span_handler,\n+            ~\"/* my source file */ \\\n+              fn main() { println!(\\\"zebra\\\"); }\\n\");\n         let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n@@ -1049,11 +1045,9 @@ mod test {\n \n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n-    fn check_tokenization (env: Env, expected: Vec<token::Token> ) {\n+    fn check_tokenization (string_reader: StringReader, expected: Vec<token::Token> ) {\n         for expected_tok in expected.iter() {\n-            let TokenAndSpan {tok:actual_tok, sp: _} =\n-                env.string_reader.next_token();\n-            assert_eq!(&actual_tok,expected_tok);\n+            assert_eq!(&string_reader.next_token().tok, expected_tok);\n         }\n     }\n \n@@ -1063,71 +1057,55 @@ mod test {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        let env = setup (~\"a b\");\n-        check_tokenization (env,\n+        check_tokenization(setup(&mk_sh(), ~\"a b\"),\n                            vec!(mk_ident(\"a\",false),\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_2 () {\n-        let env = setup (~\"a::b\");\n-        check_tokenization (env,\n+        check_tokenization(setup(&mk_sh(), ~\"a::b\"),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_3 () {\n-        let env = setup (~\"a ::b\");\n-        check_tokenization (env,\n+        check_tokenization(setup(&mk_sh(), ~\"a ::b\"),\n                            vec!(mk_ident(\"a\",false),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_4 () {\n-        let env = setup (~\"a:: b\");\n-        check_tokenization (env,\n+        check_tokenization(setup(&mk_sh(), ~\"a:: b\"),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn character_a() {\n-        let env = setup(~\"'a'\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        assert_eq!(tok,token::LIT_CHAR('a' as u32));\n+        assert_eq!(setup(&mk_sh(), ~\"'a'\").next_token().tok,\n+                   token::LIT_CHAR('a' as u32));\n     }\n \n     #[test] fn character_space() {\n-        let env = setup(~\"' '\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        assert_eq!(tok, token::LIT_CHAR(' ' as u32));\n+        assert_eq!(setup(&mk_sh(), ~\"' '\").next_token().tok,\n+                   token::LIT_CHAR(' ' as u32));\n     }\n \n     #[test] fn character_escaped() {\n-        let env = setup(~\"'\\\\n'\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        assert_eq!(tok, token::LIT_CHAR('\\n' as u32));\n+        assert_eq!(setup(&mk_sh(), ~\"'\\\\n'\").next_token().tok,\n+                   token::LIT_CHAR('\\n' as u32));\n     }\n \n     #[test] fn lifetime_name() {\n-        let env = setup(~\"'abc\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        let id = token::str_to_ident(\"abc\");\n-        assert_eq!(tok, token::LIFETIME(id));\n+        assert_eq!(setup(&mk_sh(), ~\"'abc\").next_token().tok,\n+                   token::LIFETIME(token::str_to_ident(\"abc\")));\n     }\n \n     #[test] fn raw_string() {\n-        let env = setup(~\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        let id = token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\");\n-        assert_eq!(tok, token::LIT_STR_RAW(id, 3));\n+        assert_eq!(setup(&mk_sh(), ~\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\").next_token().tok,\n+                   token::LIT_STR_RAW(token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\"), 3));\n     }\n \n     #[test] fn line_doc_comments() {\n@@ -1137,10 +1115,8 @@ mod test {\n     }\n \n     #[test] fn nested_block_comments() {\n-        let env = setup(~\"/* /* */ */'a'\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        assert_eq!(tok,token::LIT_CHAR('a' as u32));\n+        assert_eq!(setup(&mk_sh(), ~\"/* /* */ */'a'\").next_token().tok,\n+                   token::LIT_CHAR('a' as u32));\n     }\n \n }"}, {"sha": "062bc1008637a366d0ae946252830dec5eee981f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -584,7 +584,8 @@ mod test {\n     }\n \n     #[test] fn parse_ident_pat () {\n-        let mut parser = string_to_parser(&new_parse_sess(), ~\"b\");\n+        let sess = new_parse_sess();\n+        let mut parser = string_to_parser(&sess, ~\"b\");\n         assert!(parser.parse_pat() ==\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent("}, {"sha": "658e97097504add40a622e80b428804d0b393c50", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "patch": "@@ -29,7 +29,8 @@ pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: ~str) -> Parser<'a> {\n }\n \n fn with_error_checking_parse<T>(s: ~str, f: |&mut Parser| -> T) -> T {\n-    let mut p = string_to_parser(&new_parse_sess(), s);\n+    let ps = new_parse_sess();\n+    let mut p = string_to_parser(&ps, s);\n     let x = f(&mut p);\n     p.abort_if_errors();\n     x"}]}