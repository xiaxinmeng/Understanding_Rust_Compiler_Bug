{"sha": "f5024692d49be49b2efff452059f83efaebfd0ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MDI0NjkyZDQ5YmU0OWIyZWZmZjQ1MjA1OWY4M2VmYWViZmQwZWU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-23T10:51:06Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-23T11:21:55Z"}, "message": "Remove support for the old-style intrinsics\n\nCloses #2042\nCloses #1981", "tree": {"sha": "23da664fb1bf1c374081550309731cf206341b57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23da664fb1bf1c374081550309731cf206341b57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5024692d49be49b2efff452059f83efaebfd0ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5024692d49be49b2efff452059f83efaebfd0ee", "html_url": "https://github.com/rust-lang/rust/commit/f5024692d49be49b2efff452059f83efaebfd0ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5024692d49be49b2efff452059f83efaebfd0ee/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0303396f4cc292b54a0b097364581c88b8631696", "url": "https://api.github.com/repos/rust-lang/rust/commits/0303396f4cc292b54a0b097364581c88b8631696", "html_url": "https://github.com/rust-lang/rust/commit/0303396f4cc292b54a0b097364581c88b8631696"}], "stats": {"total": 1036, "additions": 15, "deletions": 1021}, "files": [{"sha": "71aca347d68222aa091ae20d93acccd2b374e777", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -317,7 +317,6 @@ HSREQ$(1)_H_$(3) = \\\n TSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HSREQ$(1)_H_$(3)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUNTIME) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/intrinsics.bc \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a\n \n # Prerequisites for complete stageN targets"}, {"sha": "1971af044819569f501727f5a73f4ef209bdc9e6", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -99,8 +99,6 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_GLOB)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM)\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libstd.rlib\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/intrinsics.bc\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/intrinsics.ll\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a\n endef\n "}, {"sha": "605639c8be13bee6a479cf1aa43e57f42969a5b4", "filename": "mk/install.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -42,7 +42,6 @@ install-target-$(1)-host-$(2): $$(SREQ$$(ISTAGE)_T_$(1)_H_$(2))\n \t\t$$(TL$(1)$(2)),$$(PTL$(1)$(2)),$$(STDLIB_GLOB))\n \t$$(Q)$$(call INSTALL_LIB, \\\n \t\t$$(TL$(1)$(2)),$$(PTL$(1)$(2)),$$(LIBRUSTC_GLOB))\n-\t$$(Q)$$(call INSTALL,$$(TL$(1)$(2)),$$(PTL$(1)$(2)),intrinsics.bc)\n \t$$(Q)$$(call INSTALL,$$(TL$(1)$(2)),$$(PTL$(1)$(2)),libmorestack.a)\n \n endef"}, {"sha": "0f02c153cac84ccfe6ccc19cdf948681914aa8e8", "filename": "mk/target.mk", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -13,17 +13,6 @@ USE_SNAPSHOT_CORELIB=0\n \n define TARGET_STAGE_N\n \n-$$(TLIB$(1)_T_$(2)_H_$(3))/intrinsics.ll: \\\n-\t\t$$(S)src/rt/intrinsics/intrinsics.$(HOST_$(2)).ll.in\n-\t@$$(call E, sed: $$@)\n-\t$$(Q)sed s/@CFG_TARGET_TRIPLE@/$(2)/ $$< > $$@\n-\n-$$(TLIB$(1)_T_$(2)_H_$(3))/intrinsics.bc: \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/intrinsics.ll \\\n-\t\t$$(LLVM_CONFIG_$(2))\n-\t@$$(call E, llvms-as: $$@)\n-\t$$(Q)$$(LLVM_AS_$(2)) -o $$@ $$<\n-\n $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a: \\\n \t\trt/$(2)/arch/$$(HOST_$(2))/libmorestack.a\n \t@$$(call E, cp: $$@)"}, {"sha": "72785bfbbf6b5bfb504e43e63b420c2cae4a851b", "filename": "src/etc/gen-intrinsics", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0303396f4cc292b54a0b097364581c88b8631696/src%2Fetc%2Fgen-intrinsics", "raw_url": "https://github.com/rust-lang/rust/raw/0303396f4cc292b54a0b097364581c88b8631696/src%2Fetc%2Fgen-intrinsics", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgen-intrinsics?ref=0303396f4cc292b54a0b097364581c88b8631696", "patch": "@@ -1,27 +0,0 @@\n-#!/bin/sh\n-\n-# This script generates new definitions for the intrinsics using\n-# clang. This is not currently in the Makefile to avoid any dependency\n-# on clang.\n-\n-for ARCH in i386 x86_64\n-do\n-    if [ $ARCH = \"i386\" ]\n-    then\n-\tBITS=32\n-    else\n-\tBITS=64\n-    fi\n-\n-    clang++ -emit-llvm -S -m$BITS -O3 -Isrc/rt/isaac -Isrc/rt/uthash \\\n-        -Isrc/rt/arch/$ARCH -Isrc/rt -fno-stack-protector \\\n-        -o src/rt/intrinsics/intrinsics.$ARCH.ll.in \\\n-        src/rt/intrinsics/intrinsics.cpp\n-    sed -i .orig \\\n-        -e 's/^target datalayout =/; target datalayout =/' \\\n-        src/rt/intrinsics/intrinsics.$ARCH.ll.in\n-    sed -i .orig \\\n-        -e 's/^target triple = \"[^\"]*\"/target triple = \"@CFG_TARGET_TRIPLE@\"/' \\\n-        src/rt/intrinsics/intrinsics.$ARCH.ll.in\n-    rm src/rt/intrinsics/intrinsics.$ARCH.ll.in.orig\n-done"}, {"sha": "d36bdf8767517338060af6859f70855dc5db1427", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/0303396f4cc292b54a0b097364581c88b8631696/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0303396f4cc292b54a0b097364581c88b8631696/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=0303396f4cc292b54a0b097364581c88b8631696", "patch": "@@ -1,174 +0,0 @@\n-// Rust intrinsics. These are built into each compilation unit and are\n-// run on the Rust stack. They should not call C methods because that\n-// will very likely result in running off the end of the stack.\n-// Build with the script in src/etc/gen-intrinsics\n-\n-#include \"../rust_internal.h\"\n-#include \"../rust_util.h\"\n-#include <cstdlib>\n-#include <cstring>\n-\n-extern \"C\" CDECL void\n-rust_task_yield(rust_task *task, bool *killed);\n-\n-extern \"C\" void\n-rust_intrinsic_vec_len(size_t *retptr,\n-                         void *env,\n-                         type_desc *ty,\n-                         rust_vec **vp)\n-{\n-    *retptr = (*vp)->fill / ty->size;\n-}\n-\n-extern \"C\" void\n-rust_intrinsic_ptr_offset(void **retptr,\n-                          void *env,\n-                          type_desc *ty,\n-                          void *ptr,\n-                          uintptr_t count)\n-{\n-    *retptr = &((uint8_t *)ptr)[ty->size * count];\n-}\n-\n-extern \"C\" void\n-rust_intrinsic_cast(void *retptr,\n-                    void *env,\n-                    type_desc *t1,\n-                    type_desc *t2,\n-                    void *src)\n-{\n-    // assert t1->size == t2->size\n-    // FIXME: This should be easily expressible in rust\n-    memmove(retptr, src, t1->size);\n-}\n-\n-extern \"C\" void\n-rust_intrinsic_addr_of(void **retptr,\n-                       void *env,\n-                       type_desc *ty,\n-                       void *valptr) {\n-    *retptr = valptr;\n-}\n-\n-struct rust_fn {\n-    uintptr_t *fn;\n-    rust_box *env;\n-};\n-\n-typedef void (*retptr_fn)(void **retptr,\n-\t\t\t   void *env,\n-\t\t\t   void **dptr);\n-// FIXME (1185): This exists just to get access to the return pointer\n-extern \"C\" void\n-rust_intrinsic_call_with_retptr(void **retptr,\n-\t\t\t\tvoid *env,\n-\t\t\t\ttype_desc *ty,\n-\t\t\t\trust_fn *recvfn) {\n-    retptr_fn fn = ((retptr_fn)(recvfn->fn));\n-    ((retptr_fn)(*fn))(NULL, recvfn->env, retptr);\n-}\n-\n-extern \"C\" void\n-rust_intrinsic_get_type_desc(void **retptr,\n-                             void *env,\n-                             type_desc* ty) {\n-    *(type_desc**)retptr = ty;\n-}\n-\n-extern \"C\" void\n-rust_intrinsic_task_yield(void **retptr,\n-                          void *env,\n-\t\t\t  rust_task *task,\n-\t\t\t  bool *killed) {\n-    rust_task_yield(task, killed);\n-}\n-\n-extern \"C\" void\n-rust_intrinsic_memmove(void *retptr,\n-                    void *env,\n-                    type_desc *ty,\n-                    void *dst,\n-                    void *src,\n-                    uintptr_t count)\n-{\n-    memmove(dst, src, ty->size * count);\n-}\n-\n-extern \"C\" void\n-rust_intrinsic_memcpy(void *retptr,\n-                    void *env,\n-                    type_desc *ty,\n-                    void *dst,\n-                    void *src,\n-                    uintptr_t count)\n-{\n-    memcpy(dst, src, ty->size * count);\n-}\n-\n-extern \"C\" void\n-rust_intrinsic_leak(void *retptr,\n-                    void *env,\n-                    type_desc *ty,\n-                    void *thing)\n-{\n-}\n-\n-extern \"C\" CDECL void *\n-upcall_shared_realloc(void *ptr, size_t size);\n-\n-inline void reserve_vec_fast(rust_vec **vpp, size_t size) {\n-    if (size > (*vpp)->alloc) {\n-      size_t new_size = next_power_of_two(size);\n-        size_t alloc_size = new_size + sizeof(rust_vec);\n-        // Because this is called from an intrinsic we need to use\n-        // the exported API\n-        *vpp = (rust_vec*)upcall_shared_realloc(*vpp, alloc_size);\n-        (*vpp)->alloc = new_size;\n-    }\n-}\n-\n-// Copy elements from one vector to another,\n-// dealing with reference counts\n-static inline void\n-copy_elements(type_desc *elem_t,\n-              void *pdst, void *psrc, size_t n) {\n-    char *dst = (char *)pdst, *src = (char *)psrc;\n-    memmove(dst, src, n);\n-\n-    // increment the refcount of each element of the vector\n-    if (elem_t->take_glue) {\n-        glue_fn *take_glue = elem_t->take_glue;\n-        size_t elem_size = elem_t->size;\n-        const type_desc **tydescs = elem_t->first_param;\n-        for (char *p = dst; p < dst+n; p += elem_size) {\n-            take_glue(NULL, NULL, tydescs, p);\n-        }\n-    }\n-}\n-\n-// Because this is used so often, and it calls take glue that must run\n-// on the rust stack, it is statically compiled into every crate.\n-extern \"C\" CDECL void\n-upcall_intrinsic_vec_push(rust_vec** vp,\n-\t\t\t  type_desc* elt_ty, void* elt) {\n-\n-    size_t new_sz = (*vp)->fill + elt_ty->size;\n-    reserve_vec_fast(vp, new_sz);\n-    rust_vec* v = *vp;\n-    copy_elements(elt_ty, &v->data[0] + v->fill,\n-                  elt, elt_ty->size);\n-    v->fill += elt_ty->size;\n-}\n-\n-// FIXME: Transational. Remove\n-extern \"C\" CDECL void\n-upcall_vec_push(rust_vec** vp,\n-\t\ttype_desc* elt_ty, void* elt) {\n-  upcall_intrinsic_vec_push(vp, elt_ty, elt);\n-}\n-\n-extern \"C\" CDECL void\n-rust_intrinsic_frame_address(void **p, unsigned n) {\n-    *p = __builtin_frame_address(n);\n-}\n-"}, {"sha": "a03bed031181438da00ba6bd6d09352be570e4bb", "filename": "src/rt/intrinsics/intrinsics.i386.ll.in", "status": "removed", "additions": 0, "deletions": 236, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/0303396f4cc292b54a0b097364581c88b8631696/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/0303396f4cc292b54a0b097364581c88b8631696/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in?ref=0303396f4cc292b54a0b097364581c88b8631696", "patch": "@@ -1,236 +0,0 @@\n-; ModuleID = 'src/rt/intrinsics/intrinsics.cpp'\n-; target datalayout = \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32\"\n-target triple = \"@CFG_TARGET_TRIPLE@\"\n-\n-%0 = type { i32, %struct.rust_task**, i32 }\n-%1 = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n-%class.array_list = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n-%class.boxed_region = type { %class.memory_region*, %struct.rust_opaque_box* }\n-%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n-%class.context = type { %struct.registers_t, %class.context*, [12 x i8] }\n-%\"class.debug::task_debug_info\" = type { %\"class.std::map\" }\n-%class.hash_map = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n-%class.indexed_list = type { i32 (...)**, %0 }\n-%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_mutex_t, %struct._opaque_pthread_t* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i32 }\n-%class.rust_kernel = type { %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, i32, i32, %1, %class.lock_and_signal, i32, %class.lock_and_signal, i32, %\"class.std::map\", %\"class.std::vector\", %struct.rust_env* }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n-%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n-%class.rust_port = type { i32, i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.circular_buffer, %class.lock_and_signal }\n-%class.rust_port_selector = type { %class.rust_port**, i32, %class.lock_and_signal }\n-%class.rust_scheduler = type opaque\n-%class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n-%class.rust_task_list = type { %class.indexed_list, %struct.rust_task_thread*, i8* }\n-%class.rust_thread = type { i32 (...)**, %struct._opaque_pthread_t*, i32 }\n-%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" }\n-%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n-%\"class.std::vector\" = type { %\"struct.std::_Vector_base\" }\n-%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n-%struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n-%struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n-%struct.__darwin_pthread_handler_rec = type { void (i8*)*, i8*, %struct.__darwin_pthread_handler_rec* }\n-%struct._opaque_pthread_attr_t = type { i32, [36 x i8] }\n-%struct._opaque_pthread_cond_t = type { i32, [24 x i8] }\n-%struct._opaque_pthread_mutex_t = type { i32, [40 x i8] }\n-%struct._opaque_pthread_t = type { i32, %struct.__darwin_pthread_handler_rec*, [596 x i8] }\n-%struct.chan_handle = type { i32, i32 }\n-%\"struct.hash_map<long, rust_port *>::map_entry\" = type opaque\n-%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n-%\"struct.memory_region::alloc_header\" = type { i8 }\n-%struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n-%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32, [12 x i8] }\n-%struct.rust_box = type opaque\n-%struct.rust_env = type { i32, i32, i32, i8*, i8, i8, i8* }\n-%struct.rust_fn = type { i32*, %struct.rust_box* }\n-%struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n-%struct.rust_obstack_chunk = type { %struct.rust_obstack_chunk*, i32, i32, i32, [0 x i8] }\n-%struct.rust_opaque_box = type { i32, %struct.type_desc*, %struct.rust_opaque_box*, %struct.rust_opaque_box* }\n-%struct.rust_shape_tables = type { i8*, i8* }\n-%struct.rust_task = type { i32, i32, i8, %struct.chan_handle, [12 x i8], %class.context, %struct.stk_seg*, i32, %class.rust_scheduler*, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %\"struct.memory_region::alloc_header\"*, i8*, %struct.rust_task*, i32, i32, i32*, %class.memory_region, %class.boxed_region, i8, i8, %class.lock_and_signal, %class.hash_map, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i32, i8, i8, %struct.stk_seg*, i32, i32, %class.rust_port_selector, [8 x i8] }\n-%struct.rust_task_thread = type { %class.rust_thread, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, %class.rust_scheduler*, i32, i32, %class.lock_and_signal, i32, %struct._opaque_pthread_attr_t, %struct.rust_env*, [4 x i8], %class.context, i8, %struct.stk_seg*, %struct.stk_seg*, [4 x i8] }\n-%struct.rust_vec = type { i32, i32, [0 x i8] }\n-%\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" = type { %\"struct.memory_region::alloc_header\", %\"struct.std::_Rb_tree_node_base\", i32 }\n-%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n-%\"struct.std::_Vector_base\" = type { %\"struct.std::_Vector_base<long, std::allocator<long> >::_Vector_impl\" }\n-%\"struct.std::_Vector_base<long, std::allocator<long> >::_Vector_impl\" = type { i32*, i32*, i32* }\n-%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i32, i32, i32, i32, [0 x i8] }\n-%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i32, i8*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n-\n-define void @rust_intrinsic_vec_len(i32* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n-  %1 = load %struct.rust_vec** %vp, align 4\n-  %2 = getelementptr inbounds %struct.rust_vec* %1, i32 0, i32 0\n-  %3 = load i32* %2, align 4\n-  %4 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %5 = load i32* %4, align 4\n-  %6 = udiv i32 %3, %5\n-  store i32 %6, i32* %retptr, align 4\n-  ret void\n-}\n-\n-define void @rust_intrinsic_ptr_offset(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %2 = load i32* %1, align 4\n-  %3 = mul i32 %2, %count\n-  %4 = getelementptr inbounds i8* %ptr, i32 %3\n-  store i8* %4, i8** %retptr, align 4\n-  ret void\n-}\n-\n-define void @rust_intrinsic_cast(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n-  %2 = load i32* %1, align 4\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %retptr, i8* %src, i32 %2, i32 1, i1 false)\n-  ret void\n-}\n-\n-declare void @llvm.memmove.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n-\n-define void @rust_intrinsic_addr_of(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n-  store i8* %valptr, i8** %retptr, align 4\n-  ret void\n-}\n-\n-define void @rust_intrinsic_call_with_retptr(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_fn* nocapture %recvfn) {\n-  %1 = getelementptr inbounds %struct.rust_fn* %recvfn, i32 0, i32 0\n-  %2 = load i32** %1, align 4\n-  %3 = bitcast i32* %2 to void (i8**, i8*, i8**)*\n-  %4 = getelementptr inbounds %struct.rust_fn* %recvfn, i32 0, i32 1\n-  %5 = load %struct.rust_box** %4, align 4\n-  %6 = bitcast %struct.rust_box* %5 to i8*\n-  tail call void %3(i8** null, i8* %6, i8** %retptr)\n-  ret void\n-}\n-\n-define void @rust_intrinsic_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind {\n-  %ty.c = bitcast %struct.type_desc* %ty to i8*\n-  store i8* %ty.c, i8** %retptr, align 4\n-  ret void\n-}\n-\n-define void @rust_intrinsic_task_yield(i8** nocapture %retptr, i8* nocapture %env, %struct.rust_task* %task, i8* %killed) {\n-  tail call void @rust_task_yield(%struct.rust_task* %task, i8* %killed)\n-  ret void\n-}\n-\n-declare void @rust_task_yield(%struct.rust_task*, i8*)\n-\n-define void @rust_intrinsic_memmove(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i32 %count) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %2 = load i32* %1, align 4\n-  %3 = mul i32 %2, %count\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %3, i32 1, i1 false)\n-  ret void\n-}\n-\n-define void @rust_intrinsic_memcpy(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i32 %count) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %2 = load i32* %1, align 4\n-  %3 = mul i32 %2, %count\n-  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %dst, i8* %src, i32 %3, i32 1, i1 false)\n-  ret void\n-}\n-\n-declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n-\n-define void @rust_intrinsic_leak(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %thing) nounwind readnone {\n-  ret void\n-}\n-\n-define void @upcall_intrinsic_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n-; <label>:0\n-  %1 = load %struct.rust_vec** %vp, align 4\n-  %2 = getelementptr inbounds %struct.rust_vec* %1, i32 0, i32 0\n-  %3 = load i32* %2, align 4\n-  %4 = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 1\n-  %5 = load i32* %4, align 4\n-  %6 = add i32 %5, %3\n-  %7 = getelementptr inbounds %struct.rust_vec* %1, i32 0, i32 1\n-  %8 = load i32* %7, align 4\n-  %9 = icmp ult i32 %8, %6\n-  br i1 %9, label %10, label %_Z16reserve_vec_fastPP8rust_vecm.exit\n-\n-; <label>:10                                      ; preds = %0\n-  %11 = add i32 %6, -1\n-  %12 = lshr i32 %11, 1\n-  %13 = or i32 %12, %11\n-  %14 = lshr i32 %13, 2\n-  %15 = or i32 %14, %13\n-  %16 = lshr i32 %15, 4\n-  %17 = or i32 %16, %15\n-  %18 = lshr i32 %17, 8\n-  %19 = or i32 %18, %17\n-  %20 = lshr i32 %19, 16\n-  %21 = or i32 %20, %19\n-  %22 = add i32 %21, 1\n-  %23 = add i32 %21, 9\n-  %24 = bitcast %struct.rust_vec* %1 to i8*\n-  %25 = tail call i8* @upcall_shared_realloc(i8* %24, i32 %23)\n-  %26 = bitcast i8* %25 to %struct.rust_vec*\n-  store %struct.rust_vec* %26, %struct.rust_vec** %vp, align 4\n-  %27 = getelementptr inbounds i8* %25, i32 4\n-  %28 = bitcast i8* %27 to i32*\n-  store i32 %22, i32* %28, align 4\n-  %.pr = load i32* %4, align 4\n-  %.pre = load %struct.rust_vec** %vp, align 4\n-  %.phi.trans.insert = getelementptr inbounds %struct.rust_vec* %.pre, i32 0, i32 0\n-  %.pre4 = load i32* %.phi.trans.insert, align 4\n-  br label %_Z16reserve_vec_fastPP8rust_vecm.exit\n-\n-_Z16reserve_vec_fastPP8rust_vecm.exit:            ; preds = %0, %10\n-  %29 = phi i32 [ %3, %0 ], [ %.pre4, %10 ]\n-  %30 = phi %struct.rust_vec* [ %1, %0 ], [ %.pre, %10 ]\n-  %31 = phi i32 [ %5, %0 ], [ %.pr, %10 ]\n-  %32 = getelementptr inbounds %struct.rust_vec* %30, i32 0, i32 0\n-  %33 = getelementptr inbounds %struct.rust_vec* %30, i32 0, i32 2, i32 %29\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %33, i8* %elt, i32 %31, i32 1, i1 false)\n-  %34 = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 3\n-  %35 = load void (i8*, i8*, %struct.type_desc**, i8*)** %34, align 4\n-  %36 = icmp eq void (i8*, i8*, %struct.type_desc**, i8*)* %35, null\n-  br i1 %36, label %_ZL13copy_elementsP9type_descPvS1_m.exit, label %37\n-\n-; <label>:37                                      ; preds = %_Z16reserve_vec_fastPP8rust_vecm.exit\n-  %38 = load i32* %4, align 4\n-  %39 = getelementptr inbounds %struct.type_desc* %elt_ty, i32 0, i32 0\n-  %40 = load %struct.type_desc*** %39, align 4\n-  %41 = icmp sgt i32 %31, 0\n-  br i1 %41, label %.lr.ph.i.preheader, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n-\n-.lr.ph.i.preheader:                               ; preds = %37\n-  %scevgep = getelementptr %struct.rust_vec* %30, i32 1, i32 0\n-  %scevgep2 = bitcast i32* %scevgep to i8*\n-  br label %.lr.ph.i\n-\n-.lr.ph.i:                                         ; preds = %.lr.ph.i.preheader, %.lr.ph.i\n-  %indvar.i = phi i32 [ %indvar.next.i, %.lr.ph.i ], [ 0, %.lr.ph.i.preheader ]\n-  %tmp = mul i32 %38, %indvar.i\n-  %tmp2.i = add i32 %38, %tmp\n-  %tmp3 = add i32 %29, %tmp\n-  %p.01.i = getelementptr i8* %scevgep2, i32 %tmp3\n-  tail call void %35(i8* null, i8* null, %struct.type_desc** %40, i8* %p.01.i)\n-  %42 = icmp slt i32 %tmp2.i, %31\n-  %indvar.next.i = add i32 %indvar.i, 1\n-  br i1 %42, label %.lr.ph.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n-\n-_ZL13copy_elementsP9type_descPvS1_m.exit:         ; preds = %.lr.ph.i, %_Z16reserve_vec_fastPP8rust_vecm.exit, %37\n-  %43 = load i32* %4, align 4\n-  %44 = load i32* %32, align 4\n-  %45 = add i32 %44, %43\n-  store i32 %45, i32* %32, align 4\n-  ret void\n-}\n-\n-define void @upcall_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n-  tail call void @upcall_intrinsic_vec_push(%struct.rust_vec** %vp, %struct.type_desc* %elt_ty, i8* %elt)\n-  ret void\n-}\n-\n-define void @rust_intrinsic_frame_address(i8** nocapture %p) nounwind {\n-  %1 = tail call i8* @llvm.frameaddress(i32 1)\n-  store i8* %1, i8** %p, align 4\n-  ret void\n-}\n-\n-declare i8* @llvm.frameaddress(i32) nounwind readnone\n-\n-declare i8* @upcall_shared_realloc(i8*, i32)"}, {"sha": "8f02e4b3d9809dd30ab3849950d0ace69a0905f0", "filename": "src/rt/intrinsics/intrinsics.ll.bak", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/0303396f4cc292b54a0b097364581c88b8631696/src%2Frt%2Fintrinsics%2Fintrinsics.ll.bak", "raw_url": "https://github.com/rust-lang/rust/raw/0303396f4cc292b54a0b097364581c88b8631696/src%2Frt%2Fintrinsics%2Fintrinsics.ll.bak", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.ll.bak?ref=0303396f4cc292b54a0b097364581c88b8631696", "patch": "@@ -1,149 +0,0 @@\n-; ModuleID = 'intrinsics.cpp'\n-target triple = \"@CFG_LLVM_TRIPLE@\"\n-\n-%struct.rust_task = type { i32, %struct.stk_seg*, i32, i32, %struct.gc_alloc*, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32, %class.timer, i32*, %class.array_list, %class.context, i32, i32, %class.memory_region, %\"class.rust_task::wakeup_callback\"*, i8, i8, %class.lock_and_signal }\n-%struct.stk_seg = type { i32, i32, [0 x i8] }\n-%struct.gc_alloc = type { %struct.gc_alloc*, %struct.gc_alloc*, i32, [0 x i8] }\n-%struct.rust_scheduler = type { %class.rust_thread, %struct.rc_base, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, %class.hash_map, %class.hash_map.3, i32, %class.lock_and_signal, i32, %struct._opaque_pthread_attr_t, %struct.rust_env* }\n-%class.rust_thread = type { i32 (...)**, i8, %struct._opaque_pthread_t* }\n-%struct._opaque_pthread_t = type { i32, %struct.__darwin_pthread_handler_rec*, [596 x i8] }\n-%struct.__darwin_pthread_handler_rec = type { {}*, i8*, %struct.__darwin_pthread_handler_rec* }\n-%struct.rc_base = type { i32 }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n-%class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n-%struct.rust_env = type { i32, i32, i8*, i8, i8, i8* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list.0, i8, i8, %class.lock_and_signal, i8 }\n-%class.array_list.0 = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n-%\"struct.memory_region::alloc_header\" = type { i32, i32, i8*, [0 x i8] }\n-%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_mutex_t, %struct._opaque_pthread_t*, i8, i8 }\n-%struct._opaque_pthread_cond_t = type { i32, [24 x i8] }\n-%struct._opaque_pthread_mutex_t = type { i32, [40 x i8] }\n-%class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n-%class.indexed_list = type { i32 (...)**, %class.array_list }\n-%class.array_list = type { i32, %struct.rust_task**, i32 }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i32 }\n-%struct.type_desc = type { %struct.type_desc**, i32, i32, {}*, {}*, {}*, {}*, {}*, {}*, i32, {}*, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n-%struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n-%struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n-%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n-%struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n-%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.4, %struct.randctx, i32, i32, i32, %struct.rust_env* }\n-%class.array_list.4 = type { i32, %struct.rust_scheduler**, i32 }\n-%class.hash_map = type { %\"struct.hash_map<rust_task *, rust_task *>::map_entry\"* }\n-%\"struct.hash_map<rust_task *, rust_task *>::map_entry\" = type opaque\n-%class.hash_map.3 = type { %\"struct.hash_map<rust_port *, rust_port *>::map_entry\"* }\n-%\"struct.hash_map<rust_port *, rust_port *>::map_entry\" = type opaque\n-%struct._opaque_pthread_attr_t = type { i32, [36 x i8] }\n-%struct.rust_cond = type { i8 }\n-%class.timer = type { i32 (...)**, i64, i64 }\n-%class.context = type { %struct.registers_t, %class.context* }\n-%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n-%\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n-%struct.rust_vec = type { %struct.rc_base.5, i32, i32, i32, [0 x i8] }\n-%struct.rc_base.5 = type { i32 }\n-%struct.rust_ivec = type { i32, i32, %union.rust_ivec_payload }\n-%union.rust_ivec_payload = type { %struct.rust_ivec_heap* }\n-%struct.rust_ivec_heap = type { i32, [0 x i8] }\n-%class.rust_port = type { i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.ptr_vec, %class.ptr_vec.7, %class.rust_chan*, %class.lock_and_signal }\n-%class.ptr_vec = type { %struct.rust_task*, i32, i32, %struct.rust_token** }\n-%struct.rust_token = type opaque\n-%class.ptr_vec.7 = type { %struct.rust_task*, i32, i32, %class.rust_chan** }\n-%class.rust_chan = type { i32, %class.rust_kernel*, %struct.rust_task*, %class.rust_port*, i32, %class.circular_buffer }\n-%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n-\n-@.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\", align 1\n-@.str1 = private unnamed_addr constant [15 x i8] c\"intrinsics.cpp\\00\", align 1\n-\n-define linkonce_odr void @rust_intrinsic_vec_len(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_vec* nocapture %v) nounwind {\n-entry:\n-  %fill = getelementptr inbounds %struct.rust_vec* %v, i32 0, i32 2\n-  %tmp1 = load i32* %fill, align 4, !tbaa !0\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %tmp3 = load i32* %size, align 4, !tbaa !0\n-  %div = udiv i32 %tmp1, %tmp3\n-  store i32 %div, i32* %retptr, align 4, !tbaa !0\n-  ret void\n-}\n-\n-define linkonce_odr void @rust_intrinsic_ivec_len(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_ivec* nocapture %v) nounwind {\n-entry:\n-  %fill1 = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 0\n-  %tmp2 = load i32* %fill1, align 4, !tbaa !0\n-  %tobool = icmp eq i32 %tmp2, 0\n-  br i1 %tobool, label %if.else, label %if.end17\n-\n-if.else:                                          ; preds = %entry\n-  %ptr = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 2, i32 0\n-  %tmp7 = load %struct.rust_ivec_heap** %ptr, align 4, !tbaa !3\n-  %tobool8 = icmp eq %struct.rust_ivec_heap* %tmp7, null\n-  br i1 %tobool8, label %if.end17, label %if.then9\n-\n-if.then9:                                         ; preds = %if.else\n-  %fill14 = getelementptr inbounds %struct.rust_ivec_heap* %tmp7, i32 0, i32 0\n-  %tmp15 = load i32* %fill14, align 4, !tbaa !0\n-  br label %if.end17\n-\n-if.end17:                                         ; preds = %if.else, %entry, %if.then9\n-  %fill.0 = phi i32 [ %tmp15, %if.then9 ], [ %tmp2, %entry ], [ 0, %if.else ]\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %tmp20 = load i32* %size, align 4, !tbaa !0\n-  %div = udiv i32 %fill.0, %tmp20\n-  store i32 %div, i32* %retptr, align 4, !tbaa !0\n-  ret void\n-}\n-\n-define linkonce_odr void @rust_intrinsic_ptr_offset(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n-  %tmp1 = load i32* %size, align 4, !tbaa !0\n-  %mul = mul i32 %tmp1, %count\n-  %arrayidx = getelementptr inbounds i8* %ptr, i32 %mul\n-  store i8* %arrayidx, i8** %retptr, align 4, !tbaa !3\n-  ret void\n-}\n-\n-define linkonce_odr void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n-entry:\n-  %size = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n-  %tmp1 = load i32* %size, align 4, !tbaa !0\n-  %size3 = getelementptr inbounds %struct.type_desc* %t2, i32 0, i32 1\n-  %tmp4 = load i32* %size3, align 4, !tbaa !0\n-  %cmp = icmp eq i32 %tmp1, %tmp4\n-  br i1 %cmp, label %if.end, label %if.then\n-\n-if.then:                                          ; preds = %entry\n-  tail call void @upcall_fail(%struct.rust_task* %task, i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8]* @.str1, i32 0, i32 0), i32 45)\n-  br label %return\n-\n-if.end:                                           ; preds = %entry\n-  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %retptr, i8* %src, i32 %tmp1, i32 1, i1 false)\n-  br label %return\n-\n-return:                                           ; preds = %if.end, %if.then\n-  ret void\n-}\n-\n-declare void @upcall_fail(%struct.rust_task*, i8*, i8*, i32)\n-\n-declare void @llvm.memmove.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n-\n-define linkonce_odr void @rust_intrinsic_addr_of(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n-entry:\n-  store i8* %valptr, i8** %retptr, align 4, !tbaa !3\n-  ret void\n-}\n-\n-define linkonce_odr void @rust_intrinsic_recv(%struct.rust_task* %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n-entry:\n-  %tmp2 = load i8** %retptr, align 4, !tbaa !3\n-  %0 = bitcast i8* %tmp2 to i32*\n-  tail call void @port_recv(%struct.rust_task* %task, i32* %0, %class.rust_port* %port)\n-  ret void\n-}\n-\n-declare void @port_recv(%struct.rust_task*, i32*, %class.rust_port*)\n-\n-!0 = metadata !{metadata !\"long\", metadata !1}\n-!1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n-!2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}\n-!3 = metadata !{metadata !\"any pointer\", metadata !1}"}, {"sha": "d18c1f7c9e4264ce27e0cb3d4a098fef72bc8e05", "filename": "src/rt/intrinsics/intrinsics.x86_64.ll.in", "status": "removed", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/0303396f4cc292b54a0b097364581c88b8631696/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/0303396f4cc292b54a0b097364581c88b8631696/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in?ref=0303396f4cc292b54a0b097364581c88b8631696", "patch": "@@ -1,237 +0,0 @@\n-; ModuleID = 'src/rt/intrinsics/intrinsics.cpp'\n-; target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64\"\n-target triple = \"@CFG_TARGET_TRIPLE@\"\n-\n-%0 = type { i64, %struct.rust_task**, i64 }\n-%1 = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n-%class.array_list = type { i64, %\"struct.memory_region::alloc_header\"**, i64 }\n-%class.boxed_region = type { %class.memory_region*, %struct.rust_opaque_box* }\n-%class.circular_buffer = type { %class.rust_kernel*, i64, i64, i64, i64, i8* }\n-%class.context = type { %struct.registers_t, %class.context*, [8 x i8] }\n-%\"class.debug::task_debug_info\" = type { %\"class.std::map\" }\n-%class.hash_map = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n-%class.indexed_list = type { i32 (...)**, %0 }\n-%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_attr_t, %struct._opaque_pthread_t* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_hashable_dict*, %struct.rust_task_thread*, i64 }\n-%class.rust_kernel = type { %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, i64, i64, %1, %class.lock_and_signal, i32, %class.lock_and_signal, i64, %\"class.std::map\", %\"class.std::vector\", %struct.rust_env* }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_task_thread*, i8 }\n-%class.rust_obstack = type { %struct.rust_obstack_chunk*, %struct.rust_task* }\n-%class.rust_port = type { i64, i64, %class.rust_kernel*, %struct.rust_task*, i64, %class.circular_buffer, %class.lock_and_signal }\n-%class.rust_port_selector = type { %class.rust_port**, i64, %class.lock_and_signal }\n-%class.rust_scheduler = type opaque\n-%class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n-%class.rust_task_list = type { %class.indexed_list, %struct.rust_task_thread*, i8* }\n-%class.rust_thread = type { i32 (...)**, %struct._opaque_pthread_t*, i64 }\n-%\"class.std::_Rb_tree\" = type { %\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" }\n-%\"class.std::map\" = type { %\"class.std::_Rb_tree\" }\n-%\"class.std::vector\" = type { %\"struct.std::_Vector_base\" }\n-%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n-%struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n-%struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i64, i32, i32, i32, i32 }\n-%struct.__darwin_pthread_handler_rec = type { void (i8*)*, i8*, %struct.__darwin_pthread_handler_rec* }\n-%struct._opaque_pthread_attr_t = type { i64, [56 x i8] }\n-%struct._opaque_pthread_cond_t = type { i64, [40 x i8] }\n-%struct._opaque_pthread_t = type { i64, %struct.__darwin_pthread_handler_rec*, [1168 x i8] }\n-%struct.chan_handle = type { i64, i64 }\n-%\"struct.hash_map<long, rust_port *>::map_entry\" = type opaque\n-%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n-%\"struct.memory_region::alloc_header\" = type { i8 }\n-%struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n-%struct.registers_t = type { [22 x i64] }\n-%struct.rust_box = type opaque\n-%struct.rust_env = type { i64, i64, i64, i8*, i8, i8, i8* }\n-%struct.rust_fn = type { i64*, %struct.rust_box* }\n-%struct.rust_hashable_dict = type { %struct.UT_hash_handle, [0 x i8*] }\n-%struct.rust_obstack_chunk = type { %struct.rust_obstack_chunk*, i64, i64, i64, [0 x i8] }\n-%struct.rust_opaque_box = type { i64, %struct.type_desc*, %struct.rust_opaque_box*, %struct.rust_opaque_box* }\n-%struct.rust_shape_tables = type { i8*, i8* }\n-%struct.rust_task = type { i64, i64, i8, %struct.chan_handle, [8 x i8], %class.context, %struct.stk_seg*, i64, %class.rust_scheduler*, %struct.rust_task_thread*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %\"struct.memory_region::alloc_header\"*, i8*, %struct.rust_task*, i32, i64, i64*, %class.memory_region, %class.boxed_region, i8, i8, %class.lock_and_signal, %class.hash_map, %class.rust_obstack, i32, %\"class.debug::task_debug_info\", i64, i8, i8, %struct.stk_seg*, i64, i64, %class.rust_port_selector }\n-%struct.rust_task_thread = type { %class.rust_thread, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, %class.rust_scheduler*, i32, i32, %class.lock_and_signal, i64, %struct._opaque_pthread_attr_t, %struct.rust_env*, %class.context, i8, %struct.stk_seg*, %struct.stk_seg*, [8 x i8] }\n-%struct.rust_vec = type { i64, i64, [0 x i8] }\n-%\"struct.std::_Rb_tree<long, std::pair<const long, rust_scheduler *>, std::_Select1st<std::pair<const long, rust_scheduler *> >, std::less<long>, std::allocator<std::pair<const long, rust_scheduler *> > >::_Rb_tree_impl\" = type { %\"struct.memory_region::alloc_header\", %\"struct.std::_Rb_tree_node_base\", i64 }\n-%\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n-%\"struct.std::_Vector_base\" = type { %\"struct.std::_Vector_base<long, std::allocator<long> >::_Vector_impl\" }\n-%\"struct.std::_Vector_base<long, std::allocator<long> >::_Vector_impl\" = type { i64*, i64*, i64* }\n-%struct.stk_seg = type { %struct.stk_seg*, %struct.stk_seg*, i64, i32, i64, [0 x i8] }\n-%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i64, i8*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n-\n-define void @rust_intrinsic_vec_len(i64* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n-  %1 = load %struct.rust_vec** %vp, align 8\n-  %2 = getelementptr inbounds %struct.rust_vec* %1, i64 0, i32 0\n-  %3 = load i64* %2, align 8\n-  %4 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %5 = load i64* %4, align 8\n-  %6 = udiv i64 %3, %5\n-  store i64 %6, i64* %retptr, align 8\n-  ret void\n-}\n-\n-define void @rust_intrinsic_ptr_offset(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %ptr, i64 %count) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %2 = load i64* %1, align 8\n-  %3 = mul i64 %2, %count\n-  %4 = getelementptr inbounds i8* %ptr, i64 %3\n-  store i8* %4, i8** %retptr, align 8\n-  ret void\n-}\n-\n-define void @rust_intrinsic_cast(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %t1, i64 0, i32 1\n-  %2 = load i64* %1, align 8\n-  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %retptr, i8* %src, i64 %2, i32 1, i1 false)\n-  ret void\n-}\n-\n-declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind\n-\n-define void @rust_intrinsic_addr_of(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n-  store i8* %valptr, i8** %retptr, align 8\n-  ret void\n-}\n-\n-define void @rust_intrinsic_call_with_retptr(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_fn* nocapture %recvfn) {\n-  %1 = getelementptr inbounds %struct.rust_fn* %recvfn, i64 0, i32 0\n-  %2 = load i64** %1, align 8\n-  %3 = bitcast i64* %2 to void (i8**, i8*, i8**)*\n-  %4 = getelementptr inbounds %struct.rust_fn* %recvfn, i64 0, i32 1\n-  %5 = load %struct.rust_box** %4, align 8\n-  %6 = bitcast %struct.rust_box* %5 to i8*\n-  tail call void %3(i8** null, i8* %6, i8** %retptr)\n-  ret void\n-}\n-\n-define void @rust_intrinsic_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind {\n-  %ty.c = bitcast %struct.type_desc* %ty to i8*\n-  store i8* %ty.c, i8** %retptr, align 8\n-  ret void\n-}\n-\n-define void @rust_intrinsic_task_yield(i8** nocapture %retptr, i8* nocapture %env, %struct.rust_task* %task, i8* %killed) {\n-  tail call void @rust_task_yield(%struct.rust_task* %task, i8* %killed)\n-  ret void\n-}\n-\n-declare void @rust_task_yield(%struct.rust_task*, i8*)\n-\n-define void @rust_intrinsic_memmove(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i64 %count) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %2 = load i64* %1, align 8\n-  %3 = mul i64 %2, %count\n-  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %3, i32 1, i1 false)\n-  ret void\n-}\n-\n-define void @rust_intrinsic_memcpy(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %dst, i8* nocapture %src, i64 %count) nounwind {\n-  %1 = getelementptr inbounds %struct.type_desc* %ty, i64 0, i32 1\n-  %2 = load i64* %1, align 8\n-  %3 = mul i64 %2, %count\n-  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dst, i8* %src, i64 %3, i32 1, i1 false)\n-  ret void\n-}\n-\n-declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind\n-\n-define void @rust_intrinsic_leak(i8* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, i8* nocapture %thing) nounwind readnone {\n-  ret void\n-}\n-\n-define void @upcall_intrinsic_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n-; <label>:0\n-  %1 = load %struct.rust_vec** %vp, align 8\n-  %2 = getelementptr inbounds %struct.rust_vec* %1, i64 0, i32 0\n-  %3 = load i64* %2, align 8\n-  %4 = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 1\n-  %5 = load i64* %4, align 8\n-  %6 = add i64 %5, %3\n-  %7 = getelementptr inbounds %struct.rust_vec* %1, i64 0, i32 1\n-  %8 = load i64* %7, align 8\n-  %9 = icmp ult i64 %8, %6\n-  br i1 %9, label %10, label %_Z16reserve_vec_fastPP8rust_vecm.exit\n-\n-; <label>:10                                      ; preds = %0\n-  %11 = add i64 %6, -1\n-  %12 = lshr i64 %11, 1\n-  %13 = or i64 %12, %11\n-  %14 = lshr i64 %13, 2\n-  %15 = or i64 %14, %13\n-  %16 = lshr i64 %15, 4\n-  %17 = or i64 %16, %15\n-  %18 = lshr i64 %17, 8\n-  %19 = or i64 %18, %17\n-  %20 = lshr i64 %19, 16\n-  %21 = or i64 %20, %19\n-  %22 = lshr i64 %21, 32\n-  %23 = or i64 %22, %21\n-  %24 = add i64 %23, 1\n-  %25 = add i64 %23, 17\n-  %26 = bitcast %struct.rust_vec* %1 to i8*\n-  %27 = tail call i8* @upcall_shared_realloc(i8* %26, i64 %25)\n-  %28 = bitcast i8* %27 to %struct.rust_vec*\n-  store %struct.rust_vec* %28, %struct.rust_vec** %vp, align 8\n-  %29 = getelementptr inbounds i8* %27, i64 8\n-  %30 = bitcast i8* %29 to i64*\n-  store i64 %24, i64* %30, align 8\n-  %.pr = load i64* %4, align 8\n-  %.pre = load %struct.rust_vec** %vp, align 8\n-  %.phi.trans.insert = getelementptr inbounds %struct.rust_vec* %.pre, i64 0, i32 0\n-  %.pre4 = load i64* %.phi.trans.insert, align 8\n-  br label %_Z16reserve_vec_fastPP8rust_vecm.exit\n-\n-_Z16reserve_vec_fastPP8rust_vecm.exit:            ; preds = %0, %10\n-  %31 = phi i64 [ %3, %0 ], [ %.pre4, %10 ]\n-  %32 = phi %struct.rust_vec* [ %1, %0 ], [ %.pre, %10 ]\n-  %33 = phi i64 [ %5, %0 ], [ %.pr, %10 ]\n-  %34 = getelementptr inbounds %struct.rust_vec* %32, i64 0, i32 0\n-  %35 = getelementptr inbounds %struct.rust_vec* %32, i64 0, i32 2, i64 %31\n-  tail call void @llvm.memmove.p0i8.p0i8.i64(i8* %35, i8* %elt, i64 %33, i32 1, i1 false)\n-  %36 = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 3\n-  %37 = load void (i8*, i8*, %struct.type_desc**, i8*)** %36, align 8\n-  %38 = icmp eq void (i8*, i8*, %struct.type_desc**, i8*)* %37, null\n-  br i1 %38, label %_ZL13copy_elementsP9type_descPvS1_m.exit, label %39\n-\n-; <label>:39                                      ; preds = %_Z16reserve_vec_fastPP8rust_vecm.exit\n-  %40 = load i64* %4, align 8\n-  %41 = getelementptr inbounds %struct.type_desc* %elt_ty, i64 0, i32 0\n-  %42 = load %struct.type_desc*** %41, align 8\n-  %43 = icmp sgt i64 %33, 0\n-  br i1 %43, label %.lr.ph.i.preheader, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n-\n-.lr.ph.i.preheader:                               ; preds = %39\n-  %scevgep = getelementptr %struct.rust_vec* %32, i64 1, i32 0\n-  %scevgep2 = bitcast i64* %scevgep to i8*\n-  br label %.lr.ph.i\n-\n-.lr.ph.i:                                         ; preds = %.lr.ph.i.preheader, %.lr.ph.i\n-  %indvar.i = phi i64 [ %indvar.next.i, %.lr.ph.i ], [ 0, %.lr.ph.i.preheader ]\n-  %tmp = mul i64 %40, %indvar.i\n-  %tmp2.i = add i64 %40, %tmp\n-  %tmp3 = add i64 %31, %tmp\n-  %p.01.i = getelementptr i8* %scevgep2, i64 %tmp3\n-  tail call void %37(i8* null, i8* null, %struct.type_desc** %42, i8* %p.01.i)\n-  %44 = icmp slt i64 %tmp2.i, %33\n-  %indvar.next.i = add i64 %indvar.i, 1\n-  br i1 %44, label %.lr.ph.i, label %_ZL13copy_elementsP9type_descPvS1_m.exit\n-\n-_ZL13copy_elementsP9type_descPvS1_m.exit:         ; preds = %.lr.ph.i, %_Z16reserve_vec_fastPP8rust_vecm.exit, %39\n-  %45 = load i64* %4, align 8\n-  %46 = load i64* %34, align 8\n-  %47 = add i64 %46, %45\n-  store i64 %47, i64* %34, align 8\n-  ret void\n-}\n-\n-define void @upcall_vec_push(%struct.rust_vec** nocapture %vp, %struct.type_desc* nocapture %elt_ty, i8* nocapture %elt) {\n-  tail call void @upcall_intrinsic_vec_push(%struct.rust_vec** %vp, %struct.type_desc* %elt_ty, i8* %elt)\n-  ret void\n-}\n-\n-define void @rust_intrinsic_frame_address(i8** nocapture %p) nounwind {\n-  %1 = tail call i8* @llvm.frameaddress(i32 1)\n-  store i8* %1, i8** %p, align 8\n-  ret void\n-}\n-\n-declare i8* @llvm.frameaddress(i32) nounwind readnone\n-\n-declare i8* @upcall_shared_realloc(i8*, i64)"}, {"sha": "cf01d9507f2289296648a92fd5f8e634c167913a", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -30,69 +30,6 @@ fn llvm_err(sess: session, msg: str) -> ! unsafe {\n     } else { sess.fatal(msg + \": \" + str::unsafe::from_c_str(cstr)); }\n }\n \n-fn load_intrinsics_bc(sess: session) -> option<ModuleRef> {\n-    let path = alt filesearch::search(\n-        sess.filesearch,\n-        bind filesearch::pick_file(\"intrinsics.bc\", _)) {\n-      option::some(path) { path }\n-      option::none {\n-        sess.warn(\"couldn't find intrinsics.bc\");\n-        ret option::none;\n-      }\n-    };\n-    let membuf = str::as_c_str(path, {|buf|\n-        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-                                   });\n-    if membuf as uint == 0u {\n-        llvm_err(sess, \"installation problem: couldn't open \" + path);\n-    }\n-    let llintrinsicsmod = llvm::LLVMRustParseBitcode(membuf);\n-    llvm::LLVMDisposeMemoryBuffer(membuf);\n-    if llintrinsicsmod as uint == 0u {\n-        sess.warn(\"couldn't parse intrinsics.bc\");\n-        ret option::none;\n-    }\n-\n-    ret option::some(llintrinsicsmod);\n-}\n-\n-fn load_intrinsics_ll(sess: session) -> ModuleRef {\n-    let path = alt filesearch::search(\n-        sess.filesearch,\n-        bind filesearch::pick_file(\"intrinsics.ll\", _)) {\n-      option::some(path) { path }\n-      option::none { sess.fatal(\"couldn't find intrinsics.ll\") }\n-    };\n-    let llintrinsicsmod = str::as_c_str(path, { |buf|\n-        llvm::LLVMRustParseAssemblyFile(buf)\n-                                        });\n-    if llintrinsicsmod as uint == 0u {\n-        llvm_err(sess, \"couldn't parse intrinsics.ll\");\n-    }\n-    ret llintrinsicsmod;\n-}\n-\n-fn link_intrinsics(sess: session, llmod: ModuleRef) {\n-    let llintrinsicsmod = {\n-        alt load_intrinsics_bc(sess) {\n-          option::some(m) { m }\n-          option::none {\n-            // When the bitcode format changes we can't parse a .bc\n-            // file produced with a newer LLVM (as happens when stage0\n-            // is trying to build against a new LLVM revision), in\n-            // that case we'll try to parse the assembly.\n-            sess.warn(\"couldn't parse intrinsics.bc, trying intrinsics.ll\");\n-            load_intrinsics_ll(sess)\n-          }\n-        }\n-    };\n-    let linkres = llvm::LLVMLinkModules(llmod, llintrinsicsmod);\n-    llvm::LLVMDisposeModule(llintrinsicsmod);\n-    if linkres == False {\n-        llvm_err(sess, \"couldn't link the module with the intrinsics\");\n-    }\n-}\n-\n mod write {\n     fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n         if ot == output_type_assembly || ot == output_type_object ||\n@@ -115,7 +52,6 @@ mod write {\n     fn run_passes(sess: session, llmod: ModuleRef, output: str) {\n         let opts = sess.opts;\n         if opts.time_llvm_passes { llvm::LLVMRustEnableTimePasses(); }\n-        link_intrinsics(sess, llmod);\n         let mut pm = mk_pass_manager();\n         let td = mk_target_data(\n             sess.targ_cfg.target_strs.data_layout);"}, {"sha": "43c924b959576590800eb34b47af9d30edec74f9", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -17,7 +17,6 @@ type upcalls =\n      shared_realloc: ValueRef,\n      mark: ValueRef,\n      vec_grow: ValueRef,\n-     vec_push: ValueRef,\n      str_concat: ValueRef,\n      cmp_type: ValueRef,\n      log_type: ValueRef,\n@@ -41,7 +40,6 @@ fn declare_upcalls(targ_cfg: @session::config,\n     }\n     let d = bind decl(llmod, \"upcall_\", _, _, _);\n     let dv = bind decl(llmod, \"upcall_\", _, _, T_void());\n-    let dvi = bind decl(llmod, \"upcall_intrinsic_\", _, _, T_void());\n \n     let int_t = T_int(targ_cfg);\n     let size_t = T_size_t(targ_cfg);\n@@ -66,10 +64,6 @@ fn declare_upcalls(targ_cfg: @session::config,\n               d(\"mark\", [T_ptr(T_i8())], int_t),\n           vec_grow:\n               dv(\"vec_grow\", [T_ptr(T_ptr(opaque_vec_t)), int_t]),\n-          vec_push:\n-              dvi(\"vec_push\",\n-                [T_ptr(T_ptr(opaque_vec_t)), T_ptr(tydesc_type),\n-                 T_ptr(T_i8())]),\n           str_concat:\n               d(\"str_concat\", [T_ptr(opaque_vec_t), T_ptr(opaque_vec_t)],\n                 T_ptr(opaque_vec_t)),"}, {"sha": "4fdb3e2fe7ec096c91177fda2f394d8b1e2ce3fe", "filename": "src/rustc/front/attr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fattr.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -237,9 +237,6 @@ fn native_abi(attrs: [ast::attribute]) -> either<str, ast::native_abi> {\n       option::none {\n         either::right(ast::native_abi_cdecl)\n       }\n-      option::some(\"rust-intrinsic\") {\n-        either::right(ast::native_abi_rust_intrinsic)\n-      }\n       option::some(\"rust-builtin\") {\n         either::right(ast::native_abi_rust_builtin)\n       }"}, {"sha": "8a6b0eb30b2f25df1f44aea58e94c9fc68ba498c", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -68,7 +68,6 @@ const tag_mod_impl: uint = 0x30u;\n \n const tag_item_method: uint = 0x31u;\n const tag_impl_iface: uint = 0x32u;\n-const tag_item_is_intrinsic: uint = 0x33u;\n \n // discriminator value for variants\n const tag_disr_val: uint = 0x34u;"}, {"sha": "e43b7aa7ff355241da6d66cb1a5ac64704ed798f", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -26,7 +26,6 @@ export get_type;\n export get_impl_iface;\n export get_impl_method;\n export get_item_path;\n-export item_is_intrinsic;\n export maybe_get_item_ast, found_ast, found, found_parent, not_found;\n \n fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n@@ -190,11 +189,6 @@ fn get_class_method(cstore: cstore::cstore, def: ast::def_id, mname: str)\n     decoder::get_class_method(cdata, def.node, mname)\n }\n \n-fn item_is_intrinsic(cstore: cstore::cstore, def: ast::def_id) -> bool {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::item_is_intrinsic(cdata, def.node)\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "97a77dd71d3bbc6ef9c15bc9d26aa8ea1a8dd15e", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -41,7 +41,6 @@ export get_item_path;\n export maybe_find_item; // sketchy\n export item_type; // sketchy\n export maybe_get_item_ast;\n-export item_is_intrinsic;\n \n // Used internally by astencode:\n export translate_def_id;\n@@ -309,13 +308,6 @@ fn get_class_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n     }\n }\n \n-fn item_is_intrinsic(cdata: cmd, id: ast::node_id) -> bool {\n-    let mut intrinsic = false;\n-    ebml::tagged_docs(lookup_item(id, cdata.data), tag_item_is_intrinsic,\n-                      {|_i| intrinsic = true;});\n-    intrinsic\n-}\n-\n fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }"}, {"sha": "2533d12545765715e79248b976181e36493b96fc", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -676,10 +676,6 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(fn_decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        if abi == native_abi_rust_intrinsic {\n-            ebml_w.start_tag(tag_item_is_intrinsic);\n-            ebml_w.end_tag();\n-        }\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, nitem.id));\n         if abi == native_abi_rust_builtin {\n             astencode::encode_inlined_item(ecx, ebml_w, path,"}, {"sha": "7faf81bdcdcc789cb155f554df92145c06736775", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 53, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -1801,9 +1801,7 @@ enum callee_env {\n type lval_maybe_callee = {bcx: block,\n                           val: ValueRef,\n                           kind: lval_kind,\n-                          env: callee_env,\n-                          // Tydescs to pass. Only used to call intrinsics\n-                          tds: option<[ValueRef]>};\n+                          env: callee_env};\n \n fn null_env_ptr(bcx: block) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx.ccx()))\n@@ -1822,7 +1820,7 @@ fn lval_temp(bcx: block, val: ValueRef) -> lval_result {\n \n fn lval_no_env(bcx: block, val: ValueRef, kind: lval_kind)\n     -> lval_maybe_callee {\n-    ret {bcx: bcx, val: val, kind: kind, env: is_closure, tds: none};\n+    ret {bcx: bcx, val: val, kind: kind, env: is_closure};\n }\n \n fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n@@ -1909,7 +1907,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t],\n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n                   vtables: option<typeck::vtable_res>,\n                   ref_id: option<ast::node_id>)\n-    -> {val: ValueRef, must_cast: bool, intrinsic: bool} {\n+    -> {val: ValueRef, must_cast: bool} {\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, {|t|\n@@ -1927,7 +1925,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n     }\n     alt ccx.monomorphized.find(hash_id) {\n       some(val) {\n-        ret {val: val, must_cast: must_cast, intrinsic: false};\n+        ret {val: val, must_cast: must_cast};\n       }\n       none {}\n     }\n@@ -1954,8 +1952,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n       ast_map::node_native_item(_, abi, _) {\n         // Natives don't have to be monomorphized.\n         ret {val: get_item_val(ccx, fn_id.node),\n-             must_cast: true,\n-             intrinsic: abi == ast::native_abi_rust_intrinsic};\n+             must_cast: true};\n       }\n       ast_map::node_ctor(i, _) {\n         alt check ccx.tcx.items.get(i.id) {\n@@ -2014,7 +2011,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         }\n       }\n     }\n-    {val: lldecl, must_cast: must_cast, intrinsic: false}\n+    {val: lldecl, must_cast: must_cast}\n }\n \n fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n@@ -2078,33 +2075,6 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     }\n }\n \n-fn lval_intrinsic_fn(bcx: block, val: ValueRef, tys: [ty::t],\n-                     id: ast::node_id) -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(\"lval_intrinsic_fn\");\n-    fn add_tydesc_params(ccx: @crate_ctxt, llfty: TypeRef, n: uint)\n-        -> TypeRef {\n-        let out_ty = llvm::LLVMGetReturnType(llfty);\n-        let n_args = llvm::LLVMCountParamTypes(llfty);\n-        let args = vec::from_elem(n_args as uint, 0 as TypeRef);\n-        unsafe { llvm::LLVMGetParamTypes(llfty, vec::unsafe::to_ptr(args)); }\n-        T_fn(vec::slice(args, 0u, first_real_arg) +\n-             vec::from_elem(n, T_ptr(ccx.tydesc_type)) +\n-             vec::tailn(args, first_real_arg), out_ty)\n-    }\n-\n-    let mut bcx = bcx;\n-    let ccx = bcx.ccx();\n-    let tds = vec::map(tys, {|t|\n-        let mut ti = none, td = get_tydesc(bcx.ccx(), t, ti);\n-        lazily_emit_all_tydesc_glue(ccx, ti);\n-        td\n-    });\n-    let llfty = type_of_fn_from_ty(ccx, node_id_type(bcx, id));\n-    let val = PointerCast(bcx, val, T_ptr(add_tydesc_params(\n-        ccx, llfty, tys.len())));\n-    {bcx: bcx, val: val, kind: owned, env: null_env, tds: some(tds)}\n-}\n-\n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n     -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"lval_static_fn\");\n@@ -2128,14 +2098,13 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n     } else { fn_id };\n \n     if fn_id.crate == ast::local_crate && tys.len() > 0u {\n-        let mut {val, must_cast, intrinsic} =\n+        let mut {val, must_cast} =\n             monomorphic_fn(ccx, fn_id, tys, vtables, some(id));\n-        if intrinsic { ret lval_intrinsic_fn(bcx, val, tys, id); }\n         if must_cast {\n             val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n                 ccx, node_id_type(bcx, id))));\n         }\n-        ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: none};\n+        ret {bcx: bcx, val: val, kind: owned, env: null_env};\n     }\n \n     let mut val = if fn_id.crate == ast::local_crate {\n@@ -2146,11 +2115,6 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         trans_external_path(ccx, fn_id, tpt.ty)\n     };\n     if tys.len() > 0u {\n-        // This is supposed to be an external native function.\n-        // Unfortunately, I found no easy/cheap way to assert that.\n-        if csearch::item_is_intrinsic(ccx.sess.cstore, fn_id) {\n-            ret lval_intrinsic_fn(bcx, val, tys, id);\n-        }\n         val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n             ccx, node_id_type(bcx, id))));\n     }\n@@ -2167,7 +2131,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         }\n     }\n \n-    ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: none};\n+    ret {bcx: bcx, val: val, kind: owned, env: null_env};\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n@@ -2625,7 +2589,7 @@ enum call_args {\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n-              dest: dest, always_valid_retptr: bool)\n+              dest: dest)\n     -> {bcx: block, args: [ValueRef], retslot: ValueRef} {\n     let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = [];\n@@ -2639,7 +2603,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n     // Arg 0: Output pointer.\n     let llretslot = alt dest {\n       ignore {\n-        if ty::type_is_nil(retty) && !always_valid_retptr {\n+        if ty::type_is_nil(retty) {\n             llvm::LLVMGetUndef(T_ptr(T_nil()))\n         } else {\n             let {bcx: cx, val} = alloc_ty(bcx, retty);\n@@ -2733,15 +2697,10 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n         };\n \n         let args_res = {\n-            trans_args(bcx, llenv, args, fn_expr_ty, dest,\n-                       option::is_some(f_res.tds))\n+            trans_args(bcx, llenv, args, fn_expr_ty, dest)\n         };\n         bcx = args_res.bcx;\n         let mut llargs = args_res.args;\n-        option::may(f_res.tds) {|vals|\n-            llargs = vec::slice(llargs, 0u, first_real_arg) + vals +\n-                vec::tailn(llargs, first_real_arg);\n-        }\n \n         let llretslot = args_res.retslot;\n "}, {"sha": "a10eda9932a732d227744b7ae034220229498ce4", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -416,7 +416,6 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n                 args: [option<@ast::expr>], pair_ty: ty::t,\n                 dest: dest) -> block {\n     let _icx = cx.insn_ctxt(\"closure::trans_bind1\");\n-    assert option::is_none(f_res.tds);\n     let ccx = cx.ccx();\n     let mut bound: [@ast::expr] = [];\n     for argopt: option<@ast::expr> in args {"}, {"sha": "0f9c5cf4759f2d2cbb44a64ca4e73467dcc83588", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -79,7 +79,7 @@ fn trans_vtable_callee(bcx: block, env: callee_env, vtable: ValueRef,\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n-    {bcx: bcx, val: mptr, kind: owned, env: env, tds: none}\n+    {bcx: bcx, val: mptr, kind: owned, env: env}\n }\n \n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,"}, {"sha": "dbbf918f896bc1ce348086d414ccb13535f4483d", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -730,10 +730,6 @@ fn trans_native_mod(ccx: @crate_ctxt,\n     }\n \n     let mut cc = alt abi {\n-      ast::native_abi_rust_intrinsic {\n-        for item in native_mod.items { get_item_val(ccx, item.id); }\n-        ret;\n-      }\n       ast::native_abi_rust_builtin { ret; }\n       ast::native_abi_cdecl { lib::llvm::CCallConv }\n       ast::native_abi_stdcall { lib::llvm::X86StdcallCallConv }\n@@ -1009,28 +1005,5 @@ fn abi_of_native_fn(ccx: @crate_ctxt, i: @ast::native_item)\n \n fn decl_native_fn(ccx: @crate_ctxt, i: @ast::native_item,\n                   pth: ast_map::path) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(\"native::decl_native_fn\");\n-    alt i.node {\n-      ast::native_item_fn(_, _) {\n-        let node_type = ty::node_id_to_type(ccx.tcx, i.id);\n-        alt abi_of_native_fn(ccx, i) {\n-          ast::native_abi_rust_intrinsic {\n-            // For intrinsics: link the function directly to the intrinsic\n-            // function itself.\n-            let fn_type = type_of_fn_from_ty(ccx, node_type);\n-            let ri_name = \"rust_intrinsic_\" + native::link_name(i);\n-            ccx.item_symbols.insert(i.id, ri_name);\n-            get_extern_fn(ccx.externs, ccx.llmod, ri_name,\n-                          lib::llvm::CCallConv, fn_type)\n-          }\n-          ast::native_abi_cdecl | ast::native_abi_stdcall |\n-          ast::native_abi_rust_builtin {\n-            // For true external functions: create a rust wrapper\n-            // and link to that.  The rust wrapper will handle\n-            // switching to the C stack.\n-            register_fn(ccx, i.span, pth, i.id)\n-          }\n-        }\n-      }\n-    }\n+    register_fn(ccx, i.span, pth, i.id)\n }"}, {"sha": "5b381b79c4dc62e45143dc641afb5379ac1fb175", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -52,11 +52,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       _ {}\n     }\n \n-    // FIXME handle external native functions in a more efficient way\n     if fn_id_loc.crate != local_crate {\n-        if csearch::item_is_intrinsic(ccx.sess.cstore, fn_id) {\n-            uint::range(0u, n_tps) {|n| cx.uses[n] |= use_tydesc;}\n-        }\n         let uses = vec::from_mut(cx.uses);\n         ccx.type_use_cache.insert(fn_id, uses);\n         ret uses;\n@@ -72,9 +68,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         uint::range(0u, n_tps) {|n| cx.uses[n] |= use_repr;}\n       }\n       ast_map::node_native_item(i@@{node: native_item_fn(_, _), _}, abi, _) {\n-        if abi == native_abi_rust_intrinsic {\n-            uint::range(0u, n_tps) {|n| cx.uses[n] |= use_tydesc;}\n-        } else if abi == native_abi_rust_builtin {\n+        if abi == native_abi_rust_builtin {\n             let flags = alt check i.ident {\n               \"size_of\" | \"align_of\" | \"init\" |\n               \"reinterpret_cast\" { use_repr }"}, {"sha": "e3881eec2032197658cd923b8d88905919972d39", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5024692d49be49b2efff452059f83efaebfd0ee/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=f5024692d49be49b2efff452059f83efaebfd0ee", "patch": "@@ -556,7 +556,6 @@ type _mod = {view_items: [@view_item], items: [@item]};\n \n #[auto_serialize]\n enum native_abi {\n-    native_abi_rust_intrinsic,\n     native_abi_rust_builtin,\n     native_abi_cdecl,\n     native_abi_stdcall,"}]}