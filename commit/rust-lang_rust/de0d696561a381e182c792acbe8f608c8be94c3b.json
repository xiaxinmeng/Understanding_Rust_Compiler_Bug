{"sha": "de0d696561a381e182c792acbe8f608c8be94c3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMGQ2OTY1NjFhMzgxZTE4MmM3OTJhY2JlOGY2MDhjOGJlOTRjM2I=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-02T02:38:19Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-07-03T14:46:49Z"}, "message": "Remove vec::{filter, filtered, filter_map, filter_mapped}, replaced by iterators.", "tree": {"sha": "e1468b45552bcd5e026659cf19c8fb185997daa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1468b45552bcd5e026659cf19c8fb185997daa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de0d696561a381e182c792acbe8f608c8be94c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de0d696561a381e182c792acbe8f608c8be94c3b", "html_url": "https://github.com/rust-lang/rust/commit/de0d696561a381e182c792acbe8f608c8be94c3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de0d696561a381e182c792acbe8f608c8be94c3b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eee677564216a64f48ebaffa860e4062f2b2d264", "url": "https://api.github.com/repos/rust-lang/rust/commits/eee677564216a64f48ebaffa860e4062f2b2d264", "html_url": "https://github.com/rust-lang/rust/commit/eee677564216a64f48ebaffa860e4062f2b2d264"}], "stats": {"total": 549, "additions": 131, "deletions": 418}, "files": [{"sha": "97793ce440c2b477726145334de97c5e7d5369db", "filename": "src/libextra/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -523,7 +523,7 @@ pub fn filter_tests(\n             } else { return option::None; }\n         }\n \n-        vec::filter_map(filtered, |x| filter_fn(x, filter_str))\n+        filtered.consume_iter().filter_map(|x| filter_fn(x, filter_str)).collect()\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -541,7 +541,7 @@ pub fn filter_tests(\n                 None\n             }\n         };\n-        vec::filter_map(filtered, |x| filter(x))\n+        filtered.consume_iter().filter_map(|x| filter(x)).collect()\n     };\n \n     // Sort the tests alphabetically\n@@ -720,9 +720,9 @@ impl BenchHarness {\n             // Eliminate outliers\n             let med = samples.median();\n             let mad = samples.median_abs_dev();\n-            let samples = do vec::filter(samples) |f| {\n+            let samples = do samples.consume_iter().filter |f| {\n                 num::abs(*f - med) <= 3.0 * mad\n-            };\n+            }.collect::<~[f64]>();\n \n             debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n                    n_samples, med as float, mad as float,"}, {"sha": "7d478afee41a1bf85b41be7b6f723cdf5319f453", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -10,7 +10,6 @@\n \n \n use std::option;\n-use std::vec;\n use syntax::{ast, fold, attr};\n \n type in_cfg_pred = @fn(attrs: ~[ast::attribute]) -> bool;\n@@ -61,13 +60,15 @@ fn filter_view_item(cx: @Context, view_item: @ast::view_item\n }\n \n fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n-    let filtered_items =\n-        m.items.filter_mapped(|a| filter_item(cx, *a));\n-    let filtered_view_items =\n-        m.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n+    let filtered_items = do  m.items.iter().filter_map |a| {\n+        filter_item(cx, *a).chain(|x| fld.fold_item(x))\n+    }.collect();\n+    let filtered_view_items = do m.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+    }.collect();\n     ast::_mod {\n-        view_items: filtered_view_items.map(|x| fld.fold_view_item(*x)),\n-        items: vec::filter_map(filtered_items, |x| fld.fold_item(x))\n+        view_items: filtered_view_items,\n+        items: filtered_items\n     }\n }\n \n@@ -83,14 +84,14 @@ fn fold_foreign_mod(\n     nm: &ast::foreign_mod,\n     fld: @fold::ast_fold\n ) -> ast::foreign_mod {\n-    let filtered_items =\n-        nm.items.filter_mapped(|a| filter_foreign_item(cx, *a));\n-    let filtered_view_items =\n-        nm.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n+    let filtered_items = nm.items.iter().filter_map(|a| filter_foreign_item(cx, *a)).collect();\n+    let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+    }.collect();\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: filtered_view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n+        view_items: filtered_view_items,\n         items: filtered_items\n     }\n }\n@@ -99,11 +100,13 @@ fn fold_item_underscore(cx: @Context, item: &ast::item_,\n                         fld: @fold::ast_fold) -> ast::item_ {\n     let item = match *item {\n         ast::item_impl(ref a, b, c, ref methods) => {\n-            let methods = methods.filtered(|m| method_in_cfg(cx, *m) );\n+            let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n+                .transform(|x| *x).collect();\n             ast::item_impl(/*bad*/ copy *a, b, c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n-            let methods = methods.filtered(|m| trait_method_in_cfg(cx, m) );\n+            let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )\n+                .transform(|x| /* bad */copy *x).collect();\n             ast::item_trait(/*bad*/copy *a, /*bad*/copy *b, methods)\n         }\n         ref item => /*bad*/ copy *item\n@@ -134,19 +137,12 @@ fn fold_block(\n     b: &ast::blk_,\n     fld: @fold::ast_fold\n ) -> ast::blk_ {\n-    let filtered_stmts =\n-        b.stmts.filter_mapped(|a| filter_stmt(cx, *a));\n-    let filtered_view_items =\n-        b.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n-    let filtered_view_items =\n-        filtered_view_items.map(|x| fld.fold_view_item(*x));\n-    let mut resulting_stmts = ~[];\n-    for filtered_stmts.iter().advance |stmt| {\n-        match fld.fold_stmt(*stmt) {\n-            None => {}\n-            Some(stmt) => resulting_stmts.push(stmt),\n-        }\n-    }\n+    let resulting_stmts = do b.stmts.iter().filter_map |a| {\n+        filter_stmt(cx, *a).chain(|stmt| fld.fold_stmt(stmt))\n+    }.collect();\n+    let filtered_view_items = do b.view_items.iter().filter_map |a| {\n+        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+    }.collect();\n     ast::blk_ {\n         view_items: filtered_view_items,\n         stmts: resulting_stmts,\n@@ -193,7 +189,9 @@ pub fn metas_in_cfg(cfg: &[@ast::meta_item],\n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    let cfg_metas = vec::filter_map(cfg_metas, |i| attr::get_meta_item_list(i));\n+    let cfg_metas = cfg_metas.consume_iter()\n+        .filter_map(|i| attr::get_meta_item_list(i))\n+        .collect::<~[~[@ast::meta_item]]>();\n \n     if cfg_metas.iter().all(|c| c.is_empty()) { return true; }\n "}, {"sha": "91000d68aad09be29aca378f16efecca3346266f", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -109,9 +109,11 @@ fn fold_mod(cx: @mut TestCtxt,\n \n     fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n         if !*cx.sess.building_library {\n-            @ast::item{attrs: item.attrs.filtered(|attr| {\n-                               \"main\" != attr::get_attr_name(attr)\n-                           }),.. copy *item}\n+            @ast::item{\n+                attrs: do item.attrs.iter().filter_map |attr| {\n+                    if \"main\" != attr::get_attr_name(attr) {Some(*attr)} else {None}\n+                }.collect(),\n+                .. copy *item}\n         } else { item }\n     }\n \n@@ -229,10 +231,10 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     return if !ignoreitems.is_empty() {\n-        let cfg_metas =\n-            vec::concat(\n-                vec::filter_map(ignoreitems,\n-                                |i| attr::get_meta_item_list(i)));\n+        let cfg_metas = ignoreitems.consume_iter()\n+            .filter_map(|i| attr::get_meta_item_list(i))\n+            .collect::<~[~[@ast::meta_item]]>()\n+            .concat_vec();\n         config::metas_in_cfg(/*bad*/copy cx.crate.node.config, cfg_metas)\n     } else {\n         false"}, {"sha": "72b6f8e1c805bd00e1e0ed6b67ca1936aa40b43d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -291,16 +291,16 @@ fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n // inlined items.\n fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n     fn drop_nested_items(blk: &ast::blk_, fld: @fold::ast_fold) -> ast::blk_ {\n-        let stmts_sans_items = do blk.stmts.filtered |stmt| {\n+        let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n-              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_),\n-                                             span: _}, _) => true,\n-              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_),\n-                                             span: _}, _) => false,\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_local(_), span: _}, _)\n+                => Some(*stmt),\n+              ast::stmt_decl(@codemap::spanned { node: ast::decl_item(_), span: _}, _)\n+                => None,\n               ast::stmt_mac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n-        };\n+        }.collect();\n         let blk_sans_items = ast::blk_ {\n             view_items: ~[], // I don't know if we need the view_items here,\n                              // but it doesn't break tests!"}, {"sha": "740499bbf25e6cd26f218dd24afb785a8672b678", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -95,7 +95,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = vec::concat(arms.filter_mapped(unguarded_pat));\n+       let arms = arms.iter().filter_map(unguarded_pat).collect::<~[~[@pat]]>().concat_vec();\n        if arms.is_empty() {\n            cx.tcx.sess.span_err(ex.span, \"non-exhaustive patterns\");\n        } else {\n@@ -265,7 +265,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n           }\n           Some(ref ctor) => {\n             match is_useful(cx,\n-                            &m.filter_mapped(|r| default(cx, *r)),\n+                            &m.iter().filter_map(|r| default(cx, *r)).collect::<matrix>(),\n                             v.tail()) {\n               useful_ => useful(left_ty, /*bad*/copy *ctor),\n               ref u => (/*bad*/copy *u)\n@@ -287,7 +287,7 @@ pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n-    let ms = m.filter_mapped(|r| specialize(cx, *r, &ctor, arity, lty));\n+    let ms = m.iter().filter_map(|r| specialize(cx, *r, &ctor, arity, lty)).collect::<matrix>();\n     let could_be_useful = is_useful(\n         cx, &ms, specialize(cx, v, &ctor, arity, lty).get());\n     match could_be_useful {\n@@ -397,14 +397,14 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n         // Find the lengths and slices of all vector patterns.\n-        let vec_pat_lens = do m.filter_mapped |r| {\n+        let vec_pat_lens = do m.iter().filter_map |r| {\n             match r[0].node {\n                 pat_vec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n                 }\n                 _ => None\n             }\n-        };\n+        }.collect::<~[(uint, bool)]>();\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first."}, {"sha": "75b1830778b1bd9d81c88c6a245baff744f82733", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -26,7 +26,6 @@ use util::ppaux;\n use middle::trans::type_::Type;\n \n use std::str;\n-use std::vec;\n use syntax::ast;\n use syntax::ast::ident;\n use syntax::ast_map::path_mod;\n@@ -190,9 +189,13 @@ pub fn trans_log(log_ex: &ast::expr,\n \n     let (modpath, modname) = {\n         let path = &mut bcx.fcx.path;\n-        let modpath = vec::append(\n-            ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))],\n-            path.filtered(|e| match *e { path_mod(_) => true, _ => false }));\n+        let mut modpath = ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))];\n+        for path.iter().advance |e| {\n+            match *e {\n+                path_mod(_) => { modpath.push(*e) }\n+                _ => {}\n+            }\n+        }\n         let modname = path_str(ccx.sess, modpath);\n         (modpath, modname)\n     };"}, {"sha": "0681cf867f13a322004ad03585cea727069353fd", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -45,9 +45,9 @@ pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n-    let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n-        attr::get_meta_item_value_str(*meta).map(|s| s.to_owned())\n-    };\n+    let doc_strs = do doc_metas(attrs).consume_iter().filter_map |meta| {\n+        attr::get_meta_item_value_str(meta).map(|s| s.to_owned())\n+    }.collect::<~[~str]>();\n     if doc_strs.is_empty() {\n         None\n     } else {"}, {"sha": "ffb4642be8107dcd8509a25e0cfb9ba19eb1ded3", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 39, "deletions": 104, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -13,8 +13,6 @@\n \n use doc;\n \n-use std::vec;\n-\n pub type AstId = int;\n \n #[deriving(Eq)]\n@@ -186,87 +184,64 @@ impl Doc {\n     }\n }\n \n+macro_rules! filt_mapper {\n+    ($vec:expr, $pat:pat) => {\n+        do ($vec).iter().filter_map |thing| {\n+            match thing {\n+                &$pat => Some(copy *x),\n+                _ => None\n+            }\n+        }.collect()\n+    }\n+}\n+\n+macro_rules! md {\n+    ($id:ident) => {\n+        filt_mapper!(self.items, $id(ref x))\n+    }\n+}\n /// Some helper methods on ModDoc, mostly for testing\n impl ModDoc {\n     pub fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ModTag(ModDoc) => Some(ModDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ModTag)\n     }\n \n     pub fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              NmodTag(nModDoc) => Some(nModDoc),\n-              _ => None\n-            }\n-        }\n+        md!(NmodTag)\n     }\n \n     pub fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              FnTag(FnDoc) => Some(FnDoc),\n-              _ => None\n-            }\n-        }\n+        md!(FnTag)\n     }\n \n     pub fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ConstTag(ConstDoc) => Some(ConstDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ConstTag)\n     }\n \n     pub fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              EnumTag(EnumDoc) => Some(EnumDoc),\n-              _ => None\n-            }\n-        }\n+        md!(EnumTag)\n     }\n \n     pub fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              TraitTag(TraitDoc) => Some(TraitDoc),\n-              _ => None\n-            }\n-        }\n+        md!(TraitTag)\n     }\n \n     pub fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              ImplTag(ImplDoc) => Some(ImplDoc),\n-              _ => None\n-            }\n-        }\n+        md!(ImplTag)\n     }\n \n     pub fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-              TyTag(TyDoc) => Some(TyDoc),\n-              _ => None\n-            }\n-        }\n+        md!(TyTag)\n     }\n \n     pub fn structs(&self) -> ~[StructDoc] {\n-        do vec::filter_mapped(self.items) |itemtag| {\n-            match copy *itemtag {\n-                StructTag(StructDoc) => Some(StructDoc),\n-                _ => None\n-            }\n-        }\n+        md!(StructTag)\n+    }\n+}\n+\n+macro_rules! pu {\n+    ($id:ident) => {\n+        filt_mapper!(*self, ItemPage($id(ref x)))\n     }\n }\n \n@@ -284,75 +259,35 @@ pub trait PageUtils {\n impl PageUtils for ~[Page] {\n \n     fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ModTag(ModDoc)) => Some(ModDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ModTag)\n     }\n \n     fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(NmodTag(nModDoc)) => Some(nModDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(NmodTag)\n     }\n \n     fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(FnTag(FnDoc)) => Some(FnDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(FnTag)\n     }\n \n     fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ConstTag(ConstDoc)) => Some(ConstDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ConstTag)\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(EnumTag(EnumDoc)) => Some(EnumDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(EnumTag)\n     }\n \n     fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(TraitTag(TraitDoc)) => Some(TraitDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(TraitTag)\n     }\n \n     fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(ImplTag(ImplDoc)) => Some(ImplDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(ImplTag)\n     }\n \n     fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_mapped(*self) |page| {\n-            match copy *page {\n-              ItemPage(TyTag(TyDoc)) => Some(TyDoc),\n-              _ => None\n-            }\n-        }\n+        pu!(TyTag)\n     }\n }\n "}, {"sha": "01b77a985fedb249a28d456f01dfe3a02ff6557f", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -15,7 +15,6 @@ use astsrv;\n use doc::ItemUtils;\n use doc;\n \n-use std::vec;\n use syntax::ast;\n use syntax::parse::token::{ident_interner, ident_to_str};\n use syntax::parse::token;\n@@ -83,7 +82,7 @@ fn moddoc_from_mod(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: itemdoc,\n-        items: do vec::filter_mapped(module_.items) |item| {\n+        items: do module_.items.iter().filter_map |item| {\n             let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n             match copy item.node {\n               ast::item_mod(m) => {\n@@ -133,7 +132,7 @@ fn moddoc_from_mod(\n               }\n               _ => None\n             }\n-        },\n+        }.collect(),\n         index: None\n     }\n }"}, {"sha": "83a0d44978ec49c96b84dc3596edbcdb61686cae", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -128,13 +128,12 @@ fn fold_mod(\n \n fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n     doc::ModDoc {\n-        items: do doc.items.filtered |item| {\n-            match *item {\n-              doc::ModTag(_) => false,\n-              doc::NmodTag(_) => false,\n+        items: do doc.items.iter().filter |item| {\n+            match **item {\n+              doc::ModTag(_) | doc::NmodTag(_) => false,\n               _ => true\n             }\n-        },\n+        }.transform(|x| copy *x).collect::<~[doc::ItemTag]>(),\n         .. copy doc\n     }\n }"}, {"sha": "96c5df10680cc51ca8f214d68ec6f92f84f64056", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -41,9 +41,9 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     doc::ModDoc {\n-        items: do doc.items.filtered |ItemTag| {\n-            !is_hidden(fold.ctxt.clone(), ItemTag.item())\n-        },\n+        items: do doc.items.iter().filter |item_tag| {\n+            !is_hidden(fold.ctxt.clone(), item_tag.item())\n+        }.transform(|x| copy *x).collect(),\n         .. doc\n     }\n }"}, {"sha": "aeb6e02f244f175055f9f9516d4e1006bfcbc853", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -80,7 +80,7 @@ fn strip_priv_methods(\n     methods: &[@ast::method],\n     item_vis: ast::visibility\n ) -> doc::ImplDoc {\n-    let methods = do (&doc.methods).filtered |method| {\n+    let methods = do doc.methods.iter().filter |method| {\n         let ast_method = do methods.iter().find_ |m| {\n             extract::to_str(m.ident) == method.name\n         };\n@@ -91,7 +91,7 @@ fn strip_priv_methods(\n             ast::private => false,\n             ast::inherited => item_vis == ast::public\n         }\n-    };\n+    }.transform(|x| copy *x).collect();\n \n     doc::ImplDoc {\n         methods: methods,\n@@ -106,9 +106,9 @@ fn fold_mod(\n     let doc = fold::default_any_fold_mod(fold, doc);\n \n     doc::ModDoc {\n-        items: doc.items.filtered(|ItemTag| {\n-            match ItemTag {\n-                &doc::ImplTag(ref doc) => {\n+        items: doc.items.iter().filter(|item_tag| {\n+            match item_tag {\n+                & &doc::ImplTag(ref doc) => {\n                     if doc.trait_types.is_empty() {\n                         // This is an associated impl. We have already pruned the\n                         // non-visible methods. If there are any left then\n@@ -123,10 +123,10 @@ fn fold_mod(\n                     }\n                 }\n                 _ => {\n-                    is_visible(fold.ctxt.clone(), ItemTag.item())\n+                    is_visible(fold.ctxt.clone(), item_tag.item())\n                 }\n             }\n-        }),\n+        }).transform(|x| copy *x).collect(),\n         .. doc\n     }\n }"}, {"sha": "1e99a3fa4bcda2f68ae593a4607d55f18696ef93", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -77,9 +77,9 @@ fn fold_mod(_ctx: @mut ReadyCtx,\n             fold: @fold::ast_fold) -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n-            attrs: do item.attrs.filtered |attr| {\n-                \"main\" != attr::get_attr_name(attr)\n-            },\n+            attrs: do item.attrs.iter().filter_map |attr| {\n+                if \"main\" != attr::get_attr_name(attr) {Some(*attr)} else {None}\n+            }.collect(),\n             .. copy *item\n         }\n     }"}, {"sha": "5876dbdc9dea13823124cef251901c6857375a72", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -34,6 +34,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n }\n \n pub fn pkg_parent_workspaces(pkgid: &PkgId) -> ~[Path] {\n-    rust_path().filtered(|ws|\n-        workspace_contains_package_id(pkgid, ws))\n+    rust_path().consume_iter()\n+        .filter(|ws| workspace_contains_package_id(pkgid, ws))\n+        .collect()\n }"}, {"sha": "c994bbf6fa49f096def3ab3a67473725d4533d97", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -777,9 +777,9 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 strings\n             }\n         }\n-        do get_list(p).filtered |filename| {\n-            *filename != ~\".\" && *filename != ~\"..\"\n-        }\n+        do get_list(p).consume_iter().filter |filename| {\n+            \".\" != *filename && \"..\" != *filename\n+        }.collect()\n     }\n }\n "}, {"sha": "5d4943c49d9c3e00b5c383eb248f69f79d491bca", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -309,77 +309,6 @@ pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     result\n }\n \n-pub fn filter_map<T, U>(\n-    v: ~[T],\n-    f: &fn(t: T) -> Option<U>) -> ~[U]\n-{\n-    /*!\n-     *\n-     * Apply a function to each element of a vector and return the results.\n-     * Consumes the input vector.  If function `f` returns `None` then that\n-     * element is excluded from the resulting vector.\n-     */\n-\n-    let mut result = ~[];\n-    for v.consume_iter().advance |elem| {\n-        match f(elem) {\n-            None => {}\n-            Some(result_elem) => { result.push(result_elem); }\n-        }\n-    }\n-    result\n-}\n-\n-pub fn filter_mapped<T, U: Copy>(\n-    v: &[T],\n-    f: &fn(t: &T) -> Option<U>) -> ~[U]\n-{\n-    /*!\n-     *\n-     * Like `filter_map()`, but operates on a borrowed slice\n-     * and does not consume the input.\n-     */\n-\n-    let mut result = ~[];\n-    for v.iter().advance |elem| {\n-        match f(elem) {\n-          None => {/* no-op */ }\n-          Some(result_elem) => { result.push(result_elem); }\n-        }\n-    }\n-    result\n-}\n-\n-/**\n- * Construct a new vector from the elements of a vector for which some\n- * predicate holds.\n- *\n- * Apply function `f` to each element of `v` and return a vector containing\n- * only those elements for which `f` returned true.\n- */\n-pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n-    let mut result = ~[];\n-    for v.consume_iter().advance |elem| {\n-        if f(&elem) { result.push(elem); }\n-    }\n-    result\n-}\n-\n-/**\n- * Construct a new vector from the elements of a vector for which some\n- * predicate holds.\n- *\n- * Apply function `f` to each element of `v` and return a vector containing\n- * only those elements for which `f` returned true.\n- */\n-pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n-    let mut result = ~[];\n-    for v.iter().advance |elem| {\n-        if f(elem) { result.push(copy *elem); }\n-    }\n-    result\n-}\n-\n /// Flattens a vector of vectors of T into a single vector of T.\n pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] { v.concat_vec() }\n \n@@ -866,7 +795,6 @@ pub trait ImmutableVector<'self, T> {\n     fn last_opt(&self) -> Option<&'self T>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n \n     fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n@@ -976,17 +904,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n-    /**\n-     * Apply a function to each element of a vector and return the results\n-     *\n-     * If function `f` returns `none` then that element is excluded from\n-     * the resulting vector.\n-     */\n-    #[inline]\n-    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n-        filter_mapped(*self, f)\n-    }\n-\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[inline]\n@@ -1077,25 +994,12 @@ impl<'self, T: TotalOrd> ImmutableTotalOrdVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait ImmutableCopyableVector<T> {\n-    fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n }\n \n /// Extension methods for vectors\n impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n-    /**\n-     * Construct a new vector from the elements of a vector for which some\n-     * predicate holds.\n-     *\n-     * Apply function `f` to each element of `v` and return a vector\n-     * containing only those elements for which `f` returned true.\n-     */\n-    #[inline]\n-    fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n-        filtered(*self, f)\n-    }\n-\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -1144,7 +1048,6 @@ pub trait OwnedVector<T> {\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n     fn retain(&mut self, f: &fn(t: &T) -> bool);\n-    fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n     fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T);\n }\n@@ -1482,11 +1385,6 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n-    #[inline]\n-    fn filter(self, f: &fn(&T) -> bool) -> ~[T] {\n-        filter(self, f)\n-    }\n-\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n@@ -2616,87 +2514,6 @@ mod tests {\n         assert_eq!(w[4], 25u);\n     }\n \n-    #[test]\n-    fn test_filter_mapped() {\n-        // Test on-stack filter-map.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut w = filter_mapped(v, square_if_odd_r);\n-        assert_eq!(w.len(), 2u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-\n-        // Test on-heap filter-map.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = filter_mapped(v, square_if_odd_r);\n-        assert_eq!(w.len(), 3u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-        assert_eq!(w[2], 25u);\n-\n-        fn halve(i: &int) -> Option<int> {\n-            if *i % 2 == 0 {\n-                Some::<int>(*i / 2)\n-            } else {\n-                None::<int>\n-            }\n-        }\n-        fn halve_for_sure(i: &int) -> int { *i / 2 }\n-        let all_even: ~[int] = ~[0, 2, 8, 6];\n-        let all_odd1: ~[int] = ~[1, 7, 3];\n-        let all_odd2: ~[int] = ~[];\n-        let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n-        let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert!(filter_mapped(all_even, halve) ==\n-                     all_even.map(halve_for_sure));\n-        assert_eq!(filter_mapped(all_odd1, halve), ~[]);\n-        assert_eq!(filter_mapped(all_odd2, halve), ~[]);\n-        assert_eq!(filter_mapped(mix, halve), mix_dest);\n-    }\n-\n-    #[test]\n-    fn test_filter_map() {\n-        // Test on-stack filter-map.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut w = filter_map(v, square_if_odd_v);\n-        assert_eq!(w.len(), 2u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-\n-        // Test on-heap filter-map.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = filter_map(v, square_if_odd_v);\n-        assert_eq!(w.len(), 3u);\n-        assert_eq!(w[0], 1u);\n-        assert_eq!(w[1], 9u);\n-        assert_eq!(w[2], 25u);\n-\n-        fn halve(i: int) -> Option<int> {\n-            if i % 2 == 0 {\n-                Some::<int>(i / 2)\n-            } else {\n-                None::<int>\n-            }\n-        }\n-        fn halve_for_sure(i: &int) -> int { *i / 2 }\n-        let all_even: ~[int] = ~[0, 2, 8, 6];\n-        let all_even0: ~[int] = copy all_even;\n-        let all_odd1: ~[int] = ~[1, 7, 3];\n-        let all_odd2: ~[int] = ~[];\n-        let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n-        let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert!(filter_map(all_even, halve) ==\n-                     all_even0.map(halve_for_sure));\n-        assert_eq!(filter_map(all_odd1, halve), ~[]);\n-        assert_eq!(filter_map(all_odd2, halve), ~[]);\n-        assert_eq!(filter_map(mix, halve), mix_dest);\n-    }\n-\n-    #[test]\n-    fn test_filter() {\n-        assert_eq!(filter(~[1u, 2u, 3u], is_odd), ~[1u, 3u]);\n-        assert_eq!(filter(~[1u, 2u, 4u, 8u, 16u], is_three), ~[]);\n-    }\n-\n     #[test]\n     fn test_retain() {\n         let mut v = ~[1, 2, 3, 4, 5];\n@@ -3227,38 +3044,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_filter_mapped_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do filter_mapped(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            Some((~0, @0))\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_filter_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do v.filtered |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]"}, {"sha": "ce8e24fd4445a912b24337e0bd6fb902dff6bead", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -238,12 +238,12 @@ pub fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n }\n \n pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n-    do ms.filtered |m| {\n+    do ms.consume_iter().filter |m| {\n         match m.vis {\n             public => true,\n             _   => false\n         }\n-    }\n+    }.collect()\n }\n \n // extract a ty_method from a trait_method. if the trait_method is"}, {"sha": "d04d96b2481d62127ba28f9b2323d7a2e9fbef29", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -143,13 +143,13 @@ pub fn get_name_value_str_pair(item: @ast::meta_item)\n /// Search a list of attributes and return only those with a specific name\n pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n-    do vec::filter_mapped(attrs) |a| {\n+    do attrs.iter().filter_map |a| {\n         if name == get_attr_name(a) {\n             Some(*a)\n         } else {\n             None\n         }\n-    }\n+    }.collect()\n }\n \n /// Search a list of meta items and return only those with a specific name\n@@ -277,14 +277,7 @@ pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n \n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n-\n-    return vec::filter_mapped(items, |item| {\n-        if name != get_meta_item_name(*item) {\n-            Some(*item)\n-        } else {\n-            None\n-        }\n-    });\n+    items.consume_iter().filter(|item| name != get_meta_item_name(*item)).collect()\n }\n \n /**"}, {"sha": "96d7685353b2d7cb551a2203b585bfc350cd40df", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -14,8 +14,6 @@ use codemap::{span, spanned};\n use parse::token;\n use opt_vec::OptVec;\n \n-use std::vec;\n-\n pub trait ast_fold {\n     fn fold_crate(@self, &crate) -> crate;\n     fn fold_view_item(@self, @view_item) -> @view_item;\n@@ -700,7 +698,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n         view_items: m.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n-        items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n+        items: m.items.iter().filter_map(|x| fld.fold_item(*x)).collect(),\n     }\n }\n "}, {"sha": "e7e01a40487214b4257a13326ca8f50fb7267888", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0d696561a381e182c792acbe8f608c8be94c3b/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=de0d696561a381e182c792acbe8f608c8be94c3b", "patch": "@@ -30,7 +30,7 @@ use std::io::WriterUtil;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use std::vec::{filter, from_elem};   //~ ERROR unused import\n+use std::vec::{from_fn, from_elem};   //~ ERROR unused import\n \n mod foo {\n     pub struct Point{x: int, y: int}"}]}