{"sha": "9f06c3d87f5a40078319e60ebe91bba279bf3f76", "node_id": "C_kwDOAAsO6NoAKDlmMDZjM2Q4N2Y1YTQwMDc4MzE5ZTYwZWJlOTFiYmEyNzliZjNmNzY", "commit": {"author": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-01-28T16:41:14Z"}, "committer": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-02-14T15:31:45Z"}, "message": "Port SuggestRemoveSemiOrReturnBinding", "tree": {"sha": "3e9d72c9ee8e11d365b9bf658fd9bbdd61e54a5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e9d72c9ee8e11d365b9bf658fd9bbdd61e54a5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f06c3d87f5a40078319e60ebe91bba279bf3f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f06c3d87f5a40078319e60ebe91bba279bf3f76", "html_url": "https://github.com/rust-lang/rust/commit/9f06c3d87f5a40078319e60ebe91bba279bf3f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f06c3d87f5a40078319e60ebe91bba279bf3f76/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fa4c7d89c48146af0b246c7640ad3a611412a23", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa4c7d89c48146af0b246c7640ad3a611412a23", "html_url": "https://github.com/rust-lang/rust/commit/6fa4c7d89c48146af0b246c7640ad3a611412a23"}], "stats": {"total": 143, "additions": 97, "deletions": 46}, "files": [{"sha": "1019b6114641c183965b283822e9979ebbdb97b4", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f06c3d87f5a40078319e60ebe91bba279bf3f76/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9f06c3d87f5a40078319e60ebe91bba279bf3f76/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=9f06c3d87f5a40078319e60ebe91bba279bf3f76", "patch": "@@ -330,3 +330,8 @@ infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by t\n \n infer_where_remove = remove the `where` clause\n infer_where_copy_predicates = copy the `where` clause predicates from the trait\n+\n+infer_srs_remove_and_box = consider removing this semicolon and boxing the expressions\n+infer_srs_remove = consider removing this semicolon\n+infer_srs_add = consider returning the local binding `{$ident}`\n+infer_srs_add_one = consider returning one of these bindings"}, {"sha": "41691ff4f72bceefc2ef86074bc23aee959da104", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9f06c3d87f5a40078319e60ebe91bba279bf3f76/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f06c3d87f5a40078319e60ebe91bba279bf3f76/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=9f06c3d87f5a40078319e60ebe91bba279bf3f76", "patch": "@@ -1006,3 +1006,47 @@ pub enum WhereClauseSuggestions {\n         trait_predicates: String,\n     },\n }\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestRemoveSemiOrReturnBinding {\n+    #[multipart_suggestion(infer_srs_remove_and_box, applicability = \"machine-applicable\")]\n+    RemoveAndBox {\n+        #[suggestion_part(code = \"Box::new(\")]\n+        first_lo: Span,\n+        #[suggestion_part(code = \")\")]\n+        first_hi: Span,\n+        #[suggestion_part(code = \"Box::new(\")]\n+        second_lo: Span,\n+        #[suggestion_part(code = \")\")]\n+        second_hi: Span,\n+        #[suggestion_part(code = \"\")]\n+        sp: Span,\n+    },\n+    #[suggestion(\n+        infer_srs_remove,\n+        style = \"short\",\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Remove {\n+        #[primary_span]\n+        sp: Span,\n+    },\n+    #[suggestion(\n+        infer_srs_add,\n+        style = \"verbose\",\n+        code = \"{code}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Add {\n+        #[primary_span]\n+        sp: Span,\n+        code: String,\n+        ident: Ident,\n+    },\n+    #[note(infer_srs_add_one)]\n+    AddOne {\n+        #[primary_span]\n+        spans: MultiSpan,\n+    },\n+}"}, {"sha": "ae231b1188d3c203001f37124eb72a64b7555ebf", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f06c3d87f5a40078319e60ebe91bba279bf3f76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f06c3d87f5a40078319e60ebe91bba279bf3f76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9f06c3d87f5a40078319e60ebe91bba279bf3f76", "patch": "@@ -750,15 +750,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer, msg);\n-                    self.suggest_remove_semi_or_return_binding(\n-                        err,\n+                    if let Some(subdiag) = self.suggest_remove_semi_or_return_binding(\n                         prior_arm_block_id,\n                         prior_arm_ty,\n                         prior_arm_span,\n                         arm_block_id,\n                         arm_ty,\n                         arm_span,\n-                    );\n+                    ) {\n+                        err.subdiagnostic(subdiag);\n+                    }\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n                         self.suggest_boxing_for_return_impl_trait(\n@@ -783,15 +784,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                self.suggest_remove_semi_or_return_binding(\n-                    err,\n+                if let Some(subdiag) = self.suggest_remove_semi_or_return_binding(\n                     Some(then_id),\n                     then_ty,\n                     then_span,\n                     Some(else_id),\n                     else_ty,\n                     else_span,\n-                );\n+                ) {\n+                    err.subdiagnostic(subdiag);\n+                }\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,"}, {"sha": "8d84264ee8c0dfe9b139ed3eec206a9bd2140a8c", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9f06c3d87f5a40078319e60ebe91bba279bf3f76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f06c3d87f5a40078319e60ebe91bba279bf3f76/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=9f06c3d87f5a40078319e60ebe91bba279bf3f76", "patch": "@@ -11,21 +11,20 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitable};\n use rustc_span::{sym, BytePos, Span};\n \n-use crate::errors::SuggAddLetForLetChains;\n+use crate::errors::{SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding};\n \n use super::TypeErrCtxt;\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     pub(super) fn suggest_remove_semi_or_return_binding(\n         &self,\n-        err: &mut Diagnostic,\n         first_id: Option<hir::HirId>,\n         first_ty: Ty<'tcx>,\n         first_span: Span,\n         second_id: Option<hir::HirId>,\n         second_ty: Ty<'tcx>,\n         second_span: Span,\n-    ) {\n+    ) -> Option<SuggestRemoveSemiOrReturnBinding> {\n         let remove_semicolon = [\n             (first_id, self.resolve_vars_if_possible(second_ty)),\n             (second_id, self.resolve_vars_if_possible(first_ty)),\n@@ -37,35 +36,29 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         });\n         match remove_semicolon {\n             Some((sp, StatementAsExpression::NeedsBoxing)) => {\n-                err.multipart_suggestion(\n-                    \"consider removing this semicolon and boxing the expressions\",\n-                    vec![\n-                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (first_span.shrink_to_hi(), \")\".to_string()),\n-                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (second_span.shrink_to_hi(), \")\".to_string()),\n-                        (sp, String::new()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n+                Some(SuggestRemoveSemiOrReturnBinding::RemoveAndBox {\n+                    first_lo: first_span.shrink_to_lo(),\n+                    first_hi: first_span.shrink_to_hi(),\n+                    second_lo: second_span.shrink_to_lo(),\n+                    second_hi: second_span.shrink_to_hi(),\n+                    sp,\n+                })\n             }\n             Some((sp, StatementAsExpression::CorrectType)) => {\n-                err.span_suggestion_short(\n-                    sp,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                Some(SuggestRemoveSemiOrReturnBinding::Remove { sp })\n             }\n             None => {\n+                let mut ret = None;\n                 for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n                     if let Some(id) = id\n                         && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n-                        && self.consider_returning_binding(blk, ty, err)\n+                        && let Some(diag) = self.consider_returning_binding_diag(blk, ty)\n                     {\n+                        ret = Some(diag);\n                         break;\n                     }\n                 }\n+                ret\n             }\n         }\n     }\n@@ -655,16 +648,15 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n \n     /// Suggest returning a local binding with a compatible type if the block\n     /// has no return expression.\n-    pub fn consider_returning_binding(\n+    pub fn consider_returning_binding_diag(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n+    ) -> Option<SuggestRemoveSemiOrReturnBinding> {\n         let blk = blk.innermost_block();\n         // Do not suggest if we have a tail expr.\n         if blk.expr.is_some() {\n-            return false;\n+            return None;\n         }\n         let mut shadowed = FxIndexSet::default();\n         let mut candidate_idents = vec![];\n@@ -733,7 +725,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         match &candidate_idents[..] {\n             [(ident, _ty)] => {\n                 let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n+                let (span, sugg) = if let Some(stmt) = blk.stmts.last() {\n                     let stmt_span = sm.stmt_span(stmt.span, blk.span);\n                     let sugg = if sm.is_multiline(blk.span)\n                         && let Some(spacing) = sm.indentation_before(stmt_span)\n@@ -742,12 +734,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     } else {\n                         format!(\" {ident}\")\n                     };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    (stmt_span.shrink_to_hi(), sugg)\n                 } else {\n                     let sugg = if sm.is_multiline(blk.span)\n                         && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n@@ -757,21 +744,34 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         format!(\" {ident} \")\n                     };\n                     let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n+                    (\n                         sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n                         sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                true\n+                    )\n+                };\n+                Some(SuggestRemoveSemiOrReturnBinding::Add { sp: span, code: sugg, ident: *ident })\n             }\n             values if (1..3).contains(&values.len()) => {\n                 let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n+                Some(SuggestRemoveSemiOrReturnBinding::AddOne { spans: spans.into() })\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let diag = self.consider_returning_binding_diag(blk, expected_ty);\n+        match diag {\n+            Some(diag) => {\n+                err.subdiagnostic(diag);\n                 true\n             }\n-            _ => false,\n+            None => false,\n         }\n     }\n }"}]}