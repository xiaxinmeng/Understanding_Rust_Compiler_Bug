{"sha": "10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYWY2YTJiMzdiZjUyZTAyM2I4OTJkYzI2MjJjMTllMzJmNmViZjU=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-09T17:34:39Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-23T11:32:18Z"}, "message": "Refactor explain_borrow to return explanation.\n\nPreviously, explain_borrow would emit an error with the explanation of\nthe a borrow. Now, it returns a enum with what the explanation for the\nborrow is and any relevant spans or information such that the calling\ncode can choose to emit the same note/suggestion as before by calling\nthe emit method on the new enum.", "tree": {"sha": "1c847651872c41dd4ade2c2aa5107afc446ff995", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c847651872c41dd4ade2c2aa5107afc446ff995"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlunecIACgkQAXYLT59T\n8VT40hAAhxshK7SKOZFDtj6DvHUxaT1LWVnsUIsd5g7HoZTX7jLn9unv+4ufs5Xo\naJkEtmnYbJjjXCZx5t/9CHwMU5AemQdgRYZNhhIWQPBj9dd/ssxQJKD1ff4KHnlH\n6gH4gasgo9PFnWhJu7KgDtEGnsWzaYhDmtwt3xoiQ2uV/64rLLy8MpAbejD+HGK+\nIMvORMLtj36GJg3HB2s7N72fbEVXbJ/MRlHlM40kR8IDG5COOAe44H56IZbNlQ2a\nCLQdMN1lXCmOlW8SrL1JYP9CJqP20hkDzUt0vOhLRbS4m9/9Km1kEeO0qrMNdfZs\nIR/6RaPmVxCH8a4VqF8itKqYESaEwFSROQXhrTnRxbcceFDJEjK516O800OYdQsa\na+qOhMrBrf8s+17AFCm8p0JqCQuZ8QGwbR18NjY63ljFz0qzfZ3XwLkOpOeWlHuR\nOENFvrgUtEg7qGyYO0o37swWEzgtGWIXUJ950xkXDt3hVZxDV5qyjNhh97IJ3t6T\ndOaHqnWA//9hxd2mD564W+LJSUpYY2IVz+TNIq/yXphv/NF+4+2onoZ9LHUFApAM\nk1kRH7flUPF05KvPy54cuX0o661bSLYXGpPiIFgBnbEYiYICyEEQeNxgaoc1h+ez\nM38cGV3ezeRcXlmYuxDNU7DVZT15IAh9AU+KGmRwHYqZRmhy1ho=\n=O/t8\n-----END PGP SIGNATURE-----", "payload": "tree 1c847651872c41dd4ade2c2aa5107afc446ff995\nparent 317ae05a7e4ee5324cc006eda877eb8f2eb57898\nauthor David Wood <david@davidtw.co> 1536514479 +0200\ncommitter David Wood <david@davidtw.co> 1537702338 +0200\n\nRefactor explain_borrow to return explanation.\n\nPreviously, explain_borrow would emit an error with the explanation of\nthe a borrow. Now, it returns a enum with what the explanation for the\nborrow is and any relevant spans or information such that the calling\ncode can choose to emit the same note/suggestion as before by calling\nthe emit method on the new enum.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "html_url": "https://github.com/rust-lang/rust/commit/10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10af6a2b37bf52e023b892dc2622c19e32f6ebf5/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "317ae05a7e4ee5324cc006eda877eb8f2eb57898", "url": "https://api.github.com/repos/rust-lang/rust/commits/317ae05a7e4ee5324cc006eda877eb8f2eb57898", "html_url": "https://github.com/rust-lang/rust/commit/317ae05a7e4ee5324cc006eda877eb8f2eb57898"}], "stats": {"total": 302, "additions": 140, "deletions": 162}, "files": [{"sha": "c5d86f9743e7acf05d0eceeb88ee1da4db6c7c31", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/10af6a2b37bf52e023b892dc2622c19e32f6ebf5/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10af6a2b37bf52e023b892dc2622c19e32f6ebf5/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "patch": "@@ -10,11 +10,14 @@\n \n use borrow_check::{WriteKind, StorageDeadOrDrop};\n use borrow_check::prefixes::IsPrefixOf;\n+use borrow_check::nll::explain_borrow::BorrowExplanation;\n use rustc::middle::region::ScopeTree;\n-use rustc::mir::VarBindingForm;\n-use rustc::mir::{BindingForm, BorrowKind, ClearCrossCrate, Field, Local};\n-use rustc::mir::{FakeReadCause, LocalDecl, LocalKind, Location, Operand, Place};\n-use rustc::mir::{ProjectionElem, Rvalue, Statement, StatementKind};\n+use rustc::mir::{\n+    BindingForm, BorrowKind, ClearCrossCrate, Field, FakeReadCause, Local,\n+    LocalDecl, LocalKind, Location, Operand, Place,\n+    ProjectionElem, Rvalue, Statement, StatementKind,\n+    VarBindingForm,\n+};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n@@ -25,7 +28,6 @@ use super::borrow_set::BorrowData;\n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n \n-use borrow_check::nll::explain_borrow::BorrowContainsPointReason;\n use dataflow::drop_flag_effects;\n use dataflow::move_paths::indexes::MoveOutIndex;\n use dataflow::move_paths::MovePathIndex;\n@@ -226,7 +228,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         move_spans.var_span_label(&mut err, \"move occurs due to use in closure\");\n \n-        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None).emit(self.tcx, &mut err);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -263,7 +265,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"borrow occurs due to use of `{}` in closure\", desc_place)\n         });\n \n-        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None).emit(self.tcx, &mut err);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -390,7 +392,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n         }\n \n-        self.explain_why_borrow_contains_point(context, issued_borrow, None, &mut err);\n+        self.explain_why_borrow_contains_point(context, issued_borrow, None)\n+            .emit(self.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -445,17 +448,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.access_place_error_reported\n             .insert((root_place.clone(), borrow_span));\n \n-        let borrow_reason = self.find_why_borrow_contains_point(context, borrow);\n-\n-        if let Some(WriteKind::StorageDeadOrDrop(StorageDeadOrDrop::Destructor)) = kind\n-        {\n+        if let Some(WriteKind::StorageDeadOrDrop(StorageDeadOrDrop::Destructor)) = kind {\n             // If a borrow of path `B` conflicts with drop of `D` (and\n             // we're not in the uninteresting case where `B` is a\n             // prefix of `D`), then report this as a more interesting\n             // destructor conflict.\n             if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n-                self.report_borrow_conflicts_with_destructor(\n-                    context, borrow, borrow_reason, place_span, kind);\n+                self.report_borrow_conflicts_with_destructor(context, borrow, place_span, kind);\n                 return;\n             }\n         }\n@@ -469,7 +468,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 name,\n                 &scope_tree,\n                 &borrow,\n-                borrow_reason,\n                 drop_span,\n                 borrow_span,\n                 kind.map(|k| (k, place_span.0)),\n@@ -478,7 +476,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 context,\n                 &scope_tree,\n                 &borrow,\n-                borrow_reason,\n                 drop_span,\n                 proper_span,\n             ),\n@@ -495,16 +492,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         name: &String,\n         scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n-        reason: BorrowContainsPointReason<'tcx>,\n         drop_span: Span,\n         borrow_span: Span,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, name, scope_tree, borrow, reason, drop_span, borrow_span\n+            context, name, scope_tree, borrow, drop_span, borrow_span\n         );\n \n         let mut err = self.tcx.path_does_not_live_long_enough(\n@@ -519,34 +515,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"`{}` dropped here while still borrowed\", name),\n         );\n \n-        self.report_why_borrow_contains_point(&mut err, reason, kind_place);\n+        self.explain_why_borrow_contains_point(context, borrow, kind_place)\n+            .emit(self.tcx, &mut err);\n+\n         err\n     }\n \n     pub(super) fn report_borrow_conflicts_with_destructor(\n         &mut self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n-        borrow_reason: BorrowContainsPointReason<'tcx>,\n-        place_span: (&Place<'tcx>, Span),\n+        (place, drop_span): (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n         debug!(\n             \"report_borrow_conflicts_with_destructor(\\\n-             {:?}, {:?}, {:?}, {:?} {:?}\\\n+             {:?}, {:?}, ({:?}, {:?}), {:?}\\\n              )\",\n-            context, borrow, borrow_reason, place_span, kind,\n+            context, borrow, place, drop_span, kind,\n         );\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n         let mut err = self.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n \n-        let drop_span = place_span.1;\n-\n         let (what_was_dropped, dropped_ty) = {\n-            let place = place_span.0;\n             let desc = match self.describe_place(place) {\n                 Some(name) => format!(\"`{}`\", name.as_str()),\n                 None => format!(\"temporary value\"),\n@@ -571,17 +565,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         };\n         err.span_label(drop_span, label);\n \n-        // Only give this note and suggestion if they could be relevant\n-        match borrow_reason {\n-            BorrowContainsPointReason::Liveness {..}\n-            | BorrowContainsPointReason::DropLiveness {..} => {\n+        // Only give this note and suggestion if they could be relevant.\n+        let explanation = self.explain_why_borrow_contains_point(\n+            context, borrow, kind.map(|k| (k, place)),\n+        );\n+        match explanation {\n+            BorrowExplanation::UsedLater {..} |\n+            BorrowExplanation::UsedLaterWhenDropped {..} => {\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n-            }\n-            BorrowContainsPointReason::OutlivesFreeRegion {..} => (),\n+            },\n+            _ => {},\n         }\n \n-        self.report_why_borrow_contains_point(\n-            &mut err, borrow_reason, kind.map(|k| (k, place_span.0)));\n+        explanation.emit(self.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -607,6 +603,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"thread-local variables cannot be borrowed beyond the end of the function\",\n         );\n         err.span_label(drop_span, \"end of enclosing function is here\");\n+\n         err\n     }\n \n@@ -615,15 +612,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         scope_tree: &Lrc<ScopeTree>,\n         borrow: &BorrowData<'tcx>,\n-        reason: BorrowContainsPointReason<'tcx>,\n         drop_span: Span,\n         proper_span: Span,\n     ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_temporary_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n+             {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, scope_tree, borrow, reason, drop_span, proper_span\n+            context, scope_tree, borrow, drop_span, proper_span\n         );\n \n         let tcx = self.tcx;\n@@ -632,16 +628,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n-        // Only give this note and suggestion if they could be relevant\n-        match reason {\n-            BorrowContainsPointReason::Liveness {..}\n-            | BorrowContainsPointReason::DropLiveness {..} => {\n+        let explanation = self.explain_why_borrow_contains_point(context, borrow, None);\n+        match explanation {\n+            BorrowExplanation::UsedLater(..) |\n+            BorrowExplanation::UsedLaterInLoop(..) |\n+            BorrowExplanation::UsedLaterWhenDropped(..) => {\n+                // Only give this note and suggestion if it could be relevant.\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n-            }\n-            BorrowContainsPointReason::OutlivesFreeRegion {..} => (),\n+            },\n+            _ => {},\n         }\n+        explanation.emit(self.tcx, &mut err);\n \n-        self.report_why_borrow_contains_point(&mut err, reason, None);\n         err\n     }\n \n@@ -749,7 +747,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n \n-        self.explain_why_borrow_contains_point(context, loan, None, &mut err);\n+        self.explain_why_borrow_contains_point(context, loan, None).emit(self.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }"}, {"sha": "d4adff7c443cbcd18eb2f123f260a2f27ed6a31f", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10af6a2b37bf52e023b892dc2622c19e32f6ebf5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10af6a2b37bf52e023b892dc2622c19e32f6ebf5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "patch": "@@ -121,9 +121,7 @@ struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n \n enum DefUseResult {\n     Def,\n-\n     UseLive { local: Local },\n-\n     UseDrop { local: Local },\n }\n "}, {"sha": "27fb06bdaecebd32eb2d559cd57744f083a46bba", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 96, "deletions": 114, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/10af6a2b37bf52e023b892dc2622c19e32f6ebf5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10af6a2b37bf52e023b892dc2622c19e32f6ebf5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=10af6a2b37bf52e023b892dc2622c19e32f6ebf5", "patch": "@@ -11,26 +11,71 @@\n use borrow_check::borrow_set::BorrowData;\n use borrow_check::nll::region_infer::Cause;\n use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n-use rustc::mir::{FakeReadCause, Local, Location, Place, TerminatorKind};\n+use rustc::ty::{Region, TyCtxt};\n+use rustc::mir::{FakeReadCause, Location, Place, TerminatorKind};\n use rustc_errors::DiagnosticBuilder;\n-use rustc::ty::Region;\n+use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n \n mod find_use;\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum BorrowContainsPointReason<'tcx> {\n-    Liveness {\n-        local: Local,\n-        location: Location,\n-        in_loop: bool,\n-    },\n-    DropLiveness {\n-        local: Local,\n-        location: Location,\n-    },\n-    OutlivesFreeRegion {\n-        outlived_region: Option<Region<'tcx>>,\n-    },\n+pub(in borrow_check) enum BorrowExplanation<'tcx> {\n+    UsedLater(bool, Option<FakeReadCause>, Span),\n+    UsedLaterInLoop(bool, Span),\n+    UsedLaterWhenDropped(Span, Symbol, bool),\n+    MustBeValidFor(Region<'tcx>),\n+    Unexplained,\n+}\n+\n+impl<'tcx> BorrowExplanation<'tcx> {\n+    pub(in borrow_check) fn emit<'cx, 'gcx>(\n+        &self,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        err: &mut DiagnosticBuilder<'_>\n+    ) {\n+        match *self {\n+            BorrowExplanation::UsedLater(is_in_closure, fake_read_cause, var_or_use_span) => {\n+                let message = if is_in_closure {\n+                    \"borrow later captured here by closure\"\n+                } else if let Some(FakeReadCause::ForLet) = fake_read_cause {\n+                    \"borrow later stored here\"\n+                } else {\n+                    \"borrow later used here\"\n+                };\n+                err.span_label(var_or_use_span, message);\n+            },\n+            BorrowExplanation::UsedLaterInLoop(is_in_closure, var_or_use_span) => {\n+                let message = if is_in_closure {\n+                    \"borrow captured here by closure in later iteration of loop\"\n+                } else {\n+                    \"borrow used here in later iteration of loop\"\n+                };\n+                err.span_label(var_or_use_span, message);\n+            },\n+            BorrowExplanation::UsedLaterWhenDropped(span, local_name, should_note_order) => {\n+                err.span_label(\n+                    span,\n+                    format!(\"borrow later used here, when `{}` is dropped\", local_name),\n+                );\n+\n+                if should_note_order {\n+                    err.note(\n+                        \"values in a scope are dropped \\\n+                         in the opposite order they are defined\",\n+                    );\n+                }\n+            },\n+            BorrowExplanation::MustBeValidFor(region) => {\n+                tcx.note_and_explain_free_region(\n+                    err,\n+                    \"borrowed value must be valid for \",\n+                    region,\n+                    \"...\",\n+                );\n+            },\n+            _ => {},\n+        }\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n@@ -53,23 +98,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n-        let reason = self.find_why_borrow_contains_point(context, borrow);\n-        self.report_why_borrow_contains_point(err, reason, kind_place);\n-    }\n-\n-    /// Finds the reason that [explain_why_borrow_contains_point] will report\n-    /// but doesn't add it to any message. This is a separate function in case\n-    /// the caller wants to change the error they report based on the reason\n-    /// that will be reported.\n-    pub(in borrow_check) fn find_why_borrow_contains_point(\n-        &self,\n-        context: Context,\n-        borrow: &BorrowData<'tcx>\n-    ) -> BorrowContainsPointReason<'tcx> {\n-        use self::BorrowContainsPointReason::*;\n-\n+    ) -> BorrowExplanation<'tcx> {\n         debug!(\n             \"find_why_borrow_contains_point(context={:?}, borrow={:?})\",\n             context, borrow,\n@@ -80,113 +109,67 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n \n         let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n-\n         debug!(\n             \"explain_why_borrow_contains_point: borrow_region_vid={:?}\",\n             borrow_region_vid\n         );\n \n         let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, context.loc);\n-\n         debug!(\n             \"explain_why_borrow_contains_point: region_sub={:?}\",\n             region_sub\n         );\n \n-        match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n-            Some(Cause::LiveVar(local, location)) => Liveness {\n-                local,\n-                location,\n-                in_loop: self.is_borrow_location_in_loop(context.loc),\n-            },\n-            Some(Cause::DropVar(local, location)) => DropLiveness {\n-                local,\n-                location,\n-            },\n-            None => OutlivesFreeRegion {\n-                outlived_region: regioncx.to_error_region(region_sub),\n-            },\n-        }\n-    }\n-\n-    /// Adds annotations to `err` for the explanation `reason`. This is a\n-    /// separate method so that the caller can change their error message based\n-    /// on the reason that is going to be reported.\n-    pub (in borrow_check) fn report_why_borrow_contains_point(\n-        &self,\n-        err: &mut DiagnosticBuilder,\n-        reason: BorrowContainsPointReason<'tcx>,\n-        kind_place: Option<(WriteKind, &Place<'tcx>)>,\n-    ) {\n-        use self::BorrowContainsPointReason::*;\n-\n-        debug!(\n-            \"find_why_borrow_contains_point(reason={:?}, kind_place={:?})\",\n-            reason, kind_place,\n-        );\n-\n-        let mir = self.mir;\n-\n-        match reason {\n-            Liveness { local, location, in_loop } => {\n+         match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n+            Some(Cause::LiveVar(local, location)) => {\n                 let span = mir.source_info(location).span;\n                 let spans = self.move_spans(&Place::Local(local), location)\n                     .or_else(|| self.borrow_spans(span, location));\n-                let message = if in_loop {\n-                    if spans.for_closure() {\n-                        \"borrow captured here by closure in later iteration of loop\"\n-                    } else {\n-                        \"borrow used here in later iteration of loop\"\n-                    }\n+\n+                if self.is_borrow_location_in_loop(context.loc) {\n+                    BorrowExplanation::UsedLaterInLoop(spans.for_closure(), spans.var_or_use())\n                 } else {\n-                    if spans.for_closure() {\n-                        \"borrow later captured here by closure\"\n-                    } else {\n-                        // Check if the location represents a `FakeRead`, and adapt the error\n-                        // message to the `FakeReadCause` it is from: in particular,\n-                        // the ones inserted in optimized `let var = <expr>` patterns.\n-                        match self.retrieve_fake_read_cause_for_location(&location) {\n-                            Some(FakeReadCause::ForLet) => \"borrow later stored here\",\n-                            _ => \"borrow later used here\"\n-                        }\n-                    }\n-                };\n-                err.span_label(spans.var_or_use(), message);\n+                    // Check if the location represents a `FakeRead`, and adapt the error\n+                    // message to the `FakeReadCause` it is from: in particular,\n+                    // the ones inserted in optimized `let var = <expr>` patterns.\n+                    BorrowExplanation::UsedLater(\n+                        spans.for_closure(),\n+                        self.retrieve_fake_read_cause_for_location(&location),\n+                        spans.var_or_use()\n+                    )\n+                }\n             }\n-            DropLiveness { local, location } => match &mir.local_decls[local].name {\n-                Some(local_name) => {\n-                    err.span_label(\n-                        mir.source_info(location).span,\n-                        format!(\"borrow later used here, when `{}` is dropped\", local_name),\n-                    );\n \n+            Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {\n+                Some(local_name) => {\n+                    let mut should_note_order = false;\n                     if let Some((WriteKind::StorageDeadOrDrop(_), place)) = kind_place {\n                         if let Place::Local(borrowed_local) = place {\n                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n                             let borrowed_local_scope =\n-                            mir.local_decls[*borrowed_local].visibility_scope;\n+                                mir.local_decls[*borrowed_local].visibility_scope;\n \n                             if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n-                                err.note(\n-                                \"values in a scope are dropped \\\n-                                                     in the opposite order they are defined\",\n-                                );\n+                                should_note_order = true;\n                             }\n                         }\n                     }\n-                }\n \n-                None => {}\n-            }\n-            OutlivesFreeRegion { outlived_region: Some(region) } => {\n-                self.tcx.note_and_explain_free_region(\n-                    err,\n-                    \"borrowed value must be valid for \",\n-                    region,\n-                    \"...\",\n-                );\n-            }\n-            OutlivesFreeRegion { outlived_region: None } => (),\n+                    BorrowExplanation::UsedLaterWhenDropped(\n+                        mir.source_info(location).span,\n+                        *local_name,\n+                        should_note_order\n+                    )\n+                },\n+\n+                None => BorrowExplanation::Unexplained,\n+            },\n+\n+            None => if let Some(region) = regioncx.to_error_region(region_sub) {\n+                BorrowExplanation::MustBeValidFor(region)\n+            } else {\n+                BorrowExplanation::Unexplained\n+            },\n         }\n     }\n \n@@ -262,4 +245,3 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         false\n     }\n }\n-"}]}