{"sha": "44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZTUyNmIyYzM4YzgxYzczMmRkM2U2NDBmM2NjMDZhY2M4ZjY5YmI=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-02-09T01:39:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-09T01:39:50Z"}, "message": "Rollup merge of #80732 - spastorino:trait-inheritance-self2, r=nikomatsakis\n\nAllow Trait inheritance with cycles on associated types take 2\n\nThis reverts the revert of #79209 and fixes the ICEs that's occasioned by that PR exposing some problems that are addressed in #80648 and #79811.\nFor easier review I'd say, check only the last commit, the first one is just a revert of the revert of #79209 which was already approved.\n\nThis also could be considered part or the actual fix of #79560 but I guess for that to be closed and fixed completely we would need to land #80648 and #79811 too.\n\nr? `@nikomatsakis`\ncc `@Aaron1011`", "tree": {"sha": "3c953a9ef9e6eb532224fe1c7107e1c642fff27b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c953a9ef9e6eb532224fe1c7107e1c642fff27b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgIefmCRBK7hj4Ov3rIwAAdHIIAAqam2So33g9zO1cDYTuUcax\n81QeB0BQMQRfkqAkveHbhAs3T0NfRp9OOVUIC69oexSeAPiKa9qIGGuzQw/vH6zP\n1wO0WqahNJTIc/eN/uz7LMXCXRwl9UOX5q37UPIPrQFjyTyrnfX5EJhNTGJZqSm2\nC+Q2MtKLfMA7l8VyKhnJA+70PgnIbdMFQKDpoxacIHmNHBE3HgNVxiXEiZ4w8cue\nelyuPnW0BcFdjm64vINERau3790pg45DNvrzSBy/3/T1z5SomGPGfN7RGpiPy1Si\nIAtupvtQydb9bIT5jk08bfBycY/0bKIbcWwWc7i057VT/1IOePXw3GPllSFKoOM=\n=eI63\n-----END PGP SIGNATURE-----\n", "payload": "tree 3c953a9ef9e6eb532224fe1c7107e1c642fff27b\nparent f8b330d9fb114132fb41eccdafbe29b48d386749\nparent 8d17c6a85d6530d446d1cb42ee6636c5c9fbfaaf\nauthor Dylan DPC <dylan.dpc@gmail.com> 1612834790 +0100\ncommitter GitHub <noreply@github.com> 1612834790 +0100\n\nRollup merge of #80732 - spastorino:trait-inheritance-self2, r=nikomatsakis\n\nAllow Trait inheritance with cycles on associated types take 2\n\nThis reverts the revert of #79209 and fixes the ICEs that's occasioned by that PR exposing some problems that are addressed in #80648 and #79811.\nFor easier review I'd say, check only the last commit, the first one is just a revert of the revert of #79209 which was already approved.\n\nThis also could be considered part or the actual fix of #79560 but I guess for that to be closed and fixed completely we would need to land #80648 and #79811 too.\n\nr? `@nikomatsakis`\ncc `@Aaron1011`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "html_url": "https://github.com/rust-lang/rust/commit/44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8b330d9fb114132fb41eccdafbe29b48d386749", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8b330d9fb114132fb41eccdafbe29b48d386749", "html_url": "https://github.com/rust-lang/rust/commit/f8b330d9fb114132fb41eccdafbe29b48d386749"}, {"sha": "8d17c6a85d6530d446d1cb42ee6636c5c9fbfaaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d17c6a85d6530d446d1cb42ee6636c5c9fbfaaf", "html_url": "https://github.com/rust-lang/rust/commit/8d17c6a85d6530d446d1cb42ee6636c5c9fbfaaf"}], "stats": {"total": 733, "additions": 582, "deletions": 151}, "files": [{"sha": "87684c2715f4ef0541b3793af691a26d51c2d66f", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -1,9 +1,10 @@\n use smallvec::smallvec;\n \n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::{self, ToPredicate, TyCtxt, WithConstness};\n+use rustc_span::symbol::Ident;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -282,6 +283,44 @@ pub fn transitive_bounds<'tcx>(\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n+/// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n+/// define the given associated type `assoc_name`. It uses the\n+/// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n+/// aren't related to `assoc_item`.  This is used when resolving types like `Self::Item` or\n+/// `T::Item` and helps to avoid cycle errors (see e.g. #35237).\n+pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+    assoc_name: Ident,\n+) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+    let mut stack: Vec<_> = bounds.collect();\n+    let mut visited = FxIndexSet::default();\n+\n+    std::iter::from_fn(move || {\n+        while let Some(trait_ref) = stack.pop() {\n+            let anon_trait_ref = tcx.anonymize_late_bound_regions(trait_ref);\n+            if visited.insert(anon_trait_ref) {\n+                let super_predicates = tcx.super_predicates_that_define_assoc_type((\n+                    trait_ref.def_id(),\n+                    Some(assoc_name),\n+                ));\n+                for (super_predicate, _) in super_predicates.predicates {\n+                    let bound_predicate = super_predicate.kind();\n+                    let subst_predicate = super_predicate\n+                        .subst_supertrait(tcx, &bound_predicate.rebind(trait_ref.skip_binder()));\n+                    if let Some(binder) = subst_predicate.to_opt_poly_trait_ref() {\n+                        stack.push(binder.value);\n+                    }\n+                }\n+\n+                return Some(trait_ref);\n+            }\n+        }\n+\n+        return None;\n+    })\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "a3040f498ce541fa1568c5d8b604a648c350b5e9", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -443,12 +443,23 @@ rustc_queries! {\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n     query super_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n-        desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"computing the super predicates of `{}`\", tcx.def_path_str(key) }\n+    }\n+\n+    /// The `Option<Ident>` is the name of an associated type. If it is `None`, then this query\n+    /// returns the full set of predicates. If `Some<Ident>`, then the query returns only the\n+    /// subset of super-predicates that reference traits that define the given associated type.\n+    /// This is used to avoid cycles in resolving types like `T::Item`.\n+    query super_predicates_that_define_assoc_type(key: (DefId, Option<rustc_span::symbol::Ident>)) -> ty::GenericPredicates<'tcx> {\n+        desc { |tcx| \"computing the super traits of `{}`{}\",\n+            tcx.def_path_str(key.0),\n+            if let Some(assoc_name) = key.1 { format!(\" with associated type name `{}`\", assoc_name) } else { \"\".to_string() },\n+        }\n     }\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    query type_param_predicates(key: (DefId, LocalDefId)) -> ty::GenericPredicates<'tcx> {\n+    query type_param_predicates(key: (DefId, LocalDefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n         desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n             let id = tcx.hir().local_def_id_to_hir_id(key.1);\n             tcx.hir().ty_param_name(id)"}, {"sha": "f83056ebe2a4573ce37e325e45ade172de9bfa8d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -52,7 +52,7 @@ use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Session;\n use rustc_span::source_map::MultiSpan;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n@@ -2053,6 +2053,42 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig { unsafety: hir::Unsafety::Unsafe, ..sig }))\n     }\n \n+    /// Given the def_id of a Trait `trait_def_id` and the name of an associated item `assoc_name`\n+    /// returns true if the `trait_def_id` defines an associated item of name `assoc_name`.\n+    pub fn trait_may_define_assoc_type(self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n+        self.super_traits_of(trait_def_id).any(|trait_did| {\n+            self.associated_items(trait_did)\n+                .find_by_name_and_kind(self, assoc_name, ty::AssocKind::Type, trait_did)\n+                .is_some()\n+        })\n+    }\n+\n+    /// Computes the def-ids of the transitive super-traits of `trait_def_id`. This (intentionally)\n+    /// does not compute the full elaborated super-predicates but just the set of def-ids. It is used\n+    /// to identify which traits may define a given associated type to help avoid cycle errors.\n+    /// Returns a `DefId` iterator.\n+    fn super_traits_of(self, trait_def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n+        let mut set = FxHashSet::default();\n+        let mut stack = vec![trait_def_id];\n+\n+        set.insert(trait_def_id);\n+\n+        iter::from_fn(move || -> Option<DefId> {\n+            let trait_did = stack.pop()?;\n+            let generic_predicates = self.super_predicates_of(trait_did);\n+\n+            for (predicate, _) in generic_predicates.predicates {\n+                if let ty::PredicateKind::Trait(data, _) = predicate.kind().skip_binder() {\n+                    if set.insert(data.def_id()) {\n+                        stack.push(data.def_id());\n+                    }\n+                }\n+            }\n+\n+            Some(trait_did)\n+        })\n+    }\n+\n     /// Given a closure signature, returns an equivalent fn signature. Detuples\n     /// and so forth -- so e.g., if we have a sig with `Fn<(u32, i32)>` then\n     /// you would get a `fn(u32, i32)`."}, {"sha": "6b4714b1bb8c84d8601d304bd1deecb2566492a5", "filename": "compiler/rustc_middle/src/ty/query/keys.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -7,7 +7,7 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_query_system::query::DefaultCacheSelector;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n /// The `Key` trait controls what types can legally be used as the key\n@@ -160,6 +160,28 @@ impl Key for (LocalDefId, DefId) {\n     }\n }\n \n+impl Key for (DefId, Option<Ident>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        tcx.def_span(self.0)\n+    }\n+}\n+\n+impl Key for (DefId, LocalDefId, Ident) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n impl Key for (CrateNum, DefId) {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "0a81b6e105dff847dd223a0664b169b51f379af4", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -65,7 +65,8 @@ pub use self::util::{\n     get_vtable_index_of_object_method, impl_item_is_final, predicate_for_trait_def, upcast_choices,\n };\n pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n+    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n+    SupertraitDefIds, Supertraits,\n };\n \n pub use self::chalk_fulfill::FulfillmentContext as ChalkFulfillmentContext;"}, {"sha": "244eba8ad5e02d2758de77542e8172408922463b", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -49,9 +49,10 @@ pub trait AstConv<'tcx> {\n \n     fn default_constness_for_trait_bounds(&self) -> Constness;\n \n-    /// Returns predicates in scope of the form `X: Foo`, where `X` is\n-    /// a type parameter `X` with the given id `def_id`. This is a\n-    /// subset of the full set of predicates.\n+    /// Returns predicates in scope of the form `X: Foo<T>`, where `X`\n+    /// is a type parameter `X` with the given id `def_id` and T\n+    /// matches `assoc_name`. This is a subset of the full set of\n+    /// predicates.\n     ///\n     /// This is used for one specific purpose: resolving \"short-hand\"\n     /// associated type references like `T::Item`. In principle, we\n@@ -60,7 +61,12 @@ pub trait AstConv<'tcx> {\n     /// but this can lead to cycle errors. The problem is that we have\n     /// to do this resolution *in order to create the predicates in\n     /// the first place*. Hence, we have this \"special pass\".\n-    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx>;\n+    fn get_type_parameter_bounds(\n+        &self,\n+        span: Span,\n+        def_id: DefId,\n+        assoc_name: Ident,\n+    ) -> ty::GenericPredicates<'tcx>;\n \n     /// Returns the lifetime to use when a lifetime is omitted (and not elided).\n     fn re_infer(&self, param: Option<&ty::GenericParamDef>, span: Span)\n@@ -792,7 +798,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n+    pub fn is_unsized(&self, ast_bounds: &[&hir::GenericBound<'_>], span: Span) -> bool {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n@@ -850,7 +856,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn add_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n+        ast_bounds: &[&hir::GenericBound<'_>],\n         bounds: &mut Bounds<'tcx>,\n     ) {\n         let constness = self.default_constness_for_trait_bounds();\n@@ -865,7 +871,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n                 hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n                     .instantiate_lang_item_trait_ref(\n-                        lang_item, span, hir_id, args, param_ty, bounds,\n+                        *lang_item, *span, *hir_id, args, param_ty, bounds,\n                     ),\n                 hir::GenericBound::Outlives(ref l) => bounds\n                     .region_bounds\n@@ -896,6 +902,42 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ast_bounds: &[hir::GenericBound<'_>],\n         sized_by_default: SizedByDefault,\n         span: Span,\n+    ) -> Bounds<'tcx> {\n+        let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n+        self.compute_bounds_inner(param_ty, &ast_bounds, sized_by_default, span)\n+    }\n+\n+    /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n+    /// named `assoc_name` into ty::Bounds. Ignore the rest.\n+    pub fn compute_bounds_that_match_assoc_type(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound<'_>],\n+        sized_by_default: SizedByDefault,\n+        span: Span,\n+        assoc_name: Ident,\n+    ) -> Bounds<'tcx> {\n+        let mut result = Vec::new();\n+\n+        for ast_bound in ast_bounds {\n+            if let Some(trait_ref) = ast_bound.trait_ref() {\n+                if let Some(trait_did) = trait_ref.trait_def_id() {\n+                    if self.tcx().trait_may_define_assoc_type(trait_did, assoc_name) {\n+                        result.push(ast_bound);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.compute_bounds_inner(param_ty, &result, sized_by_default, span)\n+    }\n+\n+    fn compute_bounds_inner(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[&hir::GenericBound<'_>],\n+        sized_by_default: SizedByDefault,\n+        span: Span,\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n \n@@ -1098,7 +1140,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // parameter to have a skipped binder.\n                 let param_ty =\n                     tcx.mk_projection(assoc_ty.def_id, projection_ty.skip_binder().substs);\n-                self.add_bounds(param_ty, ast_bounds, bounds);\n+                let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n+                self.add_bounds(param_ty, &ast_bounds, bounds);\n             }\n         }\n         Ok(())\n@@ -1413,21 +1456,24 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty_param_def_id, assoc_name, span,\n         );\n \n-        let predicates =\n-            &self.get_type_parameter_bounds(span, ty_param_def_id.to_def_id()).predicates;\n+        let predicates = &self\n+            .get_type_parameter_bounds(span, ty_param_def_id.to_def_id(), assoc_name)\n+            .predicates;\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n         let param_hir_id = tcx.hir().local_def_id_to_hir_id(ty_param_def_id);\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n         self.one_bound_for_assoc_type(\n             || {\n-                traits::transitive_bounds(\n+                traits::transitive_bounds_that_define_assoc_type(\n                     tcx,\n                     predicates.iter().filter_map(|(p, _)| {\n                         p.to_opt_poly_trait_ref().map(|trait_ref| trait_ref.value)\n                     }),\n+                    assoc_name,\n                 )\n+                .into_iter()\n             },\n             || param_name.to_string(),\n             assoc_name,"}, {"sha": "4da4835f7cfbb065ab561ea414ed95b77e2a5399", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::Session;\n+use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode};\n \n@@ -183,7 +184,12 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n+    fn get_type_parameter_bounds(\n+        &self,\n+        _: Span,\n+        def_id: DefId,\n+        _: Ident,\n+    ) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         let item_id = tcx.hir().ty_param_owner(hir_id);"}, {"sha": "e5045f906df59f714c37924455e38e8b20750d62", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 133, "deletions": 52, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -77,6 +78,7 @@ pub fn provide(providers: &mut Providers) {\n         projection_ty_from_predicates,\n         explicit_predicates_of,\n         super_predicates_of,\n+        super_predicates_that_define_assoc_type,\n         trait_explicit_predicates_and_bounds,\n         type_param_predicates,\n         trait_def,\n@@ -308,8 +310,17 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         }\n     }\n \n-    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n-        self.tcx.at(span).type_param_predicates((self.item_def_id, def_id.expect_local()))\n+    fn get_type_parameter_bounds(\n+        &self,\n+        span: Span,\n+        def_id: DefId,\n+        assoc_name: Ident,\n+    ) -> ty::GenericPredicates<'tcx> {\n+        self.tcx.at(span).type_param_predicates((\n+            self.item_def_id,\n+            def_id.expect_local(),\n+            assoc_name,\n+        ))\n     }\n \n     fn re_infer(&self, _: Option<&ty::GenericParamDef>, _: Span) -> Option<ty::Region<'tcx>> {\n@@ -490,7 +501,7 @@ fn get_new_lifetime_name<'tcx>(\n /// `X: Foo` where `X` is the type parameter `def_id`.\n fn type_param_predicates(\n     tcx: TyCtxt<'_>,\n-    (item_def_id, def_id): (DefId, LocalDefId),\n+    (item_def_id, def_id, assoc_name): (DefId, LocalDefId, Ident),\n ) -> ty::GenericPredicates<'_> {\n     use rustc_hir::*;\n \n@@ -515,7 +526,7 @@ fn type_param_predicates(\n     let mut result = parent\n         .map(|parent| {\n             let icx = ItemCtxt::new(tcx, parent);\n-            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id())\n+            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id(), assoc_name)\n         })\n         .unwrap_or_default();\n     let mut extend = None;\n@@ -558,12 +569,18 @@ fn type_param_predicates(\n \n     let icx = ItemCtxt::new(tcx, item_def_id);\n     let extra_predicates = extend.into_iter().chain(\n-        icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n-            .into_iter()\n-            .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n-                _ => false,\n-            }),\n+        icx.type_parameter_bounds_in_generics(\n+            ast_generics,\n+            param_id,\n+            ty,\n+            OnlySelfBounds(true),\n+            Some(assoc_name),\n+        )\n+        .into_iter()\n+        .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n+            ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n+            _ => false,\n+        }),\n     );\n     result.predicates =\n         tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(extra_predicates));\n@@ -581,6 +598,7 @@ impl ItemCtxt<'tcx> {\n         param_id: hir::HirId,\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n+        assoc_name: Option<Ident>,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         let constness = self.default_constness_for_trait_bounds();\n         let from_ty_params = ast_generics\n@@ -591,6 +609,10 @@ impl ItemCtxt<'tcx> {\n                 _ => None,\n             })\n             .flat_map(|bounds| bounds.iter())\n+            .filter(|b| match assoc_name {\n+                Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n+                None => true,\n+            })\n             .flat_map(|b| predicates_from_bound(self, ty, b, constness));\n \n         let from_where_clauses = ast_generics\n@@ -609,12 +631,34 @@ impl ItemCtxt<'tcx> {\n                 } else {\n                     None\n                 };\n-                bp.bounds.iter().filter_map(move |b| bt.map(|bt| (bt, b)))\n+                bp.bounds\n+                    .iter()\n+                    .filter(|b| match assoc_name {\n+                        Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n+                        None => true,\n+                    })\n+                    .filter_map(move |b| bt.map(|bt| (bt, b)))\n             })\n             .flat_map(|(bt, b)| predicates_from_bound(self, bt, b, constness));\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n+\n+    fn bound_defines_assoc_item(&self, b: &hir::GenericBound<'_>, assoc_name: Ident) -> bool {\n+        debug!(\"bound_defines_assoc_item(b={:?}, assoc_name={:?})\", b, assoc_name);\n+\n+        match b {\n+            hir::GenericBound::Trait(poly_trait_ref, _) => {\n+                let trait_ref = &poly_trait_ref.trait_ref;\n+                if let Some(trait_did) = trait_ref.trait_def_id() {\n+                    self.tcx.trait_may_define_assoc_type(trait_did, assoc_name)\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n }\n \n /// Tests whether this is the AST for a reference to the type\n@@ -983,54 +1027,91 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n /// the transitive super-predicates are converted.\n fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n+    tcx.super_predicates_that_define_assoc_type((trait_def_id, None))\n+}\n \n-    let item = match tcx.hir().get(trait_hir_id) {\n-        Node::Item(item) => item,\n-        _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n-    };\n+/// Ensures that the super-predicates of the trait with a `DefId`\n+/// of `trait_def_id` are converted and stored. This also ensures that\n+/// the transitive super-predicates are converted.\n+fn super_predicates_that_define_assoc_type(\n+    tcx: TyCtxt<'_>,\n+    (trait_def_id, assoc_name): (DefId, Option<Ident>),\n+) -> ty::GenericPredicates<'_> {\n+    debug!(\n+        \"super_predicates_that_define_assoc_type(trait_def_id={:?}, assoc_name={:?})\",\n+        trait_def_id, assoc_name\n+    );\n+    if trait_def_id.is_local() {\n+        debug!(\"super_predicates_that_define_assoc_type: local trait_def_id={:?}\", trait_def_id);\n+        let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n \n-    let (generics, bounds) = match item.kind {\n-        hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-        hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n-        _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n-    };\n+        let item = match tcx.hir().get(trait_hir_id) {\n+            Node::Item(item) => item,\n+            _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n+        };\n \n-    let icx = ItemCtxt::new(tcx, trait_def_id);\n-\n-    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-    let self_param_ty = tcx.types.self_param;\n-    let superbounds1 =\n-        AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n-\n-    let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n-\n-    // Convert any explicit superbounds in the where-clause,\n-    // e.g., `trait Foo where Self: Bar`.\n-    // In the case of trait aliases, however, we include all bounds in the where-clause,\n-    // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n-    // as one of its \"superpredicates\".\n-    let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n-    let superbounds2 = icx.type_parameter_bounds_in_generics(\n-        generics,\n-        item.hir_id,\n-        self_param_ty,\n-        OnlySelfBounds(!is_trait_alias),\n-    );\n+        let (generics, bounds) = match item.kind {\n+            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n+            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+            _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n+        };\n+\n+        let icx = ItemCtxt::new(tcx, trait_def_id);\n+\n+        // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n+        let self_param_ty = tcx.types.self_param;\n+        let superbounds1 = if let Some(assoc_name) = assoc_name {\n+            AstConv::compute_bounds_that_match_assoc_type(\n+                &icx,\n+                self_param_ty,\n+                &bounds,\n+                SizedByDefault::No,\n+                item.span,\n+                assoc_name,\n+            )\n+        } else {\n+            AstConv::compute_bounds(&icx, self_param_ty, &bounds, SizedByDefault::No, item.span)\n+        };\n \n-    // Combine the two lists to form the complete set of superbounds:\n-    let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n+        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+\n+        // Convert any explicit superbounds in the where-clause,\n+        // e.g., `trait Foo where Self: Bar`.\n+        // In the case of trait aliases, however, we include all bounds in the where-clause,\n+        // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n+        // as one of its \"superpredicates\".\n+        let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n+        let superbounds2 = icx.type_parameter_bounds_in_generics(\n+            generics,\n+            item.hir_id,\n+            self_param_ty,\n+            OnlySelfBounds(!is_trait_alias),\n+            assoc_name,\n+        );\n \n-    // Now require that immediate supertraits are converted,\n-    // which will, in turn, reach indirect supertraits.\n-    for &(pred, span) in superbounds {\n-        debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateKind::Trait(bound, _) = pred.kind().skip_binder() {\n-            tcx.at(span).super_predicates_of(bound.def_id());\n+        // Combine the two lists to form the complete set of superbounds:\n+        let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n+\n+        // Now require that immediate supertraits are converted,\n+        // which will, in turn, reach indirect supertraits.\n+        if assoc_name.is_none() {\n+            // Now require that immediate supertraits are converted,\n+            // which will, in turn, reach indirect supertraits.\n+            for &(pred, span) in superbounds {\n+                debug!(\"superbound: {:?}\", pred);\n+                if let ty::PredicateKind::Trait(bound, _) = pred.kind().skip_binder() {\n+                    tcx.at(span).super_predicates_of(bound.def_id());\n+                }\n+            }\n         }\n-    }\n \n-    ty::GenericPredicates { parent: None, predicates: superbounds }\n+        ty::GenericPredicates { parent: None, predicates: superbounds }\n+    } else {\n+        // if `assoc_name` is None, then the query should've been redirected to an\n+        // external provider\n+        assert!(assoc_name.is_some());\n+        tcx.super_predicates_of(trait_def_id)\n+    }\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {"}, {"sha": "fe18dc5ed0c69cf85938387ca20154151e549f97", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -28,7 +28,7 @@ fn associated_type_bounds<'tcx>(\n     let bounds = AstConv::compute_bounds(\n         &ItemCtxt::new(tcx, assoc_item_def_id),\n         item_ty,\n-        bounds,\n+        &bounds,\n         SizedByDefault::Yes,\n         span,\n     );\n@@ -69,7 +69,7 @@ fn opaque_type_bounds<'tcx>(\n         let bounds = AstConv::compute_bounds(\n             &ItemCtxt::new(tcx, opaque_def_id),\n             item_ty,\n-            bounds,\n+            &bounds,\n             SizedByDefault::Yes,\n             span,\n         )"}, {"sha": "b502e7207d56182a380aa61787137c70c561026f", "filename": "src/test/incremental/cyclic-trait-hierarchy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -3,11 +3,11 @@\n // revisions: rpass1 cfail2\n \n #[cfg(rpass1)]\n-pub trait T2 { }\n+pub trait T2 {}\n #[cfg(cfail2)]\n-pub trait T2: T1 { }\n-//[cfail2]~^ ERROR cycle detected when computing the supertraits of `T2`\n+pub trait T2: T1 {}\n+//[cfail2]~^ ERROR cycle detected when computing the super predicates of `T2`\n \n-pub trait T1: T2 { }\n+pub trait T1: T2 {}\n \n-fn main() { }\n+fn main() {}"}, {"sha": "1b6d6d0ff599f2ae8093f4c5f0276ebc9671cfea", "filename": "src/test/ui/associated-type-bounds/ambiguous-associated-type2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,12 @@\n+// ignore-tidy-linelength\n+\n+trait Foo {\n+    type Item;\n+}\n+trait Bar<T> {\n+    type Item;\n+}\n+trait Baz: Foo + Bar<Self::Item> {}\n+//~^ ERROR cycle detected when computing the super traits of `Baz` with associated type name `Item` [E0391]\n+\n+fn main() {}"}, {"sha": "bda1debeac0d6f7b8e4271036c3afb235b3d28ae", "filename": "src/test/ui/associated-type-bounds/ambiguous-associated-type2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,16 @@\n+error[E0391]: cycle detected when computing the super traits of `Baz` with associated type name `Item`\n+  --> $DIR/ambiguous-associated-type2.rs:9:1\n+   |\n+LL | trait Baz: Foo + Bar<Self::Item> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: ...which again requires computing the super traits of `Baz` with associated type name `Item`, completing the cycle\n+note: cycle used when computing the super traits of `Baz`\n+  --> $DIR/ambiguous-associated-type2.rs:9:1\n+   |\n+LL | trait Baz: Foo + Bar<Self::Item> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "3eb50ab554735e7b680dfe43d2ef9e5324fb4b1b", "filename": "src/test/ui/associated-type-bounds/associated-item-through-where-clause.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+trait Foo {\n+    type Item;\n+}\n+\n+trait Bar\n+where\n+    Self: Foo,\n+{\n+}\n+\n+#[allow(dead_code)]\n+fn foo<M>(_m: M)\n+where\n+    M: Bar,\n+    M::Item: Send,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "b1e54ec04493b3a3c97ecfab4b9b33ba8eae2103", "filename": "src/test/ui/associated-type-bounds/handle-predicates-that-can-define-assoc-type.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+trait Foo<T> {}\n+trait Bar {\n+    type A;\n+    type B;\n+}\n+trait Baz: Bar<B = u32> + Foo<Self::A> {}\n+\n+fn main() {}"}, {"sha": "07d0f8f8769e5f2bd46ed23e24a718b315a8b44f", "filename": "src/test/ui/associated-type-bounds/missing-trait-bound-for-assoc-fails.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,10 @@\n+#[allow(dead_code)]\n+fn foo<M>(_m: M)\n+where\n+    M::Item: Temp,\n+    //~^ ERROR cannot find trait `Temp` in this scope [E0405]\n+    //~| ERROR associated type `Item` not found for `M` [E0220]\n+{\n+}\n+\n+fn main() {}"}, {"sha": "bc2807b03961c0db6f79a3d93f41741272f5ab38", "filename": "src/test/ui/associated-type-bounds/missing-trait-bound-for-assoc-fails.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,16 @@\n+error[E0405]: cannot find trait `Temp` in this scope\n+  --> $DIR/missing-trait-bound-for-assoc-fails.rs:4:14\n+   |\n+LL |     M::Item: Temp,\n+   |              ^^^^ not found in this scope\n+\n+error[E0220]: associated type `Item` not found for `M`\n+  --> $DIR/missing-trait-bound-for-assoc-fails.rs:4:8\n+   |\n+LL |     M::Item: Temp,\n+   |        ^^^^ associated type `Item` not found\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0220, E0405.\n+For more information about an error, try `rustc --explain E0220`."}, {"sha": "c82ec01f4d61db9b99f8a00d3adb039f1618f685", "filename": "src/test/ui/associated-type-bounds/super-trait-referencing-self.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+trait Foo {\n+    type Bar;\n+}\n+trait Qux: Foo + AsRef<Self::Bar> {}\n+trait Foo2 {}\n+\n+trait Qux2: Foo2 + AsRef<Self::Bar> {\n+    type Bar;\n+}\n+\n+fn main() {}"}, {"sha": "2e97535157fd2ca40ea0aba1f6786e3ccfd86c46", "filename": "src/test/ui/associated-type-bounds/super-trait-referencing.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+// The goal of this test is to ensure that T: Bar<T::Item>\n+// in the where clause does not cycle\n+\n+trait Foo {\n+    type Item;\n+}\n+\n+trait Bar<T> {}\n+\n+fn baz<T>()\n+where\n+    T: Foo,\n+    T: Bar<T::Item>,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "72a6be9ffc38843a38ebf1346b3ea4aebc978645", "filename": "src/test/ui/associated-type-bounds/super-trait-where-referencing-self.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+// Test that we do not get a cycle due to\n+// resolving `Self::Bar` in the where clauses\n+// on a trait definition (in particular, in\n+// a where clause that is defining a superpredicate).\n+\n+trait Foo {\n+    type Bar;\n+}\n+trait Qux\n+where\n+    Self: Foo,\n+    Self: AsRef<Self::Bar>,\n+{\n+}\n+trait Foo2 {}\n+\n+trait Qux2\n+where\n+    Self: Foo2,\n+    Self: AsRef<Self::Bar>,\n+{\n+    type Bar;\n+}\n+\n+fn main() {}"}, {"sha": "a9d6eed810a6b172699e3a85afa15ad79ae35ac0", "filename": "src/test/ui/associated-type-bounds/traits-assoc-anonymized.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-anonymized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-anonymized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-anonymized.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+\n+pub struct LookupInternedStorage;\n+\n+impl<Q> QueryStorageOps<Q> for LookupInternedStorage\n+where\n+    Q: Query,\n+    for<'d> Q: QueryDb<'d>,\n+{\n+    fn fmt_index(&self, db: &<Q as QueryDb<'_>>::DynDb) {\n+        <<Q as QueryDb<'_>>::DynDb as HasQueryGroup<Q::Group>>::group_storage(db);\n+    }\n+}\n+\n+pub trait HasQueryGroup<G> {\n+    fn group_storage(&self);\n+}\n+\n+pub trait QueryStorageOps<Q>\n+where\n+    Q: Query,\n+{\n+    fn fmt_index(&self, db: &<Q as QueryDb<'_>>::DynDb);\n+}\n+\n+pub trait QueryDb<'d> {\n+    type DynDb: HasQueryGroup<Self::Group> + 'd;\n+    type Group;\n+}\n+\n+pub trait Query: for<'d> QueryDb<'d> {}\n+\n+fn main() {}"}, {"sha": "ad5c6aed97c2c3ce7fb57c7215a839fc33b49a32", "filename": "src/test/ui/associated-type-bounds/traits-assoc-type-macros.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-type-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-type-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-type-macros.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+// compile-flags:-Cincremental=tmp/traits-assoc-type-macros\n+\n+// This test case makes sure that we can compile with incremental compilation\n+// enabled when there are macros, traits, inheritance and associated types involved.\n+\n+trait Deserializer {\n+    type Error;\n+}\n+\n+trait Deserialize {\n+    fn deserialize<D>(_: D) -> D::Error\n+    where\n+        D: Deserializer;\n+}\n+\n+macro_rules! impl_deserialize {\n+    ($name:ident) => {\n+        impl Deserialize for $name {\n+            fn deserialize<D>(_: D) -> D::Error\n+            where\n+                D: Deserializer,\n+            {\n+                loop {}\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! formats {\n+    {\n+        $($name:ident,)*\n+    } => {\n+        $(\n+            pub struct $name;\n+\n+            impl_deserialize!($name);\n+        )*\n+    }\n+}\n+formats! { Foo, Bar, }\n+\n+fn main() {}"}, {"sha": "d3609acfdff63edd44e05599669eeb292e2083d2", "filename": "src/test/ui/cycle-projection-based-on-where-clause.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8b330d9fb114132fb41eccdafbe29b48d386749/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8b330d9fb114132fb41eccdafbe29b48d386749/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs?ref=f8b330d9fb114132fb41eccdafbe29b48d386749", "patch": "@@ -1,24 +0,0 @@\n-// Example cycle where a bound on `T` uses a shorthand for `T`. This\n-// creates a cycle because we have to know the bounds on `T` to figure\n-// out what trait defines `Item`, but we can't know the bounds on `T`\n-// without knowing how to handle `T::Item`.\n-//\n-// Note that in the future cases like this could perhaps become legal,\n-// if we got more fine-grained about our cycle detection or changed\n-// how we handle `T::Item` resolution.\n-\n-use std::ops::Add;\n-\n-// Preamble.\n-trait Trait { type Item; }\n-\n-struct A<T>\n-    where T : Trait,\n-          T : Add<T::Item>\n-    //~^ ERROR cycle detected\n-{\n-    data: T\n-}\n-\n-fn main() {\n-}"}, {"sha": "2c337cc6bf903bf6edefca9a1716777b93c41716", "filename": "src/test/ui/cycle-projection-based-on-where-clause.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8b330d9fb114132fb41eccdafbe29b48d386749/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8b330d9fb114132fb41eccdafbe29b48d386749/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr?ref=f8b330d9fb114132fb41eccdafbe29b48d386749", "patch": "@@ -1,16 +0,0 @@\n-error[E0391]: cycle detected when computing the bounds for type parameter `T`\n-  --> $DIR/cycle-projection-based-on-where-clause.rs:17:19\n-   |\n-LL |           T : Add<T::Item>\n-   |                   ^^^^^^^\n-   |\n-   = note: ...which again requires computing the bounds for type parameter `T`, completing the cycle\n-note: cycle used when computing explicit predicates of `A`\n-  --> $DIR/cycle-projection-based-on-where-clause.rs:17:19\n-   |\n-LL |           T : Add<T::Item>\n-   |                   ^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "ee54b2fd151d79294e90dd36764709b5340af359", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-direct.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -1,10 +1,15 @@\n-error[E0391]: cycle detected when computing the supertraits of `Chromosome`\n+error[E0391]: cycle detected when computing the super predicates of `Chromosome`\n+  --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n+   |\n+LL | trait Chromosome: Chromosome {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing the super traits of `Chromosome`...\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:19\n    |\n LL | trait Chromosome: Chromosome {\n    |                   ^^^^^^^^^^\n-   |\n-   = note: ...which again requires computing the supertraits of `Chromosome`, completing the cycle\n+   = note: ...which again requires computing the super predicates of `Chromosome`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n    |"}, {"sha": "0a2284e0efbcaf595e5ed5af739d7174b32bfbd8", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-indirect.stderr", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -1,16 +1,26 @@\n-error[E0391]: cycle detected when computing the supertraits of `B`\n+error[E0391]: cycle detected when computing the super predicates of `B`\n+  --> $DIR/cycle-trait-supertrait-indirect.rs:7:1\n+   |\n+LL | trait B: C {\n+   | ^^^^^^^^^^\n+   |\n+note: ...which requires computing the super traits of `B`...\n   --> $DIR/cycle-trait-supertrait-indirect.rs:7:10\n    |\n LL | trait B: C {\n    |          ^\n+note: ...which requires computing the super predicates of `C`...\n+  --> $DIR/cycle-trait-supertrait-indirect.rs:11:1\n    |\n-note: ...which requires computing the supertraits of `C`...\n+LL | trait C: B { }\n+   | ^^^^^^^^^^\n+note: ...which requires computing the super traits of `C`...\n   --> $DIR/cycle-trait-supertrait-indirect.rs:11:10\n    |\n LL | trait C: B { }\n    |          ^\n-   = note: ...which again requires computing the supertraits of `B`, completing the cycle\n-note: cycle used when computing the supertraits of `A`\n+   = note: ...which again requires computing the super predicates of `B`, completing the cycle\n+note: cycle used when computing the super traits of `A`\n   --> $DIR/cycle-trait-supertrait-indirect.rs:4:10\n    |\n LL | trait A: B {"}, {"sha": "5f2b98c5237db15c4d1d46699d60e68b7e1fac13", "filename": "src/test/ui/issues/issue-12511.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -1,15 +1,25 @@\n-error[E0391]: cycle detected when computing the supertraits of `T1`\n+error[E0391]: cycle detected when computing the super predicates of `T1`\n+  --> $DIR/issue-12511.rs:1:1\n+   |\n+LL | trait T1 : T2 {\n+   | ^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing the super traits of `T1`...\n   --> $DIR/issue-12511.rs:1:12\n    |\n LL | trait T1 : T2 {\n    |            ^^\n+note: ...which requires computing the super predicates of `T2`...\n+  --> $DIR/issue-12511.rs:5:1\n    |\n-note: ...which requires computing the supertraits of `T2`...\n+LL | trait T2 : T1 {\n+   | ^^^^^^^^^^^^^\n+note: ...which requires computing the super traits of `T2`...\n   --> $DIR/issue-12511.rs:5:12\n    |\n LL | trait T2 : T1 {\n    |            ^^\n-   = note: ...which again requires computing the supertraits of `T1`, completing the cycle\n+   = note: ...which again requires computing the super predicates of `T1`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-12511.rs:1:1\n    |"}, {"sha": "4aecc7eab46287bfe9ad257c1080edc372e7d9db", "filename": "src/test/ui/issues/issue-20772.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -1,13 +1,13 @@\n-error[E0391]: cycle detected when computing the supertraits of `T`\n+error[E0391]: cycle detected when computing the super traits of `T` with associated type name `Item`\n   --> $DIR/issue-20772.rs:1:1\n    |\n LL | / trait T : Iterator<Item=Self::Item>\n LL | |\n LL | | {}\n    | |__^\n    |\n-   = note: ...which again requires computing the supertraits of `T`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n+   = note: ...which again requires computing the super traits of `T` with associated type name `Item`, completing the cycle\n+note: cycle used when computing the super traits of `T`\n   --> $DIR/issue-20772.rs:1:1\n    |\n LL | / trait T : Iterator<Item=Self::Item>"}, {"sha": "ccbe06d9c0d565a20d79ebc43394815692c49c4b", "filename": "src/test/ui/issues/issue-20825.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when computing the supertraits of `Processor`\n+error[E0391]: cycle detected when computing the super traits of `Processor` with associated type name `Input`\n   --> $DIR/issue-20825.rs:5:1\n    |\n LL | pub trait Processor: Subscriber<Input = Self::Input> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires computing the supertraits of `Processor`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n+   = note: ...which again requires computing the super traits of `Processor` with associated type name `Input`, completing the cycle\n+note: cycle used when computing the super traits of `Processor`\n   --> $DIR/issue-20825.rs:5:1\n    |\n LL | pub trait Processor: Subscriber<Input = Self::Input> {"}, {"sha": "4b9b4d6b23da488c0d77d3a08f98ff3022a5d42d", "filename": "src/test/ui/issues/issue-22673.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e526b2c38c81c732dd3e640f3cc06acc8f69bb/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs?ref=44e526b2c38c81c732dd3e640f3cc06acc8f69bb", "patch": "@@ -1,5 +1,6 @@\n-trait Expr : PartialEq<Self::Item> {\n-    //~^ ERROR: cycle detected\n+// check-pass\n+\n+trait Expr: PartialEq<Self::Item> {\n     type Item;\n }\n "}, {"sha": "9e7e4b218b1c668cdba6e31068cc2af5c05316b2", "filename": "src/test/ui/issues/issue-22673.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f8b330d9fb114132fb41eccdafbe29b48d386749/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8b330d9fb114132fb41eccdafbe29b48d386749/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr?ref=f8b330d9fb114132fb41eccdafbe29b48d386749", "patch": "@@ -1,16 +0,0 @@\n-error[E0391]: cycle detected when computing the supertraits of `Expr`\n-  --> $DIR/issue-22673.rs:1:1\n-   |\n-LL | trait Expr : PartialEq<Self::Item> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: ...which again requires computing the supertraits of `Expr`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/issue-22673.rs:1:1\n-   |\n-LL | trait Expr : PartialEq<Self::Item> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0391`."}]}