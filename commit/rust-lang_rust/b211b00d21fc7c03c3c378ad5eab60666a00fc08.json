{"sha": "b211b00d21fc7c03c3c378ad5eab60666a00fc08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMTFiMDBkMjFmYzdjMDNjM2MzNzhhZDVlYWI2MDY2NmEwMGZjMDg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-30T01:39:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T17:32:34Z"}, "message": "syntax: Remove io_error usage", "tree": {"sha": "233c38ed416d943f5fab0f77664a5d0eb6c15fe6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/233c38ed416d943f5fab0f77664a5d0eb6c15fe6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b211b00d21fc7c03c3c378ad5eab60666a00fc08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b211b00d21fc7c03c3c378ad5eab60666a00fc08", "html_url": "https://github.com/rust-lang/rust/commit/b211b00d21fc7c03c3c378ad5eab60666a00fc08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b211b00d21fc7c03c3c378ad5eab60666a00fc08/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef00c6a278cdd3bd00f44133573e1f5e2e951520", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef00c6a278cdd3bd00f44133573e1f5e2e951520", "html_url": "https://github.com/rust-lang/rust/commit/ef00c6a278cdd3bd00f44133573e1f5e2e951520"}], "stats": {"total": 2395, "additions": 1349, "deletions": 1046}, "files": [{"sha": "5b3b436a6fc5a71813d230249a3d4b03b40637c0", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b211b00d21fc7c03c3c378ad5eab60666a00fc08", "patch": "@@ -189,58 +189,61 @@ impl Level {\n     }\n }\n \n-fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n-    local_data_key!(tls_terminal: ~Option<term::Terminal<StdWriter>>)\n+fn print_maybe_styled(msg: &str, color: term::attr::Attr) -> io::IoResult<()> {\n+    local_data_key!(tls_terminal: Option<term::Terminal<StdWriter>>)\n+\n \n     fn is_stderr_screen() -> bool {\n         use std::libc;\n         unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n     }\n-    fn write_pretty<T: Writer>(term: &mut term::Terminal<T>, s: &str, c: term::attr::Attr) {\n-        term.attr(c);\n-        term.write(s.as_bytes());\n-        term.reset();\n+    fn write_pretty<T: Writer>(term: &mut term::Terminal<T>, s: &str,\n+                               c: term::attr::Attr) -> io::IoResult<()> {\n+        if_ok!(term.attr(c));\n+        if_ok!(term.write(s.as_bytes()));\n+        if_ok!(term.reset());\n+        Ok(())\n     }\n \n     if is_stderr_screen() {\n         local_data::get_mut(tls_terminal, |term| {\n             match term {\n                 Some(term) => {\n-                    match **term {\n+                    match *term {\n                         Some(ref mut term) => write_pretty(term, msg, color),\n                         None => io::stderr().write(msg.as_bytes())\n                     }\n                 }\n                 None => {\n-                    let t = ~match term::Terminal::new(io::stderr()) {\n+                    let (t, ret) = match term::Terminal::new(io::stderr()) {\n                         Ok(mut term) => {\n-                            write_pretty(&mut term, msg, color);\n-                            Some(term)\n+                            let r = write_pretty(&mut term, msg, color);\n+                            (Some(term), r)\n                         }\n                         Err(_) => {\n-                            io::stderr().write(msg.as_bytes());\n-                            None\n+                            (None, io::stderr().write(msg.as_bytes()))\n                         }\n                     };\n                     local_data::set(tls_terminal, t);\n+                    ret\n                 }\n             }\n-        });\n+        })\n     } else {\n-        io::stderr().write(msg.as_bytes());\n+        io::stderr().write(msg.as_bytes())\n     }\n }\n \n-fn print_diagnostic(topic: &str, lvl: Level, msg: &str) {\n-    let mut stderr = io::stderr();\n-\n+fn print_diagnostic(topic: &str, lvl: Level, msg: &str) -> io::IoResult<()> {\n     if !topic.is_empty() {\n-        write!(&mut stderr as &mut io::Writer, \"{} \", topic);\n+        let mut stderr = io::stderr();\n+        if_ok!(write!(&mut stderr as &mut io::Writer, \"{} \", topic));\n     }\n \n-    print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n-                       term::attr::ForegroundColor(lvl.color()));\n-    print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold);\n+    if_ok!(print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n+                              term::attr::ForegroundColor(lvl.color())));\n+    if_ok!(print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold));\n+    Ok(())\n }\n \n pub struct DefaultEmitter;\n@@ -250,20 +253,28 @@ impl Emitter for DefaultEmitter {\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: Level) {\n-        match cmsp {\n+        let error = match cmsp {\n             Some((cm, sp)) => emit(cm, sp, msg, lvl, false),\n             None => print_diagnostic(\"\", lvl, msg),\n+        };\n+\n+        match error {\n+            Ok(()) => {}\n+            Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n         }\n     }\n \n     fn custom_emit(&self, cm: &codemap::CodeMap,\n                    sp: Span, msg: &str, lvl: Level) {\n-        emit(cm, sp, msg, lvl, true);\n+        match emit(cm, sp, msg, lvl, true) {\n+            Ok(()) => {}\n+            Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n+        }\n     }\n }\n \n fn emit(cm: &codemap::CodeMap, sp: Span,\n-        msg: &str, lvl: Level, custom: bool) {\n+        msg: &str, lvl: Level, custom: bool) -> io::IoResult<()> {\n     let ss = cm.span_to_str(sp);\n     let lines = cm.span_to_lines(sp);\n     if custom {\n@@ -272,19 +283,19 @@ fn emit(cm: &codemap::CodeMap, sp: Span,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n         let ses = cm.span_to_str(span_end);\n-        print_diagnostic(ses, lvl, msg);\n-        custom_highlight_lines(cm, sp, lvl, lines);\n+        if_ok!(print_diagnostic(ses, lvl, msg));\n+        if_ok!(custom_highlight_lines(cm, sp, lvl, lines));\n     } else {\n-        print_diagnostic(ss, lvl, msg);\n-        highlight_lines(cm, sp, lvl, lines);\n+        if_ok!(print_diagnostic(ss, lvl, msg));\n+        if_ok!(highlight_lines(cm, sp, lvl, lines));\n     }\n-    print_macro_backtrace(cm, sp);\n+    print_macro_backtrace(cm, sp)\n }\n \n fn highlight_lines(cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: &codemap::FileLines) {\n+                   lines: &codemap::FileLines) -> io::IoResult<()> {\n     let fm = lines.file;\n     let mut err = io::stderr();\n     let err = &mut err as &mut io::Writer;\n@@ -297,12 +308,13 @@ fn highlight_lines(cm: &codemap::CodeMap,\n     }\n     // Print the offending lines\n     for line in display_lines.iter() {\n-        write!(err, \"{}:{} {}\\n\", fm.name, *line + 1, fm.get_line(*line as int));\n+        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name, *line + 1,\n+                      fm.get_line(*line as int)));\n     }\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n-        write!(err, \"{0:1$}...\\n\", \"\", s.len());\n+        if_ok!(write!(err, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n@@ -334,16 +346,18 @@ fn highlight_lines(cm: &codemap::CodeMap,\n                 _ => s.push_char(' '),\n             };\n         }\n-        write!(err, \"{}\", s);\n+        if_ok!(write!(err, \"{}\", s));\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n             for _ in range(0, num_squigglies) { s.push_char('~'); }\n         }\n-        print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()));\n+        if_ok!(print_maybe_styled(s + \"\\n\",\n+                                  term::attr::ForegroundColor(lvl.color())));\n     }\n+    Ok(())\n }\n \n // Here are the differences between this and the normal `highlight_lines`:\n@@ -355,23 +369,23 @@ fn highlight_lines(cm: &codemap::CodeMap,\n fn custom_highlight_lines(cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n-                          lines: &codemap::FileLines) {\n+                          lines: &codemap::FileLines) -> io::IoResult<()> {\n     let fm = lines.file;\n     let mut err = io::stderr();\n     let err = &mut err as &mut io::Writer;\n \n     let lines = lines.lines.as_slice();\n     if lines.len() > MAX_LINES {\n-        write!(err, \"{}:{} {}\\n\", fm.name,\n-               lines[0] + 1, fm.get_line(lines[0] as int));\n-        write!(err, \"...\\n\");\n+        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+                      lines[0] + 1, fm.get_line(lines[0] as int)));\n+        if_ok!(write!(err, \"...\\n\"));\n         let last_line = lines[lines.len()-1];\n-        write!(err, \"{}:{} {}\\n\", fm.name,\n-               last_line + 1, fm.get_line(last_line as int));\n+        if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+                      last_line + 1, fm.get_line(last_line as int)));\n     } else {\n         for line in lines.iter() {\n-            write!(err, \"{}:{} {}\\n\", fm.name,\n-                   *line + 1, fm.get_line(*line as int));\n+            if_ok!(write!(err, \"{}:{} {}\\n\", fm.name,\n+                          *line + 1, fm.get_line(*line as int)));\n         }\n     }\n     let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n@@ -381,22 +395,24 @@ fn custom_highlight_lines(cm: &codemap::CodeMap,\n     let mut s = ~\"\";\n     for _ in range(0, skip) { s.push_char(' '); }\n     s.push_char('^');\n-    print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()));\n+    print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()))\n }\n \n-fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) {\n+fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) -> io::IoResult<()> {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.as_ref().map_or(~\"\", |span| cm.span_to_str(*span));\n         let (pre, post) = match ei.callee.format {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")\n         };\n-        print_diagnostic(ss, Note,\n-                         format!(\"in expansion of {}{}{}\", pre, ei.callee.name, post));\n+        if_ok!(print_diagnostic(ss, Note,\n+                                format!(\"in expansion of {}{}{}\", pre,\n+                                        ei.callee.name, post)));\n         let ss = cm.span_to_str(ei.call_site);\n-        print_diagnostic(ss, Note, \"expansion site\");\n-        print_macro_backtrace(cm, ei.call_site);\n+        if_ok!(print_diagnostic(ss, Note, \"expansion site\"));\n+        if_ok!(print_macro_backtrace(cm, ei.call_site));\n     }\n+    Ok(())\n }\n \n pub fn expect<T:Clone>(diag: @SpanHandler, opt: Option<T>, msg: || -> ~str)"}, {"sha": "52010b39a544697bdfc7325a8f8e5058e3b9e493", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b211b00d21fc7c03c3c378ad5eab60666a00fc08", "patch": "@@ -20,7 +20,6 @@ use parse::token::get_ident_interner;\n use parse::token;\n use print::pprust;\n \n-use std::io;\n use std::io::File;\n use std::rc::Rc;\n use std::str;\n@@ -109,9 +108,9 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         None => return MacResult::dummy_expr()\n     };\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-    let bytes = match io::result(|| File::open(&file).read_to_end()) {\n+    let bytes = match File::open(&file).read_to_end() {\n         Err(e) => {\n-            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e.desc));\n+            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n             return MacResult::dummy_expr();\n         }\n         Ok(bytes) => bytes,\n@@ -141,9 +140,9 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         None => return MacResult::dummy_expr()\n     };\n     let file = res_rel_file(cx, sp, &Path::new(file));\n-    match io::result(|| File::open(&file).read_to_end()) {\n+    match File::open(&file).read_to_end() {\n         Err(e) => {\n-            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e.desc));\n+            cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n             return MacResult::dummy_expr();\n         }\n         Ok(bytes) => {"}, {"sha": "e2aa9e3b3ee671a7a54eb025d3c367775e85d81b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b211b00d21fc7c03c3c378ad5eab60666a00fc08", "patch": "@@ -33,6 +33,11 @@ This API is completely unstable and subject to change.\n extern mod extra;\n extern mod term;\n \n+#[cfg(stage0)]\n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)\n+\n pub mod util {\n     pub mod interner;\n     #[cfg(test)]"}, {"sha": "f65bc3ad7a3511bc4e296ba76e805bac6ced47c0", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b211b00d21fc7c03c3c378ad5eab60666a00fc08", "patch": "@@ -350,7 +350,8 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     path: ~str,\n                                     srdr: &mut io::Reader)\n                                  -> (~[Comment], ~[Literal]) {\n-    let src = str::from_utf8_owned(srdr.read_to_end()).unwrap();\n+    let src = srdr.read_to_end().unwrap();\n+    let src = str::from_utf8_owned(src).unwrap();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "328f0e7f22187ca7d678e85df3d0ff1f945a8ced", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b211b00d21fc7c03c3c378ad5eab60666a00fc08", "patch": "@@ -19,7 +19,6 @@ use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n use std::cell::RefCell;\n-use std::io;\n use std::io::File;\n use std::str;\n \n@@ -232,10 +231,10 @@ pub fn file_to_filemap(sess: @ParseSess, path: &Path, spanopt: Option<Span>)\n             None => sess.span_diagnostic.handler().fatal(msg),\n         }\n     };\n-    let bytes = match io::result(|| File::open(path).read_to_end()) {\n+    let bytes = match File::open(path).read_to_end() {\n         Ok(bytes) => bytes,\n         Err(e) => {\n-            err(format!(\"couldn't read {}: {}\", path.display(), e.desc));\n+            err(format!(\"couldn't read {}: {}\", path.display(), e));\n             unreachable!()\n         }\n     };"}, {"sha": "bb287c0f5f8807712f66111a1870b91ad1c61b29", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 57, "deletions": 47, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=b211b00d21fc7c03c3c378ad5eab60666a00fc08", "patch": "@@ -292,7 +292,7 @@ impl Printer {\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.token[self.right] = t;\n     }\n-    pub fn pretty_print(&mut self, t: Token) {\n+    pub fn pretty_print(&mut self, t: Token) -> io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n         match t {\n           Eof => {\n@@ -301,31 +301,19 @@ impl Printer {\n                 let left = self.token[self.left].clone();\n                 self.advance_left(left, self.size[self.left]);\n             }\n-            self.indent(0);\n-          }\n-          Begin(b) => {\n-            if self.scan_stack_empty {\n-                self.left_total = 1;\n-                self.right_total = 1;\n-                self.left = 0u;\n-                self.right = 0u;\n-            } else { self.advance_right(); }\n-            debug!(\"pp Begin({})/buffer ~[{},{}]\",\n-                   b.offset, self.left, self.right);\n-            self.token[self.right] = t;\n-            self.size[self.right] = -self.right_total;\n-            self.scan_push(self.right);\n-          }\n-          End => {\n-            if self.scan_stack_empty {\n-                debug!(\"pp End/print ~[{},{}]\", self.left, self.right);\n-                self.print(t, 0);\n-            } else {\n-                debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n-                self.advance_right();\n+            Begin(b) => {\n+                if self.scan_stack_empty {\n+                    self.left_total = 1;\n+                    self.right_total = 1;\n+                    self.left = 0u;\n+                    self.right = 0u;\n+                } else { self.advance_right(); }\n+                debug!(\"pp Begin({})/buffer ~[{},{}]\",\n+                b.offset, self.left, self.right);\n                 self.token[self.right] = t;\n-                self.size[self.right] = -1;\n+                self.size[self.right] = -self.right_total;\n                 self.scan_push(self.right);\n+                Ok(())\n             }\n           }\n           Break(b) => {\n@@ -357,10 +345,9 @@ impl Printer {\n                 self.right_total += len;\n                 self.check_stream();\n             }\n-          }\n         }\n     }\n-    pub fn check_stream(&mut self) {\n+    pub fn check_stream(&mut self) -> io::IoResult<()> {\n         debug!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -376,6 +363,7 @@ impl Printer {\n             self.advance_left(left, self.size[self.left]);\n             if self.left != self.right { self.check_stream(); }\n         }\n+        Ok(())\n     }\n     pub fn scan_push(&mut self, x: uint) {\n         debug!(\"scan_push {}\", x);\n@@ -413,7 +401,7 @@ impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    pub fn advance_left(&mut self, x: Token, L: int) {\n+    pub fn advance_left(&mut self, x: Token, L: int) -> io::IoResult<()> {\n         debug!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n@@ -431,6 +419,9 @@ impl Printer {\n                 let left = self.token[self.left].clone();\n                 self.advance_left(left, self.size[self.left]);\n             }\n+            ret\n+        } else {\n+            Ok(())\n         }\n     }\n     pub fn check_stack(&mut self, k: int) {\n@@ -456,11 +447,12 @@ impl Printer {\n             }\n         }\n     }\n-    pub fn print_newline(&mut self, amount: int) {\n+    pub fn print_newline(&mut self, amount: int) -> io::IoResult<()> {\n         debug!(\"NEWLINE {}\", amount);\n-        write!(self.out, \"\\n\");\n+        let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n+        return ret;\n     }\n     pub fn indent(&mut self, amount: int) {\n         debug!(\"INDENT {}\", amount);\n@@ -478,12 +470,12 @@ impl Printer {\n             }\n         }\n     }\n-    pub fn print_str(&mut self, s: &str) {\n+    pub fn print_str(&mut self, s: &str) -> io::IoResult<()> {\n         while self.pending_indentation > 0 {\n-            write!(self.out, \" \");\n+            if_ok!(write!(self.out, \" \"));\n             self.pending_indentation -= 1;\n         }\n-        write!(self.out, \"{}\", s);\n+        write!(self.out, \"{}\", s)\n     }\n     pub fn print(&mut self, x: Token, L: int) {\n         debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), L,\n@@ -509,12 +501,14 @@ impl Printer {\n                     pbreak: Fits\n                 });\n             }\n+            Ok(())\n           }\n           End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n             assert!((print_stack.len() != 0u));\n             print_stack.pop().unwrap();\n+            Ok(())\n           }\n           Break(b) => {\n             let top = self.get_top();\n@@ -523,24 +517,28 @@ impl Printer {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n+                Ok(())\n               }\n               Broken(Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n-                self.print_newline(top.offset + b.offset);\n+                let ret = self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n+                ret\n               }\n               Broken(Inconsistent) => {\n                 if L > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n-                    self.print_newline(top.offset + b.offset);\n+                    let ret = self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n+                    ret\n                 } else {\n                     debug!(\"print Break({}) w/o newline in inconsistent\",\n                            b.blank_space);\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n+                    Ok(())\n                 }\n               }\n             }\n@@ -550,7 +548,7 @@ impl Printer {\n             assert_eq!(L, len);\n             // assert!(L <= space);\n             self.space -= len;\n-            self.print_str(s);\n+            self.print_str(s)\n           }\n           Eof => {\n             // Eof should never get here.\n@@ -563,27 +561,31 @@ impl Printer {\n // Convenience functions to talk to the printer.\n //\n // \"raw box\"\n-pub fn rbox(p: &mut Printer, indent: uint, b: Breaks) {\n+pub fn rbox(p: &mut Printer, indent: uint, b: Breaks) -> io::IoResult<()> {\n     p.pretty_print(Begin(BeginToken {\n         offset: indent as int,\n         breaks: b\n-    }));\n+    }))\n }\n \n-pub fn ibox(p: &mut Printer, indent: uint) { rbox(p, indent, Inconsistent); }\n+pub fn ibox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n+    rbox(p, indent, Inconsistent)\n+}\n \n-pub fn cbox(p: &mut Printer, indent: uint) { rbox(p, indent, Consistent); }\n+pub fn cbox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n+    rbox(p, indent, Consistent)\n+}\n \n-pub fn break_offset(p: &mut Printer, n: uint, off: int) {\n+pub fn break_offset(p: &mut Printer, n: uint, off: int) -> io::IoResult<()> {\n     p.pretty_print(Break(BreakToken {\n         offset: off,\n         blank_space: n as int\n-    }));\n+    }))\n }\n \n-pub fn end(p: &mut Printer) { p.pretty_print(End); }\n+pub fn end(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(End) }\n \n-pub fn eof(p: &mut Printer) { p.pretty_print(Eof); }\n+pub fn eof(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(Eof) }\n \n pub fn word(p: &mut Printer, wrd: &str) {\n     p.pretty_print(String(/* bad */ wrd.to_str(), wrd.len() as int));\n@@ -597,13 +599,21 @@ pub fn zero_word(p: &mut Printer, wrd: &str) {\n     p.pretty_print(String(/* bad */ wrd.to_str(), 0));\n }\n \n-pub fn spaces(p: &mut Printer, n: uint) { break_offset(p, n, 0); }\n+pub fn spaces(p: &mut Printer, n: uint) -> io::IoResult<()> {\n+    break_offset(p, n, 0)\n+}\n \n-pub fn zerobreak(p: &mut Printer) { spaces(p, 0u); }\n+pub fn zerobreak(p: &mut Printer) -> io::IoResult<()> {\n+    spaces(p, 0u)\n+}\n \n-pub fn space(p: &mut Printer) { spaces(p, 1u); }\n+pub fn space(p: &mut Printer) -> io::IoResult<()> {\n+    spaces(p, 1u)\n+}\n \n-pub fn hardbreak(p: &mut Printer) { spaces(p, SIZE_INFINITY as uint); }\n+pub fn hardbreak(p: &mut Printer) -> io::IoResult<()> {\n+    spaces(p, SIZE_INFINITY as uint)\n+}\n \n pub fn hardbreak_tok_offset(off: int) -> Token {\n     Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})"}, {"sha": "17b0b7b9c3849f03d2dadccca24e0064ffbe73c3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1215, "deletions": 942, "changes": 2157, "blob_url": "https://github.com/rust-lang/rust/blob/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b211b00d21fc7c03c3c378ad5eab60666a00fc08/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b211b00d21fc7c03c3c378ad5eab60666a00fc08"}]}