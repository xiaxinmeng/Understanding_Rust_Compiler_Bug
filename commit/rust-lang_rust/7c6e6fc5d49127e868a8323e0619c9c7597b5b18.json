{"sha": "7c6e6fc5d49127e868a8323e0619c9c7597b5b18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNmU2ZmM1ZDQ5MTI3ZTg2OGE4MzIzZTA2MTljOWM3NTk3YjViMTg=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-13T22:34:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-13T22:50:34Z"}, "message": "Make expr_while work in typestate_check\n\nAlso did some refactoring in typestate_check. All test cases in\ncompile-fail that involve uninitialized vars now fail correctly!\n(All eight of them, that is.)", "tree": {"sha": "7f6e32ed9887e057d768027c4f1f03b4eec631cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f6e32ed9887e057d768027c4f1f03b4eec631cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c6e6fc5d49127e868a8323e0619c9c7597b5b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6e6fc5d49127e868a8323e0619c9c7597b5b18", "html_url": "https://github.com/rust-lang/rust/commit/7c6e6fc5d49127e868a8323e0619c9c7597b5b18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c6e6fc5d49127e868a8323e0619c9c7597b5b18/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb33a5307b42ef1c1ab7697ed1a0583a7f6b80b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb33a5307b42ef1c1ab7697ed1a0583a7f6b80b8", "html_url": "https://github.com/rust-lang/rust/commit/eb33a5307b42ef1c1ab7697ed1a0583a7f6b80b8"}], "stats": {"total": 220, "additions": 104, "deletions": 116}, "files": [{"sha": "e9c366c536824a7228d1d8d8ed1b01b59ed412ef", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 91, "deletions": 114, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/7c6e6fc5d49127e868a8323e0619c9c7597b5b18/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6e6fc5d49127e868a8323e0619c9c7597b5b18/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=7c6e6fc5d49127e868a8323e0619c9c7597b5b18", "patch": "@@ -30,6 +30,7 @@ import front.ast.expr_rec;\n import front.ast.expr_if;\n import front.ast.expr_binary;\n import front.ast.expr_assign;\n+import front.ast.expr_while;\n import front.ast.expr_lit;\n import front.ast.expr_ret;\n import front.ast.path;\n@@ -71,6 +72,8 @@ import util.common.new_def_hash;\n import util.common.uistr;\n import util.common.elt_exprs;\n import util.common.field_exprs;\n+import util.common.log_expr;\n+import util.common.lift;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n import util.typestate_ann.empty_pre_post;\n@@ -717,6 +720,33 @@ fn find_pre_post_item(_fn_info_map fm, fn_info enclosing, &item i) -> () {\n   }\n }\n \n+/* Finds the pre and postcondition for each expr in <args>;\n+   sets the precondition in a to be the result of combining\n+   the preconditions for <args>, and the postcondition in a to \n+   be the union of all postconditions for <args> */\n+fn find_pre_post_exprs(&_fn_info_map fm, &fn_info enclosing,\n+                       &vec[@expr] args, ann a) {\n+    fn do_one(_fn_info_map fm, fn_info enclosing,\n+              &@expr e) -> () {\n+        find_pre_post_expr(fm, enclosing, *e);\n+    }\n+    auto f = bind do_one(fm, enclosing, _);\n+\n+    _vec.map[@expr, ()](f, args);\n+\n+    fn get_pp(&@expr e) -> pre_and_post {\n+        ret expr_pp(*e);\n+    }\n+    auto g = get_pp;\n+    auto pps = _vec.map[@expr, pre_and_post](g, args);\n+    auto h = get_post;\n+\n+    set_pre_and_post(a,\n+       rec(precondition=seq_preconds(num_locals(enclosing), pps),\n+           postcondition=union_postconds\n+           (_vec.map[pre_and_post, postcond](h, pps))));\n+}\n+\n /* Fills in annotations as a side effect. Does not rebuild the expr */\n fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n     auto num_local_vars = num_locals(enclosing);\n@@ -730,24 +760,9 @@ fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n \n     alt(e.node) {\n         case(expr_call(?operator, ?operands, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *operator);\n-\n-            auto do_rand = bind do_rand_(fm, enclosing,_);\n-            auto f = do_rand;\n-            _vec.map[@expr, ()](f, operands);\n-      \n-            auto g = pp_one;\n-            auto pps = _vec.map[@expr, pre_and_post](g, operands);\n-            _vec.push[pre_and_post](pps, expr_pp(*operator));\n-            auto h = get_post;\n-            auto res_postconds = _vec.map[pre_and_post, postcond](h, pps);\n-            auto res_postcond = union_postconds(res_postconds);\n-      \n-            let pre_and_post pp =\n-                rec(precondition=seq_preconds(num_local_vars, pps),\n-                    postcondition=res_postcond);\n-            set_pre_and_post(a, pp);\n-            ret;\n+            auto args = _vec.clone[@expr](operands);\n+            _vec.push[@expr](args, operator);\n+            find_pre_post_exprs(fm, enclosing, args, a);\n         }\n         case(expr_path(?p, ?maybe_def, ?a)) {\n             auto df;\n@@ -779,98 +794,21 @@ fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             set_pre_and_post(a, block_pp(b));\n         }\n         case (expr_rec(?fields,?maybe_base,?a)) {\n-            /* factor out this code */\n             auto es = field_exprs(fields);\n-            auto do_rand = bind do_rand_(fm, enclosing,_);\n-            auto f = do_rand;\n-            _vec.map[@expr, ()](f, es);\n-            auto g = pp_one;\n-            auto h = get_post;\n-            /* FIXME avoid repeated code */\n-            alt (maybe_base) {\n-                case (none[@expr]) {\n-                    auto pps = _vec.map[@expr, pre_and_post](g, es);\n-                    auto res_postconds = _vec.map[pre_and_post, postcond]\n-                        (h, pps);\n-                    auto res_postcond = union_postconds(res_postconds);\n-                    let pre_and_post pp =\n-                        rec(precondition=seq_preconds(num_local_vars, pps),\n-                            postcondition=res_postcond);\n-                    set_pre_and_post(a, pp);\n-                }\n-                case (some[@expr](?base_exp)) {\n-                    find_pre_post_expr(fm, enclosing, *base_exp);\n-        \n-                    es += vec(base_exp);\n-                    auto pps = _vec.map[@expr, pre_and_post](g, es);\n-                    auto res_postconds = _vec.map[pre_and_post, postcond]\n-                        (h, pps);\n-                    auto res_postcond = union_postconds(res_postconds);\n-\n-                    let pre_and_post pp =\n-                        rec(precondition=seq_preconds(num_local_vars, pps),\n-                            postcondition=res_postcond);\n-                    set_pre_and_post(a, pp);\n-                }\n-            }\n-            ret;\n+            _vec.plus_option[@expr](es, maybe_base);\n+            find_pre_post_exprs(fm, enclosing, es, a);\n         }\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n-            // what's below should be compressed into two cases:\n-            // path of a local, and non-path-of-a-local\n             alt (lhs.node) {\n-                case (expr_field(?e,?id,?a_lhs)) {\n-                    // lhs is already initialized, so this doesn't initialize\n-                    // anything anew\n-                    find_pre_post_expr(fm, enclosing, *e);\n-                    set_pre_and_post(a_lhs, expr_pp(*e));\n-\n+                case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n                     find_pre_post_expr(fm, enclosing, *rhs);\n-                    let pre_and_post expr_assign_pp = \n-                        rec(precondition=seq_preconds\n-                            (num_local_vars,\n-                             vec(expr_pp(*e), expr_pp(*rhs))),\n-                            postcondition=union_postconds\n-                            (vec(expr_postcond(*e), expr_postcond(*rhs))));\n-                    set_pre_and_post(a, expr_assign_pp);\n-                }\n-                case (expr_path(?p,?maybe_def,?a_lhs)) {\n-                    find_pre_post_expr(fm, enclosing, *rhs);\n-                    set_pre_and_post(a_lhs, empty_pre_post(num_local_vars));\n-                    find_pre_post_expr(fm, enclosing, *rhs);\n-                    alt (maybe_def) {\n-                        // is this a local variable?\n-                        // if so, the only case in which an assign actually\n-                        // causes a variable to become initialized\n-                        case (some[def](def_local(?d_id))) {\n-                            set_pre_and_post(a, expr_pp(*rhs));\n-                            gen(enclosing, a, d_id);\n-                        }\n-                        case (_) {\n-                            // already initialized\n-                            set_pre_and_post(a, expr_pp(*rhs));\n-                        }\n-                    }\n-                }\n-                case (expr_index(?e,?sub,_)) {\n-                    // lhs is already initialized\n-                    // assuming the array subscript gets evaluated before the\n-                    // array\n-                    find_pre_post_expr(fm, enclosing, *lhs);\n-                    find_pre_post_expr(fm, enclosing, *rhs);\n-                    set_pre_and_post(a, \n-                       rec(precondition=\n-                           seq_preconds\n-                           (num_local_vars, vec(expr_pp(*lhs), \n-                                                expr_pp(*rhs))),\n-                           postcondition=\n-                           union_postconds(vec(expr_postcond(*lhs),\n-                                               expr_postcond(*rhs)))));\n-                \n+                    set_pre_and_post(a, expr_pp(*rhs));\n+                    gen(enclosing, a, d_id);\n                 }\n                 case (_) {\n-                    log(\"find_pre_post_for_expr: non-lval on lhs of assign\");\n-                    fail;\n+                    // doesn't check that lhs is an lval, but\n+                    // that's probably ok\n+                    find_pre_post_exprs(fm, enclosing, vec(lhs, rhs), a);\n                 }\n             }\n         }\n@@ -927,15 +865,22 @@ fn find_pre_post_expr(&_fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n         case (expr_binary(?bop,?l,?r,?a)) {\n             /* *unless* bop is lazy (e.g. and, or)? \n              FIXME */\n-            find_pre_post_expr(fm, enclosing, *l);\n-            find_pre_post_expr(fm, enclosing, *r);\n-            set_pre_and_post(a, \n-                             rec(precondition=\n-                                 seq_preconds(num_local_vars,\n-                                              vec(expr_pp(*l), expr_pp(*r))),\n-                                 postcondition=\n-                                 union_postconds(vec(expr_postcond(*l),\n-                                                     expr_postcond(*r)))));\n+            find_pre_post_exprs(fm, enclosing, vec(l, r), a);\n+        }\n+        case (expr_while(?test, ?body, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *test);\n+            find_pre_post_block(fm, enclosing, body);\n+            set_pre_and_post(a,\n+              rec(precondition=\n+                    seq_preconds(num_local_vars,\n+                                 vec(expr_pp(*test), \n+                                     block_pp(body))),\n+                  postcondition=\n+                  intersect_postconds(vec(expr_postcond(*test),\n+                                          block_postcond(body)))));\n+        }\n+        case (expr_index(?e, ?sub, ?a)) {\n+            find_pre_post_exprs(fm, enclosing, vec(e, sub), a);\n         }\n         case(_) {\n             log(\"this sort of expr isn't implemented!\");\n@@ -1253,6 +1198,33 @@ fn find_pre_post_state_expr(&_fn_info_map fm, &fn_info enclosing,\n         changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n         ret changed;\n     }\n+    case (expr_while(?test, ?body, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        /* to handle general predicates, we need to pass in\n+            pres `intersect` (poststate(a)) \n+         like: auto test_pres = intersect_postconds(pres, expr_postcond(a));\n+         However, this doesn't work right now because we would be passing\n+         in an all-zero prestate initially\n+           FIXME\n+           maybe need a \"don't know\" state in addition to 0 or 1?\n+        */\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, test)\n+            || changed;\n+        changed = find_pre_post_state_block(fm, \n+                   enclosing, expr_poststate(*test), body) || changed; \n+        changed = extend_poststate_ann(a,\n+                    intersect_postconds(vec(expr_poststate(*test),\n+                                        block_poststate(body)))) || changed;\n+        ret changed;\n+    }\n+    case (expr_index(?e, ?sub, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed; \n+        changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+        changed = find_pre_post_state_expr(fm, enclosing,\n+                     expr_poststate(*e), sub) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*sub));\n+        ret changed;\n+    }\n     case (_) {\n       log(\"find_pre_post_state_expr: implement this case!\");\n       fail;\n@@ -1397,8 +1369,13 @@ impure fn check_states_expr(fn_info enclosing, &expr e) -> () {\n   let prestate pres   = expr_prestate(e);\n \n   if (!implies(pres, prec)) {\n-    log(\"check_states_expr: unsatisfied precondition\");\n-    fail;\n+      log(\"check_states_stmt: unsatisfied precondition for \");\n+      log_expr(e);\n+      log(\"Precondition: \");\n+      log_bitv(enclosing, prec);\n+      log(\"Prestate: \");\n+      log_bitv(enclosing, pres);\n+      fail;\n   }\n }\n "}, {"sha": "006bccb06832acaa5900dfe3277176d2c3282bf4", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c6e6fc5d49127e868a8323e0619c9c7597b5b18/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6e6fc5d49127e868a8323e0619c9c7597b5b18/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=7c6e6fc5d49127e868a8323e0619c9c7597b5b18", "patch": "@@ -115,14 +115,14 @@ fn plain_ann() -> ast.ann {\n                    none[vec[@middle.ty.t]], none[@ts_ann]);\n }\n \n-fn log_expr(@ast.expr e) -> () {\n+fn log_expr(&ast.expr e) -> () {\n   let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front.lexer.cmnt]],\n                   mutable cur_cmnt=0u);\n \n-  print_expr(out, e);\n+  print_expr(out, @e);\n   log(s.get_str());\n }\n "}, {"sha": "87a97359a57fcb2bbde6e18e0bb2896cd78eaa42", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c6e6fc5d49127e868a8323e0619c9c7597b5b18/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c6e6fc5d49127e868a8323e0619c9c7597b5b18/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=7c6e6fc5d49127e868a8323e0619c9c7597b5b18", "patch": "@@ -251,6 +251,17 @@ fn or(&vec[bool] v) -> bool {\n     be _vec.foldl[bool, bool](f, false, v);\n }\n \n+fn clone[T](&vec[T] v) -> vec[T] {\n+    ret slice[T](v, 0u, len[T](v));\n+}\n+\n+fn plus_option[T](&vec[T] v, &option.t[T] o) -> () {\n+    alt (o) {\n+        case (none[T]) {}\n+        case (some[T](?x)) { v += vec(x); }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}]}