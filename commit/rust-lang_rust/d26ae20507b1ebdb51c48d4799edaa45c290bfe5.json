{"sha": "d26ae20507b1ebdb51c48d4799edaa45c290bfe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNmFlMjA1MDdiMWViZGI1MWM0OGQ0Nzk5ZWRhYTQ1YzI5MGJmZTU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-29T01:48:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-08T11:15:11Z"}, "message": "resolve: Rename some fields related to legacy macro scopes", "tree": {"sha": "a29d39d6abbb269f687dd6c59b53bf446b88c3be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a29d39d6abbb269f687dd6c59b53bf446b88c3be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d26ae20507b1ebdb51c48d4799edaa45c290bfe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d26ae20507b1ebdb51c48d4799edaa45c290bfe5", "html_url": "https://github.com/rust-lang/rust/commit/d26ae20507b1ebdb51c48d4799edaa45c290bfe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d26ae20507b1ebdb51c48d4799edaa45c290bfe5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c057d579abb3a6614e38fa6f93f7f5f22a5e7f13", "url": "https://api.github.com/repos/rust-lang/rust/commits/c057d579abb3a6614e38fa6f93f7f5f22a5e7f13", "html_url": "https://github.com/rust-lang/rust/commit/c057d579abb3a6614e38fa6f93f7f5f22a5e7f13"}], "stats": {"total": 111, "additions": 60, "deletions": 51}, "files": [{"sha": "423817d1be21d519b27d852188626c0aac05fd80", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d26ae20507b1ebdb51c48d4799edaa45c290bfe5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ae20507b1ebdb51c48d4799edaa45c290bfe5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d26ae20507b1ebdb51c48d4799edaa45c290bfe5", "patch": "@@ -950,7 +950,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a, 'c: 'b> {\n     pub resolver: &'a mut Resolver<'b, 'c>,\n-    pub legacy_scope: LegacyScope<'b>,\n+    pub current_legacy_scope: LegacyScope<'b>,\n     pub expansion: Mark,\n }\n \n@@ -960,7 +960,7 @@ impl<'a, 'b, 'cl> BuildReducedGraphVisitor<'a, 'b, 'cl> {\n         self.resolver.current_module.unresolved_invocations.borrow_mut().insert(mark);\n         let invocation = self.resolver.invocations[&mark];\n         invocation.module.set(self.resolver.current_module);\n-        invocation.legacy_scope.set(self.legacy_scope);\n+        invocation.parent_legacy_scope.set(self.current_legacy_scope);\n         invocation\n     }\n }\n@@ -986,29 +986,30 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.resolver.define_macro(item, self.expansion, &mut self.legacy_scope);\n+                self.resolver.define_macro(item, self.expansion, &mut self.current_legacy_scope);\n                 return\n             }\n             ItemKind::Mac(..) => {\n-                self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+                self.current_legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n                 return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n             _ => false,\n         };\n \n-        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n+        let orig_current_module = self.resolver.current_module;\n+        let orig_current_legacy_scope = self.current_legacy_scope;\n         self.resolver.build_reduced_graph_for_item(item, self.expansion);\n         visit::walk_item(self, item);\n-        self.resolver.current_module = parent;\n+        self.resolver.current_module = orig_current_module;\n         if !macro_use {\n-            self.legacy_scope = legacy_scope;\n+            self.current_legacy_scope = orig_current_legacy_scope;\n         }\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a ast::Stmt) {\n         if let ast::StmtKind::Mac(..) = stmt.node {\n-            self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n+            self.current_legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1025,11 +1026,12 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n     }\n \n     fn visit_block(&mut self, block: &'a Block) {\n-        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n+        let orig_current_module = self.resolver.current_module;\n+        let orig_current_legacy_scope = self.current_legacy_scope;\n         self.resolver.build_reduced_graph_for_block(block, self.expansion);\n         visit::walk_block(self, block);\n-        self.resolver.current_module = parent;\n-        self.legacy_scope = legacy_scope;\n+        self.resolver.current_module = orig_current_module;\n+        self.current_legacy_scope = orig_current_legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &'a TraitItem) {"}, {"sha": "baff58ccee3821a63b799e10448d6ef041b740d8", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d26ae20507b1ebdb51c48d4799edaa45c290bfe5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d26ae20507b1ebdb51c48d4799edaa45c290bfe5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d26ae20507b1ebdb51c48d4799edaa45c290bfe5", "patch": "@@ -50,26 +50,37 @@ crate struct FromPrelude(bool);\n \n #[derive(Clone)]\n pub struct InvocationData<'a> {\n-    pub module: Cell<Module<'a>>,\n-    pub def_index: DefIndex,\n-    // The scope in which the invocation path is resolved.\n-    pub legacy_scope: Cell<LegacyScope<'a>>,\n-    // The smallest scope that includes this invocation's expansion,\n-    // or `Empty` if this invocation has not been expanded yet.\n-    pub expansion: Cell<LegacyScope<'a>>,\n+    crate module: Cell<Module<'a>>,\n+    def_index: DefIndex,\n+    // Legacy scope in which the macro was invoked.\n+    // The invocation path is resolved in this scope.\n+    crate parent_legacy_scope: Cell<LegacyScope<'a>>,\n+    // Legacy scope *produced* by expanding this macro invocation,\n+    // includes all the macro_rules items, other invocations, etc generated by it.\n+    // `Empty` is used if for invocations that has not been expanded yet.\n+    output_legacy_scope: Cell<LegacyScope<'a>>,\n }\n \n impl<'a> InvocationData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n         InvocationData {\n             module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n-            legacy_scope: Cell::new(LegacyScope::Empty),\n-            expansion: Cell::new(LegacyScope::Empty),\n+            parent_legacy_scope: Cell::new(LegacyScope::Empty),\n+            output_legacy_scope: Cell::new(LegacyScope::Empty),\n         }\n     }\n }\n \n+// Binding produced by a `macro_rules` item.\n+// Not modularized, can shadow previous legacy bindings, etc.\n+pub struct LegacyBinding<'a> {\n+    binding: &'a NameBinding<'a>,\n+    // Legacy scope into which the `macro_rules` item was planted.\n+    parent_legacy_scope: Cell<LegacyScope<'a>>,\n+    ident: Ident,\n+}\n+\n #[derive(Copy, Clone)]\n pub enum LegacyScope<'a> {\n     Empty,\n@@ -78,14 +89,6 @@ pub enum LegacyScope<'a> {\n     Binding(&'a LegacyBinding<'a>),\n }\n \n-// Binding produced by a `macro_rules` item.\n-// Not modularized, can shadow previous legacy bindings, etc.\n-pub struct LegacyBinding<'a> {\n-    binding: &'a NameBinding<'a>,\n-    parent: Cell<LegacyScope<'a>>,\n-    ident: Ident,\n-}\n-\n pub struct ProcMacError {\n     crate_name: Symbol,\n     name: Symbol,\n@@ -105,8 +108,8 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n-            legacy_scope: Cell::new(LegacyScope::Empty),\n-            expansion: Cell::new(LegacyScope::Empty),\n+            parent_legacy_scope: Cell::new(LegacyScope::Empty),\n+            output_legacy_scope: Cell::new(LegacyScope::Empty),\n         }));\n         mark\n     }\n@@ -178,11 +181,11 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         }\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n-            legacy_scope: LegacyScope::Invocation(invocation),\n+            current_legacy_scope: LegacyScope::Invocation(invocation),\n             expansion: mark,\n         };\n         fragment.visit_with(&mut visitor);\n-        invocation.expansion.set(visitor.legacy_scope);\n+        invocation.output_legacy_scope.set(visitor.current_legacy_scope);\n     }\n \n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n@@ -481,7 +484,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         let legacy_resolution =\n-            self.resolve_legacy_scope(path[0], invoc_id, &invocation.legacy_scope, false);\n+            self.resolve_legacy_scope(path[0], invoc_id, &invocation.parent_legacy_scope, false);\n         let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n         } else {\n@@ -814,18 +817,20 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n             macro_rules! continue_search { () => {\n                 where_to_resolve = match where_to_resolve.get() {\n-                    LegacyScope::Binding(binding) => &binding.parent,\n-                    LegacyScope::Invocation(invocation) => &invocation.legacy_scope,\n-                    LegacyScope::Expansion(invocation) => match invocation.expansion.get() {\n-                        LegacyScope::Empty => &invocation.legacy_scope,\n-                        LegacyScope::Binding(..) |\n-                        LegacyScope::Expansion(..) => &invocation.expansion,\n-                        LegacyScope::Invocation(..) => {\n-                            where_to_resolve.set(invocation.legacy_scope.get());\n-                            where_to_resolve\n+                    LegacyScope::Empty => break, // nowhere else to search\n+                    LegacyScope::Binding(binding) => &binding.parent_legacy_scope,\n+                    LegacyScope::Invocation(invocation) => &invocation.parent_legacy_scope,\n+                    LegacyScope::Expansion(invocation) => {\n+                        match invocation.output_legacy_scope.get() {\n+                            LegacyScope::Empty => &invocation.parent_legacy_scope,\n+                            LegacyScope::Binding(..) |\n+                            LegacyScope::Expansion(..) => &invocation.output_legacy_scope,\n+                            LegacyScope::Invocation(..) => {\n+                                where_to_resolve.set(invocation.parent_legacy_scope.get());\n+                                where_to_resolve\n+                            }\n                         }\n                     }\n-                    LegacyScope::Empty => break, // nowhere else to search\n                 };\n \n                 continue;\n@@ -880,8 +885,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         for &(invoc_id, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n             let span = ident.span;\n-            let legacy_scope = &self.invocations[&invoc_id].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(ident, invoc_id, legacy_scope, true);\n+            let invoc_parent_legacy_scope = &self.invocations[&invoc_id].parent_legacy_scope;\n+            let legacy_resolution =\n+                self.resolve_legacy_scope(ident, invoc_id, invoc_parent_legacy_scope, true);\n             let resolution = self.resolve_lexical_macro_path_segment(\n                 ident, MacroNS, invoc_id, true, true, kind == MacroKind::Attr, span\n             );\n@@ -1007,8 +1013,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 arenas.alloc_invocation_data(InvocationData {\n                     def_index: invoc.def_index,\n                     module: Cell::new(graph_root),\n-                    expansion: Cell::new(LegacyScope::Empty),\n-                    legacy_scope: Cell::new(LegacyScope::Empty),\n+                    parent_legacy_scope: Cell::new(LegacyScope::Empty),\n+                    output_legacy_scope: Cell::new(LegacyScope::Empty),\n                 })\n             });\n         };\n@@ -1023,7 +1029,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn define_macro(&mut self,\n                         item: &ast::Item,\n                         expansion: Mark,\n-                        legacy_scope: &mut LegacyScope<'a>) {\n+                        current_legacy_scope: &mut LegacyScope<'a>) {\n         self.local_macro_def_scopes.insert(item.id, self.current_module);\n         let ident = item.ident;\n         if ident.name == \"macro_rules\" {\n@@ -1043,9 +1049,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let def = Def::Macro(def_id, MacroKind::Bang);\n             let vis = ty::Visibility::Invisible; // Doesn't matter for legacy bindings\n             let binding = (def, vis, item.span, expansion).to_name_binding(self.arenas);\n-            *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(\n-                LegacyBinding { parent: Cell::new(*legacy_scope), binding, ident }\n-            ));\n+            let legacy_binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent_legacy_scope: Cell::new(*current_legacy_scope), binding, ident\n+            });\n+            *current_legacy_scope = LegacyScope::Binding(legacy_binding);\n             self.all_macros.insert(ident.name, def);\n             if attr::contains_name(&item.attrs, \"macro_export\") {\n                 let module = self.graph_root;"}]}