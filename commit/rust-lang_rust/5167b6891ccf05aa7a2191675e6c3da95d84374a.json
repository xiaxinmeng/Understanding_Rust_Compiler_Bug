{"sha": "5167b6891ccf05aa7a2191675e6c3da95d84374a", "node_id": "C_kwDOAAsO6NoAKDUxNjdiNjg5MWNjZjA1YWE3YTIxOTE2NzVlNmMzZGE5NWQ4NDM3NGE", "commit": {"author": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-22T05:27:28Z"}, "committer": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-30T00:16:34Z"}, "message": "Introduce experimental APIs for conforming to \"strict provenance\".\n\nThis patch series examines the question: how bad would it be if we adopted\nan extremely strict pointer provenance model that completely banished all\nint<->ptr casts.\n\nThe key insight to making this approach even *vaguely* pallatable is the\n\nptr.with_addr(addr) -> ptr\n\nfunction, which takes a pointer and an address and creates a new pointer\nwith that address and the provenance of the input pointer. In this way\nthe \"chain of custody\" is completely and dynamically restored, making the\nmodel suitable even for dynamic checkers like CHERI and Miri.\n\nThis is not a formal model, but lots of the docs discussing the model\nhave been updated to try to the *concept* of this design in the hopes\nthat it can be iterated on.", "tree": {"sha": "4fa1e0a70903ebadad05cae2e6fbd6b2df35efe6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fa1e0a70903ebadad05cae2e6fbd6b2df35efe6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5167b6891ccf05aa7a2191675e6c3da95d84374a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5167b6891ccf05aa7a2191675e6c3da95d84374a", "html_url": "https://github.com/rust-lang/rust/commit/5167b6891ccf05aa7a2191675e6c3da95d84374a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5167b6891ccf05aa7a2191675e6c3da95d84374a/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c06e1ba47e1077725a950e0b5d1870a89c8b536", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c06e1ba47e1077725a950e0b5d1870a89c8b536", "html_url": "https://github.com/rust-lang/rust/commit/9c06e1ba47e1077725a950e0b5d1870a89c8b536"}], "stats": {"total": 410, "additions": 400, "deletions": 10}, "files": [{"sha": "617f92e135afb78f59bac8bf96f080054d7c3249", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5167b6891ccf05aa7a2191675e6c3da95d84374a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5167b6891ccf05aa7a2191675e6c3da95d84374a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=5167b6891ccf05aa7a2191675e6c3da95d84374a", "patch": "@@ -150,6 +150,75 @@ impl<T: ?Sized> *const T {\n         bits as Self\n     }\n \n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This is equivalent to `self as usize`, which semantically discards\n+    /// *provenance* and *address-space* information. To properly restore that information,\n+    /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    ///\n+    /// On most platforms this information isn't represented at runtime, and so the loss\n+    /// of information is \"only\" semantic. On more complicated platforms like miri, CHERI,\n+    /// and segmented architectures, this may result in an actual change of representation\n+    /// and the loss of information.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn addr(self) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        self as usize\n+    }\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as an `addr as ptr` cast, but copies\n+    /// the *address-space* and *provenance* of `self` to the new pointer.\n+    /// This allows us to dynamically preserve and propagate this important\n+    /// information in a way that is otherwise impossible with a unary cast.\n+    ///\n+    /// This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset `self` to the\n+    /// given address, and therefore has all the same capabilities and restrictions.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn with_addr(self, addr: usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        let self_addr = self.addr() as isize;\n+        let dest_addr = addr as isize;\n+        let offset = dest_addr.wrapping_sub(self_addr);\n+\n+        // This is the canonical desugarring of this operation\n+        self.cast::<u8>().wrapping_offset(offset).cast::<T>()\n+    }\n+\n+    /// Creates a new pointer by mapping `self`'s address to a new one.\n+    ///\n+    /// This is a convenience for [`with_addr`][pointer::with_addr], see that method for details.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        self.with_addr(f(self.addr()))\n+    }\n+\n     /// Decompose a (possibly wide) pointer into its address and metadata components.\n     ///\n     /// The pointer can be later reconstructed with [`from_raw_parts`].\n@@ -1006,7 +1075,7 @@ impl<T> *const [T] {\n     /// use std::ptr;\n     ///\n     /// let slice: *const [i8] = ptr::slice_from_raw_parts(ptr::null(), 3);\n-    /// assert_eq!(slice.as_ptr(), 0 as *const i8);\n+    /// assert_eq!(slice.as_ptr(), ptr::null());\n     /// ```\n     #[inline]\n     #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]"}, {"sha": "3e8efc96c88f478ae8bc0766ab6ed4e12636b8f4", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 260, "deletions": 8, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/5167b6891ccf05aa7a2191675e6c3da95d84374a/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5167b6891ccf05aa7a2191675e6c3da95d84374a/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=5167b6891ccf05aa7a2191675e6c3da95d84374a", "patch": "@@ -63,12 +63,212 @@\n //! separate allocated object), heap allocations (each allocation created by the global allocator is\n //! a separate allocated object), and `static` variables.\n //!\n+//!\n+//! # Strict Provenance\n+//!\n+//! This section is *non-normative* and describes an experimental set of APIs that help tools\n+//! that validate the memory-safety of your program's execution. Notably this includes [miri][]\n+//! and [CHERI][], which can detect when you access out of bounds memory or otherwise violate\n+//! Rust's memory model.\n+//!\n+//! **The following text is overly strict and insufficiently formal, and is an extremely\n+//! strict interpretation of provenance.** Provenance must exist in some form for any language\n+//! higher-level than an assembler, but to our knowledge no one has ever been able to square\n+//! the notion of provenance with all the operations that programmers believe should be permitted.\n+//! The [Strict Provenance][] experiment seeks to explore the question: *what if we just said you\n+//! couldn't do all the nasty operations that make provenance so messy?*\n+//!\n+//! What APIs would have to be removed? What APIs would have to be added? How much would code\n+//! have to change, and is it worse or better now? Would any patterns become truly inexpressible?\n+//! Could we carve out special exceptions for those patterns?\n+//!\n+//!\n+//! ## Provenance\n+//!\n+//! **This section is *non-normative* and is part of the [Strict Provenance][] experiment.**\n+//!\n+//! Pointers are not *simply* an \"integer\" or \"address\". For instance, it's uncontroversial\n+//! to say that a Use After Free is clearly Undefined Behaviour, even if you \"get lucky\"\n+//! and the freed memory gets reallocated before your read/write (in fact this is the\n+//! worst-case scenario, UAFs would be much less concerning if this didn't happen!).\n+//! To rationalize this claim, pointers need to somehow be *more* than just their addresses:\n+//! they must have provenance.\n+//!\n+//! When an allocation is created, that allocation has a unique Original Pointer. For alloc\n+//! APIs this is literally the pointer the call returns, and for variables declarations this\n+//! is the name of the variable. This is mildly overloading the term \"pointer\" for the sake\n+//! of brevity/exposition.\n+//!\n+//! The Original Pointer for an allocation is guaranteed to have unique access to the entire\n+//! allocation and *only* that allocation. In this sense, an allocation can be thought of\n+//! as a \"sandbox\" that cannot be broken into or out of. *Provenance* is the permission\n+//! to access an allocation's sandbox and consists of:\n+//!\n+//! * Some kind of globally unique identifier tied to the allocation itself.\n+//! * A range of bytes in the allocation that the pointer is allowed to access.\n+//!\n+//! Provenance is implicitly shared with all pointers transitively derived from\n+//! The Original Pointer through operations like [`offset`], borrowing, and pointer casts.\n+//! Some operations may produce a pointer whose provenance has a smaller range\n+//! than the one it's derived from (i.e. borrowing a subfield and subslicing).\n+//!\n+//! Shrinking provenance cannot be undone: even if you \"know\" there is a larger allocation, you\n+//! can't derive a pointer with a larger provenance. Similarly, you cannot \"recombine\"\n+//! two contiguous provenances back into one (i.e. with a `fn merge(&[T], &[T]) -> &[T]`).\n+//!\n+//! A reference to a value always has provenance over exactly the memory that field occupies.\n+//! A reference slice always has provenance over exactly the range that slice describes.\n+//!\n+//! If an allocation is deallocated, all pointers with provenance to that allocation become\n+//! invalidated, and effectively lose their provenance.\n+//!\n+//!\n+//! ## Pointer Vs Addresses\n+//!\n+//! **This section is *non-normative* and is part of the [Strict Provenance][] experiment.**\n+//!\n+//! One of the largest historical issues with trying to define provenance is that programmers\n+//! freely convert between pointers and integers. Once you allow for this, it generally becomes\n+//! impossible to accurately track and preserve provenance information, and you need to appeal\n+//! to very complex and unreliable heuristics. But of course, converting between pointers and\n+//! integers is very useful, so what can we do?\n+//!\n+//! Strict Provenance attempts to square this circle by decoupling Rust's traditional conflation\n+//! of pointers and `usize` (and `isize`), defining a pointer to semantically contain the following\n+//! information:\n+//!\n+//! * The **address-space** it is part of.\n+//! * The **address** it points to, which can be represented by a `usize`.\n+//! * The **provenance** it has, defining the memory it has permission to access.\n+//!\n+//! Under Strict Provenance, a usize *cannot* accurately represent a pointer, and converting from\n+//! a pointer to a usize is generally an operation which *only* extracts the address. It is\n+//! therefore *impossible* to construct a valid pointer from a usize because there is no way\n+//! to restore the address-space and provenance.\n+//!\n+//! The key insight to making this model *at all* viable is the [`with_addr`][] method:\n+//!\n+//! ```text\n+//!     /// Creates a new pointer with the given address.\n+//!     ///\n+//!     /// This performs the same operation as an `addr as ptr` cast, but copies\n+//!     /// the *address-space* and *provenance* of `self` to the new pointer.\n+//!     /// This allows us to dynamically preserve and propagate this important\n+//!     /// information in a way that is otherwise impossible with a unary cast.\n+//!     ///\n+//!     /// This is equivalent to using `wrapping_offset` to offset `self` to the\n+//!     /// given address, and therefore has all the same capabilities and restrictions.\n+//!     pub fn with_addr(self, addr: usize) -> Self;\n+//! ```\n+//!\n+//! So you're still able to drop down to the address representation and do whatever\n+//! clever bit tricks you want *as long as* you're able to keep around a pointer\n+//! into the allocation you care about that can \"reconstitute\" the other parts of the pointer.\n+//! Usually this is very easy, because you only are taking a pointer, messing with the address,\n+//! and then immediately converting back to a pointer. To make this use case more ergonomic,\n+//! we provide the [`map_addr`][] method.\n+//!\n+//! To help make it clear that code is \"following\" Strict Provenance semantics, we also\n+//! provide an [`addr`][] method which is currently equivalent to `ptr as usize`. In the\n+//! future we may provide a lint for pointer<->integer casts to help you audit if your\n+//! code conforms to strict provenance.\n+//!\n+//!\n+//! ## Using Strict Provenance\n+//!\n+//! Most code needs no changes to conform to strict provenance, as the only really concerning\n+//! operation that *wasn't* obviously already Undefined Behaviour is casts from usize to a\n+//! pointer. For code which *does* cast a usize to a pointer, the scope of the change depends\n+//! on exactly what you're doing.\n+//!\n+//! In general you just need to make sure that if you want to convert a usize address to a\n+//! pointer and then use that pointer to read/write memory, you need to keep around a pointer\n+//! that has sufficient provenance to perform that read/write itself. In this way all of your\n+//! casts from an address to a pointer are essentially just applying offsets/indexing.\n+//!\n+//! This is generally trivial to do for simple cases like tagged pointers *as long as you\n+//! represent the tagged pointer as an actual pointer and not a usize*. For instance:\n+//!\n+//! ```\n+//! #![feature(strict_provenance)]\n+//!\n+//! unsafe {\n+//!     // A flag we want to pack into our pointer\n+//!     static HAS_DATA: usize = 0x1;\n+//!     static FLAG_MASK: usize = !HAS_DATA;\n+//!\n+//!     // Our value, which must have enough alignment to have spare least-significant-bits.\n+//!     let my_precious_data: u32 = 17;\n+//!     assert!(core::mem::align_of::<u32>() > 1);\n+//!\n+//!     // Create a tagged pointer\n+//!     let ptr = &my_precious_data as *const u32;\n+//!     let tagged = ptr.map_addr(|addr| addr | HAS_DATA);\n+//!\n+//!     // Check the flag:\n+//!     if tagged.addr() & HAS_DATA != 0 {\n+//!         // Untag and read the pointer\n+//!         let data = *tagged.map_addr(|addr| addr & FLAG_MASK);\n+//!         assert_eq!(data, 17);\n+//!     } else {\n+//!         unreachable!()\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! Something more complicated and just generally *evil* like a XOR-List requires more significant\n+//! changes like allocating all nodes in a pre-allocated Vec or Arena and using a pointer\n+//! to the whole allocation to reconstitute the XORed addresses.\n+//!\n+//! Situations where a valid pointer *must* be created from just an address, such as baremetal code\n+//! accessing a memory-mapped interface at a fixed address, are an open question on how to support.\n+//! These situations *will* still be allowed, but we might require some kind of \"I know what I'm\n+//! doing\" annotation to explain the situation to the compiler. Because those situations require\n+//! `volatile` accesses anyway, it should be possible to carve out exceptions for them.\n+//!\n+//! Under [Strict Provenance] is is Undefined Behaviour to:\n+//!\n+//! * Access memory through a pointer that does not have provenance over that memory.\n+//!\n+//! * [`offset`] a pointer to an address it doesn't have provenance over.\n+//!   This means it's always UB to offset a pointer derived from something deallocated,\n+//!   even if the offset is 0. Note that a pointer \"one past the end\" of its provenance\n+//!   is not actually outside its provenance, it just has 0 bytes it can load/store.\n+//!\n+//! But it *is* still sound to:\n+//!\n+//! * Create an invalid pointer from just an address (see [`ptr::invalid`][]). This can\n+//!   be used for sentinel values like `null` *or* to represent a tagged pointer that will\n+//!   never be dereferencable.\n+//!\n+//! * [`wrapping_offset`][] a pointer outside its provenance. This includes invalid pointers\n+//!   which have no provenance. Unfortunately there may be practical limits on this for a\n+//!   particular platform ([CHERI][] may mark your pointers as invalid, but it has a pretty\n+//!   generour buffer that is *at least* 1KB on each side of the provenance). Note that\n+//!   least-significant-bit tagging is generally pretty robust, and often doesn't even\n+//!   go out of bounds because types have a size >= align.\n+//!\n+//! * Forge an allocation of size zero at any sufficiently aligned non-null address.\n+//!   i.e. the usual \"ZSTs are fake, do what you want\" rules apply *but* this only applies\n+//!   for actual forgery (integers cast to pointers). If you borrow some structs subfield\n+//!   that *happens* to be zero-sized, the resulting pointer will have provenance tied to\n+//!   that allocation and it will still get invalidated if the allocation gets deallocated.\n+//!   In the future we may introduce an API to make such a forged allocation explicit.\n+//!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html\n //! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n //! [atomic operations]: crate::sync::atomic\n //! [`offset`]: pointer::offset\n+//! [`wrapping_offset`]: pointer::offset\n+//! [`with_addr`]: pointer::with_addr\n+//! [`map_addr`]: pointer::map_addr\n+//! [`addr`]: pointer::addr\n+//! [`ptr::invalid`]: core::ptr::invalid\n+//! [miri]: https://github.com/rust-lang/miri\n+//! [CHERI]: https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/\n+//! [Strict Provenance]: https://github.com/rust-lang/rust/issues/95228\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -210,7 +410,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.24.0\")]\n #[rustc_diagnostic_item = \"ptr_null\"]\n pub const fn null<T>() -> *const T {\n-    0 as *const T\n+    invalid::<T>(0)\n }\n \n /// Creates a null mutable raw pointer.\n@@ -230,7 +430,55 @@ pub const fn null<T>() -> *const T {\n #[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.24.0\")]\n #[rustc_diagnostic_item = \"ptr_null_mut\"]\n pub const fn null_mut<T>() -> *mut T {\n-    0 as *mut T\n+    invalid_mut::<T>(0)\n+}\n+\n+/// Creates an invalid pointer with the given address.\n+///\n+/// This is *currently* equivalent to `addr as *const T` but it expresses the intended semantic\n+/// more clearly, and may become important under future memory models.\n+///\n+/// The module's to-level documentation discusses the precise meaning of an \"invalid\"\n+/// pointer but essentially this expresses that the pointer is not associated\n+/// with any actual allocation and is little more than a usize address in disguise.\n+///\n+/// This pointer will have no provenance associated with it and is therefore\n+/// UB to read/write/offset. This mostly exists to facilitate things\n+/// like ptr::null and NonNull::dangling which make invalid pointers.\n+///\n+/// This API and its claimed semantics are part of the Strict Provenance experiment,\n+/// see the [module documentation][crate::ptr] for details.\n+#[inline(always)]\n+#[must_use]\n+#[rustc_const_stable(feature = \"strict_provenance\", since = \"1.61.0\")]\n+#[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+pub const fn invalid<T>(addr: usize) -> *const T {\n+    // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+    addr as *const T\n+}\n+\n+/// Creates an invalid mutable pointer with the given address.\n+///\n+/// This is *currently* equivalent to `addr as *const T` but it expresses the intended semantic\n+/// more clearly, and may become important under future memory models.\n+///\n+/// The module's to-level documentation discusses the precise meaning of an \"invalid\"\n+/// pointer but essentially this expresses that the pointer is not associated\n+/// with any actual allocation and is little more than a usize address in disguise.\n+///\n+/// This pointer will have no provenance associated with it and is therefore\n+/// UB to read/write/offset. This mostly exists to facilitate things\n+/// like ptr::null and NonNull::dangling which make invalid pointers.\n+///\n+/// This API and its claimed semantics are part of the Strict Provenance experiment,\n+/// see the [module documentation][crate::ptr] for details.\n+#[inline(always)]\n+#[must_use]\n+#[rustc_const_stable(feature = \"strict_provenance\", since = \"1.61.0\")]\n+#[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+pub const fn invalid_mut<T>(addr: usize) -> *mut T {\n+    // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+    addr as *mut T\n }\n \n /// Forms a raw slice from a pointer and a length.\n@@ -1110,6 +1358,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         unchecked_shl, unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n     };\n \n+    let addr = p.addr();\n+\n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n     ///\n     /// This implementation is tailored for `align_offset` and has following preconditions:\n@@ -1170,13 +1420,10 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         //\n         // which distributes operations around the load-bearing, but pessimizing `and` sufficiently\n         // for LLVM to be able to utilize the various optimizations it knows about.\n-        return wrapping_sub(\n-            wrapping_add(p as usize, a_minus_one) & wrapping_sub(0, a),\n-            p as usize,\n-        );\n+        return wrapping_sub(wrapping_add(addr, a_minus_one) & wrapping_sub(0, a), addr);\n     }\n \n-    let pmoda = p as usize & a_minus_one;\n+    let pmoda = addr & a_minus_one;\n     if pmoda == 0 {\n         // Already aligned. Yay!\n         return 0;\n@@ -1193,7 +1440,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n \n     // SAFETY: gcd is always greater or equal to 1.\n-    if p as usize & unsafe { unchecked_sub(gcd, 1) } == 0 {\n+    if addr & unsafe { unchecked_sub(gcd, 1) } == 0 {\n         // This branch solves for the following linear congruence equation:\n         //\n         // ` p + so = 0 mod a `\n@@ -1347,6 +1594,11 @@ pub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n     hashee.hash(into);\n }\n \n+// FIXME(strict_provenance_magic): function pointers have buggy codegen that\n+// necessitates casting to a usize to get the backend to do the right thing.\n+// for now I will break AVR to silence *a billion* lints. We should probably\n+// have a proper \"opaque function pointer type\" to handle this kind of thing.\n+\n // Impls for function pointers\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {"}, {"sha": "ead96147b526b2d80608a54e2a176558816767c4", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5167b6891ccf05aa7a2191675e6c3da95d84374a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5167b6891ccf05aa7a2191675e6c3da95d84374a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=5167b6891ccf05aa7a2191675e6c3da95d84374a", "patch": "@@ -154,6 +154,75 @@ impl<T: ?Sized> *mut T {\n         bits as Self\n     }\n \n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This is equivalent to `self as usize`, which semantically discards\n+    /// *provenance* and *address-space* information. To properly restore that information,\n+    /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    ///\n+    /// On most platforms this information isn't represented at runtime, and so the loss\n+    /// of information is \"only\" semantic. On more complicated platforms like miri, CHERI,\n+    /// and segmented architectures, this may result in an actual change of representation\n+    /// and the loss of information.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn addr(self) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        self as usize\n+    }\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as an `addr as ptr` cast, but copies\n+    /// the *address-space* and *provenance* of `self` to the new pointer.\n+    /// This allows us to dynamically preserve and propagate this important\n+    /// information in a way that is otherwise impossible with a unary cast.\n+    ///\n+    /// This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset `self` to the\n+    /// given address, and therefore has all the same capabilities and restrictions.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn with_addr(self, addr: usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        let self_addr = self.addr() as isize;\n+        let dest_addr = addr as isize;\n+        let offset = dest_addr.wrapping_sub(self_addr);\n+\n+        // This is the canonical desugarring of this operation\n+        self.cast::<u8>().wrapping_offset(offset).cast::<T>()\n+    }\n+\n+    /// Creates a new pointer by mapping `self`'s address to a new one.\n+    ///\n+    /// This is a convenience for [`with_addr`][pointer::with_addr], see that method for details.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n+    /// see the [module documentation][crate::ptr] for details.\n+    #[must_use]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        self.with_addr(f(self.addr()))\n+    }\n+\n     /// Decompose a (possibly wide) pointer into its address and metadata components.\n     ///\n     /// The pointer can be later reconstructed with [`from_raw_parts_mut`].\n@@ -1276,7 +1345,7 @@ impl<T> *mut [T] {\n     /// use std::ptr;\n     ///\n     /// let slice: *mut [i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 3);\n-    /// assert_eq!(slice.as_mut_ptr(), 0 as *mut i8);\n+    /// assert_eq!(slice.as_mut_ptr(), ptr::null_mut());\n     /// ```\n     #[inline(always)]\n     #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]"}]}