{"sha": "b671c32ddc8c36d50866428d83b7716233356721", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NzFjMzJkZGM4YzM2ZDUwODY2NDI4ZDgzYjc3MTYyMzMzNTY3MjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-01T07:57:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-01T07:57:09Z"}, "message": "Auto merge of #40167 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 6 pull requests\n\n- Successful merges: #39419, #39936, #39944, #39960, #40028, #40128\n- Failed merges:", "tree": {"sha": "be000760e8ca562315bf3a95faf32a16bd1c51c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be000760e8ca562315bf3a95faf32a16bd1c51c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b671c32ddc8c36d50866428d83b7716233356721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b671c32ddc8c36d50866428d83b7716233356721", "html_url": "https://github.com/rust-lang/rust/commit/b671c32ddc8c36d50866428d83b7716233356721", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b671c32ddc8c36d50866428d83b7716233356721/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ce1fbe1f7fe5cdbec57377d76306e2bc7811bce", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ce1fbe1f7fe5cdbec57377d76306e2bc7811bce", "html_url": "https://github.com/rust-lang/rust/commit/7ce1fbe1f7fe5cdbec57377d76306e2bc7811bce"}, {"sha": "0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5bf6744900cdb3bcb82ab35dc760220dd001c6", "html_url": "https://github.com/rust-lang/rust/commit/0b5bf6744900cdb3bcb82ab35dc760220dd001c6"}], "stats": {"total": 1290, "additions": 759, "deletions": 531}, "files": [{"sha": "e4b94a1d70ee4189fe3ce610721aa52cf0bd096c", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -14,7 +14,7 @@\n \n //! Range syntax.\n \n-use core::ops::{RangeFull, Range, RangeTo, RangeFrom};\n+use core::ops::{RangeFull, Range, RangeTo, RangeFrom, RangeInclusive, RangeToInclusive};\n use Bound::{self, Excluded, Included, Unbounded};\n \n /// **RangeArgument** is implemented by Rust's built-in range types, produced\n@@ -105,6 +105,32 @@ impl<T> RangeArgument<T> for Range<T> {\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> RangeArgument<T> for RangeInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        match *self {\n+            RangeInclusive::Empty{ ref at }            => Included(at),\n+            RangeInclusive::NonEmpty { ref start, .. } => Included(start),\n+        }\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        match *self {\n+            RangeInclusive::Empty{ ref at }            => Excluded(at),\n+            RangeInclusive::NonEmpty { ref end, .. }   => Included(end),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> RangeArgument<T> for RangeToInclusive<T> {\n+    fn start(&self) -> Bound<&T> {\n+        Unbounded\n+    }\n+    fn end(&self) -> Bound<&T> {\n+        Included(&self.end)\n+    }\n+}\n+\n impl<T> RangeArgument<T> for (Bound<T>, Bound<T>) {\n     fn start(&self) -> Bound<&T> {\n         match *self {"}, {"sha": "4b37aef860d7212e38d500aa3061040cb76efa4d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -1483,6 +1483,15 @@ impl FromIterator<char> for String {\n     }\n }\n \n+#[stable(feature = \"string_from_iter_by_ref\", since = \"1.17.0\")]\n+impl<'a> FromIterator<&'a char> for String {\n+    fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> String {\n+        let mut buf = String::new();\n+        buf.extend(iter);\n+        buf\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n     fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> String {"}, {"sha": "2c899d96940ece9e222adc3ff21600f7f164c708", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -178,6 +178,43 @@ fn test_range_small() {\n     assert_eq!(j, size - 2);\n }\n \n+#[test]\n+fn test_range_inclusive() {\n+    let size = 500;\n+\n+    let map: BTreeMap<_, _> = (0...size).map(|i| (i, i)).collect();\n+\n+    fn check<'a, L, R>(lhs: L, rhs: R)\n+        where L: IntoIterator<Item=(&'a i32, &'a i32)>,\n+              R: IntoIterator<Item=(&'a i32, &'a i32)>,\n+    {\n+        let lhs: Vec<_> = lhs.into_iter().collect();\n+        let rhs: Vec<_> = rhs.into_iter().collect();\n+        assert_eq!(lhs, rhs);\n+    }\n+\n+    check(map.range(size + 1...size + 1), vec![]);\n+    check(map.range(size...size), vec![(&size, &size)]);\n+    check(map.range(size...size + 1), vec![(&size, &size)]);\n+    check(map.range(0...0), vec![(&0, &0)]);\n+    check(map.range(0...size - 1), map.range(..size));\n+    check(map.range(-1...-1), vec![]);\n+    check(map.range(-1...size), map.range(..));\n+    check(map.range(...size), map.range(..));\n+    check(map.range(...200), map.range(..201));\n+    check(map.range(5...8), vec![(&5, &5), (&6, &6), (&7, &7), (&8, &8)]);\n+    check(map.range(-1...0), vec![(&0, &0)]);\n+    check(map.range(-1...2), vec![(&0, &0), (&1, &1), (&2, &2)]);\n+}\n+\n+#[test]\n+fn test_range_inclusive_max_value() {\n+    let max = ::std::usize::MAX;\n+    let map: BTreeMap<_, _> = vec![(max, 0)].into_iter().collect();\n+\n+    assert_eq!(map.range(max...max).collect::<Vec<_>>(), &[(&max, &0)]);\n+}\n+\n #[test]\n fn test_range_equal_empty_cases() {\n     let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();"}, {"sha": "849d2401691691eb013d0e57736fd29db0d5a496", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -14,6 +14,7 @@\n #![feature(binary_heap_peek_mut_pop)]\n #![feature(box_syntax)]\n #![feature(btree_range)]\n+#![feature(inclusive_range_syntax)]\n #![feature(collection_placement)]\n #![feature(collections)]\n #![feature(collections_bound)]"}, {"sha": "06d70800d392560e8c99e44fd65edc878c95a114", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -507,6 +507,56 @@ fn test_drain_range() {\n     assert_eq!(v, &[(), ()]);\n }\n \n+#[test]\n+fn test_drain_inclusive_range() {\n+    let mut v = vec!['a', 'b', 'c', 'd', 'e'];\n+    for _ in v.drain(1...3) {\n+    }\n+    assert_eq!(v, &['a', 'e']);\n+\n+    let mut v: Vec<_> = (0...5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(1...5) {\n+    }\n+    assert_eq!(v, &[\"0\".to_string()]);\n+\n+    let mut v: Vec<String> = (0...5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(0...5) {\n+    }\n+    assert_eq!(v, Vec::<String>::new());\n+\n+    let mut v: Vec<_> = (0...5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(0...3) {\n+    }\n+    assert_eq!(v, &[\"4\".to_string(), \"5\".to_string()]);\n+\n+    let mut v: Vec<_> = (0...1).map(|x| x.to_string()).collect();\n+    for _ in v.drain(...0) {\n+    }\n+    assert_eq!(v, &[\"1\".to_string()]);\n+}\n+\n+#[test]\n+fn test_drain_max_vec_size() {\n+    let mut v = Vec::<()>::with_capacity(usize::max_value());\n+    unsafe { v.set_len(usize::max_value()); }\n+    for _ in v.drain(usize::max_value() - 1..) {\n+    }\n+    assert_eq!(v.len(), usize::max_value() - 1);\n+\n+    let mut v = Vec::<()>::with_capacity(usize::max_value());\n+    unsafe { v.set_len(usize::max_value()); }\n+    for _ in v.drain(usize::max_value() - 1...usize::max_value() - 1) {\n+    }\n+    assert_eq!(v.len(), usize::max_value() - 1);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_drain_inclusive_out_of_bounds() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    v.drain(5...5);\n+}\n+\n #[test]\n fn test_into_boxed_slice() {\n     let xs = vec![1, 2, 3];"}, {"sha": "21139c8dde2a4b34b96c22becfc1b483728c9dfb", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "renamed", "additions": 8, "deletions": 462, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -55,32 +55,25 @@\n //! ported to this system, and which relies on string concatenation at the\n //! time of error detection.\n \n-use super::InferCtxt;\n-use super::TypeTrace;\n-use super::SubregionOrigin;\n-use super::RegionVariableOrigin;\n-use super::ValuePairs;\n-use super::region_inference::RegionResolutionError;\n-use super::region_inference::ConcreteFailure;\n-use super::region_inference::SubSupConflict;\n-use super::region_inference::GenericBoundFailure;\n-use super::region_inference::GenericKind;\n+use infer;\n+use super::{InferCtxt, TypeTrace, SubregionOrigin, RegionVariableOrigin, ValuePairs};\n+use super::region_inference::{RegionResolutionError, ConcreteFailure, SubSupConflict,\n+                              GenericBoundFailure, GenericKind};\n \n-use hir::map as hir_map;\n+use std::fmt;\n use hir;\n-\n+use hir::map as hir_map;\n use hir::def_id::DefId;\n-use infer;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, Issue32330};\n use ty::error::TypeError;\n-\n-use std::fmt;\n use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n+mod note;\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n@@ -584,289 +577,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin<'tcx>,\n-                               sub: &'tcx Region,\n-                               sup: &'tcx Region)\n-                                -> DiagnosticBuilder<'tcx> {\n-        match origin {\n-            infer::Subtype(trace) => {\n-                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                self.report_and_explain_type_error(trace, &terr)\n-            }\n-            infer::Reborrow(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n-                    \"lifetime of reference outlives \\\n-                     lifetime of borrowed content...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the reference is valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...but the borrowed content is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0313,\n-                    \"lifetime of borrowed pointer outlives \\\n-                            lifetime of captured variable `{}`...\",\n-                            self.tcx.local_var_name_str(upvar_id.var_id));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the borrowed pointer is valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    &format!(\"...but `{}` is only valid for \",\n-                             self.tcx.local_var_name_str(upvar_id.var_id)),\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::InfStackClosure(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0314,\n-                    \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...the closure must be valid for \",\n-                    sub,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"...but the closure's stack frame is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::InvokeClosure(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0315,\n-                    \"cannot invoke closure outside of its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the closure is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::DerefPointer(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0473,\n-                          \"dereference of reference outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the reference is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::FreeVariable(span, id) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0474,\n-                          \"captured variable `{}` does not outlive the enclosing closure\",\n-                          self.tcx.local_var_name_str(id));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"captured variable is valid for \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"closure is valid for \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::IndexSlice(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0475,\n-                          \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the slice is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateObjectBound(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0476,\n-                          \"lifetime of the source pointer does not outlive \\\n-                           lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"source pointer is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateParamBound(span, ty) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0477,\n-                          \"the type `{}` does not fulfill the required lifetime\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                        \"type must outlive \",\n-                                        sub,\n-                                        \"\");\n-                err\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0478,\n-                          \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"lifetime parameter instantiated with \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"but lifetime parameter must outlive \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::RelateDefaultParamBound(span, ty) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0479,\n-                          \"the type `{}` (provided as the value of \\\n-                           a type parameter) is not valid at this point\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                                        \"type must outlive \",\n-                                        sub,\n-                                        \"\");\n-                err\n-            }\n-            infer::CallRcvr(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0480,\n-                          \"lifetime of method receiver does not outlive \\\n-                           the method call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the receiver is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CallArg(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0481,\n-                          \"lifetime of function argument does not outlive \\\n-                           the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the function argument is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CallReturn(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0482,\n-                          \"lifetime of return value does not outlive \\\n-                           the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the return value is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::Operand(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0483,\n-                          \"lifetime of operand does not outlive \\\n-                           the operation\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the operand is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::AddrOf(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0484,\n-                          \"reference is not valid at the time of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the borrow is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::AutoBorrow(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0485,\n-                          \"automatically reference is not valid \\\n-                           at the time of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the automatic borrow is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0486,\n-                          \"type of expression contains references \\\n-                           that are not valid during the expression: `{}`\",\n-                          self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"type is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::SafeDestructor(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0487,\n-                          \"unsafe use of destructor: destructor might be called \\\n-                           while references are dead\");\n-                // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"superregion: \",\n-                    sup,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"subregion: \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0488,\n-                          \"lifetime of variable does not enclose its declaration\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the variable is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0489,\n-                          \"type/lifetime parameter not in scope here\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the parameter is only valid for \",\n-                    sub,\n-                    \"\");\n-                err\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0490,\n-                          \"a value of type `{}` is borrowed for too long\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n-                err\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                let mut err = struct_span_err!(self.tcx.sess, span, E0491,\n-                          \"in type `{}`, reference has a longer lifetime \\\n-                           than the data it references\",\n-                          self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n-                    \"but the referenced data is only valid for \",\n-                    sup,\n-                    \"\");\n-                err\n-            }\n-            infer::CompareImplMethodObligation { span,\n-                                                 item_name,\n-                                                 impl_item_def_id,\n-                                                 trait_item_def_id,\n-                                                 lint_id } => {\n-                self.report_extra_impl_obligation(span,\n-                                                  item_name,\n-                                                  impl_item_def_id,\n-                                                  trait_item_def_id,\n-                                                  &format!(\"`{}: {}`\", sup, sub),\n-                                                  lint_id)\n-            }\n-        }\n-    }\n-\n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n@@ -939,170 +649,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                    due to conflicting requirements\",\n                   var_description)\n     }\n-\n-    fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n-        match *origin {\n-            infer::Subtype(ref trace) => {\n-                if let Some((expected, found)) = self.values_str(&trace.values) {\n-                    // FIXME: do we want a \"the\" here?\n-                    err.span_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {} (expected {}, found {})\",\n-                                 trace.cause.as_requirement_str(), expected, found));\n-                } else {\n-                    // FIXME: this really should be handled at some earlier stage. Our\n-                    // handling of region checking when type errors are present is\n-                    // *terrible*.\n-\n-                    err.span_note(\n-                        trace.cause.span,\n-                        &format!(\"...so that {}\",\n-                                 trace.cause.as_requirement_str()));\n-                }\n-            }\n-            infer::Reborrow(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that reference does not outlive \\\n-                    borrowed content\");\n-            }\n-            infer::ReborrowUpvar(span, ref upvar_id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"...so that closure can access `{}`\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id)\n-                            .to_string()));\n-            }\n-            infer::InfStackClosure(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that closure does not outlive its stack frame\");\n-            }\n-            infer::InvokeClosure(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that closure is not invoked outside its lifetime\");\n-            }\n-            infer::DerefPointer(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that pointer is not dereferenced \\\n-                    outside its lifetime\");\n-            }\n-            infer::FreeVariable(span, id) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that captured variable `{}` \\\n-                            does not outlive the enclosing closure\",\n-                            self.tcx.local_var_name_str(id)));\n-            }\n-            infer::IndexSlice(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that slice is not indexed outside the lifetime\");\n-            }\n-            infer::RelateObjectBound(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that it can be closed over into an object\");\n-            }\n-            infer::CallRcvr(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that method receiver is valid for the method call\");\n-            }\n-            infer::CallArg(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that argument is valid for the call\");\n-            }\n-            infer::CallReturn(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that return value is valid for the call\");\n-            }\n-            infer::Operand(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that operand is valid for operation\");\n-            }\n-            infer::AddrOf(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that reference is valid \\\n-                     at the time of borrow\");\n-            }\n-            infer::AutoBorrow(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that auto-reference is valid \\\n-                     at the time of borrow\");\n-            }\n-            infer::ExprTypeIsNotInScope(t, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so type `{}` of expression is valid during the \\\n-                             expression\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::BindingTypeIsNotValidAtDecl(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that variable is valid at time of its declaration\");\n-            }\n-            infer::ParameterInScope(_, span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that a type/lifetime parameter is in scope here\");\n-            }\n-            infer::DataBorrowed(ty, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the type `{}` is not borrowed for too long\",\n-                             self.ty_to_string(ty)));\n-            }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the reference type `{}` \\\n-                             does not outlive the data it points at\",\n-                            self.ty_to_string(ty)));\n-            }\n-            infer::RelateParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that the type `{}` \\\n-                             will meet its required lifetime bounds\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::RelateDefaultParamBound(span, t) => {\n-                err.span_note(\n-                    span,\n-                    &format!(\"...so that type parameter \\\n-                             instantiated with `{}`, \\\n-                             will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t)));\n-            }\n-            infer::RelateRegionParamBound(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\");\n-            }\n-            infer::SafeDestructor(span) => {\n-                err.span_note(\n-                    span,\n-                    \"...so that references are valid when the destructor \\\n-                     runs\");\n-            }\n-            infer::CompareImplMethodObligation { span, .. } => {\n-                err.span_note(\n-                    span,\n-                    \"...so that the definition in impl matches the definition from the trait\");\n-            }\n-        }\n-    }\n }\n \n impl<'tcx> ObligationCause<'tcx> {", "previous_filename": "src/librustc/infer/error_reporting.rs"}, {"sha": "8f8b2603dad8496de6358bdfa77c7748d5165c43", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -0,0 +1,432 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::{self, InferCtxt, SubregionOrigin};\n+use ty::Region;\n+use ty::error::TypeError;\n+use errors::DiagnosticBuilder;\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub(super) fn note_region_origin(&self,\n+                                     err: &mut DiagnosticBuilder,\n+                                     origin: &SubregionOrigin<'tcx>) {\n+        match *origin {\n+            infer::Subtype(ref trace) => {\n+                if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    // FIXME: do we want a \"the\" here?\n+                    err.span_note(trace.cause.span,\n+                                  &format!(\"...so that {} (expected {}, found {})\",\n+                                           trace.cause.as_requirement_str(),\n+                                           expected,\n+                                           found));\n+                } else {\n+                    // FIXME: this really should be handled at some earlier stage. Our\n+                    // handling of region checking when type errors are present is\n+                    // *terrible*.\n+\n+                    err.span_note(trace.cause.span,\n+                                  &format!(\"...so that {}\", trace.cause.as_requirement_str()));\n+                }\n+            }\n+            infer::Reborrow(span) => {\n+                err.span_note(span,\n+                              \"...so that reference does not outlive borrowed content\");\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                err.span_note(span,\n+                              &format!(\"...so that closure can access `{}`\",\n+                                       self.tcx\n+                                           .local_var_name_str(upvar_id.var_id)\n+                                           .to_string()));\n+            }\n+            infer::InfStackClosure(span) => {\n+                err.span_note(span, \"...so that closure does not outlive its stack frame\");\n+            }\n+            infer::InvokeClosure(span) => {\n+                err.span_note(span,\n+                              \"...so that closure is not invoked outside its lifetime\");\n+            }\n+            infer::DerefPointer(span) => {\n+                err.span_note(span,\n+                              \"...so that pointer is not dereferenced outside its lifetime\");\n+            }\n+            infer::FreeVariable(span, id) => {\n+                err.span_note(span,\n+                              &format!(\"...so that captured variable `{}` does not outlive the \\\n+                                        enclosing closure\",\n+                                       self.tcx.local_var_name_str(id)));\n+            }\n+            infer::IndexSlice(span) => {\n+                err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n+            }\n+            infer::RelateObjectBound(span) => {\n+                err.span_note(span, \"...so that it can be closed over into an object\");\n+            }\n+            infer::CallRcvr(span) => {\n+                err.span_note(span,\n+                              \"...so that method receiver is valid for the method call\");\n+            }\n+            infer::CallArg(span) => {\n+                err.span_note(span, \"...so that argument is valid for the call\");\n+            }\n+            infer::CallReturn(span) => {\n+                err.span_note(span, \"...so that return value is valid for the call\");\n+            }\n+            infer::Operand(span) => {\n+                err.span_note(span, \"...so that operand is valid for operation\");\n+            }\n+            infer::AddrOf(span) => {\n+                err.span_note(span, \"...so that reference is valid at the time of borrow\");\n+            }\n+            infer::AutoBorrow(span) => {\n+                err.span_note(span,\n+                              \"...so that auto-reference is valid at the time of borrow\");\n+            }\n+            infer::ExprTypeIsNotInScope(t, span) => {\n+                err.span_note(span,\n+                              &format!(\"...so type `{}` of expression is valid during the \\\n+                                        expression\",\n+                                       self.ty_to_string(t)));\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                err.span_note(span,\n+                              \"...so that variable is valid at time of its declaration\");\n+            }\n+            infer::ParameterInScope(_, span) => {\n+                err.span_note(span,\n+                              \"...so that a type/lifetime parameter is in scope here\");\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                err.span_note(span,\n+                              &format!(\"...so that the type `{}` is not borrowed for too long\",\n+                                       self.ty_to_string(ty)));\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                err.span_note(span,\n+                              &format!(\"...so that the reference type `{}` does not outlive the \\\n+                                        data it points at\",\n+                                       self.ty_to_string(ty)));\n+            }\n+            infer::RelateParamBound(span, t) => {\n+                err.span_note(span,\n+                              &format!(\"...so that the type `{}` will meet its required \\\n+                                        lifetime bounds\",\n+                                       self.ty_to_string(t)));\n+            }\n+            infer::RelateDefaultParamBound(span, t) => {\n+                err.span_note(span,\n+                              &format!(\"...so that type parameter instantiated with `{}`, will \\\n+                                        meet its declared lifetime bounds\",\n+                                       self.ty_to_string(t)));\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                err.span_note(span,\n+                              \"...so that the declared lifetime parameter bounds are satisfied\");\n+            }\n+            infer::SafeDestructor(span) => {\n+                err.span_note(span,\n+                              \"...so that references are valid when the destructor runs\");\n+            }\n+            infer::CompareImplMethodObligation { span, .. } => {\n+                err.span_note(span,\n+                              \"...so that the definition in impl matches the definition from the \\\n+                               trait\");\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_concrete_failure(&self,\n+                                          origin: SubregionOrigin<'tcx>,\n+                                          sub: &'tcx Region,\n+                                          sup: &'tcx Region)\n+                                          -> DiagnosticBuilder<'tcx> {\n+        match origin {\n+            infer::Subtype(trace) => {\n+                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n+                self.report_and_explain_type_error(trace, &terr)\n+            }\n+            infer::Reborrow(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0312,\n+                                               \"lifetime of reference outlives lifetime of \\\n+                                                borrowed content...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the reference is valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...but the borrowed content is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0313,\n+                                               \"lifetime of borrowed pointer outlives lifetime \\\n+                                                of captured variable `{}`...\",\n+                                               self.tcx.local_var_name_str(upvar_id.var_id));\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the borrowed pointer is valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err,\n+                                             &format!(\"...but `{}` is only valid for \",\n+                                                      self.tcx\n+                                                          .local_var_name_str(upvar_id.var_id)),\n+                                             sup,\n+                                             \"\");\n+                err\n+            }\n+            infer::InfStackClosure(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...the closure must be valid for \",\n+                                                 sub,\n+                                                 \"...\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"...but the closure's stack frame is only valid \\\n+                                                  for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::InvokeClosure(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0315,\n+                                               \"cannot invoke closure outside of its lifetime\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the closure is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::DerefPointer(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0473,\n+                                               \"dereference of reference outside its lifetime\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the reference is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::FreeVariable(span, id) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0474,\n+                                               \"captured variable `{}` does not outlive the \\\n+                                                enclosing closure\",\n+                                               self.tcx.local_var_name_str(id));\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"captured variable is valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"closure is valid for \", sub, \"\");\n+                err\n+            }\n+            infer::IndexSlice(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0475,\n+                                               \"index of slice outside its lifetime\");\n+                self.tcx.note_and_explain_region(&mut err, \"the slice is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::RelateObjectBound(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0476,\n+                                               \"lifetime of the source pointer does not outlive \\\n+                                                lifetime bound of the object type\");\n+                self.tcx.note_and_explain_region(&mut err, \"object type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"source pointer is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::RelateParamBound(span, ty) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0477,\n+                                               \"the type `{}` does not fulfill the required \\\n+                                                lifetime\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n+                err\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"lifetime parameter instantiated with \",\n+                                                 sup,\n+                                                 \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"but lifetime parameter must outlive \",\n+                                                 sub,\n+                                                 \"\");\n+                err\n+            }\n+            infer::RelateDefaultParamBound(span, ty) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0479,\n+                                               \"the type `{}` (provided as the value of a type \\\n+                                                parameter) is not valid at this point\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n+                err\n+            }\n+            infer::CallRcvr(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0480,\n+                                               \"lifetime of method receiver does not outlive the \\\n+                                                method call\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the receiver is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::CallArg(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0481,\n+                                               \"lifetime of function argument does not outlive \\\n+                                                the function call\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the function argument is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::CallReturn(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0482,\n+                                               \"lifetime of return value does not outlive the \\\n+                                                function call\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the return value is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::Operand(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0483,\n+                                               \"lifetime of operand does not outlive the \\\n+                                                operation\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the operand is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::AddrOf(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0484,\n+                                               \"reference is not valid at the time of borrow\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the borrow is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::AutoBorrow(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0485,\n+                                               \"automatically reference is not valid at the time \\\n+                                                of borrow\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"the automatic borrow is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::ExprTypeIsNotInScope(t, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0486,\n+                                               \"type of expression contains references that are \\\n+                                                not valid during the expression: `{}`\",\n+                                               self.ty_to_string(t));\n+                self.tcx.note_and_explain_region(&mut err, \"type is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::SafeDestructor(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0487,\n+                                               \"unsafe use of destructor: destructor might be \\\n+                                                called while references are dead\");\n+                // FIXME (22171): terms \"super/subregion\" are suboptimal\n+                self.tcx.note_and_explain_region(&mut err, \"superregion: \", sup, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"subregion: \", sub, \"\");\n+                err\n+            }\n+            infer::BindingTypeIsNotValidAtDecl(span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0488,\n+                                               \"lifetime of variable does not enclose its \\\n+                                                declaration\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the variable is only valid for \", sup, \"\");\n+                err\n+            }\n+            infer::ParameterInScope(_, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0489,\n+                                               \"type/lifetime parameter not in scope here\");\n+                self.tcx\n+                    .note_and_explain_region(&mut err, \"the parameter is only valid for \", sub, \"\");\n+                err\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0490,\n+                                               \"a value of type `{}` is borrowed for too long\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n+                err\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                let mut err = struct_span_err!(self.tcx.sess,\n+                                               span,\n+                                               E0491,\n+                                               \"in type `{}`, reference has a longer lifetime \\\n+                                                than the data it references\",\n+                                               self.ty_to_string(ty));\n+                self.tcx.note_and_explain_region(&mut err, \"the pointer is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                                                 \"but the referenced data is only valid for \",\n+                                                 sup,\n+                                                 \"\");\n+                err\n+            }\n+            infer::CompareImplMethodObligation { span,\n+                                                 item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id,\n+                                                 lint_id } => {\n+                self.report_extra_impl_obligation(span,\n+                                                  item_name,\n+                                                  impl_item_def_id,\n+                                                  trait_item_def_id,\n+                                                  &format!(\"`{}: {}`\", sup, sub),\n+                                                  lint_id)\n+            }\n+        }\n+    }\n+}"}, {"sha": "b07ef4dfd448e45f1a3651110b4dd6b79838e836", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -210,7 +210,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n /// region that each late-bound region was replaced with.\n pub type SkolemizationMap<'tcx> = FxHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n@@ -221,7 +221,7 @@ pub enum ValuePairs<'tcx> {\n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n-/// See `error_reporting.rs` for more details.\n+/// See `error_reporting` module for more details.\n #[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n@@ -230,7 +230,7 @@ pub struct TypeTrace<'tcx> {\n \n /// The origin of a `r1 <= r2` constraint.\n ///\n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n     // Arose from a subtyping relation\n@@ -348,7 +348,7 @@ pub enum LateBoundRegionConversionTime {\n \n /// Reasons to create a region inference variable\n ///\n-/// See `error_reporting.rs` for more details\n+/// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n@@ -1295,7 +1295,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(&errors); // see error_reporting.rs\n+            self.report_region_errors(&errors); // see error_reporting module\n         }\n     }\n "}, {"sha": "1294296840ebd75b329bd6df6c81e1309883caf3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -1476,7 +1476,7 @@ pub struct PolyTrait {\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/TyCtxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n pub enum Type {\n     /// structs/enums/traits (most that'd be an hir::TyPath)\n     ResolvedPath {"}, {"sha": "23507dc889b710be084cb53985f9575d7ba87dc3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 91, "deletions": 25, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -90,6 +90,16 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     }\n }\n \n+impl<'a, T: fmt::Debug> fmt::Debug for CommaSep<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for (i, item) in self.0.iter().enumerate() {\n+            if i != 0 { write!(f, \", \")?; }\n+            fmt::Debug::fmt(item, f)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'a> fmt::Display for TyParamBounds<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &TyParamBounds(bounds) = self;\n@@ -165,7 +175,7 @@ impl<'a> fmt::Display for WhereClause<'a> {\n         if f.alternate() {\n             clause.push_str(\" where \");\n         } else {\n-            clause.push_str(\" <span class='where fmt-newline'>where \");\n+            clause.push_str(\" <span class=\\\"where fmt-newline\\\">where \");\n         }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n@@ -449,8 +459,8 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                     } else {\n                         root.push_str(&seg.name);\n                         root.push_str(\"/\");\n-                        write!(w, \"<a class='mod'\n-                                       href='{}index.html'>{}</a>::\",\n+                        write!(w, \"<a class=\\\"mod\\\"\n+                                       href=\\\"{}index.html\\\">{}</a>::\",\n                                  root,\n                                  seg.name)?;\n                     }\n@@ -491,7 +501,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n             Some(&def_id) if def_id.is_local() => {\n                 let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n                 let len = if len == 0 {0} else {len - 1};\n-                write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n+                write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}primitive.{}.html\\\">\",\n                        repeat(\"../\").take(len).collect::<String>(),\n                        prim.to_url_str())?;\n                 needs_termination = true;\n@@ -508,7 +518,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                     (.., render::Unknown) => None,\n                 };\n                 if let Some((cname, root)) = loc {\n-                    write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n+                    write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}{}/primitive.{}.html\\\">\",\n                            root,\n                            cname,\n                            prim.to_url_str())?;\n@@ -550,7 +560,7 @@ impl<'a> fmt::Display for HRef<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match href(self.did) {\n             Some((url, shortty, fqp)) => if !f.alternate() {\n-                write!(f, \"<a class='{}' href='{}' title='{} {}'>{}</a>\",\n+                write!(f, \"<a class=\\\"{}\\\" href=\\\"{}\\\" title=\\\"{} {}\\\">{}</a>\",\n                        shortty, url, shortty, fqp.join(\"::\"), self.text)\n             } else {\n                 write!(f, \"{}\", self.text)\n@@ -560,7 +570,8 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n-fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt::Result {\n+fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n+            is_not_debug: bool) -> fmt::Result {\n     match *t {\n         clean::Generic(ref name) => {\n             f.write_str(name)\n@@ -571,7 +582,8 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             tybounds(f, typarams)\n         }\n         clean::Infer => write!(f, \"_\"),\n-        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n+        clean::Primitive(prim) if is_not_debug => primitive_link(f, prim, prim.as_str()),\n+        clean::Primitive(prim) => write!(f, \"{}\", prim.as_str()),\n         clean::BareFunction(ref decl) => {\n             if f.alternate() {\n                 write!(f, \"{}{}fn{:#}{:#}\",\n@@ -589,26 +601,30 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n         }\n         clean::Tuple(ref typs) => {\n             match &typs[..] {\n-                &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n-                &[ref one] => {\n+                &[] if is_not_debug => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n+                &[] => write!(f, \"()\"),\n+                &[ref one] if is_not_debug => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     //carry f.alternate() into this display w/o branching manually\n                     fmt::Display::fmt(one, f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n-                many => {\n+                &[ref one] => write!(f, \"({:?},)\", one),\n+                many if is_not_debug => {\n                     primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                     fmt::Display::fmt(&CommaSep(&many), f)?;\n                     primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n+                many => write!(f, \"({:?})\", &CommaSep(&many)),\n             }\n         }\n-        clean::Vector(ref t) => {\n+        clean::Vector(ref t) if is_not_debug => {\n             primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n         }\n-        clean::FixedVector(ref t, ref s) => {\n+        clean::Vector(ref t) => write!(f, \"[{:?}]\", t),\n+        clean::FixedVector(ref t, ref s) if is_not_debug => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n             if f.alternate() {\n@@ -619,10 +635,17 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                                &format!(\"; {}]\", Escape(s)))\n             }\n         }\n+        clean::FixedVector(ref t, ref s) => {\n+            if f.alternate() {\n+                write!(f, \"[{:?}; {}]\", t, s)\n+            } else {\n+                write!(f, \"[{:?}; {}]\", t, Escape(s))\n+            }\n+        }\n         clean::Never => f.write_str(\"!\"),\n         clean::RawPointer(m, ref t) => {\n             match **t {\n-                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n+                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} if is_not_debug => {\n                     if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n@@ -631,11 +654,21 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                                        &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                 }\n-                _ => {\n+                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n+                    if f.alternate() {\n+                        write!(f, \"*{}{:#?}\", RawMutableSpace(m), t)\n+                    } else {\n+                        write!(f, \"*{}{:?}\", RawMutableSpace(m), t)\n+                    }\n+                }\n+                _ if is_not_debug => {\n                     primitive_link(f, clean::PrimitiveType::RawPointer,\n                                    &format!(\"*{}\", RawMutableSpace(m)))?;\n                     fmt::Display::fmt(t, f)\n                 }\n+                _ => {\n+                    write!(f, \"*{}{:?}\", RawMutableSpace(m), t)\n+                }\n             }\n         }\n         clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n@@ -647,15 +680,23 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             match **ty {\n                 clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n                     match **bt {\n-                        clean::Generic(_) =>\n+                        clean::Generic(_) if is_not_debug => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                     &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n                             } else {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                     &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n-                            },\n-                        _ => {\n+                            }\n+                        }\n+                        clean::Generic(_) => {\n+                            if f.alternate() {\n+                                write!(f, \"&{}{}[{:#?}]\", lt, m, **bt)\n+                            } else {\n+                                write!(f, \"&{}{}[{:?}]\", lt, m, **bt)\n+                            }\n+                        }\n+                        _ if is_not_debug => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n                                                &format!(\"&{}{}[\", lt, m))?;\n@@ -667,15 +708,26 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                             }\n                             primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n+                        _ => {\n+                            if f.alternate() {\n+                                write!(f, \"&{}{}[{:#?}]\", lt, m, **bt)\n+                            } else {\n+                                write!(f, \"&{}{}[{:?}]\", lt, m, **bt)\n+                            }\n+                        }\n                     }\n                 }\n                 _ => {\n                     if f.alternate() {\n                         write!(f, \"&{}{}\", lt, m)?;\n-                        fmt_type(&ty, f, use_absolute)\n+                        fmt_type(&ty, f, use_absolute, is_not_debug)\n                     } else {\n-                        write!(f, \"&amp;{}{}\", lt, m)?;\n-                        fmt_type(&ty, f, use_absolute)\n+                        if is_not_debug {\n+                            write!(f, \"&amp;{}{}\", lt, m)?;\n+                        } else {\n+                            write!(f, \"&{}{}\", lt, m)?;\n+                        }\n+                        fmt_type(&ty, f, use_absolute, is_not_debug)\n                     }\n                 }\n             }\n@@ -723,9 +775,17 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n         }\n         clean::QPath { ref name, ref self_type, ref trait_ } => {\n             if f.alternate() {\n-                write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                if is_not_debug {\n+                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                } else {\n+                    write!(f, \"<{:#?} as {:#?}>::{}\", self_type, trait_, name)\n+                }\n             } else {\n-                write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                if is_not_debug {\n+                    write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                } else {\n+                    write!(f, \"<{:?} as {:?}>::{}\", self_type, trait_, name)\n+                }\n             }\n         }\n         clean::Unique(..) => {\n@@ -736,7 +796,13 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n \n impl fmt::Display for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt_type(self, f, false)\n+        fmt_type(self, f, false, true)\n+    }\n+}\n+\n+impl fmt::Debug for clean::Type {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt_type(self, f, false, false)\n     }\n }\n \n@@ -777,7 +843,7 @@ fn fmt_impl(i: &clean::Impl,\n         plain.push_str(\" for \");\n     }\n \n-    fmt_type(&i.for_, f, use_absolute)?;\n+    fmt_type(&i.for_, f, use_absolute, true)?;\n     plain.push_str(&format!(\"{:#}\", i.for_));\n \n     fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;"}, {"sha": "0dafc4225a3210653e6d9b445914c825db8c9a35", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -144,12 +144,12 @@ impl<U: Write> Writer for U {\n                           -> io::Result<()> {\n         match klass {\n             Class::None => write!(self, \"{}\", text),\n-            klass => write!(self, \"<span class='{}'>{}</span>\", klass.rustdoc_class(), text),\n+            klass => write!(self, \"<span class=\\\"{}\\\">{}</span>\", klass.rustdoc_class(), text),\n         }\n     }\n \n     fn enter_span(&mut self, klass: Class) -> io::Result<()> {\n-        write!(self, \"<span class='{}'>\", klass.rustdoc_class())\n+        write!(self, \"<span class=\\\"{}\\\">\", klass.rustdoc_class())\n     }\n \n     fn exit_span(&mut self) -> io::Result<()> {\n@@ -363,7 +363,7 @@ fn write_header(class: Option<&str>,\n     if let Some(id) = id {\n         write!(out, \"id='{}' \", id)?;\n     }\n-    write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))\n+    write!(out, \"class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n }\n \n fn write_footer(out: &mut Write) -> io::Result<()> {"}, {"sha": "44f71d8952985b0098e482d561dad83d960969da", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -1547,7 +1547,7 @@ impl<'a> fmt::Display for Item<'a> {\n                        component)?;\n             }\n         }\n-        write!(fmt, \"<a class='{}' href=''>{}</a>\",\n+        write!(fmt, \"<a class=\\\"{}\\\" href=''>{}</a>\",\n                self.item.type_(), self.item.name.as_ref().unwrap())?;\n \n         write!(fmt, \"</span>\")?; // in-band\n@@ -1654,9 +1654,35 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n     Ok(())\n }\n \n+fn md_render_assoc_item(item: &clean::Item) -> String {\n+    match item.inner {\n+        clean::AssociatedConstItem(ref ty, ref default) => {\n+            if let Some(default) = default.as_ref() {\n+                format!(\"```\\n{}: {:?} = {}\\n```\\n\\n\", item.name.as_ref().unwrap(), ty, default)\n+            } else {\n+                format!(\"```\\n{}: {:?}\\n```\\n\\n\", item.name.as_ref().unwrap(), ty)\n+            }\n+        }\n+        _ => String::new(),\n+    }\n+}\n+\n+fn get_doc_value(item: &clean::Item) -> Option<&str> {\n+    let x = item.doc_value();\n+    if x.is_none() {\n+        match item.inner {\n+            clean::AssociatedConstItem(_, _) => Some(\"\"),\n+            _ => None,\n+        }\n+    } else {\n+        x\n+    }\n+}\n+\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n-    if let Some(s) = item.doc_value() {\n-        write!(w, \"<div class='docblock'>{}</div>\", Markdown(s))?;\n+    if let Some(s) = get_doc_value(item) {\n+        write!(w, \"<div class='docblock'>{}</div>\",\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s)))?;\n     }\n     Ok(())\n }\n@@ -1817,7 +1843,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 let doc_value = myitem.doc_value().unwrap_or(\"\");\n                 write!(w, \"\n                        <tr class='{stab} module-item'>\n-                           <td><a class='{class}' href='{href}'\n+                           <td><a class=\\\"{class}\\\" href=\\\"{href}\\\"\n                                   title='{title_type} {title}'>{name}</a>{unsafety_flag}</td>\n                            <td class='docblock-short'>\n                                {stab_docs} {docs}\n@@ -2215,24 +2241,20 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink) -> String {\n fn assoc_const(w: &mut fmt::Formatter,\n                it: &clean::Item,\n                ty: &clean::Type,\n-               default: Option<&String>,\n+               _default: Option<&String>,\n                link: AssocItemLink) -> fmt::Result {\n-    write!(w, \"const <a href='{}' class='constant'>{}</a>\",\n+    write!(w, \"const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            naive_assoc_href(it, link),\n-           it.name.as_ref().unwrap())?;\n-\n-    write!(w, \": {}\", ty)?;\n-    if let Some(default) = default {\n-        write!(w, \" = {}\", Escape(default))?;\n-    }\n+           it.name.as_ref().unwrap(),\n+           ty)?;\n     Ok(())\n }\n \n fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               bounds: &Vec<clean::TyParamBound>,\n               default: Option<&clean::Type>,\n               link: AssocItemLink) -> fmt::Result {\n-    write!(w, \"type <a href='{}' class='type'>{}</a>\",\n+    write!(w, \"type <a href='{}' class=\\\"type\\\">{}</a>\",\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap())?;\n     if !bounds.is_empty() {\n@@ -2375,7 +2397,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 let ns_id = derive_id(format!(\"{}.{}\",\n                                               field.name.as_ref().unwrap(),\n                                               ItemType::StructField.name_space()));\n-                write!(w, \"<span id='{id}' class='{item_type}'>\n+                write!(w, \"<span id='{id}' class=\\\"{item_type}\\\">\n                            <span id='{ns_id}' class='invisible'>\n                            <code>{name}: {ty}</code>\n                            </span></span>\",\n@@ -2417,7 +2439,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     if fields.peek().is_some() {\n         write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n         for (field, ty) in fields {\n-            write!(w, \"<span id='{shortty}.{name}' class='{shortty}'><code>{name}: {ty}</code>\n+            write!(w, \"<span id='{shortty}.{name}' class=\\\"{shortty}\\\"><code>{name}: {ty}</code>\n                        </span>\",\n                    shortty = ItemType::StructField,\n                    name = field.name.as_ref().unwrap(),\n@@ -2902,7 +2924,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 if render_method_item {\n                     let id = derive_id(format!(\"{}.{}\", item_type, name));\n                     let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                    write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                    write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                     write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n@@ -2914,31 +2936,31 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, &c.type_, Some(&c.expr), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let id = derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n@@ -2956,7 +2978,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         // We need the stability of the item from the trait\n                         // because impls can't have a stability.\n                         document_stability(w, cx, it)?;\n-                        if item.doc_value().is_some() {\n+                        if get_doc_value(item).is_some() {\n                             document_full(w, item)?;\n                         } else {\n                             // In case the item isn't documented,"}, {"sha": "200285862276a5f8e63ea479e02fde2268a9538c", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -979,7 +979,7 @@\n             .html(\"[<span class='inner'></span>]\");\n         toggle.children(\".inner\").text(labelForToggleButton(false));\n \n-        $(\".method\").each(function() {\n+        $(\".method, .impl-items > .associatedconstant\").each(function() {\n             if ($(this).next().is(\".docblock\") ||\n                 ($(this).next().is(\".stability\") && $(this).next().next().is(\".docblock\"))) {\n                     $(this).children().last().after(toggle.clone());"}, {"sha": "b0bf69b0181f22ae2de2705e1a333788bda169d5", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -89,7 +89,7 @@ h2 {\n h3 {\n \tfont-size: 1.3em;\n }\n-h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tfont-weight: 500;\n \tmargin: 20px 0 15px 0;\n \tpadding-bottom: 6px;\n@@ -99,10 +99,10 @@ h1.fqn {\n \tmargin-top: 0;\n \tposition: relative;\n }\n-h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tborder-bottom: 1px solid;\n }\n-h3.impl, h3.method, h4.method, h3.type, h4.type {\n+h3.impl, h3.method, h4.method, h3.type, h4.type, h4.associatedconstant {\n \tfont-weight: 600;\n \tmargin-top: 10px;\n \tmargin-bottom: 10px;\n@@ -382,7 +382,7 @@ h4 > code, h3 > code, .invisible > code {\n .content .impl-items .docblock, .content .impl-items .stability {\n \tmargin-left: 40px;\n }\n-.content .impl-items .method, .content .impl-items > .type {\n+.content .impl-items .method, .content .impl-items > .type, .impl-items > .associatedconstant {\n \tmargin-left: 20px;\n }\n "}, {"sha": "bc678fcb8385b0a9a640afdc285fe8de2eebf8e3", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -455,6 +455,20 @@ impl From<NulError> for io::Error {\n     }\n }\n \n+#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\n+impl Error for FromBytesWithNulError {\n+    fn description(&self) -> &str {\n+        \"data provided is not null terminated or contains an interior nul byte\"\n+    }\n+}\n+\n+#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\n+impl fmt::Display for FromBytesWithNulError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n impl IntoStringError {\n     /// Consumes this error, returning original `CString` which generated the\n     /// error."}, {"sha": "d4119f5d351c16fecae2c652bae61a8282b16bc1", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -13,14 +13,16 @@\n pub trait Foo {\n     // @has assoc_consts/trait.Foo.html '//*[@class=\"rust trait\"]' \\\n     //      'const FOO: usize;'\n-    // @has - '//*[@id=\"associatedconstant.FOO\"]' 'const FOO'\n-    const FOO: usize;\n+    // @has - '//*[@id=\"associatedconstant.FOO\"]' 'const FOO: usize'\n+    // @has - '//*[@class=\"docblock\"]' 'FOO: usize = 12'\n+    const FOO: usize = 12;\n }\n \n pub struct Bar;\n \n impl Bar {\n     // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.BAR\"]' \\\n-    //      'const BAR: usize = 3'\n+    //      'const BAR: usize'\n+    // @has - '//*[@class=\"docblock\"]' 'BAR: usize = 3'\n     pub const BAR: usize = 3;\n }"}, {"sha": "493c08693e94a6d1e317f5d69000dff1d4792780", "filename": "src/test/rustdoc/issue-28478.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-28478.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -16,7 +16,8 @@ pub trait Bar {\n     // @has - '//*[@id=\"associatedtype.Bar\"]' 'type Bar = ()'\n     // @has - '//*[@href=\"#associatedtype.Bar\"]' 'Bar'\n     type Bar = ();\n-    // @has - '//*[@id=\"associatedconstant.Baz\"]' 'const Baz: usize = 7'\n+    // @has - '//*[@id=\"associatedconstant.Baz\"]' 'const Baz: usize'\n+    // @has - '//*[@class=\"docblock\"]' 'Baz: usize = 7'\n     // @has - '//*[@href=\"#associatedconstant.Baz\"]' 'Baz'\n     const Baz: usize = 7;\n     // @has - '//*[@id=\"tymethod.bar\"]' 'fn bar'"}, {"sha": "a34ee908ef295adff271c5ef0aa09044fc29ac78", "filename": "src/test/rustdoc/issue-33302.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b671c32ddc8c36d50866428d83b7716233356721/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b671c32ddc8c36d50866428d83b7716233356721/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-33302.rs?ref=b671c32ddc8c36d50866428d83b7716233356721", "patch": "@@ -28,18 +28,40 @@ macro_rules! make {\n             fn ignore(_: &X) {}\n             const C: X;\n             // @has issue_33302/trait.T.html \\\n-            //        '//*[@class=\"rust trait\"]' 'const D: i32 = 4 * 4;'\n-            // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n+            //        '//*[@class=\"rust trait\"]' 'const D: i32'\n+            // @has - '//*[@class=\"docblock\"]' 'D: i32 = 4 * 4'\n+            // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32'\n             const D: i32 = ($n * $n);\n         }\n \n         // @has issue_33302/struct.S.html \\\n         //        '//h3[@class=\"impl\"]' 'impl T<[i32; 16]> for S'\n-        // @has - '//*[@id=\"associatedconstant.C\"]' 'const C: [i32; 16] = [0; 4 * 4]'\n-        // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n+        // @has - '//*[@id=\"associatedconstant.C\"]' 'const C: [i32; 16]'\n+        // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32'\n+        // @has - '//*[@class=\"docblock\"]' 'C: [i32; 16] = [0; 4 * 4]'\n         impl T<[i32; ($n * $n)]> for S {\n             const C: [i32; ($n * $n)] = [0; ($n * $n)];\n         }\n+\n+        // @has issue_33302/struct.S.html \\\n+        //        '//h3[@class=\"impl\"]' 'impl T<[i32; 16]> for S'\n+        // @has - '//*[@id=\"associatedconstant.C-1\"]' 'const C: (i32,)'\n+        // @has - '//*[@id=\"associatedconstant.D-1\"]' 'const D: i32'\n+        // @has - '//*[@class=\"docblock\"]' 'C: (i32,) = (4,)'\n+        impl T<(i32,)> for S {\n+            const C: (i32,) = ($n,);\n+        }\n+\n+        // @has issue_33302/struct.S.html \\\n+        //        '//h3[@class=\"impl\"]' 'impl T<(i32, i32)> for S'\n+        // @has - '//*[@id=\"associatedconstant.C-2\"]' 'const C: (i32, i32)'\n+        // @has - '//*[@id=\"associatedconstant.D-2\"]' 'const D: i32'\n+        // @has - '//*[@class=\"docblock\"]' 'C: (i32, i32) = (4, 4)'\n+        // @has - '//*[@class=\"docblock\"]' 'D: i32 = 4 / 4'\n+        impl T<(i32, i32)> for S {\n+            const C: (i32, i32) = ($n, $n);\n+            const D: i32 = ($n / $n);\n+        }\n     }\n }\n "}]}