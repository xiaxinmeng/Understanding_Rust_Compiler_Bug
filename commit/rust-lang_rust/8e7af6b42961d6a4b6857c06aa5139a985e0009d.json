{"sha": "8e7af6b42961d6a4b6857c06aa5139a985e0009d", "node_id": "C_kwDOAAsO6NoAKDhlN2FmNmI0Mjk2MWQ2YTRiNjg1N2MwNmFhNTEzOWE5ODVlMDAwOWQ", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-29T02:34:02Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-10-02T18:50:37Z"}, "message": "Replace `is_lang_ctor` with `is_res_lang_ctor`", "tree": {"sha": "867aa1989234241994b2cb3cb383a43d6c457742", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/867aa1989234241994b2cb3cb383a43d6c457742"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e7af6b42961d6a4b6857c06aa5139a985e0009d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e7af6b42961d6a4b6857c06aa5139a985e0009d", "html_url": "https://github.com/rust-lang/rust/commit/8e7af6b42961d6a4b6857c06aa5139a985e0009d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e7af6b42961d6a4b6857c06aa5139a985e0009d/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8ba19287dc4710fef7e63b0c75071ff6ea7d642", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8ba19287dc4710fef7e63b0c75071ff6ea7d642", "html_url": "https://github.com/rust-lang/rust/commit/f8ba19287dc4710fef7e63b0c75071ff6ea7d642"}], "stats": {"total": 407, "additions": 205, "deletions": 202}, "files": [{"sha": "0d6718c168a5c9da12865ee7633dc5078ad7e33a", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::eager_or_lazy::switch_to_eager_eval;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs, peel_blocks};\n+use clippy_utils::{\n+    contains_return, higher, is_else_clause, is_res_lang_ctor, meets_msrv, msrvs, path_res, peel_blocks,\n+};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -76,10 +78,8 @@ impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n             && let ExprKind::Block(then_block, _) = then.kind\n             && let Some(then_expr) = then_block.expr\n             && let ExprKind::Call(then_call, [then_arg]) = then_expr.kind\n-            && let ExprKind::Path(ref then_call_qpath) = then_call.kind\n-            && is_lang_ctor(cx, then_call_qpath, OptionSome)\n-            && let ExprKind::Path(ref qpath) = peel_blocks(els).kind\n-            && is_lang_ctor(cx, qpath, OptionNone)\n+            && is_res_lang_ctor(cx, path_res(cx, then_call), OptionSome)\n+            && is_res_lang_ctor(cx, path_res(cx, peel_blocks(els)), OptionNone)\n             && !stmts_contains_early_return(then_block.stmts)\n         {\n             let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");"}, {"sha": "4bb9936e9cde7a235f674ba7483f531b8f3dc1de", "filename": "clippy_lints/src/loops/manual_find.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FIND;\n use clippy_utils::{\n-    diagnostics::span_lint_and_then, higher, is_lang_ctor, path_res, peel_blocks_with_stmt,\n+    diagnostics::span_lint_and_then, higher, is_res_lang_ctor, path_res, peel_blocks_with_stmt,\n     source::snippet_with_applicability, ty::implements_trait,\n };\n use if_chain::if_chain;\n@@ -30,8 +30,8 @@ pub(super) fn check<'tcx>(\n         if let [stmt] = block.stmts;\n         if let StmtKind::Semi(semi) = stmt.kind;\n         if let ExprKind::Ret(Some(ret_value)) = semi.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ctor), .. }, [inner_ret]) = ret_value.kind;\n-        if is_lang_ctor(cx, ctor, LangItem::OptionSome);\n+        if let ExprKind::Call(ctor, [inner_ret]) = ret_value.kind;\n+        if is_res_lang_ctor(cx, path_res(cx, ctor), LangItem::OptionSome);\n         if path_res(cx, inner_ret) == Res::Local(binding_id);\n         if let Some((last_stmt, last_ret)) = last_stmt_and_ret(cx, expr);\n         then {\n@@ -143,8 +143,7 @@ fn last_stmt_and_ret<'tcx>(\n         if let Some((_, Node::Block(block))) = parent_iter.next();\n         if let Some((last_stmt, last_ret)) = extract(block);\n         if last_stmt.hir_id == node_hir;\n-        if let ExprKind::Path(path) = &last_ret.kind;\n-        if is_lang_ctor(cx, path, LangItem::OptionNone);\n+        if is_res_lang_ctor(cx, path_res(cx, last_ret), LangItem::OptionNone);\n         if let Some((_, Node::Expr(_block))) = parent_iter.next();\n         // This includes the function header\n         if let Some((_, func)) = parent_iter.next();"}, {"sha": "8c27c09404b1b28e77fb13a62b97bea0a5a6fd7b", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -3,13 +3,13 @@ use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, path_to_local_id, peel_blocks_with_stmt};\n+use clippy_utils::{path_to_local_id, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, Pat, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, DefIdTree};\n use rustc_span::source_map::Span;\n \n /// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n@@ -30,8 +30,10 @@ pub(super) fn check<'tcx>(\n         if path_to_local_id(let_expr, pat_hir_id);\n         // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n         if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n-        let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n-        let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(qpath, let_pat.hir_id);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        let some_ctor = cx.tcx.lang_items().option_some_variant() == Some(variant_id);\n+        let ok_ctor = cx.tcx.lang_items().result_ok_variant() == Some(variant_id);\n         if some_ctor || ok_ctor;\n         // Ensure expr in `if let` is not used afterwards\n         if !is_local_used(cx, if_then, pat_hir_id);"}, {"sha": "153f97e4e66c88ffe334d220c0d8425cf6589796", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -3,13 +3,12 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{\n-    get_enclosing_loop_or_multi_call_closure, is_refutable, is_trait_method, match_def_path, paths,\n-    visitors::is_res_used,\n+    get_enclosing_loop_or_multi_call_closure, is_refutable, is_res_lang_ctor, is_trait_method, visitors::is_res_used,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{def::Res, Closure, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Closure, Expr, ExprKind, HirId, LangItem, Local, Mutability, PatKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::ty::adjustment::Adjust;\n@@ -19,9 +18,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr_struct, iter_expr, some_pat, loop_expr) = if_chain! {\n         if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n-        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n-        if let Res::Def(_, pat_did) = pat_path.res;\n-        if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n+        if let PatKind::TupleStruct(ref pat_path, some_pat, _) = let_pat.kind;\n+        if is_res_lang_ctor(cx, cx.qpath_res(pat_path, let_pat.hir_id), LangItem::OptionSome);\n         // check for call to `Iterator::next`\n         if let ExprKind::MethodCall(method_name, iter_expr, [], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;"}, {"sha": "fd14d868df348e7e856c08e8b59bf2f4c9ee58d8", "filename": "clippy_lints/src/matches/collapsible_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{\n+    is_res_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq,\n+};\n use if_chain::if_chain;\n use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n@@ -110,7 +112,7 @@ fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     }\n     match arm.pat.kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n-        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n         _ => false,\n     }\n }"}, {"sha": "76f5e1c941c7a270e37f0647455c8db60550588c", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -3,8 +3,8 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n-    can_move_expr_to_closure, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id, peel_blocks,\n-    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n@@ -251,9 +251,11 @@ fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: Syn\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n             PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n+            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n+                Some(OptionPat::None)\n+            },\n             PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n+                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n@@ -272,16 +274,14 @@ fn get_some_expr<'tcx>(\n ) -> Option<SomeExpr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n-        ExprKind::Call(\n-            Expr {\n-                kind: ExprKind::Path(ref qpath),\n-                ..\n-            },\n-            [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n-            expr: arg,\n-            needs_unsafe_block,\n-        }),\n+        ExprKind::Call(callee, [arg])\n+            if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n+        {\n+            Some(SomeExpr {\n+                expr: arg,\n+                needs_unsafe_block,\n+            })\n+        },\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n@@ -302,5 +302,5 @@ fn get_some_expr<'tcx>(\n \n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n+    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n }"}, {"sha": "587c926dc01c3f02d790653c72dcbc3d8eded3e8", "filename": "clippy_lints/src/matches/manual_unwrap_or.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -3,12 +3,14 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{is_lang_ctor, path_to_local_id, sugg};\n+use clippy_utils::{is_res_lang_ctor, path_to_local_id, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::LangItem::{OptionNone, ResultErr};\n use rustc_hir::{Arm, Expr, PatKind};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::sym;\n \n use super::MANUAL_UNWRAP_OR;\n@@ -59,15 +61,19 @@ fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'\n         if arms.iter().all(|arm| arm.guard.is_none());\n         if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n             match arm.pat.kind {\n-                PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+                PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n                 PatKind::TupleStruct(ref qpath, [pat], _) =>\n-                    matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n+                    matches!(pat.kind, PatKind::Wild)\n+                        && is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), ResultErr),\n                 _ => false,\n             }\n         });\n         let unwrap_arm = &arms[1 - idx];\n         if let PatKind::TupleStruct(ref qpath, [unwrap_pat], _) = unwrap_arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(qpath, unwrap_arm.pat.hir_id);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        if cx.tcx.lang_items().option_some_variant() == Some(variant_id)\n+            || cx.tcx.lang_items().result_ok_variant() == Some(variant_id);\n         if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n         if path_to_local_id(unwrap_arm.body, binding_hir_id);\n         if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();"}, {"sha": "2818f030b7a6388fc85b4ca52fe99da681b75aca", "filename": "clippy_lints/src/matches/match_as_ref.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_lang_ctor, peel_blocks};\n+use clippy_utils::{is_res_lang_ctor, path_res, peel_blocks};\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, LangItem, Mutability, PatKind, QPath};\n use rustc_lint::LateContext;\n@@ -59,18 +59,20 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, LangItem::OptionNone))\n+    matches!(\n+        arm.pat.kind,\n+        PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), LangItem::OptionNone)\n+    )\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<Mutability> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n+        if is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), LangItem::OptionSome);\n         if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., ident, _) = first_pat.kind;\n         if let ExprKind::Call(e, [arg]) = peel_blocks(arm.body).kind;\n-        if let ExprKind::Path(ref some_path) = e.kind;\n-        if is_lang_ctor(cx, some_path, LangItem::OptionSome);\n+        if is_res_lang_ctor(cx, path_res(cx, e), LangItem::OptionSome);\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = arg.kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {"}, {"sha": "c4f6852aedc3d541785111161099fba809ff86b4", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{\n-    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_lang_ctor, over,\n+    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_res_lang_ctor, over, path_res,\n     peel_blocks_with_stmt,\n };\n use rustc_errors::Applicability;\n@@ -112,10 +112,7 @@ fn check_if_let_inner(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool\n             let ret = strip_return(else_expr);\n             let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n             if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n-                if let ExprKind::Path(ref qpath) = ret.kind {\n-                    return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n-                }\n-                return false;\n+                return is_res_lang_ctor(cx, path_res(cx, ret), OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n             }\n             return eq_expr_value(cx, if_let.let_expr, ret);\n         }"}, {"sha": "81bebff34c82c78644adfbf5ba37d34f46f7ba54", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -4,10 +4,11 @@ use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_type_diagnostic_item, needs_ordered_drop};\n use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n-use clippy_utils::{higher, is_lang_ctor, is_trait_method};\n+use clippy_utils::{higher, is_trait_method};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::LangItem::{self, OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n@@ -87,15 +88,21 @@ fn find_sugg_for_if_let<'tcx>(\n             }\n         },\n         PatKind::Path(ref path) => {\n-            let method = if is_lang_ctor(cx, path, OptionNone) {\n-                \"is_none()\"\n-            } else if is_lang_ctor(cx, path, PollPending) {\n-                \"is_pending()\"\n+            if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(path, check_pat.hir_id)\n+                && let Some(variant_id) = cx.tcx.opt_parent(ctor_id)\n+            {\n+                let method = if cx.tcx.lang_items().option_none_variant() == Some(variant_id) {\n+                    \"is_none()\"\n+                } else if cx.tcx.lang_items().poll_pending_variant() == Some(variant_id) {\n+                    \"is_pending()\"\n+                } else {\n+                    return;\n+                };\n+                // `None` and `Pending` don't have an inner type.\n+                (method, cx.tcx.types.unit)\n             } else {\n                 return;\n-            };\n-            // `None` and `Pending` don't have an inner type.\n-            (method, cx.tcx.types.unit)\n+            }\n         },\n         _ => return,\n     };"}, {"sha": "c6cba81d8718972e89d436f83a3b4ef2facd37e2", "filename": "clippy_lints/src/matches/try_err.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n+use clippy_utils::{get_parent_expr, is_res_lang_ctor, match_def_path, path_res, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::ResultErr;\n@@ -27,8 +27,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, scrutine\n         if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n         if matches!(match_fun_path, QPath::LangItem(LangItem::TryTraitBranch, ..));\n         if let ExprKind::Call(err_fun, [err_arg, ..]) = try_arg.kind;\n-        if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n-        if is_lang_ctor(cx, err_fun_path, ResultErr);\n+        if is_res_lang_ctor(cx, path_res(cx, err_fun), ResultErr);\n         if let Some(return_ty) = find_return_type(cx, &expr.kind);\n         then {\n             let prefix;"}, {"sha": "0c4d9f100f7a966f7c3bade76f7e3843b3518f70", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_non_aggregate_primitive_type;\n-use clippy_utils::{is_default_equivalent, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{is_default_equivalent, is_res_lang_ctor, meets_msrv, msrvs, path_res};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n@@ -102,40 +102,38 @@ impl_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    if let ExprKind::Path(ref replacement_qpath) = src.kind {\n-        // Check that second argument is `Option::None`\n-        if is_lang_ctor(cx, replacement_qpath, OptionNone) {\n-            // Since this is a late pass (already type-checked),\n-            // and we already know that the second argument is an\n-            // `Option`, we do not need to check the first\n-            // argument's type. All that's left is to get\n-            // replacee's path.\n-            let replaced_path = match dest.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n-                    if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n-                        replaced_path\n-                    } else {\n-                        return;\n-                    }\n-                },\n-                ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n-                _ => return,\n-            };\n+    // Check that second argument is `Option::None`\n+    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+        // Since this is a late pass (already type-checked),\n+        // and we already know that the second argument is an\n+        // `Option`, we do not need to check the first\n+        // argument's type. All that's left is to get\n+        // replacee's path.\n+        let replaced_path = match dest.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n+                if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n+                    replaced_path\n+                } else {\n+                    return;\n+                }\n+            },\n+            ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n+            _ => return,\n+        };\n \n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                MEM_REPLACE_OPTION_WITH_NONE,\n-                expr_span,\n-                \"replacing an `Option` with `None`\",\n-                \"consider `Option::take()` instead\",\n-                format!(\n-                    \"{}.take()\",\n-                    snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n-                ),\n-                applicability,\n-            );\n-        }\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            MEM_REPLACE_OPTION_WITH_NONE,\n+            expr_span,\n+            \"replacing an `Option` with `None`\",\n+            \"consider `Option::take()` instead\",\n+            format!(\n+                \"{}.take()\",\n+                snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n     }\n }\n \n@@ -203,10 +201,8 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n         return;\n     }\n     // disable lint for Option since it is covered in another lint\n-    if let ExprKind::Path(q) = &src.kind {\n-        if is_lang_ctor(cx, q, OptionNone) {\n-            return;\n-        }\n+    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+        return;\n     }\n     if is_default_equivalent(cx, src) && !in_external_macro(cx.tcx.sess, expr_span) {\n         span_lint_and_then("}, {"sha": "4f73b3ec42247e56bacf4f6d9df9a1506095c6e7", "filename": "clippy_lints/src/methods/iter_on_single_or_empty_collections.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::{get_expr_use_or_unification_node, is_lang_ctor, is_no_std_crate};\n+use clippy_utils::{get_expr_use_or_unification_node, is_no_std_crate, is_res_lang_ctor, path_res};\n \n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -26,26 +26,11 @@ impl IterType {\n }\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, method_name: &str, recv: &Expr<'_>) {\n-    let item = match &recv.kind {\n-        ExprKind::Array(v) if v.len() <= 1 => v.first(),\n-        ExprKind::Path(p) => {\n-            if is_lang_ctor(cx, p, OptionNone) {\n-                None\n-            } else {\n-                return;\n-            }\n-        },\n-        ExprKind::Call(f, some_args) if some_args.len() == 1 => {\n-            if let ExprKind::Path(p) = &f.kind {\n-                if is_lang_ctor(cx, p, OptionSome) {\n-                    Some(&some_args[0])\n-                } else {\n-                    return;\n-                }\n-            } else {\n-                return;\n-            }\n-        },\n+    let item = match recv.kind {\n+        ExprKind::Array([]) => None,\n+        ExprKind::Array([e]) => Some(e),\n+        ExprKind::Path(ref p) if is_res_lang_ctor(cx, cx.qpath_res(p, recv.hir_id), OptionNone) => None,\n+        ExprKind::Call(f, [arg]) if is_res_lang_ctor(cx, path_res(cx, f), OptionSome) => Some(arg),\n         _ => return,\n     };\n     let iter_type = match method_name {"}, {"sha": "5b758f1e6547c676ea7dca16710969e9df4834ec", "filename": "clippy_lints/src/methods/manual_ok_or.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use clippy_utils::{is_res_lang_ctor, path_res, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n-use rustc_hir::{Closure, Expr, ExprKind, PatKind};\n+use rustc_hir::{Expr, ExprKind, PatKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n@@ -22,8 +22,8 @@ pub(super) fn check<'tcx>(\n         if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n         if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Option);\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, [err_arg]) = or_expr.kind;\n-        if is_lang_ctor(cx, err_path, ResultErr);\n+        if let ExprKind::Call(err_path, [err_arg]) = or_expr.kind;\n+        if is_res_lang_ctor(cx, path_res(cx, err_path), ResultErr);\n         if is_ok_wrapping(cx, map_expr);\n         if let Some(recv_snippet) = snippet_opt(cx, recv.span);\n         if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n@@ -46,17 +46,19 @@ pub(super) fn check<'tcx>(\n }\n \n fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Path(ref qpath) = map_expr.kind {\n-        if is_lang_ctor(cx, qpath, ResultOk) {\n-            return true;\n-        }\n-    }\n-    if_chain! {\n-        if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n-        let body = cx.tcx.hir().body(body);\n-        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, [ok_arg]) = body.value.kind;\n-        if is_lang_ctor(cx, ok_path, ResultOk);\n-        then { path_to_local_id(ok_arg, param_id) } else { false }\n+    match map_expr.kind {\n+        ExprKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, map_expr.hir_id), ResultOk) => true,\n+        ExprKind::Closure(closure) => {\n+            let body = cx.tcx.hir().body(closure.body);\n+            if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind\n+                && let ExprKind::Call(callee, [ok_arg]) = body.value.kind\n+                && is_res_lang_ctor(cx, path_res(cx, callee), ResultOk)\n+            {\n+                path_to_local_id(ok_arg, param_id)\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n     }\n }"}, {"sha": "3a23ecc50dc1d4dc76b90fd721220eed395b40dc", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_def_id};\n+use clippy_utils::{is_res_lang_ctor, path_def_id, path_res};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -51,22 +51,12 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-        is_lang_ctor(cx, qpath, OptionNone)\n-    } else {\n-        return;\n-    };\n-\n-    if !default_arg_is_none {\n+    if !is_res_lang_ctor(cx, path_res(cx, def_arg), OptionNone) {\n         // nothing to lint!\n         return;\n     }\n \n-    let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-        is_lang_ctor(cx, qpath, OptionSome)\n-    } else {\n-        false\n-    };\n+    let f_arg_is_some = is_res_lang_ctor(cx, path_res(cx, map_arg), OptionSome);\n \n     if is_option {\n         let self_snippet = snippet(cx, recv.span, \"..\");"}, {"sha": "55ba6e262df7e1d44b2f3555eddec6f4b26f9d26", "filename": "clippy_lints/src/methods/or_then_unwrap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{diagnostics::span_lint_and_sugg, is_lang_ctor};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, is_res_lang_ctor, path_res};\n use rustc_errors::Applicability;\n use rustc_hir::{lang_items::LangItem, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -58,8 +58,7 @@ pub(super) fn check<'tcx>(\n \n fn get_content_if_ctor_matches(cx: &LateContext<'_>, expr: &Expr<'_>, item: LangItem) -> Option<Span> {\n     if let ExprKind::Call(some_expr, [arg]) = expr.kind\n-        && let ExprKind::Path(qpath) = &some_expr.kind\n-        && is_lang_ctor(cx, qpath, item)\n+        && is_res_lang_ctor(cx, path_res(cx, some_expr), item)\n     {\n         Some(arg.span)\n     } else {"}, {"sha": "50434a5658ac5cb3ce9c96f2066708cb70d89ca9", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -2,7 +2,7 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n-use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n+use clippy_utils::{is_res_lang_ctor, is_trait_method, path_res, path_to_local_id};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -61,15 +61,13 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n \n // returns (found_mapping, found_filtering)\n fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> (bool, bool) {\n-    match &expr.kind {\n+    match expr.kind {\n         hir::ExprKind::Call(func, args) => {\n-            if let hir::ExprKind::Path(ref path) = func.kind {\n-                if is_lang_ctor(cx, path, OptionSome) {\n-                    if path_to_local_id(&args[0], arg_id) {\n-                        return (false, false);\n-                    }\n-                    return (true, false);\n+            if is_res_lang_ctor(cx, path_res(cx, func), OptionSome) {\n+                if path_to_local_id(&args[0], arg_id) {\n+                    return (false, false);\n                 }\n+                return (true, false);\n             }\n             (true, true)\n         },\n@@ -80,7 +78,7 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;\n-            for arm in *arms {\n+            for arm in arms {\n                 let (m, f) = check_expression(cx, arg_id, arm.body);\n                 found_mapping |= m;\n                 found_filtering |= f;\n@@ -93,7 +91,9 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             let else_check = check_expression(cx, arg_id, else_arm);\n             (if_check.0 | else_check.0, if_check.1 | else_check.1)\n         },\n-        hir::ExprKind::Path(path) if is_lang_ctor(cx, path, OptionNone) => (false, true),\n+        hir::ExprKind::Path(ref path) if is_res_lang_ctor(cx, cx.qpath_res(path, expr.hir_id), OptionNone) => {\n+            (false, true)\n+        },\n         _ => (true, true),\n     }\n }"}, {"sha": "97c8cfbd3eb7a195cda0aa3b4a1caa7ffdfcde40", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lang_ctor;\n+use clippy_utils::path_res;\n use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{AsyncGeneratorKind, Block, Body, Expr, ExprKind, GeneratorKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::DefIdTree;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -112,11 +113,12 @@ impl LateLintPass<'_> for NeedlessQuestionMark {\n \n fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Call(path, [arg]) = &expr.kind;\n-        if let ExprKind::Path(ref qpath) = &path.kind;\n-        let sugg_remove = if is_lang_ctor(cx, qpath, OptionSome) {\n+        if let ExprKind::Call(path, [arg]) = expr.kind;\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = path_res(cx, path);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        let sugg_remove = if cx.tcx.lang_items().option_some_variant() == Some(variant_id) {\n             \"Some()\"\n-        } else if is_lang_ctor(cx, qpath, ResultOk) {\n+        } else if cx.tcx.lang_items().result_ok_variant() == Some(variant_id) {\n             \"Ok()\"\n         } else {\n             return;"}, {"sha": "4eb42da1fed02a1bdabb2dab559c36498e31b310", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n+    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_res_lang_ctor, peel_blocks,\n     peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n@@ -174,7 +174,8 @@ fn try_get_option_occurrence<'tcx>(\n \n fn try_get_inner_pat<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<&'tcx Pat<'tcx>> {\n     if let PatKind::TupleStruct(ref qpath, [inner_pat], ..) = pat.kind {\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk) {\n+        let res = cx.qpath_res(qpath, pat.hir_id);\n+        if is_res_lang_ctor(cx, res, OptionSome) || is_res_lang_ctor(cx, res, ResultOk) {\n             return Some(inner_pat);\n         }\n     }\n@@ -226,9 +227,10 @@ fn try_convert_match<'tcx>(\n \n fn is_none_or_err_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     match arm.pat.kind {\n-        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n         PatKind::TupleStruct(ref qpath, [first_pat], _) => {\n-            is_lang_ctor(cx, qpath, ResultErr) && matches!(first_pat.kind, PatKind::Wild)\n+            is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), ResultErr)\n+                && matches!(first_pat.kind, PatKind::Wild)\n         },\n         PatKind::Wild => true,\n         _ => false,"}, {"sha": "6810a2431758910ab3a62bf5ac25286882ac5e97", "filename": "clippy_lints/src/partialeq_to_none.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::{\n-    diagnostics::span_lint_and_sugg, is_lang_ctor, peel_hir_expr_refs, peel_ref_operators, sugg,\n+    diagnostics::span_lint_and_sugg, is_res_lang_ctor, path_res, peel_hir_expr_refs, peel_ref_operators, sugg,\n     ty::is_type_diagnostic_item,\n };\n use rustc_errors::Applicability;\n@@ -54,8 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialeqToNone {\n         // If the expression is a literal `Option::None`\n         let is_none_ctor = |expr: &Expr<'_>| {\n             !expr.span.from_expansion()\n-                && matches!(&peel_hir_expr_refs(expr).0.kind,\n-            ExprKind::Path(p) if is_lang_ctor(cx, p, LangItem::OptionNone))\n+                && is_res_lang_ctor(cx, path_res(cx, peel_hir_expr_refs(expr).0), LangItem::OptionNone)\n         };\n \n         let mut applicability = Applicability::MachineApplicable;"}, {"sha": "328371fd602f0c517c9c48a6ff2a6585535e90ba", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -3,11 +3,12 @@ use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    eq_expr_value, get_parent_node, in_constant, is_else_clause, is_lang_ctor, path_to_local, path_to_local_id,\n+    eq_expr_value, get_parent_node, in_constant, is_else_clause, is_res_lang_ctor, path_to_local, path_to_local_id,\n     peel_blocks, peel_blocks_with_stmt,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n use rustc_hir::{BindingAnnotation, ByRef, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -58,7 +59,7 @@ enum IfBlockType<'hir> {\n     /// Contains: let_pat_qpath (Xxx), let_pat_type, let_pat_sym (a), let_expr (b), if_then (c),\n     /// if_else (d)\n     IfLet(\n-        &'hir QPath<'hir>,\n+        Res,\n         Ty<'hir>,\n         Symbol,\n         &'hir Expr<'hir>,\n@@ -126,7 +127,14 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         if ddpos.as_opt_usize().is_none();\n         if let PatKind::Binding(BindingAnnotation(by_ref, _), bind_id, ident, None) = field.kind;\n         let caller_ty = cx.typeck_results().expr_ty(let_expr);\n-        let if_block = IfBlockType::IfLet(path1, caller_ty, ident.name, let_expr, if_then, if_else);\n+        let if_block = IfBlockType::IfLet(\n+            cx.qpath_res(path1, let_pat.hir_id),\n+            caller_ty,\n+            ident.name,\n+            let_expr,\n+            if_then,\n+            if_else\n+        );\n         if (is_early_return(sym::Option, cx, &if_block) && path_to_local_id(peel_blocks(if_then), bind_id))\n             || is_early_return(sym::Result, cx, &if_block);\n         if if_else.map(|e| eq_expr_value(cx, let_expr, peel_blocks(e))).filter(|e| *e).is_none();\n@@ -165,21 +173,21 @@ fn is_early_return(smbl: Symbol, cx: &LateContext<'_>, if_block: &IfBlockType<'_\n                     _ => false,\n                 }\n         },\n-        IfBlockType::IfLet(qpath, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n+        IfBlockType::IfLet(res, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n             is_type_diagnostic_item(cx, let_expr_ty, smbl)\n                 && match smbl {\n                     sym::Option => {\n                         // We only need to check `if let Some(x) = option` not `if let None = option`,\n                         // because the later one will be suggested as `if option.is_none()` thus causing conflict.\n-                        is_lang_ctor(cx, qpath, OptionSome)\n+                        is_res_lang_ctor(cx, res, OptionSome)\n                             && if_else.is_some()\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, None)\n                     },\n                     sym::Result => {\n-                        (is_lang_ctor(cx, qpath, ResultOk)\n+                        (is_res_lang_ctor(cx, res, ResultOk)\n                             && if_else.is_some()\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, Some(let_pat_sym)))\n-                            || is_lang_ctor(cx, qpath, ResultErr)\n+                            || is_res_lang_ctor(cx, res, ResultErr)\n                                 && expr_return_none_or_err(smbl, cx, if_then, let_expr, Some(let_pat_sym))\n                     },\n                     _ => false,\n@@ -198,7 +206,7 @@ fn expr_return_none_or_err(\n     match peel_blocks_with_stmt(expr).kind {\n         ExprKind::Ret(Some(ret_expr)) => expr_return_none_or_err(smbl, cx, ret_expr, cond_expr, err_sym),\n         ExprKind::Path(ref qpath) => match smbl {\n-            sym::Option => is_lang_ctor(cx, qpath, OptionNone),\n+            sym::Option => is_res_lang_ctor(cx, cx.qpath_res(qpath, expr.hir_id), OptionNone),\n             sym::Result => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         },"}, {"sha": "7211e6864f3a93b92692bb9ec524f34067814122", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{contains_return, is_lang_ctor, return_ty, visitors::find_all_ret_expressions};\n+use clippy_utils::{contains_return, is_res_lang_ctor, path_res, return_ty, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -120,9 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                 if !ret_expr.span.from_expansion();\n                 // Check if a function call.\n                 if let ExprKind::Call(func, [arg]) = ret_expr.kind;\n-                // Check if OPTION_SOME or RESULT_OK, depending on return type.\n-                if let ExprKind::Path(qpath) = &func.kind;\n-                if is_lang_ctor(cx, qpath, lang_item);\n+                if is_res_lang_ctor(cx, path_res(cx, func), lang_item);\n                 // Make sure the function argument does not contain a return expression.\n                 if !contains_return(arg);\n                 then {"}, {"sha": "c7cc5d04c85992bd6bfff0ff8baad807c85c33d5", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e7af6b42961d6a4b6857c06aa5139a985e0009d/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=8e7af6b42961d6a4b6857c06aa5139a985e0009d", "patch": "@@ -238,17 +238,27 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n     }\n }\n \n-/// Checks if a `QPath` resolves to a constructor of a `LangItem`.\n+/// Checks if a `Res` refers to a constructor of a `LangItem`\n /// For example, use this to check whether a function call or a pattern is `Some(..)`.\n-pub fn is_lang_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, lang_item: LangItem) -> bool {\n-    if let QPath::Resolved(_, path) = qpath {\n-        if let Res::Def(DefKind::Ctor(..), ctor_id) = path.res {\n-            if let Ok(item_id) = cx.tcx.lang_items().require(lang_item) {\n-                return cx.tcx.parent(ctor_id) == item_id;\n-            }\n-        }\n+pub fn is_res_lang_ctor(cx: &LateContext<'_>, res: Res, lang_item: LangItem) -> bool {\n+    if let Res::Def(DefKind::Ctor(..), id) = res\n+        && let Ok(lang_id) = cx.tcx.lang_items().require(lang_item)\n+        && let Some(id) = cx.tcx.opt_parent(id)\n+    {\n+        id == lang_id\n+    } else {\n+        false\n+    }\n+}\n+\n+pub fn is_res_diagnostic_ctor(cx: &LateContext<'_>, res: Res, diag_item: Symbol) -> bool {\n+    if let Res::Def(DefKind::Ctor(..), id) = res\n+        && let Some(id) = cx.tcx.opt_parent(id)\n+    {\n+        cx.tcx.is_diagnostic_item(diag_item, id)\n+    } else {\n+        false\n     }\n-    false\n }\n \n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n@@ -738,7 +748,7 @@ pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n             }\n         },\n         ExprKind::Call(repl_func, _) => is_default_equivalent_call(cx, repl_func),\n-        ExprKind::Path(qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        ExprKind::Path(qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, e.hir_id), OptionNone),\n         ExprKind::AddrOf(rustc_hir::BorrowKind::Ref, _, expr) => matches!(expr.kind, ExprKind::Array([])),\n         _ => false,\n     }\n@@ -1553,7 +1563,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n         if_chain! {\n             if let PatKind::TupleStruct(ref path, pat, ddpos) = arm.pat.kind;\n             if ddpos.as_opt_usize().is_none();\n-            if is_lang_ctor(cx, path, ResultOk);\n+            if is_res_lang_ctor(cx, cx.qpath_res(path, arm.pat.hir_id), ResultOk);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n             if path_to_local_id(arm.body, hir_id);\n             then {\n@@ -1565,7 +1575,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n \n     fn is_err(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n-            is_lang_ctor(cx, path, ResultErr)\n+            is_res_lang_ctor(cx, cx.qpath_res(path, arm.pat.hir_id), ResultErr)\n         } else {\n             false\n         }"}]}