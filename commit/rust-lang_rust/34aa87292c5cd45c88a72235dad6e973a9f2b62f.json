{"sha": "34aa87292c5cd45c88a72235dad6e973a9f2b62f", "node_id": "C_kwDOAAsO6NoAKDM0YWE4NzI5MmM1Y2Q0NWM4OGE3MjIzNWRhZDZlOTczYTlmMmI2MmY", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2023-03-14T15:42:34Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2023-03-14T15:42:34Z"}, "message": "std: leak remaining messages in bounded channel if message destructor panics", "tree": {"sha": "2250ebd09125a84eae1c8e08c7d597ffc693a64b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2250ebd09125a84eae1c8e08c7d597ffc693a64b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34aa87292c5cd45c88a72235dad6e973a9f2b62f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmQQleoACgkQcE4BSbAZ\nSzxnOA//bcs6f5X4wLfL9bHBXAupgHfpW3T54BMmVIhTEOcuc7FlsqFlDapxzQds\ntl3OdUpDXBpMMQfZ7TEjKjdgJXJFce04hLHBJKY3/IoUgctmT5XfCorVj+cXO78z\nAwrZ5+GN2wkLXf8YL5/3Vp7Y/+rz0nl/6EMUz0xHmN8PO+70EQj6OsyGYjkT1Cpn\nPsQe+L4FGRac3o4QsprN1k0j2etA8bM3PmO3my3XmJFiFpg3gMAiXgDUUfXo9h0d\n0Ik/n6TxqBmKIWefR6lXCN7eoLmbUig3cSqnh431S3dsO4Z/QhtxdpUEb9USmH3i\nIi7qoByU/gA0C8BGlid3c6S0aqilLBR4JK5quuEKugxzfRBnsFT7Ir44R2uUfP8S\nQLG9r9HbN5tsYezB7nPtawCBJHzoalpJdpyBJVN3cb7LEifEYKdstsvNET5YjAlT\nOHaJBHLd1minmPVZYYQXtdY3bZoD8Hkrcjt4ZkuWlI81Oe1YyDAYmqmMQxTnuK0C\nB4jQxXyIMO0NZF1cs99HMhqTSoFP/iTyzIc7Pl/2MbRwN9mzZKHhs6pqcnrpCmqN\nZmApZdFf0tS3FOnwQ0QpQ5WqS8J+UtwzF4QK6nn4Dvyx2HKo00E4mja1bGxxzsks\n/WyRovxpz/cO3fJM7HF5sh5cUvM59RY0CO/tAFZoz/SqxRHNDNk=\n=DuK8\n-----END PGP SIGNATURE-----", "payload": "tree 2250ebd09125a84eae1c8e08c7d597ffc693a64b\nparent 4e9e465bd4cbdfe3946ea6f0ff4786f2f495a020\nauthor joboet <jonasboettiger@icloud.com> 1678808554 +0100\ncommitter joboet <jonasboettiger@icloud.com> 1678808554 +0100\n\nstd: leak remaining messages in bounded channel if message destructor panics\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34aa87292c5cd45c88a72235dad6e973a9f2b62f", "html_url": "https://github.com/rust-lang/rust/commit/34aa87292c5cd45c88a72235dad6e973a9f2b62f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34aa87292c5cd45c88a72235dad6e973a9f2b62f/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e9e465bd4cbdfe3946ea6f0ff4786f2f495a020", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9e465bd4cbdfe3946ea6f0ff4786f2f495a020", "html_url": "https://github.com/rust-lang/rust/commit/4e9e465bd4cbdfe3946ea6f0ff4786f2f495a020"}], "stats": {"total": 108, "additions": 42, "deletions": 66}, "files": [{"sha": "492e21d9bdb634b737e1a0d15ff2ba16adf1a732", "filename": "library/std/src/sync/mpmc/array.rs", "status": "modified", "additions": 42, "deletions": 66, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/34aa87292c5cd45c88a72235dad6e973a9f2b62f/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34aa87292c5cd45c88a72235dad6e973a9f2b62f/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Farray.rs?ref=34aa87292c5cd45c88a72235dad6e973a9f2b62f", "patch": "@@ -15,7 +15,7 @@ use super::utils::{Backoff, CachePadded};\n use super::waker::SyncWaker;\n \n use crate::cell::UnsafeCell;\n-use crate::mem::{self, MaybeUninit};\n+use crate::mem::MaybeUninit;\n use crate::ptr;\n use crate::sync::atomic::{self, AtomicUsize, Ordering};\n use crate::time::Instant;\n@@ -479,82 +479,58 @@ impl<T> Channel<T> {\n     ///\n     /// `tail` should be the current (and therefore last) value of `tail`.\n     ///\n+    /// # Panicking\n+    /// If a destructor panics, the remaining messages are leaked, matching the\n+    /// behaviour of the unbounded channel.\n+    ///\n     /// # Safety\n     /// This method must only be called when dropping the last receiver. The\n     /// destruction of all other receivers must have been observed with acquire\n     /// ordering or stronger.\n     unsafe fn discard_all_messages(&self, tail: usize) {\n         debug_assert!(self.is_disconnected());\n \n-        /// Use a helper struct with a custom `Drop` to ensure all messages are\n-        /// dropped, even if a destructor panicks.\n-        struct DiscardState<'a, T> {\n-            channel: &'a Channel<T>,\n-            head: usize,\n-            tail: usize,\n-            backoff: Backoff,\n-        }\n+        // Only receivers modify `head`, so since we are the last one,\n+        // this value will not change and will not be observed (since\n+        // no new messages can be sent after disconnection).\n+        let mut head = self.head.load(Ordering::Relaxed);\n+        let tail = tail & !self.mark_bit;\n \n-        impl<'a, T> DiscardState<'a, T> {\n-            fn discard(&mut self) {\n-                loop {\n-                    // Deconstruct the head.\n-                    let index = self.head & (self.channel.mark_bit - 1);\n-                    let lap = self.head & !(self.channel.one_lap - 1);\n-\n-                    // Inspect the corresponding slot.\n-                    debug_assert!(index < self.channel.buffer.len());\n-                    let slot = unsafe { self.channel.buffer.get_unchecked(index) };\n-                    let stamp = slot.stamp.load(Ordering::Acquire);\n-\n-                    // If the stamp is ahead of the head by 1, we may drop the message.\n-                    if self.head + 1 == stamp {\n-                        self.head = if index + 1 < self.channel.cap {\n-                            // Same lap, incremented index.\n-                            // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n-                            self.head + 1\n-                        } else {\n-                            // One lap forward, index wraps around to zero.\n-                            // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n-                            lap.wrapping_add(self.channel.one_lap)\n-                        };\n-\n-                        // We updated the head, so even if this descrutor panics,\n-                        // we will not attempt to destroy the slot again.\n-                        unsafe {\n-                            (*slot.msg.get()).assume_init_drop();\n-                        }\n-                    // If the tail equals the head, that means the channel is empty.\n-                    } else if self.tail == self.head {\n-                        return;\n-                    // Otherwise, a sender is about to write into the slot, so we need\n-                    // to wait for it to update the stamp.\n-                    } else {\n-                        self.backoff.spin_heavy();\n-                    }\n-                }\n-            }\n-        }\n+        let backoff = Backoff::new();\n+        loop {\n+            // Deconstruct the head.\n+            let index = head & (self.mark_bit - 1);\n+            let lap = head & !(self.one_lap - 1);\n \n-        impl<'a, T> Drop for DiscardState<'a, T> {\n-            fn drop(&mut self) {\n-                self.discard();\n+            // Inspect the corresponding slot.\n+            debug_assert!(index < self.buffer.len());\n+            let slot = unsafe { self.buffer.get_unchecked(index) };\n+            let stamp = slot.stamp.load(Ordering::Acquire);\n+\n+            // If the stamp is ahead of the head by 1, we may drop the message.\n+            if head + 1 == stamp {\n+                head = if index + 1 < self.cap {\n+                    // Same lap, incremented index.\n+                    // Set to `{ lap: lap, mark: 0, index: index + 1 }`.\n+                    head + 1\n+                } else {\n+                    // One lap forward, index wraps around to zero.\n+                    // Set to `{ lap: lap.wrapping_add(1), mark: 0, index: 0 }`.\n+                    lap.wrapping_add(self.one_lap)\n+                };\n+\n+                unsafe {\n+                    (*slot.msg.get()).assume_init_drop();\n+                }\n+            // If the tail equals the head, that means the channel is empty.\n+            } else if tail == head {\n+                return;\n+            // Otherwise, a sender is about to write into the slot, so we need\n+            // to wait for it to update the stamp.\n+            } else {\n+                backoff.spin_heavy();\n             }\n         }\n-\n-        let mut state = DiscardState {\n-            channel: self,\n-            // Only receivers modify `head`, so since we are the last one,\n-            // this value will not change and will not be observed (since\n-            // no new messages can be sent after disconnection).\n-            head: self.head.load(Ordering::Relaxed),\n-            tail: tail & !self.mark_bit,\n-            backoff: Backoff::new(),\n-        };\n-        state.discard();\n-        // This point is only reached if no destructor panics, so all messages\n-        // have already been dropped.\n-        mem::forget(state);\n     }\n \n     /// Returns `true` if the channel is disconnected."}]}