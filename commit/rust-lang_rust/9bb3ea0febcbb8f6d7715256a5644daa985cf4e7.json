{"sha": "9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYjNlYTBmZWJjYmI4ZjZkNzcxNTI1NmE1NjQ0ZGFhOTg1Y2Y0ZTc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T02:19:34Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-26T02:20:14Z"}, "message": "Rollup merge of #34436 - jseyfried:no_block_expr, r=eddyb\n\nTo allow these braced macro invocation, this PR removes the optional expression from `ast::Block` and instead uses a `StmtKind::Expr` at the end of the statement list.\n\nCurrently, braced macro invocations in blocks can expand into statements (and items) except when they are last in a block, in which case they can only expand into expressions.\n\nFor example,\n```rust\nmacro_rules! make_stmt {\n    () => { let x = 0; }\n}\n\nfn f() {\n    make_stmt! {} //< This is OK...\n    let x = 0; //< ... unless this line is commented out.\n}\n```\n\nFixes #34418.", "tree": {"sha": "eeed21468b6bceeed80766490852c8cee2653170", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeed21468b6bceeed80766490852c8cee2653170"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "html_url": "https://github.com/rust-lang/rust/commit/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eddf0280014972e051856dfe949054acf53c043", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eddf0280014972e051856dfe949054acf53c043", "html_url": "https://github.com/rust-lang/rust/commit/8eddf0280014972e051856dfe949054acf53c043"}, {"sha": "8cad25199acb346bf8d6b1771f1f50dc9e59374c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cad25199acb346bf8d6b1771f1f50dc9e59374c", "html_url": "https://github.com/rust-lang/rust/commit/8cad25199acb346bf8d6b1771f1f50dc9e59374c"}], "stats": {"total": 277, "additions": 161, "deletions": 116}, "files": [{"sha": "5b655522f342f6ef82149b52f6009924e2093af3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -574,10 +574,23 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_block(&mut self, b: &Block) -> P<hir::Block> {\n+        let mut stmts = Vec::new();\n+        let mut expr = None;\n+\n+        if let Some((last, rest)) = b.stmts.split_last() {\n+            stmts = rest.iter().map(|s| self.lower_stmt(s)).collect::<Vec<_>>();\n+            let last = self.lower_stmt(last);\n+            if let hir::StmtExpr(e, _) = last.node {\n+                expr = Some(e);\n+            } else {\n+                stmts.push(last);\n+            }\n+        }\n+\n         P(hir::Block {\n             id: b.id,\n-            stmts: b.stmts.iter().map(|s| self.lower_stmt(s)).collect(),\n-            expr: b.expr.as_ref().map(|ref x| self.lower_expr(x)),\n+            stmts: stmts.into(),\n+            expr: expr,\n             rules: self.lower_block_check_mode(&b.rules),\n             span: b.span,\n         })"}, {"sha": "eb442c0a34e74cb68ba015fb765b3f2e61e262c3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -763,6 +763,9 @@ pub fn phase_2_configure_and_expand<'a>(sess: &Session,\n }\n \n pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n+    use syntax::ptr::P;\n+    use syntax::util::move_map::MoveMap;\n+\n     struct NodeIdAssigner<'a> {\n         sess: &'a Session,\n     }\n@@ -772,6 +775,27 @@ pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n             assert_eq!(old_id, ast::DUMMY_NODE_ID);\n             self.sess.next_node_id()\n         }\n+\n+        fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n+            block.map(|mut block| {\n+                block.id = self.new_id(block.id);\n+\n+                let stmt = block.stmts.pop();\n+                block.stmts = block.stmts.move_flat_map(|s| self.fold_stmt(s).into_iter());\n+                if let Some(ast::Stmt { node: ast::StmtKind::Expr(expr), span, .. }) = stmt {\n+                    let expr = self.fold_expr(expr);\n+                    block.stmts.push(ast::Stmt {\n+                        id: expr.id,\n+                        node: ast::StmtKind::Expr(expr),\n+                        span: span,\n+                    });\n+                } else if let Some(stmt) = stmt {\n+                    block.stmts.extend(self.fold_stmt(stmt));\n+                }\n+\n+                block\n+            })\n+        }\n     }\n \n     let krate = time(sess.time_passes(),"}, {"sha": "baac455a25f334c7c6c6a3194f0ed6c00f44da56", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -657,8 +657,11 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n         fn expr_to_block(rules: ast::BlockCheckMode, e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-                expr: e,\n-                stmts: vec![],\n+                stmts: e.map(|e| ast::Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: e.span,\n+                    node: ast::StmtKind::Expr(e),\n+                }).into_iter().collect(),\n                 rules: rules,\n                 id: ast::DUMMY_NODE_ID,\n                 span: syntax_pos::DUMMY_SP,"}, {"sha": "a352715b20b129a21ec56e1776a8a897b932f778", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -557,9 +557,6 @@ impl PartialEq for MetaItemKind {\n pub struct Block {\n     /// Statements in a block\n     pub stmts: Vec<Stmt>,\n-    /// An expression at the end of the block\n-    /// without a semicolon, if any\n-    pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n@@ -832,7 +829,7 @@ pub enum StmtKind {\n     /// An item definition.\n     Item(P<Item>),\n \n-    /// Expr without trailing semi-colon (must have unit type).\n+    /// Expr without trailing semi-colon.\n     Expr(P<Expr>),\n \n     Semi(P<Expr>),"}, {"sha": "435241f426ec6f4329e90a2dc6dea8c093e3e723", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -88,6 +88,7 @@ pub trait AstBuilder {\n \n     // statements\n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;\n+    fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: P<ast::Expr>) -> ast::Stmt;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n@@ -99,12 +100,8 @@ pub trait AstBuilder {\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n     // blocks\n-    fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n-             expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n+    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n-    fn block_all(&self, span: Span,\n-                 stmts: Vec<ast::Stmt>,\n-                 expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n     // expressions\n     fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr>;\n@@ -509,6 +506,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: expr.span,\n+            node: ast::StmtKind::Expr(expr),\n+        }\n+    }\n+\n+    fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n             span: expr.span,\n@@ -567,11 +572,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n-    fn block(&self, span: Span, stmts: Vec<ast::Stmt>,\n-             expr: Option<P<Expr>>) -> P<ast::Block> {\n-        self.block_all(span, stmts, expr)\n-    }\n-\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -581,19 +581,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n-        self.block_all(expr.span, Vec::new(), Some(expr))\n-    }\n-    fn block_all(&self,\n-                 span: Span,\n-                 stmts: Vec<ast::Stmt>,\n-                 expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n-            P(ast::Block {\n-               stmts: stmts,\n-               expr: expr,\n-               id: ast::DUMMY_NODE_ID,\n-               rules: BlockCheckMode::Default,\n-               span: span,\n-            })\n+        self.block(expr.span, vec![ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            span: expr.span,\n+            node: ast::StmtKind::Expr(expr),\n+        }])\n+    }\n+    fn block(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Block> {\n+        P(ast::Block {\n+           stmts: stmts,\n+           id: ast::DUMMY_NODE_ID,\n+           rules: BlockCheckMode::Default,\n+           span: span,\n+        })\n     }\n \n     fn expr(&self, span: Span, node: ast::ExprKind) -> P<ast::Expr> {\n@@ -962,14 +962,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     ids: Vec<ast::Ident>,\n                     stmts: Vec<ast::Stmt>)\n                     -> P<ast::Expr> {\n-        self.lambda(span, ids, self.block(span, stmts, None))\n+        self.lambda(span, ids, self.block(span, stmts))\n     }\n     fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n-        self.lambda0(span, self.block(span, stmts, None))\n+        self.lambda0(span, self.block(span, stmts))\n     }\n     fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n-        self.lambda1(span, self.block(span, stmts, None), ident)\n+        self.lambda1(span, self.block(span, stmts), ident)\n     }\n \n     fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {"}, {"sha": "3036a88430a2be6e82360049b2f121f745d15f91", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -611,23 +611,14 @@ pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n \n // expand the elements of a block.\n pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, stmts, expr, rules, span}| {\n+    b.map(|Block {id, stmts, rules, span}| {\n         let new_stmts = stmts.into_iter().flat_map(|x| {\n             // perform pending renames and expand macros in the statement\n             fld.fold_stmt(x).into_iter()\n         }).collect();\n-        let new_expr = expr.map(|x| {\n-            let expr = {\n-                let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n-                let mut rename_fld = IdentRenamer{renames:pending_renames};\n-                rename_fld.fold_expr(x)\n-            };\n-            fld.fold_expr(expr)\n-        });\n         Block {\n             id: fld.new_id(id),\n             stmts: new_stmts,\n-            expr: new_expr,\n             rules: rules,\n             span: span\n         }"}, {"sha": "68527b0797d5b6031da5ca6dcc4a2d9eb2c24341", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -513,10 +513,8 @@ pub fn expand_quote_matcher(cx: &mut ExtCtxt,\n     let (cx_expr, tts) = parse_arguments_to_quote(cx, tts);\n     let mut vector = mk_stmts_let(cx, sp);\n     vector.extend(statements_mk_tts(cx, &tts[..], true));\n-    let block = cx.expr_block(\n-        cx.block_all(sp,\n-                     vector,\n-                     Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+    vector.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+    let block = cx.expr_block(cx.block(sp, vector));\n \n     let expanded = expand_wrapper(cx, sp, cx_expr, block, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]]);\n     base::MacEager::expr(expanded)\n@@ -766,8 +764,9 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, matcher: bool) -> Vec<ast::Stm\n             let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n             let mut tts_stmts = vec![stmt_let_tt];\n             tts_stmts.extend(statements_mk_tts(cx, &seq.tts[..], matcher));\n-            let e_tts = cx.expr_block(cx.block(sp, tts_stmts,\n-                                                   Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+            tts_stmts.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+            let e_tts = cx.expr_block(cx.block(sp, tts_stmts));\n+\n             let e_separator = match seq.separator {\n                 Some(ref sep) => cx.expr_some(sp, expr_mk_token(cx, sp, sep)),\n                 None => cx.expr_none(sp),\n@@ -882,10 +881,8 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[TokenTree])\n \n     let mut vector = mk_stmts_let(cx, sp);\n     vector.extend(statements_mk_tts(cx, &tts[..], false));\n-    let block = cx.expr_block(\n-        cx.block_all(sp,\n-                     vector,\n-                     Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+    vector.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n+    let block = cx.expr_block(cx.block(sp, vector));\n \n     (cx_expr, block)\n }\n@@ -899,13 +896,14 @@ fn expand_wrapper(cx: &ExtCtxt,\n     let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n \n-    let stmts = imports.iter().map(|path| {\n+    let mut stmts = imports.iter().map(|path| {\n         // make item: `use ...;`\n         let path = path.iter().map(|s| s.to_string()).collect();\n         cx.stmt_item(sp, cx.item_use_glob(sp, ast::Visibility::Inherited, ids_ext(path)))\n-    }).chain(Some(stmt_let_ext_cx)).collect();\n+    }).chain(Some(stmt_let_ext_cx)).collect::<Vec<_>>();\n+    stmts.push(cx.stmt_expr(expr));\n \n-    cx.expr_block(cx.block_all(sp, stmts, Some(expr)))\n+    cx.expr_block(cx.block(sp, stmts))\n }\n \n fn expand_parse_call(cx: &ExtCtxt,"}, {"sha": "6789e7be058bfcd7177991c3e2bb7c0b5a9c7176", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -818,10 +818,9 @@ fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block {id, stmts, expr, rules, span}| Block {\n+    b.map(|Block {id, stmts, rules, span}| Block {\n         id: folder.new_id(id),\n         stmts: stmts.move_flat_map(|s| folder.fold_stmt(s).into_iter()),\n-        expr: expr.and_then(|x| folder.fold_opt_expr(x)),\n         rules: rules,\n         span: folder.new_span(span),\n     })"}, {"sha": "bbcc044d43c6b74b8701924847df75867f0a8ec6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -957,7 +957,6 @@ mod tests {\n                                                 attrs: ThinVec::new()})),\n                                             id: ast::DUMMY_NODE_ID,\n                                             span: sp(17,19)}),\n-                                        expr: None,\n                                         id: ast::DUMMY_NODE_ID,\n                                         rules: ast::BlockCheckMode::Default, // no idea\n                                         span: sp(15,21),"}, {"sha": "813d90103b8878000bf4f103078bc3781c3e28dd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -3236,9 +3236,12 @@ impl<'a> Parser<'a> {\n                 let body_expr = self.parse_expr()?;\n                 P(ast::Block {\n                     id: ast::DUMMY_NODE_ID,\n-                    stmts: vec![],\n                     span: body_expr.span,\n-                    expr: Some(body_expr),\n+                    stmts: vec![Stmt {\n+                        span: body_expr.span,\n+                        node: StmtKind::Expr(body_expr),\n+                        id: ast::DUMMY_NODE_ID,\n+                    }],\n                     rules: BlockCheckMode::Default,\n                 })\n             }\n@@ -4098,7 +4101,6 @@ impl<'a> Parser<'a> {\n     /// Precondition: already parsed the '{'.\n     fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n-        let mut expr = None;\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n             let Stmt {node, span, ..} = if let Some(s) = self.parse_stmt_() {\n@@ -4112,10 +4114,10 @@ impl<'a> Parser<'a> {\n \n             match node {\n                 StmtKind::Expr(e) => {\n-                    self.handle_expression_like_statement(e, span, &mut stmts, &mut expr)?;\n+                    self.handle_expression_like_statement(e, span, &mut stmts)?;\n                 }\n                 StmtKind::Mac(mac) => {\n-                    self.handle_macro_in_block(mac.unwrap(), span, &mut stmts, &mut expr)?;\n+                    self.handle_macro_in_block(mac.unwrap(), span, &mut stmts)?;\n                 }\n                 _ => { // all other kinds of statements:\n                     let mut hi = span.hi;\n@@ -4135,7 +4137,6 @@ impl<'a> Parser<'a> {\n \n         Ok(P(ast::Block {\n             stmts: stmts,\n-            expr: expr,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n             span: mk_sp(lo, self.last_span.hi),\n@@ -4145,8 +4146,7 @@ impl<'a> Parser<'a> {\n     fn handle_macro_in_block(&mut self,\n                              (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinVec<Attribute>),\n                              span: Span,\n-                             stmts: &mut Vec<Stmt>,\n-                             last_block_expr: &mut Option<P<Expr>>)\n+                             stmts: &mut Vec<Stmt>)\n                              -> PResult<'a, ()> {\n         if style == MacStmtStyle::NoBraces {\n             // statement macro without braces; might be an\n@@ -4165,7 +4165,7 @@ impl<'a> Parser<'a> {\n                     let lo = e.span.lo;\n                     let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n                     let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                    self.handle_expression_like_statement(e, span, stmts, last_block_expr)?;\n+                    self.handle_expression_like_statement(e, span, stmts)?;\n                 }\n             }\n         } else {\n@@ -4179,11 +4179,6 @@ impl<'a> Parser<'a> {\n                     });\n                     self.bump();\n                 }\n-                token::CloseDelim(token::Brace) => {\n-                    // if a block ends in `m!(arg)` without\n-                    // a `;`, it must be an expr\n-                    *last_block_expr = Some(self.mk_mac_expr(span.lo, span.hi, mac.node, attrs));\n-                }\n                 _ => {\n                     stmts.push(Stmt {\n                         id: ast::DUMMY_NODE_ID,\n@@ -4199,8 +4194,7 @@ impl<'a> Parser<'a> {\n     fn handle_expression_like_statement(&mut self,\n                                         e: P<Expr>,\n                                         span: Span,\n-                                        stmts: &mut Vec<Stmt>,\n-                                        last_block_expr: &mut Option<P<Expr>>)\n+                                        stmts: &mut Vec<Stmt>)\n                                         -> PResult<'a, ()> {\n         // expression without semicolon\n         if classify::expr_requires_semi_to_be_stmt(&e) {\n@@ -4227,7 +4221,6 @@ impl<'a> Parser<'a> {\n                     span: span_with_semi,\n                 });\n             }\n-            token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n             _ => {\n                 stmts.push(Stmt {\n                     id: ast::DUMMY_NODE_ID,"}, {"sha": "b56cec72a956e0555a8b0d5a710c0378c8e72690", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -1619,12 +1619,16 @@ impl<'a> State<'a> {\n                     try!(self.word_space(\"=\"));\n                     try!(self.print_expr(&init));\n                 }\n+                try!(word(&mut self.s, \";\"));\n                 self.end()?;\n             }\n             ast::StmtKind::Item(ref item) => self.print_item(&item)?,\n             ast::StmtKind::Expr(ref expr) => {\n                 try!(self.space_if_not_bol());\n                 try!(self.print_expr_outer_attr_style(&expr, false));\n+                if parse::classify::expr_requires_semi_to_be_stmt(expr) {\n+                    try!(word(&mut self.s, \";\"));\n+                }\n             }\n             ast::StmtKind::Semi(ref expr) => {\n                 try!(self.space_if_not_bol());\n@@ -1646,9 +1650,6 @@ impl<'a> State<'a> {\n                 }\n             }\n         }\n-        if parse::classify::stmt_ends_with_semi(&st.node) {\n-            try!(word(&mut self.s, \";\"));\n-        }\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n@@ -1692,17 +1693,17 @@ impl<'a> State<'a> {\n \n         try!(self.print_inner_attributes(attrs));\n \n-        for st in &blk.stmts {\n-            try!(self.print_stmt(st));\n-        }\n-        match blk.expr {\n-            Some(ref expr) => {\n-                try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&expr, false));\n-                try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n+        for (i, st) in blk.stmts.iter().enumerate() {\n+            match st.node {\n+                ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n+                    try!(self.space_if_not_bol());\n+                    try!(self.print_expr_outer_attr_style(&expr, false));\n+                    try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n+                }\n+                _ => try!(self.print_stmt(st)),\n             }\n-            _ => ()\n         }\n+\n         try!(self.bclose_maybe_open(blk.span, indented, close_box));\n         self.ann.post(self, NodeBlock(blk))\n     }\n@@ -2111,22 +2112,21 @@ impl<'a> State<'a> {\n                     _ => false\n                 };\n \n-                if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    try!(self.print_block_unclosed(&body));\n-                } else {\n-                    // we extract the block, so as not to create another set of boxes\n-                    let i_expr = body.expr.as_ref().unwrap();\n-                    match i_expr.node {\n-                        ast::ExprKind::Block(ref blk) => {\n+                match body.stmts.last().map(|stmt| &stmt.node) {\n+                    Some(&ast::StmtKind::Expr(ref i_expr)) if default_return &&\n+                                                              body.stmts.len() == 1 => {\n+                        // we extract the block, so as not to create another set of boxes\n+                        if let ast::ExprKind::Block(ref blk) = i_expr.node {\n                             try!(self.print_block_unclosed_with_attrs(&blk, &i_expr.attrs));\n-                        }\n-                        _ => {\n+                        } else {\n                             // this is a bare expression\n                             try!(self.print_expr(&i_expr));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n+                    _ => try!(self.print_block_unclosed(&body)),\n                 }\n+\n                 // a box will be closed by print_expr, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close."}, {"sha": "0a60b7fd430c427277fcbe33cf3d7668388c9ae5", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -478,7 +478,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n-    let main_body = ecx.block_all(sp, vec![call_test_main], None);\n+    let main_body = ecx.block(sp, vec![call_test_main]);\n     let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal,\n                            ast::Constness::NotConst,"}, {"sha": "1fc4e54d21807c26145f6d10e98e7d85f34eed15", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -590,7 +590,6 @@ pub fn walk_struct_field<V: Visitor>(visitor: &mut V, struct_field: &StructField\n \n pub fn walk_block<V: Visitor>(visitor: &mut V, block: &Block) {\n     walk_list!(visitor, visit_stmt, &block.stmts);\n-    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {"}, {"sha": "1e47ebb85837a761a9596bfafcb1369ba783db7e", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -145,12 +145,10 @@ fn cs_clone(\n \n     match mode {\n         Mode::Shallow => {\n-            cx.expr_block(cx.block(trait_span,\n-                                   all_fields.iter()\n-                                             .map(subcall)\n-                                             .map(|e| cx.stmt_expr(e))\n-                                             .collect(),\n-                                   Some(cx.expr_deref(trait_span, cx.expr_self(trait_span)))))\n+            let mut stmts: Vec<_> =\n+                all_fields.iter().map(subcall).map(|e| cx.stmt_expr(e)).collect();\n+            stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n+            cx.expr_block(cx.block(trait_span, stmts))\n         }\n         Mode::Deep => {\n             match *vdata {"}, {"sha": "9c5072eeb3e0b79dc9ba58c4b447eba4efc146a9", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -30,7 +30,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 // create `a.<method>(); b.<method>(); c.<method>(); ...`\n                 // (where method is `assert_receiver_is_total_eq`)\n                 let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-                let block = cx.block(span, stmts, None);\n+                let block = cx.block(span, stmts);\n                 cx.expr_block(block)\n             },\n             Box::new(|cx, sp, _, _| {"}, {"sha": "34c872bef11d10916698f2a57a6475dfe798fa66", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -78,7 +78,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n \n     let fmt = substr.nonself_args[0].clone();\n \n-    let stmts = match *substr.fields {\n+    let mut stmts = match *substr.fields {\n         Struct(_, ref fields) | EnumMatching(_, _, ref fields) => {\n             let mut stmts = vec![];\n             if !is_struct {\n@@ -136,7 +136,8 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                                    token::str_to_ident(\"finish\"),\n                                    vec![]);\n \n-    let block = cx.block(span, stmts, Some(expr));\n+    stmts.push(cx.stmt_expr(expr));\n+    let block = cx.block(span, stmts);\n     cx.expr_block(block)\n }\n "}, {"sha": "ad3786212475eaa76f23a82963fab1270827aa13", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -285,7 +285,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n                 blk\n             ));\n-            cx.expr_block(cx.block(trait_span, vec!(me), Some(ret)))\n+            cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\")"}, {"sha": "647e414a7fd2736cf6443e36ed8ce7be8b36458d", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -1332,8 +1332,8 @@ impl<'a> MethodDef<'a> {\n             //  }\n             let all_match = cx.expr_match(sp, match_arg, match_arms);\n             let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n-            cx.expr_block(\n-                cx.block_all(sp, index_let_stmts, Some(arm_expr)))\n+            index_let_stmts.push(cx.stmt_expr(arm_expr));\n+            cx.expr_block(cx.block(sp, index_let_stmts))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler"}, {"sha": "0fad96c84ef3d2a859569768a4115995ebfc54b0", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -99,5 +99,5 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         stmts.push(call_hash(span, self_.clone()));\n     }\n \n-    cx.expr_block(cx.block(trait_span, stmts, None))\n+    cx.expr_block(cx.block(trait_span, stmts))\n }"}, {"sha": "169e8073661976cf56c709ac1b1aa3bcb641d3a5", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -298,8 +298,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     let call = cx.expr_call_global(span, path, args);\n \n     cx.expr_block(P(ast::Block {\n-        stmts: vec![],\n-        expr: Some(call),\n+        stmts: vec![cx.stmt_expr(call)],\n         id: ast::DUMMY_NODE_ID,\n         rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n         span: span }))"}, {"sha": "f311f16f11b0efbebd7c59390f75102f537c171b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         };\n \n         // Wrap the declaration in a block so that it forms a single expression.\n-        ecx.expr_block(ecx.block(sp, vec![stmt], Some(ecx.expr_ident(sp, name))))\n+        ecx.expr_block(ecx.block(sp, vec![stmt, ecx.stmt_expr(ecx.expr_ident(sp, name))]))\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded"}, {"sha": "6bc0add2205175d48846f91ec0971971238b21ca", "filename": "src/test/compile-fail/issue-34418.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Ftest%2Fcompile-fail%2Fissue-34418.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bb3ea0febcbb8f6d7715256a5644daa985cf4e7/src%2Ftest%2Fcompile-fail%2Fissue-34418.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34418.rs?ref=9bb3ea0febcbb8f6d7715256a5644daa985cf4e7", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+macro_rules! make_item {\n+    () => { fn f() {} }\n+}\n+\n+macro_rules! make_stmt {\n+    () => { let x = 0; }\n+}\n+\n+fn f() {\n+    make_item! {}\n+}\n+\n+fn g() {\n+    make_stmt! {}\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}]}