{"sha": "b44f423dd4f6e9c8f462904c884308f44544c192", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NGY0MjNkZDRmNmU5YzhmNDYyOTA0Yzg4NDMwOGY0NDU0NGMxOTI=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-10T23:55:34Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-10T23:57:20Z"}, "message": "std::iterator: Rename .peek() to .inspect()", "tree": {"sha": "1641ee60517afa836007568f130eb4b4987ae523", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1641ee60517afa836007568f130eb4b4987ae523"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b44f423dd4f6e9c8f462904c884308f44544c192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b44f423dd4f6e9c8f462904c884308f44544c192", "html_url": "https://github.com/rust-lang/rust/commit/b44f423dd4f6e9c8f462904c884308f44544c192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b44f423dd4f6e9c8f462904c884308f44544c192/comments", "author": null, "committer": null, "parents": [{"sha": "8b9e1ce75a3e1416f2db80d30f65879fd902183f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b9e1ce75a3e1416f2db80d30f65879fd902183f", "html_url": "https://github.com/rust-lang/rust/commit/8b9e1ce75a3e1416f2db80d30f65879fd902183f"}], "stats": {"total": 39, "additions": 20, "deletions": 19}, "files": [{"sha": "03d8ae67998d9fedc64342d80e3f850fa44e38f1", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b44f423dd4f6e9c8f462904c884308f44544c192/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44f423dd4f6e9c8f462904c884308f44544c192/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=b44f423dd4f6e9c8f462904c884308f44544c192", "patch": "@@ -286,15 +286,15 @@ pub trait Iterator<A> {\n     ///let xs = [1u, 4, 2, 3, 8, 9, 6];\n     ///let sum = xs.iter()\n     ///            .map(|&x| x)\n-    ///            .peek(|&x| debug!(\"filtering %u\", x))\n+    ///            .inspect(|&x| debug!(\"filtering %u\", x))\n     ///            .filter(|&x| x % 2 == 0)\n-    ///            .peek(|&x| debug!(\"%u made it through\", x))\n+    ///            .inspect(|&x| debug!(\"%u made it through\", x))\n     ///            .sum();\n     ///println(sum.to_str());\n     /// ~~~\n     #[inline]\n-    fn peek<'r>(self, f: &'r fn(&A)) -> Peek<'r, A, Self> {\n-        Peek{iter: self, f: f}\n+    fn inspect<'r>(self, f: &'r fn(&A)) -> Inspect<'r, A, Self> {\n+        Inspect{iter: self, f: f}\n     }\n \n     /// An adaptation of an external iterator to the for-loop protocol of rust.\n@@ -1329,14 +1329,14 @@ impl<'self,\n \n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n-pub struct Peek<'self, A, T> {\n+pub struct Inspect<'self, A, T> {\n     priv iter: T,\n     priv f: &'self fn(&A)\n }\n \n-impl<'self, A, T> Peek<'self, A, T> {\n+impl<'self, A, T> Inspect<'self, A, T> {\n     #[inline]\n-    fn do_peek(&self, elt: Option<A>) -> Option<A> {\n+    fn do_inspect(&self, elt: Option<A>) -> Option<A> {\n         match elt {\n             Some(ref a) => (self.f)(a),\n             None => ()\n@@ -1346,11 +1346,11 @@ impl<'self, A, T> Peek<'self, A, T> {\n     }\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for Peek<'self, A, T> {\n+impl<'self, A, T: Iterator<A>> Iterator<A> for Inspect<'self, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let next = self.iter.next();\n-        self.do_peek(next)\n+        self.do_inspect(next)\n     }\n \n     #[inline]\n@@ -1359,23 +1359,25 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for Peek<'self, A, T> {\n     }\n }\n \n-impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Peek<'self, A, T> {\n+impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n+for Inspect<'self, A, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         let next = self.iter.next_back();\n-        self.do_peek(next)\n+        self.do_inspect(next)\n     }\n }\n \n-impl<'self, A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Peek<'self, A, T> {\n+impl<'self, A, T: RandomAccessIterator<A>> RandomAccessIterator<A>\n+for Inspect<'self, A, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n     }\n \n     #[inline]\n     fn idx(&self, index: uint) -> Option<A> {\n-        self.do_peek(self.iter.idx(index))\n+        self.do_inspect(self.iter.idx(index))\n     }\n }\n \n@@ -1651,13 +1653,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_peek() {\n+    fn test_inspect() {\n         let xs = [1u, 2, 3, 4];\n         let mut n = 0;\n \n         let ys = xs.iter()\n                    .map(|&x| x)\n-                   .peek(|_| n += 1)\n+                   .inspect(|_| n += 1)\n                    .collect::<~[uint]>();\n \n         assert_eq!(n, xs.len());\n@@ -2011,11 +2013,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_random_access_peek() {\n+    fn test_random_access_inspect() {\n         let xs = [1, 2, 3, 4, 5];\n \n-        // test .map and .peek that don't implement Clone\n-        let it = xs.iter().peek(|_| {});\n+        // test .map and .inspect that don't implement Clone\n+        let it = xs.iter().inspect(|_| {});\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(elt), it.idx(i));\n@@ -2027,7 +2029,6 @@ mod tests {\n     fn test_random_access_map() {\n         let xs = [1, 2, 3, 4, 5];\n \n-        // test .map and .peek that don't implement Clone\n         let it = xs.iter().map(|x| *x);\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {"}]}