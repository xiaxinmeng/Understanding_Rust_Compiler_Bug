{"sha": "cf3bb098881da40eed6ce7ad913a7e5d904663e2", "node_id": "C_kwDOAAsO6NoAKGNmM2JiMDk4ODgxZGE0MGVlZDZjZTdhZDkxM2E3ZTVkOTA0NjYzZTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-25T13:14:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-25T13:14:39Z"}, "message": "Rollup merge of #94343 - RalfJung:fn-ptr, r=oli-obk\n\nMiri fn ptr check: don't use conservative null check\n\nIn https://github.com/rust-lang/rust/pull/94270 I used the wrong NULL check for function pointers: `memory.ptr_may_be_null` is conservative even on machines that support ptr-to-int casts, leading to false errors in Miri.\n\nThis fixes that problem, and also replaces that foot-fun of a method with `scalar_may_be_null` which is never unnecessarily conservative.\n\nr? `@oli-obk`", "tree": {"sha": "06d83d088c197a7e7d5c90c965f3a0847e4273c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06d83d088c197a7e7d5c90c965f3a0847e4273c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf3bb098881da40eed6ce7ad913a7e5d904663e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiGNY/CRBK7hj4Ov3rIwAAZbMIAI+Tf0/R+VFQI57OS7AkqiFm\nZmGG/7vK0a18iCo5mLJcQqONbPb9deS5XrQhGmTaDzOo2VmeQZO+4MPVthYcOCAw\nOt7yel+NuGxJ7CrlFRLISV4xKd2EyBGcewLy+xenx7qXRegzOwAPkTbDIBG+rtv9\nIg7r6wKINdthi+xtnTutfK5JUXXxCevUMhONxoyjF0l8p/VG3NQYJn8Vm6MDdbk5\nUwIIqmOe5gcUG8Fon4w06cO5rynxTqyOz4BzqY1V3ggxAVkNAtMNUcXPMb6FP+lL\nIkZd9QGIYWps7wNKice8s3SrxpSwnw1fOykKZjzHUVOdpmNY1qUIHLG8ic9kQws=\n=limD\n-----END PGP SIGNATURE-----\n", "payload": "tree 06d83d088c197a7e7d5c90c965f3a0847e4273c7\nparent f9f97b661a0160aa99083ac5c5b98a47f0778292\nparent d8064d7d49073ff9962369a40678c934d700f7e0\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645794879 +0100\ncommitter GitHub <noreply@github.com> 1645794879 +0100\n\nRollup merge of #94343 - RalfJung:fn-ptr, r=oli-obk\n\nMiri fn ptr check: don't use conservative null check\n\nIn https://github.com/rust-lang/rust/pull/94270 I used the wrong NULL check for function pointers: `memory.ptr_may_be_null` is conservative even on machines that support ptr-to-int casts, leading to false errors in Miri.\n\nThis fixes that problem, and also replaces that foot-fun of a method with `scalar_may_be_null` which is never unnecessarily conservative.\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3bb098881da40eed6ce7ad913a7e5d904663e2", "html_url": "https://github.com/rust-lang/rust/commit/cf3bb098881da40eed6ce7ad913a7e5d904663e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf3bb098881da40eed6ce7ad913a7e5d904663e2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9f97b661a0160aa99083ac5c5b98a47f0778292", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f97b661a0160aa99083ac5c5b98a47f0778292", "html_url": "https://github.com/rust-lang/rust/commit/f9f97b661a0160aa99083ac5c5b98a47f0778292"}, {"sha": "d8064d7d49073ff9962369a40678c934d700f7e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8064d7d49073ff9962369a40678c934d700f7e0", "html_url": "https://github.com/rust-lang/rust/commit/d8064d7d49073ff9962369a40678c934d700f7e0"}], "stats": {"total": 75, "additions": 43, "deletions": 32}, "files": [{"sha": "99888992bc86aef53944c184b90edb73e82559c2", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=cf3bb098881da40eed6ce7ad913a7e5d904663e2", "patch": "@@ -217,8 +217,9 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n-            (Scalar::Int(int), Scalar::Ptr(ptr, _)) | (Scalar::Ptr(ptr, _), Scalar::Int(int)) => {\n-                int.is_null() && !self.memory.ptr_may_be_null(ptr.into())\n+            (Scalar::Int(int), ptr @ Scalar::Ptr(..))\n+            | (ptr @ Scalar::Ptr(..), Scalar::Int(int)) => {\n+                int.is_null() && !self.scalar_may_be_null(ptr)\n             }\n             // FIXME: return `true` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time."}, {"sha": "45ac3cd1f84a60315ebd5df0d3cd519631eb1a69", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=cf3bb098881da40eed6ce7ad913a7e5d904663e2", "patch": "@@ -22,9 +22,9 @@ use rustc_span::{Pos, Span};\n use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n-    AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemPlace,\n-    MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer, Provenance, Scalar,\n-    ScalarMaybeUninit, StackPopJump,\n+    AllocCheck, AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine,\n+    MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer, Provenance,\n+    Scalar, ScalarMaybeUninit, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n \n@@ -440,6 +440,29 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.memory.scalar_to_ptr(scalar)\n     }\n \n+    /// Test if this value might be null.\n+    /// If the machine does not support ptr-to-int casts, this is conservative.\n+    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> bool {\n+        match scalar.try_to_int() {\n+            Ok(int) => int.is_null(),\n+            Err(_) => {\n+                let ptr = self.scalar_to_ptr(scalar);\n+                match self.memory.ptr_try_get_alloc(ptr) {\n+                    Ok((alloc_id, offset, _)) => {\n+                        let (size, _align) = self\n+                            .memory\n+                            .get_size_and_align(alloc_id, AllocCheck::MaybeDead)\n+                            .expect(\"alloc info with MaybeDead cannot fail\");\n+                        // If the pointer is out-of-bounds, it may be null.\n+                        // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n+                        offset > size\n+                    }\n+                    Err(offset) => offset == 0,\n+                }\n+            }\n+        }\n+    }\n+\n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n     /// the machine pointer to the allocation.  Must never be used\n     /// for any other pointers, nor for TLS statics."}, {"sha": "04a6209990ccf72795e45716ae4f89f30db87675", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=cf3bb098881da40eed6ce7ad913a7e5d904663e2", "patch": "@@ -483,21 +483,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         })\n     }\n-\n-    /// Test if the pointer might be null.\n-    pub fn ptr_may_be_null(&self, ptr: Pointer<Option<M::PointerTag>>) -> bool {\n-        match self.ptr_try_get_alloc(ptr) {\n-            Ok((alloc_id, offset, _)) => {\n-                let (size, _align) = self\n-                    .get_size_and_align(alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\");\n-                // If the pointer is out-of-bounds, it may be null.\n-                // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n-                offset > size\n-            }\n-            Err(offset) => offset == 0,\n-        }\n-    }\n }\n \n /// Allocation accessors"}, {"sha": "9b317e8e0abfb3b4a100e6e69b122638ca901221", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=cf3bb098881da40eed6ce7ad913a7e5d904663e2", "patch": "@@ -720,12 +720,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Err(dbg_val) => {\n                         // So this is a pointer then, and casting to an int failed.\n                         // Can only happen during CTFE.\n-                        let ptr = self.scalar_to_ptr(tag_val);\n                         // The niche must be just 0, and the ptr not null, then we know this is\n                         // okay. Everything else, we conservatively reject.\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n-                            && !self.memory.ptr_may_be_null(ptr);\n+                            && !self.scalar_may_be_null(tag_val);\n                         if !ptr_valid {\n                             throw_ub!(InvalidTag(dbg_val))\n                         }"}, {"sha": "5cacab823866ad81dc7804e103ae69a625e2b183", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3bb098881da40eed6ce7ad913a7e5d904663e2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=cf3bb098881da40eed6ce7ad913a7e5d904663e2", "patch": "@@ -572,21 +572,25 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n                     err_ub!(InvalidUninitBytes(None)) => { \"uninitialized bytes\" } expected { \"a proper pointer or integer value\" },\n                 );\n-                let ptr = self.ecx.scalar_to_ptr(value);\n-                // Ensure the pointer is non-null.\n-                if self.ecx.memory.ptr_may_be_null(ptr) {\n-                    throw_validation_failure!(self.path, { \"a potentially null function pointer\" });\n-                }\n+\n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n+                    let ptr = self.ecx.scalar_to_ptr(value);\n                     let _fn = try_validation!(\n                         self.ecx.memory.get_fn(ptr),\n                         self.path,\n+                        err_ub!(DanglingIntPointer(0, _)) =>\n+                            { \"a null function pointer\" },\n                         err_ub!(DanglingIntPointer(..)) |\n                         err_ub!(InvalidFunctionPointer(..)) =>\n                             { \"{:x}\", value } expected { \"a function pointer\" },\n                     );\n                     // FIXME: Check if the signature matches\n+                } else {\n+                    // Otherwise (for standalone Miri), we have to still check it to be non-null.\n+                    if self.ecx.scalar_may_be_null(value) {\n+                        throw_validation_failure!(self.path, { \"a null function pointer\" });\n+                    }\n                 }\n                 Ok(true)\n             }\n@@ -644,10 +648,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             Err(_) => {\n                 // So this is a pointer then, and casting to an int failed.\n                 // Can only happen during CTFE.\n-                let ptr = self.ecx.scalar_to_ptr(value);\n                 if start == 1 && end == max_value {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n-                    if self.ecx.memory.ptr_may_be_null(ptr) {\n+                    if self.ecx.scalar_may_be_null(value) {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n                             expected {\n@@ -758,7 +761,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     fn visit_value(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n \n-        // Check primitive types -- the leafs of our recursive descend.\n+        // Check primitive types -- the leaves of our recursive descent.\n         if self.try_visit_primitive(op)? {\n             return Ok(());\n         }"}, {"sha": "f6f2432f2d71d8fa94a7bb6e11930f0c25d0420b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf3bb098881da40eed6ce7ad913a7e5d904663e2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf3bb098881da40eed6ce7ad913a7e5d904663e2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=cf3bb098881da40eed6ce7ad913a7e5d904663e2", "patch": "@@ -112,7 +112,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:49:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a potentially null function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a null function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "28bd040e2232c3f812ec966d822ef81efcd21b8b", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf3bb098881da40eed6ce7ad913a7e5d904663e2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf3bb098881da40eed6ce7ad913a7e5d904663e2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=cf3bb098881da40eed6ce7ad913a7e5d904663e2", "patch": "@@ -112,7 +112,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:49:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a potentially null function pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a null function pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}]}