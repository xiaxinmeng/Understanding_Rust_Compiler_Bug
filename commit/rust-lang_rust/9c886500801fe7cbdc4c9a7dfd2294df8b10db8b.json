{"sha": "9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljODg2NTAwODAxZmU3Y2JkYzRjOWE3ZGZkMjI5NGRmOGIxMGRiOGI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-10T10:29:36Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-17T08:08:06Z"}, "message": "Add feature `use_extern_macros`.", "tree": {"sha": "2d3d40551f32cb034dcbf023547206fdb1f451e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3d40551f32cb034dcbf023547206fdb1f451e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "html_url": "https://github.com/rust-lang/rust/commit/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b25c063caa5e4ab8202527e3cfcfe04196e0836f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b25c063caa5e4ab8202527e3cfcfe04196e0836f", "html_url": "https://github.com/rust-lang/rust/commit/b25c063caa5e4ab8202527e3cfcfe04196e0836f"}], "stats": {"total": 373, "additions": 238, "deletions": 135}, "files": [{"sha": "6816789cf284659a71a38c9f62ad121193767a43", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "patch": "@@ -504,9 +504,11 @@ impl<'b> Resolver<'b> {\n         })\n     }\n \n-    pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n-        let def_id = match def {\n-            Def::Macro(def_id) => def_id,\n+    pub fn get_macro(&mut self, binding: &'b NameBinding<'b>) -> Rc<SyntaxExtension> {\n+        let def_id = match binding.kind {\n+            NameBindingKind::Def(Def::Macro(def_id)) => def_id,\n+            NameBindingKind::Import { binding, .. } => return self.get_macro(binding),\n+            NameBindingKind::Ambiguity { b1, .. } => return self.get_macro(b1),\n             _ => panic!(\"Expected Def::Macro(..)\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n@@ -579,7 +581,7 @@ impl<'b> Resolver<'b> {\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n                 if let Success(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n@@ -589,7 +591,7 @@ impl<'b> Resolver<'b> {\n         }\n         for (name, span) in legacy_imports.reexports {\n             self.used_crates.insert(module.def_id().unwrap().krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n             if let Success(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {"}, {"sha": "a3a60e4f6d7548abe5d2f6787ba0bab13437a381", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "patch": "@@ -540,6 +540,7 @@ pub enum Namespace {\n pub struct PerNS<T> {\n     value_ns: T,\n     type_ns: T,\n+    macro_ns: Option<T>,\n }\n \n impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n@@ -548,7 +549,7 @@ impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n         match ns {\n             ValueNS => &self.value_ns,\n             TypeNS => &self.type_ns,\n-            MacroNS => unreachable!(),\n+            MacroNS => self.macro_ns.as_ref().unwrap(),\n         }\n     }\n }\n@@ -558,7 +559,7 @@ impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n         match ns {\n             ValueNS => &mut self.value_ns,\n             TypeNS => &mut self.type_ns,\n-            MacroNS => unreachable!(),\n+            MacroNS => self.macro_ns.as_mut().unwrap(),\n         }\n     }\n }\n@@ -675,22 +676,14 @@ impl<'a> Visitor for Resolver<'a> {\n \n pub type ErrorMessage = Option<(Span, String)>;\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum ResolveResult<T> {\n     Failed(ErrorMessage), // Failed to resolve the name, optional helpful error message.\n     Indeterminate, // Couldn't determine due to unresolved globs.\n     Success(T), // Successfully resolved the import.\n }\n \n impl<T> ResolveResult<T> {\n-    fn and_then<U, F: FnOnce(T) -> ResolveResult<U>>(self, f: F) -> ResolveResult<U> {\n-        match self {\n-            Failed(msg) => Failed(msg),\n-            Indeterminate => Indeterminate,\n-            Success(t) => f(t),\n-        }\n-    }\n-\n     fn success(self) -> Option<T> {\n         match self {\n             Success(t) => Some(t),\n@@ -825,6 +818,7 @@ pub struct ModuleS<'a> {\n     normal_ancestor_id: Option<NodeId>,\n \n     resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Name, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<Mark>>,\n@@ -852,6 +846,7 @@ impl<'a> ModuleS<'a> {\n             kind: kind,\n             normal_ancestor_id: None,\n             resolutions: RefCell::new(FxHashMap()),\n+            legacy_macro_resolutions: RefCell::new(Vec::new()),\n             unresolved_invocations: RefCell::new(FxHashSet()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n@@ -943,6 +938,7 @@ struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n struct AmbiguityError<'a> {\n     span: Span,\n     name: Name,\n+    lexical: bool,\n     b1: &'a NameBinding<'a>,\n     b2: &'a NameBinding<'a>,\n }\n@@ -1001,7 +997,7 @@ impl<'a> NameBinding<'a> {\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { directive, .. } => directive.is_glob(),\n-            NameBindingKind::Ambiguity { .. } => true,\n+            NameBindingKind::Ambiguity { b1, .. } => b1.is_glob_import(),\n             _ => false,\n         }\n     }\n@@ -1136,6 +1132,7 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n+    use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n@@ -1300,6 +1297,7 @@ impl<'a> Resolver<'a> {\n             ribs: PerNS {\n                 value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n                 type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                macro_ns: None,\n             },\n             label_ribs: Vec::new(),\n \n@@ -1336,6 +1334,7 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n             new_import_semantics: session.features.borrow().item_like_imports,\n+            use_extern_macros: session.features.borrow().use_extern_macros,\n \n             exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n@@ -1365,6 +1364,10 @@ impl<'a> Resolver<'a> {\n         PerNS {\n             type_ns: f(self, TypeNS),\n             value_ns: f(self, ValueNS),\n+            macro_ns: match self.use_extern_macros {\n+                true => Some(f(self, MacroNS)),\n+                false => None,\n+            },\n         }\n     }\n \n@@ -1403,8 +1406,9 @@ impl<'a> Resolver<'a> {\n             }\n             NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { b1, b2 } => {\n-                let ambiguity_error = AmbiguityError { span: span, name: name, b1: b1, b2: b2 };\n-                self.ambiguity_errors.push(ambiguity_error);\n+                self.ambiguity_errors.push(AmbiguityError {\n+                    span: span, name: name, lexical: false, b1: b1, b2: b2,\n+                });\n                 true\n             }\n             _ => false\n@@ -1438,7 +1442,7 @@ impl<'a> Resolver<'a> {\n                                      -> ResolveResult<Module<'a>> {\n         fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n                                        -> Option<Module<'a>> {\n-            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n+            match this.resolve_name_in_module(module, needle, TypeNS, false, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n                     search_parent_externals(this, needle, parent)\n@@ -1456,7 +1460,7 @@ impl<'a> Resolver<'a> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index].name;\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, false, span) {\n                 Failed(_) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n@@ -1613,7 +1617,7 @@ impl<'a> Resolver<'a> {\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n                 let name = ident.name;\n-                let item = self.resolve_name_in_module(module, name, ns, true, record_used);\n+                let item = self.resolve_name_in_module(module, name, ns, true, false, record_used);\n                 if let Success(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1622,7 +1626,7 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n+                        self.resolve_name_in_module(prelude, name, ns, false, false, None).success()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -1717,6 +1721,7 @@ impl<'a> Resolver<'a> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n+            self.finalize_current_module_macro_resolutions();\n             f(self);\n \n             self.current_module = orig_module;\n@@ -2221,6 +2226,7 @@ impl<'a> Resolver<'a> {\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.current_module = anonymous_module;\n+            self.finalize_current_module_macro_resolutions();\n         } else {\n             self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n@@ -2754,23 +2760,19 @@ impl<'a> Resolver<'a> {\n         let module_path =\n             segments.split_last().unwrap().1.iter().map(|ps| ps.identifier).collect::<Vec<_>>();\n \n-        let containing_module;\n-        match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n+        let module = match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n             Failed(err) => {\n                 if let Some((span, msg)) = err {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 return Err(true);\n             }\n             Indeterminate => return Err(false),\n-            Success(resulting_module) => {\n-                containing_module = resulting_module;\n-            }\n-        }\n+            Success(module) => module,\n+        };\n \n         let name = segments.last().unwrap().identifier.name;\n-        let result =\n-            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -2782,10 +2784,9 @@ impl<'a> Resolver<'a> {\n         where T: Named,\n     {\n         let module_path = segments.split_last().unwrap().1.iter().map(T::ident).collect::<Vec<_>>();\n-        let root_module = self.graph_root;\n+        let root = self.graph_root;\n \n-        let containing_module;\n-        match self.resolve_module_path_from_root(root_module, &module_path, 0, Some(span)) {\n+        let module = match self.resolve_module_path_from_root(root, &module_path, 0, Some(span)) {\n             Failed(err) => {\n                 if let Some((span, msg)) = err {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -2795,14 +2796,11 @@ impl<'a> Resolver<'a> {\n \n             Indeterminate => return Err(false),\n \n-            Success(resulting_module) => {\n-                containing_module = resulting_module;\n-            }\n-        }\n+            Success(module) => module,\n+        };\n \n         let name = segments.last().unwrap().ident().name;\n-        let result =\n-            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -3383,14 +3381,18 @@ impl<'a> Resolver<'a> {\n         self.report_shadowing_errors();\n         let mut reported_spans = FxHashSet();\n \n-        for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n+        for &AmbiguityError { span, name, b1, b2, lexical } in &self.ambiguity_errors {\n             if !reported_spans.insert(span) { continue }\n             let msg1 = format!(\"`{}` could resolve to the name imported here\", name);\n             let msg2 = format!(\"`{}` could also resolve to the name imported here\", name);\n             self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n                 .span_note(b1.span, &msg1)\n                 .span_note(b2.span, &msg2)\n-                .note(&format!(\"Consider adding an explicit import of `{}` to disambiguate\", name))\n+                .note(&if lexical || !b1.is_glob_import() {\n+                    \"macro-expanded macro imports do not shadow\".to_owned()\n+                } else {\n+                    format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n+                })\n                 .emit();\n         }\n \n@@ -3413,12 +3415,12 @@ impl<'a> Resolver<'a> {\n \n     fn report_shadowing_errors(&mut self) {\n         for (name, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n-            self.resolve_macro_name(scope, name);\n+            self.resolve_legacy_scope(scope, name, true);\n         }\n \n         let mut reported_errors = FxHashSet();\n         for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n-            if self.resolve_macro_name(binding.parent, binding.name).is_some() &&\n+            if self.resolve_legacy_scope(binding.parent, binding.name, false).is_some() &&\n                reported_errors.insert((binding.name, binding.span)) {\n                 let msg = format!(\"`{}` is already in scope\", binding.name);\n                 self.session.struct_span_err(binding.span, &msg)"}, {"sha": "56d76272e235a0ecbd1fb62de59a0b599d69f929", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 122, "deletions": 28, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {Module, ModuleKind, NameBinding, NameBindingKind, Resolver};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, Resolver, AmbiguityError};\n+use Namespace::{self, MacroNS};\n+use ResolveResult::{Success, Indeterminate, Failed};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n@@ -17,7 +19,7 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n-use syntax::ast;\n+use syntax::ast::{self, Name};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n@@ -85,6 +87,11 @@ pub struct LegacyBinding<'a> {\n     pub span: Span,\n }\n \n+pub enum MacroBinding<'a> {\n+    Legacy(&'a LegacyBinding<'a>),\n+    Modern(&'a NameBinding<'a>),\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -140,6 +147,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             expansion: mark,\n         };\n         expansion.visit_with(&mut visitor);\n+        self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n@@ -201,7 +209,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n             match self.builtin_macros.get(&name).cloned() {\n-                Some(binding) => match *self.get_macro(binding.def()) {\n+                Some(binding) => match *self.get_macro(binding) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -225,25 +233,77 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n             invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n         }\n-        self.resolve_macro_name(invocation.legacy_scope.get(), name).ok_or_else(|| {\n-            if force {\n-                let msg = format!(\"macro undefined: '{}!'\", name);\n-                let mut err = self.session.struct_span_err(path.span, &msg);\n-                self.suggest_macro_name(&name.as_str(), &mut err);\n-                err.emit();\n-                Determinacy::Determined\n-            } else {\n-                Determinacy::Undetermined\n-            }\n-        })\n+\n+        self.current_module = invocation.module.get();\n+        let result = match self.resolve_legacy_scope(invocation.legacy_scope.get(), name, false) {\n+            Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n+            Some(MacroBinding::Modern(binding)) => Ok(self.get_macro(binding)),\n+            None => match self.resolve_in_item_lexical_scope(name, MacroNS, None) {\n+                Some(binding) => Ok(self.get_macro(binding)),\n+                None => return Err(if force {\n+                    let msg = format!(\"macro undefined: '{}!'\", name);\n+                    let mut err = self.session.struct_span_err(path.span, &msg);\n+                    self.suggest_macro_name(&name.as_str(), &mut err);\n+                    err.emit();\n+                    Determinacy::Determined\n+                } else {\n+                    Determinacy::Undetermined\n+                }),\n+            },\n+        };\n+\n+        if self.use_extern_macros {\n+            self.current_module.legacy_macro_resolutions.borrow_mut()\n+                .push((scope, name, path.span));\n+        }\n+        result\n     }\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn resolve_macro_name(&mut self, mut scope: LegacyScope<'a>, name: ast::Name)\n-                              -> Option<Rc<SyntaxExtension>> {\n+    // Resolve the name in the module's lexical scope, excluding non-items.\n+    fn resolve_in_item_lexical_scope(\n+        &mut self, name: Name, ns: Namespace, record_used: Option<Span>,\n+    ) -> Option<&'a NameBinding<'a>> {\n+        let mut module = self.current_module;\n+        let mut potential_expanded_shadower = None;\n+        loop {\n+            // Since expanded macros may not shadow the lexical scope (enforced below),\n+            // we can ignore unresolved invocations (indicated by the penultimate argument).\n+            match self.resolve_name_in_module(module, name, ns, true, true, record_used) {\n+                Success(binding) => {\n+                    let span = match record_used {\n+                        Some(span) => span,\n+                        None => return Some(binding),\n+                    };\n+                    if let Some(shadower) = potential_expanded_shadower {\n+                        self.ambiguity_errors.push(AmbiguityError {\n+                            span: span, name: name, b1: shadower, b2: binding, lexical: true,\n+                        });\n+                        return Some(shadower);\n+                    } else if binding.expansion == Mark::root() {\n+                        return Some(binding);\n+                    } else {\n+                        potential_expanded_shadower = Some(binding);\n+                    }\n+                },\n+                Indeterminate => return None,\n+                Failed(..) => {}\n+            }\n+\n+            match module.kind {\n+                ModuleKind::Block(..) => module = module.parent.unwrap(),\n+                ModuleKind::Def(..) => return potential_expanded_shadower,\n+            }\n+        }\n+    }\n+\n+    pub fn resolve_legacy_scope(\n+        &mut self, mut scope: LegacyScope<'a>, name: ast::Name, record_used: bool,\n+    ) -> Option<MacroBinding<'a>> {\n         let mut possible_time_travel = None;\n         let mut relative_depth: u32 = 0;\n+        let mut binding = None;\n         loop {\n             scope = match scope {\n                 LegacyScope::Empty => break,\n@@ -262,25 +322,59 @@ impl<'a> Resolver<'a> {\n                     relative_depth = relative_depth.saturating_sub(1);\n                     invocation.legacy_scope.get()\n                 }\n-                LegacyScope::Binding(binding) => {\n-                    if binding.name == name {\n-                        if let Some(scope) = possible_time_travel {\n-                            // Check for disallowed shadowing later\n-                            self.lexical_macro_resolutions.push((name, scope));\n-                        } else if relative_depth > 0 {\n-                            self.disallowed_shadowing.push(binding);\n+                LegacyScope::Binding(potential_binding) => {\n+                    if potential_binding.name == name {\n+                        if (!self.use_extern_macros || record_used) && relative_depth > 0 {\n+                            self.disallowed_shadowing.push(potential_binding);\n                         }\n-                        return Some(binding.ext.clone());\n+                        binding = Some(potential_binding);\n+                        break\n                     }\n-                    binding.parent\n+                    potential_binding.parent\n                 }\n             };\n         }\n \n-        if let Some(scope) = possible_time_travel {\n-            self.lexical_macro_resolutions.push((name, scope));\n+        let binding = match binding {\n+            Some(binding) => MacroBinding::Legacy(binding),\n+            None => match self.builtin_macros.get(&name).cloned() {\n+                Some(binding) => MacroBinding::Modern(binding),\n+                None => return None,\n+            },\n+        };\n+\n+        if !self.use_extern_macros {\n+            if let Some(scope) = possible_time_travel {\n+                // Check for disallowed shadowing later\n+                self.lexical_macro_resolutions.push((name, scope));\n+            }\n+        }\n+\n+        Some(binding)\n+    }\n+\n+    pub fn finalize_current_module_macro_resolutions(&mut self) {\n+        let module = self.current_module;\n+        for &(mark, name, span) in module.legacy_macro_resolutions.borrow().iter() {\n+            let legacy_scope = self.invocations[&mark].legacy_scope.get();\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, name, true);\n+            let resolution = self.resolve_in_item_lexical_scope(name, MacroNS, Some(span));\n+            let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n+                (Some(legacy_resolution), Some(resolution)) => (legacy_resolution, resolution),\n+                _ => continue,\n+            };\n+            let (legacy_span, participle) = match legacy_resolution {\n+                MacroBinding::Modern(binding) if binding.def() == resolution.def() => continue,\n+                MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n+                MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n+            };\n+            let msg1 = format!(\"`{}` could resolve to the macro {} here\", name, participle);\n+            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", name);\n+            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n+                .span_note(legacy_span, &msg1)\n+                .span_note(resolution.span, &msg2)\n+                .emit();\n         }\n-        self.builtin_macros.get(&name).cloned().map(|binding| self.get_macro(binding.def()))\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {"}, {"sha": "d0ce1acaadf62128434b5b2f2469f981eec80977", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "patch": "@@ -11,7 +11,7 @@\n use self::ImportDirectiveSubclass::*;\n \n use {Module, PerNS};\n-use Namespace::{self, TypeNS};\n+use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, PrivacyError, ToNameBinding};\n use ResolveResult;\n use ResolveResult::*;\n@@ -142,6 +142,7 @@ impl<'a> Resolver<'a> {\n                                   name: Name,\n                                   ns: Namespace,\n                                   allow_private_imports: bool,\n+                                  ignore_unresolved_invocations: bool,\n                                   record_used: Option<Span>)\n                                   -> ResolveResult<&'a NameBinding<'a>> {\n         self.populate_module_if_necessary(module);\n@@ -175,70 +176,65 @@ impl<'a> Resolver<'a> {\n             return resolution.binding.map(Success).unwrap_or(Failed(None));\n         }\n \n-        // If the resolution doesn't depend on glob definability, check privacy and return.\n-        if let Some(result) = self.try_result(&resolution, module, ns) {\n-            return result.and_then(|binding| {\n-                if self.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n-                   binding.is_extern_crate() { // c.f. issue #37020\n-                    Success(binding)\n-                } else {\n-                    Failed(None)\n-                }\n-            });\n-        }\n+        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n+            let usable =\n+                this.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n+                binding.is_extern_crate(); // c.f. issue #37020\n+            if usable { Success(binding) } else { Failed(None) }\n+        };\n \n-        // Check if the globs are determined\n-        for directive in module.globs.borrow().iter() {\n-            if self.is_accessible(directive.vis.get()) {\n-                if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, true, None);\n-                    if let Indeterminate = result {\n-                        return Indeterminate;\n-                    }\n-                } else {\n-                    return Indeterminate;\n-                }\n+        // Items and single imports are not shadowable.\n+        if let Some(binding) = resolution.binding {\n+            if !binding.is_glob_import() {\n+                return check_usable(self, binding);\n             }\n         }\n \n-        Failed(None)\n-    }\n-\n-    // Returns Some(the resolution of the name), or None if the resolution depends\n-    // on whether more globs can define the name.\n-    fn try_result(&mut self, resolution: &NameResolution<'a>, module: Module<'a>, ns: Namespace)\n-                  -> Option<ResolveResult<&'a NameBinding<'a>>> {\n-        match resolution.binding {\n-            Some(binding) if !binding.is_glob_import() =>\n-                return Some(Success(binding)), // Items and single imports are not shadowable.\n-            _ => {}\n-        };\n-\n         // Check if a single import can still define the name.\n         match resolution.single_imports {\n-            SingleImports::AtLeastOne => return Some(Indeterminate),\n+            SingleImports::AtLeastOne => return Indeterminate,\n             SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n                 let module = match directive.imported_module.get() {\n                     Some(module) => module,\n-                    None => return Some(Indeterminate),\n+                    None => return Indeterminate,\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, true, None) {\n+                match self.resolve_name_in_module(module, name, ns, true, false, None) {\n                     Failed(_) => {}\n-                    _ => return Some(Indeterminate),\n+                    _ => return Indeterminate,\n                 }\n             }\n             SingleImports::MaybeOne(_) | SingleImports::None => {},\n         }\n \n-        if !module.unresolved_invocations.borrow().is_empty() {\n-            return Some(Indeterminate);\n+        let no_unresolved_invocations =\n+            ignore_unresolved_invocations || module.unresolved_invocations.borrow().is_empty();\n+        match resolution.binding {\n+            // In `MacroNS`, expanded bindings do not shadow (enforced in `try_define`).\n+            Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n+                return check_usable(self, binding),\n+            None if no_unresolved_invocations => {}\n+            _ => return Indeterminate,\n         }\n \n-        resolution.binding.map(Success)\n+        // Check if the globs are determined\n+        for directive in module.globs.borrow().iter() {\n+            if self.is_accessible(directive.vis.get()) {\n+                if let Some(module) = directive.imported_module.get() {\n+                    let result = self.resolve_name_in_module(module, name, ns, true, false, None);\n+                    if let Indeterminate = result {\n+                        return Indeterminate;\n+                    }\n+                } else {\n+                    return Indeterminate;\n+                }\n+            }\n+        }\n+\n+        Failed(None)\n     }\n \n     // Add an import directive to the current module.\n@@ -315,29 +311,26 @@ impl<'a> Resolver<'a> {\n         self.update_resolution(module, name, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n-                    if !this.new_import_semantics || !old_binding.is_glob_import() {\n+                    if !this.new_import_semantics {\n                         resolution.duplicate_globs.push(binding);\n+                    } else if !old_binding.is_glob_import() &&\n+                              !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n                     } else if binding.def() != old_binding.def() {\n-                        resolution.binding = Some(this.arenas.alloc_name_binding(NameBinding {\n-                            kind: NameBindingKind::Ambiguity {\n-                                b1: old_binding,\n-                                b2: binding,\n-                            },\n-                            vis: if old_binding.vis.is_at_least(binding.vis, this) {\n-                                old_binding.vis\n-                            } else {\n-                                binding.vis\n-                            },\n-                            span: old_binding.span,\n-                            expansion: Mark::root(),\n-                        }));\n+                        resolution.binding = Some(this.ambiguity(old_binding, binding));\n                     } else if !old_binding.vis.is_at_least(binding.vis, this) {\n                         // We are glob-importing the same item but with greater visibility.\n                         resolution.binding = Some(binding);\n                     }\n                 } else if old_binding.is_glob_import() {\n-                    resolution.duplicate_globs.push(old_binding);\n-                    resolution.binding = Some(binding);\n+                    if !this.new_import_semantics {\n+                        resolution.duplicate_globs.push(old_binding);\n+                        resolution.binding = Some(binding);\n+                    } else if ns == MacroNS && binding.expansion != Mark::root() &&\n+                              binding.def() != old_binding.def() {\n+                        resolution.binding = Some(this.ambiguity(binding, old_binding));\n+                    } else {\n+                        resolution.binding = Some(binding);\n+                    }\n                 } else {\n                     return Err(old_binding);\n                 }\n@@ -349,6 +342,16 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n+    pub fn ambiguity(&mut self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n+                 -> &'a NameBinding<'a> {\n+        self.arenas.alloc_name_binding(NameBinding {\n+            kind: NameBindingKind::Ambiguity { b1: b1, b2: b2 },\n+            vis: if b1.vis.is_at_least(b2.vis, self) { b1.vis } else { b2.vis },\n+            span: b1.span,\n+            expansion: Mark::root(),\n+        })\n+    }\n+\n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n@@ -525,7 +528,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n                 result[ns].set({\n-                    match this.resolve_name_in_module(module, source, ns, false, None) {\n+                    match this.resolve_name_in_module(module, source, ns, false, false, None) {\n                         Success(binding) => Ok(binding),\n                         Indeterminate => Err(Undetermined),\n                         Failed(_) => Err(Determined),\n@@ -621,7 +624,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n-                match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n+                match this.resolve_name_in_module(module, name, ns, false, false, Some(span)) {\n                     Success(_) => all_ns_failed = false,\n                     _ => {}\n                 }"}, {"sha": "ea66fdc31cf08e7ce59d07a288cb2fb0869799d9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "patch": "@@ -314,6 +314,8 @@ declare_features! (\n \n     // Allows #[link(..., cfg(..))]\n     (active, link_cfg, \"1.14.0\", Some(37406)),\n+\n+    (active, use_extern_macros, \"1.15.0\", Some(35896)),\n );\n \n declare_features! ("}, {"sha": "faf85a523e8fb01fdf33c6b00e45b3ff20fd1037", "filename": "src/test/compile-fail/imports/duplicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c886500801fe7cbdc4c9a7dfd2294df8b10db8b/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs?ref=9c886500801fe7cbdc4c9a7dfd2294df8b10db8b", "patch": "@@ -46,9 +46,9 @@ mod g {\n fn main() {\n     e::foo();\n     f::foo(); //~ ERROR `foo` is ambiguous\n-              //~| NOTE Consider adding an explicit import of `foo` to disambiguate\n+              //~| NOTE consider adding an explicit import of `foo` to disambiguate\n     g::foo(); //~ ERROR `foo` is ambiguous\n-              //~| NOTE Consider adding an explicit import of `foo` to disambiguate\n+              //~| NOTE consider adding an explicit import of `foo` to disambiguate\n }\n \n mod ambiguous_module_errors {"}]}