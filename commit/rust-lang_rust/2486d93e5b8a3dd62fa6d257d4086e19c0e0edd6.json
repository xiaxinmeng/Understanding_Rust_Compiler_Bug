{"sha": "2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ODZkOTNlNWI4YTNkZDYyZmE2ZDI1N2Q0MDg2ZTE5YzBlMGVkZDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-06T10:03:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-06T18:42:42Z"}, "message": "Fix ICE that @steveklabnik encountered in rust-ice. The problems turned out to be that were being very loose with bound regions in trans (we were basically just ignoring and flattening binders). Since binders are significant to subtyping and hence to trait selection, this can cause a lot of problems. So this patch makes us treat them more strictly -- for example, we propagate binders, and avoid skipping past the `Binder` by writing `foo.0`.\n\nFixes #20644.", "tree": {"sha": "51b1e0c875588aff6c1c61d2868bd887bace9937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51b1e0c875588aff6c1c61d2868bd887bace9937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "html_url": "https://github.com/rust-lang/rust/commit/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8efd9901b628d687d11a4d0ccc153553b38ada49", "url": "https://api.github.com/repos/rust-lang/rust/commits/8efd9901b628d687d11a4d0ccc153553b38ada49", "html_url": "https://github.com/rust-lang/rust/commit/8efd9901b628d687d11a4d0ccc153553b38ada49"}], "stats": {"total": 582, "additions": 399, "deletions": 183}, "files": [{"sha": "dedd32119159558762ea8ed6f1c9187f1894df05", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if return_ty == ty::FnDiverging {\n+        if return_ty.diverges() {\n             self.add_node(ast::DUMMY_NODE_ID, &[])\n         } else {\n             ret"}, {"sha": "4d6e494cc82eaf1a9f33bc555fe73671f322eb1e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -864,7 +864,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 None => {}\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n-                    let self_ty = ty::ty_fn_args(method_ty)[0];\n+\n+                    // the method call infrastructure should have\n+                    // replaced all late-bound regions with variables:\n+                    let self_ty = ty::ty_fn_sig(method_ty).input(0);\n+                    let self_ty = ty::assert_no_late_bound_regions(self.tcx(), &self_ty);\n+\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,"}, {"sha": "fe067ba8b00a1cc1212e147fadedcd67f894bdf6", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -112,6 +112,7 @@ use self::VarKind::*;\n use middle::def::*;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n+use middle::region::CodeExtent;\n use middle::ty;\n use middle::ty::UnboxedClosureTyper;\n use lint;\n@@ -1149,8 +1150,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n-                let t_ret = ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f));\n-                t_ret == ty::FnDiverging\n+                ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f)).diverges()\n             };\n             let succ = if diverges {\n                 self.s.exit_ln\n@@ -1164,7 +1164,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n-            let diverges = ty::ty_fn_ret(method_ty) == ty::FnDiverging;\n+            let diverges = ty::ty_fn_ret(method_ty).diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1514,11 +1514,11 @@ fn check_fn(_v: &Liveness,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::FnOutput<'tcx> {\n+    fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n             ty::ty_unboxed_closure(closure_def_id, _, substs) =>\n-                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.0.output,\n+                self.ir.tcx.unboxed_closure_type(closure_def_id, substs).sig.output(),\n             _ =>\n                 ty::ty_fn_ret(fn_ty),\n         }\n@@ -1529,8 +1529,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                  sp: Span,\n                  _fk: FnKind,\n                  entry_ln: LiveNode,\n-                 body: &ast::Block) {\n-        match self.fn_ret(id) {\n+                 body: &ast::Block)\n+    {\n+        // within the fn body, late-bound regions are liberated:\n+        let fn_ret =\n+            ty::liberate_late_bound_regions(\n+                self.ir.tcx,\n+                CodeExtent::from_node_id(body.id),\n+                &self.fn_ret(id));\n+\n+        match fn_ret {\n             ty::FnConverging(t_ret)\n                 if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n "}, {"sha": "91c2681ef613a3ea692de9cc17535ea8ab0f7e73", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -492,9 +492,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     let method_call = ty::MethodCall::expr(expr.id());\n                     match self.typer.node_method_ty(method_call) {\n                         Some(method_ty) => {\n-                            // If this is an index implemented by a method call, then it will\n-                            // include an implicit deref of the result.\n-                            let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                            // If this is an index implemented by a\n+                            // method call, then it will include an\n+                            // implicit deref of the result.\n+                            let ret_ty = self.overloaded_method_return_ty(method_ty);\n                             self.cat_deref(expr,\n                                            self.cat_rvalue_node(expr.id(),\n                                                                 expr.span(),\n@@ -865,7 +866,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         let base_cmt = match method_ty {\n             Some(method_ty) => {\n-                let ref_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                let ref_ty =\n+                    ty::assert_no_late_bound_regions(\n+                        self.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n@@ -945,9 +948,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         let element_ty = match method_ty {\n             Some(method_ty) => {\n-                let ref_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                let ref_ty = self.overloaded_method_return_ty(method_ty);\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n-                ty::ty_fn_args(method_ty)[0]\n+\n+                // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n+                let self_ty = ty::ty_fn_sig(method_ty).input(0);\n+                ty::assert_no_late_bound_regions(self.tcx(), &self_ty)\n             }\n             None => {\n                 match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n@@ -1269,6 +1275,19 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n         Ok(())\n     }\n+\n+    fn overloaded_method_return_ty(&self,\n+                                   method_ty: Ty<'tcx>)\n+                                   -> Ty<'tcx>\n+    {\n+        // When we process an overloaded `*` or `[]` etc, we often\n+        // need to extract the return type of the method. These method\n+        // types are generated by method resolution and always have\n+        // all late-bound regions fully instantiated, so we just want\n+        // to skip past the binder.\n+        ty::assert_no_late_bound_regions(self.tcx(), &ty::ty_fn_ret(method_ty))\n+            .unwrap() // overloaded ops do not diverge, either\n+    }\n }\n \n #[derive(Copy)]"}, {"sha": "192f86bfa624a0bfec24a05ea38ab8f8ce750047", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -1054,6 +1054,10 @@ pub enum FnOutput<'tcx> {\n }\n \n impl<'tcx> FnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        *self == FnDiverging\n+    }\n+\n     pub fn unwrap(self) -> Ty<'tcx> {\n         match self {\n             ty::FnConverging(t) => t,\n@@ -1062,6 +1066,14 @@ impl<'tcx> FnOutput<'tcx> {\n     }\n }\n \n+pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;\n+\n+impl<'tcx> PolyFnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        self.0.diverges()\n+    }\n+}\n+\n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n@@ -1077,6 +1089,21 @@ pub struct FnSig<'tcx> {\n \n pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n+impl<'tcx> PolyFnSig<'tcx> {\n+    pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        ty::Binder(self.0.inputs.clone())\n+    }\n+    pub fn input(&self, index: uint) -> ty::Binder<Ty<'tcx>> {\n+        ty::Binder(self.0.inputs[index])\n+    }\n+    pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n+        ty::Binder(self.0.output.clone())\n+    }\n+    pub fn variadic(&self) -> bool {\n+        self.0.variadic\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n@@ -4145,8 +4172,8 @@ pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n }\n \n // Type accessors for substructures of types\n-pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> &'tcx [Ty<'tcx>] {\n-    ty_fn_sig(fty).0.inputs.as_slice()\n+pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> ty::Binder<Vec<Ty<'tcx>>> {\n+    ty_fn_sig(fty).inputs()\n }\n \n pub fn ty_closure_store(fty: Ty) -> TraitStore {\n@@ -4162,9 +4189,9 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n     }\n }\n \n-pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n+pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n     match fty.sty {\n-        ty_bare_fn(_, ref f) => f.sig.0.output,\n+        ty_bare_fn(_, ref f) => f.sig.output(),\n         ref s => {\n             panic!(\"ty_fn_ret() called on non-fn type: {}\", s)\n         }\n@@ -4319,9 +4346,12 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             let method_call = MethodCall::autoderef(expr_id, i);\n                             match method_type(method_call) {\n                                 Some(method_ty) => {\n-                                    if let ty::FnConverging(result_type) = ty_fn_ret(method_ty) {\n-                                        adjusted_ty = result_type;\n-                                    }\n+                                    // overloaded deref operators have all late-bound\n+                                    // regions fully instantiated and coverge\n+                                    let fn_ret =\n+                                        ty::assert_no_late_bound_regions(cx,\n+                                                                         &ty_fn_ret(method_ty));\n+                                    adjusted_ty = fn_ret.unwrap();\n                                 }\n                                 None => {}\n                             }\n@@ -5143,7 +5173,9 @@ impl<'tcx> VariantInfo<'tcx> {\n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n                 let arg_tys = if args.len() > 0 {\n-                    ty_fn_args(ctor_ty).iter().map(|a| *a).collect()\n+                    // the regions in the argument types come from the\n+                    // enum def'n, and hence will all be early bound\n+                    ty::assert_no_late_bound_regions(cx, &ty_fn_args(ctor_ty))\n                 } else {\n                     Vec::new()\n                 };\n@@ -5159,7 +5191,6 @@ impl<'tcx> VariantInfo<'tcx> {\n                 };\n             },\n             ast::StructVariantKind(ref struct_def) => {\n-\n                 let fields: &[StructField] = struct_def.fields[];\n \n                 assert!(fields.len() > 0);\n@@ -5791,40 +5822,6 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n     return tbl[tycat(cx, ty) as uint ][opcat(op) as uint];\n }\n \n-/// Returns an equivalent type with all the typedefs and self regions removed.\n-pub fn normalize_ty<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let u = TypeNormalizer(cx).fold_ty(ty);\n-    return u;\n-\n-    struct TypeNormalizer<'a, 'tcx: 'a>(&'a ctxt<'tcx>);\n-\n-    impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n-        fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n-\n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n-                None => {}\n-                Some(u) => return u\n-            }\n-\n-            let t_norm = ty_fold::super_fold_ty(self, ty);\n-            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n-            return t_norm;\n-        }\n-\n-        fn fold_region(&mut self, _: ty::Region) -> ty::Region {\n-            ty::ReStatic\n-        }\n-\n-        fn fold_substs(&mut self,\n-                       substs: &subst::Substs<'tcx>)\n-                       -> subst::Substs<'tcx> {\n-            subst::Substs { regions: subst::ErasedRegions,\n-                            types: substs.types.fold_with(self) }\n-        }\n-    }\n-}\n-\n // Returns the repeat count for a repeating vector expression.\n pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n@@ -6204,7 +6201,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n             mt.mutbl.hash(state);\n         };\n         let fn_sig = |&: state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n-            let sig = anonymize_late_bound_regions(tcx, sig);\n+            let sig = anonymize_late_bound_regions(tcx, sig).0;\n             for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {\n                 helper(tcx, output, svh, state);\n@@ -6265,7 +6262,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     did(state, data.principal_def_id());\n                     hash!(data.bounds);\n \n-                    let principal = anonymize_late_bound_regions(tcx, &data.principal);\n+                    let principal = anonymize_late_bound_regions(tcx, &data.principal).0;\n                     for subty in principal.substs.types.iter() {\n                         helper(tcx, *subty, svh, state);\n                     }\n@@ -6696,6 +6693,16 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     count_late_bound_regions(tcx, value) > 0\n }\n \n+pub fn assert_no_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    value: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + Clone\n+{\n+    assert!(!binds_late_bound_regions(tcx, value));\n+    value.0.clone()\n+}\n+\n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n /// method lookup and a few other places where precise region relationships are not required.\n pub fn erase_late_bound_regions<'tcx, T>(\n@@ -6718,14 +6725,14 @@ pub fn erase_late_bound_regions<'tcx, T>(\n pub fn anonymize_late_bound_regions<'tcx, T>(\n     tcx: &ctxt<'tcx>,\n     sig: &Binder<T>)\n-    -> T\n+    -> Binder<T>\n     where T : TypeFoldable<'tcx> + Repr<'tcx>,\n {\n     let mut counter = 0;\n-    replace_late_bound_regions(tcx, sig, |_, db| {\n+    ty::Binder(replace_late_bound_regions(tcx, sig, |_, db| {\n         counter += 1;\n         ReLateBound(db, BrAnon(counter))\n-    }).0\n+    }).0)\n }\n \n /// Replaces the late-bound-regions in `value` that are bound by `value`."}, {"sha": "564858a462ae6cc544d894241c115076ee332b5a", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -868,6 +868,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        // because whether or not a region is bound affects subtyping,\n+        // we can't erase the bound/free distinction, but we can\n+        // replace all free regions with 'static\n         match r {\n             ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n             _ => ty::ReStatic"}, {"sha": "19c9b74743464425e4a4cdee2a22639863ee825e", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -283,35 +283,40 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let fn_ty = monomorphize::normalize_associated_type(ccx.tcx(), &fn_ty);\n \n-    let (inputs, output, abi, env) = match fn_ty.sty {\n+    let function_type; // placeholder so that the memory ownership works out ok\n+\n+    let (sig, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n-            (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n+            (&f.sig, f.abi, None)\n         }\n         ty::ty_unboxed_closure(closure_did, _, substs) => {\n             let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            let function_type = typer.unboxed_closure_type(closure_did, substs);\n+            function_type = typer.unboxed_closure_type(closure_did, substs);\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n             debug!(\"decl_rust_fn: function_type={} self_type={}\",\n                    function_type.repr(ccx.tcx()),\n                    self_type.repr(ccx.tcx()));\n-            (function_type.sig.0.inputs,\n-             function_type.sig.0.output,\n-             RustCall,\n-             Some(llenvironment_type))\n+            (&function_type.sig, RustCall, Some(llenvironment_type))\n         }\n         _ => panic!(\"expected closure or fn\")\n     };\n \n-    let llfty = type_of_rust_fn(ccx, env, inputs[], output, abi);\n-    debug!(\"decl_rust_fn(input count={},type={})\",\n-           inputs.len(),\n+    let sig = ty::erase_late_bound_regions(ccx.tcx(), sig);\n+    let sig = ty::Binder(sig);\n+\n+    let llfty = type_of_rust_fn(ccx, env, &sig, abi);\n+\n+    debug!(\"decl_rust_fn(sig={}, type={})\",\n+           sig.repr(ccx.tcx()),\n            ccx.tn().type_to_string(llfty));\n \n-    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, output);\n+    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output /* (1) */);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n     attrs.apply_llfn(llfn);\n \n+    // (1) it's ok to directly access sig.0.output because we erased all late-bound-regions above\n+\n     llfn\n }\n \n@@ -1938,7 +1943,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n-    let output_type = ty::ty_fn_ret(fn_ty);\n+    let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n     let abi = ty::ty_fn_abi(fn_ty);\n     trans_closure(ccx,\n                   decl,\n@@ -1981,7 +1986,9 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output.unwrap(),\n+        ty::ty_bare_fn(_, ref bft) => {\n+            ty::erase_late_bound_regions(bcx.tcx(), &bft.sig.output()).unwrap()\n+        }\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n@@ -2053,7 +2060,9 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(_, ref bft) => bft.sig.0.output,\n+        ty::ty_bare_fn(_, ref bft) => {\n+            ty::erase_late_bound_regions(ccx.tcx(), &bft.sig.output())\n+        }\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n@@ -2067,7 +2076,9 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    let arg_tys = ty::ty_fn_args(ctor_ty);\n+    let arg_tys =\n+        ty::erase_late_bound_regions(\n+            ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n \n     let arg_datums = create_datums_for_fn_args(&fcx, arg_tys[]);\n \n@@ -2426,49 +2437,52 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>)\n-                                        -> llvm::AttrBuilder {\n+                                        -> llvm::AttrBuilder\n+{\n     use middle::ty::{BrAnon, ReLateBound};\n \n+    let function_type;\n     let (fn_sig, abi, has_env) = match fn_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (f.sig.clone(), f.abi, false),\n+        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _, substs) => {\n             let typer = common::NormalizingUnboxedClosureTyper::new(ccx.tcx());\n-            let function_type = typer.unboxed_closure_type(closure_did, substs);\n-            (function_type.sig, RustCall, true)\n+            function_type = typer.unboxed_closure_type(closure_did, substs);\n+            (&function_type.sig, RustCall, true)\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n \n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n \n     // Since index 0 is the return value of the llvm func, we start\n     // at either 1 or 2 depending on whether there's an env slot or not\n     let mut first_arg_offset = if has_env { 2 } else { 1 };\n     let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.0.output;\n+    let ret_ty = fn_sig.output;\n \n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n         ty::ty_unboxed_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n-            match fn_sig.0.inputs[0].sty {\n+            match fn_sig.inputs[0].sty {\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n         ty::ty_bare_fn(..) if abi == RustCall => {\n-            let mut inputs = vec![fn_sig.0.inputs[0]];\n+            let mut inputs = vec![fn_sig.inputs[0]];\n \n-            match fn_sig.0.inputs[1].sty {\n+            match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n                     inputs.push_all(t_in[]);\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         }\n-        _ => fn_sig.0.inputs.clone()\n+        _ => fn_sig.inputs.clone()\n     };\n \n     if let ty::FnConverging(ret_ty) = ret_ty {"}, {"sha": "a5ed42c99ebcef90b4cf0d193c8f599309f522fb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -265,7 +265,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n-    let bare_fn_ty = ty::normalize_ty(tcx, bare_fn_ty);\n+    let bare_fn_ty = normalize_ty(tcx, bare_fn_ty);\n     match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n         Some(&llval) => { return llval; }\n         None => { }\n@@ -279,24 +279,22 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n-    let (opt_def_id, input_tys, output_ty) =\n+    let (opt_def_id, sig) =\n         match bare_fn_ty.sty {\n             ty::ty_bare_fn(opt_def_id,\n                            &ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n-                                          abi: synabi::Rust,\n-                                          sig: ty::Binder(ty::FnSig { inputs: ref input_tys,\n-                                                                      output: output_ty,\n-                                                                      variadic: false })}) =>\n-            {\n-                (opt_def_id, input_tys, output_ty)\n+                                           abi: synabi::Rust,\n+                                           ref sig }) => {\n+                (opt_def_id, sig)\n             }\n \n             _ => {\n                 tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n                                            bare_fn_ty.repr(tcx))[]);\n             }\n         };\n-    let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n+    let sig = ty::erase_late_bound_regions(tcx, sig);\n+    let tuple_input_ty = ty::mk_tup(tcx, sig.inputs.to_vec());\n     let tuple_fn_ty = ty::mk_bare_fn(tcx,\n                                      opt_def_id,\n                                      tcx.mk_bare_fn(ty::BareFnTy {\n@@ -305,7 +303,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                          sig: ty::Binder(ty::FnSig {\n                                              inputs: vec![bare_fn_ty_ref,\n                                                           tuple_input_ty],\n-                                             output: output_ty,\n+                                             output: sig.output,\n                                              variadic: false\n                                          })}));\n     debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n@@ -326,26 +324,26 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                           llfn,\n                           ast::DUMMY_NODE_ID,\n                           false,\n-                          output_ty,\n+                          sig.output,\n                           &empty_substs,\n                           None,\n                           &block_arena);\n-    let mut bcx = init_function(&fcx, false, output_ty);\n+    let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be ptr to the the fn pointer\n     let llfnpointer =\n         Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32));\n \n     // the remaining arguments will be the untupled values\n     let llargs: Vec<_> =\n-        input_tys.iter()\n+        sig.inputs.iter()\n         .enumerate()\n         .map(|(i, _)| get_param(fcx.llfn, fcx.arg_pos(i+1) as u32))\n         .collect();\n     assert!(!fcx.needs_ret_allocas);\n \n     let dest = fcx.llretslotptr.get().map(|_|\n-        expr::SaveIn(fcx.get_ret_slot(bcx, output_ty, \"ret_slot\"))\n+        expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n     );\n \n     bcx = trans_call_inner(bcx,\n@@ -355,7 +353,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            ArgVals(llargs[]),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, output_ty);\n+    finish_fn(&fcx, bcx, sig.output);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n \n@@ -668,7 +666,10 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (f.abi, f.sig.0.output),\n+        ty::ty_bare_fn(_, ref f) => {\n+            let output = ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output());\n+            (f.abi, output)\n+        }\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n \n@@ -865,13 +866,18 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n                              ignore_self: bool)\n-                             -> Block<'blk, 'tcx> {\n+                             -> Block<'blk, 'tcx>\n+{\n+    let args =\n+        ty::erase_late_bound_regions(\n+            bcx.tcx(), &ty::ty_fn_args(fn_ty));\n+\n     // Translate the `self` argument first.\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n-                            ty::ty_fn_args(fn_ty)[0],\n+                            args[0],\n                             arg_datum,\n                             arg_cleanup_scope,\n                             DontAutorefArg)\n@@ -926,7 +932,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                               ignore_self: bool)\n                               -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n-    let arg_tys = ty::ty_fn_args(fn_ty);\n+    let arg_tys = ty::erase_late_bound_regions(bcx.tcx(),  &ty::ty_fn_args(fn_ty));\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n@@ -974,7 +980,7 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n-    let arg_tys = ty::ty_fn_args(fn_ty);\n+    let arg_tys = ty::erase_late_bound_regions(cx.tcx(), &ty::ty_fn_args(fn_ty));\n     let variadic = ty::fn_is_variadic(fn_ty);\n \n     let mut bcx = cx;"}, {"sha": "ad5159f0e990b550475f232b9f76cbe5bc1d0d6c", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -442,7 +442,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   bcx.fcx.param_substs,\n                   id,\n                   &[],\n-                  ty::ty_fn_ret(fty),\n+                  ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fty)),\n                   ty::ty_fn_abi(fty),\n                   ClosureEnv::new(freevars[],\n                                   BoxedClosure(cdata_ty, store)));\n@@ -466,7 +466,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n \n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let function_type = ty::normalize_ty(ccx.tcx(), function_type);\n+    let function_type = normalize_ty(ccx.tcx(), function_type);\n     let params = match function_type.sty {\n         ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n@@ -533,14 +533,16 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n     let freevar_mode = bcx.tcx().capture_mode(id);\n \n+    let sig = ty::erase_late_bound_regions(bcx.tcx(), &function_type.sig);\n+\n     trans_closure(bcx.ccx(),\n                   decl,\n                   body,\n                   llfn.val,\n                   bcx.fcx.param_substs,\n                   id,\n                   &[],\n-                  function_type.sig.0.output,\n+                  sig.output,\n                   function_type.abi,\n                   ClosureEnv::new(freevars[],\n                                   UnboxedClosure(freevar_mode)));"}, {"sha": "3a9bd77c5161e604b3c822a35b5f1f8e95910322", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -58,6 +58,61 @@ use util::nodemap::FnvHashSet;\n \n pub use trans::context::CrateContext;\n \n+/// Returns an equivalent type with all the typedefs and self regions removed.\n+pub fn normalize_ty<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    let u = TypeNormalizer(cx).fold_ty(ty);\n+    debug!(\"normalize_ty({}) = {}\",\n+           ty.repr(cx), u.repr(cx));\n+    return u;\n+\n+    struct TypeNormalizer<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n+\n+    impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n+        fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n+                None => {}\n+                Some(u) => return u\n+            }\n+\n+            let t_norm = ty_fold::super_fold_ty(self, ty);\n+            self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n+            return t_norm;\n+        }\n+\n+        fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+            where T : TypeFoldable<'tcx> + Repr<'tcx>\n+        {\n+            // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n+            let u = ty::anonymize_late_bound_regions(self.tcx(), t);\n+            ty_fold::super_fold_binder(self, &u)\n+        }\n+\n+        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            // because late-bound regions affect subtyping, we can't\n+            // erase the bound/free distinction, but we can replace\n+            // all free regions with 'static.\n+            //\n+            // Note that we *CAN* replace early-bound regions -- the\n+            // type system never \"sees\" those, they get substituted\n+            // away. In trans, they will always be erased to 'static\n+            // whenever a substitution occurs.\n+            match r {\n+                ty::ReLateBound(..) => r,\n+                _ => ty::ReStatic\n+            }\n+        }\n+\n+        fn fold_substs(&mut self,\n+                       substs: &subst::Substs<'tcx>)\n+                       -> subst::Substs<'tcx> {\n+            subst::Substs { regions: subst::ErasedRegions,\n+                            types: substs.types.fold_with(self) }\n+        }\n+    }\n+}\n+\n // Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     ty::type_contents(cx, ty).is_sized(cx)"}, {"sha": "afb43c38762a3a9f17cb417e67fc3af4128e21b2", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -265,7 +265,8 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              pat: &ast::Pat,\n                              head: &ast::Expr,\n                              body: &ast::Block)\n-                             -> Block<'blk, 'tcx> {\n+                             -> Block<'blk, 'tcx>\n+{\n     let _icx = push_ctxt(\"trans_for\");\n \n     //            bcx\n@@ -306,7 +307,9 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                      .borrow())[method_call]\n                                      .ty;\n     let method_type = monomorphize_type(loopback_bcx_in, method_type);\n-    let method_result_type = ty::ty_fn_ret(method_type).unwrap();\n+    let method_result_type =\n+        ty::assert_no_late_bound_regions( // LB regions are instantiated in invoked methods\n+            loopback_bcx_in.tcx(), &ty::ty_fn_ret(method_type)).unwrap();\n     let option_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n     let option_cleanup_scope_id = cleanup::CustomScope(option_cleanup_scope);\n "}, {"sha": "59a918d6509bafe0cc6829533b969b14ed14ac09", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -425,10 +425,14 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n \n+                let principal =\n+                    ty::erase_late_bound_regions(cx.tcx(),\n+                                                 &trait_data.principal);\n+\n                 from_def_id_and_substs(self,\n                                        cx,\n-                                       trait_data.principal_def_id(),\n-                                       trait_data.principal.0.substs,\n+                                       principal.def_id,\n+                                       principal.substs,\n                                        &mut unique_type_id);\n             },\n             ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n@@ -440,7 +444,9 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 unique_type_id.push_str(\" fn(\");\n \n-                for &parameter_type in sig.0.inputs.iter() {\n+                let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+\n+                for &parameter_type in sig.inputs.iter() {\n                     let parameter_type_id =\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n@@ -449,12 +455,12 @@ impl<'tcx> TypeMap<'tcx> {\n                     unique_type_id.push(',');\n                 }\n \n-                if sig.0.variadic {\n+                if sig.variadic {\n                     unique_type_id.push_str(\"...\");\n                 }\n \n                 unique_type_id.push_str(\")->\");\n-                match sig.0.output {\n+                match sig.output {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n@@ -568,7 +574,9 @@ impl<'tcx> TypeMap<'tcx> {\n             }\n         };\n \n-        for &parameter_type in sig.0.inputs.iter() {\n+        let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+\n+        for &parameter_type in sig.inputs.iter() {\n             let parameter_type_id =\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n@@ -577,13 +585,13 @@ impl<'tcx> TypeMap<'tcx> {\n             unique_type_id.push(',');\n         }\n \n-        if sig.0.variadic {\n+        if sig.variadic {\n             unique_type_id.push_str(\"...\");\n         }\n \n         unique_type_id.push_str(\"|->\");\n \n-        match sig.0.output {\n+        match sig.output {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n@@ -2822,11 +2830,14 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       unique_type_id: UniqueTypeId,\n                                       signature: &ty::PolyFnSig<'tcx>,\n                                       span: Span)\n-                                      -> MetadataCreationResult {\n-    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.0.inputs.len() + 1);\n+                                      -> MetadataCreationResult\n+{\n+    let signature = ty::erase_late_bound_regions(cx.tcx(), signature);\n+\n+    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n-    signature_metadata.push(match signature.0.output {\n+    signature_metadata.push(match signature.output {\n         ty::FnConverging(ret_ty) => match ret_ty.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, ret_ty, span)\n@@ -2835,7 +2846,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     });\n \n     // regular arguments\n-    for &argument_type in signature.0.inputs.iter() {\n+    for &argument_type in signature.inputs.iter() {\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n@@ -3794,8 +3805,9 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n-            push_item_name(cx, trait_data.principal_def_id(), false, output);\n-            push_type_params(cx, trait_data.principal.0.substs, output);\n+            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n+            push_item_name(cx, principal.def_id, false, output);\n+            push_type_params(cx, principal.substs, output);\n         },\n         ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n@@ -3810,17 +3822,18 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            if sig.0.inputs.len() > 0 {\n-                for &parameter_type in sig.0.inputs.iter() {\n+            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+            if sig.inputs.len() > 0 {\n+                for &parameter_type in sig.inputs.iter() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n                 output.pop();\n             }\n \n-            if sig.0.variadic {\n-                if sig.0.inputs.len() > 0 {\n+            if sig.variadic {\n+                if sig.inputs.len() > 0 {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");\n@@ -3829,7 +3842,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(')');\n \n-            match sig.0.output {\n+            match sig.output {\n                 ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");"}, {"sha": "33c669df73d7f5bd342c5ed1d93b48ec909a5500", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -585,14 +585,16 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        .borrow()\n                                        .get(&method_call)\n                                        .map(|method| method.ty);\n+                    let method_ty = monomorphize_type(bcx, method_ty.unwrap());\n                     let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n \n                     let mut args = vec![];\n                     start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n                     end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n \n-                    let result_ty = ty::ty_fn_ret(monomorphize_type(bcx,\n-                                                                    method_ty.unwrap())).unwrap();\n+                    let result_ty = // LB regions are instantiated in invoked methods\n+                        ty::assert_no_late_bound_regions(\n+                            bcx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n                     let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n \n                     unpack_result!(bcx,\n@@ -732,12 +734,16 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                        .map(|method| method.ty);\n     let elt_datum = match method_ty {\n         Some(method_ty) => {\n+            let method_ty = monomorphize_type(bcx, method_ty);\n+\n             let base_datum = unpack_datum!(bcx, trans(bcx, base));\n \n             // Translate index expression.\n             let ix_datum = unpack_datum!(bcx, trans(bcx, idx));\n \n-            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty)).unwrap();\n+            let ref_ty = // invoked methods have LB regions instantiated:\n+                ty::assert_no_late_bound_regions(\n+                    bcx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n             let elt_ty = match ty::deref(ref_ty, true) {\n                 None => {\n                     bcx.tcx().sess.span_bug(index_expr.span,\n@@ -2181,6 +2187,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                        .get(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {\n+            let method_ty = monomorphize_type(bcx, method_ty);\n+\n             // Overloaded. Evaluate `trans_overloaded_op`, which will\n             // invoke the user's deref() method, which basically\n             // converts from the `Smaht<T>` pointer that we have into\n@@ -2192,7 +2200,9 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => datum\n             };\n \n-            let ref_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty)).unwrap();\n+            let ref_ty = // invoked methods have their LB regions instantiated\n+                ty::assert_no_late_bound_regions(\n+                    ccx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,"}, {"sha": "e58807d658881a840a22552489aa30cc8d79cca2", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -43,7 +43,7 @@ use util::ppaux::Repr;\n \n struct ForeignTypes<'tcx> {\n     /// Rust signature of the function\n-    fn_sig: ty::PolyFnSig<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n \n     /// Adapter object for handling native ABI rules (trust me, you\n     /// don't want to know)\n@@ -180,7 +180,7 @@ pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Make sure the calling convention is right for variadic functions\n     // (should've been caught if not in typeck)\n-    if tys.fn_sig.0.variadic {\n+    if tys.fn_sig.variadic {\n         assert!(cc == llvm::CCallConv);\n     }\n \n@@ -218,7 +218,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      llretptr: ValueRef,\n                                      llargs_rust: &[ValueRef],\n                                      passed_arg_tys: Vec<Ty<'tcx>>)\n-                                     -> Block<'blk, 'tcx> {\n+                                     -> Block<'blk, 'tcx>\n+{\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n \n@@ -230,9 +231,10 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            ccx.tn().val_to_string(llretptr));\n \n     let (fn_abi, fn_sig) = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n+        ty::ty_bare_fn(_, ref fn_ty) => (fn_ty.abi, &fn_ty.sig),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys[]);\n     let fn_type = cabi::compute_abi_info(ccx,\n                                          llsig.llarg_tys[],\n@@ -387,7 +389,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n-            match fn_sig.0.output {\n+            match fn_sig.output {\n                 ty::FnConverging(result_ty) => {\n                     base::store_ty(bcx, llforeign_retval, llretptr, result_ty)\n                 }\n@@ -635,7 +637,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         };\n \n         // Push Rust return pointer, using null if it will be unused.\n-        let rust_uses_outptr = match tys.fn_sig.0.output {\n+        let rust_uses_outptr = match tys.fn_sig.output {\n             ty::FnConverging(ret_ty) => type_of::return_uses_outptr(ccx, ret_ty),\n             ty::FnDiverging => false\n         };\n@@ -668,7 +670,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             return_ty={}\",\n                            ccx.tn().val_to_string(slot),\n                            ccx.tn().type_to_string(llrust_ret_ty),\n-                           tys.fn_sig.0.output.repr(tcx));\n+                           tys.fn_sig.output.repr(tcx));\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n                 }\n@@ -683,8 +685,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Build up the arguments to the call to the rust function.\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n-        for i in range(0, tys.fn_sig.0.inputs.len()) {\n-            let rust_ty = tys.fn_sig.0.inputs[i];\n+        for i in range(0, tys.fn_sig.inputs.len()) {\n+            let rust_ty = tys.fn_sig.inputs[i];\n             let llrust_ty = tys.llsig.llarg_tys[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n             let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n@@ -829,10 +831,11 @@ pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n /// because foreign functions just plain ignore modes. They also don't pass aggregate values by\n /// pointer like we do.\n fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               fn_sig: &ty::PolyFnSig<'tcx>, arg_tys: &[Ty<'tcx>])\n+                               fn_sig: &ty::FnSig<'tcx>,\n+                               arg_tys: &[Ty<'tcx>])\n                                -> LlvmSignature {\n     let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n-    let (llret_ty, ret_def) = match fn_sig.0.output {\n+    let (llret_ty, ret_def) = match fn_sig.output {\n         ty::FnConverging(ret_ty) =>\n             (type_of::arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n         ty::FnDiverging =>\n@@ -853,10 +856,11 @@ fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n     let fn_sig = match ty.sty {\n-        ty::ty_bare_fn(_, ref fn_ty) => fn_ty.sig.clone(),\n+        ty::ty_bare_fn(_, ref fn_ty) => &fn_ty.sig,\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.0.inputs.as_slice());\n+    let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n+    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        llsig.llarg_tys[],\n                                        llsig.llret_ty,\n@@ -916,7 +920,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n         llargument_tys.push(llarg_ty);\n     }\n \n-    if tys.fn_sig.0.variadic {\n+    if tys.fn_sig.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n         Type::func(llargument_tys[], &llreturn_ty)"}, {"sha": "8019ae822e65fb33039d99b5ca31939eacfc5081", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -212,7 +212,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  dtor_did: ast::DefId,\n                                  class_did: ast::DefId,\n                                  substs: &subst::Substs<'tcx>)\n-                                 -> Block<'blk, 'tcx> {\n+                                 -> Block<'blk, 'tcx>\n+{\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n     // Find and call the actual destructor\n@@ -228,8 +229,9 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n     let self_ty = match fty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n-            assert!(f.sig.0.inputs.len() == 1);\n-            f.sig.0.inputs[0]\n+            let sig = ty::erase_late_bound_regions(bcx.tcx(), &f.sig);\n+            assert!(sig.inputs.len() == 1);\n+            sig.inputs[0]\n         }\n         _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n                                     bcx.ty_to_string(fty))[])"}, {"sha": "ed75445b9939be9b1266334364a9e229c827e244", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -150,14 +150,16 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             dest: expr::Dest,\n                                             substs: subst::Substs<'tcx>,\n                                             call_info: NodeInfo)\n-                                            -> Result<'blk, 'tcx> {\n-\n+                                            -> Result<'blk, 'tcx>\n+{\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n \n     let ret_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => f.sig.0.output,\n+        ty::ty_bare_fn(_, ref f) => {\n+            ty::erase_late_bound_regions(bcx.tcx(), &f.sig.output())\n+        }\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);"}, {"sha": "362fca881b7115440af17c1ae54b28f16214551b", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -477,13 +477,19 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n+\n     // Replace the self type (&Self or Box<Self>) with an opaque pointer.\n     let llcallee_ty = match callee_ty.sty {\n         ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n+            let fake_sig =\n+                ty::Binder(ty::FnSig {\n+                    inputs: f.sig.0.inputs.slice_from(1).to_vec(),\n+                    output: f.sig.0.output,\n+                    variadic: f.sig.0.variadic,\n+                });\n             type_of_rust_fn(ccx,\n                             Some(Type::i8p(ccx)),\n-                            f.sig.0.inputs.slice_from(1),\n-                            f.sig.0.output,\n+                            &fake_sig,\n                             f.abi)\n         }\n         _ => {\n@@ -557,7 +563,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     // Upcast to the trait in question and extract out the substitutions.\n     let upcast_trait_ref = traits::upcast(ccx.tcx(), object_trait_ref.clone(), trait_id).unwrap();\n-    let object_substs = upcast_trait_ref.substs().clone().erase_regions();\n+    let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n+    let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n     debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));\n \n     // Lookup the type of this method as deeclared in the trait and apply substitutions.\n@@ -579,18 +586,20 @@ pub fn trans_object_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx, method_bare_fn_ty, function_name.as_slice());\n \n+    let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n+\n     //\n     let block_arena = TypedArena::new();\n     let empty_substs = Substs::trans_empty();\n     let fcx = new_fn_ctxt(ccx,\n                           llfn,\n                           ast::DUMMY_NODE_ID,\n                           false,\n-                          fty.sig.0.output,\n+                          sig.output,\n                           &empty_substs,\n                           None,\n                           &block_arena);\n-    let mut bcx = init_function(&fcx, false, fty.sig.0.output);\n+    let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be a trait object\n     let llobject = get_param(fcx.llfn, fcx.arg_pos(0) as u32);\n@@ -603,18 +612,18 @@ pub fn trans_object_shim<'a, 'tcx>(\n         match fty.abi {\n             RustCall => {\n                 // unpack the tuple to extract the input type arguments:\n-                match fty.sig.0.inputs[1].sty {\n+                match sig.inputs[1].sty {\n                     ty::ty_tup(ref tys) => tys.as_slice(),\n                     _ => {\n                         bcx.sess().bug(\n                             format!(\"rust-call expects a tuple not {}\",\n-                                    fty.sig.0.inputs[1].repr(tcx)).as_slice());\n+                                    sig.inputs[1].repr(tcx)).as_slice());\n                     }\n                 }\n             }\n             _ => {\n                 // skip the self parameter:\n-                fty.sig.0.inputs.slice_from(1)\n+                sig.inputs.slice_from(1)\n             }\n         };\n \n@@ -631,9 +640,12 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     assert!(!fcx.needs_ret_allocas);\n \n+    let sig =\n+        ty::erase_late_bound_regions(bcx.tcx(), &fty.sig);\n+\n     let dest =\n         fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, fty.sig.0.output, \"ret_slot\")));\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n \n     let method_offset_in_vtable =\n         traits::get_vtable_index_of_object_method(bcx.tcx(),\n@@ -653,7 +665,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n                            ArgVals(llargs.as_slice()),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, fty.sig.0.output);\n+    finish_fn(&fcx, bcx, sig.output);\n \n     llfn\n }"}, {"sha": "64b83c48729d4b765372e196e70d572d9c7950ba", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -17,7 +17,7 @@ use trans::adt;\n use trans::common::*;\n use trans::foreign;\n use trans::machine;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, RegionEscape, Ty};\n use util::ppaux;\n use util::ppaux::Repr;\n \n@@ -99,18 +99,21 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  llenvironment_type: Option<Type>,\n-                                 inputs: &[Ty<'tcx>],\n-                                 output: ty::FnOutput<'tcx>,\n+                                 sig: &ty::Binder<ty::FnSig<'tcx>>,\n                                  abi: abi::Abi)\n-                                 -> Type {\n+                                 -> Type\n+{\n+    let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+    assert!(!sig.variadic); // rust fns are never variadic\n+\n     let mut atys: Vec<Type> = Vec::new();\n \n     // First, munge the inputs, if this has the `rust-call` ABI.\n-    let inputs = untuple_arguments_if_necessary(cx, inputs, abi);\n+    let inputs = untuple_arguments_if_necessary(cx, sig.inputs.as_slice(), abi);\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n-    let lloutputtype = match output {\n+    let lloutputtype = match sig.output {\n         ty::FnConverging(output) => {\n             let use_out_pointer = return_uses_outptr(cx, output);\n             let lloutputtype = arg_type_of(cx, output);\n@@ -147,11 +150,7 @@ pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>)\n             // FIXME(#19925) once fn item types are\n             // zero-sized, we'll need to do something here\n             if f.abi == abi::Rust || f.abi == abi::RustCall {\n-                type_of_rust_fn(cx,\n-                                None,\n-                                f.sig.0.inputs.as_slice(),\n-                                f.sig.0.output,\n-                                f.abi)\n+                type_of_rust_fn(cx, None, &f.sig, f.abi)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)\n             }\n@@ -279,12 +278,14 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n \n     debug!(\"type_of {} {}\", t.repr(cx.tcx()), t.sty);\n \n+    assert!(!t.has_escaping_regions());\n+\n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n     // Rust types are defined as the same LLVM types.  If we don't do\n     // this then, e.g. `Option<{myfield: bool}>` would be a different\n     // type than `Option<myrec>`.\n-    let t_norm = ty::normalize_ty(cx.tcx(), t);\n+    let t_norm = normalize_ty(cx.tcx(), t);\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);"}, {"sha": "8cd181c37747d76134932f666b0222bb4a4db16b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -505,9 +505,10 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n \n     let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n     let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n+        let fn_ret = ty::assert_no_late_bound_regions(tcx, &ty::ty_fn_ret(ctor_scheme.ty));\n         ty::TypeScheme {\n-            ty: ty::ty_fn_ret(ctor_scheme.ty).unwrap(),\n-            ..ctor_scheme\n+            ty: fn_ret.unwrap(),\n+            generics: ctor_scheme.generics,\n         }\n     } else {\n         ctor_scheme"}, {"sha": "d9afa2da3b5eea34eeb7a892351c0e0dad75fd6b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -2317,7 +2317,9 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     match method {\n         Some(method) => {\n-            let ref_ty = ty::ty_fn_ret(method.ty);\n+            let ref_ty = // invoked methods have all LB regions instantiated\n+                ty::assert_no_late_bound_regions(\n+                    fcx.tcx(), &ty::ty_fn_ret(method.ty));\n             match method_call {\n                 Some(method_call) => {\n                     fcx.inh.method_map.borrow_mut().insert(method_call,\n@@ -2448,7 +2450,11 @@ fn try_overloaded_slice_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let method_ty = method.ty;\n         make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method));\n \n-        let result_ty = ty::ty_fn_ret(method_ty);\n+        let result_ty =\n+            // invoked methods have LB regions instantiated\n+            ty::assert_no_late_bound_regions(fcx.tcx(),\n+                                             &ty::ty_fn_ret(method_ty));\n+\n         let result_ty = match result_ty {\n             ty::FnConverging(result_ty) => result_ty,\n             ty::FnDiverging => {"}, {"sha": "4badfc03858a407094648ae806a59bb75f50ad79", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -582,7 +582,9 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 Some(method) => {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n-                    ty::ty_fn_ret(method.ty).unwrap()\n+                    let fn_ret = // late-bound regions in overloaded method calls are instantiated\n+                        ty::assert_no_late_bound_regions(rcx.tcx(), &ty::ty_fn_ret(method.ty));\n+                    fn_ret.unwrap()\n                 }\n                 None => rcx.resolve_node_type(base.id)\n             };"}, {"sha": "300f72960848e9436d1b0c70b117d181c02368cd", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -416,7 +416,13 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             match variant.node.kind {\n                 ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                     let ctor_ty = ty::node_id_to_type(fcx.tcx(), variant.node.id);\n-                    let arg_tys = ty::ty_fn_args(ctor_ty);\n+\n+                    // the regions in the argument types come from the\n+                    // enum def'n, and hence will all be early bound\n+                    let arg_tys =\n+                        ty::assert_no_late_bound_regions(\n+                            fcx.tcx(), &ty::ty_fn_args(ctor_ty));\n+\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];"}, {"sha": "4a57ed56594b1a04a1b81d73d3e5528f3c16c5f2", "filename": "src/test/run-pass/issue-20644.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20644.rs?ref=2486d93e5b8a3dd62fa6d257d4086e19c0e0edd6", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A reduced version of the rustbook ice. The problem this encountered\n+// had to do with trans ignoring binders.\n+\n+#![feature(slicing_syntax)]\n+#![feature(associated_types)]\n+#![feature(macro_rules)]\n+\n+use std::iter;\n+use std::os;\n+use std::io::File;\n+\n+#[allow(unused)]\n+pub fn parse_summary<R: Reader>(_: R, _: &Path) {\n+     let path_from_root = Path::new(\"\");\n+     Path::new(iter::repeat(\"../\")\n+               .take(path_from_root.components().count() - 1)\n+               .collect::<String>());\n+ }\n+\n+fn main() {\n+    let cwd = os::getcwd().unwrap();\n+    let src = cwd.clone();\n+    let summary = File::open(&src.join(\"SUMMARY.md\"));\n+    let _ = parse_summary(summary, &src);\n+}"}]}