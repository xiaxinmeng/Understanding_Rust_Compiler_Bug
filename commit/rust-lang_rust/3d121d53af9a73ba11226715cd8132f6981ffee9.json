{"sha": "3d121d53af9a73ba11226715cd8132f6981ffee9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMTIxZDUzYWY5YTczYmExMTIyNjcxNWNkODEzMmY2OTgxZmZlZTk=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-04-27T07:15:51Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-04-27T07:15:51Z"}, "message": "Extract roles getting indexes from `get_indexed_assignments`", "tree": {"sha": "101d6c0dd031d9c2afbfbcb30b4e2a820177b22e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/101d6c0dd031d9c2afbfbcb30b4e2a820177b22e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d121d53af9a73ba11226715cd8132f6981ffee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d121d53af9a73ba11226715cd8132f6981ffee9", "html_url": "https://github.com/rust-lang/rust/commit/3d121d53af9a73ba11226715cd8132f6981ffee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d121d53af9a73ba11226715cd8132f6981ffee9/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aab80eedf3e271ada92a6509727461cc3aa6bb12", "url": "https://api.github.com/repos/rust-lang/rust/commits/aab80eedf3e271ada92a6509727461cc3aa6bb12", "html_url": "https://github.com/rust-lang/rust/commit/aab80eedf3e271ada92a6509727461cc3aa6bb12"}], "stats": {"total": 106, "additions": 55, "deletions": 51}, "files": [{"sha": "0753b23e45b30dddba21fd52d53e0a3d083d3f0a", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3d121d53af9a73ba11226715cd8132f6981ffee9/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d121d53af9a73ba11226715cd8132f6981ffee9/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3d121d53af9a73ba11226715cd8132f6981ffee9", "patch": "@@ -10,7 +10,6 @@ use crate::utils::{\n };\n use crate::utils::{is_type_diagnostic_item, qpath_res, same_tys, sext, sugg};\n use if_chain::if_chain;\n-use itertools::Itertools;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n@@ -885,52 +884,39 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, v\n     }\n }\n \n-fn get_indexed_assignments<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    body: &Expr<'_>,\n-    var: HirId,\n-) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n-    fn get_assignment<'a, 'tcx>(\n-        cx: &LateContext<'a, 'tcx>,\n-        e: &Expr<'_>,\n-        var: HirId,\n-    ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n+fn get_assignments<'a, 'tcx>(\n+    body: &'tcx Expr<'tcx>,\n+) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> {\n+    fn get_assignment<'a, 'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n         if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n-            match (\n-                get_fixed_offset_var(cx, lhs, var),\n-                get_fixed_offset_var(cx, fetch_cloned_expr(rhs), var),\n-            ) {\n-                (Some(offset_left), Some(offset_right)) => {\n-                    // Source and destination must be different\n-                    if offset_left.var_name == offset_right.var_name {\n-                        None\n-                    } else {\n-                        Some((offset_left, offset_right))\n-                    }\n-                },\n-                _ => None,\n-            }\n+            Some((lhs, rhs))\n         } else {\n             None\n         }\n     }\n \n+    // This is one of few ways to return different iterators\n+    // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+    let mut iter_a = None;\n+    let mut iter_b = None;\n+\n     if let ExprKind::Block(b, _) = body.kind {\n         let Block { stmts, expr, .. } = *b;\n \n-        stmts\n+        iter_a = stmts\n             .iter()\n             .filter_map(|stmt| match stmt.kind {\n                 StmtKind::Local(..) | StmtKind::Item(..) => None,\n                 StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n             })\n             .chain(expr.into_iter())\n-            .map(|op| get_assignment(cx, op, var))\n-            .collect::<Option<Vec<_>>>()\n-            .unwrap_or_default()\n+            .map(get_assignment)\n+            .into()\n     } else {\n-        get_assignment(cx, body, var).into_iter().collect()\n+        iter_b = Some(get_assignment(body))\n     }\n+\n+    iter_a.into_iter().flatten().chain(iter_b.into_iter())\n }\n \n /// Checks for for loops that sequentially copy items from one slice-like\n@@ -1003,30 +989,48 @@ fn detect_manual_memcpy<'a, 'tcx>(\n \n             // The only statements in the for loops can be indexed assignments from\n             // indexed retrievals.\n-            let manual_copies = get_indexed_assignments(cx, body, canonical_id);\n-\n-            let big_sugg = manual_copies\n-                .into_iter()\n-                .map(|(dst_var, src_var)| {\n-                    let start_str = snippet(cx, start.span, \"\").to_string();\n-                    let dst_offset = print_offset(&start_str, &dst_var.offset);\n-                    let dst_limit = print_limit(end, dst_var.offset, &dst_var.var_name);\n-                    let src_offset = print_offset(&start_str, &src_var.offset);\n-                    let src_limit = print_limit(end, src_var.offset, &src_var.var_name);\n-                    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n-                        dst_var.var_name\n-                    } else {\n-                        format!(\"{}[{}..{}]\", dst_var.var_name, dst_offset, dst_limit)\n-                    };\n+            let big_sugg = get_assignments(body)\n+                .map(|o| {\n+                    o.and_then(|(lhs, rhs)| {\n+                        let rhs = fetch_cloned_expr(rhs);\n+                        if_chain! {\n+                            if let Some(offset_left) = get_fixed_offset_var(cx, lhs, canonical_id);\n+                            if let Some(offset_right) = get_fixed_offset_var(cx, rhs, canonical_id);\n+\n+                            // Source and destination must be different\n+                            if offset_left.var_name != offset_right.var_name;\n+                            then {\n+                                Some((offset_left, offset_right))\n+                            } else {\n+                                return None\n+                            }\n+                        }\n+                    })\n+                })\n+                .map(|o| {\n+                    o.map(|(dst_var, src_var)| {\n+                        let start_str = snippet(cx, start.span, \"\").to_string();\n+                        let dst_offset = print_offset(&start_str, &dst_var.offset);\n+                        let dst_limit = print_limit(end, dst_var.offset, &dst_var.var_name);\n+                        let src_offset = print_offset(&start_str, &src_var.offset);\n+                        let src_limit = print_limit(end, src_var.offset, &src_var.var_name);\n+                        let dst = if dst_offset == \"\" && dst_limit == \"\" {\n+                            dst_var.var_name\n+                        } else {\n+                            format!(\"{}[{}..{}]\", dst_var.var_name, dst_offset, dst_limit)\n+                        };\n \n-                    format!(\n-                        \"{}.clone_from_slice(&{}[{}..{}])\",\n-                        dst, src_var.var_name, src_offset, src_limit\n-                    )\n+                        format!(\n+                            \"{}.clone_from_slice(&{}[{}..{}])\",\n+                            dst, src_var.var_name, src_offset, src_limit\n+                        )\n+                    })\n                 })\n-                .join(\"\\n    \");\n+                .collect::<Option<Vec<_>>>()\n+                .filter(|v| !v.is_empty())\n+                .map(|v| v.join(\"\\n    \"));\n \n-            if !big_sugg.is_empty() {\n+            if let Some(big_sugg) = big_sugg {\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_MEMCPY,"}]}