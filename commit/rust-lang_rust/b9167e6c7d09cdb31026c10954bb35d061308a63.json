{"sha": "b9167e6c7d09cdb31026c10954bb35d061308a63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MTY3ZTZjN2QwOWNkYjMxMDI2YzEwOTU0YmIzNWQwNjEzMDhhNjM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-02-23T01:38:33Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-03-16T17:29:19Z"}, "message": "Support type search for arguments and returned types", "tree": {"sha": "184d036c182fc2ff1b327052aa5ff97dc899cff3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/184d036c182fc2ff1b327052aa5ff97dc899cff3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9167e6c7d09cdb31026c10954bb35d061308a63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9167e6c7d09cdb31026c10954bb35d061308a63", "html_url": "https://github.com/rust-lang/rust/commit/b9167e6c7d09cdb31026c10954bb35d061308a63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9167e6c7d09cdb31026c10954bb35d061308a63/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59f4ba95045e91a63e921e0d736242d7e1ffabec", "url": "https://api.github.com/repos/rust-lang/rust/commits/59f4ba95045e91a63e921e0d736242d7e1ffabec", "html_url": "https://github.com/rust-lang/rust/commit/59f4ba95045e91a63e921e0d736242d7e1ffabec"}], "stats": {"total": 325, "additions": 222, "deletions": 103}, "files": [{"sha": "e69d4ddc2d01b4f97276daea97faecd768dc8082", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b9167e6c7d09cdb31026c10954bb35d061308a63", "patch": "@@ -1078,6 +1078,26 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     }\n }\n \n+impl Clean<TypeKind> for hir::def::DefKind {\n+    fn clean(&self, _: &DocContext<'_>) -> TypeKind {\n+        match *self {\n+            hir::def::DefKind::Mod => TypeKind::Module,\n+            hir::def::DefKind::Struct => TypeKind::Struct,\n+            hir::def::DefKind::Union => TypeKind::Union,\n+            hir::def::DefKind::Enum => TypeKind::Enum,\n+            hir::def::DefKind::Trait => TypeKind::Trait,\n+            hir::def::DefKind::TyAlias => TypeKind::Typedef,\n+            hir::def::DefKind::ForeignTy => TypeKind::Foreign,\n+            hir::def::DefKind::TraitAlias => TypeKind::TraitAlias,\n+            hir::def::DefKind::Fn => TypeKind::Function,\n+            hir::def::DefKind::Const => TypeKind::Const,\n+            hir::def::DefKind::Static => TypeKind::Static,\n+            hir::def::DefKind::Macro(_) => TypeKind::Macro,\n+            _ => TypeKind::Foreign,\n+        }\n+    }\n+}\n+\n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.kind {"}, {"sha": "73f2c399e56982bc67a2312044bc59d86dc69d3a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=b9167e6c7d09cdb31026c10954bb35d061308a63", "patch": "@@ -836,26 +836,26 @@ pub struct Method {\n     pub decl: FnDecl,\n     pub header: hir::FnHeader,\n     pub defaultness: Option<hir::Defaultness>,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n+    pub all_types: Vec<(Type, TypeKind)>,\n+    pub ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, Debug)]\n pub struct TyMethod {\n     pub header: hir::FnHeader,\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n+    pub all_types: Vec<(Type, TypeKind)>,\n+    pub ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub header: hir::FnHeader,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n+    pub all_types: Vec<(Type, TypeKind)>,\n+    pub ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -1042,7 +1042,7 @@ pub enum PrimitiveType {\n     Never,\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n pub enum TypeKind {\n     Enum,\n     Function,"}, {"sha": "b54af499187097e5b22e3e860f705f44ab15dab3", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=b9167e6c7d09cdb31026c10954bb35d061308a63", "patch": "@@ -184,7 +184,7 @@ pub fn get_real_types(\n     arg: &Type,\n     cx: &DocContext<'_>,\n     recurse: i32,\n-) -> FxHashSet<Type> {\n+) -> FxHashSet<(Type, TypeKind)> {\n     let arg_s = arg.print().to_string();\n     let mut res = FxHashSet::default();\n     if recurse >= 10 {\n@@ -209,7 +209,11 @@ pub fn get_real_types(\n                                 if !adds.is_empty() {\n                                     res.extend(adds);\n                                 } else if !ty.is_full_generic() {\n-                                    res.insert(ty);\n+                                    if let Some(did) = ty.def_id() {\n+                                        if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                                            res.insert((ty, kind));\n+                                        }\n+                                    }\n                                 }\n                             }\n                         }\n@@ -225,22 +229,32 @@ pub fn get_real_types(\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     } else if !ty.is_full_generic() {\n-                        res.insert(ty.clone());\n+                        if let Some(did) = ty.def_id() {\n+                            if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                                res.insert((ty.clone(), kind));\n+                            }\n+                        }\n                     }\n                 }\n             }\n         }\n     } else {\n-        res.insert(arg.clone());\n+        if let Some(did) = arg.def_id() {\n+            if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                res.insert((arg.clone(), kind));\n+            }\n+        }\n         if let Some(gens) = arg.generics() {\n             for gen in gens.iter() {\n                 if gen.is_full_generic() {\n                     let adds = get_real_types(generics, gen, cx, recurse + 1);\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     }\n-                } else {\n-                    res.insert(gen.clone());\n+                } else if let Some(did) = gen.def_id() {\n+                    if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                        res.insert((gen.clone(), kind));\n+                    }\n                 }\n             }\n         }\n@@ -256,7 +270,7 @@ pub fn get_all_types(\n     generics: &Generics,\n     decl: &FnDecl,\n     cx: &DocContext<'_>,\n-) -> (Vec<Type>, Vec<Type>) {\n+) -> (Vec<(Type, TypeKind)>, Vec<(Type, TypeKind)>) {\n     let mut all_types = FxHashSet::default();\n     for arg in decl.inputs.values.iter() {\n         if arg.type_.is_self_type() {\n@@ -266,15 +280,23 @@ pub fn get_all_types(\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n-            all_types.insert(arg.type_.clone());\n+            if let Some(did) = arg.type_.def_id() {\n+                if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                    all_types.insert((arg.type_.clone(), kind));\n+                }\n+            }\n         }\n     }\n \n     let ret_types = match decl.output {\n         FnRetTy::Return(ref return_type) => {\n             let mut ret = get_real_types(generics, &return_type, cx, 0);\n             if ret.is_empty() {\n-                ret.insert(return_type.clone());\n+                if let Some(did) = return_type.def_id() {\n+                    if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                        ret.insert((return_type.clone(), kind));\n+                    }\n+                }\n             }\n             ret.into_iter().collect()\n         }"}, {"sha": "8d60e087e048f6a8e3ec1dfb991cf4635671a99c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b9167e6c7d09cdb31026c10954bb35d061308a63", "patch": "@@ -58,7 +58,7 @@ use rustc_span::symbol::{sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n-use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy};\n+use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, TypeKind};\n use crate::config::{OutputFormat, RenderOptions};\n use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n@@ -303,8 +303,10 @@ impl Serialize for IndexItem {\n /// A type used for the search index.\n #[derive(Debug)]\n struct Type {\n+    ty: Option<DefId>,\n+    idx: Option<usize>,\n     name: Option<String>,\n-    generics: Option<Vec<String>>,\n+    generics: Option<Vec<Generic>>,\n }\n \n impl Serialize for Type {\n@@ -314,7 +316,11 @@ impl Serialize for Type {\n     {\n         if let Some(name) = &self.name {\n             let mut seq = serializer.serialize_seq(None)?;\n-            seq.serialize_element(&name)?;\n+            if let Some(id) = self.idx {\n+                seq.serialize_element(&id)?;\n+            } else {\n+                seq.serialize_element(&name)?;\n+            }\n             if let Some(generics) = &self.generics {\n                 seq.serialize_element(&generics)?;\n             }\n@@ -325,11 +331,32 @@ impl Serialize for Type {\n     }\n }\n \n+/// A type used for the search index.\n+#[derive(Debug)]\n+struct Generic {\n+    name: String,\n+    defid: Option<DefId>,\n+    idx: Option<usize>,\n+}\n+\n+impl Serialize for Generic {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        if let Some(id) = self.idx {\n+            serializer.serialize_some(&id)\n+        } else {\n+            serializer.serialize_some(&self.name)\n+        }\n+    }\n+}\n+\n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n struct IndexItemFunctionType {\n-    inputs: Vec<Type>,\n-    output: Option<Vec<Type>>,\n+    inputs: Vec<TypeWithKind>,\n+    output: Option<Vec<TypeWithKind>>,\n }\n \n impl Serialize for IndexItemFunctionType {\n@@ -340,8 +367,8 @@ impl Serialize for IndexItemFunctionType {\n         // If we couldn't figure out a type, just write `null`.\n         let mut iter = self.inputs.iter();\n         if match self.output {\n-            Some(ref output) => iter.chain(output.iter()).any(|ref i| i.name.is_none()),\n-            None => iter.any(|ref i| i.name.is_none()),\n+            Some(ref output) => iter.chain(output.iter()).any(|ref i| i.ty.name.is_none()),\n+            None => iter.any(|ref i| i.ty.name.is_none()),\n         } {\n             serializer.serialize_none()\n         } else {\n@@ -359,6 +386,34 @@ impl Serialize for IndexItemFunctionType {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct TypeWithKind {\n+    ty: Type,\n+    kind: TypeKind,\n+}\n+\n+impl From<(Type, TypeKind)> for TypeWithKind {\n+    fn from(x: (Type, TypeKind)) -> TypeWithKind {\n+        TypeWithKind {\n+            ty: x.0,\n+            kind: x.1,\n+        }\n+    }\n+}\n+\n+impl Serialize for TypeWithKind {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let mut seq = serializer.serialize_seq(None)?;\n+        seq.serialize_element(&self.ty.name)?;\n+        let x: ItemType = self.kind.into();\n+        seq.serialize_element(&x)?;\n+        seq.end()\n+    }\n+}\n+\n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n "}, {"sha": "746146c50847978ab5f4f92b3e23a198d1b6fadd", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=b9167e6c7d09cdb31026c10954bb35d061308a63", "patch": "@@ -12,7 +12,7 @@ use std::path::{Path, PathBuf};\n use serde::Serialize;\n \n use super::{plain_summary_line, shorten, Impl, IndexItem, IndexItemFunctionType, ItemType};\n-use super::{RenderInfo, Type};\n+use super::{Generic, RenderInfo, Type, TypeWithKind};\n \n /// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n@@ -588,19 +588,22 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut lastpathid = 0usize;\n \n     for item in search_index {\n-        item.parent_idx = item.parent.map(|defid| {\n-            if defid_to_pathid.contains_key(&defid) {\n-                *defid_to_pathid.get(&defid).expect(\"no pathid\")\n-            } else {\n-                let pathid = lastpathid;\n-                defid_to_pathid.insert(defid, pathid);\n-                lastpathid += 1;\n+        item.parent_idx = item.parent.and_then(|defid| {\n+        if defid_to_pathid.contains_key(&defid) {\n+            defid_to_pathid.get(&defid).map(|x| *x)\n+        } else {\n+            let pathid = lastpathid;\n+            defid_to_pathid.insert(defid, pathid);\n+            lastpathid += 1;\n \n-                let &(ref fqp, short) = paths.get(&defid).unwrap();\n+            if let Some(&(ref fqp, short)) = paths.get(&defid) {\n                 crate_paths.push((short, fqp.last().unwrap().clone()));\n-                pathid\n+                Some(pathid)\n+            } else {\n+                None\n             }\n-        });\n+        }\n+    });\n \n         // Omit the parent path if it is same to that of the prior item.\n         if lastpath == item.path {\n@@ -647,12 +650,15 @@ fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n         _ => return None,\n     };\n \n-    let inputs =\n-        all_types.iter().map(|arg| get_index_type(&arg)).filter(|a| a.name.is_some()).collect();\n+    let inputs = all_types\n+        .iter()\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty), *kind)))\n+        .filter(|a| a.ty.name.is_some())\n+        .collect();\n     let output = ret_types\n         .iter()\n-        .map(|arg| get_index_type(&arg))\n-        .filter(|a| a.name.is_some())\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty), *kind)))\n+        .filter(|a| a.ty.name.is_some())\n         .collect::<Vec<_>>();\n     let output = if output.is_empty() { None } else { Some(output) };\n \n@@ -661,6 +667,8 @@ fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n \n fn get_index_type(clean_type: &clean::Type) -> Type {\n     let t = Type {\n+        ty: clean_type.def_id(),\n+        idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n         generics: get_generics(clean_type),\n     };\n@@ -685,12 +693,15 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n     }\n }\n \n-fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n+fn get_generics(clean_type: &clean::Type) -> Option<Vec<Generic>> {\n     clean_type.generics().and_then(|types| {\n         let r = types\n             .iter()\n-            .filter_map(|t| get_index_type_name(t, false))\n-            .map(|s| s.to_ascii_lowercase())\n+            .filter_map(|t| if let Some(name) = get_index_type_name(t, false) {\n+                Some(Generic { name: name.to_ascii_lowercase(), defid: t.def_id(), idx: None })\n+            } else {\n+                None\n+            })\n             .collect::<Vec<_>>();\n         if r.is_empty() { None } else { Some(r) }\n     })"}, {"sha": "c936be1cfb35b43800acb9ae08aeb4a0343ed4a3", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=b9167e6c7d09cdb31026c10954bb35d061308a63", "patch": "@@ -523,13 +523,14 @@ function getSearchElement() {\n     }\n \n     function initSearch(rawSearchIndex) {\n-        var currentResults, index, searchIndex;\n         var MAX_LEV_DISTANCE = 3;\n         var MAX_RESULTS = 200;\n         var GENERICS_DATA = 1;\n         var NAME = 0;\n         var INPUTS_DATA = 0;\n         var OUTPUT_DATA = 1;\n+        var NO_TYPE_FILTER = -1;\n+        var currentResults, index, searchIndex;\n         var params = getQueryStringParams();\n \n         // Populate search bar with query string search term when provided,\n@@ -556,7 +557,7 @@ function getSearchElement() {\n                         return i;\n                     }\n                 }\n-                return -1;\n+                return NO_TYPE_FILTER;\n             }\n \n             var valLower = query.query.toLowerCase(),\n@@ -719,6 +720,13 @@ function getSearchElement() {\n                 };\n             }\n \n+            function getObjectFromId(id) {\n+                if (typeof id === \"number\") {\n+                    return searchIndex[id];\n+                }\n+                return {'name': id};\n+            }\n+\n             function checkGenerics(obj, val) {\n                 // The names match, but we need to be sure that all generics kinda\n                 // match as well.\n@@ -735,8 +743,10 @@ function getSearchElement() {\n                         for (var y = 0; y < vlength; ++y) {\n                             var lev = { pos: -1, lev: MAX_LEV_DISTANCE + 1};\n                             var elength = elems.length;\n+                            var firstGeneric = getObjectFromId(val.generics[y]).name;\n                             for (var x = 0; x < elength; ++x) {\n-                                var tmp_lev = levenshtein(elems[x], val.generics[y]);\n+                                var tmp_lev = levenshtein(getObjectFromId(elems[x]).name,\n+                                                          firstGeneric);\n                                 if (tmp_lev < lev.lev) {\n                                     lev.lev = tmp_lev;\n                                     lev.pos = x;\n@@ -771,8 +781,9 @@ function getSearchElement() {\n \n                                 for (var y = 0; allFound === true && y < val.generics.length; ++y) {\n                                     allFound = false;\n+                                    var firstGeneric = getObjectFromId(val.generics[y]).name;\n                                     for (x = 0; allFound === false && x < elems.length; ++x) {\n-                                        allFound = elems[x] === val.generics[y];\n+                                        allFound = getObjectFromId(elems[x]).name === firstGeneric;\n                                     }\n                                     if (allFound === true) {\n                                         elems.splice(x - 1, 1);\n@@ -829,16 +840,23 @@ function getSearchElement() {\n                 return lev_distance + 1;\n             }\n \n-            function findArg(obj, val, literalSearch) {\n+            function findArg(obj, val, literalSearch, typeFilter) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n-                if (obj && obj.type && obj.type[INPUTS_DATA] &&\n-                      obj.type[INPUTS_DATA].length > 0) {\n+                if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n                     var length = obj.type[INPUTS_DATA].length;\n                     for (var i = 0; i < length; i++) {\n-                        var tmp = checkType(obj.type[INPUTS_DATA][i], val, literalSearch);\n-                        if (literalSearch === true && tmp === true) {\n-                            return true;\n+                        var tmp = obj.type[INPUTS_DATA][i];\n+                        if (typePassesFilter(typeFilter, tmp[1]) === false) {\n+                            continue;\n+                        }\n+                        tmp[0] = tmp[NAME];\n+                        var tmp = checkType(tmp, val, literalSearch);\n+                        if (literalSearch === true) {\n+                            if (tmp === true) {\n+                                return true;\n+                            }\n+                            continue;\n                         }\n                         lev_distance = Math.min(tmp, lev_distance);\n                         if (lev_distance === 0) {\n@@ -849,19 +867,20 @@ function getSearchElement() {\n                 return literalSearch === true ? false : lev_distance;\n             }\n \n-            function checkReturned(obj, val, literalSearch) {\n+            function checkReturned(obj, val, literalSearch, typeFilter) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n                 if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n                     var ret = obj.type[OUTPUT_DATA];\n-                    if (!obj.type[OUTPUT_DATA].length) {\n+                    if (typeof ret[0] === \"string\") {\n                         ret = [ret];\n                     }\n                     for (var x = 0; x < ret.length; ++x) {\n                         var r = ret[x];\n-                        if (typeof r === \"string\") {\n-                            r = [r];\n+                        if (typePassesFilter(typeFilter, r[1]) === false) {\n+                            continue;\n                         }\n+                        r[0] = r[NAME];\n                         var tmp = checkType(r, val, literalSearch);\n                         if (literalSearch === true) {\n                             if (tmp === true) {\n@@ -917,7 +936,7 @@ function getSearchElement() {\n \n             function typePassesFilter(filter, type) {\n                 // No filter\n-                if (filter < 0) return true;\n+                if (filter <= NO_TYPE_FILTER) return true;\n \n                 // Exact match\n                 if (filter === type) return true;\n@@ -926,11 +945,13 @@ function getSearchElement() {\n                 var name = itemTypes[type];\n                 switch (itemTypes[filter]) {\n                     case \"constant\":\n-                        return (name == \"associatedconstant\");\n+                        return name === \"associatedconstant\";\n                     case \"fn\":\n-                        return (name == \"method\" || name == \"tymethod\");\n+                        return name === \"method\" || name === \"tymethod\";\n                     case \"type\":\n-                        return (name == \"primitive\" || name == \"keyword\");\n+                        return name === \"primitive\" || name === \"associatedtype\";\n+                    case \"trait\":\n+                        return name === \"traitalias\";\n                 }\n \n                 // No match\n@@ -959,42 +980,33 @@ function getSearchElement() {\n                     if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n                         continue;\n                     }\n-                    in_args = findArg(searchIndex[i], val, true);\n-                    returned = checkReturned(searchIndex[i], val, true);\n+                    in_args = findArg(searchIndex[i], val, true, typeFilter);\n+                    returned = checkReturned(searchIndex[i], val, true, typeFilter);\n                     ty = searchIndex[i];\n                     fullId = generateId(ty);\n \n-                    if (searchWords[i] === val.name) {\n-                        // filter type: ... queries\n-                        if (typePassesFilter(typeFilter, searchIndex[i].ty) &&\n-                            results[fullId] === undefined)\n-                        {\n-                            results[fullId] = {id: i, index: -1};\n-                        }\n-                    } else if ((in_args === true || returned === true) &&\n-                               typePassesFilter(typeFilter, searchIndex[i].ty)) {\n-                        if (in_args === true || returned === true) {\n-                            if (in_args === true) {\n-                                results_in_args[fullId] = {\n-                                    id: i,\n-                                    index: -1,\n-                                    dontValidate: true,\n-                                };\n-                            }\n-                            if (returned === true) {\n-                                results_returned[fullId] = {\n-                                    id: i,\n-                                    index: -1,\n-                                    dontValidate: true,\n-                                };\n-                            }\n-                        } else {\n-                            results[fullId] = {\n-                                id: i,\n-                                index: -1,\n-                                dontValidate: true,\n-                            };\n-                        }\n+                    if (searchWords[i] === val.name\n+                        && typePassesFilter(typeFilter, searchIndex[i].ty)\n+                        && results[fullId] === undefined) {\n+                        results[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                    if (in_args === true && results_in_args[fullId] === undefined) {\n+                        results_in_args[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                    if (returned === true && results_returned[fullId] === undefined) {\n+                        results_returned[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n                     }\n                 }\n                 query.inputs = [val];\n@@ -1025,7 +1037,7 @@ function getSearchElement() {\n \n                     // allow searching for void (no output) functions as well\n                     var typeOutput = type.length > OUTPUT_DATA ? type[OUTPUT_DATA].name : \"\";\n-                    returned = checkReturned(ty, output, true);\n+                    returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n                     if (output.name === \"*\" || returned === true) {\n                         in_args = false;\n                         var is_module = false;\n@@ -1126,16 +1138,8 @@ function getSearchElement() {\n                             lev += 1;\n                         }\n                     }\n-                    if ((in_args = findArg(ty, valGenerics)) <= MAX_LEV_DISTANCE) {\n-                        if (typePassesFilter(typeFilter, ty.ty) === false) {\n-                            in_args = MAX_LEV_DISTANCE + 1;\n-                        }\n-                    }\n-                    if ((returned = checkReturned(ty, valGenerics)) <= MAX_LEV_DISTANCE) {\n-                        if (typePassesFilter(typeFilter, ty.ty) === false) {\n-                            returned = MAX_LEV_DISTANCE + 1;\n-                        }\n-                    }\n+                    in_args = findArg(ty, valGenerics, false, typeFilter);\n+                    returned = checkReturned(ty, valGenerics, false, typeFilter);\n \n                     lev += lev_add;\n                     if (lev > 0 && val.length > 3 && searchWords[j].indexOf(val) > -1) {"}, {"sha": "6cdeefd10caa87bac3dde2f6ff1f80721acdaa58", "filename": "src/test/rustdoc-js-std/return-specific.js", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Ftest%2Frustdoc-js-std%2Freturn-specific.js", "raw_url": "https://github.com/rust-lang/rust/raw/b9167e6c7d09cdb31026c10954bb35d061308a63/src%2Ftest%2Frustdoc-js-std%2Freturn-specific.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Freturn-specific.js?ref=b9167e6c7d09cdb31026c10954bb35d061308a63", "patch": "@@ -0,0 +1,7 @@\n+const QUERY = 'struct:chunksmut';\n+\n+const EXPECTED = {\n+    'returned': [\n+        { 'path': 'std::slice::chunks_mut', 'name': 'chunks_mut' },\n+    ],\n+};"}]}