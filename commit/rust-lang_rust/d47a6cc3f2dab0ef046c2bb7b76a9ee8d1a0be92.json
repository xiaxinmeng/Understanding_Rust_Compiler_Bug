{"sha": "d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "node_id": "C_kwDOAAsO6NoAKGQ0N2E2Y2MzZjJkYWIwZWYwNDZjMmJiN2I3NmE5ZWU4ZDFhMGJlOTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-03T10:15:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-03T10:15:11Z"}, "message": "Auto merge of #91286 - scottmcm:residual-trait, r=joshtriplett\n\nMake `array::{try_from_fn, try_map}` and `Iterator::try_find` generic over `Try`\n\nFixes #85115\n\nThis only updates unstable functions.\n\n`array::try_map` didn't actually exist before; this adds it under the still-open tracking issue #79711 from the old PR #79713.\n\nTracking issue for the new trait: #91285\n\nThis would also solve the return type question in for the proposed `Iterator::try_reduce` in #87054", "tree": {"sha": "6e087744037bb59f590b0a8707e2877d2e1e19dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e087744037bb59f590b0a8707e2877d2e1e19dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "html_url": "https://github.com/rust-lang/rust/commit/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e21768a0a3fc84befd1cbe825ae6849e9941b73", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e21768a0a3fc84befd1cbe825ae6849e9941b73", "html_url": "https://github.com/rust-lang/rust/commit/3e21768a0a3fc84befd1cbe825ae6849e9941b73"}, {"sha": "b96b9b409309bc84807f37643c90f76de4bfb0d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b96b9b409309bc84807f37643c90f76de4bfb0d5", "html_url": "https://github.com/rust-lang/rust/commit/b96b9b409309bc84807f37643c90f76de4bfb0d5"}], "stats": {"total": 240, "additions": 195, "deletions": 45}, "files": [{"sha": "d635829151e4db299bcced797b01220347c9bd33", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 84, "deletions": 32, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "patch": "@@ -11,7 +11,9 @@ use crate::fmt;\n use crate::hash::{self, Hash};\n use crate::iter::TrustedLen;\n use crate::mem::{self, MaybeUninit};\n-use crate::ops::{Index, IndexMut};\n+use crate::ops::{\n+    ChangeOutputType, ControlFlow, FromResidual, Index, IndexMut, NeverShortCircuit, Residual, Try,\n+};\n use crate::slice::{Iter, IterMut};\n \n mod equality;\n@@ -49,9 +51,13 @@ where\n }\n \n /// Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.\n-/// Unlike `core::array::from_fn`, where the element creation can't fail, this version will return an error\n+/// Unlike [`from_fn`], where the element creation can't fail, this version will return an error\n /// if any element creation was unsuccessful.\n ///\n+/// The return type of this function depends on the return type of the closure.\n+/// If you return `Result<T, E>` from the closure, you'll get a `Result<[T; N]; E>`.\n+/// If you return `Option<T>` from the closure, you'll get an `Option<[T; N]>`.\n+///\n /// # Arguments\n ///\n /// * `cb`: Callback where the passed argument is the current array index.\n@@ -60,27 +66,32 @@ where\n ///\n /// ```rust\n /// #![feature(array_from_fn)]\n+/// # // Apparently these doc tests are still on edition2018\n+/// # use std::convert::TryInto;\n ///\n-/// #[derive(Debug, PartialEq)]\n-/// enum SomeError {\n-///     Foo,\n-/// }\n-///\n-/// let array = core::array::try_from_fn(|i| Ok::<_, SomeError>(i));\n+/// let array: Result<[u8; 5], _> = std::array::try_from_fn(|i| i.try_into());\n /// assert_eq!(array, Ok([0, 1, 2, 3, 4]));\n ///\n-/// let another_array = core::array::try_from_fn::<SomeError, _, (), 2>(|_| Err(SomeError::Foo));\n-/// assert_eq!(another_array, Err(SomeError::Foo));\n+/// let array: Result<[i8; 200], _> = std::array::try_from_fn(|i| i.try_into());\n+/// assert!(array.is_err());\n+///\n+/// let array: Option<[_; 4]> = std::array::try_from_fn(|i| i.checked_add(100));\n+/// assert_eq!(array, Some([100, 101, 102, 103]));\n+///\n+/// let array: Option<[_; 4]> = std::array::try_from_fn(|i| i.checked_sub(100));\n+/// assert_eq!(array, None);\n /// ```\n #[inline]\n #[unstable(feature = \"array_from_fn\", issue = \"89379\")]\n-pub fn try_from_fn<E, F, T, const N: usize>(cb: F) -> Result<[T; N], E>\n+pub fn try_from_fn<F, R, const N: usize>(cb: F) -> ChangeOutputType<R, [R::Output; N]>\n where\n-    F: FnMut(usize) -> Result<T, E>,\n+    F: FnMut(usize) -> R,\n+    R: Try,\n+    R::Residual: Residual<[R::Output; N]>,\n {\n     // SAFETY: we know for certain that this iterator will yield exactly `N`\n     // items.\n-    unsafe { collect_into_array_rslt_unchecked(&mut (0..N).map(cb)) }\n+    unsafe { try_collect_into_array_unchecked(&mut (0..N).map(cb)) }\n }\n \n /// Converts a reference to `T` into a reference to an array of length 1 (without copying).\n@@ -444,6 +455,45 @@ impl<T, const N: usize> [T; N] {\n         unsafe { collect_into_array_unchecked(&mut IntoIterator::into_iter(self).map(f)) }\n     }\n \n+    /// A fallible function `f` applied to each element on array `self` in order to\n+    /// return an array the same size as `self` or the first error encountered.\n+    ///\n+    /// The return type of this function depends on the return type of the closure.\n+    /// If you return `Result<T, E>` from the closure, you'll get a `Result<[T; N]; E>`.\n+    /// If you return `Option<T>` from the closure, you'll get an `Option<[T; N]>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_try_map)]\n+    /// let a = [\"1\", \"2\", \"3\"];\n+    /// let b = a.try_map(|v| v.parse::<u32>()).unwrap().map(|v| v + 1);\n+    /// assert_eq!(b, [2, 3, 4]);\n+    ///\n+    /// let a = [\"1\", \"2a\", \"3\"];\n+    /// let b = a.try_map(|v| v.parse::<u32>());\n+    /// assert!(b.is_err());\n+    ///\n+    /// use std::num::NonZeroU32;\n+    /// let z = [1, 2, 0, 3, 4];\n+    /// assert_eq!(z.try_map(NonZeroU32::new), None);\n+    /// let a = [1, 2, 3];\n+    /// let b = a.try_map(NonZeroU32::new);\n+    /// let c = b.map(|x| x.map(NonZeroU32::get));\n+    /// assert_eq!(c, Some(a));\n+    /// ```\n+    #[unstable(feature = \"array_try_map\", issue = \"79711\")]\n+    pub fn try_map<F, R>(self, f: F) -> ChangeOutputType<R, [R::Output; N]>\n+    where\n+        F: FnMut(T) -> R,\n+        R: Try,\n+        R::Residual: Residual<[R::Output; N]>,\n+    {\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { try_collect_into_array_unchecked(&mut IntoIterator::into_iter(self).map(f)) }\n+    }\n+\n     /// 'Zips up' two arrays into a single array of pairs.\n     ///\n     /// `zip()` returns a new array where every element is a tuple where the\n@@ -621,42 +671,42 @@ impl<T, const N: usize> [T; N] {\n /// Pulls `N` items from `iter` and returns them as an array. If the iterator\n /// yields fewer than `N` items, this function exhibits undefined behavior.\n ///\n-/// See [`collect_into_array`] for more information.\n+/// See [`try_collect_into_array`] for more information.\n ///\n ///\n /// # Safety\n ///\n /// It is up to the caller to guarantee that `iter` yields at least `N` items.\n /// Violating this condition causes undefined behavior.\n-unsafe fn collect_into_array_rslt_unchecked<E, I, T, const N: usize>(\n-    iter: &mut I,\n-) -> Result<[T; N], E>\n+unsafe fn try_collect_into_array_unchecked<I, T, R, const N: usize>(iter: &mut I) -> R::TryType\n where\n     // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n     // internal function, so feel free to remove if this bound turns out to be a\n     // bad idea. In that case, remember to also remove the lower bound\n     // `debug_assert!` below!\n-    I: Iterator<Item = Result<T, E>> + TrustedLen,\n+    I: Iterator + TrustedLen,\n+    I::Item: Try<Output = T, Residual = R>,\n+    R: Residual<[T; N]>,\n {\n     debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n     debug_assert!(N <= iter.size_hint().0);\n \n     // SAFETY: covered by the function contract.\n-    unsafe { collect_into_array(iter).unwrap_unchecked() }\n+    unsafe { try_collect_into_array(iter).unwrap_unchecked() }\n }\n \n-// Infallible version of `collect_into_array_rslt_unchecked`.\n+// Infallible version of `try_collect_into_array_unchecked`.\n unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n where\n     I: Iterator + TrustedLen,\n {\n-    let mut map = iter.map(Ok::<_, Infallible>);\n+    let mut map = iter.map(NeverShortCircuit);\n \n     // SAFETY: The same safety considerations w.r.t. the iterator length\n-    // apply for `collect_into_array_rslt_unchecked` as for\n+    // apply for `try_collect_into_array_unchecked` as for\n     // `collect_into_array_unchecked`\n-    match unsafe { collect_into_array_rslt_unchecked(&mut map) } {\n-        Ok(array) => array,\n+    match unsafe { try_collect_into_array_unchecked(&mut map) } {\n+        NeverShortCircuit(array) => array,\n     }\n }\n \n@@ -670,13 +720,15 @@ where\n ///\n /// If `iter.next()` panicks, all items already yielded by the iterator are\n /// dropped.\n-fn collect_into_array<E, I, T, const N: usize>(iter: &mut I) -> Option<Result<[T; N], E>>\n+fn try_collect_into_array<I, T, R, const N: usize>(iter: &mut I) -> Option<R::TryType>\n where\n-    I: Iterator<Item = Result<T, E>>,\n+    I: Iterator,\n+    I::Item: Try<Output = T, Residual = R>,\n+    R: Residual<[T; N]>,\n {\n     if N == 0 {\n         // SAFETY: An empty array is always inhabited and has no validity invariants.\n-        return unsafe { Some(Ok(mem::zeroed())) };\n+        return unsafe { Some(Try::from_output(mem::zeroed())) };\n     }\n \n     struct Guard<'a, T, const N: usize> {\n@@ -701,11 +753,11 @@ where\n     let mut guard = Guard { array_mut: &mut array, initialized: 0 };\n \n     while let Some(item_rslt) = iter.next() {\n-        let item = match item_rslt {\n-            Err(err) => {\n-                return Some(Err(err));\n+        let item = match item_rslt.branch() {\n+            ControlFlow::Break(r) => {\n+                return Some(FromResidual::from_residual(r));\n             }\n-            Ok(elem) => elem,\n+            ControlFlow::Continue(elem) => elem,\n         };\n \n         // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n@@ -723,7 +775,7 @@ where\n             // SAFETY: the condition above asserts that all elements are\n             // initialized.\n             let out = unsafe { MaybeUninit::array_assume_init(array) };\n-            return Some(Ok(out));\n+            return Some(Try::from_output(out));\n         }\n     }\n "}, {"sha": "88e7623eba1ce7fe62df29da4cf4b71e10eab727", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "patch": "@@ -1,5 +1,5 @@\n use crate::cmp::{self, Ordering};\n-use crate::ops::{ControlFlow, Try};\n+use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n \n use super::super::TrustedRandomAccessNoCoerce;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n@@ -2418,6 +2418,10 @@ pub trait Iterator {\n     /// Applies function to the elements of iterator and returns\n     /// the first true result or the first error.\n     ///\n+    /// The return type of this method depends on the return type of the closure.\n+    /// If you return `Result<bool, E>` from the closure, you'll get a `Result<Option<Self::Item>; E>`.\n+    /// If you return `Option<bool>` from the closure, you'll get an `Option<Option<Self::Item>>`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2435,32 +2439,48 @@ pub trait Iterator {\n     /// let result = a.iter().try_find(|&&s| is_my_num(s, 5));\n     /// assert!(result.is_err());\n     /// ```\n+    ///\n+    /// This also supports other types which implement `Try`, not just `Result`.\n+    /// ```\n+    /// #![feature(try_find)]\n+    ///\n+    /// use std::num::NonZeroU32;\n+    /// let a = [3, 5, 7, 4, 9, 0, 11];\n+    /// let result = a.iter().try_find(|&&x| NonZeroU32::new(x).map(|y| y.is_power_of_two()));\n+    /// assert_eq!(result, Some(Some(&4)));\n+    /// let result = a.iter().take(3).try_find(|&&x| NonZeroU32::new(x).map(|y| y.is_power_of_two()));\n+    /// assert_eq!(result, Some(None));\n+    /// let result = a.iter().rev().try_find(|&&x| NonZeroU32::new(x).map(|y| y.is_power_of_two()));\n+    /// assert_eq!(result, None);\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"try_find\", reason = \"new API\", issue = \"63178\")]\n-    fn try_find<F, R, E>(&mut self, f: F) -> Result<Option<Self::Item>, E>\n+    fn try_find<F, R>(&mut self, f: F) -> ChangeOutputType<R, Option<Self::Item>>\n     where\n         Self: Sized,\n         F: FnMut(&Self::Item) -> R,\n         R: Try<Output = bool>,\n-        // FIXME: This bound is rather strange, but means minimal breakage on nightly.\n-        // See #85115 for the issue tracking a holistic solution for this and try_map.\n-        R: Try<Residual = Result<crate::convert::Infallible, E>>,\n+        R::Residual: Residual<Option<Self::Item>>,\n     {\n         #[inline]\n-        fn check<F, T, R, E>(mut f: F) -> impl FnMut((), T) -> ControlFlow<Result<T, E>>\n+        fn check<I, V, R>(\n+            mut f: impl FnMut(&I) -> V,\n+        ) -> impl FnMut((), I) -> ControlFlow<R::TryType>\n         where\n-            F: FnMut(&T) -> R,\n-            R: Try<Output = bool>,\n-            R: Try<Residual = Result<crate::convert::Infallible, E>>,\n+            V: Try<Output = bool, Residual = R>,\n+            R: Residual<Option<I>>,\n         {\n             move |(), x| match f(&x).branch() {\n                 ControlFlow::Continue(false) => ControlFlow::CONTINUE,\n-                ControlFlow::Continue(true) => ControlFlow::Break(Ok(x)),\n-                ControlFlow::Break(Err(x)) => ControlFlow::Break(Err(x)),\n+                ControlFlow::Continue(true) => ControlFlow::Break(Try::from_output(Some(x))),\n+                ControlFlow::Break(r) => ControlFlow::Break(FromResidual::from_residual(r)),\n             }\n         }\n \n-        self.try_fold((), check(f)).break_value().transpose()\n+        match self.try_fold((), check(f)) {\n+            ControlFlow::Break(x) => x,\n+            ControlFlow::Continue(()) => Try::from_output(None),\n+        }\n     }\n \n     /// Searches for an element in an iterator, returning its index."}, {"sha": "5ee8e377de1cdfa30a8b5d7e56f847d7fa0d8e26", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "patch": "@@ -123,6 +123,11 @@ impl<B, C> ops::FromResidual for ControlFlow<B, C> {\n     }\n }\n \n+#[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n+impl<B, C> ops::Residual<C> for ControlFlow<B, convert::Infallible> {\n+    type TryType = ControlFlow<B, C>;\n+}\n+\n impl<B, C> ControlFlow<B, C> {\n     /// Returns `true` if this is a `Break` variant.\n     ///"}, {"sha": "9d1e7e81b0e7e853eee1b44642e4b49af9957b57", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "patch": "@@ -187,6 +187,11 @@ pub use self::range::OneSidedRange;\n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n pub use self::try_trait::{FromResidual, Try};\n \n+#[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n+pub use self::try_trait::Residual;\n+\n+pub(crate) use self::try_trait::{ChangeOutputType, NeverShortCircuit};\n+\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub use self::generator::{Generator, GeneratorState};\n "}, {"sha": "f4f0a5898097ff305b44eea5a1aefe39a3bb03b5", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "patch": "@@ -338,3 +338,61 @@ pub trait FromResidual<R = <Self as Try>::Residual> {\n     #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n     fn from_residual(residual: R) -> Self;\n }\n+\n+/// Allows retrieving the canonical type implementing [`Try`] that has this type\n+/// as its residual and allows it to hold an `O` as its output.\n+///\n+/// If you think of the `Try` trait as splitting a type into its [`Try::Output`]\n+/// and [`Try::Residual`] components, this allows putting them back together.\n+///\n+/// For example,\n+/// `Result<T, E>: Try<Output = T, Residual = Result<Infallible, E>>`,\n+/// and in the other direction,\n+/// `<Result<Infallible, E> as Residual<T>>::TryType = Result<T, E>`.\n+#[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n+pub trait Residual<O> {\n+    /// The \"return\" type of this meta-function.\n+    #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n+    type TryType: Try<Output = O, Residual = Self>;\n+}\n+\n+#[unstable(feature = \"pub_crate_should_not_need_unstable_attr\", issue = \"none\")]\n+pub(crate) type ChangeOutputType<T, V> = <<T as Try>::Residual as Residual<V>>::TryType;\n+\n+/// An adapter for implementing non-try methods via the `Try` implementation.\n+///\n+/// Conceptually the same as `Result<T, !>`, but requiring less work in trait\n+/// solving and inhabited-ness checking and such, by being an obvious newtype\n+/// and not having `From` bounds lying around.\n+///\n+/// Not currently planned to be exposed publicly, so just `pub(crate)`.\n+#[repr(transparent)]\n+pub(crate) struct NeverShortCircuit<T>(pub T);\n+\n+pub(crate) enum NeverShortCircuitResidual {}\n+\n+impl<T> Try for NeverShortCircuit<T> {\n+    type Output = T;\n+    type Residual = NeverShortCircuitResidual;\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<NeverShortCircuitResidual, T> {\n+        ControlFlow::Continue(self.0)\n+    }\n+\n+    #[inline]\n+    fn from_output(x: T) -> Self {\n+        NeverShortCircuit(x)\n+    }\n+}\n+\n+impl<T> FromResidual for NeverShortCircuit<T> {\n+    #[inline]\n+    fn from_residual(never: NeverShortCircuitResidual) -> Self {\n+        match never {}\n+    }\n+}\n+\n+impl<T> Residual<T> for NeverShortCircuitResidual {\n+    type TryType = NeverShortCircuit<T>;\n+}"}, {"sha": "7b9c6e43960f7b61a2e15931dd090ac1a2656ecb", "filename": "library/core/src/option.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "patch": "@@ -2089,6 +2089,11 @@ impl<T> const ops::FromResidual for Option<T> {\n     }\n }\n \n+#[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n+impl<T> ops::Residual<T> for Option<convert::Infallible> {\n+    type TryType = Option<T>;\n+}\n+\n impl<T> Option<Option<T>> {\n     /// Converts from `Option<Option<T>>` to `Option<T>`.\n     ///"}, {"sha": "e6b8c8ec3385a09077f2f743e975ec1d63d63558", "filename": "library/core/src/result.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "patch": "@@ -1959,3 +1959,8 @@ impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Res\n         }\n     }\n }\n+\n+#[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n+impl<T, E> ops::Residual<T> for Result<convert::Infallible, E> {\n+    type TryType = Result<T, E>;\n+}"}, {"sha": "43d30d12355eb491166d4ce7431df6590b15fbb5", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=d47a6cc3f2dab0ef046c2bb7b76a9ee8d1a0be92", "patch": "@@ -377,7 +377,7 @@ fn array_try_from_fn() {\n     let array = core::array::try_from_fn(|i| Ok::<_, SomeError>(i));\n     assert_eq!(array, Ok([0, 1, 2, 3, 4]));\n \n-    let another_array = core::array::try_from_fn::<SomeError, _, (), 2>(|_| Err(SomeError::Foo));\n+    let another_array = core::array::try_from_fn::<_, Result<(), _>, 2>(|_| Err(SomeError::Foo));\n     assert_eq!(another_array, Err(SomeError::Foo));\n }\n "}]}