{"sha": "3c6787306d6b7a45e3b76f18ce543be700fb3c00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNjc4NzMwNmQ2YjdhNDVlM2I3NmYxOGNlNTQzYmU3MDBmYjNjMDA=", "commit": {"author": {"name": "Hirokazu Hata", "email": "h.hata.ai.t@gmail.com", "date": "2019-02-03T23:22:30Z"}, "committer": {"name": "Hirokazu Hata", "email": "h.hata.ai.t@gmail.com", "date": "2019-02-03T23:22:30Z"}, "message": "Excute rustfmt for fixing tidy check", "tree": {"sha": "208a33b070660d29a447bcfa89bf7ea3462bb40e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/208a33b070660d29a447bcfa89bf7ea3462bb40e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c6787306d6b7a45e3b76f18ce543be700fb3c00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6787306d6b7a45e3b76f18ce543be700fb3c00", "html_url": "https://github.com/rust-lang/rust/commit/3c6787306d6b7a45e3b76f18ce543be700fb3c00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c6787306d6b7a45e3b76f18ce543be700fb3c00/comments", "author": {"login": "h-michael", "id": 4556097, "node_id": "MDQ6VXNlcjQ1NTYwOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4556097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/h-michael", "html_url": "https://github.com/h-michael", "followers_url": "https://api.github.com/users/h-michael/followers", "following_url": "https://api.github.com/users/h-michael/following{/other_user}", "gists_url": "https://api.github.com/users/h-michael/gists{/gist_id}", "starred_url": "https://api.github.com/users/h-michael/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/h-michael/subscriptions", "organizations_url": "https://api.github.com/users/h-michael/orgs", "repos_url": "https://api.github.com/users/h-michael/repos", "events_url": "https://api.github.com/users/h-michael/events{/privacy}", "received_events_url": "https://api.github.com/users/h-michael/received_events", "type": "User", "site_admin": false}, "committer": {"login": "h-michael", "id": 4556097, "node_id": "MDQ6VXNlcjQ1NTYwOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/4556097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/h-michael", "html_url": "https://github.com/h-michael", "followers_url": "https://api.github.com/users/h-michael/followers", "following_url": "https://api.github.com/users/h-michael/following{/other_user}", "gists_url": "https://api.github.com/users/h-michael/gists{/gist_id}", "starred_url": "https://api.github.com/users/h-michael/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/h-michael/subscriptions", "organizations_url": "https://api.github.com/users/h-michael/orgs", "repos_url": "https://api.github.com/users/h-michael/repos", "events_url": "https://api.github.com/users/h-michael/events{/privacy}", "received_events_url": "https://api.github.com/users/h-michael/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ae8abab9369357a0e5cabd66673ad3d4af307b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae8abab9369357a0e5cabd66673ad3d4af307b1", "html_url": "https://github.com/rust-lang/rust/commit/4ae8abab9369357a0e5cabd66673ad3d4af307b1"}], "stats": {"total": 141, "additions": 86, "deletions": 55}, "files": [{"sha": "cced66f4a22bdc0ae7970c6728005ae4e8be916f", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 86, "deletions": 55, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/3c6787306d6b7a45e3b76f18ce543be700fb3c00/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6787306d6b7a45e3b76f18ce543be700fb3c00/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3c6787306d6b7a45e3b76f18ce543be700fb3c00", "patch": "@@ -20,9 +20,12 @@\n #![deny(rust_2018_idioms)]\n #![crate_name = \"test\"]\n #![unstable(feature = \"test\", issue = \"27812\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n+#![doc(\n+    html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+    html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+    test(attr(deny(warnings)))\n+)]\n #![feature(asm)]\n #![feature(fnbox)]\n #![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc, rustc_private))]\n@@ -47,52 +50,57 @@ use term;\n #[cfg(not(all(windows, target_arch = \"aarch64\")))]\n extern crate panic_unwind;\n \n-pub use self::TestFn::*;\n pub use self::ColorConfig::*;\n-pub use self::TestResult::*;\n-pub use self::TestName::*;\n-use self::TestEvent::*;\n use self::NamePadding::*;\n use self::OutputLocation::*;\n+use self::TestEvent::*;\n+pub use self::TestFn::*;\n+pub use self::TestName::*;\n+pub use self::TestResult::*;\n \n-use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::any::Any;\n+use std::borrow::Cow;\n use std::boxed::FnBox;\n use std::cmp;\n use std::collections::BTreeMap;\n use std::env;\n use std::fmt;\n use std::fs::File;\n-use std::io::prelude::*;\n use std::io;\n+use std::io::prelude::*;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::path::PathBuf;\n+use std::process;\n use std::process::Termination;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n use std::time::{Duration, Instant};\n-use std::borrow::Cow;\n-use std::process;\n \n const TEST_WARN_TIMEOUT_S: u64 = 60;\n const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n \n // to be used by rustc to compile tests in libtest\n pub mod test {\n-    pub use crate::{assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n-             StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n-             TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk};\n+    pub use crate::{\n+        assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n+        Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n+        StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName, TestOpts,\n+        TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n+    };\n }\n \n-pub mod stats;\n mod formatters;\n+pub mod stats;\n \n use crate::formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n \n /// Whether to execute tests concurrently or not\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Concurrent { Yes, No }\n+pub enum Concurrent {\n+    Yes,\n+    No,\n+}\n \n // The name of a test. By convention this follows the rules for rust\n // paths; i.e., it should be a series of identifiers separated by double\n@@ -330,8 +338,7 @@ pub fn test_main_static(tests: &[&TestDescAndFn]) {\n pub fn assert_test_result<T: Termination>(result: T) {\n     let code = result.report();\n     assert_eq!(\n-        code,\n-        0,\n+        code, 0,\n         \"the test returned a termination value with a non-zero status code ({}) \\\n          which indicates a failure\",\n         code\n@@ -559,14 +566,16 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let include_ignored = matches.opt_present(\"include-ignored\");\n     if !allow_unstable && include_ignored {\n         return Some(Err(\n-            \"The \\\"include-ignored\\\" flag is only accepted on the nightly compiler\".into()\n+            \"The \\\"include-ignored\\\" flag is only accepted on the nightly compiler\".into(),\n         ));\n     }\n \n     let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n-        (true, true) => return Some(Err(\n-            \"the options --include-ignored and --ignored are mutually exclusive\".into()\n-        )),\n+        (true, true) => {\n+            return Some(Err(\n+                \"the options --include-ignored and --ignored are mutually exclusive\".into(),\n+            ));\n+        }\n         (true, false) => RunIgnored::Yes,\n         (false, true) => RunIgnored::Only,\n         (false, false) => RunIgnored::No,\n@@ -598,7 +607,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n                     \"argument for --test-threads must be a number > 0 \\\n                      (error: {})\",\n                     e\n-                )))\n+                )));\n             }\n         },\n         None => None,\n@@ -614,7 +623,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n                 \"argument for --color must be auto, always, or never (was \\\n                  {})\",\n                 v\n-            )))\n+            )));\n         }\n     };\n \n@@ -636,7 +645,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n                 \"argument for --format must be pretty, terse, or json (was \\\n                  {})\",\n                 v\n-            )))\n+            )));\n         }\n     };\n \n@@ -1013,10 +1022,12 @@ fn use_color(opts: &TestOpts) -> bool {\n     }\n }\n \n-#[cfg(any(target_os = \"cloudabi\",\n-          target_os = \"redox\",\n-          all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-          all(target_vendor = \"fortanix\", target_env = \"sgx\")))]\n+#[cfg(any(\n+    target_os = \"cloudabi\",\n+    target_os = \"redox\",\n+    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+    all(target_vendor = \"fortanix\", target_env = \"sgx\")\n+))]\n fn stdout_isatty() -> bool {\n     // FIXME: Implement isatty on Redox and SGX\n     false\n@@ -1247,21 +1258,34 @@ fn get_concurrency() -> usize {\n         1\n     }\n \n-    #[cfg(any(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-              all(target_vendor = \"fortanix\", target_env = \"sgx\")))]\n+    #[cfg(any(\n+        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\")\n+    ))]\n     fn num_cpus() -> usize {\n         1\n     }\n \n-    #[cfg(any(target_os = \"android\", target_os = \"cloudabi\", target_os = \"emscripten\",\n-              target_os = \"fuchsia\", target_os = \"ios\", target_os = \"linux\",\n-              target_os = \"macos\", target_os = \"solaris\"))]\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"cloudabi\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"solaris\"\n+    ))]\n     fn num_cpus() -> usize {\n         unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n     }\n \n-    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"bitrig\",\n-              target_os = \"netbsd\"))]\n+    #[cfg(any(\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"bitrig\",\n+        target_os = \"netbsd\"\n+    ))]\n     fn num_cpus() -> usize {\n         use std::ptr;\n \n@@ -1344,18 +1368,20 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     }\n \n     // Skip tests that match any of the skip filters\n-    filtered.retain(|test| {\n-        !opts.skip.iter().any(|sf| matches_filter(test, sf))\n-    });\n+    filtered.retain(|test| !opts.skip.iter().any(|sf| matches_filter(test, sf)));\n \n     // maybe unignore tests\n     match opts.run_ignored {\n         RunIgnored::Yes => {\n-            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n-        },\n+            filtered\n+                .iter_mut()\n+                .for_each(|test| test.desc.ignore = false);\n+        }\n         RunIgnored::Only => {\n             filtered.retain(|test| test.desc.ignore);\n-            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n+            filtered\n+                .iter_mut()\n+                .for_each(|test| test.desc.ignore = false);\n         }\n         RunIgnored::No => {}\n     }\n@@ -1397,7 +1423,8 @@ pub fn run_test(\n ) {\n     let TestDescAndFn { desc, testfn } = test;\n \n-    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\") && !cfg!(target_os = \"emscripten\")\n+    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\")\n+        && !cfg!(target_os = \"emscripten\")\n         && desc.should_panic != ShouldPanic::No;\n \n     if force_ignore || desc.ignore || ignore_because_panic_abort {\n@@ -1488,7 +1515,8 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<dyn Any + Send>>) ->\n     match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n-            if err.downcast_ref::<String>()\n+            if err\n+                .downcast_ref::<String>()\n                 .map(|e| &**e)\n                 .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n                 .map(|e| e.contains(msg))\n@@ -1535,7 +1563,8 @@ impl MetricMap {\n     }\n \n     pub fn fmt_metrics(&self) -> String {\n-        let v = self.0\n+        let v = self\n+            .0\n             .iter()\n             .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n             .collect::<Vec<_>>();\n@@ -1644,7 +1673,8 @@ where\n \n         // If we've run for 100ms and seem to have converged to a\n         // stable median.\n-        if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0\n+        if loop_run > Duration::from_millis(100)\n+            && summ.median_abs_dev_pct < 1.0\n             && summ.median - summ5.median < summ5.median_abs_dev\n         {\n             return summ5;\n@@ -1670,12 +1700,12 @@ where\n }\n \n pub mod bench {\n-    use std::panic::{catch_unwind, AssertUnwindSafe};\n+    use super::{BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult};\n+    use crate::stats;\n     use std::cmp;\n     use std::io;\n+    use std::panic::{catch_unwind, AssertUnwindSafe};\n     use std::sync::{Arc, Mutex};\n-    use crate::stats;\n-    use super::{BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult};\n \n     pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<MonitorMsg>, nocapture: bool, f: F)\n     where\n@@ -1750,14 +1780,15 @@ pub mod bench {\n \n #[cfg(test)]\n mod tests {\n-    use crate::test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n-               ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n-               TrFailedMsg, TrIgnored, TrOk};\n-    use std::sync::mpsc::channel;\n     use crate::bench;\n+    use crate::test::{\n+        filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+        ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+        TrIgnored, TrOk,\n+    };\n     use crate::Bencher;\n     use crate::Concurrent;\n-\n+    use std::sync::mpsc::channel;\n \n     fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n         vec!["}]}