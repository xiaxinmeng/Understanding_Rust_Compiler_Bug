{"sha": "50cd218c1e74dac5113e82bd3e03008d746a26df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwY2QyMThjMWU3NGRhYzUxMTNlODJiZDNlMDMwMDhkNzQ2YTI2ZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-18T23:06:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-18T23:06:52Z"}, "message": "auto merge of #5920 : catamorphism/rust/rustpkg, r=catamorphism\n\nr? @graydon", "tree": {"sha": "c734545721ab7107849355a360bb11edfd6163d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c734545721ab7107849355a360bb11edfd6163d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50cd218c1e74dac5113e82bd3e03008d746a26df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50cd218c1e74dac5113e82bd3e03008d746a26df", "html_url": "https://github.com/rust-lang/rust/commit/50cd218c1e74dac5113e82bd3e03008d746a26df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50cd218c1e74dac5113e82bd3e03008d746a26df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b19c644d543b3638c4d420e923446606ad8ac2e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b19c644d543b3638c4d420e923446606ad8ac2e2", "html_url": "https://github.com/rust-lang/rust/commit/b19c644d543b3638c4d420e923446606ad8ac2e2"}, {"sha": "1aebf30f72c16628ce3b5404329e65a0d4ad4e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aebf30f72c16628ce3b5404329e65a0d4ad4e05", "html_url": "https://github.com/rust-lang/rust/commit/1aebf30f72c16628ce3b5404329e65a0d4ad4e05"}], "stats": {"total": 764, "additions": 526, "deletions": 238}, "files": [{"sha": "140d9ced5808d362d1213385785a88a5075ede56", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -11,7 +11,8 @@\n // rustpkg utilities having to do with paths and directories\n \n use core::path::*;\n-use core::os;\n+use core::{os, str};\n+use core::option::*;\n use util::PkgId;\n \n /// Returns the output directory to use.\n@@ -50,6 +51,24 @@ pub fn default_dest_dir(pkg_dir: &Path) -> Path {\n     }\n }\n \n+/// Replace all occurrences of '-' in the stem part of path with '_'\n+/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n+/// as the same name\n+pub fn normalize(p: ~Path) -> ~Path {\n+    match p.filestem() {\n+        None => p,\n+        Some(st) => {\n+            let replaced = str::replace(st, \"-\", \"_\");\n+            if replaced != st {\n+                ~p.with_filestem(replaced)\n+            }\n+            else {\n+                p\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use core::{os, rand};"}, {"sha": "206404ae2040cd949010c6f837b9693268955199", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 97, "deletions": 207, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -33,11 +33,11 @@ use core::hashmap::HashMap;\n use core::io::WriterUtil;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n-use std::net::url;\n use std::{getopts};\n use syntax::{ast, diagnostic};\n-use util::{ExitCode, Pkg, PkgId};\n-use path_util::dest_dir;\n+use util::*;\n+use path_util::{dest_dir, normalize};\n+use rustc::driver::session::{lib_crate, bin_crate, unknown_crate, crate_type};\n \n mod conditions;\n mod usage;\n@@ -117,9 +117,12 @@ impl PkgScript {\n             Ok(r) => {\n                 let root = r.pop().pop().pop().pop(); // :-\\\n                 debug!(\"Root is %s, calling compile_rest\", root.to_str());\n-                util::compile_crate_from_input(self.input, Some(self.build_dir),\n-                                               sess, Some(crate), os::args()[0]);\n                 let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n+                util::compile_crate_from_input(self.input, self.id,\n+                                               Some(self.build_dir),\n+                                               sess, Some(crate),\n+                                               exe, os::args()[0],\n+                                               driver::cu_everything);\n                 debug!(\"Running program: %s %s %s\", exe.to_str(), root.to_str(), what);\n                 let status = run::run_program(exe.to_str(), ~[root.to_str(), what]);\n                 if status != 0 {\n@@ -199,15 +202,15 @@ impl Ctx {\n                 // relative to the CWD. In the future, we should search\n                 // paths\n                 let cwd = os::getcwd().normalize();\n-                debug!(\"Current working directory = %?\", cwd);\n+                debug!(\"Current working directory = %s\", cwd.to_str());\n \n-                // Find crates inside the workspace\n+                // Create the package source\n                 let mut src = PkgSrc::new(&cwd, &dst_dir, &pkgid);\n                 debug!(\"Package src = %?\", src);\n-                src.find_crates();\n \n                 // Is there custom build logic? If so, use it\n                 let pkg_src_dir = cwd.push_rel(&pkgid.path);\n+                let mut custom = false;;\n                 debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n                 let cfgs = match src.package_script_option(&pkg_src_dir) {\n                     Some(package_script_path) => {\n@@ -221,6 +224,7 @@ impl Ctx {\n                         if hook_result != 0 {\n                             fail!(fmt!(\"Error running custom build command\"))\n                         }\n+                        custom = true;\n                         // otherwise, the package script succeeded\n                         cfgs\n                     }\n@@ -229,19 +233,32 @@ impl Ctx {\n                         ~[]\n                     }\n                 };\n-                src.build(&dst_dir, cfgs);\n+\n+                // If there was a package script, it should have finished\n+                // the build already. Otherwise...\n+                if !custom {\n+                    // Find crates inside the workspace\n+                    src.find_crates();\n+                    // Build it!\n+                    src.build(&dst_dir, cfgs);\n+                }\n             }\n             ~\"clean\" => {\n-                self.clean();\n+                if args.len() < 1 {\n+                    return usage::build();\n+                }\n+                // The package id is presumed to be the first command-line\n+                // argument\n+                let pkgid = PkgId::new(args[0]);\n+\n+                self.clean(pkgid);\n             }\n             ~\"do\" => {\n                 if args.len() < 2 {\n                     return usage::do_cmd();\n                 }\n \n-                if !self.do_cmd(args[0], args[1]) {\n-                    fail!(~\"a command failed!\");\n-                }\n+                self.do_cmd(args[0], args[1]);\n             }\n             ~\"info\" => {\n                 self.info();\n@@ -286,12 +303,11 @@ impl Ctx {\n         }\n     }\n \n-    fn do_cmd(&self, cmd: ~str, pkgname: ~str) -> bool {\n+    fn do_cmd(&self, cmd: ~str, pkgname: ~str)  {\n         match cmd {\n             ~\"build\" | ~\"test\" => {\n                 util::error(~\"that command cannot be manually called\");\n-\n-                return false;\n+                fail!(~\"do_cmd\");\n             }\n             _ => {}\n         }\n@@ -307,16 +323,15 @@ impl Ctx {\n             Some(script_path) => {\n                 let script = PkgScript::parse(script_path, pkgid);\n                 let (_, status) = script.run_custom(cmd); // Ignore cfgs?\n-                if status == 42 { // ???\n+                if status == 42 {\n                     util::error(~\"no fns are listening for that cmd\");\n-                    return false;\n+                    fail!(~\"do_cmd\");\n                 }\n-                status == 0\n             }\n             None => {\n                 util::error(fmt!(\"invoked `do`, but there is no package script in %s\",\n                                  cwd.to_str()));\n-                false\n+                fail!(~\"do_cmd\");\n             }\n         }\n     }\n@@ -329,128 +344,44 @@ impl Ctx {\n     }\n \n     fn compile(&self, _crate: &Path, _dir: &Path, _flags: ~[~str],\n-               _cfgs: ~[~str], _opt: bool, _test: bool) -> bool {\n+               _cfgs: ~[~str], _opt: bool, _test: bool)  {\n         // What's the difference between build and compile?\n         fail!(~\"compile not yet implemented\");\n     }\n \n-    fn clean(&self) -> bool {\n-        // stub\n-        fail!();\n+    fn clean(&self, id: PkgId)  {\n+        // Could also support a custom build hook in the pkg\n+        // script for cleaning files rustpkg doesn't know about.\n+        // Do something reasonable for now\n+\n+        let dir = dest_dir(id);\n+        util::note(fmt!(\"Cleaning package %s (removing directory %s)\",\n+                        id.to_str(), dir.to_str()));\n+        if os::path_exists(&dir) {\n+            util::remove_dir_r(&dir);\n+            util::note(fmt!(\"Removed directory %s\", dir.to_str()));\n+        }\n+\n+        util::note(fmt!(\"Cleaned package %s\", id.to_str()));\n     }\n \n     fn info(&self) {\n         // stub\n-        fail!();\n+        fail!(~\"info not yet implemented\");\n     }\n \n-    fn install(&self, url: Option<~str>,\n-               target: Option<~str>, cache: bool) -> bool {\n-       let dir = match url {\n-            None => {\n-                util::note(~\"installing from the cwd\");\n-                os::getcwd()\n-            }\n-            Some(url) => {\n-                let hash = util::hash(if !target.is_none() {\n-                    url + target.get()\n-                }\n-                else { url });\n-\n-                if self.dep_cache.contains_key(&hash) {\n-                    util::warn(~\"already installed dep this run\");\n-                    return true;\n-                }\n-\n-                self.dep_cache.insert(hash, true);\n-\n-                let dir = util::root().push(~\"tmp\").push(hash);\n-\n-                if cache && os::path_exists(&dir) {\n-                    return true;\n-                }\n-\n-                if !self.fetch(&dir, url, target) {\n-                    return false;\n-                }\n-                dir\n-            }\n-        };\n-\n-        let script = match self.build(&dir, false, true, false) {\n-            Some(script) => script,\n-            None => {\n-                return false;\n-            }\n-        };\n-        let work_dir = script.build_dir;\n-        let from_bin_dir = work_dir.push(~\"bin\");\n-        let from_lib_dir = work_dir.push(~\"lib\");\n-        let to_bin_dir = util::root().push(~\"bin\");\n-        let to_lib_dir = util::root().push(~\"lib\");\n-        let mut bins = ~[];\n-        let mut libs = ~[];\n-\n-        for os::walk_dir(&from_bin_dir) |bin| {\n-            let to = to_bin_dir.push_rel(&bin.file_path());\n-\n-            os::copy_file(bin, &to);\n-            bins.push(to.to_str());\n-        }\n-\n-        for os::walk_dir(&from_lib_dir) |lib| {\n-            let to = to_lib_dir.push_rel(&lib.file_path());\n-\n-            os::copy_file(lib, &to);\n-            libs.push(to.to_str());\n-        }\n-\n-        let package = Pkg {\n-            id: script.id,\n-            bins: bins,\n-            libs: libs\n-        };\n-\n-        util::note(fmt!(\"installed %s\", script.id.to_str()));\n-        util::add_pkg(&package);\n-\n-        true\n+    fn install(&self, _url: Option<~str>,\n+               _target: Option<~str>, _cache: bool)  {\n+        // stub\n+        fail!(~\"install not yet implemented\");\n     }\n \n-    fn fetch(&self, dir: &Path, url: ~str, target: Option<~str>) -> bool {\n-        let url = if str::find_str(url, \"://\").is_none() {\n-            ~\"http://\" + url }\n-        else { url };\n-        let url = match url::from_str(url) {\n-            result::Ok(url) => url,\n-            result::Err(err) => {\n-                util::error(fmt!(\"failed parsing %s\", err.to_lower()));\n-\n-                return false;\n-            }\n-        };\n-        let str = url.to_str();\n-\n-        match Path(url.path).filetype() {\n-            Some(ext) => {\n-                if ext == ~\".git\" {\n-                    return self.fetch_git(dir, str, target);\n-                }\n-            }\n-            None => {}\n-        }\n-\n-        match url.scheme {\n-            ~\"git\" => self.fetch_git(dir, str, target),\n-            ~\"http\" | ~\"ftp\" | ~\"file\" => self.fetch_curl(dir, str),\n-            _ => {\n-                util::warn(~\"unknown url scheme to fetch, using curl\");\n-                self.fetch_curl(dir, str)\n-            }\n-        }\n+    fn fetch(&self, _dir: &Path, _url: ~str, _target: Option<~str>)  {\n+        // stub\n+        fail!(~\"fetch not yet implemented\");\n     }\n \n-    fn fetch_curl(&self, dir: &Path, url: ~str) -> bool {\n+    fn fetch_curl(&self, dir: &Path, url: ~str)  {\n         util::note(fmt!(\"fetching from %s using curl\", url));\n \n         let tar = dir.dir_path().push(&dir.file_path().to_str() + ~\".tar\");\n@@ -460,7 +391,7 @@ impl Ctx {\n                                           url]).status != 0 {\n             util::error(~\"fetching failed: downloading using curl failed\");\n \n-            return false;\n+            fail!();\n         }\n \n         if run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n@@ -469,13 +400,11 @@ impl Ctx {\n             util::error(~\"fetching failed: extracting using tar failed\" +\n                         ~\"(is it a valid tar archive?)\");\n \n-            return false;\n+           fail!();\n         }\n-\n-        true\n     }\n \n-    fn fetch_git(&self, dir: &Path, url: ~str, target: Option<~str>) -> bool {\n+    fn fetch_git(&self, dir: &Path, url: ~str, target: Option<~str>)  {\n         util::note(fmt!(\"fetching from %s using git\", url));\n \n         // Git can't clone into a non-empty directory\n@@ -484,8 +413,7 @@ impl Ctx {\n         if run::program_output(~\"git\", ~[~\"clone\", url,\n                                          dir.to_str()]).status != 0 {\n             util::error(~\"fetching failed: can't clone repository\");\n-\n-            return false;\n+            fail!();\n         }\n \n         if !target.is_none() {\n@@ -499,21 +427,17 @@ impl Ctx {\n \n             if !success {\n                 util::error(~\"fetching failed: can't checkout target\");\n-\n-                return false;\n+                fail!();\n             }\n         }\n-\n-        true\n     }\n \n-    fn prefer(&self, id: ~str, vers: Option<~str>) -> bool {\n+    fn prefer(&self, id: ~str, vers: Option<~str>)  {\n         let package = match util::get_pkg(id, vers) {\n             result::Ok(package) => package,\n             result::Err(err) => {\n                 util::error(err);\n-\n-                return false;\n+                fail!(); // Condition?\n             }\n         };\n         let name = package.id.path.to_str(); // ???\n@@ -536,29 +460,18 @@ impl Ctx {\n         }\n \n         util::note(fmt!(\"preferred %s v%s\", name, package.id.version.to_str()));\n-\n-        true\n     }\n \n-    fn test(&self) -> bool {\n-        let script = match self.build(&os::getcwd(), false, false, true) {\n-            Some(script) => script,\n-            None => {\n-                return false;\n-            }\n-        };\n-\n-        // To do\n-        util::note(fmt!(\"Would test %s, but this is a dry run\",\n-                        script.id.to_str()));\n-        false\n+    fn test(&self)  {\n+        // stub\n+        fail!(~\"test not yet implemented\");\n     }\n \n-    fn uninstall(&self, _id: ~str, _vers: Option<~str>) -> bool {\n+    fn uninstall(&self, _id: ~str, _vers: Option<~str>)  {\n         fail!(~\"uninstall not yet implemented\");\n     }\n \n-    fn unprefer(&self, _id: ~str, _vers: Option<~str>) -> bool {\n+    fn unprefer(&self, _id: ~str, _vers: Option<~str>)  {\n         fail!(~\"unprefer not yet implemented\");\n     }\n }\n@@ -728,7 +641,6 @@ condition! {\n \n impl PkgSrc {\n \n-\n     fn new(src_dir: &Path, dst_dir: &Path,\n                   id: &PkgId) -> PkgSrc {\n         PkgSrc {\n@@ -765,12 +677,6 @@ impl PkgSrc {\n         dir\n     }\n \n-\n-    fn has_pkg_file(&self) -> bool {\n-        let dir = self.check_dir();\n-        dir.push(\"pkg.rs\").exists()\n-    }\n-\n     // If a file named \"pkg.rs\" in the current directory exists,\n     // return the path for it. Otherwise, None\n     fn package_script_option(&self, cwd: &Path) -> Option<Path> {\n@@ -786,14 +692,16 @@ impl PkgSrc {\n     /// True if the given path's stem is self's pkg ID's stem\n     /// or if the pkg ID's stem is <rust-foo> and the given path's\n     /// stem is foo\n+    /// Requires that dashes in p have already been normalized to\n+    /// underscores\n     fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = self.id.path.filestem();\n+        let self_id = normalize(~self.id.path).filestem();\n         if self_id == p.filestem() {\n             return true;\n         }\n         else {\n             for self_id.each |pth| {\n-                if pth.starts_with(\"rust-\")\n+                if pth.starts_with(\"rust_\") // because p is already normalized\n                     && match p.filestem() {\n                            Some(s) => str::eq_slice(s, pth.slice(5, pth.len())),\n                            None => false\n@@ -814,17 +722,14 @@ impl PkgSrc {\n         cs.push(Crate::new(&sub));\n     }\n \n+    /// Infers crates to build. Called only in the case where there\n+    /// is no custom build logic\n     fn find_crates(&mut self) {\n         use PkgSrc::push_crate;\n \n         let dir = self.check_dir();\n         let prefix = dir.components.len();\n-        // This is ugly, but can go away once we get rid\n-        // of .rc files\n-        let mut saw_rs = false;\n-        let mut saw_rc = false;\n-        debug!(\"Matching against %?\",\n-               self.id.path.filestem());\n+        debug!(\"Matching against %?\", self.id.path.filestem());\n         for os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n                 Some(~\"lib.rs\") => push_crate(&mut self.libs,\n@@ -835,57 +740,42 @@ impl PkgSrc {\n                                                prefix, pth),\n                 Some(~\"bench.rs\") => push_crate(&mut self.benchs,\n                                                 prefix, pth),\n-                _ => {\n-                    // If the file stem is the same as the\n-                    // package ID, with an .rs or .rc extension,\n-                    // consider it to be a crate\n-                    let ext = pth.filetype();\n-                    let matches = |p: &Path| {\n-                        self.stem_matches(p) && (ext == Some(~\".rc\")\n-                                                  || ext == Some(~\".rs\"))\n-                    };\n-                    debug!(\"Checking %? which %s and ext = %? %? %?\", pth.filestem(),\n-                           if matches(pth) { \"matches\" } else { \"does not match\" },\n-                           ext, saw_rs, saw_rc);\n-                    if matches(pth) &&\n-                        // Avoid pushing foo.rc *and* foo.rs\n-                         !((ext == Some(~\".rc\") && saw_rs) ||\n-                           (ext == Some(~\".rs\") && saw_rc)) {\n-                        push_crate(&mut self.libs, // ????\n-                                   prefix, pth);\n-                        if ext == Some(~\".rc\") {\n-                            saw_rc = true;\n-                        }\n-                        else if ext == Some(~\".rs\") {\n-                            saw_rs = true;\n-                        }\n-                    }\n-                }\n+                _ => ()\n             }\n         }\n+\n+        if self.libs.is_empty() && self.mains.is_empty()\n+            && self.tests.is_empty() && self.benchs.is_empty() {\n+\n+            util::note(~\"Couldn't infer any crates to build.\\n\\\n+                         Try naming a crate `main.rs`, `lib.rs`, \\\n+                         `test.rs`, or `bench.rs`.\");\n+            fail!(~\"Failed to infer crates to build\");\n+        }\n+\n         debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n                self.libs.len(),\n                self.mains.len(),\n                self.tests.len(),\n                self.benchs.len())\n     }\n \n-    fn build_crates(dst_dir: &Path,\n+    fn build_crates(&self, dst_dir: &Path,\n                            src_dir: &Path,\n                            crates: &[Crate],\n                            cfgs: ~[~str],\n-                           test: bool) {\n+                           test: bool, crate_type: crate_type) {\n \n         for crates.each |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             util::note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n \n-            let result = util::compile_crate(None, path,\n+            let result = util::compile_crate(None, self.id, path,\n                                      dst_dir,\n                                      crate.flags,\n                                      crate.cfgs + cfgs,\n-                                     false, test);\n+                                     false, test, crate_type);\n             if !result {\n                 build_err::cond.raise(fmt!(\"build failure on %s\",\n                                            path.to_str()));\n@@ -898,12 +788,12 @@ impl PkgSrc {\n     fn build(&self, dst_dir: &Path, cfgs: ~[~str]) {\n         let dir = self.check_dir();\n         debug!(\"Building libs\");\n-        PkgSrc::build_crates(dst_dir, &dir, self.libs, cfgs, false);\n+        self.build_crates(dst_dir, &dir, self.libs, cfgs, false, lib_crate);\n         debug!(\"Building mains\");\n-        PkgSrc::build_crates(dst_dir, &dir, self.mains, cfgs, false);\n+        self.build_crates(dst_dir, &dir, self.mains, cfgs, false, bin_crate);\n         debug!(\"Building tests\");\n-        PkgSrc::build_crates(dst_dir, &dir, self.tests, cfgs, true);\n+        self.build_crates(dst_dir, &dir, self.tests, cfgs, true, bin_crate);\n         debug!(\"Building benches\");\n-        PkgSrc::build_crates(dst_dir, &dir, self.benchs, cfgs, true);\n+        self.build_crates(dst_dir, &dir, self.benchs, cfgs, true, bin_crate);\n     }\n }"}, {"sha": "c9c1f00fb082a57f23274a97d06e4813b84fc729", "filename": "src/librustpkg/testsuite/fail/no-inferred-crates/zzyzx.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fno-inferred-crates%2Fzzyzx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fno-inferred-crates%2Fzzyzx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fno-inferred-crates%2Fzzyzx.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+The test runner should check that, after `rustpkg build hello-world`:\n+  * testsuite/hello-world/build/ exists\n+  * testsuite/hello-world/build/ contains an executable named hello-world\n+  * testsuite/hello-world/build/ does not contain a library\n+*/\n+\n+use core::io;\n+\n+fn main() {\n+    io::println(~\"Hello world!\");\n+}"}, {"sha": "e1a1b2462b253b609a699975d07f1d7dd31538a1", "filename": "src/librustpkg/testsuite/pass/commands.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fcommands.txt?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,35 @@\n+Commands that should succeed:\n+\n+1. rustpkg install github.com/mozilla-servo/rust-http-client\n+\n+2. Create a git repo containing a package \"foo\", add a tag called \"1.0\" -- `rustpkg install foo` should install a library called \"libfoo-....-1.0...\"\n+\n+3. rustpkg install foo, if ./.rust/foo exists and is a valid package directory\n+\n+4. RUST_PATH=/home/rust rustpkg install foo installs an executable in /home/rust/foo if ./foo exists and is a valid package directory\n+\n+5. RUST_PATH=/home/rust:/home/more_rust rustpkg install foo succeeds if /home/more_rust/foo exists and is a valid package directory\n+\n+6. rustpkg install foo; rustpkg install bar; rustpkg install quux; rustpkg list should show foo, bar, and quux\n+  6a. then, rustpkg remove foo; rustpkg list should show bar and quux, but not foo\n+\n+7. Execute `rustpkg build foo`. Check the datestamp on build/foo. Execute the same command again. Make sure the datestamp hasn't changed.\n+\n+8. Execute `rustpkg build foo` where foo has a dependency on bar, which hasn't been built before. Check the datestamps on build/foo and build/bar and make sure bar's datestamp is earlier than foo's.\n+\n+9. Execute `rustpkg build foo` where foo has a dependency on bar, which hasn't been built before. Then, change one of the source files in bar. Execute `rustpkg build foo` again. Make sure, based on datestamps, that foo was really rebuilt.\n+\n+10. Repeat test 9 in the case where the contents of the source file in bar change but its datestamp doesn't change.\n+\n+11. If the current directory contains package directories for foo-0.1 and foo.0.2, `rustpkg install foo#0.1` installs foo#0.1 and doesn't install foo#0.2.\n+\n+12. `rustpkg do fancy-pkg frob` succeeds if `fancy-pkg` has a package script that defines a custom build hook named `frob`.\n+\n+13. `rustpkg info foo` prints out something about foo, if foo is installed.\n+\n+14. (Not sure what prefer and unprefer do)\n+\n+15. `rustpkg test foo` runs tests and prints their output, if foo contains #[test]s.\n+\n+16. If foo is installed, `rustpkg uninstall foo; rustpkg list` doesn't include foo in the list\n+"}, {"sha": "41041ccb50912fb0a54f4ce8c1ded1796d2f3d78", "filename": "src/librustpkg/testsuite/pass/deeply/nested/path/foo/main.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fdeeply%2Fnested%2Fpath%2Ffoo%2Fmain.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+The test runner should check that, after `rustpkg install deeply/nested/path/foo`:\n+  with RUST_PATH undefined in the environment:\n+   * ./deeply/nested/path/foo exists and is an executable\n+*/\n+\n+fn main() {}\n+"}, {"sha": "d094bcd6bba62766dbfb6207f26a1d1b9fd8fe24", "filename": "src/librustpkg/testsuite/pass/external-crate/main.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fexternal-crate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fexternal-crate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fexternal-crate%2Fmain.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+The test runner should check that, after `rustpkg install external crate`\n+  with RUST_PATH undefined in the environment\n+  and with `rustpkg install deeply/nested/path/foo` already\n+     executed:\n+   * ./.rust/external_crate exists and is an executable\n+*/\n+\n+extern mod foo; // refers to deeply/nested/path/foo\n+\n+fn main() {}"}, {"sha": "ffbc6e2a7f9b2a68f07a2a3137e5dd25eb9a18dc", "filename": "src/librustpkg/testsuite/pass/fancy-lib/bar.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Fbar.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn assert_true() {\n+    assert!(true);\n+}"}, {"sha": "55261a820981ab2735c1e34e2c4c2efdf3c81753", "filename": "src/librustpkg/testsuite/pass/fancy-lib/fancy-lib.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Ffancy-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Ffancy-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Ffancy-lib.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+The test runner should check that, after `rustpkg build fancy-lib`:\n+  * testsuite/fancy-lib/build/ exists\n+  * testsuite/fancy-lib/build/ contains a file called generated.rs\n+  * testsuite/fancy-lib/build/ contains a library named libfancy_lib\n+  * testsuite/fancy-lib/build/ does not contain an executable\n+  *\n+*/\n+\n+extern mod std;\n+\n+pub mod foo;\n+pub mod bar;\n+#[path = \"build/generated.rs\"] pub mod generated;"}, {"sha": "542a6af402d055053afffe3c366fb145e51c4b83", "filename": "src/librustpkg/testsuite/pass/fancy-lib/foo.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Ffoo.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn do_nothing() {\n+}\n\\ No newline at end of file"}, {"sha": "be3c68d731b2336507e33caa797d672b6eec42db", "filename": "src/librustpkg/testsuite/pass/fancy-lib/pkg.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Ffancy-lib%2Fpkg.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::run;\n+\n+pub fn main() {\n+    let cwd = os::getcwd();\n+    debug!(\"cwd = %s\", cwd.to_str());\n+    let file = io::file_writer(&Path(~\"fancy-lib/build/generated.rs\"),\n+                               [io::Create]).get();\n+    file.write_str(\"pub fn wheeeee() { for [1, 2, 3].each() |_| { assert!(true); } }\");\n+\n+    // now compile the crate itself\n+    run::run_program(\"rustc\", ~[~\"fancy-lib/fancy-lib.rs\", ~\"--lib\",\n+                                ~\"-o\", ~\"fancy-lib/build/fancy_lib\"]);\n+}\n\\ No newline at end of file"}, {"sha": "2ef387d962000c1f044061bb646ae299fa97b045", "filename": "src/librustpkg/testsuite/pass/hello-world/main.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fhello-world%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fhello-world%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fhello-world%2Fmain.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+The test runner should check that, after `rustpkg build hello-world`:\n+  * testsuite/pass/hello-world/build/ exists\n+  * testsuite/pass/hello-world/build/ contains an executable named hello-world\n+  * testsuite/pass/hello-world/build/ does not contain a library\n+\n+ It should also check that after `rustpkg clean hello-world`:\n+  * testsuite/pass/hello-world/build is empty\n+*/\n+\n+use core::io;\n+\n+fn main() {\n+    io::println(~\"Hello world!\");\n+}"}, {"sha": "e1641ccf0749309426e57a911ce21ceed13d75fd", "filename": "src/librustpkg/testsuite/pass/install-paths/bench.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Fbench.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[bench]\n+fn g() {\n+    let mut x = 0;\n+    while(x < 1000) {\n+        x += 1;\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "baf90446f7aaca6c3364f96306e94574ee76f602", "filename": "src/librustpkg/testsuite/pass/install-paths/lib.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Flib.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() -> int { 42 }"}, {"sha": "37e606dcb1ab3ee283c3c6a280cf8837c2bdc038", "filename": "src/librustpkg/testsuite/pass/install-paths/main.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Fmain.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+The test runner should check that, after `rustpkg install install-paths`\n+  with RUST_PATH undefined in the environment:\n+   * ./.rust/install_paths exists and is an executable\n+   * ./.rust/libinstall_paths exists and is a library\n+   * ./.rust/install_pathstest does not exist\n+   * ./.rust/install_pathsbench does not exist\n+   * install-paths/build/install_pathstest exists and is an executable\n+   * install-paths/build/install_pathsbench exists and is an executable\n+*/\n+\n+fn main() {}"}, {"sha": "acfae9e04fb59b54caf70ae08e407542606b83c5", "filename": "src/librustpkg/testsuite/pass/install-paths/test.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Finstall-paths%2Ftest.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[test]\n+fn test_two_plus_two() {\n+    assert!(2 + 2 == 4);\n+}"}, {"sha": "ffbc6e2a7f9b2a68f07a2a3137e5dd25eb9a18dc", "filename": "src/librustpkg/testsuite/pass/simple-lib/bar.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Fbar.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn assert_true() {\n+    assert!(true);\n+}"}, {"sha": "542a6af402d055053afffe3c366fb145e51c4b83", "filename": "src/librustpkg/testsuite/pass/simple-lib/foo.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Ffoo.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn do_nothing() {\n+}\n\\ No newline at end of file"}, {"sha": "1cdca6cdd5d87f3208ac2d85c9ba255447c59dbf", "filename": "src/librustpkg/testsuite/pass/simple-lib/lib.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Flib.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+The test runner should check that, after `rustpkg build simple-lib`:\n+  * testsuite/simple-lib/build/ exists\n+  * testsuite/simple-lib/build/ contains a library named libsimple_lib\n+  * testsuite/simple-lib/build/ does not contain an executable\n+*/\n+\n+extern mod std;\n+\n+pub mod foo;\n+pub mod bar;"}, {"sha": "1cdca6cdd5d87f3208ac2d85c9ba255447c59dbf", "filename": "src/librustpkg/testsuite/pass/simple-lib/simple-lib.rc", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Fsimple-lib.rc", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Fsimple-lib.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsimple-lib%2Fsimple-lib.rc?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+The test runner should check that, after `rustpkg build simple-lib`:\n+  * testsuite/simple-lib/build/ exists\n+  * testsuite/simple-lib/build/ contains a library named libsimple_lib\n+  * testsuite/simple-lib/build/ does not contain an executable\n+*/\n+\n+extern mod std;\n+\n+pub mod foo;\n+pub mod bar;"}, {"sha": "bb162974e035d9fa172dec073b55ce33268b9e24", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 85, "deletions": 30, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50cd218c1e74dac5113e82bd3e03008d746a26df/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=50cd218c1e74dac5113e82bd3e03008d746a26df", "patch": "@@ -12,16 +12,20 @@ use core::*;\n use core::cmp::Ord;\n use core::hash::Streaming;\n use rustc::driver::{driver, session};\n+use rustc::driver::session::{lib_crate, bin_crate, unknown_crate};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;\n use std::semver;\n use std::{json, term, getopts};\n use syntax::ast_util::*;\n-use syntax::codemap::{dummy_sp};\n+use syntax::codemap::{dummy_sp, spanned, dummy_spanned};\n use syntax::ext::base::{mk_ctxt, ext_ctxt};\n use syntax::ext::build;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n+use syntax::ast::{meta_name_value, meta_list, attribute, crate_};\n+use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n+use rustc::driver::session::{lib_crate, bin_crate, unknown_crate, crate_type};\n \n pub type ExitCode = int; // For now\n \n@@ -112,7 +116,7 @@ pub impl PkgId {\n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-v%s\", self.path.to_str(), self.version.to_str())\n+        fmt!(\"%s-%s\", self.path.to_str(), self.version.to_str())\n     }\n }\n \n@@ -425,44 +429,51 @@ pub fn add_pkg(pkg: &Pkg) -> bool {\n \n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_input(sysroot: Option<Path>,\n+                     pkg_id: PkgId,\n                      in_file: &Path,\n                      out_dir: &Path,\n                      flags: ~[~str],\n                      cfgs: ~[~str],\n                      opt: bool,\n-                     test: bool) -> bool {\n+                     test: bool,\n+                     crate_type: session::crate_type) -> bool {\n+\n+    let short_name = pkg_id.to_str();\n \n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n-    debug!(\"compile_input: %s\", in_file.to_str());\n+    debug!(\"compile_input: %s / %?\", in_file.to_str(), crate_type);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n-    let short_name = in_file.filestem().expect(\"Can't compile a directory!\");\n-    debug!(\"short_name = %s\", short_name.to_str());\n \n-// Right now we're always assuming that we're building a library.\n-// What we should do is parse the crate and infer whether it's a library\n-// from the absence or presence of a main fn\n-    let out_file = out_dir.push(os::dll_filename(short_name));\n-    let building_library = true;\n+    let binary = os::args()[0];\n+    let building_library = match crate_type {\n+        lib_crate | unknown_crate => true,\n+        _ => false\n+    };\n+\n+    let out_file = if building_library {\n+        out_dir.push(os::dll_filename(short_name))\n+    }\n+    else {\n+        out_dir.push(short_name + if test { ~\"test\" } else { ~\"\" }\n+                     + os::EXE_SUFFIX)\n+    };\n \n     debug!(\"compiling %s into %s\",\n            in_file.to_str(),\n            out_file.to_str());\n-\n-    let binary = os::args()[0];\n-\n     debug!(\"flags: %s\", str::connect(flags, ~\" \"));\n     debug!(\"cfgs: %s\", str::connect(cfgs, ~\" \"));\n-// Again, we assume we're building a library\n+\n     let matches = getopts(~[~\"-Z\", ~\"time-passes\"]\n-                          + if building_library { ~[~\"--lib\"] } else { ~[] }\n+                          + if building_library { ~[~\"--lib\"] }\n+                            else { ~[] }\n                           + flags\n                           + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n                           driver::optgroups()).get();\n     let options = @session::options {\n-        crate_type: if building_library { session::lib_crate }\n-                    else { session::bin_crate },\n+        crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: test,\n         maybe_sysroot: sysroot,\n@@ -485,32 +496,56 @@ pub fn compile_input(sysroot: Option<Path>,\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(input, Some(*out_dir), sess, None, binary);\n+    let _ = compile_crate_from_input(input, pkg_id, Some(*out_dir), sess, None,\n+                                     out_file, binary,\n+                                     driver::cu_everything);\n     true\n }\n \n // Should use workcache to avoid recompiling when not necessary\n // Should also rename this to something better\n // If crate_opt is present, then finish compilation. If it's None, then\n // call compile_upto and return the crate\n-pub fn compile_crate_from_input(input: driver::input, build_dir_opt: Option<Path>,\n-    sess: session::Session, crate_opt: Option<@ast::crate>,\n-                                binary: ~str) -> @ast::crate {\n+// also, too many arguments\n+pub fn compile_crate_from_input(input: driver::input,\n+                                pkg_id: PkgId,\n+                                build_dir_opt: Option<Path>,\n+                                sess: session::Session,\n+                                crate_opt: Option<@ast::crate>,\n+                                out_file: Path,\n+                                binary: ~str,\n+                                what: driver::compile_upto) -> @ast::crate {\n     debug!(\"Calling build_output_filenames with %?\", build_dir_opt);\n-    let outputs = driver::build_output_filenames(input, &build_dir_opt, &None, sess);\n+    let outputs = driver::build_output_filenames(input, &build_dir_opt, &Some(out_file), sess);\n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n     let cfg = driver::build_configuration(sess, binary, input);\n     match crate_opt {\n         Some(c) => {\n             debug!(\"Calling compile_rest, outputs = %?\", outputs);\n+            assert!(what == driver::cu_everything);\n             driver::compile_rest(sess, cfg, driver::cu_everything, Some(outputs), Some(c));\n             c\n         }\n         None => {\n             debug!(\"Calling compile_upto, outputs = %?\", outputs);\n-            let (crate, _) = driver::compile_upto(sess, cfg, input, driver::cu_parse,\n-                                                  Some(outputs));\n-            crate\n+            let (crate, _) = driver::compile_upto(sess, cfg, input,\n+                                                  driver::cu_parse, Some(outputs));\n+\n+            // Inject the inferred link_meta info if it's not already there\n+            // (assumes that name and vers are the only linkage metas)\n+            let mut crate_to_use = crate;\n+            if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n+                crate_to_use = add_attrs(*crate, ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n+                                                  // change PkgId to have a <shortname> field?\n+                    ~[@dummy_spanned(meta_name_value(@~\"name\",\n+                                                    mk_string_lit(@pkg_id.path.filestem().get()))),\n+                      @dummy_spanned(meta_name_value(@~\"vers\",\n+                                                    mk_string_lit(@pkg_id.version.to_str())))])))]);\n+            }\n+\n+\n+            driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate_to_use));\n+            crate_to_use\n         }\n     }\n }\n@@ -525,17 +560,30 @@ pub fn exe_suffix() -> ~str { ~\".exe\" }\n pub fn exe_suffix() -> ~str { ~\"\" }\n \n \n+/// Returns a copy of crate `c` with attributes `attrs` added to its\n+/// attributes\n+fn add_attrs(c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n+    @spanned {\n+        node: crate_ {\n+            attrs: c.node.attrs + new_attrs, ..c.node\n+        },\n+        span: c.span\n+    }\n+}\n+\n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_crate(sysroot: Option<Path>, crate: &Path, dir: &Path,\n+pub fn compile_crate(sysroot: Option<Path>, pkg_id: PkgId,\n+                     crate: &Path, dir: &Path,\n                      flags: ~[~str], cfgs: ~[~str], opt: bool,\n-                     test: bool) -> bool {\n+                     test: bool, crate_type: crate_type) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n-    debug!(\"compile_crate: flags =...\");\n+    debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for flags.each |&fl| {\n         debug!(\"+++ %s\", fl);\n     }\n-    compile_input(sysroot, crate, dir, flags, cfgs, opt, test)\n+    compile_input(sysroot, pkg_id,\n+                  crate, dir, flags, cfgs, opt, test, crate_type)\n }\n \n \n@@ -563,6 +611,13 @@ pub fn link_exe(src: &Path, dest: &Path) -> bool {\n     }\n }\n \n+pub fn mk_string_lit(s: @~str) -> ast::lit {\n+    spanned {\n+        node: ast::lit_str(s),\n+        span: dummy_sp()\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{is_cmd, parse_name};"}]}