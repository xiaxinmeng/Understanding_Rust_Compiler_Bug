{"sha": "2ff89469d43a3da326d7da50e4a97fb9c0ba359b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZjg5NDY5ZDQzYTNkYTMyNmQ3ZGE1MGU0YTk3ZmI5YzBiYTM1OWI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-06T12:17:56Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-07T08:41:40Z"}, "message": "Actually pass parameters specified as by-val by value\n\nIssue #1008", "tree": {"sha": "8c03d4b28dfa10cb6954c92ebc6496fcf5dab84e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c03d4b28dfa10cb6954c92ebc6496fcf5dab84e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ff89469d43a3da326d7da50e4a97fb9c0ba359b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff89469d43a3da326d7da50e4a97fb9c0ba359b", "html_url": "https://github.com/rust-lang/rust/commit/2ff89469d43a3da326d7da50e4a97fb9c0ba359b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ff89469d43a3da326d7da50e4a97fb9c0ba359b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41528dc5438f66c001a521d287be59e9c0d3addf", "url": "https://api.github.com/repos/rust-lang/rust/commits/41528dc5438f66c001a521d287be59e9c0d3addf", "html_url": "https://github.com/rust-lang/rust/commit/41528dc5438f66c001a521d287be59e9c0d3addf"}], "stats": {"total": 80, "additions": 49, "deletions": 31}, "files": [{"sha": "694a258bffbbcd93f84baa7fa63a50c1940fe031", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2ff89469d43a3da326d7da50e4a97fb9c0ba359b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff89469d43a3da326d7da50e4a97fb9c0ba359b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2ff89469d43a3da326d7da50e4a97fb9c0ba359b", "patch": "@@ -62,7 +62,9 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n         // FIXME: would be nice to have a constraint on arg\n         // that would obviate the need for this check\n         check non_ty_var(cx, arg_ty);\n-        atys += [T_ptr(type_of_inner(cx, sp, arg_ty))];\n+        let llty = type_of_inner(cx, sp, arg_ty);\n+        if arg.mode == ast::by_val { atys += [llty]; }\n+        else { atys += [T_ptr(llty)]; }\n     }\n     ret atys;\n }\n@@ -3424,15 +3426,15 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n                     env_ty: ty::t, ty_param_count: uint,\n                     target_fn: option::t<ValueRef>)\n     -> {val: ValueRef, ty: TypeRef} {\n-// If we supported constraints on record fields, we could make the\n-// constraints for this function:\n-/*\n+    // If we supported constraints on record fields, we could make the\n+    // constraints for this function:\n+    /*\n     : returns_non_ty_var(ccx, outgoing_fty),\n       type_has_static_size(ccx, incoming_fty) ->\n-*/\n-// but since we don't, we have to do the checks at the beginning.\n-          let ccx = cx.ccx;\n-          check type_has_static_size(ccx, incoming_fty);\n+    */\n+    // but since we don't, we have to do the checks at the beginning.\n+    let ccx = cx.ccx;\n+    check type_has_static_size(ccx, incoming_fty);\n \n     // Here we're not necessarily constructing a thunk in the sense of\n     // \"function with no arguments\".  The result of compiling 'bind f(foo,\n@@ -3566,6 +3568,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n                               abi::closure_elt_bindings, b]);\n             bcx = bound_arg.bcx;\n             let val = bound_arg.val;\n+            if out_arg.mode == ast::by_val { val = Load(bcx, val); }\n             // If the type is parameterized, then we need to cast the\n             // type we actually have to the parameterized out type.\n             if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n@@ -3700,21 +3703,24 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty0: TypeRef,\n         // to have type lldestty0 (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty0);\n     } else if arg.mode == ast::by_ref || arg.mode == ast::by_val {\n-        let copied = false;\n-        if !lv.is_mem && type_is_immediate(ccx, e_ty) {\n+        let copied = false, imm = type_is_immediate(ccx, e_ty);\n+        if arg.mode == ast::by_ref && !lv.is_mem && imm {\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n         }\n         if ccx.copy_map.contains_key(e.id) && lv.is_mem {\n+            assert lv.is_mem;\n             if !copied {\n                 let alloc = alloc_ty(bcx, e_ty);\n-                bcx =\n-                    copy_val(alloc.bcx, INIT, alloc.val,\n-                             load_if_immediate(alloc.bcx, val, e_ty), e_ty);\n+                bcx = copy_val(alloc.bcx, INIT, alloc.val,\n+                               load_if_immediate(alloc.bcx, val, e_ty), e_ty);\n                 val = alloc.val;\n             } else { bcx = take_ty(bcx, val, e_ty); }\n             add_clean(bcx, val, e_ty);\n         }\n+        if arg.mode == ast::by_val && (lv.is_mem || !imm) {\n+            val = Load(bcx, val);\n+        }\n     } else if type_is_immediate(ccx, e_ty) && !lv.is_mem {\n         let r = do_spill(bcx, val, e_ty);\n         val = r.val;\n@@ -3960,7 +3966,8 @@ fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n \n         let r = trans_arg_expr(bcx, ty_arg, llargty, to_zero, to_revoke, arg);\n         let llargval = r.val; bcx = r.bcx;\n-        { llval: llargval, llty: llargty, static: static }\n+        { llval: llargval, llty: llargty, static: static,\n+          by_val: ty_arg.mode == ast::by_val }\n     }, fn_arg_tys, args);\n \n     // Allocate the argument bundle.\n@@ -3976,7 +3983,7 @@ fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n         if llarg.static {\n             // FIXME: This load is unfortunate. It won't be necessary once we\n             // have reference types again.\n-            llargval = Load(bcx, llarg.llval);\n+            llargval = llarg.by_val ? llarg.llval : Load(bcx, llarg.llval);\n         } else {\n             llargval = llarg.llval;\n         }\n@@ -5141,27 +5148,38 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n                         arg_tys: [ty::arg], ignore_mut: bool)\n     -> @block_ctxt {\n     let arg_n: uint = 0u;\n-    for aarg: ast::arg in args {\n-        let arg_ty = arg_tys[arg_n].ty;\n-        alt aarg.mode {\n+    for arg in arg_tys {\n+        let id = args[arg_n].id;\n+        let mutated = !ignore_mut && fcx.lcx.ccx.mut_map.contains_key(id);\n+        alt arg.mode {\n+          ast::mode_infer. {\n+            bcx_ccx(bcx).sess.span_fatal(fcx.sp, \"this\");\n+          }\n           ast::by_move. {\n-            add_clean(bcx, fcx.llargs.get(aarg.id), arg_ty);\n+            add_clean(bcx, fcx.llargs.get(id), arg.ty);\n           }\n           ast::by_mut_ref. { }\n-          _ {\n-            let mutated =\n-                !ignore_mut && fcx.lcx.ccx.mut_map.contains_key(aarg.id);\n-\n+          ast::by_val. {\n+            let aval = fcx.llargs.get(id);\n+            let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n+            bcx = cx;\n+            Store(bcx, aval, alloc);\n+            if mutated {\n+                bcx = take_ty(bcx, alloc, arg.ty);\n+                add_clean(bcx, alloc, arg.ty);\n+            }\n+            fcx.llargs.insert(id, alloc);\n+          }\n+          ast::by_ref. {\n             // Overwrite the llargs entry for locally mutated params\n             // with a local alloca.\n             if mutated {\n-                let aptr = fcx.llargs.get(aarg.id);\n-                let {bcx: bcx, val: alloc} = alloc_ty(bcx, arg_ty);\n-                bcx =\n-                    copy_val(bcx, INIT, alloc,\n-                             load_if_immediate(bcx, aptr, arg_ty), arg_ty);\n-                fcx.llargs.insert(aarg.id, alloc);\n-                add_clean(bcx, alloc, arg_ty);\n+                let aptr = fcx.llargs.get(id);\n+                let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n+                bcx = copy_val(cx, INIT, alloc,\n+                               load_if_immediate(cx, aptr, arg.ty), arg.ty);\n+                fcx.llargs.insert(id, alloc);\n+                add_clean(bcx, alloc, arg.ty);\n             }\n           }\n         }\n@@ -5845,7 +5863,7 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n     let i = arg_n;\n     for arg: ty::arg in args {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n-        if arg.mode == ast::by_ref || arg.mode == ast::by_val {\n+        if arg.mode == ast::by_ref {\n             llarg = load_if_immediate(bcx, llarg, arg.ty);\n         }\n         assert (llarg as int != 0);"}]}