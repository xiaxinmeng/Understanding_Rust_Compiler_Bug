{"sha": "aba11b3206da1ac0a1eb35ee55f86f059a927832", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYTExYjMyMDZkYTFhYzBhMWViMzVlZTU1Zjg2ZjA1OWE5Mjc4MzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-27T07:32:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-27T07:32:00Z"}, "message": "Auto merge of #31020 - regexident:fix_16884, r=brson\n\nChanges error message from displaying first found missing constructor witness to showing up to 10, if necessary.\n\nFixes issue #16884.", "tree": {"sha": "ca00953c67715941ba72099eded8f76d5f1708d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca00953c67715941ba72099eded8f76d5f1708d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aba11b3206da1ac0a1eb35ee55f86f059a927832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aba11b3206da1ac0a1eb35ee55f86f059a927832", "html_url": "https://github.com/rust-lang/rust/commit/aba11b3206da1ac0a1eb35ee55f86f059a927832", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aba11b3206da1ac0a1eb35ee55f86f059a927832/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a186eb2fb220fe7055528a2245fc7289e5972625", "url": "https://api.github.com/repos/rust-lang/rust/commits/a186eb2fb220fe7055528a2245fc7289e5972625", "html_url": "https://github.com/rust-lang/rust/commit/a186eb2fb220fe7055528a2245fc7289e5972625"}, {"sha": "2c7a19a10df23f132dfa96bea49bc3a6a16cc231", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c7a19a10df23f132dfa96bea49bc3a6a16cc231", "html_url": "https://github.com/rust-lang/rust/commit/2c7a19a10df23f132dfa96bea49bc3a6a16cc231"}], "stats": {"total": 154, "additions": 96, "deletions": 58}, "files": [{"sha": "fa09c9d2bb6bade3d241b48a14bd8ca306c19b3e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/aba11b3206da1ac0a1eb35ee55f86f059a927832/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba11b3206da1ac0a1eb35ee55f86f059a927832/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=aba11b3206da1ac0a1eb35ee55f86f059a927832", "patch": "@@ -368,31 +368,46 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir::MatchSource) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match &pats[..] {\n-                [ref witness] => &**witness,\n-                [] => DUMMY_WILD_PAT,\n-                _ => unreachable!()\n+            let witnesses = if pats.is_empty() {\n+                vec![DUMMY_WILD_PAT]\n+            } else {\n+                pats.iter().map(|w| &**w ).collect()\n             };\n             match source {\n                 hir::MatchSource::ForLoopDesugar => {\n-                    // `witness` has the form `Some(<head>)`, peel off the `Some`\n-                    let witness = match witness.node {\n+                    // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n+                    let witness = match witnesses[0].node {\n                         hir::PatEnum(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => unreachable!(),\n                         },\n                         _ => unreachable!(),\n                     };\n-\n                     span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n                                 pat_to_string(witness));\n                 },\n                 _ => {\n+                    let pattern_strings: Vec<_> = witnesses.iter().map(|w| {\n+                        pat_to_string(w)\n+                    }).collect();\n+                    const LIMIT: usize = 3;\n+                    let joined_patterns = match pattern_strings.len() {\n+                        0 => unreachable!(),\n+                        1 => format!(\"`{}`\", pattern_strings[0]),\n+                        2...LIMIT => {\n+                            let (tail, head) = pattern_strings.split_last().unwrap();\n+                            format!(\"`{}`\", head.join(\"`, `\") + \"` and `\" + tail)\n+                        },\n+                        _ => {\n+                            let (head, tail) = pattern_strings.split_at(LIMIT);\n+                            format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n+                        }\n+                    };\n                     span_err!(cx.tcx.sess, sp, E0004,\n-                        \"non-exhaustive patterns: `{}` not covered\",\n-                        pat_to_string(witness)\n+                        \"non-exhaustive patterns: {} not covered\",\n+                        joined_patterns\n                     );\n                 },\n             }\n@@ -594,14 +609,15 @@ impl<'tcx, 'container> ty::AdtDefData<'tcx, 'container> {\n     }\n }\n \n-fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n-                       left_ty: Ty, max_slice_length: usize) -> Option<Constructor> {\n+fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n+                       left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n         .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length))\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n         .into_iter()\n-        .find(|c| !used_constructors.contains(c))\n+        .filter(|c| !used_constructors.contains(c))\n+        .collect()\n }\n \n /// This determines the set of all possible constructors of a pattern matching\n@@ -680,46 +696,44 @@ fn is_useful(cx: &MatchCheckCtxt,\n \n     let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n     if constructors.is_empty() {\n-        match missing_constructor(cx, matrix, left_ty, max_slice_length) {\n-            None => {\n-                all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n-                    match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n-                        UsefulWithWitness(pats) => UsefulWithWitness({\n-                            let arity = constructor_arity(cx, &c, left_ty);\n-                            let mut result = {\n-                                let pat_slice = &pats[..];\n-                                let subpats: Vec<_> = (0..arity).map(|i| {\n-                                    pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n-                                }).collect();\n-                                vec![construct_witness(cx, &c, subpats, left_ty)]\n-                            };\n-                            result.extend(pats.into_iter().skip(arity));\n-                            result\n-                        }),\n-                        result => result\n-                    }\n-                }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n-            },\n-\n-            Some(constructor) => {\n-                let matrix = rows.iter().filter_map(|r| {\n-                    if pat_is_binding_or_wild(&cx.tcx.def_map.borrow(), raw_pat(r[0])) {\n-                        Some(r[1..].to_vec())\n-                    } else {\n-                        None\n-                    }\n-                }).collect();\n-                match is_useful(cx, &matrix, &v[1..], witness) {\n-                    UsefulWithWitness(pats) => {\n-                        let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = vec![DUMMY_WILD_PAT; arity];\n-                        let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n-                        let mut new_pats = vec![enum_pat];\n-                        new_pats.extend(pats);\n-                        UsefulWithWitness(new_pats)\n-                    },\n+        let constructors = missing_constructors(cx, matrix, left_ty, max_slice_length);\n+        if constructors.is_empty() {\n+            all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n+                match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n+                    UsefulWithWitness(pats) => UsefulWithWitness({\n+                        let arity = constructor_arity(cx, &c, left_ty);\n+                        let mut result = {\n+                            let pat_slice = &pats[..];\n+                            let subpats: Vec<_> = (0..arity).map(|i| {\n+                                pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n+                            }).collect();\n+                            vec![construct_witness(cx, &c, subpats, left_ty)]\n+                        };\n+                        result.extend(pats.into_iter().skip(arity));\n+                        result\n+                    }),\n                     result => result\n                 }\n+            }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+        } else {\n+            let matrix = rows.iter().filter_map(|r| {\n+                if pat_is_binding_or_wild(&cx.tcx.def_map.borrow(), raw_pat(r[0])) {\n+                    Some(r[1..].to_vec())\n+                } else {\n+                    None\n+                }\n+            }).collect();\n+            match is_useful(cx, &matrix, &v[1..], witness) {\n+                UsefulWithWitness(pats) => {\n+                    let mut new_pats: Vec<_> = constructors.into_iter().map(|constructor| {\n+                        let arity = constructor_arity(cx, &constructor, left_ty);\n+                        let wild_pats = vec![DUMMY_WILD_PAT; arity];\n+                        construct_witness(cx, &constructor, wild_pats, left_ty)\n+                    }).collect();\n+                    new_pats.extend(pats);\n+                    UsefulWithWitness(new_pats)\n+                },\n+                result => result\n             }\n         }\n     } else {"}, {"sha": "b986878f78396ae823bf9e3fac40e93486dd65f2", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aba11b3206da1ac0a1eb35ee55f86f059a927832/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba11b3206da1ac0a1eb35ee55f86f059a927832/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=aba11b3206da1ac0a1eb35ee55f86f059a927832", "patch": "@@ -16,12 +16,6 @@ struct Foo {\n     second: Option<[usize; 4]>\n }\n \n-enum Color {\n-    Red,\n-    Green,\n-    CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n-}\n-\n fn struct_with_a_nested_enum_and_vector() {\n     match (Foo { first: true, second: None }) {\n //~^ ERROR non-exhaustive patterns: `Foo { first: false, second: Some([_, _, _, _]) }` not covered\n@@ -32,10 +26,40 @@ fn struct_with_a_nested_enum_and_vector() {\n     }\n }\n \n-fn enum_with_multiple_missing_variants() {\n+enum Color {\n+    Red,\n+    Green,\n+    CustomRGBA { a: bool, r: u8, g: u8, b: u8 }\n+}\n+\n+fn enum_with_single_missing_variant() {\n     match Color::Red {\n     //~^ ERROR non-exhaustive patterns: `Red` not covered\n-        Color::CustomRGBA { .. } => ()\n+        Color::CustomRGBA { .. } => (),\n+        Color::Green => ()\n+    }\n+}\n+\n+enum Direction {\n+    North, East, South, West\n+}\n+\n+fn enum_with_multiple_missing_variants() {\n+    match Direction::North {\n+    //~^ ERROR non-exhaustive patterns: `East`, `South` and `West` not covered\n+        Direction::North => ()\n+    }\n+}\n+\n+enum ExcessiveEnum {\n+    First, Second, Third, Fourth, Fifth, Sixth, Seventh, Eighth, Ninth, Tenth, Eleventh, Twelfth\n+}\n+\n+fn enum_with_excessive_missing_variants() {\n+    match ExcessiveEnum::First {\n+    //~^ ERROR `Second`, `Third`, `Fourth` and 8 more not covered\n+\n+        ExcessiveEnum::First => ()\n     }\n }\n "}]}