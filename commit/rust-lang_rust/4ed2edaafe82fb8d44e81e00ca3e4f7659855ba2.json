{"sha": "4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZDJlZGFhZmU4MmZiOGQ0NGU4MWUwMGNhM2U0Zjc2NTk4NTViYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-01T11:34:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-01T11:34:13Z"}, "message": "Auto merge of #42281 - eddyb:well-adjusted, r=nikomatsakis\n\nDecompose Adjustment into smaller steps and remove the method map.\n\nThe method map held method callee information for:\n* actual method calls (`x.f(...)`)\n* overloaded unary, binary, indexing and call operators\n* *every overloaded deref adjustment* (many can exist for each expression)\n\nThat last one was a historical ~~accident~~ hack, and part of the motivation for this PR, along with:\n* a desire to compose adjustments more freely\n* containing the autoderef logic better to avoid mutation within an inference snapshot\n* not creating `TyFnDef` types which are incompatible with the original one\n  * i.e. we used to take a`TyFnDef`'s `for<'a> &'a T -> &'a U` signature and instantiate `'a` using a region inference variable, *then* package the resulting `&'b T -> &'b U` signature in another `TyFnDef`, while keeping *the same* `DefId` and `Substs`\n* to fix #3548 by explicitly writing autorefs for the RHS of comparison operators\n\nIndividual commits tell their own story, of \"atomic\" changes avoiding breaking semantics.\n\nFuture work based on this PR could include:\n* removing the signature from `TyFnDef`, now that it's always \"canonical\"\n  * some questions of variance remain, as subtyping *still* treats the signature differently\n* moving part of the typeck logic for methods, autoderef and coercion into `rustc::traits`\n* allowing LUB coercions (joining multiple expressions) to \"stack up\" many adjustments\n* transitive coercions (e.g. reify or unsize after multiple steps of autoderef)\n\nr? @nikomatsakis", "tree": {"sha": "bac575e79cb4c10b9ad04ddc752c1428735291e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bac575e79cb4c10b9ad04ddc752c1428735291e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "html_url": "https://github.com/rust-lang/rust/commit/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afd4b81c8642016dcb3a641d45a1258193dab958", "url": "https://api.github.com/repos/rust-lang/rust/commits/afd4b81c8642016dcb3a641d45a1258193dab958", "html_url": "https://github.com/rust-lang/rust/commit/afd4b81c8642016dcb3a641d45a1258193dab958"}, {"sha": "5fb37beecdb7827aada42a2ab4e7e0228d02c13a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb37beecdb7827aada42a2ab4e7e0228d02c13a", "html_url": "https://github.com/rust-lang/rust/commit/5fb37beecdb7827aada42a2ab4e7e0228d02c13a"}], "stats": {"total": 3626, "additions": 1479, "deletions": 2147}, "files": [{"sha": "06d585f8ea82f699e64a181921554f237083ff21", "filename": "src/libcollections/tests/binary_heap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibcollections%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibcollections%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftests%2Fbinary_heap.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -134,22 +134,22 @@ fn test_push() {\n fn test_push_unique() {\n     let mut heap = BinaryHeap::<Box<_>>::from(vec![box 2, box 4, box 9]);\n     assert_eq!(heap.len(), 3);\n-    assert!(*heap.peek().unwrap() == box 9);\n+    assert!(**heap.peek().unwrap() == 9);\n     heap.push(box 11);\n     assert_eq!(heap.len(), 4);\n-    assert!(*heap.peek().unwrap() == box 11);\n+    assert!(**heap.peek().unwrap() == 11);\n     heap.push(box 5);\n     assert_eq!(heap.len(), 5);\n-    assert!(*heap.peek().unwrap() == box 11);\n+    assert!(**heap.peek().unwrap() == 11);\n     heap.push(box 27);\n     assert_eq!(heap.len(), 6);\n-    assert!(*heap.peek().unwrap() == box 27);\n+    assert!(**heap.peek().unwrap() == 27);\n     heap.push(box 3);\n     assert_eq!(heap.len(), 7);\n-    assert!(*heap.peek().unwrap() == box 27);\n+    assert!(**heap.peek().unwrap() == 27);\n     heap.push(box 103);\n     assert_eq!(heap.len(), 8);\n-    assert!(*heap.peek().unwrap() == box 103);\n+    assert!(**heap.peek().unwrap() == 103);\n }\n \n fn check_to_vec(mut data: Vec<i32>) {"}, {"sha": "85b1858c875bc0eae8b513d285daac10e6d9fab1", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -355,11 +355,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tables.is_method_call(expr.id) => {\n+            hir::ExprBinary(_, ref l, ref r) if self.tables.is_method_call(expr) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tables.is_method_call(expr.id) => {\n+            hir::ExprUnary(_, ref e) if self.tables.is_method_call(expr) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n@@ -412,16 +412,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             pred: CFGIndex,\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n-        let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tables.method_map.get(&method_call) {\n-            Some(method) => method.ty,\n-            None => self.tables.expr_ty_adjusted(func_or_rcvr),\n-        };\n-\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n         // FIXME(canndrew): This is_never should probably be an is_uninhabited.\n-        if fn_ty.fn_ret().0.is_never() {\n+        if self.tables.expr_ty(call_expr).is_never() {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "a362dc31ff180e27031f6b5c6a9c3bf8f732bee0", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -19,8 +19,6 @@ use std::mem;\n use syntax_pos::symbol::InternedString;\n use ty;\n \n-impl_stable_hash_for!(struct ty::ItemSubsts<'tcx> { substs });\n-\n impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for &'tcx ty::Slice<T>\n     where T: HashStable<StableHashingContext<'a, 'tcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -101,19 +99,20 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::adjustment::Ad\n             ty::adjustment::Adjust::ReifyFnPointer |\n             ty::adjustment::Adjust::UnsafeFnPointer |\n             ty::adjustment::Adjust::ClosureFnPointer |\n-            ty::adjustment::Adjust::MutToConstPointer => {}\n-            ty::adjustment::Adjust::DerefRef { autoderefs, ref autoref, unsize } => {\n-                autoderefs.hash_stable(hcx, hasher);\n+            ty::adjustment::Adjust::MutToConstPointer |\n+            ty::adjustment::Adjust::Unsize => {}\n+            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+                overloaded.hash_stable(hcx, hasher);\n+            }\n+            ty::adjustment::Adjust::Borrow(ref autoref) => {\n                 autoref.hash_stable(hcx, hasher);\n-                unsize.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n-impl_stable_hash_for!(struct ty::MethodCall { expr_id, autoderef });\n-impl_stable_hash_for!(struct ty::MethodCallee<'tcx> { def_id, ty, substs });\n+impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n \n@@ -601,11 +600,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n-            ref type_relative_path_defs,\n+            ref type_dependent_defs,\n             ref node_types,\n-            ref item_substs,\n+            ref node_substs,\n             ref adjustments,\n-            ref method_map,\n             ref upvar_capture_map,\n             ref closure_tys,\n             ref closure_kinds,\n@@ -622,21 +620,10 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            ich::hash_stable_nodemap(hcx, hasher, type_relative_path_defs);\n+            ich::hash_stable_nodemap(hcx, hasher, type_dependent_defs);\n             ich::hash_stable_nodemap(hcx, hasher, node_types);\n-            ich::hash_stable_nodemap(hcx, hasher, item_substs);\n+            ich::hash_stable_nodemap(hcx, hasher, node_substs);\n             ich::hash_stable_nodemap(hcx, hasher, adjustments);\n-\n-            ich::hash_stable_hashmap(hcx, hasher, method_map, |hcx, method_call| {\n-                let ty::MethodCall {\n-                    expr_id,\n-                    autoderef\n-                } = *method_call;\n-\n-                let def_id = hcx.tcx().hir.local_def_id(expr_id);\n-                (hcx.def_path_hash(def_id), autoderef)\n-            });\n-\n             ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n                 let ty::UpvarId {\n                     var_id,"}, {"sha": "f05f411945089d58dafdc3d5e0eba58cfbce7067", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -564,13 +564,14 @@ impl<'tcx, T> InferOk<'tcx, T> {\n }\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot {\n+pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot,\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n     region_vars_snapshot: RegionSnapshot,\n     was_in_snapshot: bool,\n+    _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n /// Helper trait for shortening the lifetimes inside a\n@@ -888,7 +889,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn start_snapshot(&self) -> CombinedSnapshot {\n+    fn start_snapshot<'b>(&'b self) -> CombinedSnapshot<'b, 'tcx> {\n         debug!(\"start_snapshot()\");\n \n         let in_snapshot = self.in_snapshot.get();\n@@ -901,6 +902,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n             was_in_snapshot: in_snapshot,\n+            // Borrow tables \"in progress\" (i.e. during typeck)\n+            // to ban writes from within a snapshot to them.\n+            _in_progress_tables: match self.tables {\n+                InferTables::InProgress(ref tables) => tables.try_borrow().ok(),\n+                _ => None\n+            }\n         }\n     }\n \n@@ -911,7 +918,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n-                               was_in_snapshot } = snapshot;\n+                               was_in_snapshot,\n+                               _in_progress_tables } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n \n@@ -938,7 +946,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                int_snapshot,\n                                float_snapshot,\n                                region_vars_snapshot,\n-                               was_in_snapshot } = snapshot;\n+                               was_in_snapshot,\n+                               _in_progress_tables } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n \n@@ -1645,29 +1654,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         !traits::type_known_to_meet_bound(self, ty, copy_def_id, span)\n     }\n \n-    pub fn node_method_ty(&self, method_call: ty::MethodCall)\n-                          -> Option<Ty<'tcx>> {\n-        self.tables\n-            .borrow()\n-            .method_map\n-            .get(&method_call)\n-            .map(|method| method.ty)\n-            .map(|ty| self.resolve_type_vars_if_possible(&ty))\n-    }\n-\n-    pub fn node_method_id(&self, method_call: ty::MethodCall)\n-                          -> Option<DefId> {\n-        self.tables\n-            .borrow()\n-            .method_map\n-            .get(&method_call)\n-            .map(|method| method.def_id)\n-    }\n-\n-    pub fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n-    }\n-\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }"}, {"sha": "6077b7863e2c3d034a59f8548df12fb21e9d8208", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -95,9 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n-        let method_call = ty::MethodCall::expr(id);\n-        let method = self.tables.method_map[&method_call];\n-        self.check_def_id(method.def_id);\n+        self.check_def_id(self.tables.type_dependent_defs[&id].def_id());\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {"}, {"sha": "74e1225f3948b92e9ab52e93f016ba48271a3d9e", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -13,7 +13,6 @@\n use self::RootUnsafeContext::*;\n \n use ty::{self, Ty, TyCtxt};\n-use ty::MethodCall;\n use lint;\n \n use syntax::ast;\n@@ -174,8 +173,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tables.method_map[&method_call].ty;\n+                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let base_type = self.tcx.type_of(def_id);\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "bb56439a157fe260f0ef13285a164a6ccf8d3010", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 43, "deletions": 183, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -263,12 +263,6 @@ macro_rules! return_if_err {\n     )\n }\n \n-/// Whether the elements of an overloaded operation are passed by value or by reference\n-enum PassArgs {\n-    ByValue,\n-    ByRef,\n-}\n-\n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n                region_maps: &'a RegionMaps,\n@@ -382,9 +376,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprUnary(hir::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &base, Vec::new(), PassArgs::ByRef) {\n-                    self.select_from_expr(&base);\n-                }\n+                self.select_from_expr(&base);\n             }\n \n             hir::ExprField(ref base, _) => {         // base.f\n@@ -396,13 +388,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr,\n-                                                  &lhs,\n-                                                  vec![&rhs],\n-                                                  PassArgs::ByValue) {\n-                    self.select_from_expr(&lhs);\n-                    self.consume_expr(&rhs);\n-                }\n+                self.select_from_expr(&lhs);\n+                self.consume_expr(&rhs);\n             }\n \n             hir::ExprCall(ref callee, ref args) => {    // callee(args)\n@@ -485,29 +472,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprUnary(op, ref lhs) => {\n-                let pass_args = if op.is_by_value() {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n-\n-                if !self.walk_overloaded_operator(expr, &lhs, Vec::new(), pass_args) {\n-                    self.consume_expr(&lhs);\n-                }\n+            hir::ExprUnary(_, ref lhs) => {\n+                self.consume_expr(&lhs);\n             }\n \n-            hir::ExprBinary(op, ref lhs, ref rhs) => {\n-                let pass_args = if op.node.is_by_value() {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n-\n-                if !self.walk_overloaded_operator(expr, &lhs, vec![&rhs], pass_args) {\n-                    self.consume_expr(&lhs);\n-                    self.consume_expr(&rhs);\n-                }\n+            hir::ExprBinary(_, ref lhs, ref rhs) => {\n+                self.consume_expr(&lhs);\n+                self.consume_expr(&rhs);\n             }\n \n             hir::ExprBlock(ref blk) => {\n@@ -529,14 +500,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                // NB All our assignment operations take the RHS by value\n-                assert!(op.node.is_by_value());\n-\n-                if !self.walk_overloaded_operator(expr, lhs, vec![rhs], PassArgs::ByValue) {\n+            hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n+                if self.mc.infcx.tables.borrow().is_method_call(expr) {\n+                    self.consume_expr(lhs);\n+                } else {\n                     self.mutate_expr(expr, &lhs, MutateMode::WriteAndRead);\n-                    self.consume_expr(&rhs);\n                 }\n+                self.consume_expr(&rhs);\n             }\n \n             hir::ExprRepeat(ref base, _) => {\n@@ -563,19 +533,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let overloaded_call_type =\n-                    match self.mc.infcx.node_method_id(ty::MethodCall::expr(call.id)) {\n-                        Some(method_id) => {\n-                            OverloadedCallType::from_method_id(self.tcx(), method_id)\n-                        }\n-                        None => {\n-                            span_bug!(\n-                                callee.span,\n-                                \"unexpected callee type {}\",\n-                                callee_ty)\n-                        }\n-                    };\n-                match overloaded_call_type {\n+                let def_id = self.mc.infcx.tables.borrow().type_dependent_defs[&call.id].def_id();\n+                match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n                         self.borrow_expr(callee,\n@@ -715,102 +674,55 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n-        let infcx = self.mc.infcx;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adj = infcx.tables.borrow().adjustments.get(&expr.id).map(|x| x.clone());\n-        if let Some(adjustment) = adj {\n+        let adjustments = self.mc.infcx.tables.borrow().expr_adjustments(expr).to_vec();\n+        let mut cmt = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+        for adjustment in adjustments {\n+            debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny |\n                 adjustment::Adjust::ReifyFnPointer |\n                 adjustment::Adjust::UnsafeFnPointer |\n                 adjustment::Adjust::ClosureFnPointer |\n-                adjustment::Adjust::MutToConstPointer => {\n+                adjustment::Adjust::MutToConstPointer |\n+                adjustment::Adjust::Unsize => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    debug!(\"walk_adjustment: trivial adjustment\");\n-                    let cmt_unadjusted =\n-                        return_if_err!(self.mc.cat_expr_unadjusted(expr));\n-                    self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n+                    self.delegate_consume(expr.id, expr.span, cmt.clone());\n                 }\n-                adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n-                    debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n \n-                    self.walk_autoderefs(expr, autoderefs);\n-\n-                    let cmt_derefd =\n-                        return_if_err!(self.mc.cat_expr_autoderefd(expr, autoderefs));\n-\n-                    let cmt_refd =\n-                        self.walk_autoref(expr, cmt_derefd, autoref);\n-\n-                    if unsize {\n-                        // Unsizing consumes the thin pointer and produces a fat one.\n-                        self.delegate_consume(expr.id, expr.span, cmt_refd);\n-                    }\n+                adjustment::Adjust::Deref(None) => {}\n+\n+                // Autoderefs for overloaded Deref calls in fact reference\n+                // their receiver. That is, if we have `(*x)` where `x`\n+                // is of type `Rc<T>`, then this in fact is equivalent to\n+                // `x.deref()`. Since `deref()` is declared with `&self`,\n+                // this is an autoref of `x`.\n+                adjustment::Adjust::Deref(Some(ref deref)) => {\n+                    let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n+                    self.delegate.borrow(expr.id, expr.span, cmt.clone(),\n+                                         deref.region, bk, AutoRef);\n                 }\n-            }\n-        }\n-    }\n \n-    /// Autoderefs for overloaded Deref calls in fact reference their receiver. That is, if we have\n-    /// `(*x)` where `x` is of type `Rc<T>`, then this in fact is equivalent to `x.deref()`. Since\n-    /// `deref()` is declared with `&self`, this is an autoref of `x`.\n-    fn walk_autoderefs(&mut self,\n-                       expr: &hir::Expr,\n-                       autoderefs: usize) {\n-        debug!(\"walk_autoderefs expr={:?} autoderefs={}\", expr, autoderefs);\n-\n-        for i in 0..autoderefs {\n-            let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n-            if let Some(method_ty) = self.mc.infcx.node_method_ty(deref_id) {\n-                let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n-\n-                // the method call infrastructure should have\n-                // replaced all late-bound regions with variables:\n-                let self_ty = method_ty.fn_sig().input(0);\n-                let self_ty = self.tcx().no_late_bound_regions(&self_ty).unwrap();\n-\n-                let (m, r) = match self_ty.sty {\n-                    ty::TyRef(r, ref m) => (m.mutbl, r),\n-                    _ => span_bug!(expr.span,\n-                                   \"bad overloaded deref type {:?}\",\n-                                   method_ty)\n-                };\n-                let bk = ty::BorrowKind::from_mutbl(m);\n-                self.delegate.borrow(expr.id, expr.span, cmt,\n-                                     r, bk, AutoRef);\n+                adjustment::Adjust::Borrow(ref autoref) => {\n+                    self.walk_autoref(expr, cmt.clone(), autoref);\n+                }\n             }\n+            cmt = return_if_err!(self.mc.cat_expr_adjusted(expr, cmt, &adjustment));\n         }\n     }\n \n-    /// Walks the autoref `opt_autoref` applied to the autoderef'd\n-    /// `expr`. `cmt_derefd` is the mem-categorized form of `expr`\n-    /// after all relevant autoderefs have occurred. Because AutoRefs\n-    /// can be recursive, this function is recursive: it first walks\n-    /// deeply all the way down the autoref chain, and then processes\n-    /// the autorefs on the way out. At each point, it returns the\n-    /// `cmt` for the rvalue that will be produced by introduced an\n-    /// autoref.\n+    /// Walks the autoref `autoref` applied to the autoderef'd\n+    /// `expr`. `cmt_base` is the mem-categorized form of `expr`\n+    /// after all relevant autoderefs have occurred.\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n-                    opt_autoref: Option<adjustment::AutoBorrow<'tcx>>)\n-                    -> mc::cmt<'tcx>\n-    {\n-        debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n+                    autoref: &adjustment::AutoBorrow<'tcx>) {\n+        debug!(\"walk_autoref(expr.id={} cmt_base={:?} autoref={:?})\",\n                expr.id,\n                cmt_base,\n-               opt_autoref);\n-\n-        let cmt_base_ty = cmt_base.ty;\n-\n-        let autoref = match opt_autoref {\n-            Some(ref autoref) => autoref,\n-            None => {\n-                // No AutoRef.\n-                return cmt_base;\n-            }\n-        };\n+               autoref);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n@@ -840,58 +752,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                      AutoUnsafe);\n             }\n         }\n-\n-        // Construct the categorization for the result of the autoref.\n-        // This is always an rvalue, since we are producing a new\n-        // (temporary) indirection.\n-\n-        let adj_ty = cmt_base_ty.adjust_for_autoref(self.tcx(), opt_autoref);\n-\n-        self.mc.cat_rvalue_node(expr.id, expr.span, adj_ty)\n-    }\n-\n-\n-    // When this returns true, it means that the expression *is* a\n-    // method-call (i.e. via the operator-overload).  This true result\n-    // also implies that walk_overloaded_operator already took care of\n-    // recursively processing the input arguments, and thus the caller\n-    // should not do so.\n-    fn walk_overloaded_operator(&mut self,\n-                                expr: &hir::Expr,\n-                                receiver: &hir::Expr,\n-                                rhs: Vec<&hir::Expr>,\n-                                pass_args: PassArgs)\n-                                -> bool\n-    {\n-        if !self.mc.infcx.is_method_call(expr.id) {\n-            return false;\n-        }\n-\n-        match pass_args {\n-            PassArgs::ByValue => {\n-                self.consume_expr(receiver);\n-                for &arg in &rhs {\n-                    self.consume_expr(arg);\n-                }\n-\n-                return true;\n-            },\n-            PassArgs::ByRef => {},\n-        }\n-\n-        self.walk_expr(receiver);\n-\n-        // Arguments (but not receivers) to overloaded operator\n-        // methods are implicitly autoref'd which sadly does not use\n-        // adjustments, so we must hardcode the borrow here.\n-\n-        let r = self.tcx().node_scope_region(expr.id);\n-        let bk = ty::ImmBorrow;\n-\n-        for &arg in &rhs {\n-            self.borrow_expr(arg, r, bk, OverloadedOperator);\n-        }\n-        return true;\n     }\n \n     fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {"}, {"sha": "c6a42be6135ccbfb8995eb37cd8509bf0ef2491f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n-            if self.tables.is_method_call(expr.id) {\n+            if self.tables.is_method_call(expr) {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n@@ -1072,9 +1072,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let diverges = !self.tables.is_method_call(expr.id) &&\n-                self.tables.expr_ty_adjusted(&f).fn_ret().0.is_never();\n-            let succ = if diverges {\n+            let succ = if self.tables.expr_ty(expr).is_never() {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1084,10 +1082,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprMethodCall(.., ref args) => {\n-            let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.tables.method_map[&method_call].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let succ = if method_ty.fn_ret().0.is_never() {\n+            let succ = if self.tables.expr_ty(expr).is_never() {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1370,7 +1366,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        if !this.tables.is_method_call(expr.id) {\n+        if !this.tables.is_method_call(expr) {\n             this.check_lvalue(&l);\n         }\n "}, {"sha": "53d8eecde54223b28a845371b013301832b8b41d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 149, "deletions": 191, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -63,7 +63,6 @@\n pub use self::PointerKind::*;\n pub use self::InteriorKind::*;\n pub use self::FieldName::*;\n-pub use self::ElementKind::*;\n pub use self::MutabilityCategory::*;\n pub use self::AliasableReason::*;\n pub use self::Note::*;\n@@ -94,7 +93,7 @@ pub enum Categorization<'tcx> {\n     StaticItem,\n     Upvar(Upvar),                          // upvar referenced by closure env\n     Local(ast::NodeId),                    // local variable\n-    Deref(cmt<'tcx>, usize, PointerKind<'tcx>),  // deref of a ptr\n+    Deref(cmt<'tcx>, PointerKind<'tcx>),   // deref of a ptr\n     Interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n     Downcast(cmt<'tcx>, DefId),            // selects a particular enum variant (*1)\n \n@@ -129,7 +128,7 @@ pub enum PointerKind<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n-    InteriorElement(InteriorOffsetKind, ElementKind),\n+    InteriorElement(InteriorOffsetKind),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -144,12 +143,6 @@ pub enum InteriorOffsetKind {\n     Pattern,          // e.g. `fn foo([_, a, _, _]: [A; 4]) { ... }`\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum ElementKind {\n-    VecElement,\n-    OtherElement,\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n@@ -229,8 +222,8 @@ impl<'tcx> cmt_<'tcx> {\n \n     pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n         match self.cat {\n-            Categorization::Deref(ref base_cmt, _, BorrowedPtr(ty::ImmBorrow, _)) |\n-            Categorization::Deref(ref base_cmt, _, Implicit(ty::ImmBorrow, _)) => {\n+            Categorization::Deref(ref base_cmt, BorrowedPtr(ty::ImmBorrow, _)) |\n+            Categorization::Deref(ref base_cmt, Implicit(ty::ImmBorrow, _)) => {\n                 // try to figure out where the immutable reference came from\n                 match base_cmt.cat {\n                     Categorization::Local(node_id) =>\n@@ -255,13 +248,13 @@ impl<'tcx> cmt_<'tcx> {\n             }\n             Categorization::Rvalue(..) |\n             Categorization::Upvar(..) |\n-            Categorization::Deref(.., UnsafePtr(..)) => {\n+            Categorization::Deref(_, UnsafePtr(..)) => {\n                 // This should not be reachable up to inference limitations.\n                 None\n             }\n             Categorization::Interior(ref base_cmt, _) |\n             Categorization::Downcast(ref base_cmt, _) |\n-            Categorization::Deref(ref base_cmt, _, _) => {\n+            Categorization::Deref(ref base_cmt, _) => {\n                 base_cmt.immutability_blame()\n             }\n             Categorization::StaticItem => {\n@@ -473,53 +466,64 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n-        match self.infcx.tables.borrow().adjustments.get(&expr.id) {\n-            None => {\n-                // No adjustments.\n-                self.cat_expr_unadjusted(expr)\n-            }\n-\n-            Some(adjustment) => {\n-                match adjustment.kind {\n-                    adjustment::Adjust::DerefRef {\n-                        autoderefs,\n-                        autoref: None,\n-                        unsize: false\n-                    } => {\n-                        // Equivalent to *expr or something similar.\n-                        self.cat_expr_autoderefd(expr, autoderefs)\n-                    }\n-\n-                    adjustment::Adjust::NeverToAny |\n-                    adjustment::Adjust::ReifyFnPointer |\n-                    adjustment::Adjust::UnsafeFnPointer |\n-                    adjustment::Adjust::ClosureFnPointer |\n-                    adjustment::Adjust::MutToConstPointer |\n-                    adjustment::Adjust::DerefRef {..} => {\n-                        debug!(\"cat_expr({:?}): {:?}\",\n-                               adjustment,\n-                               expr);\n-                        // Result is an rvalue.\n-                        let expr_ty = self.expr_ty_adjusted(expr)?;\n-                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n-                    }\n+        // This recursion helper avoids going through *too many*\n+        // adjustments, since *only* non-overloaded deref recurses.\n+        fn helper<'a, 'gcx, 'tcx>(mc: &MemCategorizationContext<'a, 'gcx, 'tcx>,\n+                                  expr: &hir::Expr,\n+                                  adjustments: &[adjustment::Adjustment<'tcx>])\n+                                   -> McResult<cmt<'tcx>> {\n+            match adjustments.split_last() {\n+                None => mc.cat_expr_unadjusted(expr),\n+                Some((adjustment, previous)) => {\n+                    mc.cat_expr_adjusted_with(expr, || helper(mc, expr, previous), adjustment)\n                 }\n             }\n         }\n+\n+        helper(self, expr, self.infcx.tables.borrow().expr_adjustments(expr))\n+    }\n+\n+    pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n+                             previous: cmt<'tcx>,\n+                             adjustment: &adjustment::Adjustment<'tcx>)\n+                             -> McResult<cmt<'tcx>> {\n+        self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n     }\n \n-    pub fn cat_expr_autoderefd(&self,\n-                               expr: &hir::Expr,\n-                               autoderefs: usize)\n-                               -> McResult<cmt<'tcx>> {\n-        let mut cmt = self.cat_expr_unadjusted(expr)?;\n-        debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={:?}\",\n-               autoderefs,\n-               cmt);\n-        for deref in 1..autoderefs + 1 {\n-            cmt = self.cat_deref(expr, cmt, deref)?;\n+    fn cat_expr_adjusted_with<F>(&self, expr: &hir::Expr,\n+                                 previous: F,\n+                                 adjustment: &adjustment::Adjustment<'tcx>)\n+                                 -> McResult<cmt<'tcx>>\n+        where F: FnOnce() -> McResult<cmt<'tcx>>\n+    {\n+        debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n+        let target = self.infcx.resolve_type_vars_if_possible(&adjustment.target);\n+        match adjustment.kind {\n+            adjustment::Adjust::Deref(overloaded) => {\n+                // Equivalent to *expr or something similar.\n+                let base = if let Some(deref) = overloaded {\n+                    let ref_ty = self.tcx().mk_ref(deref.region, ty::TypeAndMut {\n+                        ty: target,\n+                        mutbl: deref.mutbl,\n+                    });\n+                    self.cat_rvalue_node(expr.id, expr.span, ref_ty)\n+                } else {\n+                    previous()?\n+                };\n+                self.cat_deref(expr, base, false)\n+            }\n+\n+            adjustment::Adjust::NeverToAny |\n+            adjustment::Adjust::ReifyFnPointer |\n+            adjustment::Adjust::UnsafeFnPointer |\n+            adjustment::Adjust::ClosureFnPointer |\n+            adjustment::Adjust::MutToConstPointer |\n+            adjustment::Adjust::Borrow(_) |\n+            adjustment::Adjust::Unsize => {\n+                // Result is an rvalue.\n+                Ok(self.cat_rvalue_node(expr.id, expr.span, target))\n+            }\n         }\n-        return Ok(cmt);\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n@@ -528,8 +532,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n-            let base_cmt = self.cat_expr(&e_base)?;\n-            self.cat_deref(expr, base_cmt, 0)\n+            if self.infcx.tables.borrow().is_method_call(expr) {\n+                self.cat_overloaded_lvalue(expr, e_base, false)\n+            } else {\n+                let base_cmt = self.cat_expr(&e_base)?;\n+                self.cat_deref(expr, base_cmt, false)\n+            }\n           }\n \n           hir::ExprField(ref base, f_name) => {\n@@ -547,33 +555,16 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprIndex(ref base, _) => {\n-            let method_call = ty::MethodCall::expr(expr.id());\n-            match self.infcx.node_method_ty(method_call) {\n-                Some(method_ty) => {\n-                    // If this is an index implemented by a method call, then it\n-                    // will include an implicit deref of the result.\n-                    let ret_ty = self.overloaded_method_return_ty(method_ty);\n-\n-                    // The index method always returns an `&T`, so\n-                    // dereference it to find the result type.\n-                    let elem_ty = match ret_ty.sty {\n-                        ty::TyRef(_, mt) => mt.ty,\n-                        _ => {\n-                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {:?}?\",\n-                                   ret_ty);\n-                            return Err(());\n-                        }\n-                    };\n-\n-                    // The call to index() returns a `&T` value, which\n-                    // is an rvalue. That is what we will be\n-                    // dereferencing.\n-                    let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n-                    Ok(self.cat_deref_common(expr, base_cmt, 1, elem_ty, true))\n-                }\n-                None => {\n-                    self.cat_index(expr, self.cat_expr(&base)?, InteriorOffsetKind::Index)\n-                }\n+            if self.infcx.tables.borrow().is_method_call(expr) {\n+                // If this is an index implemented by a method call, then it\n+                // will include an implicit deref of the result.\n+                // The call to index() returns a `&T` value, which\n+                // is an rvalue. That is what we will be\n+                // dereferencing.\n+                self.cat_overloaded_lvalue(expr, base, true)\n+            } else {\n+                let base_cmt = self.cat_expr(&base)?;\n+                self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n             }\n           }\n \n@@ -763,7 +754,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 cmt_ {\n                     id: id,\n                     span: span,\n-                    cat: Categorization::Deref(Rc::new(cmt_result), 0, ptr),\n+                    cat: Categorization::Deref(Rc::new(cmt_result), ptr),\n                     mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n                     ty: var_ty,\n                     note: NoteUpvarRef(upvar_id)\n@@ -823,7 +814,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let ret = cmt_ {\n             id: id,\n             span: span,\n-            cat: Categorization::Deref(Rc::new(cmt_result), 0, env_ptr),\n+            cat: Categorization::Deref(Rc::new(cmt_result), env_ptr),\n             mutbl: deref_mutbl,\n             ty: var_ty,\n             note: NoteClosureEnv(upvar_id)\n@@ -932,78 +923,79 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n-    fn cat_deref<N:ast_node>(&self,\n-                             node: &N,\n-                             base_cmt: cmt<'tcx>,\n-                             deref_cnt: usize)\n+    fn cat_overloaded_lvalue(&self,\n+                             expr: &hir::Expr,\n+                             base: &hir::Expr,\n+                             implicit: bool)\n                              -> McResult<cmt<'tcx>> {\n-        let method_call = ty::MethodCall {\n-            expr_id: node.id(),\n-            autoderef: deref_cnt as u32\n-        };\n-        let method_ty = self.infcx.node_method_ty(method_call);\n+        debug!(\"cat_overloaded_lvalue: implicit={}\", implicit);\n \n-        debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n-               method_call, method_ty.map(|ty| ty));\n+        // Reconstruct the output assuming it's a reference with the\n+        // same region and mutability as the receiver. This holds for\n+        // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n+        let lvalue_ty = self.expr_ty(expr)?;\n+        let base_ty = self.expr_ty_adjusted(base)?;\n \n-        let base_cmt = match method_ty {\n-            Some(method_ty) => {\n-                let ref_ty =\n-                    self.tcx().no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-                self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n+        let (region, mutbl) = match base_ty.sty {\n+            ty::TyRef(region, mt) => (region, mt.mutbl),\n+            _ => {\n+                span_bug!(expr.span, \"cat_overloaded_lvalue: base is not a reference\")\n             }\n-            None => base_cmt\n         };\n+        let ref_ty = self.tcx().mk_ref(region, ty::TypeAndMut {\n+            ty: lvalue_ty,\n+            mutbl,\n+        });\n+\n+        let base_cmt = self.cat_rvalue_node(expr.id, expr.span, ref_ty);\n+        self.cat_deref(expr, base_cmt, implicit)\n+    }\n+\n+    pub fn cat_deref<N:ast_node>(&self,\n+                                 node: &N,\n+                                 base_cmt: cmt<'tcx>,\n+                                 implicit: bool)\n+                                 -> McResult<cmt<'tcx>> {\n+        debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n+\n         let base_cmt_ty = base_cmt.ty;\n-        match base_cmt_ty.builtin_deref(true, ty::NoPreference) {\n-            Some(mt) => {\n-                let ret = self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, false);\n-                debug!(\"cat_deref ret {:?}\", ret);\n-                Ok(ret)\n-            }\n+        let deref_ty = match base_cmt_ty.builtin_deref(true, ty::NoPreference) {\n+            Some(mt) => mt.ty,\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {:?}\",\n                        base_cmt_ty);\n                 return Err(());\n             }\n-        }\n-    }\n+        };\n \n-    fn cat_deref_common<N:ast_node>(&self,\n-                                    node: &N,\n-                                    base_cmt: cmt<'tcx>,\n-                                    deref_cnt: usize,\n-                                    deref_ty: Ty<'tcx>,\n-                                    implicit: bool)\n-                                    -> cmt<'tcx>\n-    {\n         let ptr = match base_cmt.ty.sty {\n             ty::TyAdt(def, ..) if def.is_box() => Unique,\n             ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n             ty::TyRef(r, mt) => {\n                 let bk = ty::BorrowKind::from_mutbl(mt.mutbl);\n                 if implicit { Implicit(bk, r) } else { BorrowedPtr(bk, r) }\n             }\n-            ref ty => bug!(\"unexpected type in cat_deref_common: {:?}\", ty)\n+            ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)\n         };\n         let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             // For unique ptrs, we inherit mutability from the owning reference.\n             mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n-            cat: Categorization::Deref(base_cmt, deref_cnt, ptr),\n+            cat: Categorization::Deref(base_cmt, ptr),\n             ty: deref_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_deref_common ret {:?}\", ret);\n-        ret\n+        debug!(\"cat_deref ret {:?}\", ret);\n+        Ok(ret)\n     }\n \n-    pub fn cat_index<N:ast_node>(&self,\n-                                 elt: &N,\n-                                 mut base_cmt: cmt<'tcx>,\n-                                 context: InteriorOffsetKind)\n-                                 -> McResult<cmt<'tcx>> {\n+    fn cat_index<N:ast_node>(&self,\n+                             elt: &N,\n+                             base_cmt: cmt<'tcx>,\n+                             element_ty: Ty<'tcx>,\n+                             context: InteriorOffsetKind)\n+                             -> McResult<cmt<'tcx>> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -1021,31 +1013,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         //! - `elt`: the AST node being indexed\n         //! - `base_cmt`: the cmt of `elt`\n \n-        let method_call = ty::MethodCall::expr(elt.id());\n-        let method_ty = self.infcx.node_method_ty(method_call);\n-\n-        let (element_ty, element_kind) = match method_ty {\n-            Some(method_ty) => {\n-                let ref_ty = self.overloaded_method_return_ty(method_ty);\n-                base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n-\n-                (ref_ty.builtin_deref(false, ty::NoPreference).unwrap().ty,\n-                 ElementKind::OtherElement)\n-            }\n-            None => {\n-                match base_cmt.ty.builtin_index() {\n-                    Some(ty) => (ty, ElementKind::VecElement),\n-                    None => {\n-                        debug!(\"Explicit index of non-indexable type {:?}\", base_cmt);\n-                        return Err(());\n-                    }\n-                }\n-            }\n-        };\n-\n-        let interior_elem = InteriorElement(context, element_kind);\n+        let interior_elem = InteriorElement(context);\n         let ret =\n-            self.cat_imm_interior(elt, base_cmt.clone(), element_ty, interior_elem);\n+            self.cat_imm_interior(elt, base_cmt, element_ty, interior_elem);\n         debug!(\"cat_index ret {:?}\", ret);\n         return Ok(ret);\n     }\n@@ -1235,13 +1205,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = self.cat_deref(pat, cmt, 0)?;\n+            let subcmt = self.cat_deref(pat, cmt, false)?;\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n           PatKind::Slice(ref before, ref slice, ref after) => {\n+            let element_ty = match cmt.ty.builtin_index() {\n+                Some(ty) => ty,\n+                None => {\n+                    debug!(\"Explicit index of non-indexable type {:?}\", cmt);\n+                    return Err(());\n+                }\n+            };\n             let context = InteriorOffsetKind::Pattern;\n-            let elt_cmt = self.cat_index(pat, cmt, context)?;\n+            let elt_cmt = self.cat_index(pat, cmt, element_ty, context)?;\n             for before_pat in before {\n                 self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n             }\n@@ -1261,19 +1238,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         Ok(())\n     }\n-\n-    fn overloaded_method_return_ty(&self,\n-                                   method_ty: Ty<'tcx>)\n-                                   -> Ty<'tcx>\n-    {\n-        // When we process an overloaded `*` or `[]` etc, we often\n-        // need to extract the return type of the method. These method\n-        // types are generated by method resolution and always have\n-        // all late-bound regions fully instantiated, so we just want\n-        // to skip past the binder.\n-        self.tcx().no_late_bound_regions(&method_ty.fn_ret())\n-           .unwrap()\n-    }\n }\n \n #[derive(Clone, Debug)]\n@@ -1300,15 +1264,15 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Rvalue(..) |\n             Categorization::StaticItem |\n             Categorization::Local(..) |\n-            Categorization::Deref(.., UnsafePtr(..)) |\n-            Categorization::Deref(.., BorrowedPtr(..)) |\n-            Categorization::Deref(.., Implicit(..)) |\n+            Categorization::Deref(_, UnsafePtr(..)) |\n+            Categorization::Deref(_, BorrowedPtr(..)) |\n+            Categorization::Deref(_, Implicit(..)) |\n             Categorization::Upvar(..) => {\n                 Rc::new((*self).clone())\n             }\n             Categorization::Downcast(ref b, _) |\n             Categorization::Interior(ref b, _) |\n-            Categorization::Deref(ref b, _, Unique) => {\n+            Categorization::Deref(ref b, Unique) => {\n                 b.guarantor()\n             }\n         }\n@@ -1321,11 +1285,11 @@ impl<'tcx> cmt_<'tcx> {\n         // aliased and eventually recused.\n \n         match self.cat {\n-            Categorization::Deref(ref b, _, BorrowedPtr(ty::MutBorrow, _)) |\n-            Categorization::Deref(ref b, _, Implicit(ty::MutBorrow, _)) |\n-            Categorization::Deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n-            Categorization::Deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n-            Categorization::Deref(ref b, _, Unique) |\n+            Categorization::Deref(ref b, BorrowedPtr(ty::MutBorrow, _)) |\n+            Categorization::Deref(ref b, Implicit(ty::MutBorrow, _)) |\n+            Categorization::Deref(ref b, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n+            Categorization::Deref(ref b, Implicit(ty::UniqueImmBorrow, _)) |\n+            Categorization::Deref(ref b, Unique) |\n             Categorization::Downcast(ref b, _) |\n             Categorization::Interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n@@ -1335,7 +1299,7 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Rvalue(..) |\n             Categorization::Local(..) |\n             Categorization::Upvar(..) |\n-            Categorization::Deref(.., UnsafePtr(..)) => { // yes, it's aliasable, but...\n+            Categorization::Deref(_, UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 NonAliasable\n             }\n \n@@ -1347,8 +1311,8 @@ impl<'tcx> cmt_<'tcx> {\n                 }\n             }\n \n-            Categorization::Deref(_, _, BorrowedPtr(ty::ImmBorrow, _)) |\n-            Categorization::Deref(_, _, Implicit(ty::ImmBorrow, _)) => {\n+            Categorization::Deref(_, BorrowedPtr(ty::ImmBorrow, _)) |\n+            Categorization::Deref(_, Implicit(ty::ImmBorrow, _)) => {\n                 FreelyAliasable(AliasableBorrowed)\n             }\n         }\n@@ -1360,9 +1324,9 @@ impl<'tcx> cmt_<'tcx> {\n         match self.note {\n             NoteClosureEnv(..) | NoteUpvarRef(..) => {\n                 Some(match self.cat {\n-                    Categorization::Deref(ref inner, ..) => {\n+                    Categorization::Deref(ref inner, _) => {\n                         match inner.cat {\n-                            Categorization::Deref(ref inner, ..) => inner.clone(),\n+                            Categorization::Deref(ref inner, _) => inner.clone(),\n                             Categorization::Upvar(..) => inner.clone(),\n                             _ => bug!()\n                         }\n@@ -1390,7 +1354,7 @@ impl<'tcx> cmt_<'tcx> {\n                     \"local variable\".to_string()\n                 }\n             }\n-            Categorization::Deref(.., pk) => {\n+            Categorization::Deref(_, pk) => {\n                 let upvar = self.upvar();\n                 match upvar.as_ref().map(|i| &i.cat) {\n                     Some(&Categorization::Upvar(ref var)) => {\n@@ -1421,16 +1385,10 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Interior(_, InteriorField(PositionalField(_))) => {\n                 \"anonymous field\".to_string()\n             }\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index,\n-                                                        VecElement)) |\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index,\n-                                                        OtherElement)) => {\n+            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index)) => {\n                 \"indexed content\".to_string()\n             }\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n-                                                        VecElement)) |\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n-                                                        OtherElement)) => {\n+            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern)) => {\n                 \"pattern-bound indexed content\".to_string()\n             }\n             Categorization::Upvar(ref var) => {\n@@ -1467,8 +1425,8 @@ impl<'tcx> fmt::Debug for Categorization<'tcx> {\n             Categorization::Upvar(upvar) => {\n                 write!(f, \"upvar({:?})\", upvar)\n             }\n-            Categorization::Deref(ref cmt, derefs, ptr) => {\n-                write!(f, \"{:?}-{:?}{}->\", cmt.cat, ptr, derefs)\n+            Categorization::Deref(ref cmt, ptr) => {\n+                write!(f, \"{:?}-{:?}->\", cmt.cat, ptr)\n             }\n             Categorization::Interior(ref cmt, interior) => {\n                 write!(f, \"{:?}.{:?}\", cmt.cat, interior)"}, {"sha": "c2f69147e3a563c64e0c87794debfdf7d1ff20b6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -110,9 +110,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n                 Some(self.tables.qpath_def(qpath, expr.id))\n             }\n             hir::ExprMethodCall(..) => {\n-                let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tables.method_map[&method_call].def_id;\n-                Some(Def::Method(def_id))\n+                Some(self.tables.type_dependent_defs[&expr.id])\n             }\n             _ => None\n         };"}, {"sha": "62d137475f90e9797b10bbc0e17611f84584d541", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 83, "deletions": 139, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -8,21 +8,59 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::{self, Ty, TyCtxt, TypeAndMut};\n-use ty::LvaluePreference::{NoPreference};\n-\n-use syntax::ast;\n-use syntax_pos::Span;\n-\n use hir;\n+use hir::def_id::DefId;\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::Substs;\n+\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+/// Represents coercing a value to a different type of value.\n+///\n+/// We transform values by following a number of `Adjust` steps in order.\n+/// See the documentation on variants of `Adjust` for more details.\n+///\n+/// Here are some common scenarios:\n+///\n+/// 1. The simplest cases are where a pointer is not adjusted fat vs thin.\n+/// Here the pointer will be dereferenced N times (where a dereference can\n+/// happen to raw or borrowed pointers or any smart pointer which implements\n+/// Deref, including Box<_>). The types of dereferences is given by\n+/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+/// `false`.\n+///\n+/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+/// with a thin pointer, deref a number of times, unsize the underlying data,\n+/// then autoref. The 'unsize' phase may change a fixed length array to a\n+/// dynamically sized one, a concrete object to a trait object, or statically\n+/// sized struct to a dynamically sized one. E.g., &[i32; 4] -> &[i32] is\n+/// represented by:\n+///\n+/// ```\n+/// Deref(None) -> [i32; 4],\n+/// Borrow(AutoBorrow::Ref) -> &[i32; 4],\n+/// Unsize -> &[i32],\n+/// ```\n+///\n+/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+/// The autoderef and -ref are the same as in the above example, but the type\n+/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+/// the underlying conversions from `[i32; 4]` to `[i32]`.\n+///\n+/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+/// that case, we have the pointer we need coming in, so there are no\n+/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+/// At some point, of course, `Box` should move out of the compiler, in which\n+/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+/// Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Adjustment<'tcx> {\n     pub kind: Adjust<'tcx>,\n-    pub target: Ty<'tcx>\n+    pub target: Ty<'tcx>,\n }\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum Adjust<'tcx> {\n     /// Go from ! to any type.\n     NeverToAny,\n@@ -39,94 +77,45 @@ pub enum Adjust<'tcx> {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n-    /// Represents coercing a pointer to a different kind of pointer - where 'kind'\n-    /// here means either or both of raw vs borrowed vs unique and fat vs thin.\n-    ///\n-    /// We transform pointers by following the following steps in order:\n-    /// 1. Deref the pointer `self.autoderefs` times (may be 0).\n-    /// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n-    ///    `&` or `*` pointer.\n-    /// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n-    ///    which will do things like convert thin pointers to fat\n-    ///    pointers, or convert structs containing thin pointers to\n-    ///    structs containing fat pointers, or convert between fat\n-    ///    pointers.  We don't store the details of how the transform is\n-    ///    done (in fact, we don't know that, because it might depend on\n-    ///    the precise type parameters). We just store the target\n-    ///    type. Trans figures out what has to be done at monomorphization\n-    ///    time based on the precise source/target type at hand.\n-    ///\n-    /// To make that more concrete, here are some common scenarios:\n-    ///\n-    /// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n-    /// Here the pointer will be dereferenced N times (where a dereference can\n-    /// happen to raw or borrowed pointers or any smart pointer which implements\n-    /// Deref, including Box<_>). The number of dereferences is given by\n-    /// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n-    /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-    /// None.\n-    ///\n-    /// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n-    /// with a thin pointer, deref a number of times, unsize the underlying data,\n-    /// then autoref. The 'unsize' phase may change a fixed length array to a\n-    /// dynamically sized one, a concrete object to a trait object, or statically\n-    /// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n-    /// represented by:\n-    ///\n-    /// ```\n-    /// Adjust::DerefRef {\n-    ///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n-    ///     autoref: Some(AutoBorrow::Ref), // [i32] -> &[i32]\n-    ///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n-    /// }\n-    /// ```\n-    ///\n-    /// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n-    /// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n-    /// The autoderef and -ref are the same as in the above example, but the type\n-    /// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n-    /// the underlying conversions from `[i32; 4]` to `[i32]`.\n-    ///\n-    /// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n-    /// that case, we have the pointer we need coming in, so there are no\n-    /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n-    /// At some point, of course, `Box` should move out of the compiler, in which\n-    /// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n-    /// Box<[i32]> is represented by:\n-    ///\n-    /// ```\n-    /// Adjust::DerefRef {\n-    ///     autoderefs: 0,\n-    ///     autoref: None,\n-    ///     unsize: Some(Box<[i32]>),\n-    /// }\n-    /// ```\n-    DerefRef {\n-        /// Step 1. Apply a number of dereferences, producing an lvalue.\n-        autoderefs: usize,\n-\n-        /// Step 2. Optionally produce a pointer/reference from the value.\n-        autoref: Option<AutoBorrow<'tcx>>,\n-\n-        /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n-        /// `&[T]`. Note that the source could be a thin or fat pointer.\n-        unsize: bool,\n-    }\n+    /// Dereference once, producing an lvalue.\n+    Deref(Option<OverloadedDeref<'tcx>>),\n+\n+    /// Take the address and produce either a `&` or `*` pointer.\n+    Borrow(AutoBorrow<'tcx>),\n+\n+    /// Unsize a pointer/reference value, e.g. `&[T; n]` to\n+    /// `&[T]`. Note that the source could be a thin or fat pointer.\n+    /// This will do things like convert thin pointers to fat\n+    /// pointers, or convert structs containing thin pointers to\n+    /// structs containing fat pointers, or convert between fat\n+    /// pointers.  We don't store the details of how the transform is\n+    /// done (in fact, we don't know that, because it might depend on\n+    /// the precise type parameters). We just store the target\n+    /// type. Trans figures out what has to be done at monomorphization\n+    /// time based on the precise source/target type at hand.\n+    Unsize,\n }\n \n-impl<'tcx> Adjustment<'tcx> {\n-    pub fn is_identity(&self) -> bool {\n-        match self.kind {\n-            Adjust::NeverToAny => self.target.is_never(),\n-\n-            Adjust::DerefRef { autoderefs: 0, autoref: None, unsize: false } => true,\n+/// An overloaded autoderef step, representing a `Deref(Mut)::deref(_mut)`\n+/// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n+/// The target type is `U` in both cases, with the region and mutability\n+/// being those shared by both the receiver and the returned reference.\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub struct OverloadedDeref<'tcx> {\n+    pub region: ty::Region<'tcx>,\n+    pub mutbl: hir::Mutability,\n+}\n \n-            Adjust::ReifyFnPointer |\n-            Adjust::UnsafeFnPointer |\n-            Adjust::ClosureFnPointer |\n-            Adjust::MutToConstPointer |\n-            Adjust::DerefRef {..} => false,\n-        }\n+impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n+    pub fn method_call(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, source: Ty<'tcx>)\n+                       -> (DefId, &'tcx Substs<'tcx>) {\n+        let trait_def_id = match self.mutbl {\n+            hir::MutImmutable => tcx.lang_items.deref_trait(),\n+            hir::MutMutable => tcx.lang_items.deref_mut_trait()\n+        };\n+        let method_def_id = tcx.associated_items(trait_def_id.unwrap())\n+            .find(|m| m.kind == ty::AssociatedKind::Method).unwrap().def_id;\n+        (method_def_id, tcx.mk_substs_trait(source, &[]))\n     }\n }\n \n@@ -159,48 +148,3 @@ pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced.\n     Struct(usize)\n }\n-\n-impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n-    pub fn adjust_for_autoderef<F>(&'tcx self,\n-                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   expr_id: ast::NodeId,\n-                                   expr_span: Span,\n-                                   autoderef: u32, // how many autoderefs so far?\n-                                   mut method_type: F)\n-                                   -> Ty<'tcx> where\n-        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n-    {\n-        let method_call = ty::MethodCall::autoderef(expr_id, autoderef);\n-        let mut adjusted_ty = self;\n-        if let Some(method_ty) = method_type(method_call) {\n-            // Method calls always have all late-bound regions\n-            // fully instantiated.\n-            adjusted_ty = tcx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n-        }\n-        match adjusted_ty.builtin_deref(true, NoPreference) {\n-            Some(mt) => mt.ty,\n-            None => {\n-                span_bug!(\n-                    expr_span,\n-                    \"the {}th autoderef for {} failed: {}\",\n-                    autoderef,\n-                    expr_id,\n-                    adjusted_ty);\n-            }\n-        }\n-    }\n-\n-    pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              autoref: Option<AutoBorrow<'tcx>>)\n-                              -> Ty<'tcx> {\n-        match autoref {\n-            None => self,\n-            Some(AutoBorrow::Ref(r, m)) => {\n-                tcx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n-            }\n-            Some(AutoBorrow::RawPtr(m)) => {\n-                tcx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n-            }\n-        }\n-    }\n-}"}, {"sha": "e0e195867131f65e23a50661ce826ded95398aac", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -206,8 +206,9 @@ pub struct CommonTypes<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TypeckTables<'tcx> {\n-    /// Resolved definitions for `<T>::X` associated paths.\n-    pub type_relative_path_defs: NodeMap<Def>,\n+    /// Resolved definitions for `<T>::X` associated paths and\n+    /// method calls, including those of overloaded operators.\n+    pub type_dependent_defs: NodeMap<Def>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n@@ -218,11 +219,9 @@ pub struct TypeckTables<'tcx> {\n     /// of this node.  This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n-    pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n+    pub node_substs: NodeMap<&'tcx Substs<'tcx>>,\n \n-    pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n-\n-    pub method_map: ty::MethodMap<'tcx>,\n+    pub adjustments: NodeMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n@@ -271,11 +270,10 @@ pub struct TypeckTables<'tcx> {\n impl<'tcx> TypeckTables<'tcx> {\n     pub fn empty() -> TypeckTables<'tcx> {\n         TypeckTables {\n-            type_relative_path_defs: NodeMap(),\n+            type_dependent_defs: NodeMap(),\n             node_types: FxHashMap(),\n-            item_substs: NodeMap(),\n+            node_substs: NodeMap(),\n             adjustments: NodeMap(),\n-            method_map: FxHashMap(),\n             upvar_capture_map: FxHashMap(),\n             closure_tys: NodeMap(),\n             closure_kinds: NodeMap(),\n@@ -294,7 +292,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.def,\n             hir::QPath::TypeRelative(..) => {\n-                self.type_relative_path_defs.get(&id).cloned().unwrap_or(Def::Err)\n+                self.type_dependent_defs.get(&id).cloned().unwrap_or(Def::Err)\n             }\n         }\n     }\n@@ -313,8 +311,8 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_types.get(&id).cloned()\n     }\n \n-    pub fn node_id_item_substs(&self, id: NodeId) -> Option<&'tcx Substs<'tcx>> {\n-        self.item_substs.get(&id).map(|ts| ts.substs)\n+    pub fn node_substs(&self, id: NodeId) -> &'tcx Substs<'tcx> {\n+        self.node_substs.get(&id).cloned().unwrap_or(Substs::empty())\n     }\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n@@ -345,24 +343,37 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_id_to_type_opt(expr.id)\n     }\n \n+    pub fn expr_adjustments(&self, expr: &hir::Expr)\n+                            -> &[ty::adjustment::Adjustment<'tcx>] {\n+        self.adjustments.get(&expr.id).map_or(&[], |a| &a[..])\n+    }\n+\n     /// Returns the type of `expr`, considering any `Adjustment`\n     /// entry recorded for that expression.\n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n-        self.adjustments.get(&expr.id)\n+        self.expr_adjustments(expr)\n+            .last()\n             .map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n     }\n \n     pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n-        self.adjustments.get(&expr.id)\n-            .map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+        self.expr_adjustments(expr)\n+            .last()\n+            .map(|adj| adj.target)\n+            .or_else(|| self.expr_ty_opt(expr))\n     }\n \n-    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n-        self.method_map.contains_key(&ty::MethodCall::expr(expr_id))\n-    }\n+    pub fn is_method_call(&self, expr: &hir::Expr) -> bool {\n+        // Only paths and method calls/overloaded operators have\n+        // entries in type_dependent_defs, ignore the former here.\n+        if let hir::ExprPath(_) = expr.node {\n+            return false;\n+        }\n \n-    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n-        self.method_map.contains_key(&ty::MethodCall::autoderef(expr_id, autoderefs))\n+        match self.type_dependent_defs.get(&expr.id) {\n+            Some(&Def::Method(_)) => true,\n+            _ => false\n+        }\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {"}, {"sha": "bb13031a2b7c4ac0580771dc4c1acd5a326b5ff1", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -39,8 +39,6 @@\n //! These methods return true to indicate that the visitor has found what it is looking for\n //! and does not need to visit anything else.\n \n-use ty::subst::Substs;\n-use ty::adjustment;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::fmt;\n@@ -138,34 +136,9 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_mt(&mut self, t: &ty::TypeAndMut<'tcx>) -> ty::TypeAndMut<'tcx> {\n-        t.super_fold_with(self)\n-    }\n-\n-    fn fold_impl_header(&mut self, imp: &ty::ImplHeader<'tcx>) -> ty::ImplHeader<'tcx> {\n-        imp.super_fold_with(self)\n-    }\n-\n-    fn fold_substs(&mut self,\n-                   substs: &'tcx Substs<'tcx>)\n-                   -> &'tcx Substs<'tcx> {\n-        substs.super_fold_with(self)\n-    }\n-\n-    fn fold_fn_sig(&mut self,\n-                   sig: &ty::FnSig<'tcx>)\n-                   -> ty::FnSig<'tcx> {\n-        sig.super_fold_with(self)\n-    }\n-\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         r.super_fold_with(self)\n     }\n-\n-    fn fold_autoref(&mut self, ar: &adjustment::AutoBorrow<'tcx>)\n-                    -> adjustment::AutoBorrow<'tcx> {\n-        ar.super_fold_with(self)\n-    }\n }\n \n pub trait TypeVisitor<'tcx> : Sized {"}, {"sha": "b495b5ee81a9a644fb759262a7c4836e14d58e14", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -390,52 +390,6 @@ impl Variance {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n-pub struct MethodCallee<'tcx> {\n-    /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n-    pub def_id: DefId,\n-    pub ty: Ty<'tcx>,\n-    pub substs: &'tcx Substs<'tcx>\n-}\n-\n-/// With method calls, we store some extra information in\n-/// side tables (i.e method_map). We use\n-/// MethodCall as a key to index into these tables instead of\n-/// just directly using the expression's NodeId. The reason\n-/// for this being that we may apply adjustments (coercions)\n-/// with the resulting expression also needing to use the\n-/// side tables. The problem with this is that we don't\n-/// assign a separate NodeId to this new expression\n-/// and so it would clash with the base expression if both\n-/// needed to add to the side tables. Thus to disambiguate\n-/// we also keep track of whether there's an adjustment in\n-/// our key.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct MethodCall {\n-    pub expr_id: NodeId,\n-    pub autoderef: u32\n-}\n-\n-impl MethodCall {\n-    pub fn expr(id: NodeId) -> MethodCall {\n-        MethodCall {\n-            expr_id: id,\n-            autoderef: 0\n-        }\n-    }\n-\n-    pub fn autoderef(expr_id: NodeId, autoderef: u32) -> MethodCall {\n-        MethodCall {\n-            expr_id: expr_id,\n-            autoderef: 1 + autoderef\n-        }\n-    }\n-}\n-\n-// maps from an expression id that corresponds to a method call to the details\n-// of the method to be invoked\n-pub type MethodMap<'tcx> = FxHashMap<MethodCall, MethodCallee<'tcx>>;\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -1843,13 +1797,6 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     }\n }\n \n-/// Records the substitutions used to translate the polytype for an\n-/// item into the monotype of an item reference.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct ItemSubsts<'tcx> {\n-    pub substs: &'tcx Substs<'tcx>,\n-}\n-\n #[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum ClosureKind {\n     // Warning: Ordering is significant here! The ordering is chosen\n@@ -1927,12 +1874,6 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-impl<'tcx> ItemSubsts<'tcx> {\n-    pub fn is_noop(&self) -> bool {\n-        self.substs.is_noop()\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum LvaluePreference {\n     PreferMutLvalue,"}, {"sha": "3a6147f911cce9192ea0593ae9bac921f559d62a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 98, "deletions": 25, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -217,12 +217,50 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::ItemSubsts<'a> {\n-    type Lifted = ty::ItemSubsts<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n+    type Lifted = ty::adjustment::Adjustment<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| {\n-            ty::ItemSubsts {\n-                substs: substs\n+        tcx.lift(&self.kind).and_then(|kind| {\n+            tcx.lift(&self.target).map(|target| {\n+                ty::adjustment::Adjustment { kind, target }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n+    type Lifted = ty::adjustment::Adjust<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny =>\n+                Some(ty::adjustment::Adjust::NeverToAny),\n+            ty::adjustment::Adjust::ReifyFnPointer =>\n+                Some(ty::adjustment::Adjust::ReifyFnPointer),\n+            ty::adjustment::Adjust::UnsafeFnPointer =>\n+                Some(ty::adjustment::Adjust::UnsafeFnPointer),\n+            ty::adjustment::Adjust::ClosureFnPointer =>\n+                Some(ty::adjustment::Adjust::ClosureFnPointer),\n+            ty::adjustment::Adjust::MutToConstPointer =>\n+                Some(ty::adjustment::Adjust::MutToConstPointer),\n+            ty::adjustment::Adjust::Unsize =>\n+                Some(ty::adjustment::Adjust::Unsize),\n+            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+                tcx.lift(overloaded).map(ty::adjustment::Adjust::Deref)\n+            }\n+            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+                tcx.lift(autoref).map(ty::adjustment::Adjust::Borrow)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n+    type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.region).map(|region| {\n+            ty::adjustment::OverloadedDeref {\n+                region,\n+                mutbl: self.mutbl,\n             }\n         })\n     }\n@@ -540,10 +578,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n         ty::TypeAndMut { ty: self.ty.fold_with(folder), mutbl: self.mutbl }\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_mt(self)\n-    }\n-\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.ty.visit_with(visitor)\n     }\n@@ -560,10 +594,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n         }\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_fn_sig(self)\n-    }\n-\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.inputs().iter().any(|i| i.visit_with(visitor)) ||\n         self.output().visit_with(visitor)\n@@ -610,10 +640,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n         }\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_impl_header(self)\n-    }\n-\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.self_ty.visit_with(visitor) ||\n             self.trait_ref.map(|r| r.visit_with(visitor)).unwrap_or(false) ||\n@@ -651,15 +677,66 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjustment<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ItemSubsts {\n-            substs: self.substs.fold_with(folder),\n+        ty::adjustment::Adjustment {\n+            kind: self.kind.fold_with(folder),\n+            target: self.target.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor)\n+        self.kind.visit_with(visitor) ||\n+        self.target.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjust<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny |\n+            ty::adjustment::Adjust::ReifyFnPointer |\n+            ty::adjustment::Adjust::UnsafeFnPointer |\n+            ty::adjustment::Adjust::ClosureFnPointer |\n+            ty::adjustment::Adjust::MutToConstPointer |\n+            ty::adjustment::Adjust::Unsize => self.clone(),\n+            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+                ty::adjustment::Adjust::Deref(overloaded.fold_with(folder))\n+            }\n+            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+                ty::adjustment::Adjust::Borrow(autoref.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ty::adjustment::Adjust::NeverToAny |\n+            ty::adjustment::Adjust::ReifyFnPointer |\n+            ty::adjustment::Adjust::UnsafeFnPointer |\n+            ty::adjustment::Adjust::ClosureFnPointer |\n+            ty::adjustment::Adjust::MutToConstPointer |\n+            ty::adjustment::Adjust::Unsize => false,\n+            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+                overloaded.visit_with(visitor)\n+            }\n+            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+                autoref.visit_with(visitor)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::OverloadedDeref<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::adjustment::OverloadedDeref {\n+            region: self.region.fold_with(folder),\n+            mutbl: self.mutbl,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.region.visit_with(visitor)\n     }\n }\n \n@@ -673,10 +750,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n         }\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_autoref(self)\n-    }\n-\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n             ty::adjustment::AutoBorrow::Ref(r, _m) => r.visit_with(visitor),"}, {"sha": "0925a4032fba3ca2472e03629c5a9f0a346ef182", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -141,8 +141,6 @@ pub enum TypeVariants<'tcx> {\n     TyFnDef(DefId, &'tcx Substs<'tcx>, PolyFnSig<'tcx>),\n \n     /// A pointer to a function.  Written as `fn() -> i32`.\n-    /// FIXME: This is currently also used to represent the callee of a method;\n-    /// see ty::MethodCallee etc.\n     TyFnPtr(PolyFnSig<'tcx>),\n \n     /// A trait, defined with `trait`.\n@@ -1338,15 +1336,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Type accessors for substructures of types\n-    pub fn fn_args(&self) -> ty::Binder<&'tcx [Ty<'tcx>]> {\n-        self.fn_sig().inputs()\n-    }\n-\n-    pub fn fn_ret(&self) -> Binder<Ty<'tcx>> {\n-        self.fn_sig().output()\n-    }\n-\n     pub fn is_fn(&self) -> bool {\n         match self.sty {\n             TyFnDef(..) | TyFnPtr(_) => true,"}, {"sha": "d0d61323392c732c983c288867e814a2219efaa4", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -320,10 +320,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n         }\n     }\n \n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_substs(self)\n-    }\n-\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.iter().any(|t| t.visit_with(visitor))\n     }"}, {"sha": "15fbeb5108fdb26654da9de941aaba81eef71b33", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -363,12 +363,6 @@ impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ItemSubsts<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ItemSubsts({:?})\", self.substs)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // when printing out the debug representation, we don't need"}, {"sha": "0fe8865f4a268a6c4f5d682d2892a389afc639de", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -805,7 +805,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.check_if_assigned_path_is_moved(id, span,\n                                                      use_kind, lp_base);\n             }\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement(..))) |\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) |\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // assigning to `P[i]` requires `P` is initialized\n                 // assigning to `(*P)` requires `P` is initialized"}, {"sha": "3d98c2a23dc674317b619c96c502830c16a9b624", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -222,9 +222,9 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                cmt: &mc::cmt<'tcx>)\n                                                -> Option<mc::cmt<'tcx>> {\n     match cmt.cat {\n-        Categorization::Deref(.., mc::BorrowedPtr(..)) |\n-        Categorization::Deref(.., mc::Implicit(..)) |\n-        Categorization::Deref(.., mc::UnsafePtr(..)) |\n+        Categorization::Deref(_, mc::BorrowedPtr(..)) |\n+        Categorization::Deref(_, mc::Implicit(..)) |\n+        Categorization::Deref(_, mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n             Some(cmt.clone())\n         }\n@@ -237,7 +237,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) |\n-        Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n+        Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern)) => {\n             match b.ty.sty {\n                 ty::TyAdt(def, _) => {\n                     if def.has_dtor(bccx.tcx) {\n@@ -253,12 +253,12 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             }\n         }\n \n-        Categorization::Interior(_, mc::InteriorElement(Kind::Index, _)) => {\n+        Categorization::Interior(_, mc::InteriorElement(Kind::Index)) => {\n             // Forbid move of arr[i] for arr: [T; 3]; see RFC 533.\n             Some(cmt.clone())\n         }\n \n-        Categorization::Deref(ref b, _, mc::Unique) => {\n+        Categorization::Deref(ref b, mc::Unique) => {\n             check_and_get_illegal_move_origin(bccx, b)\n         }\n     }"}, {"sha": "0a6375ab187d6c82da980442163ccb3241a4436f", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -72,11 +72,11 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n         match cmt.cat {\n             Categorization::Rvalue(..) |\n-            Categorization::Local(..) |                         // L-Local\n+            Categorization::Local(..) |                     // L-Local\n             Categorization::Upvar(..) |\n-            Categorization::Deref(.., mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n-            Categorization::Deref(.., mc::Implicit(..)) |\n-            Categorization::Deref(.., mc::UnsafePtr(..)) => {\n+            Categorization::Deref(_, mc::BorrowedPtr(..)) | // L-Deref-Borrowed\n+            Categorization::Deref(_, mc::Implicit(..)) |\n+            Categorization::Deref(_, mc::UnsafePtr(..)) => {\n                 self.check_scope(self.scope(cmt))\n             }\n \n@@ -85,8 +85,8 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             }\n \n             Categorization::Downcast(ref base, _) |\n-            Categorization::Deref(ref base, _, mc::Unique) |     // L-Deref-Send\n-            Categorization::Interior(ref base, _) => {             // L-Field\n+            Categorization::Deref(ref base, mc::Unique) |   // L-Deref-Send\n+            Categorization::Interior(ref base, _) => {      // L-Field\n                 self.check(base, discr_scope)\n             }\n         }\n@@ -119,15 +119,15 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                     self.bccx.region_maps.var_scope(local_id)))\n             }\n             Categorization::StaticItem |\n-            Categorization::Deref(.., mc::UnsafePtr(..)) => {\n+            Categorization::Deref(_, mc::UnsafePtr(..)) => {\n                 self.bccx.tcx.types.re_static\n             }\n-            Categorization::Deref(.., mc::BorrowedPtr(_, r)) |\n-            Categorization::Deref(.., mc::Implicit(_, r)) => {\n+            Categorization::Deref(_, mc::BorrowedPtr(_, r)) |\n+            Categorization::Deref(_, mc::Implicit(_, r)) => {\n                 r\n             }\n             Categorization::Downcast(ref cmt, _) |\n-            Categorization::Deref(ref cmt, _, mc::Unique) |\n+            Categorization::Deref(ref cmt, mc::Unique) |\n             Categorization::Interior(ref cmt, _) => {\n                 self.scope(cmt)\n             }"}, {"sha": "cceb4a7b3cc2180a1d41e9354d4298ac78c85445", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -138,9 +138,9 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_from: mc::cmt<'tcx>)\n                                        -> DiagnosticBuilder<'a> {\n     match move_from.cat {\n-        Categorization::Deref(.., mc::BorrowedPtr(..)) |\n-        Categorization::Deref(.., mc::Implicit(..)) |\n-        Categorization::Deref(.., mc::UnsafePtr(..)) |\n+        Categorization::Deref(_, mc::BorrowedPtr(..)) |\n+        Categorization::Deref(_, mc::Implicit(..)) |\n+        Categorization::Deref(_, mc::UnsafePtr(..)) |\n         Categorization::StaticItem => {\n             let mut err = struct_span_err!(bccx, move_from.span, E0507,\n                              \"cannot move out of {}\",\n@@ -152,7 +152,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             err\n         }\n \n-        Categorization::Interior(ref b, mc::InteriorElement(ik, _)) => {\n+        Categorization::Interior(ref b, mc::InteriorElement(ik)) => {\n             match (&b.ty.sty, ik) {\n                 (&ty::TySlice(..), _) |\n                 (_, Kind::Index) => {"}, {"sha": "b7965f81b8826e3e0a8b28d2cafb2d04699179fc", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 RestrictionResult::Safe\n             }\n \n-            Categorization::Deref(cmt_base, _, pk) => {\n+            Categorization::Deref(cmt_base, pk) => {\n                 match pk {\n                     mc::Unique => {\n                         // R-Deref-Send-Pointer"}, {"sha": "2b5bbe0e8a5dff88768b95601794620625f48ee6", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -284,15 +284,15 @@ const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(mc::FieldName),\n-    InteriorElement(mc::ElementKind),\n+    InteriorElement,\n }\n \n trait ToInteriorKind { fn cleaned(self) -> InteriorKind; }\n impl ToInteriorKind for mc::InteriorKind {\n     fn cleaned(self) -> InteriorKind {\n         match self {\n             mc::InteriorField(name) => InteriorField(name),\n-            mc::InteriorElement(_, elem_kind) => InteriorElement(elem_kind),\n+            mc::InteriorElement(_) => InteriorElement,\n         }\n     }\n }\n@@ -426,7 +426,7 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n             Some(new_lp(LpUpvar(id)))\n         }\n \n-        Categorization::Deref(ref cmt_base, _, pk) => {\n+        Categorization::Deref(ref cmt_base, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n                 new_lp(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n             })\n@@ -1232,7 +1232,7 @@ before rustc 1.16, this temporary lived longer - see issue #39283 \\\n                 }\n             }\n \n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement(..))) => {\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 out.push_str(\"[..]\");\n             }\n@@ -1318,7 +1318,7 @@ impl<'tcx> fmt::Debug for InteriorKind {\n         match *self {\n             InteriorField(mc::NamedField(fld)) => write!(f, \"{}\", fld),\n             InteriorField(mc::PositionalField(i)) => write!(f, \"#{}\", i),\n-            InteriorElement(..) => write!(f, \"[]\"),\n+            InteriorElement => write!(f, \"[]\"),\n         }\n     }\n }"}, {"sha": "0a31905c7928af79c050177a1653ee84d1bb135b", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -191,7 +191,7 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n         LpVar(_) | LpUpvar(_) => {\n             true\n         }\n-        LpExtend(.., LpInterior(_, InteriorKind::InteriorElement(..))) => {\n+        LpExtend(.., LpInterior(_, InteriorKind::InteriorElement)) => {\n             // Paths involving element accesses a[i] do not refer to a unique\n             // location, as there is no accurate tracking of the indices.\n             //"}, {"sha": "a6b39f22277de0c852024512b15f0ca6c43d3c06", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -286,8 +286,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-        let substs = cx.tables.node_id_item_substs(e.id)\n-            .unwrap_or_else(|| tcx.intern_substs(&[]));\n+        let substs = cx.tables.node_substs(e.id);\n \n         // Avoid applying substitutions if they're empty, that'd ICE.\n         let substs = if cx.substs.is_empty() {"}, {"sha": "d175920e8a6baf895abb18522c26e55295cf5954", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -584,8 +584,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let tcx = self.tcx.global_tcx();\n-                let substs = self.tables.node_id_item_substs(id)\n-                    .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                let substs = self.tables.node_substs(id);\n                 match eval::lookup_const_by_id(tcx, def_id, substs) {\n                     Some((def_id, _substs)) => {\n                         // Enter the inlined constant's tables temporarily."}, {"sha": "12bfb1e02cf6f48cfefa41a7291706a54fb9b6b2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -881,39 +881,45 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                                       -> bool {\n             use rustc::ty::adjustment::*;\n \n-            // Check for method calls and overloaded operators.\n-            let opt_m = cx.tables.method_map.get(&ty::MethodCall::expr(id)).cloned();\n-            if let Some(m) = opt_m {\n-                if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n-                    return true;\n-                }\n-            }\n+            // Ignore non-expressions.\n+            let expr = if let hir_map::NodeExpr(e) = cx.tcx.hir.get(id) {\n+                e\n+            } else {\n+                return false;\n+            };\n \n             // Check for overloaded autoderef method calls.\n-            let opt_adj = cx.tables.adjustments.get(&id).cloned();\n-            if let Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) = opt_adj {\n-                for i in 0..autoderefs {\n-                    let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = cx.tables.method_map.get(&method_call).cloned() {\n-                        if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n-                            return true;\n-                        }\n+            let mut source = cx.tables.expr_ty(expr);\n+            for adjustment in cx.tables.expr_adjustments(expr) {\n+                if let Adjust::Deref(Some(deref)) = adjustment.kind {\n+                    let (def_id, substs) = deref.method_call(cx.tcx, source);\n+                    if method_call_refers_to_method(cx.tcx, method, def_id, substs, id) {\n+                        return true;\n                     }\n                 }\n+                source = adjustment.target;\n+            }\n+\n+            // Check for method calls and overloaded operators.\n+            if cx.tables.is_method_call(expr) {\n+                let def_id = cx.tables.type_dependent_defs[&id].def_id();\n+                let substs = cx.tables.node_substs(id);\n+                if method_call_refers_to_method(cx.tcx, method, def_id, substs, id) {\n+                    return true;\n+                }\n             }\n \n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n-            match cx.tcx.hir.get(id) {\n-                hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n+            match expr.node {\n+                hir::ExprCall(ref callee, _) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.id)\n                     } else {\n                         return false;\n                     };\n                     match def {\n                         Def::Method(def_id) => {\n-                            let substs = cx.tables.node_id_item_substs(callee.id)\n-                                .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n+                            let substs = cx.tables.node_substs(callee.id);\n                             method_call_refers_to_method(\n                                 cx.tcx, method, def_id, substs, id)\n                         }"}, {"sha": "0c82679c307d3ad0c2cdd665689cd53cd90388a1", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -468,21 +468,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n             _ => return,\n         }\n \n-        if let Some(adjustment) = cx.tables.adjustments.get(&e.id) {\n-            if let adjustment::Adjust::DerefRef { autoref, .. } = adjustment.kind {\n-                match autoref {\n-                    Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION,\n-                                     e.span,\n-                                     \"unnecessary allocation, use & instead\");\n-                    }\n-                    Some(adjustment::AutoBorrow::Ref(_, hir::MutMutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION,\n-                                     e.span,\n-                                     \"unnecessary allocation, use &mut instead\");\n-                    }\n-                    _ => (),\n-                }\n+        for adj in cx.tables.expr_adjustments(e) {\n+            if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n+                let msg = match m {\n+                    hir::MutImmutable => \"unnecessary allocation, use & instead\",\n+                    hir::MutMutable => \"unnecessary allocation, use &mut instead\"\n+                };\n+                cx.span_lint(UNUSED_ALLOCATION, e.span, msg);\n             }\n         }\n     }"}, {"sha": "d456bc3ded3907b03224c66c0436c848f2df1eff", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -201,13 +201,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 exit_block.unit()\n             }\n             ExprKind::Call { ty, fun, args } => {\n-                let diverges = match ty.sty {\n-                    ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n-                        // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                        f.output().skip_binder().is_never()\n-                    }\n-                    _ => false\n-                };\n+                // FIXME(canndrew): This is_never should probably be an is_uninhabited\n+                let diverges = expr.ty.is_never();\n                 let intrinsic = match ty.sty {\n                     ty::TyFnDef(def_id, _, ref f) if\n                         f.abi() == Abi::RustIntrinsic ||"}, {"sha": "2c3f51969267f33811477d912c15e86fd73e4edd", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 151, "deletions": 299, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -17,9 +17,10 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::cast::CastKind as TyCastKind;\n+use rustc::ty::subst::Subst;\n use rustc::hir;\n-use syntax::ptr::P;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n@@ -31,175 +32,13 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n-        let adj = cx.tables().adjustments.get(&self.id).cloned();\n-\n-        debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr,\n-               adj);\n \n         // Now apply adjustments, if any.\n-        match adj.map(|adj| (adj.kind, adj.target)) {\n-            None => {}\n-            Some((ty::adjustment::Adjust::ReifyFnPointer, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n-                };\n-            }\n-            Some((ty::adjustment::Adjust::UnsafeFnPointer, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n-                };\n-            }\n-            Some((ty::adjustment::Adjust::ClosureFnPointer, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::ClosureFnPointer { source: expr.to_ref() },\n-                };\n-            }\n-            Some((ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::NeverToAny { source: expr.to_ref() },\n-                };\n-            }\n-            Some((ty::adjustment::Adjust::MutToConstPointer, adjusted_ty)) => {\n-                expr = Expr {\n-                    temp_lifetime: temp_lifetime,\n-                    temp_lifetime_was_shrunk: was_shrunk,\n-                    ty: adjusted_ty,\n-                    span: self.span,\n-                    kind: ExprKind::Cast { source: expr.to_ref() },\n-                };\n-            }\n-            Some((ty::adjustment::Adjust::DerefRef { autoderefs, autoref, unsize },\n-                  adjusted_ty)) => {\n-                for i in 0..autoderefs {\n-                    let i = i as u32;\n-                    let adjusted_ty =\n-                        expr.ty.adjust_for_autoderef(cx.tcx, self.id, self.span, i, |mc| {\n-                            cx.tables().method_map.get(&mc).map(|m| m.ty)\n-                        });\n-                    debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\",\n-                           i,\n-                           adjusted_ty);\n-                    let method_key = ty::MethodCall::autoderef(self.id, i);\n-                    let meth_ty = cx.tables().method_map.get(&method_key).map(|m| m.ty);\n-                    let kind = if let Some(meth_ty) = meth_ty {\n-                        debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n-\n-                        let ref_ty = cx.tcx.no_late_bound_regions(&meth_ty.fn_ret());\n-                        let (region, mutbl) = match ref_ty {\n-                            Some(&ty::TyS { sty: ty::TyRef(region, mt), .. }) => (region, mt.mutbl),\n-                            _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n-                        };\n-\n-                        expr = Expr {\n-                            temp_lifetime: temp_lifetime,\n-                            temp_lifetime_was_shrunk: was_shrunk,\n-                            ty: cx.tcx.mk_ref(region,\n-                                              ty::TypeAndMut {\n-                                                  ty: expr.ty,\n-                                                  mutbl: mutbl,\n-                                              }),\n-                            span: expr.span,\n-                            kind: ExprKind::Borrow {\n-                                region: region,\n-                                borrow_kind: to_borrow_kind(mutbl),\n-                                arg: expr.to_ref(),\n-                            },\n-                        };\n-\n-                        overloaded_lvalue(cx,\n-                                          self,\n-                                          method_key,\n-                                          PassArgs::ByRef,\n-                                          expr.to_ref(),\n-                                          vec![])\n-                    } else {\n-                        debug!(\"make_mirror: built-in autoderef\");\n-                        ExprKind::Deref { arg: expr.to_ref() }\n-                    };\n-                    expr = Expr {\n-                        temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n-                        ty: adjusted_ty,\n-                        span: self.span,\n-                        kind: kind,\n-                    };\n-                }\n-\n-                if let Some(autoref) = autoref {\n-                    let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n-                    match autoref {\n-                        ty::adjustment::AutoBorrow::Ref(r, m) => {\n-                            expr = Expr {\n-                                temp_lifetime: temp_lifetime,\n-                                temp_lifetime_was_shrunk: was_shrunk,\n-                                ty: adjusted_ty,\n-                                span: self.span,\n-                                kind: ExprKind::Borrow {\n-                                    region: r,\n-                                    borrow_kind: to_borrow_kind(m),\n-                                    arg: expr.to_ref(),\n-                                },\n-                            };\n-                        }\n-                        ty::adjustment::AutoBorrow::RawPtr(m) => {\n-                            // Convert this to a suitable `&foo` and\n-                            // then an unsafe coercion. Limit the region to be just this\n-                            // expression.\n-                            let region = ty::ReScope(expr_extent);\n-                            let region = cx.tcx.mk_region(region);\n-                            expr = Expr {\n-                                temp_lifetime: temp_lifetime,\n-                                temp_lifetime_was_shrunk: was_shrunk,\n-                                ty: cx.tcx.mk_ref(region,\n-                                                  ty::TypeAndMut {\n-                                                      ty: expr.ty,\n-                                                      mutbl: m,\n-                                                  }),\n-                                span: self.span,\n-                                kind: ExprKind::Borrow {\n-                                    region: region,\n-                                    borrow_kind: to_borrow_kind(m),\n-                                    arg: expr.to_ref(),\n-                                },\n-                            };\n-                            expr = Expr {\n-                                temp_lifetime: temp_lifetime,\n-                                temp_lifetime_was_shrunk: was_shrunk,\n-                                ty: adjusted_ty,\n-                                span: self.span,\n-                                kind: ExprKind::Cast { source: expr.to_ref() },\n-                            };\n-                        }\n-                    }\n-                }\n-\n-                if unsize {\n-                    expr = Expr {\n-                        temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n-                        ty: adjusted_ty,\n-                        span: self.span,\n-                        kind: ExprKind::Unsize { source: expr.to_ref() },\n-                    };\n-                }\n-            }\n+        for adjustment in cx.tables().expr_adjustments(self) {\n+            debug!(\"make_mirror: expr={:?} applying adjustment={:?}\",\n+                   expr,\n+                   adjustment);\n+            expr = apply_adjustment(cx, self, expr, adjustment);\n         }\n \n         // Next, wrap this up in the expr's scope.\n@@ -233,6 +72,96 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     }\n }\n \n+fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                    hir_expr: &'tcx hir::Expr,\n+                                    mut expr: Expr<'tcx>,\n+                                    adjustment: &Adjustment<'tcx>)\n+                                    -> Expr<'tcx> {\n+    let Expr { temp_lifetime, temp_lifetime_was_shrunk, span, .. } = expr;\n+    let kind = match adjustment.kind {\n+        Adjust::ReifyFnPointer => {\n+            ExprKind::ReifyFnPointer { source: expr.to_ref() }\n+        }\n+        Adjust::UnsafeFnPointer => {\n+            ExprKind::UnsafeFnPointer { source: expr.to_ref() }\n+        }\n+        Adjust::ClosureFnPointer => {\n+            ExprKind::ClosureFnPointer { source: expr.to_ref() }\n+        }\n+        Adjust::NeverToAny => {\n+            ExprKind::NeverToAny { source: expr.to_ref() }\n+        }\n+        Adjust::MutToConstPointer => {\n+            ExprKind::Cast { source: expr.to_ref() }\n+        }\n+        Adjust::Deref(None) => {\n+            ExprKind::Deref { arg: expr.to_ref() }\n+        }\n+        Adjust::Deref(Some(deref)) => {\n+            let call = deref.method_call(cx.tcx, expr.ty);\n+\n+            expr = Expr {\n+                temp_lifetime,\n+                temp_lifetime_was_shrunk,\n+                ty: cx.tcx.mk_ref(deref.region,\n+                                  ty::TypeAndMut {\n+                                    ty: expr.ty,\n+                                    mutbl: deref.mutbl,\n+                                  }),\n+                span,\n+                kind: ExprKind::Borrow {\n+                    region: deref.region,\n+                    borrow_kind: to_borrow_kind(deref.mutbl),\n+                    arg: expr.to_ref(),\n+                },\n+            };\n+\n+            overloaded_lvalue(cx, hir_expr, adjustment.target, Some(call), vec![expr.to_ref()])\n+        }\n+        Adjust::Borrow(AutoBorrow::Ref(r, m)) => {\n+            ExprKind::Borrow {\n+                region: r,\n+                borrow_kind: to_borrow_kind(m),\n+                arg: expr.to_ref(),\n+            }\n+        }\n+        Adjust::Borrow(AutoBorrow::RawPtr(m)) => {\n+            // Convert this to a suitable `&foo` and\n+            // then an unsafe coercion. Limit the region to be just this\n+            // expression.\n+            let region = ty::ReScope(CodeExtent::Misc(hir_expr.id));\n+            let region = cx.tcx.mk_region(region);\n+            expr = Expr {\n+                temp_lifetime,\n+                temp_lifetime_was_shrunk,\n+                ty: cx.tcx.mk_ref(region,\n+                                  ty::TypeAndMut {\n+                                    ty: expr.ty,\n+                                    mutbl: m,\n+                                  }),\n+                span,\n+                kind: ExprKind::Borrow {\n+                    region: region,\n+                    borrow_kind: to_borrow_kind(m),\n+                    arg: expr.to_ref(),\n+                },\n+            };\n+            ExprKind::Cast { source: expr.to_ref() }\n+        }\n+        Adjust::Unsize => {\n+            ExprKind::Unsize { source: expr.to_ref() }\n+        }\n+    };\n+\n+    Expr {\n+        temp_lifetime,\n+        temp_lifetime_was_shrunk,\n+        ty: adjustment.target,\n+        span,\n+        kind,\n+    }\n+}\n+\n fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n@@ -243,7 +172,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         // Here comes the interesting stuff:\n         hir::ExprMethodCall(.., ref args) => {\n             // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n-            let expr = method_callee(cx, expr, ty::MethodCall::expr(expr.id));\n+            let expr = method_callee(cx, expr, None);\n             let args = args.iter()\n                 .map(|e| e.to_ref())\n                 .collect();\n@@ -255,26 +184,19 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if cx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n                 // callee-object as expr parameter.\n \n                 // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n \n-                let method = method_callee(cx, expr, ty::MethodCall::expr(expr.id));\n-\n-                let sig = method.ty.fn_sig();\n-\n-                let sig = cx.tcx\n-                    .no_late_bound_regions(&sig)\n-                    .unwrap_or_else(|| span_bug!(expr.span, \"method call has late-bound regions\"));\n-\n-                assert_eq!(sig.inputs().len(), 2);\n+                let method = method_callee(cx, expr, None);\n \n+                let arg_tys = args.iter().map(|e| cx.tables().expr_ty_adjusted(e));\n                 let tupled_args = Expr {\n-                    ty: sig.inputs()[1],\n+                    ty: cx.tcx.mk_tup(arg_tys, false),\n                     temp_lifetime: temp_lifetime,\n                     temp_lifetime_was_shrunk: was_shrunk,\n                     span: expr.span,\n@@ -302,8 +224,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     None\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tables().node_id_item_substs(fun.id)\n-                        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n+                    let substs = cx.tables().node_substs(fun.id);\n                     let field_refs = args.iter()\n                         .enumerate()\n                         .map(|(idx, e)| {\n@@ -352,18 +273,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tables().is_method_call(expr.id) {\n-                let pass_args = if op.node.is_by_value() {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n-                overloaded_operator(cx,\n-                                    expr,\n-                                    ty::MethodCall::expr(expr.id),\n-                                    pass_args,\n-                                    lhs.to_ref(),\n-                                    vec![rhs])\n+            if cx.tables().is_method_call(expr) {\n+                overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n                 ExprKind::AssignOp {\n                     op: bin_op(op.node),\n@@ -376,18 +287,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if cx.tables().is_method_call(expr.id) {\n-                let pass_args = if op.node.is_by_value() {\n-                    PassArgs::ByValue\n-                } else {\n-                    PassArgs::ByRef\n-                };\n-                overloaded_operator(cx,\n-                                    expr,\n-                                    ty::MethodCall::expr(expr.id),\n-                                    pass_args,\n-                                    lhs.to_ref(),\n-                                    vec![rhs])\n+            if cx.tables().is_method_call(expr) {\n+                overloaded_operator(cx, expr, vec![lhs.to_ref(), rhs.to_ref()])\n             } else {\n                 // FIXME overflow\n                 match (op.node, cx.constness) {\n@@ -436,13 +337,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if cx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx,\n-                                  expr,\n-                                  ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue,\n-                                  lhs.to_ref(),\n-                                  vec![index])\n+            if cx.tables().is_method_call(expr) {\n+                overloaded_lvalue(cx, expr, expr_ty, None, vec![lhs.to_ref(), index.to_ref()])\n             } else {\n                 ExprKind::Index {\n                     lhs: lhs.to_ref(),\n@@ -452,26 +348,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tables().is_method_call(expr.id) {\n-                overloaded_lvalue(cx,\n-                                  expr,\n-                                  ty::MethodCall::expr(expr.id),\n-                                  PassArgs::ByValue,\n-                                  arg.to_ref(),\n-                                  vec![])\n+            if cx.tables().is_method_call(expr) {\n+                overloaded_lvalue(cx, expr, expr_ty, None, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Deref { arg: arg.to_ref() }\n             }\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx,\n-                                    expr,\n-                                    ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue,\n-                                    arg.to_ref(),\n-                                    vec![])\n+            if cx.tables().is_method_call(expr) {\n+                overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n                 ExprKind::Unary {\n                     op: UnOp::Not,\n@@ -481,13 +367,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tables().is_method_call(expr.id) {\n-                overloaded_operator(cx,\n-                                    expr,\n-                                    ty::MethodCall::expr(expr.id),\n-                                    PassArgs::ByValue,\n-                                    arg.to_ref(),\n-                                    vec![])\n+            if cx.tables().is_method_call(expr) {\n+                overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n                 // FIXME runtime-overflow\n                 if let hir::ExprLit(_) = arg.node {\n@@ -703,18 +584,21 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n-                                 method_call: ty::MethodCall)\n+                                 custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n                                  -> Expr<'tcx> {\n-    let callee = cx.tables().method_map[&method_call];\n     let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n+    let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n+        (cx.tables().type_dependent_defs[&expr.id].def_id(),\n+         cx.tables().node_substs(expr.id))\n+    });\n     Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n-        ty: callee.ty,\n+        ty: cx.tcx.type_of(def_id).subst(cx.tcx, substs),\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: ConstVal::Function(callee.def_id, callee.substs),\n+                value: ConstVal::Function(def_id, substs),\n             },\n         },\n     }\n@@ -739,8 +623,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tables().node_id_item_substs(expr.id)\n-        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n+    let substs = cx.tables().node_substs(expr.id);\n     match def {\n         // A regular function, constructor function or a constant.\n         Def::Fn(def_id) |\n@@ -941,90 +824,59 @@ fn bin_op(op: hir::BinOp_) -> BinOp {\n     }\n }\n \n-enum PassArgs {\n-    ByValue,\n-    ByRef,\n-}\n-\n fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                        expr: &'tcx hir::Expr,\n-                                       method_call: ty::MethodCall,\n-                                       pass_args: PassArgs,\n-                                       receiver: ExprRef<'tcx>,\n-                                       args: Vec<&'tcx P<hir::Expr>>)\n+                                       args: Vec<ExprRef<'tcx>>)\n                                        -> ExprKind<'tcx> {\n-    // the receiver has all the adjustments that are needed, so we can\n-    // just push a reference to it\n-    let mut argrefs = vec![receiver];\n-\n-    // the arguments, unfortunately, do not, so if this is a ByRef\n-    // operator, we have to gin up the autorefs (but by value is easy)\n-    match pass_args {\n-        PassArgs::ByValue => argrefs.extend(args.iter().map(|arg| arg.to_ref())),\n-\n-        PassArgs::ByRef => {\n-            let region = cx.tcx.node_scope_region(expr.id);\n-            let (temp_lifetime, was_shrunk) =\n-                cx.region_maps.temporary_scope2(expr.id);\n-            argrefs.extend(args.iter()\n-                .map(|arg| {\n-                    let arg_ty = cx.tables().expr_ty_adjusted(arg);\n-                    let adjusted_ty = cx.tcx.mk_ref(region,\n-                                                    ty::TypeAndMut {\n-                                                        ty: arg_ty,\n-                                                        mutbl: hir::MutImmutable,\n-                                                    });\n-                    Expr {\n-                        temp_lifetime: temp_lifetime,\n-                        temp_lifetime_was_shrunk: was_shrunk,\n-                        ty: adjusted_ty,\n-                        span: expr.span,\n-                        kind: ExprKind::Borrow {\n-                            region: region,\n-                            borrow_kind: BorrowKind::Shared,\n-                            arg: arg.to_ref(),\n-                        },\n-                    }\n-                    .to_ref()\n-                }))\n-        }\n-    }\n-\n-    // now create the call itself\n-    let fun = method_callee(cx, expr, method_call);\n+    let fun = method_callee(cx, expr, None);\n     ExprKind::Call {\n         ty: fun.ty,\n         fun: fun.to_ref(),\n-        args: argrefs,\n+        args,\n     }\n }\n \n fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n-                                     method_call: ty::MethodCall,\n-                                     pass_args: PassArgs,\n-                                     receiver: ExprRef<'tcx>,\n-                                     args: Vec<&'tcx P<hir::Expr>>)\n+                                     lvalue_ty: Ty<'tcx>,\n+                                     custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>,\n+                                     args: Vec<ExprRef<'tcx>>)\n                                      -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n-    // to find the type &T of the content returned by the method;\n-    let ref_ty = cx.tables().method_map[&method_call].ty.fn_ret();\n-    let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n-    // callees always have all late-bound regions fully instantiated,\n+    let recv_ty = match args[0] {\n+        ExprRef::Hair(e) => cx.tables().expr_ty_adjusted(e),\n+        ExprRef::Mirror(ref e) => e.ty\n+    };\n+\n+    // Reconstruct the output assuming it's a reference with the\n+    // same region and mutability as the receiver. This holds for\n+    // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n+    let (region, mt) = match recv_ty.sty {\n+        ty::TyRef(region, mt) => (region, mt),\n+        _ => span_bug!(expr.span, \"overloaded_lvalue: receiver is not a reference\"),\n+    };\n+    let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut {\n+        ty: lvalue_ty,\n+        mutbl: mt.mutbl,\n+    });\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n     let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n-    let ref_kind = overloaded_operator(cx, expr, method_call, pass_args, receiver, args);\n+    let fun = method_callee(cx, expr, custom_callee);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n         ty: ref_ty,\n         span: expr.span,\n-        kind: ref_kind,\n+        kind: ExprKind::Call {\n+            ty: fun.ty,\n+            fun: fun.to_ref(),\n+            args,\n+        },\n     };\n \n     // construct and return a deref wrapper `*foo()`"}, {"sha": "fecde3a636cda0893fddd203e8b089286995bb9b", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -280,11 +280,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         _ => {}\n     }\n \n-    let method_call = ty::MethodCall::expr(e.id);\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tables.method_map.contains_key(&method_call) => {\n+        hir::ExprIndex(..) if v.tables.is_method_call(e) => {\n             v.promotable = false;\n         }\n         hir::ExprBox(_) => {\n@@ -381,9 +380,9 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tables.method_map[&method_call];\n-            match v.tcx.associated_item(method.def_id).container {\n-                ty::ImplContainer(_) => v.handle_const_fn_call(method.def_id, node_ty),\n+            let def_id = v.tables.type_dependent_defs[&e.id].def_id();\n+            match v.tcx.associated_item(def_id).container {\n+                ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false\n             }\n         }\n@@ -442,18 +441,21 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n     use rustc::ty::adjustment::*;\n \n-    match v.tables.adjustments.get(&e.id).map(|adj| adj.kind) {\n-        None |\n-        Some(Adjust::NeverToAny) |\n-        Some(Adjust::ReifyFnPointer) |\n-        Some(Adjust::UnsafeFnPointer) |\n-        Some(Adjust::ClosureFnPointer) |\n-        Some(Adjust::MutToConstPointer) => {}\n-\n-        Some(Adjust::DerefRef { autoderefs, .. }) => {\n-            if (0..autoderefs as u32)\n-                .any(|autoderef| v.tables.is_overloaded_autoderef(e.id, autoderef)) {\n-                v.promotable = false;\n+    for adjustment in v.tables.expr_adjustments(e) {\n+        match adjustment.kind {\n+            Adjust::NeverToAny |\n+            Adjust::ReifyFnPointer |\n+            Adjust::UnsafeFnPointer |\n+            Adjust::ClosureFnPointer |\n+            Adjust::MutToConstPointer |\n+            Adjust::Borrow(_) |\n+            Adjust::Unsize => {}\n+\n+            Adjust::Deref(ref overloaded) => {\n+                if overloaded.is_some() {\n+                    v.promotable = false;\n+                    break;\n+                }\n             }\n         }\n     }\n@@ -512,7 +514,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n                 Categorization::StaticItem => {\n                     break;\n                 }\n-                Categorization::Deref(ref cmt, ..) |\n+                Categorization::Deref(ref cmt, _) |\n                 Categorization::Downcast(ref cmt, _) |\n                 Categorization::Interior(ref cmt, _) => {\n                     cur = cmt;"}, {"sha": "b74d3982d61c5739eca252d6dd7728bec0e20563", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -564,8 +564,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(..) => {\n-                let method_call = ty::MethodCall::expr(expr.id);\n-                let method_id = self.tables.method_map[&method_call].def_id;\n+                let method_id = self.tables.type_dependent_defs[&expr.id].def_id();\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),"}, {"sha": "33f0b0282d173b878953ffe5dc2bf09aa840b453", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -619,7 +619,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Type check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = tcx.no_late_bound_regions(&pat_ty.fn_ret()).expect(\"expected fn type\");\n+        let pat_ty = pat_ty.fn_sig().output();\n+        let pat_ty = tcx.no_late_bound_regions(&pat_ty).expect(\"expected fn type\");\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns."}, {"sha": "92017465f7d7489171c6452d68ec27bf8ee8c3b9", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -11,19 +11,20 @@\n use astconv::AstConv;\n \n use super::{FnCtxt, LvalueOp};\n+use super::method::MethodCallee;\n \n-use check::coercion::AsCoercionSite;\n use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n-use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::{LvaluePreference, NoPreference};\n-use rustc::hir;\n+use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n use syntax::symbol::Symbol;\n \n+use std::iter;\n+\n #[derive(Copy, Clone, Debug)]\n enum AutoderefKind {\n     Builtin,\n@@ -150,52 +151,59 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         self.fcx.resolve_type_vars_if_possible(&self.cur_ty)\n     }\n \n-    pub fn finalize(self, pref: LvaluePreference, expr: &hir::Expr) {\n-        let fcx = self.fcx;\n-        fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, &[expr]));\n+    pub fn step_count(&self) -> usize {\n+        self.steps.len()\n+    }\n+\n+    /// Returns the adjustment steps.\n+    pub fn adjust_steps(&self, pref: LvaluePreference)\n+                        -> Vec<Adjustment<'tcx>> {\n+        self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(pref))\n     }\n \n-    pub fn finalize_as_infer_ok<E>(self, pref: LvaluePreference, exprs: &[E])\n-                                   -> InferOk<'tcx, ()>\n-        where E: AsCoercionSite\n-    {\n-        let Autoderef { fcx, span, mut obligations, steps, .. } = self;\n-        let methods: Vec<_> = steps\n-            .iter()\n-            .map(|&(ty, kind)| {\n-                if let AutoderefKind::Overloaded = kind {\n-                    fcx.try_overloaded_deref(span, None, ty, pref)\n-                        .map(|InferOk { value, obligations: o }| {\n-                            obligations.extend(o);\n-                            value\n-                        })\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect();\n-\n-        debug!(\"finalize({:?}) - {:?},{:?}\",\n-               pref,\n-               methods,\n-               obligations);\n-\n-        for expr in exprs {\n-            let expr = expr.as_coercion_site();\n-            debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n-            for (n, method) in methods.iter().enumerate() {\n-                if let &Some(method) = method {\n-                    let method_call = MethodCall::autoderef(expr.id, n as u32);\n-                    fcx.tables.borrow_mut().method_map.insert(method_call, method);\n-                }\n+    pub fn adjust_steps_as_infer_ok(&self, pref: LvaluePreference)\n+                                    -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n+        let mut obligations = vec![];\n+        let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty)\n+            .chain(iter::once(self.cur_ty));\n+        let steps: Vec<_> = self.steps.iter().map(|&(source, kind)| {\n+            if let AutoderefKind::Overloaded = kind {\n+                self.fcx.try_overloaded_deref(self.span, source, pref)\n+                    .and_then(|InferOk { value: method, obligations: o }| {\n+                        obligations.extend(o);\n+                        if let ty::TyRef(region, mt) = method.sig.output().sty {\n+                            Some(OverloadedDeref {\n+                                region,\n+                                mutbl: mt.mutbl,\n+                            })\n+                        } else {\n+                            None\n+                        }\n+                    })\n+            } else {\n+                None\n             }\n-        }\n+        }).zip(targets).map(|(autoderef, target)| {\n+            Adjustment {\n+                kind: Adjust::Deref(autoderef),\n+                target\n+            }\n+        }).collect();\n \n         InferOk {\n-            value: (),\n-            obligations\n+            obligations,\n+            value: steps\n         }\n     }\n+\n+    pub fn finalize(self) {\n+        let fcx = self.fcx;\n+        fcx.register_predicates(self.into_obligations());\n+    }\n+\n+    pub fn into_obligations(self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        self.obligations\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -212,14 +220,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn try_overloaded_deref(&self,\n                                 span: Span,\n-                                base_expr: Option<&hir::Expr>,\n                                 base_ty: Ty<'tcx>,\n                                 pref: LvaluePreference)\n                                 -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        let rcvr = base_expr.map(|base_expr| super::AdjustedRcvr {\n-            rcvr_expr: base_expr, autoderefs: 0, unsize: false\n-        });\n-\n-        self.try_overloaded_lvalue_op(span, rcvr, base_ty, &[], pref, LvalueOp::Deref)\n+        self.try_overloaded_lvalue_op(span, base_ty, &[], pref, LvalueOp::Deref)\n     }\n }"}, {"sha": "d5ee66a2f0a07e0fa5ee8f0c80cb6769a6d9c9fc", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -8,13 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{DeferredCallResolution, Expectation, FnCtxt, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n+use super::autoderef::Autoderef;\n+use super::method::MethodCallee;\n \n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, LvaluePreference, Ty};\n use rustc::ty::subst::Subst;\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use syntax::abi;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -33,9 +36,9 @@ pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefI\n }\n \n enum CallStep<'tcx> {\n-    Builtin,\n+    Builtin(Ty<'tcx>),\n     DeferredClosure(ty::FnSig<'tcx>),\n-    Overloaded(ty::MethodCallee<'tcx>),\n+    Overloaded(MethodCallee<'tcx>),\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -49,21 +52,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_ty = self.structurally_resolved_type(call_expr.span, original_callee_ty);\n \n         let mut autoderef = self.autoderef(callee_expr.span, expr_ty);\n-        let result = autoderef.by_ref()\n-            .flat_map(|(adj_ty, idx)| {\n-                self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n-            })\n-            .next();\n-        let callee_ty = autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, callee_expr);\n+        let mut result = None;\n+        while result.is_none() && autoderef.next().is_some() {\n+            result = self.try_overloaded_call_step(call_expr, callee_expr, &autoderef);\n+        }\n+        autoderef.finalize();\n \n         let output = match result {\n             None => {\n                 // this will report an error since original_callee_ty is not a fn\n                 self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected)\n             }\n \n-            Some(CallStep::Builtin) => {\n+            Some(CallStep::Builtin(callee_ty)) => {\n                 self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected)\n             }\n \n@@ -72,11 +73,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             Some(CallStep::Overloaded(method_callee)) => {\n-                self.confirm_overloaded_call(call_expr,\n-                                             callee_expr,\n-                                             arg_exprs,\n-                                             expected,\n-                                             method_callee)\n+                self.confirm_overloaded_call(call_expr, arg_exprs, expected, method_callee)\n             }\n         };\n \n@@ -89,19 +86,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn try_overloaded_call_step(&self,\n                                 call_expr: &'gcx hir::Expr,\n                                 callee_expr: &'gcx hir::Expr,\n-                                adjusted_ty: Ty<'tcx>,\n-                                autoderefs: usize)\n+                                autoderef: &Autoderef<'a, 'gcx, 'tcx>)\n                                 -> Option<CallStep<'tcx>> {\n-        debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?}, autoderefs={})\",\n+        let adjusted_ty = autoderef.unambiguous_final_ty();\n+        debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n                call_expr,\n-               adjusted_ty,\n-               autoderefs);\n+               adjusted_ty);\n \n         // If the callee is a bare function or a closure, then we're all set.\n-        match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n+        match adjusted_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                self.apply_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n-                return Some(CallStep::Builtin);\n+                let adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                self.apply_adjustments(callee_expr, adjustments);\n+                return Some(CallStep::Builtin(adjusted_ty));\n             }\n \n             ty::TyClosure(def_id, substs) => {\n@@ -116,15 +113,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    infer::FnCall,\n                                                                    &closure_ty)\n                         .0;\n-                    self.record_deferred_call_resolution(def_id,\n-                                                         Box::new(CallResolution {\n-                                                             call_expr: call_expr,\n-                                                             callee_expr: callee_expr,\n-                                                             adjusted_ty: adjusted_ty,\n-                                                             autoderefs: autoderefs,\n-                                                             fn_sig: fn_sig.clone(),\n-                                                             closure_def_id: def_id,\n-                                                         }));\n+                    let adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                    self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n+                        call_expr,\n+                        callee_expr,\n+                        adjusted_ty,\n+                        adjustments,\n+                        fn_sig,\n+                        closure_def_id: def_id,\n+                    });\n                     return Some(CallStep::DeferredClosure(fn_sig));\n                 }\n             }\n@@ -137,47 +134,54 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // over the top. The simplest fix by far is to just ignore\n             // this case and deref again, so we wind up with\n             // `FnMut::call_mut(&mut *x, ())`.\n-            ty::TyRef(..) if autoderefs == 0 => {\n+            ty::TyRef(..) if autoderef.step_count() == 0 => {\n                 return None;\n             }\n \n             _ => {}\n         }\n \n-        self.try_overloaded_call_traits(call_expr, callee_expr, adjusted_ty, autoderefs)\n-            .map(|method_callee| CallStep::Overloaded(method_callee))\n+        self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n+            let mut adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+            adjustments.extend(autoref);\n+            self.apply_adjustments(callee_expr, adjustments);\n+            CallStep::Overloaded(method)\n+        })\n     }\n \n     fn try_overloaded_call_traits(&self,\n                                   call_expr: &hir::Expr,\n-                                  callee_expr: &hir::Expr,\n-                                  adjusted_ty: Ty<'tcx>,\n-                                  autoderefs: usize)\n-                                  -> Option<ty::MethodCallee<'tcx>> {\n+                                  adjusted_ty: Ty<'tcx>)\n+                                  -> Option<(Option<Adjustment<'tcx>>,\n+                                             MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n-        for &(opt_trait_def_id, method_name) in\n-            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\")),\n-              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\")),\n-              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"))] {\n+        for &(opt_trait_def_id, method_name, borrow) in\n+            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\"), true),\n+              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\"), true),\n+              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"), false)] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,\n             };\n \n-            match self.lookup_method_in_trait_adjusted(call_expr.span,\n-                                                       Some(super::AdjustedRcvr {\n-                                                           rcvr_expr: callee_expr,\n-                                                           autoderefs,\n-                                                           unsize: false\n-                                                       }),\n-                                                       method_name,\n-                                                       trait_def_id,\n-                                                       adjusted_ty,\n-                                                       None) {\n+            match self.lookup_method_in_trait(call_expr.span,\n+                                              method_name,\n+                                              trait_def_id,\n+                                              adjusted_ty,\n+                                              None) {\n                 None => continue,\n                 Some(ok) => {\n-                    let method_callee = self.register_infer_ok_obligations(ok);\n-                    return Some(method_callee);\n+                    let method = self.register_infer_ok_obligations(ok);\n+                    let mut autoref = None;\n+                    if borrow {\n+                        if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                            autoref = Some(Adjustment {\n+                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                                target: method.sig.inputs()[0]\n+                            });\n+                        }\n+                    }\n+                    return Some((autoref, method));\n                 }\n             }\n         }\n@@ -301,42 +305,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn confirm_overloaded_call(&self,\n                                call_expr: &hir::Expr,\n-                               callee_expr: &'gcx hir::Expr,\n                                arg_exprs: &'gcx [hir::Expr],\n                                expected: Expectation<'tcx>,\n-                               method_callee: ty::MethodCallee<'tcx>)\n+                               method_callee: MethodCallee<'tcx>)\n                                -> Ty<'tcx> {\n         let output_type = self.check_method_argument_types(call_expr.span,\n-                                                           method_callee.ty,\n-                                                           callee_expr,\n+                                                           Ok(method_callee),\n                                                            arg_exprs,\n                                                            TupleArgumentsFlag::TupleArguments,\n                                                            expected);\n \n-        self.write_overloaded_call_method_map(call_expr, method_callee);\n+        self.write_method_call(call_expr.id, method_callee);\n         output_type\n     }\n-\n-    fn write_overloaded_call_method_map(&self,\n-                                        call_expr: &hir::Expr,\n-                                        method_callee: ty::MethodCallee<'tcx>) {\n-        let method_call = ty::MethodCall::expr(call_expr.id);\n-        self.tables.borrow_mut().method_map.insert(method_call, method_callee);\n-    }\n }\n \n #[derive(Debug)]\n-struct CallResolution<'gcx: 'tcx, 'tcx> {\n+pub struct DeferredCallResolution<'gcx: 'tcx, 'tcx> {\n     call_expr: &'gcx hir::Expr,\n     callee_expr: &'gcx hir::Expr,\n     adjusted_ty: Ty<'tcx>,\n-    autoderefs: usize,\n+    adjustments: Vec<Adjustment<'tcx>>,\n     fn_sig: ty::FnSig<'tcx>,\n     closure_def_id: DefId,\n }\n \n-impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tcx> {\n-    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n+impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n+    pub fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n         debug!(\"DeferredCallResolution::resolve() {:?}\", self);\n \n         // we should not be invoked until the closure kind has been\n@@ -345,10 +340,8 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match fcx.try_overloaded_call_traits(self.call_expr,\n-                                             self.callee_expr,\n-                                             self.adjusted_ty,\n-                                             self.autoderefs) {\n-            Some(method_callee) => {\n+                                             self.adjusted_ty) {\n+            Some((autoref, method_callee)) => {\n                 // One problem is that when we get here, we are going\n                 // to have a newly instantiated function signature\n                 // from the call trait. This has to be reconciled with\n@@ -357,9 +350,7 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n                 // can't because of the annoying need for a TypeTrace.\n                 // (This always bites me, should find a way to\n                 // refactor it.)\n-                let method_sig = fcx.tcx\n-                    .no_late_bound_regions(&method_callee.ty.fn_sig())\n-                    .unwrap();\n+                let method_sig = method_callee.sig;\n \n                 debug!(\"attempt_resolution: method_callee={:?}\", method_callee);\n \n@@ -370,7 +361,11 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n \n                 fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());\n \n-                fcx.write_overloaded_call_method_map(self.call_expr, method_callee);\n+                let mut adjustments = self.adjustments;\n+                adjustments.extend(autoref);\n+                fcx.apply_adjustments(self.callee_expr, adjustments);\n+\n+                fcx.write_method_call(self.call_expr.id, method_callee);\n             }\n             None => {\n                 span_bug!(self.call_expr.span,"}, {"sha": "a962cdb8f728fe6236ac61359145f16497d53464", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 130, "deletions": 115, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n     }\n }\n \n-type CoerceResult<'tcx> = InferResult<'tcx, Adjustment<'tcx>>;\n+type CoerceResult<'tcx> = InferResult<'tcx, (Vec<Adjustment<'tcx>>, Ty<'tcx>)>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n@@ -108,23 +108,18 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n-fn identity<'tcx>() -> Adjust<'tcx> {\n-    Adjust::DerefRef {\n-        autoderefs: 0,\n-        autoref: None,\n-        unsize: false,\n-    }\n+fn identity(_: Ty) -> Vec<Adjustment> { vec![] }\n+\n+fn simple<'tcx>(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>> {\n+    move |target| vec![Adjustment { kind, target }]\n }\n \n-fn success<'tcx>(kind: Adjust<'tcx>,\n+fn success<'tcx>(adj: Vec<Adjustment<'tcx>>,\n                  target: Ty<'tcx>,\n                  obligations: traits::PredicateObligations<'tcx>)\n                  -> CoerceResult<'tcx> {\n     Ok(InferOk {\n-        value: Adjustment {\n-            kind,\n-            target\n-        },\n+        value: (adj, target),\n         obligations\n     })\n }\n@@ -150,26 +145,22 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     }\n \n     /// Unify two types (using sub or lub) and produce a specific coercion.\n-    fn unify_and(&self, a: Ty<'tcx>, b: Ty<'tcx>, kind: Adjust<'tcx>)\n-                 -> CoerceResult<'tcx> {\n+    fn unify_and<F>(&self, a: Ty<'tcx>, b: Ty<'tcx>, f: F)\n+                    -> CoerceResult<'tcx>\n+        where F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n+    {\n         self.unify(&a, &b).and_then(|InferOk { value: ty, obligations }| {\n-            success(kind, ty, obligations)\n+            success(f(ty), ty, obligations)\n         })\n     }\n \n-    fn coerce<E>(&self,\n-                 exprs: &[E],\n-                 a: Ty<'tcx>,\n-                 b: Ty<'tcx>)\n-                 -> CoerceResult<'tcx>\n-        where E: AsCoercionSite\n-    {\n+    fn coerce(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         let a = self.shallow_resolve(a);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return success(identity(), b, vec![]);\n+            return success(vec![], b, vec![]);\n         }\n \n         if a.is_never() {\n@@ -186,9 +177,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n                     TypeVariableOrigin::AdjustmentType(self.cause.span));\n-                self.unify_and(&b, &diverging_ty, Adjust::NeverToAny)\n+                self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n             } else {\n-                success(Adjust::NeverToAny, b, vec![])\n+                success(simple(Adjust::NeverToAny)(b), b, vec![])\n             };\n         }\n \n@@ -210,7 +201,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n \n             ty::TyRef(r_b, mt_b) => {\n-                return self.coerce_borrowed_pointer(exprs, a, b, r_b, mt_b);\n+                return self.coerce_borrowed_pointer(a, b, r_b, mt_b);\n             }\n \n             _ => {}\n@@ -237,23 +228,20 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.unify_and(a, b, identity())\n+                self.unify_and(a, b, identity)\n             }\n         }\n     }\n \n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n-    fn coerce_borrowed_pointer<E>(&self,\n-                                  exprs: &[E],\n-                                  a: Ty<'tcx>,\n-                                  b: Ty<'tcx>,\n-                                  r_b: ty::Region<'tcx>,\n-                                  mt_b: TypeAndMut<'tcx>)\n-                                  -> CoerceResult<'tcx>\n-        where E: AsCoercionSite\n-    {\n+    fn coerce_borrowed_pointer(&self,\n+                               a: Ty<'tcx>,\n+                               b: Ty<'tcx>,\n+                               r_b: ty::Region<'tcx>,\n+                               mt_b: TypeAndMut<'tcx>)\n+                               -> CoerceResult<'tcx> {\n \n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n \n@@ -268,7 +256,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n-            _ => return self.unify_and(a, b, identity()),\n+            _ => return self.unify_and(a, b, identity),\n         };\n \n         let span = self.cause.span;\n@@ -375,7 +363,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                               });\n             match self.unify(derefd_ty_a, b) {\n                 Ok(ok) => {\n-                    found = Some((ok, autoderefs));\n+                    found = Some(ok);\n                     break;\n                 }\n                 Err(err) => {\n@@ -391,7 +379,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let (InferOk { value: ty, mut obligations }, autoderefs) = match found {\n+        let InferOk { value: ty, mut obligations } = match found {\n             Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n@@ -400,7 +388,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         };\n \n-        if ty == a && mt_a.mutbl == hir::MutImmutable && autoderefs == 1 {\n+        if ty == a && mt_a.mutbl == hir::MutImmutable && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -413,29 +401,31 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n             assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n-            return success(identity(), ty, obligations);\n+            return success(vec![], ty, obligations);\n         }\n \n+        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n+        let InferOk { value: mut adjustments, obligations: o }\n+            = autoderef.adjust_steps_as_infer_ok(pref);\n+        obligations.extend(o);\n+        obligations.extend(autoderef.into_obligations());\n+\n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         let r_borrow = match ty.sty {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n-        let autoref = Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl));\n-        debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n-               ty,\n-               autoderefs,\n-               autoref);\n+        adjustments.push(Adjustment {\n+            kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mt_b.mutbl)),\n+            target: ty\n+        });\n \n-        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n-        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs).obligations);\n+        debug!(\"coerce_borrowed_pointer: succeeded ty={:?} adjustments={:?}\",\n+               ty,\n+               adjustments);\n \n-        success(Adjust::DerefRef {\n-            autoderefs: autoderefs,\n-            autoref: autoref,\n-            unsize: false,\n-        }, ty, obligations)\n+        success(adjustments, ty, obligations)\n     }\n \n \n@@ -460,35 +450,59 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // that, at which point we will need extra checks on the target here.\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n-        let (source, reborrow) = match (&source.sty, &target.sty) {\n+        let reborrow = match (&source.sty, &target.sty) {\n             (&ty::TyRef(_, mt_a), &ty::TyRef(_, mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n-                (mt_a.ty, Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl)))\n+                Some((Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    target: mt_a.ty\n+                }, Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mt_b.mutbl)),\n+                    target:  self.tcx.mk_ref(r_borrow, ty::TypeAndMut {\n+                        mutbl: mt_b.mutbl,\n+                        ty: mt_a.ty\n+                    })\n+                }))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n-                (mt_a.ty, Some(AutoBorrow::RawPtr(mt_b.mutbl)))\n-            }\n-            _ => (source, None),\n-        };\n-        let coerce_source = source.adjust_for_autoref(self.tcx, reborrow);\n \n-        let adjust = Adjust::DerefRef {\n-            autoderefs: if reborrow.is_some() { 1 } else { 0 },\n-            autoref: reborrow,\n-            unsize: true,\n+                Some((Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    target: mt_a.ty\n+                }, Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::RawPtr(mt_b.mutbl)),\n+                    target:  self.tcx.mk_ptr(ty::TypeAndMut {\n+                        mutbl: mt_b.mutbl,\n+                        ty: mt_a.ty\n+                    })\n+                }))\n+            }\n+            _ => None,\n         };\n+        let coerce_source = reborrow.as_ref().map_or(source, |&(_, ref r)| r.target);\n \n         // Setup either a subtyping or a LUB relationship between\n         // the `CoerceUnsized` target type and the expected type.\n         // We only have the latter, so we use an inference variable\n         // for the former and let type inference do the rest.\n         let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n         let coerce_target = self.next_ty_var(origin);\n-        let mut coercion = self.unify_and(coerce_target, target, adjust)?;\n+        let mut coercion = self.unify_and(coerce_target, target, |target| {\n+            let unsize = Adjustment {\n+                kind: Adjust::Unsize,\n+                target\n+            };\n+            match reborrow {\n+                None => vec![unsize],\n+                Some((ref deref, ref autoref)) => {\n+                    vec![deref.clone(), autoref.clone(), unsize]\n+                }\n+            }\n+        })?;\n \n         let mut selcx = traits::SelectionContext::new(self);\n \n@@ -541,13 +555,16 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         Ok(coercion)\n     }\n \n-    fn coerce_from_safe_fn(&self,\n-                           a: Ty<'tcx>,\n-                           fn_ty_a: ty::PolyFnSig<'tcx>,\n-                           b: Ty<'tcx>,\n-                           to_unsafe: Adjust<'tcx>,\n-                           normal: Adjust<'tcx>)\n-                           -> CoerceResult<'tcx> {\n+    fn coerce_from_safe_fn<F, G>(&self,\n+                                 a: Ty<'tcx>,\n+                                 fn_ty_a: ty::PolyFnSig<'tcx>,\n+                                 b: Ty<'tcx>,\n+                                 to_unsafe: F,\n+                                 normal: G)\n+                                 -> CoerceResult<'tcx>\n+        where F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n+              G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>\n+    {\n         if let ty::TyFnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n@@ -573,7 +590,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n         self.coerce_from_safe_fn(a, fn_ty_a, b,\n-            Adjust::UnsafeFnPointer, identity())\n+            simple(Adjust::UnsafeFnPointer), identity)\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -592,9 +609,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n                 self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b,\n-                    Adjust::ReifyFnPointer, Adjust::ReifyFnPointer)\n+                    simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))\n             }\n-            _ => self.unify_and(a, b, identity()),\n+            _ => self.unify_and(a, b, identity),\n         }\n     }\n \n@@ -636,9 +653,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 let pointer_ty = self.tcx.mk_fn_ptr(converted_sig);\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\",\n                        a, b, pointer_ty);\n-                self.unify_and(pointer_ty, b, Adjust::ClosureFnPointer)\n+                self.unify_and(pointer_ty, b, simple(Adjust::ClosureFnPointer))\n             }\n-            _ => self.unify_and(a, b, identity()),\n+            _ => self.unify_and(a, b, identity),\n         }\n     }\n \n@@ -653,7 +670,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.unify_and(a, b, identity());\n+                return self.unify_and(a, b, identity);\n             }\n         };\n \n@@ -666,17 +683,21 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        self.unify_and(a_unsafe, b, if is_ref {\n-            Adjust::DerefRef {\n-                autoderefs: 1,\n-                autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n-                unsize: false,\n-            }\n+        if is_ref {\n+            self.unify_and(a_unsafe, b, |target| {\n+                vec![Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    target: mt_a.ty\n+                }, Adjustment {\n+                    kind: Adjust::Borrow(AutoBorrow::RawPtr(mutbl_b)),\n+                    target\n+                }]\n+            })\n         } else if mt_a.mutbl != mutbl_b {\n-            Adjust::MutToConstPointer\n+            self.unify_and(a_unsafe, b, simple(Adjust::MutToConstPointer))\n         } else {\n-            identity()\n-        })\n+            self.unify_and(a_unsafe, b, identity)\n+        }\n     }\n }\n \n@@ -703,14 +724,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n         let coerce = Coerce::new(self, cause);\n-        let ok = self.commit_if_ok(|_| coerce.coerce(&[expr], source, target))?;\n-\n-        let adjustment = self.register_infer_ok_obligations(ok);\n-        self.apply_adjustment(expr.id, adjustment);\n+        let ok = self.commit_if_ok(|_| coerce.coerce(source, target))?;\n \n-        // We should now have added sufficient adjustments etc to\n-        // ensure that the type of expression, post-adjustment, is\n-        // a subtype of target.\n+        let (adjustments, _) = self.register_infer_ok_obligations(ok);\n+        self.apply_adjustments(expr, adjustments);\n         Ok(target)\n     }\n \n@@ -721,7 +738,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n         let coerce = Coerce::new(self, cause);\n-        self.probe(|_| coerce.coerce::<hir::Expr>(&[], source, target)).is_ok()\n+        self.probe(|_| coerce.coerce(source, target)).is_ok()\n     }\n \n     /// Given some expressions, their known unified type and another expression,\n@@ -779,10 +796,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n                     // The only adjustment that can produce an fn item is\n                     // `NeverToAny`, so this should always be valid.\n-                    self.apply_adjustment(expr.id, Adjustment {\n+                    self.apply_adjustments(expr, vec![Adjustment {\n                         kind: Adjust::ReifyFnPointer,\n                         target: fn_ptr\n-                    });\n+                    }]);\n                 }\n                 return Ok(fn_ptr);\n             }\n@@ -796,12 +813,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-            let result = self.commit_if_ok(|_| coerce.coerce(&[new], new_ty, prev_ty));\n+            let result = self.commit_if_ok(|_| coerce.coerce(new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n-                    let adjustment = self.register_infer_ok_obligations(ok);\n-                    self.apply_adjustment(new.id, adjustment);\n-                    return Ok(adjustment.target);\n+                    let (adjustments, target) = self.register_infer_ok_obligations(ok);\n+                    self.apply_adjustments(new, adjustments);\n+                    return Ok(target);\n                 }\n                 Err(e) => first_error = Some(e),\n             }\n@@ -812,25 +829,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n         for expr in exprs {\n             let expr = expr.as_coercion_site();\n-            let noop = match self.tables.borrow().adjustments.get(&expr.id).map(|adj| adj.kind) {\n-                Some(Adjust::DerefRef {\n-                    autoderefs: 1,\n-                    autoref: Some(AutoBorrow::Ref(_, mutbl_adj)),\n-                    unsize: false\n-                }) => {\n+            let noop = match self.tables.borrow().expr_adjustments(expr) {\n+                &[\n+                    Adjustment { kind: Adjust::Deref(_), .. },\n+                    Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n+                ] => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore, because\n-                            // the next adjustment can only be a DerefRef\n+                            // the next adjustment can only be a Deref\n                             // which will be merged into it.\n                             mutbl_adj == mt_orig.mutbl\n                         }\n                         _ => false,\n                     }\n                 }\n-                Some(Adjust::NeverToAny) => true,\n-                Some(_) => false,\n-                None => true,\n+                &[Adjustment { kind: Adjust::NeverToAny, .. }] | &[] => true,\n+                _ => false,\n             };\n \n             if !noop {\n@@ -841,7 +856,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        match self.commit_if_ok(|_| coerce.coerce(&exprs, prev_ty, new_ty)) {\n+        match self.commit_if_ok(|_| coerce.coerce(prev_ty, new_ty)) {\n             Err(_) => {\n                 // Avoid giving strange errors on failed attempts.\n                 if let Some(e) = first_error {\n@@ -854,12 +869,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             Ok(ok) => {\n-                let adjustment = self.register_infer_ok_obligations(ok);\n+                let (adjustments, target) = self.register_infer_ok_obligations(ok);\n                 for expr in exprs {\n                     let expr = expr.as_coercion_site();\n-                    self.apply_adjustment(expr.id, adjustment);\n+                    self.apply_adjustments(expr, adjustments.clone());\n                 }\n-                Ok(adjustment.target)\n+                Ok(target)\n             }\n         }\n     }"}, {"sha": "34e8d6b95a92679160faf150ba420f54d890080a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 94, "deletions": 72, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::probe;\n+use super::{probe, MethodCallee};\n \n use check::{FnCtxt, LvalueOp, callee};\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, OverloadedDeref};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n@@ -45,7 +45,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           unadjusted_self_ty: Ty<'tcx>,\n                           pick: probe::Pick<'tcx>,\n                           supplied_method_types: Vec<Ty<'tcx>>)\n-                          -> ty::MethodCallee<'tcx> {\n+                          -> MethodCallee<'tcx> {\n         debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n                unadjusted_self_ty,\n                pick,\n@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n                supplied_method_types: Vec<Ty<'tcx>>)\n-               -> ty::MethodCallee<'tcx> {\n+               -> MethodCallee<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n \n@@ -88,19 +88,20 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         debug!(\"all_substs={:?}\", all_substs);\n \n         // Create the final signature for the method, replacing late-bound regions.\n-        let (method_ty, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n+        let (method_sig, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n \n         // Unify the (adjusted) self type with what the method expects.\n-        self.unify_receivers(self_ty, method_ty.fn_sig().input(0).skip_binder());\n+        self.unify_receivers(self_ty, method_sig.inputs()[0]);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n+        let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n         self.add_obligations(method_ty, all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n-        let callee = ty::MethodCallee {\n+        let callee = MethodCallee {\n             def_id: pick.item.def_id,\n-            ty: method_ty,\n             substs: all_substs,\n+            sig: method_sig,\n         };\n \n         if let Some(hir::MutMutable) = pick.autoref {\n@@ -117,40 +118,49 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                       unadjusted_self_ty: Ty<'tcx>,\n                       pick: &probe::Pick<'tcx>)\n                       -> Ty<'tcx> {\n-        let autoref = if let Some(mutbl) = pick.autoref {\n+        // Commit the autoderefs by calling `autoderef` again, but this\n+        // time writing the results into the various tables.\n+        let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n+        let (_, n) = autoderef.nth(pick.autoderefs).unwrap();\n+        assert_eq!(n, pick.autoderefs);\n+\n+        let mut adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+\n+        let mut target = autoderef.unambiguous_final_ty();\n+\n+        if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n-            Some(AutoBorrow::Ref(region, mutbl))\n+            target = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                mutbl,\n+                ty: target\n+            });\n+            adjustments.push(Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                target\n+            });\n+\n+            if let Some(unsize_target) = pick.unsize {\n+                target = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                    mutbl,\n+                    ty: unsize_target\n+                });\n+                adjustments.push(Adjustment {\n+                    kind: Adjust::Unsize,\n+                    target\n+                });\n+            }\n         } else {\n             // No unsizing should be performed without autoref (at\n             // least during method dispach). This is because we\n             // currently only unsize `[T;N]` to `[T]`, and naturally\n             // that must occur being a reference.\n             assert!(pick.unsize.is_none());\n-            None\n-        };\n-\n-\n-        // Commit the autoderefs by calling `autoderef` again, but this\n-        // time writing the results into the various tables.\n-        let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n-        let (autoderefd_ty, n) = autoderef.nth(pick.autoderefs).unwrap();\n-        assert_eq!(n, pick.autoderefs);\n-\n-        autoderef.unambiguous_final_ty();\n-        autoderef.finalize(LvaluePreference::NoPreference, self.self_expr);\n+        }\n \n-        let target = pick.unsize.unwrap_or(autoderefd_ty);\n-        let target = target.adjust_for_autoref(self.tcx, autoref);\n+        autoderef.finalize();\n \n-        // Write out the final adjustment.\n-        self.apply_adjustment(self.self_expr.id, Adjustment {\n-            kind: Adjust::DerefRef {\n-                autoderefs: pick.autoderefs,\n-                autoref: autoref,\n-                unsize: pick.unsize.is_some(),\n-            },\n-            target: target\n-        });\n+        // Write out the final adjustments.\n+        self.apply_adjustments(self.self_expr, adjustments);\n \n         target\n     }\n@@ -349,7 +359,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick<'tcx>,\n                               all_substs: &'tcx Substs<'tcx>)\n-                              -> (Ty<'tcx>, ty::InstantiatedPredicates<'tcx>) {\n+                              -> (ty::FnSig<'tcx>, ty::InstantiatedPredicates<'tcx>) {\n         debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n                pick,\n                all_substs);\n@@ -380,8 +390,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let method_sig = self.instantiate_type_scheme(self.span, all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={:?}\", method_sig);\n \n-        (self.tcx.mk_fn_def(def_id, all_substs, ty::Binder(method_sig)),\n-         method_predicates)\n+        (method_sig, method_predicates)\n     }\n \n     fn add_obligations(&mut self,\n@@ -436,19 +445,23 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded lvalue ops, and will be fixed by them in order to get\n             // the correct region.\n-            let autoderefs = match self.tables.borrow().adjustments.get(&expr.id) {\n-                Some(&Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => autoderefs,\n-                Some(_) | None => 0\n-            };\n-\n-            if autoderefs > 0 {\n-                let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n-                autoderef.nth(autoderefs).unwrap_or_else(|| {\n-                    span_bug!(expr.span,\n-                              \"expr was deref-able {} times but now isn't?\",\n-                              autoderefs);\n-                });\n-                autoderef.finalize(PreferMutLvalue, expr);\n+            let mut source = self.node_ty(expr.id);\n+            if let Some(adjustments) = self.tables.borrow_mut().adjustments.get_mut(&expr.id) {\n+                let pref = LvaluePreference::PreferMutLvalue;\n+                for adjustment in adjustments {\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n+                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, pref) {\n+                            let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::TyRef(region, mt) = method.sig.output().sty {\n+                                *deref = OverloadedDeref {\n+                                    region,\n+                                    mutbl: mt.mutbl\n+                                };\n+                            }\n+                        }\n+                    }\n+                    source = adjustment.target;\n+                }\n             }\n \n             match expr.node {\n@@ -474,13 +487,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"convert_lvalue_op_to_mutable({:?}, {:?}, {:?}, {:?})\",\n                op, expr, base_expr, arg_tys);\n-        let method_call = ty::MethodCall::expr(expr.id);\n-        if !self.tables.borrow().method_map.contains_key(&method_call) {\n+        if !self.tables.borrow().is_method_call(expr) {\n             debug!(\"convert_lvalue_op_to_mutable - builtin, nothing to do\");\n             return\n         }\n \n-        let base_ty = self.tables.borrow().adjustments.get(&base_expr.id)\n+        let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n             .map_or_else(|| self.node_ty(expr.id), |adj| adj.target);\n         let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n \n@@ -490,34 +502,44 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .ty;\n \n         let method = self.try_overloaded_lvalue_op(\n-            expr.span, None, base_ty, arg_tys, PreferMutLvalue, op);\n-        let ok = match method {\n-            Some(method) => method,\n+            expr.span, base_ty, arg_tys, PreferMutLvalue, op);\n+        let method = match method {\n+            Some(ok) => self.register_infer_ok_obligations(ok),\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n-        let method = self.register_infer_ok_obligations(ok);\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n-        self.tables.borrow_mut().method_map.insert(method_call, method);\n+        self.write_method_call(expr.id, method);\n+\n+        let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n+            (r, mt.mutbl)\n+        } else {\n+            span_bug!(expr.span, \"input to lvalue op is not a ref?\");\n+        };\n \n         // Convert the autoref in the base expr to mutable with the correct\n         // region and mutability.\n-        if let Some(&mut Adjustment {\n-            ref mut target, kind: Adjust::DerefRef {\n-                autoref: Some(AutoBorrow::Ref(ref mut r, ref mut mutbl)), ..\n+        let base_expr_ty = self.node_ty(base_expr.id);\n+        if let Some(adjustments) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n+            let mut source = base_expr_ty;\n+            for adjustment in &mut adjustments[..] {\n+                if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n+                    debug!(\"convert_lvalue_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n+                    adjustment.target = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                        ty: source,\n+                        mutbl\n+                    });\n+                }\n+                source = adjustment.target;\n             }\n-        }) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n-            debug!(\"convert_lvalue_op_to_mutable: converting autoref of {:?}\", target);\n-\n-            // extract method return type, which will be &mut T;\n-            // all LB regions should have been instantiated during method lookup\n-            let method_sig = self.tcx.no_late_bound_regions(&method.ty.fn_sig()).unwrap();\n \n-            *target = method_sig.inputs()[0];\n-            if let ty::TyRef(r_, mt) = target.sty {\n-                *r = r_;\n-                *mutbl = mt.mutbl;\n-            } else {\n-                span_bug!(expr.span, \"input to lvalue op is not a ref?\");\n+            // If we have an autoref followed by unsizing at the end, fix the unsize target.\n+            match adjustments[..] {\n+                [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. },\n+                 Adjustment { kind: Adjust::Unsize, ref mut target }] => {\n+                    *target = method.sig.inputs()[0];\n+                }\n+                _ => {}\n             }\n         }\n     }"}, {"sha": "b0ac61d2cc34af7aad8685a55787de77ded36db3", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 32, "deletions": 59, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -10,13 +10,12 @@\n \n //! Method lookup: the secret sauce of Rust. See `README.md`.\n \n-use check::{FnCtxt, AdjustedRcvr};\n+use check::FnCtxt;\n use hir::def::Def;\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::subst::Subst;\n use rustc::infer::{self, InferOk};\n \n@@ -36,6 +35,18 @@ mod suggest;\n \n use self::probe::IsSuggestion;\n \n+#[derive(Clone, Copy, Debug)]\n+pub struct MethodCallee<'tcx> {\n+    /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+\n+    /// Instantiated method signature, i.e. it has been\n+    /// substituted, normalized, and has had late-bound\n+    /// lifetimes replaced with inference variables.\n+    pub sig: ty::FnSig<'tcx>,\n+}\n+\n pub enum MethodError<'tcx> {\n     // Did not find an applicable method, but we did find various near-misses that may work.\n     NoMatch(NoMatchData<'tcx>),\n@@ -125,7 +136,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          supplied_method_types: Vec<ty::Ty<'tcx>>,\n                          call_expr: &'gcx hir::Expr,\n                          self_expr: &'gcx hir::Expr)\n-                         -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>> {\n+                         -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n                method_name,\n                self_ty,\n@@ -153,29 +164,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                supplied_method_types))\n     }\n \n-    /// `lookup_in_trait_adjusted` is used for overloaded operators.\n+    /// `lookup_method_in_trait` is used for overloaded operators.\n     /// It does a very narrow slice of what the normal probe/confirm path does.\n     /// In particular, it doesn't really do any probing: it simply constructs\n     /// an obligation for aparticular trait with the given self-type and checks\n     /// whether that trait is implemented.\n     ///\n     /// FIXME(#18741) -- It seems likely that we can consolidate some of this\n-    /// code with the other method-lookup code. In particular, autoderef on\n-    /// index is basically identical to autoderef with normal probes, except\n-    /// that the test also looks for built-in indexing. Also, the second half of\n-    /// this method is basically the same as confirmation.\n-    pub fn lookup_method_in_trait_adjusted(&self,\n-                                           span: Span,\n-                                           self_info: Option<AdjustedRcvr>,\n-                                           m_name: ast::Name,\n-                                           trait_def_id: DefId,\n-                                           self_ty: ty::Ty<'tcx>,\n-                                           opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                           -> Option<InferOk<'tcx, ty::MethodCallee<'tcx>>> {\n-        debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_info={:?}, \\\n+    /// code with the other method-lookup code. In particular, the second half\n+    /// of this method is basically the same as confirmation.\n+    pub fn lookup_method_in_trait(&self,\n+                                  span: Span,\n+                                  m_name: ast::Name,\n+                                  trait_def_id: DefId,\n+                                  self_ty: ty::Ty<'tcx>,\n+                                  opt_input_types: Option<&[ty::Ty<'tcx>]>)\n+                                  -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n+        debug!(\"lookup_in_trait_adjusted(self_ty={:?}, \\\n                 m_name={}, trait_def_id={:?})\",\n                self_ty,\n-               self_info,\n                m_name,\n                trait_def_id);\n \n@@ -225,8 +232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let original_method_ty = tcx.type_of(def_id);\n-        let fn_sig = original_method_ty.fn_sig();\n+        let fn_sig = tcx.type_of(def_id).fn_sig();\n         let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n                                                                     infer::FnCall,\n                                                                     &fn_sig).0;\n@@ -237,12 +243,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 value\n             }\n         };\n-        let transformed_self_ty = fn_sig.inputs()[0];\n-        let method_ty = tcx.mk_fn_def(def_id, substs, ty::Binder(fn_sig));\n-\n-        debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n-               method_ty,\n-               obligation);\n \n         // Register obligations for the parameters.  This will include the\n         // `Self` parameter, which in turn has a bound of the main trait,\n@@ -265,43 +265,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         obligations.extend(traits::predicates_for_generics(cause.clone(), &bounds));\n \n         // Also add an obligation for the method type being well-formed.\n+        let method_ty = tcx.mk_fn_ptr(ty::Binder(fn_sig));\n+        debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n+               method_ty,\n+               obligation);\n         obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n \n-        // Insert any adjustments needed (always an autoref of some mutability).\n-        if let Some(AdjustedRcvr { rcvr_expr, autoderefs, unsize }) = self_info {\n-            debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n-                    (self-id={}, autoderefs={}, unsize={}, fty={:?})\",\n-                    rcvr_expr.id, autoderefs, unsize, original_method_ty);\n-\n-            let original_sig = original_method_ty.fn_sig();\n-            let autoref = match (&original_sig.input(0).skip_binder().sty,\n-                                 &transformed_self_ty.sty) {\n-                (&ty::TyRef(..), &ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ })) => {\n-                    // Trait method is fn(&self) or fn(&mut self), need an\n-                    // autoref. Pull the region etc out of the type of first argument.\n-                    Some(AutoBorrow::Ref(region, mutbl))\n-                }\n-                _ => {\n-                    // Trait method is fn(self), no transformation needed.\n-                    assert!(!unsize);\n-                    None\n-                }\n-            };\n-\n-            self.apply_adjustment(rcvr_expr.id, Adjustment {\n-                kind: Adjust::DerefRef {\n-                    autoderefs: autoderefs,\n-                    autoref: autoref,\n-                    unsize: unsize\n-                },\n-                target: transformed_self_ty\n-            });\n-        }\n-\n-        let callee = ty::MethodCallee {\n+        let callee = MethodCallee {\n             def_id: def_id,\n-            ty: method_ty,\n             substs: trait_ref.substs,\n+            sig: fn_sig,\n         };\n \n         debug!(\"callee = {:?}\", callee);"}, {"sha": "32c3f5c8a5edd98a65207489395fc4c1ec3a16d7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 159, "deletions": 208, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -52,7 +52,7 @@ can be broken down into several distinct phases:\n \n While type checking a function, the intermediate types for the\n expressions, blocks, and so forth contained within the function are\n-stored in `fcx.node_types` and `fcx.item_substs`.  These types\n+stored in `fcx.node_types` and `fcx.node_substs`.  These types\n may contain unresolved type variables.  After type checking is\n complete, the functions in the writeback module are used to take the\n types from this table, resolve them, and then write them into their\n@@ -77,8 +77,11 @@ type parameter).\n */\n \n pub use self::Expectation::*;\n+use self::autoderef::Autoderef;\n+use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n+use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n use astconv::AstConv;\n@@ -93,7 +96,6 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n-use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::maps::Providers;\n@@ -168,7 +170,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // decision. We keep these deferred resolutions grouped by the\n     // def-id of the closure, so that once we decide, we can easily go\n     // back and process them.\n-    deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'gcx, 'tcx>>>>,\n+    deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolution<'gcx, 'tcx>>>>,\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n@@ -194,12 +196,6 @@ impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n     }\n }\n \n-trait DeferredCallResolution<'gcx, 'tcx> {\n-    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>);\n-}\n-\n-type DeferredCallResolutionHandler<'gcx, 'tcx> = Box<DeferredCallResolution<'gcx, 'tcx>+'tcx>;\n-\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n #[derive(Copy, Clone, Debug)]\n@@ -375,13 +371,6 @@ pub enum LvalueOp {\n     Index\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct AdjustedRcvr<'a> {\n-    pub rcvr_expr: &'a hir::Expr,\n-    pub autoderefs: usize,\n-    pub unsize: bool\n-}\n-\n /// Tracks whether executing a node may exit normally (versus\n /// return/break/panic, which \"diverge\", leaving dead code in their\n /// wake). Tracked semi-automatically (through type variables marked\n@@ -1729,17 +1718,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn record_deferred_call_resolution(&self,\n                                        closure_def_id: DefId,\n-                                       r: DeferredCallResolutionHandler<'gcx, 'tcx>) {\n+                                       r: DeferredCallResolution<'gcx, 'tcx>) {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.entry(closure_def_id).or_insert(vec![]).push(r);\n     }\n \n     fn remove_deferred_call_resolutions(&self,\n                                         closure_def_id: DefId)\n-                                        -> Vec<DeferredCallResolutionHandler<'gcx, 'tcx>>\n+                                        -> Vec<DeferredCallResolution<'gcx, 'tcx>>\n     {\n         let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n-        deferred_call_resolutions.remove(&closure_def_id).unwrap_or(Vec::new())\n+        deferred_call_resolutions.remove(&closure_def_id).unwrap_or(vec![])\n     }\n \n     pub fn tag(&self) -> String {\n@@ -1769,65 +1758,54 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n-        if !substs.substs.is_noop() {\n+    pub fn write_method_call(&self, node_id: ast::NodeId, method: MethodCallee<'tcx>) {\n+        self.tables.borrow_mut().type_dependent_defs.insert(node_id, Def::Method(method.def_id));\n+        self.write_substs(node_id, method.substs);\n+    }\n+\n+    pub fn write_substs(&self, node_id: ast::NodeId, substs: &'tcx Substs<'tcx>) {\n+        if !substs.is_noop() {\n             debug!(\"write_substs({}, {:?}) in fcx {}\",\n                    node_id,\n                    substs,\n                    self.tag());\n \n-            self.tables.borrow_mut().item_substs.insert(node_id, substs);\n+            self.tables.borrow_mut().node_substs.insert(node_id, substs);\n         }\n     }\n \n-    pub fn apply_autoderef_adjustment(&self,\n-                                      node_id: ast::NodeId,\n-                                      derefs: usize,\n-                                      adjusted_ty: Ty<'tcx>) {\n-        self.apply_adjustment(node_id, Adjustment {\n-            kind: Adjust::DerefRef {\n-                autoderefs: derefs,\n-                autoref: None,\n-                unsize: false\n-            },\n-            target: adjusted_ty\n-        });\n-    }\n-\n-    pub fn apply_adjustment(&self, node_id: ast::NodeId, adj: Adjustment<'tcx>) {\n-        debug!(\"apply_adjustment(node_id={}, adj={:?})\", node_id, adj);\n+    pub fn apply_adjustments(&self, expr: &hir::Expr, adj: Vec<Adjustment<'tcx>>) {\n+        debug!(\"apply_adjustments(expr={:?}, adj={:?})\", expr, adj);\n \n-        if adj.is_identity() {\n+        if adj.is_empty() {\n             return;\n         }\n \n-        match self.tables.borrow_mut().adjustments.entry(node_id) {\n+        match self.tables.borrow_mut().adjustments.entry(expr.id) {\n             Entry::Vacant(entry) => { entry.insert(adj); },\n             Entry::Occupied(mut entry) => {\n                 debug!(\" - composing on top of {:?}\", entry.get());\n-                let composed_kind = match (entry.get().kind, adj.kind) {\n+                match (&entry.get()[..], &adj[..]) {\n                     // Applying any adjustment on top of a NeverToAny\n                     // is a valid NeverToAny adjustment, because it can't\n                     // be reached.\n-                    (Adjust::NeverToAny, _) => Adjust::NeverToAny,\n-                    (Adjust::DerefRef {\n-                        autoderefs: 1,\n-                        autoref: Some(AutoBorrow::Ref(..)),\n-                        unsize: false\n-                    }, Adjust::DerefRef { autoderefs, .. }) if autoderefs > 0 => {\n+                    (&[Adjustment { kind: Adjust::NeverToAny, .. }], _) => return,\n+                    (&[\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. },\n+                    ], &[\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        .. // Any following adjustments are allowed.\n+                    ]) => {\n                         // A reborrow has no effect before a dereference.\n-                        adj.kind\n                     }\n                     // FIXME: currently we never try to compose autoderefs\n                     // and ReifyFnPointer/UnsafeFnPointer, but we could.\n                     _ =>\n-                        bug!(\"while adjusting {}, can't compose {:?} and {:?}\",\n-                             node_id, entry.get(), adj)\n-                };\n-                *entry.get_mut() = Adjustment {\n-                    kind: composed_kind,\n-                    target: adj.target\n+                        bug!(\"while adjusting {:?}, can't compose {:?} and {:?}\",\n+                             expr, entry.get(), adj)\n                 };\n+                *entry.get_mut() = adj;\n             }\n         }\n     }\n@@ -1972,16 +1950,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn opt_node_ty_substs<F>(&self,\n-                                 id: ast::NodeId,\n-                                 f: F) where\n-        F: FnOnce(&ty::ItemSubsts<'tcx>),\n-    {\n-        if let Some(s) = self.tables.borrow().item_substs.get(&id) {\n-            f(s);\n-        }\n-    }\n-\n     /// Registers an obligation for checking later, during regionck, that the type `ty` must\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n@@ -2169,8 +2137,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         // extract method return type, which will be &T;\n         // all LB regions should have been instantiated during method lookup\n-        let ret_ty = method.ty.fn_ret();\n-        let ret_ty = self.tcx.no_late_bound_regions(&ret_ty).unwrap();\n+        let ret_ty = method.sig.output();\n \n         // method returns &T, but the type as visible to user is T, so deref\n         ret_ty.builtin_deref(true, NoPreference).unwrap()\n@@ -2189,32 +2156,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // consolidated.\n \n         let mut autoderef = self.autoderef(base_expr.span, base_ty);\n-\n-        while let Some((adj_ty, autoderefs)) = autoderef.next() {\n-            if let Some(final_mt) = self.try_index_step(\n-                MethodCall::expr(expr.id), expr, Some(AdjustedRcvr {\n-                    rcvr_expr: base_expr,\n-                    autoderefs,\n-                    unsize: false\n-                }), base_expr.span, adj_ty, lvalue_pref, idx_ty)\n-            {\n-                autoderef.finalize(lvalue_pref, base_expr);\n-                return Some(final_mt);\n-            }\n-\n-            if let ty::TyArray(element_ty, _) = adj_ty.sty {\n-                autoderef.finalize(lvalue_pref, base_expr);\n-                let adj_ty = self.tcx.mk_slice(element_ty);\n-                return self.try_index_step(\n-                    MethodCall::expr(expr.id), expr, Some(AdjustedRcvr {\n-                        rcvr_expr: base_expr,\n-                        autoderefs,\n-                        unsize: true\n-                    }), base_expr.span, adj_ty, lvalue_pref, idx_ty)\n-            }\n+        let mut result = None;\n+        while result.is_none() && autoderef.next().is_some() {\n+            result = self.try_index_step(expr, base_expr, &autoderef, lvalue_pref, idx_ty);\n         }\n-        autoderef.unambiguous_final_ty();\n-        None\n+        autoderef.finalize();\n+        result\n     }\n \n     /// To type-check `base_expr[index_expr]`, we progressively autoderef\n@@ -2223,52 +2170,82 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This loop implements one step in that search; the autoderef loop\n     /// is implemented by `lookup_indexing`.\n     fn try_index_step(&self,\n-                      method_call: MethodCall,\n                       expr: &hir::Expr,\n-                      base_expr: Option<AdjustedRcvr>,\n-                      base_span: Span,\n-                      adjusted_ty: Ty<'tcx>,\n+                      base_expr: &hir::Expr,\n+                      autoderef: &Autoderef<'a, 'gcx, 'tcx>,\n                       lvalue_pref: LvaluePreference,\n                       index_ty: Ty<'tcx>)\n                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n-        let tcx = self.tcx;\n+        let adjusted_ty = autoderef.unambiguous_final_ty();\n         debug!(\"try_index_step(expr={:?}, base_expr={:?}, adjusted_ty={:?}, \\\n                                index_ty={:?})\",\n                expr,\n                base_expr,\n                adjusted_ty,\n                index_ty);\n \n-        let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_span));\n \n         // First, try built-in indexing.\n         match (adjusted_ty.builtin_index(), &index_ty.sty) {\n             (Some(ty), &ty::TyUint(ast::UintTy::Us)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n-                // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n-                if let Some(base_expr) = base_expr {\n-                    assert!(!base_expr.unsize);\n-                    self.apply_autoderef_adjustment(\n-                        base_expr.rcvr_expr.id, base_expr.autoderefs, adjusted_ty);\n-                }\n-                return Some((tcx.types.usize, ty));\n+                let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                self.apply_adjustments(base_expr, adjustments);\n+                return Some((self.tcx.types.usize, ty));\n             }\n             _ => {}\n         }\n \n-        // If some lookup succeeds, write callee into table and extract index/element\n-        // type from the method signature.\n-        // If some lookup succeeded, install method in table\n-        let method = self.try_overloaded_lvalue_op(\n-            expr.span, base_expr, adjusted_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n-\n-        method.map(|ok| {\n-            debug!(\"try_index_step: success, using overloaded indexing\");\n-            let method = self.register_infer_ok_obligations(ok);\n-            self.tables.borrow_mut().method_map.insert(method_call, method);\n-            (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n-        })\n+        for &unsize in &[false, true] {\n+            let mut self_ty = adjusted_ty;\n+            if unsize {\n+                // We only unsize arrays here.\n+                if let ty::TyArray(element_ty, _) = adjusted_ty.sty {\n+                    self_ty = self.tcx.mk_slice(element_ty);\n+                } else {\n+                    continue;\n+                }\n+            }\n+\n+            // If some lookup succeeds, write callee into table and extract index/element\n+            // type from the method signature.\n+            // If some lookup succeeded, install method in table\n+            let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n+            let method = self.try_overloaded_lvalue_op(\n+                expr.span, self_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n+\n+            let result = method.map(|ok| {\n+                debug!(\"try_index_step: success, using overloaded indexing\");\n+                let method = self.register_infer_ok_obligations(ok);\n+\n+                let mut adjustments = autoderef.adjust_steps(lvalue_pref);\n+                if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                        target: self.tcx.mk_ref(region, ty::TypeAndMut {\n+                            mutbl: mt.mutbl,\n+                            ty: adjusted_ty\n+                        })\n+                    });\n+                }\n+                if unsize {\n+                    adjustments.push(Adjustment {\n+                        kind: Adjust::Unsize,\n+                        target: method.sig.inputs()[0]\n+                    });\n+                }\n+                self.apply_adjustments(base_expr, adjustments);\n+\n+                self.write_method_call(expr.id, method);\n+                (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n+            });\n+            if result.is_some() {\n+                return result;\n+            }\n+        }\n+\n+        None\n     }\n \n     fn resolve_lvalue_op(&self, op: LvalueOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n@@ -2287,16 +2264,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn try_overloaded_lvalue_op(&self,\n                                 span: Span,\n-                                base_expr: Option<AdjustedRcvr>,\n                                 base_ty: Ty<'tcx>,\n                                 arg_tys: &[Ty<'tcx>],\n                                 lvalue_pref: LvaluePreference,\n                                 op: LvalueOp)\n                                 -> Option<InferOk<'tcx, MethodCallee<'tcx>>>\n     {\n-        debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?},{:?})\",\n+        debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?})\",\n                span,\n-               base_expr,\n                base_ty,\n                lvalue_pref,\n                op);\n@@ -2305,12 +2280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let (mut_tr, mut_op) = self.resolve_lvalue_op(op, true);\n         let method = match (lvalue_pref, mut_tr) {\n             (PreferMutLvalue, Some(trait_did)) => {\n-                self.lookup_method_in_trait_adjusted(span,\n-                                                     base_expr,\n-                                                     mut_op,\n-                                                     trait_did,\n-                                                     base_ty,\n-                                                     Some(arg_tys.to_owned()))\n+                self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n             }\n             _ => None,\n         };\n@@ -2319,12 +2289,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let (imm_tr, imm_op) = self.resolve_lvalue_op(op, false);\n         let method = match (method, imm_tr) {\n             (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait_adjusted(span,\n-                                                     base_expr,\n-                                                     imm_op,\n-                                                     trait_did,\n-                                                     base_ty,\n-                                                     Some(arg_tys.to_owned()))\n+                self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))\n             }\n             (method, _) => method,\n         };\n@@ -2334,13 +2299,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_method_argument_types(&self,\n                                    sp: Span,\n-                                   method_fn_ty: Ty<'tcx>,\n-                                   callee_expr: &'gcx hir::Expr,\n+                                   method: Result<MethodCallee<'tcx>, ()>,\n                                    args_no_rcvr: &'gcx [hir::Expr],\n                                    tuple_arguments: TupleArgumentsFlag,\n                                    expected: Expectation<'tcx>)\n                                    -> Ty<'tcx> {\n-        if method_fn_ty.references_error() {\n+        let has_error = match method {\n+            Ok(method) => {\n+                method.substs.references_error() || method.sig.references_error()\n+            }\n+            Err(_) => true\n+        };\n+        if has_error {\n             let err_inputs = self.err_args(args_no_rcvr.len());\n \n             let err_inputs = match tuple_arguments {\n@@ -2350,27 +2320,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             self.check_argument_types(sp, &err_inputs[..], &[], args_no_rcvr,\n                                       false, tuple_arguments, None);\n-            self.tcx.types.err\n-        } else {\n-            match method_fn_ty.sty {\n-                ty::TyFnDef(def_id, .., ref fty) => {\n-                    // HACK(eddyb) ignore self in the definition (see above).\n-                    let expected_arg_tys = self.expected_inputs_for_expected_output(\n-                        sp,\n-                        expected,\n-                        fty.0.output(),\n-                        &fty.0.inputs()[1..]\n-                    );\n-                    self.check_argument_types(sp, &fty.0.inputs()[1..], &expected_arg_tys[..],\n-                                              args_no_rcvr, fty.0.variadic, tuple_arguments,\n-                                              self.tcx.hir.span_if_local(def_id));\n-                    fty.0.output()\n-                }\n-                _ => {\n-                    span_bug!(callee_expr.span, \"method without bare fn type\");\n-                }\n-            }\n+            return self.tcx.types.err;\n         }\n+\n+        let method = method.unwrap();\n+        // HACK(eddyb) ignore self in the definition (see above).\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(\n+            sp,\n+            expected,\n+            method.sig.output(),\n+            &method.sig.inputs()[1..]\n+        );\n+        self.check_argument_types(sp, &method.sig.inputs()[1..], &expected_arg_tys[..],\n+                                  args_no_rcvr, method.sig.variadic, tuple_arguments,\n+                                  self.tcx.hir.span_if_local(method.def_id));\n+        method.sig.output()\n     }\n \n     /// Generic function that factors out common logic from function calls,\n@@ -2669,10 +2633,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n-            self.apply_adjustment(expr.id, Adjustment {\n+            self.apply_adjustments(expr, vec![Adjustment {\n                 kind: Adjust::NeverToAny,\n                 target: adj_ty\n-            });\n+            }]);\n             ty = adj_ty;\n         }\n \n@@ -2795,17 +2759,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_t = self.structurally_resolved_type(expr.span, rcvr_t);\n \n         let tps = tps.iter().map(|ast_ty| self.to_ty(&ast_ty)).collect::<Vec<_>>();\n-        let fn_ty = match self.lookup_method(method_name.span,\n-                                             method_name.node,\n-                                             expr_t,\n-                                             tps,\n-                                             expr,\n-                                             rcvr) {\n+        let method = match self.lookup_method(method_name.span,\n+                                              method_name.node,\n+                                              expr_t,\n+                                              tps,\n+                                              expr,\n+                                              rcvr) {\n             Ok(method) => {\n-                let method_ty = method.ty;\n-                let method_call = MethodCall::expr(expr.id);\n-                self.tables.borrow_mut().method_map.insert(method_call, method);\n-                method_ty\n+                self.write_method_call(expr.id, method);\n+                Ok(method)\n             }\n             Err(error) => {\n                 if method_name.node != keywords::Invalid.name() {\n@@ -2816,18 +2778,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              error,\n                                              Some(args));\n                 }\n-                self.write_error(expr.id);\n-                self.tcx.types.err\n+                Err(())\n             }\n         };\n \n         // Call the generic checker.\n-        let ret_ty = self.check_method_argument_types(method_name.span, fn_ty,\n-                                                      expr, &args[1..],\n-                                                      DontTupleArguments,\n-                                                      expected);\n-\n-        ret_ty\n+        self.check_method_argument_types(method_name.span, method,\n+                                         &args[1..],\n+                                         DontTupleArguments,\n+                                         expected)\n     }\n \n     fn check_return_expr(&self, return_expr: &'gcx hir::Expr) {\n@@ -2912,7 +2871,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, autoderefs)) = autoderef.next() {\n+        while let Some((base_t, _)) = autoderef.next() {\n             match base_t.sty {\n                 ty::TyAdt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n@@ -2922,8 +2881,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            autoderef.finalize(lvalue_pref, base);\n-                            self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n+                            let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                            self.apply_adjustments(base, adjustments);\n+                            autoderef.finalize();\n \n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n \n@@ -3020,7 +2980,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut private_candidate = None;\n         let mut tuple_like = false;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, autoderefs)) = autoderef.next() {\n+        while let Some((base_t, _)) = autoderef.next() {\n             let field = match base_t.sty {\n                 ty::TyAdt(base_def, substs) if base_def.is_struct() => {\n                     tuple_like = base_def.struct_variant().ctor_kind == CtorKind::Fn;\n@@ -3055,8 +3015,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Some(field_ty) = field {\n-                autoderef.finalize(lvalue_pref, base);\n-                self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n+                let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                self.apply_adjustments(base, adjustments);\n+                autoderef.finalize();\n                 return field_ty;\n             }\n         }\n@@ -3463,18 +3424,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                                lvalue_pref);\n \n             if !oprnd_t.references_error() {\n+                oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n                 match unop {\n                     hir::UnDeref => {\n-                        oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n-\n                         if let Some(mt) = oprnd_t.builtin_deref(true, NoPreference) {\n                             oprnd_t = mt.ty;\n                         } else if let Some(ok) = self.try_overloaded_deref(\n-                                expr.span, Some(&oprnd), oprnd_t, lvalue_pref) {\n+                                expr.span, oprnd_t, lvalue_pref) {\n                             let method = self.register_infer_ok_obligations(ok);\n+                            if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                                self.apply_adjustments(oprnd, vec![Adjustment {\n+                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                                    target: method.sig.inputs()[0]\n+                                }]);\n+                            }\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n-                            self.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n-                                                                           method);\n+                            self.write_method_call(expr.id, method);\n                         } else {\n                             self.type_error_message(expr.span, |actual| {\n                                 format!(\"type `{}` cannot be \\\n@@ -3484,22 +3449,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     hir::UnNot => {\n-                        oprnd_t = self.structurally_resolved_type(oprnd.span,\n-                                                                  oprnd_t);\n-                        let result = self.check_user_unop(\"!\", \"not\",\n-                                                          tcx.lang_items.not_trait(),\n-                                                          expr, &oprnd, oprnd_t, unop);\n+                        let result = self.check_user_unop(expr, oprnd_t, unop);\n                         // If it's builtin, we can reuse the type, this helps inference.\n                         if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n                             oprnd_t = result;\n                         }\n                     }\n                     hir::UnNeg => {\n-                        oprnd_t = self.structurally_resolved_type(oprnd.span,\n-                                                                  oprnd_t);\n-                        let result = self.check_user_unop(\"-\", \"neg\",\n-                                                          tcx.lang_items.neg_trait(),\n-                                                          expr, &oprnd, oprnd_t, unop);\n+                        let result = self.check_user_unop(expr, oprnd_t, unop);\n                         // If it's builtin, we can reuse the type, this helps inference.\n                         if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n                             oprnd_t = result;\n@@ -3561,9 +3518,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               // We always require that the type provided as the value for\n               // a type parameter outlives the moment of instantiation.\n-              self.opt_node_ty_substs(expr.id, |item_substs| {\n-                  self.add_wf_bounds(&item_substs.substs, expr);\n-              });\n+              let substs = self.tables.borrow().node_substs(expr.id);\n+              self.add_wf_bounds(substs, expr);\n \n               ty\n           }\n@@ -3940,7 +3896,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n-    // The newly resolved definition is written into `type_relative_path_defs`.\n+    // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,\n                                     qpath: &hir::QPath,\n                                     path_span: Span,\n@@ -3965,15 +3921,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    ty, def, segment);\n \n                 // Write back the new resolution.\n-                self.tables.borrow_mut().type_relative_path_defs.insert(node_id, def);\n+                self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n \n                 (def, ty)\n             }\n         }\n     }\n \n     // Resolve associated value path into a base type and associated constant or method definition.\n-    // The newly resolved definition is written into `type_relative_path_defs`.\n+    // The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n                                        qpath: &'b hir::QPath,\n                                        node_id: ast::NodeId,\n@@ -4006,7 +3962,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Write back the new resolution.\n-        self.tables.borrow_mut().type_relative_path_defs.insert(node_id, def);\n+        self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n         (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n \n@@ -4386,9 +4342,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let ty = self.local_ty(span, nid);\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(node_id, ty);\n-                self.write_substs(node_id, ty::ItemSubsts {\n-                    substs: self.tcx.intern_substs(&[])\n-                });\n                 return ty;\n             }\n             _ => {}\n@@ -4520,9 +4473,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_substs(node_id, ty::ItemSubsts {\n-            substs: substs\n-        });\n+        self.write_substs(node_id, substs);\n         ty_substituted\n     }\n "}, {"sha": "8e5b7a6546973425553455f0cdfe98c44678a041", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 77, "deletions": 71, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -11,12 +11,13 @@\n //! Code related to processing overloaded binary and unary operators.\n \n use super::FnCtxt;\n-use hir::def_id::DefId;\n-use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n+use super::method::MethodCallee;\n+use rustc::ty::{self, Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n-use syntax::ast;\n+use syntax_pos::Span;\n use syntax::symbol::Symbol;\n use rustc::hir;\n \n@@ -174,8 +175,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                lhs_ty,\n                is_assign);\n \n-        let (name, trait_def_id) = self.name_and_trait_def_id(op, is_assign);\n-\n         // NB: As we have not yet type-checked the RHS, we don't have the\n         // type at hand. Make a variable to represent it. The whole reason\n         // for this indirection is so that, below, we can check the expr\n@@ -184,15 +183,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // particularly for things like `String + &String`.\n         let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n-        let return_ty = self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n-                                              Symbol::intern(name), trait_def_id,\n-                                              lhs_expr);\n+        let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n \n         // see `NB` above\n         let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n \n-        let return_ty = match return_ty {\n-            Ok(return_ty) => return_ty,\n+        let return_ty = match result {\n+            Ok(method) => {\n+                let by_ref_binop = !op.node.is_by_value();\n+                if is_assign == IsAssign::Yes || by_ref_binop {\n+                    if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                        let autoref = Adjustment {\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            target: method.sig.inputs()[0]\n+                        };\n+                        self.apply_adjustments(lhs_expr, vec![autoref]);\n+                    }\n+                }\n+                if by_ref_binop {\n+                    if let ty::TyRef(region, mt) = method.sig.inputs()[1].sty {\n+                        let autoref = Adjustment {\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            target: method.sig.inputs()[1]\n+                        };\n+                        // HACK(eddyb) Bypass checks due to reborrows being in\n+                        // some cases applied on the RHS, on top of which we need\n+                        // to autoref, which is not allowed by apply_adjustments.\n+                        // self.apply_adjustments(rhs_expr, vec![autoref]);\n+                        self.tables.borrow_mut().adjustments.entry(rhs_expr.id)\n+                            .or_insert(vec![]).push(autoref);\n+                    }\n+                }\n+                self.write_method_call(expr.id, method);\n+\n+                method.sig.output()\n+            }\n             Err(()) => {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n@@ -214,9 +239,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                         if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n                             if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n-                                self.lookup_op_method(expr, ty_mut.ty, vec![rhs_ty],\n-                                    Symbol::intern(name), trait_def_id,\n-                                    lhs_expr).is_ok() {\n+                                self.lookup_op_method(ty_mut.ty, &[rhs_ty],\n+                                                      Op::Binary(op, is_assign)).is_ok() {\n                                 err.note(\n                                     &format!(\n                                         \"this is a reference to a type that `{}` can be applied \\\n@@ -302,38 +326,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_user_unop(&self,\n-                           op_str: &str,\n-                           mname: &str,\n-                           trait_did: Option<DefId>,\n                            ex: &'gcx hir::Expr,\n-                           operand_expr: &'gcx hir::Expr,\n                            operand_ty: Ty<'tcx>,\n                            op: hir::UnOp)\n                            -> Ty<'tcx>\n     {\n         assert!(op.is_by_value());\n-        let mname = Symbol::intern(mname);\n-        match self.lookup_op_method(ex, operand_ty, vec![], mname, trait_did, operand_expr) {\n-            Ok(t) => t,\n+        match self.lookup_op_method(operand_ty, &[], Op::Unary(op, ex.span)) {\n+            Ok(method) => {\n+                self.write_method_call(ex.id, method);\n+                method.sig.output()\n+            }\n             Err(()) => {\n                 let actual = self.resolve_type_vars_if_possible(&operand_ty);\n                 if !actual.references_error() {\n                     struct_span_err!(self.tcx.sess, ex.span, E0600,\n                                      \"cannot apply unary operator `{}` to type `{}`\",\n-                                     op_str, actual).emit();\n+                                     op.as_str(), actual).emit();\n                 }\n                 self.tcx.types.err\n             }\n         }\n     }\n \n-    fn name_and_trait_def_id(&self,\n-                             op: hir::BinOp,\n-                             is_assign: IsAssign)\n-                             -> (&'static str, Option<DefId>) {\n+    fn lookup_op_method(&self, lhs_ty: Ty<'tcx>, other_tys: &[Ty<'tcx>], op: Op)\n+                        -> Result<MethodCallee<'tcx>, ()>\n+    {\n         let lang = &self.tcx.lang_items;\n \n-        if let IsAssign::Yes = is_assign {\n+        let span = match op {\n+            Op::Binary(op, _) => op.span,\n+            Op::Unary(_, span) => span\n+        };\n+        let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n             match op.node {\n                 hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n                 hir::BiSub => (\"sub_assign\", lang.sub_assign_trait()),\n@@ -349,12 +374,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::BiGe | hir::BiGt |\n                 hir::BiEq | hir::BiNe |\n                 hir::BiAnd | hir::BiOr => {\n-                    span_bug!(op.span,\n+                    span_bug!(span,\n                               \"impossible assignment operation: {}=\",\n                               op.node.as_str())\n                 }\n             }\n-        } else {\n+        } else if let Op::Binary(op, IsAssign::No) = op {\n             match op.node {\n                 hir::BiAdd => (\"add\", lang.add_trait()),\n                 hir::BiSub => (\"sub\", lang.sub_trait()),\n@@ -373,59 +398,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::BiEq => (\"eq\", lang.eq_trait()),\n                 hir::BiNe => (\"ne\", lang.eq_trait()),\n                 hir::BiAnd | hir::BiOr => {\n-                    span_bug!(op.span, \"&& and || are not overloadable\")\n+                    span_bug!(span, \"&& and || are not overloadable\")\n                 }\n             }\n-        }\n-    }\n+        } else if let Op::Unary(hir::UnNot, _) = op {\n+            (\"not\", lang.not_trait())\n+        } else if let Op::Unary(hir::UnNeg, _) = op {\n+            (\"neg\", lang.neg_trait())\n+        } else {\n+            bug!(\"lookup_op_method: op not supported: {:?}\", op)\n+        };\n \n-    fn lookup_op_method(&self,\n-                        expr: &'gcx hir::Expr,\n-                        lhs_ty: Ty<'tcx>,\n-                        other_tys: Vec<Ty<'tcx>>,\n-                        opname: ast::Name,\n-                        trait_did: Option<DefId>,\n-                        lhs_expr: &'a hir::Expr)\n-                        -> Result<Ty<'tcx>,()>\n-    {\n-        debug!(\"lookup_op_method(expr={:?}, lhs_ty={:?}, opname={:?}, \\\n-                                 trait_did={:?}, lhs_expr={:?})\",\n-               expr,\n+        debug!(\"lookup_op_method(lhs_ty={:?}, op={:?}, opname={:?}, trait_did={:?})\",\n                lhs_ty,\n+               op,\n                opname,\n-               trait_did,\n-               lhs_expr);\n-\n-        let method = match trait_did {\n-            Some(trait_did) => {\n-                let lhs_expr = Some(super::AdjustedRcvr {\n-                    rcvr_expr: lhs_expr, autoderefs: 0, unsize: false\n-                });\n-                self.lookup_method_in_trait_adjusted(expr.span,\n-                                                     lhs_expr,\n-                                                     opname,\n-                                                     trait_did,\n-                                                     lhs_ty,\n-                                                     Some(other_tys))\n-            }\n-            None => None\n-        };\n+               trait_did);\n+\n+        let method = trait_did.and_then(|trait_did| {\n+            let opname = Symbol::intern(opname);\n+            self.lookup_method_in_trait(span, opname, trait_did, lhs_ty, Some(other_tys))\n+        });\n \n         match method {\n             Some(ok) => {\n                 let method = self.register_infer_ok_obligations(ok);\n                 self.select_obligations_where_possible();\n \n-                let method_ty = method.ty;\n-\n-                // HACK(eddyb) Fully qualified path to work around a resolve bug.\n-                let method_call = ::rustc::ty::MethodCall::expr(expr.id);\n-                self.tables.borrow_mut().method_map.insert(method_call, method);\n-\n-                // extract return type for method; all late bound regions\n-                // should have been instantiated by now\n-                let ret_ty = method_ty.fn_ret();\n-                Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap())\n+                Ok(method)\n             }\n             None => {\n                 Err(())\n@@ -491,12 +491,18 @@ impl BinOpCategory {\n }\n \n /// Whether the binary operation is an assignment (`a += b`), or not (`a + b`)\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n enum IsAssign {\n     No,\n     Yes,\n }\n \n+#[derive(Clone, Copy, Debug)]\n+enum Op {\n+    Binary(hir::BinOp, IsAssign),\n+    Unary(hir::UnOp, Span),\n+}\n+\n /// Returns true if this is a built-in arithmetic operation (e.g. u32\n /// + u32, i16x4 == i16x4) and false if these types would have to be\n /// overloaded to be legal. There are two reasons that we distinguish"}, {"sha": "afc003b986d41df68d076d0dd4f2a489f74eaa23", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 113, "deletions": 219, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -91,7 +91,7 @@ use middle::region::{CodeExtent, RegionMaps};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n@@ -520,15 +520,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n-        let method_call = MethodCall::expr(expr.id);\n-        let opt_method_callee = self.tables.borrow().method_map.get(&method_call).cloned();\n-        let has_method_map = opt_method_callee.is_some();\n+        let is_method_call = self.tables.borrow().is_method_call(expr);\n \n         // If we are calling a method (either explicitly or via an\n         // overloaded operator), check that all of the types provided as\n         // arguments for its type parameters are well-formed, and all the regions\n         // provided as arguments outlive the call.\n-        if let Some(callee) = opt_method_callee {\n+        if is_method_call {\n             let origin = match expr.node {\n                 hir::ExprMethodCall(..) =>\n                     infer::ParameterOrigin::MethodCall,\n@@ -538,66 +536,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                     infer::ParameterOrigin::OverloadedOperator\n             };\n \n-            self.substs_wf_in_scope(origin, &callee.substs, expr.span, expr_region);\n-            self.type_must_outlive(infer::ExprTypeIsNotInScope(callee.ty, expr.span),\n-                                   callee.ty, expr_region);\n+            let substs = self.tables.borrow().node_substs(expr.id);\n+            self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n+            // Arguments (sub-expressions) are checked via `constrain_call`, below.\n         }\n \n         // Check any autoderefs or autorefs that appear.\n-        let adjustment = self.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n-        if let Some(adjustment) = adjustment {\n-            debug!(\"adjustment={:?}\", adjustment);\n-            match adjustment.kind {\n-                adjustment::Adjust::DerefRef { autoderefs, ref autoref, .. } => {\n-                    let expr_ty = self.resolve_node_type(expr.id);\n-                    self.constrain_autoderefs(expr, autoderefs, expr_ty);\n-                    if let Some(ref autoref) = *autoref {\n-                        self.link_autoref(expr, autoderefs, autoref);\n-\n-                        // Require that the resulting region encompasses\n-                        // the current node.\n-                        //\n-                        // FIXME(#6268) remove to support nested method calls\n-                        self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n-                                                       expr.id, expr_region);\n-                    }\n-                }\n-                /*\n-                adjustment::AutoObject(_, ref bounds, ..) => {\n-                    // Determine if we are casting `expr` to a trait\n-                    // instance. If so, we have to be sure that the type\n-                    // of the source obeys the new region bound.\n-                    let source_ty = self.resolve_node_type(expr.id);\n-                    self.type_must_outlive(infer::RelateObjectBound(expr.span),\n-                                           source_ty, bounds.region_bound);\n-                }\n-                */\n-                _ => {}\n-            }\n-\n-            // If necessary, constrain destructors in the unadjusted form of this\n-            // expression.\n-            let cmt_result = {\n-                let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                mc.cat_expr_unadjusted(expr)\n-            };\n-            match cmt_result {\n-                Ok(head_cmt) => {\n-                    self.check_safety_of_rvalue_destructor_if_necessary(head_cmt,\n-                                                                        expr.span);\n-                }\n-                Err(..) => {\n-                    self.tcx.sess.delay_span_bug(expr.span, \"cat_expr_unadjusted Errd\");\n-                }\n-            }\n-        }\n+        let cmt_result = self.constrain_adjustments(expr);\n \n         // If necessary, constrain destructors in this expression. This will be\n         // the adjusted form if there is an adjustment.\n-        let cmt_result = {\n-            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-            mc.cat_expr(expr)\n-        };\n         match cmt_result {\n             Ok(head_cmt) => {\n                 self.check_safety_of_rvalue_destructor_if_necessary(head_cmt, expr.span);\n@@ -611,57 +559,45 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                expr, self.repeating_scope);\n         match expr.node {\n             hir::ExprPath(_) => {\n-                self.fcx.opt_node_ty_substs(expr.id, |item_substs| {\n-                    let origin = infer::ParameterOrigin::Path;\n-                    self.substs_wf_in_scope(origin, &item_substs.substs, expr.span, expr_region);\n-                });\n+                let substs = self.tables.borrow().node_substs(expr.id);\n+                let origin = infer::ParameterOrigin::Path;\n+                self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             }\n \n             hir::ExprCall(ref callee, ref args) => {\n-                if has_method_map {\n-                    self.constrain_call(expr, Some(&callee),\n-                                        args.iter().map(|e| &*e), false);\n+                if is_method_call {\n+                    self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n                 } else {\n                     self.constrain_callee(callee.id, expr, &callee);\n-                    self.constrain_call(expr, None,\n-                                        args.iter().map(|e| &*e), false);\n+                    self.constrain_call(expr, None, args.iter().map(|e| &*e));\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n             hir::ExprMethodCall(.., ref args) => {\n-                self.constrain_call(expr, Some(&args[0]),\n-                                    args[1..].iter().map(|e| &*e), false);\n+                self.constrain_call(expr, Some(&args[0]), args[1..].iter().map(|e| &*e));\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n             hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n-                if has_method_map {\n-                    self.constrain_call(expr, Some(&lhs),\n-                                        Some(&**rhs).into_iter(), false);\n+                if is_method_call {\n+                    self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprIndex(ref lhs, ref rhs) if has_method_map => {\n-                self.constrain_call(expr, Some(&lhs),\n-                                    Some(&**rhs).into_iter(), true);\n+            hir::ExprIndex(ref lhs, ref rhs) if is_method_call => {\n+                self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n             },\n \n-            hir::ExprBinary(op, ref lhs, ref rhs) if has_method_map => {\n-                let implicitly_ref_args = !op.node.is_by_value();\n-\n-                // As `expr_method_call`, but the call is via an\n-                // overloaded op.  Note that we (sadly) currently use an\n-                // implicit \"by ref\" sort of passing style here.  This\n-                // should be converted to an adjustment!\n-                self.constrain_call(expr, Some(&lhs),\n-                                    Some(&**rhs).into_iter(), implicitly_ref_args);\n+            hir::ExprBinary(_, ref lhs, ref rhs) if is_method_call => {\n+                // As `ExprMethodCall`, but the call is via an overloaded op.\n+                self.constrain_call(expr, Some(&lhs), Some(&**rhs).into_iter());\n \n                 intravisit::walk_expr(self, expr);\n             }\n@@ -678,36 +614,28 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprUnary(op, ref lhs) if has_method_map => {\n-                let implicitly_ref_args = !op.is_by_value();\n-\n-                // As above.\n-                self.constrain_call(expr, Some(&lhs),\n-                                    None::<hir::Expr>.iter(), implicitly_ref_args);\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n             hir::ExprUnary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n-                let method_call = MethodCall::expr(expr.id);\n-                let base_ty = match self.tables.borrow().method_map.get(&method_call) {\n-                    Some(method) => {\n-                        self.constrain_call(expr, Some(&base),\n-                                            None::<hir::Expr>.iter(), true);\n-                        // late-bound regions in overloaded method calls are instantiated\n-                        let fn_ret = self.tcx.no_late_bound_regions(&method.ty.fn_ret());\n-                        fn_ret.unwrap()\n-                    }\n-                    None => self.resolve_node_type(base.id)\n-                };\n+                if is_method_call {\n+                    self.constrain_call(expr, Some(base), None::<hir::Expr>.iter());\n+                }\n+                // For overloaded derefs, base_ty is the input to `Deref::deref`,\n+                // but it's a reference type uing the same region as the output.\n+                let base_ty = self.resolve_expr_type_adjusted(base);\n                 if let ty::TyRef(r_ptr, _) = base_ty.sty {\n                     self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n+            hir::ExprUnary(_, ref lhs) if is_method_call => {\n+                // As above.\n+                self.constrain_call(expr, Some(&lhs), None::<hir::Expr>.iter());\n+\n+                intravisit::walk_expr(self, expr);\n+            }\n+\n             hir::ExprIndex(ref vec_expr, _) => {\n                 // For a[b], the lifetime of a must enclose the deref\n                 let vec_type = self.resolve_expr_type_adjusted(&vec_expr);\n@@ -859,19 +787,15 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n                                                            call_expr: &hir::Expr,\n                                                            receiver: Option<&hir::Expr>,\n-                                                           arg_exprs: I,\n-                                                           implicitly_ref_args: bool) {\n+                                                           arg_exprs: I) {\n         //! Invoked on every call site (i.e., normal calls, method calls,\n         //! and overloaded operators). Constrains the regions which appear\n         //! in the type of the function. Also constrains the regions that\n         //! appear in the arguments appropriately.\n \n-        debug!(\"constrain_call(call_expr={:?}, \\\n-                receiver={:?}, \\\n-                implicitly_ref_args={})\",\n+        debug!(\"constrain_call(call_expr={:?}, receiver={:?})\",\n                 call_expr,\n-                receiver,\n-                implicitly_ref_args);\n+                receiver);\n \n         // `callee_region` is the scope representing the time in which the\n         // call occurs.\n@@ -889,104 +813,90 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // valid for at least the lifetime of the function:\n             self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n                                            arg_expr.id, callee_region);\n-\n-            // unfortunately, there are two means of taking implicit\n-            // references, and we need to propagate constraints as a\n-            // result. modes are going away and the \"DerefArgs\" code\n-            // should be ported to use adjustments\n-            if implicitly_ref_args {\n-                self.link_by_ref(arg_expr, callee_scope);\n-            }\n         }\n \n         // as loop above, but for receiver\n         if let Some(r) = receiver {\n             debug!(\"receiver: {:?}\", r);\n             self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n                                            r.id, callee_region);\n-            if implicitly_ref_args {\n-                self.link_by_ref(&r, callee_scope);\n-            }\n         }\n     }\n \n-    /// Invoked on any auto-dereference that occurs. Checks that if this is a region pointer being\n+    /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_autoderefs(&mut self,\n-                            deref_expr: &hir::Expr,\n-                            derefs: usize,\n-                            mut derefd_ty: Ty<'tcx>)\n-    {\n-        debug!(\"constrain_autoderefs(deref_expr={:?}, derefs={}, derefd_ty={:?})\",\n-               deref_expr,\n-               derefs,\n-               derefd_ty);\n-\n-        let r_deref_expr = self.tcx.node_scope_region(deref_expr.id);\n-        for i in 0..derefs {\n-            let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n-            debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n-\n-            let method = self.tables.borrow().method_map.get(&method_call).map(|m| m.clone());\n-\n-            derefd_ty = match method {\n-                Some(method) => {\n-                    debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n-                           i, method);\n-\n-                    let origin = infer::ParameterOrigin::OverloadedDeref;\n-                    self.substs_wf_in_scope(origin, method.substs, deref_expr.span, r_deref_expr);\n-\n-                    // Treat overloaded autoderefs as if an AutoBorrow adjustment\n-                    // was applied on the base type, as that is always the case.\n-                    let fn_sig = method.ty.fn_sig();\n-                    let fn_sig = // late-bound regions should have been instantiated\n-                        self.tcx.no_late_bound_regions(&fn_sig).unwrap();\n-                    let self_ty = fn_sig.inputs()[0];\n-                    let (m, r) = match self_ty.sty {\n-                        ty::TyRef(r, ref m) => (m.mutbl, r),\n-                        _ => {\n-                            span_bug!(\n-                                deref_expr.span,\n-                                \"bad overloaded deref type {:?}\",\n-                                method.ty)\n-                        }\n-                    };\n-\n-                    debug!(\"constrain_autoderefs: receiver r={:?} m={:?}\",\n-                           r, m);\n-\n-                    {\n-                        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                        let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n-                        debug!(\"constrain_autoderefs: self_cmt={:?}\",\n-                               self_cmt);\n-                        self.link_region(deref_expr.span, r,\n-                                         ty::BorrowKind::from_mutbl(m), self_cmt);\n-                    }\n+    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt<'tcx>> {\n+        debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n-                    // Specialized version of constrain_call.\n-                    self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n-                                           self_ty, r_deref_expr);\n-                    self.type_must_outlive(infer::CallReturn(deref_expr.span),\n-                                           fn_sig.output(), r_deref_expr);\n-                    fn_sig.output()\n-                }\n-                None => derefd_ty\n-            };\n+        let mut cmt = {\n+            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n+            mc.cat_expr_unadjusted(expr)?\n+        };\n+\n+        //NOTE(@jroesch): mixed RefCell borrow causes crash\n+        let adjustments = self.tables.borrow().expr_adjustments(&expr).to_vec();\n+        if adjustments.is_empty() {\n+            return Ok(cmt);\n+        }\n \n-            if let ty::TyRef(r_ptr, _) =  derefd_ty.sty {\n-                self.mk_subregion_due_to_dereference(deref_expr.span,\n-                                                     r_deref_expr, r_ptr);\n+        debug!(\"constrain_adjustments: adjustments={:?}\", adjustments);\n+\n+        // If necessary, constrain destructors in the unadjusted form of this\n+        // expression.\n+        self.check_safety_of_rvalue_destructor_if_necessary(cmt.clone(), expr.span);\n+\n+        let expr_region = self.tcx.node_scope_region(expr.id);\n+        for adjustment in adjustments {\n+            debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n+                   adjustment, cmt);\n+\n+            if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n+                debug!(\"constrain_adjustments: overloaded deref: {:?}\", deref);\n+\n+                // Treat overloaded autoderefs as if an AutoBorrow adjustment\n+                // was applied on the base type, as that is always the case.\n+                let input = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n+                    ty: cmt.ty,\n+                    mutbl: deref.mutbl,\n+                });\n+                let output = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n+                    ty: adjustment.target,\n+                    mutbl: deref.mutbl,\n+                });\n+\n+                self.link_region(expr.span, deref.region,\n+                                 ty::BorrowKind::from_mutbl(deref.mutbl), cmt.clone());\n+\n+                // Specialized version of constrain_call.\n+                self.type_must_outlive(infer::CallRcvr(expr.span),\n+                                       input, expr_region);\n+                self.type_must_outlive(infer::CallReturn(expr.span),\n+                                       output, expr_region);\n+            }\n+\n+            if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n+                self.link_autoref(expr, cmt.clone(), autoref);\n+\n+                // Require that the resulting region encompasses\n+                // the current node.\n+                //\n+                // FIXME(#6268) remove to support nested method calls\n+                self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n+                                               expr.id, expr_region);\n+            }\n+\n+            {\n+                let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n+                cmt = mc.cat_expr_adjusted(expr, cmt, &adjustment)?;\n             }\n \n-            match derefd_ty.builtin_deref(true, ty::NoPreference) {\n-                Some(mt) => derefd_ty = mt.ty,\n-                /* if this type can't be dereferenced, then there's already an error\n-                   in the session saying so. Just bail out for now */\n-                None => break\n+            if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n+                self.mk_subregion_due_to_dereference(expr.span,\n+                                                     expr_region, r_ptr);\n             }\n         }\n+\n+        Ok(cmt)\n     }\n \n     pub fn mk_subregion_due_to_dereference(&mut self,\n@@ -1053,7 +963,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(id);\n-        let ty = self.tables.borrow().adjustments.get(&id).map_or(ty0, |adj| adj.target);\n+        let ty = self.tables.borrow().adjustments.get(&id)\n+            .and_then(|adj| adj.last())\n+            .map_or(ty0, |adj| adj.target);\n         let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n                 ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n@@ -1151,13 +1063,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// autoref'd.\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n-                    autoderefs: usize,\n+                    expr_cmt: mc::cmt<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n-        debug!(\"link_autoref(autoderefs={}, autoref={:?})\", autoderefs, autoref);\n-        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-        let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n-        debug!(\"expr_cmt={:?}\", expr_cmt);\n+        debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n@@ -1172,19 +1081,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Computes the guarantor for cases where the `expr` is being passed by implicit reference and\n-    /// must outlive `callee_scope`.\n-    fn link_by_ref(&self,\n-                   expr: &hir::Expr,\n-                   callee_scope: CodeExtent) {\n-        debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n-               expr, callee_scope);\n-        let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-        let expr_cmt = ignore_err!(mc.cat_expr(expr));\n-        let borrow_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n-        self.link_region(expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n-    }\n-\n     /// Like `link_region()`, except that the region is extracted from the type of `id`,\n     /// which must be some reference (`&T`, `&str`, etc).\n     fn link_region_from_node_type(&self,\n@@ -1224,10 +1120,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                    borrow_kind,\n                    borrow_cmt);\n             match borrow_cmt.cat.clone() {\n-                Categorization::Deref(ref_cmt, _,\n-                                      mc::Implicit(ref_kind, ref_region)) |\n-                Categorization::Deref(ref_cmt, _,\n-                                      mc::BorrowedPtr(ref_kind, ref_region)) => {\n+                Categorization::Deref(ref_cmt, mc::Implicit(ref_kind, ref_region)) |\n+                Categorization::Deref(ref_cmt, mc::BorrowedPtr(ref_kind, ref_region)) => {\n                     match self.link_reborrowed_region(span,\n                                                       borrow_region, borrow_kind,\n                                                       ref_cmt, ref_region, ref_kind,\n@@ -1243,15 +1137,15 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 Categorization::Downcast(cmt_base, _) |\n-                Categorization::Deref(cmt_base, _, mc::Unique) |\n+                Categorization::Deref(cmt_base, mc::Unique) |\n                 Categorization::Interior(cmt_base, _) => {\n                     // Borrowing interior or owned data requires the base\n                     // to be valid and borrowable in the same fashion.\n                     borrow_cmt = cmt_base;\n                     borrow_kind = borrow_kind;\n                 }\n \n-                Categorization::Deref(.., mc::UnsafePtr(..)) |\n+                Categorization::Deref(_, mc::UnsafePtr(..)) |\n                 Categorization::StaticItem |\n                 Categorization::Upvar(..) |\n                 Categorization::Local(..) |"}, {"sha": "286d0ad1b35a39e73d47472779f33bfc38302294", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -216,9 +216,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n \n-            let mut deferred_call_resolutions =\n+            let deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n-            for deferred_call_resolution in &mut deferred_call_resolutions {\n+            for deferred_call_resolution in deferred_call_resolutions {\n                 deferred_call_resolution.resolve(self.fcx);\n             }\n         }\n@@ -281,8 +281,8 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n                guarantor);\n         match guarantor.cat {\n-            Categorization::Deref(.., mc::BorrowedPtr(..)) |\n-            Categorization::Deref(.., mc::Implicit(..)) => {\n+            Categorization::Deref(_, mc::BorrowedPtr(..)) |\n+            Categorization::Deref(_, mc::Implicit(..)) => {\n                 match cmt.note {\n                     mc::NoteUpvarRef(upvar_id) => {\n                         debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n@@ -327,16 +327,16 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                cmt);\n \n         match cmt.cat.clone() {\n-            Categorization::Deref(base, _, mc::Unique) |\n+            Categorization::Deref(base, mc::Unique) |\n             Categorization::Interior(base, _) |\n             Categorization::Downcast(base, _) => {\n                 // Interior or owned data is mutable if base is\n                 // mutable, so iterate to the base.\n                 self.adjust_upvar_borrow_kind_for_mut(base);\n             }\n \n-            Categorization::Deref(base, _, mc::BorrowedPtr(..)) |\n-            Categorization::Deref(base, _, mc::Implicit(..)) => {\n+            Categorization::Deref(base, mc::BorrowedPtr(..)) |\n+            Categorization::Deref(base, mc::Implicit(..)) => {\n                 if !self.try_adjust_upvar_deref(cmt, ty::MutBorrow) {\n                     // assignment to deref of an `&mut`\n                     // borrowed pointer implies that the\n@@ -346,7 +346,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Categorization::Deref(.., mc::UnsafePtr(..)) |\n+            Categorization::Deref(_, mc::UnsafePtr(..)) |\n             Categorization::StaticItem |\n             Categorization::Rvalue(..) |\n             Categorization::Local(_) |\n@@ -361,24 +361,24 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                cmt);\n \n         match cmt.cat.clone() {\n-            Categorization::Deref(base, _, mc::Unique) |\n+            Categorization::Deref(base, mc::Unique) |\n             Categorization::Interior(base, _) |\n             Categorization::Downcast(base, _) => {\n                 // Interior or owned data is unique if base is\n                 // unique.\n                 self.adjust_upvar_borrow_kind_for_unique(base);\n             }\n \n-            Categorization::Deref(base, _, mc::BorrowedPtr(..)) |\n-            Categorization::Deref(base, _, mc::Implicit(..)) => {\n+            Categorization::Deref(base, mc::BorrowedPtr(..)) |\n+            Categorization::Deref(base, mc::Implicit(..)) => {\n                 if !self.try_adjust_upvar_deref(cmt, ty::UniqueImmBorrow) {\n                     // for a borrowed pointer to be unique, its\n                     // base must be unique\n                     self.adjust_upvar_borrow_kind_for_unique(base);\n                 }\n             }\n \n-            Categorization::Deref(.., mc::UnsafePtr(..)) |\n+            Categorization::Deref(_, mc::UnsafePtr(..)) |\n             Categorization::StaticItem |\n             Categorization::Rvalue(..) |\n             Categorization::Local(_) |"}, {"sha": "012fde16d875e256031ee3415597715ad7dfd31c", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 22, "deletions": 88, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -16,8 +16,7 @@ use check::FnCtxt;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::infer::{InferCtxt};\n-use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n-use rustc::ty::adjustment;\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::util::nodemap::DefIdSet;\n use syntax::ast;\n@@ -106,7 +105,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n-                    self.fcx.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n+                    let mut tables = self.fcx.tables.borrow_mut();\n+                    tables.type_dependent_defs.remove(&e.id);\n+                    tables.node_substs.remove(&e.id);\n                 }\n             }\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n@@ -118,20 +119,19 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                    self.fcx.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n+                    let mut tables = self.fcx.tables.borrow_mut();\n+                    tables.type_dependent_defs.remove(&e.id);\n+                    tables.node_substs.remove(&e.id);\n \n-                    // weird but true: the by-ref binops put an\n-                    // adjustment on the lhs but not the rhs; the\n-                    // adjustment for rhs is kind of baked into the\n-                    // system.\n                     match e.node {\n                         hir::ExprBinary(..) => {\n                             if !op.node.is_by_value() {\n-                                self.fcx.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                                tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n+                                tables.adjustments.get_mut(&rhs.id).map(|a| a.pop());\n                             }\n                         },\n                         hir::ExprAssignOp(..) => {\n-                            self.fcx.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                            tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n                         },\n                         _ => {},\n                     }\n@@ -164,7 +164,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fix_scalar_builtin_expr(e);\n \n         self.visit_node_id(e.span, e.id);\n-        self.visit_method_map_entry(e.span, MethodCall::expr(e.id));\n \n         if let hir::ExprClosure(_, _, body, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n@@ -280,9 +279,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_node_id(&mut self, span: Span, node_id: ast::NodeId) {\n-        // Export associated path extensions.\n-        if let Some(def) = self.fcx.tables.borrow_mut().type_relative_path_defs.remove(&node_id) {\n-            self.tables.type_relative_path_defs.insert(node_id, def);\n+        // Export associated path extensions and method resultions.\n+        if let Some(def) = self.fcx.tables.borrow_mut().type_dependent_defs.remove(&node_id) {\n+            self.tables.type_dependent_defs.insert(node_id, def);\n         }\n \n         // Resolve any borrowings for the node with id `node_id`\n@@ -295,94 +294,29 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         debug!(\"Node {} has type {:?}\", node_id, n_ty);\n \n         // Resolve any substitutions\n-        self.fcx.opt_node_ty_substs(node_id, |item_substs| {\n-            let item_substs = self.resolve(item_substs, &span);\n-            if !item_substs.is_noop() {\n-                debug!(\"write_substs_to_tcx({}, {:?})\", node_id, item_substs);\n-                assert!(!item_substs.substs.needs_infer());\n-                self.tables.item_substs.insert(node_id, item_substs);\n-            }\n-        });\n+        if let Some(&substs) = self.fcx.tables.borrow().node_substs.get(&node_id) {\n+            let substs = self.resolve(&substs, &span);\n+            debug!(\"write_substs_to_tcx({}, {:?})\", node_id, substs);\n+            assert!(!substs.needs_infer());\n+            self.tables.node_substs.insert(node_id, substs);\n+        }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, node_id: ast::NodeId) {\n-        let adjustments = self.fcx.tables.borrow_mut().adjustments.remove(&node_id);\n-        match adjustments {\n+        let adjustment = self.fcx.tables.borrow_mut().adjustments.remove(&node_id);\n+        match adjustment {\n             None => {\n                 debug!(\"No adjustments for node {}\", node_id);\n             }\n \n             Some(adjustment) => {\n-                let resolved_adjustment = match adjustment.kind {\n-                    adjustment::Adjust::NeverToAny => {\n-                        adjustment::Adjust::NeverToAny\n-                    }\n-\n-                    adjustment::Adjust::ReifyFnPointer => {\n-                        adjustment::Adjust::ReifyFnPointer\n-                    }\n-\n-                    adjustment::Adjust::MutToConstPointer => {\n-                        adjustment::Adjust::MutToConstPointer\n-                    }\n-\n-                    adjustment::Adjust::ClosureFnPointer => {\n-                        adjustment::Adjust::ClosureFnPointer\n-                    }\n-\n-                    adjustment::Adjust::UnsafeFnPointer => {\n-                        adjustment::Adjust::UnsafeFnPointer\n-                    }\n-\n-                    adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n-                        for autoderef in 0..autoderefs {\n-                            let method_call = MethodCall::autoderef(node_id, autoderef as u32);\n-                            self.visit_method_map_entry(span, method_call);\n-                        }\n-\n-                        adjustment::Adjust::DerefRef {\n-                            autoderefs: autoderefs,\n-                            autoref: self.resolve(&autoref, &span),\n-                            unsize: unsize,\n-                        }\n-                    }\n-                };\n-                let resolved_adjustment = adjustment::Adjustment {\n-                    kind: resolved_adjustment,\n-                    target: self.resolve(&adjustment.target, &span)\n-                };\n+                let resolved_adjustment = self.resolve(&adjustment, &span);\n                 debug!(\"Adjustments for node {}: {:?}\", node_id, resolved_adjustment);\n                 self.tables.adjustments.insert(node_id, resolved_adjustment);\n             }\n         }\n     }\n \n-    fn visit_method_map_entry(&mut self,\n-                              method_span: Span,\n-                              method_call: MethodCall) {\n-        // Resolve any method map entry\n-        let new_method = match self.fcx.tables.borrow_mut().method_map.remove(&method_call) {\n-            Some(method) => {\n-                debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n-                       method_call,\n-                       method);\n-                let new_method = MethodCallee {\n-                    def_id: method.def_id,\n-                    ty: self.resolve(&method.ty, &method_span),\n-                    substs: self.resolve(&method.substs, &method_span),\n-                };\n-\n-                Some(new_method)\n-            }\n-            None => None\n-        };\n-\n-        //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n-        if let Some(method) = new_method {\n-            self.tables.method_map.insert(method_call, method);\n-        }\n-    }\n-\n     fn visit_liberated_fn_sigs(&mut self) {\n         for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n             let fn_sig = self.resolve(fn_sig, &node_id);"}, {"sha": "baef48fe7d2cde82b6f5ef8919af54712c1ec5e3", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -73,12 +73,14 @@ This API is completely unstable and subject to change.\n \n #![allow(non_camel_case_types)]\n \n+#![feature(advanced_slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n #![feature(never_type)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(slice_patterns)]\n \n #![cfg_attr(stage0, unstable(feature = \"rustc_private\", issue = \"27812\"))]\n #![cfg_attr(stage0, feature(rustc_private))]"}, {"sha": "40b3e789ce4a3c12d31cb49b7d9955d54bece417", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -1953,7 +1953,7 @@ mod tests {\n     fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = channel::<Box<i32>>();\n         tx.send(box 10).unwrap();\n-        assert!(rx.recv().unwrap() == box 10);\n+        assert!(*rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n@@ -2010,7 +2010,7 @@ mod tests {\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n-            assert!(rx.recv().unwrap() == box 10);\n+            assert!(*rx.recv().unwrap() == 10);\n         });\n \n         tx.send(box 10).unwrap();\n@@ -2023,7 +2023,7 @@ mod tests {\n             drop(tx);\n         });\n         let res = thread::spawn(move|| {\n-            assert!(rx.recv().unwrap() == box 10);\n+            assert!(*rx.recv().unwrap() == 10);\n         }).join();\n         assert!(res.is_err());\n     }\n@@ -2077,7 +2077,7 @@ mod tests {\n             let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n-            assert!(rx.recv().unwrap() == box 10);\n+            assert!(*rx.recv().unwrap() == 10);\n         }\n     }\n \n@@ -2102,7 +2102,7 @@ mod tests {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n-                    assert!(rx.recv().unwrap() == box i);\n+                    assert!(*rx.recv().unwrap() == i);\n                     recv(rx, i + 1);\n                 });\n             }\n@@ -2639,7 +2639,7 @@ mod sync_tests {\n     fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = sync_channel::<Box<i32>>(1);\n         tx.send(box 10).unwrap();\n-        assert!(rx.recv().unwrap() == box 10);\n+        assert!(*rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n@@ -2711,7 +2711,7 @@ mod sync_tests {\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n-            assert!(rx.recv().unwrap() == box 10);\n+            assert!(*rx.recv().unwrap() == 10);\n         });\n \n         tx.send(box 10).unwrap();\n@@ -2724,7 +2724,7 @@ mod sync_tests {\n             drop(tx);\n         });\n         let res = thread::spawn(move|| {\n-            assert!(rx.recv().unwrap() == box 10);\n+            assert!(*rx.recv().unwrap() == 10);\n         }).join();\n         assert!(res.is_err());\n     }\n@@ -2778,7 +2778,7 @@ mod sync_tests {\n             let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n-            assert!(rx.recv().unwrap() == box 10);\n+            assert!(*rx.recv().unwrap() == 10);\n         }\n     }\n \n@@ -2803,7 +2803,7 @@ mod sync_tests {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n-                    assert!(rx.recv().unwrap() == box i);\n+                    assert!(*rx.recv().unwrap() == i);\n                     recv(rx, i + 1);\n                 });\n             }"}, {"sha": "2206234b77744ca670a8cbaa52049cd86172c6b3", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -8,10 +8,10 @@ error[E0308]: mismatched types\n               found type `u32`\n \n error[E0277]: the trait bound `u32: std::ops::Add<impl Foo>` is not satisfied\n-  --> $DIR/equality.rs:34:9\n+  --> $DIR/equality.rs:34:11\n    |\n 34 |         n + sum_to(n - 1)\n-   |         ^^^^^^^^^^^^^^^^^ no implementation for `u32 + impl Foo`\n+   |           ^ no implementation for `u32 + impl Foo`\n    |\n    = help: the trait `std::ops::Add<impl Foo>` is not implemented for `u32`\n "}, {"sha": "1faf72cd760b75ebbb01f299320dcde3c907efb3", "filename": "src/test/ui/mismatched_types/binops.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -1,56 +1,56 @@\n error[E0277]: the trait bound `{integer}: std::ops::Add<std::option::Option<{integer}>>` is not satisfied\n-  --> $DIR/binops.rs:12:5\n+  --> $DIR/binops.rs:12:7\n    |\n 12 |     1 + Some(1);\n-   |     ^^^^^^^^^^^ no implementation for `{integer} + std::option::Option<{integer}>`\n+   |       ^ no implementation for `{integer} + std::option::Option<{integer}>`\n    |\n    = help: the trait `std::ops::Add<std::option::Option<{integer}>>` is not implemented for `{integer}`\n \n error[E0277]: the trait bound `usize: std::ops::Sub<std::option::Option<{integer}>>` is not satisfied\n-  --> $DIR/binops.rs:13:5\n+  --> $DIR/binops.rs:13:16\n    |\n 13 |     2 as usize - Some(1);\n-   |     ^^^^^^^^^^^^^^^^^^^^ no implementation for `usize - std::option::Option<{integer}>`\n+   |                ^ no implementation for `usize - std::option::Option<{integer}>`\n    |\n    = help: the trait `std::ops::Sub<std::option::Option<{integer}>>` is not implemented for `usize`\n \n error[E0277]: the trait bound `{integer}: std::ops::Mul<()>` is not satisfied\n-  --> $DIR/binops.rs:14:5\n+  --> $DIR/binops.rs:14:7\n    |\n 14 |     3 * ();\n-   |     ^^^^^^ no implementation for `{integer} * ()`\n+   |       ^ no implementation for `{integer} * ()`\n    |\n    = help: the trait `std::ops::Mul<()>` is not implemented for `{integer}`\n \n error[E0277]: the trait bound `{integer}: std::ops::Div<&str>` is not satisfied\n-  --> $DIR/binops.rs:15:5\n+  --> $DIR/binops.rs:15:7\n    |\n 15 |     4 / \"\";\n-   |     ^^^^^^ no implementation for `{integer} / &str`\n+   |       ^ no implementation for `{integer} / &str`\n    |\n    = help: the trait `std::ops::Div<&str>` is not implemented for `{integer}`\n \n error[E0277]: the trait bound `{integer}: std::cmp::PartialEq<std::string::String>` is not satisfied\n-  --> $DIR/binops.rs:16:5\n+  --> $DIR/binops.rs:16:7\n    |\n 16 |     5 < String::new();\n-   |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `std::string::String`\n+   |       ^ can't compare `{integer}` with `std::string::String`\n    |\n    = help: the trait `std::cmp::PartialEq<std::string::String>` is not implemented for `{integer}`\n \n error[E0277]: the trait bound `{integer}: std::cmp::PartialOrd<std::string::String>` is not satisfied\n-  --> $DIR/binops.rs:16:5\n+  --> $DIR/binops.rs:16:7\n    |\n 16 |     5 < String::new();\n-   |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `std::string::String`\n+   |       ^ can't compare `{integer}` with `std::string::String`\n    |\n    = help: the trait `std::cmp::PartialOrd<std::string::String>` is not implemented for `{integer}`\n \n error[E0277]: the trait bound `{integer}: std::cmp::PartialEq<std::result::Result<{integer}, _>>` is not satisfied\n-  --> $DIR/binops.rs:17:5\n+  --> $DIR/binops.rs:17:7\n    |\n 17 |     6 == Ok(1);\n-   |     ^^^^^^^^^^ can't compare `{integer}` with `std::result::Result<{integer}, _>`\n+   |       ^^ can't compare `{integer}` with `std::result::Result<{integer}, _>`\n    |\n    = help: the trait `std::cmp::PartialEq<std::result::Result<{integer}, _>>` is not implemented for `{integer}`\n "}, {"sha": "0224cef8da123cbc4eaed2ec89cdb5d35414373b", "filename": "src/test/ui/span/multiline-span-simple.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr?ref=4ed2edaafe82fb8d44e81e00ca3e4f7659855ba2", "patch": "@@ -1,13 +1,8 @@\n error[E0277]: the trait bound `u32: std::ops::Add<()>` is not satisfied\n-  --> $DIR/multiline-span-simple.rs:23:9\n+  --> $DIR/multiline-span-simple.rs:23:18\n    |\n-23 |       foo(1 as u32 +\n-   |  _________^\n-24 | |\n-25 | |         bar(x,\n-26 | |\n-27 | |             y),\n-   | |______________^ no implementation for `u32 + ()`\n+23 |     foo(1 as u32 +\n+   |                  ^ no implementation for `u32 + ()`\n    |\n    = help: the trait `std::ops::Add<()>` is not implemented for `u32`\n "}]}