{"sha": "db061fb274ddc9a8820c5f0c90b077c88961d1be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDYxZmIyNzRkZGM5YTg4MjBjNWYwYzkwYjA3N2M4ODk2MWQxYmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-26T15:48:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-26T15:48:58Z"}, "message": "Merge #6639\n\n6639: Use `ExpandResult` instead of `MacroResult` r=jonas-schievink a=jonas-schievink\n\n`MacroResult` is redundant.\r\n\r\nbors r+ :robot:\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "260c5811fb59578cf44ff0929c4aab8b4f1773ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/260c5811fb59578cf44ff0929c4aab8b4f1773ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db061fb274ddc9a8820c5f0c90b077c88961d1be", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfv85qCRBK7hj4Ov3rIwAAdHIIAJF6LMLvwMPqeBrRYW2ounKt\n4UC+h5KwCnvqAmY3855ZsQFkLGMW0b3Hr36PLdSmMjWAFbltS7MYVaINbKFoNGEh\nUaZYiPxKg8tZrzvtnT0x7QCBWxpyk7JpPNYf1pZW6TyEPeEcH7oB5TBxw0ZTE+HQ\nUBdoGWO3fNVyBx/xVMFIgNACSjatx1UlgL5m82vbo4LretX7evxWfm7TrqEimxYv\n2RdAq8xzwN1a9YR25fmAqcwjm+6ePhgZmiiXa1kNBRir139R3Sr9kPgBgRbTkc/f\nZXQ9d6COmr2ZHQFj2ppn+yz8IJve4SuwJUCWY5tqIZZ9pW6txJHCGP+grOXMLIA=\n=kxfk\n-----END PGP SIGNATURE-----\n", "payload": "tree 260c5811fb59578cf44ff0929c4aab8b4f1773ce\nparent 1542797284f5d3ea51d4e44c5c3c0c673d22d79a\nparent 6a9338e979ed90d2c0342db2d489c37bebb62ce7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1606405738 +0000\ncommitter GitHub <noreply@github.com> 1606405738 +0000\n\nMerge #6639\n\n6639: Use `ExpandResult` instead of `MacroResult` r=jonas-schievink a=jonas-schievink\n\n`MacroResult` is redundant.\r\n\r\nbors r+ :robot:\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db061fb274ddc9a8820c5f0c90b077c88961d1be", "html_url": "https://github.com/rust-lang/rust/commit/db061fb274ddc9a8820c5f0c90b077c88961d1be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db061fb274ddc9a8820c5f0c90b077c88961d1be/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1542797284f5d3ea51d4e44c5c3c0c673d22d79a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1542797284f5d3ea51d4e44c5c3c0c673d22d79a", "html_url": "https://github.com/rust-lang/rust/commit/1542797284f5d3ea51d4e44c5c3c0c673d22d79a"}, {"sha": "6a9338e979ed90d2c0342db2d489c37bebb62ce7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a9338e979ed90d2c0342db2d489c37bebb62ce7", "html_url": "https://github.com/rust-lang/rust/commit/6a9338e979ed90d2c0342db2d489c37bebb62ce7"}], "stats": {"total": 98, "additions": 42, "deletions": 56}, "files": [{"sha": "93bdb447217eb02a4c77d1a4c7ff4171acf735f0", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=db061fb274ddc9a8820c5f0c90b077c88961d1be", "patch": "@@ -57,7 +57,7 @@ pub use hir_def::{\n     visibility::Visibility,\n };\n pub use hir_expand::{\n-    db::MacroResult, name::known, name::AsName, name::Name, HirFileId, InFile, MacroCallId,\n+    name::known, name::AsName, name::Name, ExpandResult, HirFileId, InFile, MacroCallId,\n     MacroCallLoc, /* FIXME */ MacroDefId, MacroFile, Origin,\n };\n pub use hir_ty::display::HirDisplay;"}, {"sha": "46ebdbc74d50762b9f7a6ddd573c998341bb7f10", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 28, "deletions": 52, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=db061fb274ddc9a8820c5f0c90b077c88961d1be", "patch": "@@ -13,19 +13,6 @@ use crate::{\n     MacroFile, ProcMacroExpander,\n };\n \n-/// A result of some macro expansion.\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct MacroResult<T> {\n-    /// The result of the expansion. Might be `None` when error recovery was impossible and no\n-    /// usable result was produced.\n-    pub value: Option<T>,\n-\n-    /// The error that occurred during expansion or processing.\n-    ///\n-    /// Since we do error recovery, getting an error here does not mean that `value` will be absent.\n-    pub error: Option<String>,\n-}\n-\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum TokenExpander {\n     MacroRules(mbe::MacroRules),\n@@ -91,29 +78,15 @@ pub trait AstDatabase: SourceDatabase {\n     fn parse_macro_expansion(\n         &self,\n         macro_file: MacroFile,\n-    ) -> MacroResult<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>;\n-    fn macro_expand(&self, macro_call: MacroCallId) -> MacroResult<Arc<tt::Subtree>>;\n+    ) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>>;\n+    fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>>;\n \n     #[salsa::interned]\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n \n     fn expand_proc_macro(&self, call: MacroCallId) -> Result<tt::Subtree, mbe::ExpandError>;\n }\n \n-impl<T> MacroResult<T> {\n-    fn error(message: String) -> Self {\n-        Self { value: None, error: Some(message) }\n-    }\n-\n-    fn map<U>(self, f: impl FnOnce(T) -> U) -> MacroResult<U> {\n-        MacroResult { value: self.value.map(f), error: self.error }\n-    }\n-\n-    fn drop_value<U>(self) -> MacroResult<U> {\n-        MacroResult { value: None, error: self.error }\n-    }\n-}\n-\n /// This expands the given macro call, but with different arguments. This is\n /// used for completion, where we want to see what 'would happen' if we insert a\n /// token. The `token_to_map` mapped down into the expansion, with the mapped\n@@ -194,7 +167,7 @@ fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(tt::Subtree,\n     Some(Arc::new((tt, tmap)))\n }\n \n-fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> MacroResult<Arc<tt::Subtree>> {\n+fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n     macro_expand_with_arg(db, id, None)\n }\n \n@@ -215,18 +188,18 @@ fn macro_expand_with_arg(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n     arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n-) -> MacroResult<Arc<tt::Subtree>> {\n+) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,\n         MacroCallId::EagerMacro(id) => {\n             if arg.is_some() {\n-                return MacroResult::error(\n+                return ExpandResult::str_err(\n                     \"hypothetical macro expansion not implemented for eager macro\".to_owned(),\n                 );\n             } else {\n-                return MacroResult {\n+                return ExpandResult {\n                     value: Some(db.lookup_intern_eager_expansion(id).subtree),\n-                    error: None,\n+                    err: None,\n                 };\n             }\n         }\n@@ -235,21 +208,24 @@ fn macro_expand_with_arg(\n     let loc = db.lookup_intern_macro(lazy_id);\n     let macro_arg = match arg.or_else(|| db.macro_arg(id)) {\n         Some(it) => it,\n-        None => return MacroResult::error(\"Fail to args in to tt::TokenTree\".into()),\n+        None => return ExpandResult::str_err(\"Fail to args in to tt::TokenTree\".into()),\n     };\n \n     let macro_rules = match db.macro_def(loc.def) {\n         Some(it) => it,\n-        None => return MacroResult::error(\"Fail to find macro definition\".into()),\n+        None => return ExpandResult::str_err(\"Fail to find macro definition\".into()),\n     };\n     let ExpandResult { value: tt, err } = macro_rules.0.expand(db, lazy_id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > 262144 {\n-        return MacroResult::error(format!(\"Total tokens count exceed limit : count = {}\", count));\n+        return ExpandResult::str_err(format!(\n+            \"Total tokens count exceed limit : count = {}\",\n+            count\n+        ));\n     }\n \n-    MacroResult { value: Some(Arc::new(tt)), error: err.map(|e| format!(\"{:?}\", e)) }\n+    ExpandResult { value: Some(Arc::new(tt)), err }\n }\n \n fn expand_proc_macro(\n@@ -283,23 +259,23 @@ fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNod\n     match file_id.0 {\n         HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n         HirFileIdRepr::MacroFile(macro_file) => {\n-            db.parse_macro_expansion(macro_file).map(|(it, _)| it.syntax_node()).value\n+            db.parse_macro_expansion(macro_file).value.map(|(it, _)| it.syntax_node())\n         }\n     }\n }\n \n fn parse_macro_expansion(\n     db: &dyn AstDatabase,\n     macro_file: MacroFile,\n-) -> MacroResult<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)> {\n+) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>> {\n     parse_macro_with_arg(db, macro_file, None)\n }\n \n fn parse_macro_with_arg(\n     db: &dyn AstDatabase,\n     macro_file: MacroFile,\n     arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n-) -> MacroResult<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)> {\n+) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>> {\n     let _p = profile::span(\"parse_macro_query\");\n \n     let macro_call_id = macro_file.macro_call_id;\n@@ -308,7 +284,7 @@ fn parse_macro_with_arg(\n     } else {\n         db.macro_expand(macro_call_id)\n     };\n-    if let Some(err) = &result.error {\n+    if let Some(err) = &result.err {\n         // Note:\n         // The final goal we would like to make all parse_macro success,\n         // such that the following log will not call anyway.\n@@ -326,50 +302,50 @@ fn parse_macro_with_arg(\n                 .join(\"\\n\");\n \n                 log::warn!(\n-                    \"fail on macro_parse: (reason: {} macro_call: {:#}) parents: {}\",\n+                    \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n                     err,\n                     node.value,\n                     parents\n                 );\n             }\n             _ => {\n-                log::warn!(\"fail on macro_parse: (reason: {})\", err);\n+                log::warn!(\"fail on macro_parse: (reason: {:?})\", err);\n             }\n         }\n     }\n     let tt = match result.value {\n         Some(tt) => tt,\n-        None => return result.drop_value(),\n+        None => return ExpandResult { value: None, err: result.err },\n     };\n \n     let fragment_kind = to_fragment_kind(db, macro_call_id);\n \n     let (parse, rev_token_map) = match mbe::token_tree_to_syntax_node(&tt, fragment_kind) {\n         Ok(it) => it,\n         Err(err) => {\n-            return MacroResult::error(format!(\"{:?}\", err));\n+            return ExpandResult::only_err(err);\n         }\n     };\n \n-    match result.error {\n-        Some(error) => {\n+    match result.err {\n+        Some(err) => {\n             // Safety check for recursive identity macro.\n             let node = parse.syntax_node();\n             let file: HirFileId = macro_file.into();\n             let call_node = match file.call_node(db) {\n                 Some(it) => it,\n                 None => {\n-                    return MacroResult::error(error);\n+                    return ExpandResult::only_err(err);\n                 }\n             };\n \n             if !diff(&node, &call_node.value).is_empty() {\n-                MacroResult { value: Some((parse, Arc::new(rev_token_map))), error: Some(error) }\n+                ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err: Some(err) }\n             } else {\n-                return MacroResult::error(error);\n+                return ExpandResult::only_err(err);\n             }\n         }\n-        None => MacroResult { value: Some((parse, Arc::new(rev_token_map))), error: None },\n+        None => ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err: None },\n     }\n }\n "}, {"sha": "d5ba691b7dc08c3ef1a4b44889052f40c9f2a9af", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=db061fb274ddc9a8820c5f0c90b077c88961d1be", "patch": "@@ -15,6 +15,8 @@ pub mod proc_macro;\n pub mod quote;\n pub mod eager;\n \n+pub use mbe::{ExpandError, ExpandResult};\n+\n use std::hash::Hash;\n use std::sync::Arc;\n "}, {"sha": "e10d7c3a454fd67e6aa57b10d778dfd091b067c2", "filename": "crates/ide/src/status.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatus.rs?ref=db061fb274ddc9a8820c5f0c90b077c88961d1be", "patch": "@@ -1,6 +1,6 @@\n use std::{fmt, iter::FromIterator, sync::Arc};\n \n-use hir::{MacroFile, MacroResult};\n+use hir::{ExpandResult, MacroFile};\n use ide_db::base_db::{\n     salsa::debug::{DebugQueryTable, TableEntry},\n     CrateId, FileId, FileTextQuery, SourceDatabase, SourceRootId,\n@@ -115,12 +115,12 @@ impl FromIterator<TableEntry<FileId, Parse<ast::SourceFile>>> for SyntaxTreeStat\n     }\n }\n \n-impl<M> FromIterator<TableEntry<MacroFile, MacroResult<(Parse<SyntaxNode>, M)>>>\n+impl<M> FromIterator<TableEntry<MacroFile, ExpandResult<Option<(Parse<SyntaxNode>, M)>>>>\n     for SyntaxTreeStats\n {\n     fn from_iter<T>(iter: T) -> SyntaxTreeStats\n     where\n-        T: IntoIterator<Item = TableEntry<MacroFile, MacroResult<(Parse<SyntaxNode>, M)>>>,\n+        T: IntoIterator<Item = TableEntry<MacroFile, ExpandResult<Option<(Parse<SyntaxNode>, M)>>>>,\n     {\n         let mut res = SyntaxTreeStats::default();\n         for entry in iter {"}, {"sha": "22fbf9a80669d1ce0057dc1221930e9c9fc13a2b", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db061fb274ddc9a8820c5f0c90b077c88961d1be/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=db061fb274ddc9a8820c5f0c90b077c88961d1be", "patch": "@@ -33,6 +33,7 @@ pub enum ExpandError {\n     ConversionError,\n     InvalidRepeat,\n     ProcMacroError(tt::ExpansionError),\n+    Other(String),\n }\n \n impl From<tt::ExpansionError> for ExpandError {\n@@ -264,6 +265,13 @@ impl<T> ExpandResult<T> {\n         Self { value: Default::default(), err: Some(err) }\n     }\n \n+    pub fn str_err(err: String) -> Self\n+    where\n+        T: Default,\n+    {\n+        Self::only_err(ExpandError::Other(err))\n+    }\n+\n     pub fn map<U>(self, f: impl FnOnce(T) -> U) -> ExpandResult<U> {\n         ExpandResult { value: f(self.value), err: self.err }\n     }"}]}