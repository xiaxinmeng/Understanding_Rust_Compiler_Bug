{"sha": "962be380042c04d195d9c120d8445e8039d340ee", "node_id": "C_kwDOAAsO6NoAKDk2MmJlMzgwMDQyYzA0ZDE5NWQ5YzEyMGQ4NDQ1ZTgwMzlkMzQwZWU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-04T16:31:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-04T16:31:16Z"}, "message": "Merge #10645\n\n10645: fix: make `rename` multi-token mapping aware r=Veykril a=spookyvision\n\n\n\nCo-authored-by: Anatol Ulrich <anatol.ulrich@ferrous-systems.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\nCo-authored-by: Anatol Ulrich <45840+spookyvision@users.noreply.github.com>", "tree": {"sha": "5748d5252ffa6a884f55b7b75b32571dd4b8498d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5748d5252ffa6a884f55b7b75b32571dd4b8498d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/962be380042c04d195d9c120d8445e8039d340ee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhhArUCRBK7hj4Ov3rIwAAEpwIAECG9zwERzmFruV7g/u4w2+l\nY4ZkY3jps4XOy4jxT/q137J9eI1Cv84U8EQlKxldWuckUFEt6/P7kj567mdAhPwY\nAOU8Rvq592mPrY9D7/sjyP67otht7OZCxO4Qp3nV8b0uO+tlO6pJh1TvlbSi+xJm\nPO2aogYWMlTZWLE3vNs/QmGCRA1gLtbg+4QcYguiQ5GzIHA2hhVmZ4W006/fPXH8\n9YkdPn3Utlr+/XiQwSWsJVZg9jMT8UtNnA9SJhK06V1OAx7NZ35A9y7wNjmr1MBV\ny9Xo0QszumFt/icpKH9xbTbCF7Vh2LXfa5BBGu4v4imK5S3SE2eqc8teas6XvQo=\n=KmRt\n-----END PGP SIGNATURE-----\n", "payload": "tree 5748d5252ffa6a884f55b7b75b32571dd4b8498d\nparent c96481e25f08d1565cb9b3cac89323216e6f8d7f\nparent e8416bb64446a48a58f7e61d867c46dede0809f8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1636043476 +0000\ncommitter GitHub <noreply@github.com> 1636043476 +0000\n\nMerge #10645\n\n10645: fix: make `rename` multi-token mapping aware r=Veykril a=spookyvision\n\n\n\nCo-authored-by: Anatol Ulrich <anatol.ulrich@ferrous-systems.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\nCo-authored-by: Anatol Ulrich <45840+spookyvision@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/962be380042c04d195d9c120d8445e8039d340ee", "html_url": "https://github.com/rust-lang/rust/commit/962be380042c04d195d9c120d8445e8039d340ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/962be380042c04d195d9c120d8445e8039d340ee/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c96481e25f08d1565cb9b3cac89323216e6f8d7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c96481e25f08d1565cb9b3cac89323216e6f8d7f", "html_url": "https://github.com/rust-lang/rust/commit/c96481e25f08d1565cb9b3cac89323216e6f8d7f"}, {"sha": "e8416bb64446a48a58f7e61d867c46dede0809f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8416bb64446a48a58f7e61d867c46dede0809f8", "html_url": "https://github.com/rust-lang/rust/commit/e8416bb64446a48a58f7e61d867c46dede0809f8"}], "stats": {"total": 254, "additions": 179, "deletions": 75}, "files": [{"sha": "3afcccd64d93fc73482f329e0d30b1dfc4980e87", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 148, "deletions": 63, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/962be380042c04d195d9c120d8445e8039d340ee/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962be380042c04d195d9c120d8445e8039d340ee/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=962be380042c04d195d9c120d8445e8039d340ee", "patch": "@@ -3,13 +3,15 @@\n //! This is mostly front-end for [`ide_db::rename`], but it also includes the\n //! tests. This module also implements a couple of magic tricks, like renaming\n //! `self` and to `self` (to switch between associated function and method).\n+\n use hir::{AsAssocItem, InFile, Semantics};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n     rename::{bail, format_err, source_edit_from_references, IdentifierKind},\n     RootDatabase,\n };\n+use itertools::Itertools;\n use stdx::{always, never};\n use syntax::{ast, AstNode, SyntaxNode};\n \n@@ -31,14 +33,33 @@ pub(crate) fn prepare_rename(\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n \n-    let (name_like, def) = find_definition(&sema, syntax, position)?;\n-    if def.range_for_rename(&sema).is_none() {\n-        bail!(\"No references found at position\")\n-    }\n+    let res = find_definitions(&sema, syntax, position)?\n+        .map(|(name_like, def)| {\n+            // ensure all ranges are valid\n \n-    let frange = sema.original_range(name_like.syntax());\n-    always!(frange.range.contains_inclusive(position.offset) && frange.file_id == position.file_id);\n-    Ok(RangeInfo::new(frange.range, ()))\n+            if def.range_for_rename(&sema).is_none() {\n+                bail!(\"No references found at position\")\n+            }\n+            let frange = sema.original_range(name_like.syntax());\n+\n+            always!(\n+                frange.range.contains_inclusive(position.offset)\n+                    && frange.file_id == position.file_id\n+            );\n+            Ok(frange.range)\n+        })\n+        .reduce(|acc, cur| match (acc, cur) {\n+            // ensure all ranges are the same\n+            (Ok(acc_inner), Ok(cur_inner)) if acc_inner == cur_inner => Ok(acc_inner),\n+            (Err(e), _) => Err(e),\n+            _ => bail!(\"inconsistent text range\"),\n+        });\n+\n+    match res {\n+        // ensure at least one definition was found\n+        Some(res) => res.map(|range| RangeInfo::new(range, ())),\n+        None => bail!(\"No references found at position\"),\n+    }\n }\n \n // Feature: Rename\n@@ -61,20 +82,27 @@ pub(crate) fn rename(\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n \n-    let (_name_like, def) = find_definition(&sema, syntax, position)?;\n+    let defs = find_definitions(&sema, syntax, position)?;\n \n-    if let Definition::Local(local) = def {\n-        if let Some(self_param) = local.as_self_param(sema.db) {\n-            cov_mark::hit!(rename_self_to_param);\n-            return rename_self_to_param(&sema, local, self_param, new_name);\n-        }\n-        if new_name == \"self\" {\n-            cov_mark::hit!(rename_to_self);\n-            return rename_to_self(&sema, local);\n-        }\n-    }\n+    let ops: RenameResult<Vec<SourceChange>> = defs\n+        .map(|(_namelike, def)| {\n+            if let Definition::Local(local) = def {\n+                if let Some(self_param) = local.as_self_param(sema.db) {\n+                    cov_mark::hit!(rename_self_to_param);\n+                    return rename_self_to_param(&sema, local, self_param, new_name);\n+                }\n+                if new_name == \"self\" {\n+                    cov_mark::hit!(rename_to_self);\n+                    return rename_to_self(&sema, local);\n+                }\n+            }\n+            def.rename(&sema, new_name)\n+        })\n+        .collect();\n \n-    def.rename(&sema, new_name)\n+    ops?.into_iter()\n+        .reduce(|acc, elem| acc.merge(elem))\n+        .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n /// Called by the client when it is about to rename a file.\n@@ -91,59 +119,86 @@ pub(crate) fn will_rename_file(\n     Some(change)\n }\n \n-fn find_definition(\n+fn find_definitions(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n-) -> RenameResult<(ast::NameLike, Definition)> {\n-    let name_like = sema\n-        .find_node_at_offset_with_descend::<ast::NameLike>(syntax, position.offset)\n-        .ok_or_else(|| format_err!(\"No references found at position\"))?;\n-\n-    let def = match &name_like {\n-        // renaming aliases would rename the item being aliased as the HIR doesn't track aliases yet\n-        ast::NameLike::Name(name)\n-            if name.syntax().parent().map_or(false, |it| ast::Rename::can_cast(it.kind())) =>\n-        {\n-            bail!(\"Renaming aliases is currently unsupported\")\n-        }\n-        ast::NameLike::Name(name) => NameClass::classify(sema, name).map(|class| match class {\n-            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-            NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n-                Definition::Local(local_def)\n-            }\n-        }),\n-        ast::NameLike::NameRef(name_ref) => {\n-            if let Some(def) = NameRefClass::classify(sema, name_ref).map(|class| match class {\n-                NameRefClass::Definition(def) => def,\n-                NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n-                    Definition::Local(local_ref)\n+) -> RenameResult<impl Iterator<Item = (ast::NameLike, Definition)>> {\n+    let symbols = sema\n+        .find_nodes_at_offset_with_descend::<ast::NameLike>(syntax, position.offset)\n+        .map(|name_like| {\n+            let res = match &name_like {\n+                // renaming aliases would rename the item being aliased as the HIR doesn't track aliases yet\n+                ast::NameLike::Name(name)\n+                    if name\n+                        .syntax()\n+                        .parent()\n+                        .map_or(false, |it| ast::Rename::can_cast(it.kind())) =>\n+                {\n+                    bail!(\"Renaming aliases is currently unsupported\")\n+                }\n+                ast::NameLike::Name(name) => NameClass::classify(sema, name)\n+                    .map(|class| match class {\n+                        NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                        NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                            Definition::Local(local_def)\n+                        }\n+                    })\n+                    .map(|def| (name_like.clone(), def))\n+                    .ok_or_else(|| format_err!(\"No references found at position\")),\n+                ast::NameLike::NameRef(name_ref) => {\n+                    NameRefClass::classify(sema, name_ref)\n+                        .map(|class| match class {\n+                            NameRefClass::Definition(def) => def,\n+                            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                                Definition::Local(local_ref)\n+                            }\n+                        })\n+                        .ok_or_else(|| format_err!(\"No references found at position\"))\n+                        .and_then(|def| {\n+                            // if the name differs from the definitions name it has to be an alias\n+                            if def\n+                                .name(sema.db)\n+                                .map_or(false, |it| it.to_string() != name_ref.text())\n+                            {\n+                                Err(format_err!(\"Renaming aliases is currently unsupported\"))\n+                            } else {\n+                                Ok((name_like.clone(), def))\n+                            }\n+                        })\n                 }\n-            }) {\n-                // if the name differs from the definitions name it has to be an alias\n-                if def.name(sema.db).map_or(false, |it| it.to_string() != name_ref.text()) {\n-                    bail!(\"Renaming aliases is currently unsupported\");\n+                ast::NameLike::Lifetime(lifetime) => {\n+                    NameRefClass::classify_lifetime(sema, lifetime)\n+                        .and_then(|class| match class {\n+                            NameRefClass::Definition(def) => Some(def),\n+                            _ => None,\n+                        })\n+                        .or_else(|| {\n+                            NameClass::classify_lifetime(sema, lifetime).and_then(|it| match it {\n+                                NameClass::Definition(it) => Some(it),\n+                                _ => None,\n+                            })\n+                        })\n+                        .map(|def| (name_like, def))\n+                        .ok_or_else(|| format_err!(\"No references found at position\"))\n                 }\n-                Some(def)\n+            };\n+            res\n+        });\n+\n+    let res: RenameResult<Vec<_>> = symbols.collect();\n+    match res {\n+        Ok(v) => {\n+            if v.is_empty() {\n+                // FIXME: some semantic duplication between \"empty vec\" and \"Err()\"\n+                Err(format_err!(\"No references found at position\"))\n             } else {\n-                None\n+                // remove duplicates, comparing `Definition`s\n+                Ok(v.into_iter().unique_by(|t| t.1))\n             }\n         }\n-        ast::NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, lifetime)\n-            .and_then(|class| match class {\n-                NameRefClass::Definition(def) => Some(def),\n-                _ => None,\n-            })\n-            .or_else(|| {\n-                NameClass::classify_lifetime(sema, lifetime).and_then(|it| match it {\n-                    NameClass::Definition(it) => Some(it),\n-                    _ => None,\n-                })\n-            }),\n+        Err(e) => Err(e),\n     }\n-    .ok_or_else(|| format_err!(\"No references found at position\"))?;\n-\n-    Ok((name_like, def))\n }\n \n fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameResult<SourceChange> {\n@@ -515,6 +570,36 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_macro_multiple_occurrences() {\n+        check(\n+            \"Baaah\",\n+            r#\"macro_rules! foo {\n+    ($ident:ident) => {\n+        const $ident: () = ();\n+        struct $ident {}\n+    };\n+}\n+\n+foo!($0Foo);\n+const _: () = Foo;\n+const _: Foo = Foo {};\n+    \"#,\n+            r#\"\n+macro_rules! foo {\n+    ($ident:ident) => {\n+        const $ident: () = ();\n+        struct $ident {}\n+    };\n+}\n+\n+foo!(Baaah);\n+const _: () = Baaah;\n+const _: Baaah = Baaah {};\n+    \"#,\n+        )\n+    }\n+\n     #[test]\n     fn test_rename_for_macro_args() {\n         check("}, {"sha": "aa910eb3254e4cb9cb3658c2166508c498dc1b80", "filename": "crates/ide_db/src/source_change.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/962be380042c04d195d9c120d8445e8039d340ee/crates%2Fide_db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962be380042c04d195d9c120d8445e8039d340ee/crates%2Fide_db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsource_change.rs?ref=962be380042c04d195d9c120d8445e8039d340ee", "patch": "@@ -54,6 +54,13 @@ impl SourceChange {\n     pub fn get_source_edit(&self, file_id: FileId) -> Option<&TextEdit> {\n         self.source_file_edits.get(&file_id)\n     }\n+\n+    pub fn merge(mut self, other: SourceChange) -> SourceChange {\n+        self.extend(other.source_file_edits);\n+        self.extend(other.file_system_edits);\n+        self.is_snippet |= other.is_snippet;\n+        self\n+    }\n }\n \n impl Extend<(FileId, TextEdit)> for SourceChange {\n@@ -62,6 +69,12 @@ impl Extend<(FileId, TextEdit)> for SourceChange {\n     }\n }\n \n+impl Extend<FileSystemEdit> for SourceChange {\n+    fn extend<T: IntoIterator<Item = FileSystemEdit>>(&mut self, iter: T) {\n+        iter.into_iter().for_each(|edit| self.push_file_system_edit(edit));\n+    }\n+}\n+\n impl From<FxHashMap<FileId, TextEdit>> for SourceChange {\n     fn from(source_file_edits: FxHashMap<FileId, TextEdit>) -> SourceChange {\n         SourceChange { source_file_edits, file_system_edits: Vec::new(), is_snippet: false }"}, {"sha": "21c622d3d6bb6e2fb6a674f3318f4f77e10d9600", "filename": "crates/text_edit/src/lib.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/962be380042c04d195d9c120d8445e8039d340ee/crates%2Ftext_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962be380042c04d195d9c120d8445e8039d340ee/crates%2Ftext_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftext_edit%2Fsrc%2Flib.rs?ref=962be380042c04d195d9c120d8445e8039d340ee", "patch": "@@ -3,12 +3,13 @@\n //! `rust-analyzer` never mutates text itself and only sends diffs to clients,\n //! so `TextEdit` is the ultimate representation of the work done by\n //! rust-analyzer.\n+\n pub use text_size::{TextRange, TextSize};\n \n /// `InsertDelete` -- a single \"atomic\" change to text\n ///\n /// Must not overlap with other `InDel`s\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Indel {\n     pub insert: String,\n     /// Refers to offsets in the original text\n@@ -116,11 +117,14 @@ impl TextEdit {\n     pub fn union(&mut self, other: TextEdit) -> Result<(), TextEdit> {\n         // FIXME: can be done without allocating intermediate vector\n         let mut all = self.iter().chain(other.iter()).collect::<Vec<_>>();\n-        if !check_disjoint(&mut all) {\n+        if !check_disjoint_and_sort(&mut all) {\n             return Err(other);\n         }\n+\n         self.indels.extend(other.indels);\n-        assert_disjoint(&mut self.indels);\n+        check_disjoint_and_sort(&mut self.indels);\n+        // Only dedup deletions and replacements, keep all insertions\n+        self.indels.dedup_by(|a, b| a == b && !a.delete.is_empty());\n         Ok(())\n     }\n \n@@ -173,7 +177,7 @@ impl TextEditBuilder {\n     }\n     pub fn finish(self) -> TextEdit {\n         let mut indels = self.indels;\n-        assert_disjoint(&mut indels);\n+        assert_disjoint_or_equal(&mut indels);\n         TextEdit { indels }\n     }\n     pub fn invalidates_offset(&self, offset: TextSize) -> bool {\n@@ -182,18 +186,20 @@ impl TextEditBuilder {\n     fn indel(&mut self, indel: Indel) {\n         self.indels.push(indel);\n         if self.indels.len() <= 16 {\n-            assert_disjoint(&mut self.indels);\n+            assert_disjoint_or_equal(&mut self.indels);\n         }\n     }\n }\n \n-fn assert_disjoint(indels: &mut [impl std::borrow::Borrow<Indel>]) {\n-    assert!(check_disjoint(indels));\n+fn assert_disjoint_or_equal(indels: &mut [Indel]) {\n+    assert!(check_disjoint_and_sort(indels));\n }\n-fn check_disjoint(indels: &mut [impl std::borrow::Borrow<Indel>]) -> bool {\n+// FIXME: Remove the impl Bound here, it shouldn't be needed\n+fn check_disjoint_and_sort(indels: &mut [impl std::borrow::Borrow<Indel>]) -> bool {\n     indels.sort_by_key(|indel| (indel.borrow().delete.start(), indel.borrow().delete.end()));\n-    indels\n-        .iter()\n-        .zip(indels.iter().skip(1))\n-        .all(|(l, r)| l.borrow().delete.end() <= r.borrow().delete.start())\n+    indels.iter().zip(indels.iter().skip(1)).all(|(l, r)| {\n+        let l = l.borrow();\n+        let r = r.borrow();\n+        l.delete.end() <= r.delete.start() || l == r\n+    })\n }"}]}