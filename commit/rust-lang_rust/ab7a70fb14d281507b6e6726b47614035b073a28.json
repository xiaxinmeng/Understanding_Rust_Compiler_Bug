{"sha": "ab7a70fb14d281507b6e6726b47614035b073a28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiN2E3MGZiMTRkMjgxNTA3YjZlNjcyNmI0NzYxNDAzNWIwNzNhMjg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-21T11:38:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-21T11:38:40Z"}, "message": "Don't track imports", "tree": {"sha": "becb28dbc24c9772017a84f2e6f02bc15a03475d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/becb28dbc24c9772017a84f2e6f02bc15a03475d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7a70fb14d281507b6e6726b47614035b073a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7a70fb14d281507b6e6726b47614035b073a28", "html_url": "https://github.com/rust-lang/rust/commit/ab7a70fb14d281507b6e6726b47614035b073a28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7a70fb14d281507b6e6726b47614035b073a28/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67ba9072fad8698af4e96b38b8b4acfdd801f7f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/67ba9072fad8698af4e96b38b8b4acfdd801f7f7", "html_url": "https://github.com/rust-lang/rust/commit/67ba9072fad8698af4e96b38b8b4acfdd801f7f7"}], "stats": {"total": 74, "additions": 26, "deletions": 48}, "files": [{"sha": "5c14fefff4378be1f8e923507654d427b4663909", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ab7a70fb14d281507b6e6726b47614035b073a28/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7a70fb14d281507b6e6726b47614035b073a28/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=ab7a70fb14d281507b6e6726b47614035b073a28", "patch": "@@ -5,7 +5,7 @@ use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n \n-use crate::{per_ns::PerNs, BuiltinType, ImplId, LocalImportId, MacroDefId, ModuleDefId, TraitId};\n+use crate::{per_ns::PerNs, BuiltinType, ImplId, MacroDefId, ModuleDefId, TraitId};\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n@@ -30,7 +30,7 @@ static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n     BuiltinType::ALL\n         .iter()\n         .map(|(name, ty)| {\n-            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n+            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), declaration: false })\n         })\n         .collect()\n });\n@@ -53,11 +53,9 @@ impl ItemScope {\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n-        self.entries()\n-            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n-            .flat_map(|per_ns| {\n-                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n-            })\n+        self.entries().filter(|(_name, res)| res.declaration).flat_map(|(_name, res)| {\n+            res.def.take_types().into_iter().chain(res.def.take_values().into_iter())\n+        })\n     }\n \n     pub fn impls(&self) -> impl Iterator<Item = ImplId> + ExactSizeIterator + '_ {\n@@ -112,38 +110,26 @@ impl ItemScope {\n         self.legacy_macros.insert(name, mac);\n     }\n \n-    pub(crate) fn push_res(\n-        &mut self,\n-        name: Name,\n-        res: &Resolution,\n-        import: Option<LocalImportId>,\n-    ) -> bool {\n+    pub(crate) fn push_res(&mut self, name: Name, res: &Resolution, declaration: bool) -> bool {\n         let mut changed = false;\n         let existing = self.items.entry(name.clone()).or_default();\n \n         if existing.def.types.is_none() && res.def.types.is_some() {\n             existing.def.types = res.def.types;\n-            existing.import = import.or(res.import);\n+            existing.declaration |= declaration;\n             changed = true;\n         }\n         if existing.def.values.is_none() && res.def.values.is_some() {\n             existing.def.values = res.def.values;\n-            existing.import = import.or(res.import);\n+            existing.declaration |= declaration;\n             changed = true;\n         }\n         if existing.def.macros.is_none() && res.def.macros.is_some() {\n             existing.def.macros = res.def.macros;\n-            existing.import = import.or(res.import);\n+            existing.declaration |= declaration;\n             changed = true;\n         }\n \n-        if existing.def.is_none()\n-            && res.def.is_none()\n-            && existing.import.is_none()\n-            && res.import.is_some()\n-        {\n-            existing.import = res.import;\n-        }\n         changed\n     }\n \n@@ -160,6 +146,5 @@ impl ItemScope {\n pub struct Resolution {\n     /// None for unresolved\n     pub def: PerNs,\n-    /// ident by which this is imported into local scope.\n-    pub import: Option<LocalImportId>,\n+    pub declaration: bool,\n }"}, {"sha": "e43aafedb9140b5135d40232fded7857b69af0ec", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ab7a70fb14d281507b6e6726b47614035b073a28/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7a70fb14d281507b6e6726b47614035b073a28/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=ab7a70fb14d281507b6e6726b47614035b073a28", "patch": "@@ -218,8 +218,7 @@ where\n         if export {\n             self.update(\n                 self.def_map.root,\n-                None,\n-                &[(name, Resolution { def: PerNs::macros(macro_), import: None })],\n+                &[(name, Resolution { def: PerNs::macros(macro_), declaration: false })],\n             );\n         }\n     }\n@@ -374,7 +373,7 @@ where\n                         // Module scoped macros is included\n                         let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n@@ -384,7 +383,7 @@ where\n                         // Module scoped macros is included\n                         let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n                         if !glob.iter().any(|it| *it == (module_id, import_id)) {\n@@ -404,12 +403,12 @@ where\n                             let variant = EnumVariantId { parent: e, local_id };\n                             let res = Resolution {\n                                 def: PerNs::both(variant.into(), variant.into()),\n-                                import: Some(import_id),\n+                                declaration: false,\n                             };\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, Some(import_id), &resolutions);\n+                    self.update(module_id, &resolutions);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -431,27 +430,21 @@ where\n                         }\n                     }\n \n-                    let resolution = Resolution { def, import: Some(import_id) };\n-                    self.update(module_id, Some(import_id), &[(name, resolution)]);\n+                    let resolution = Resolution { def, declaration: false };\n+                    self.update(module_id, &[(name, resolution)]);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        import: Option<LocalImportId>,\n-        resolutions: &[(Name, Resolution)],\n-    ) {\n-        self.update_recursive(module_id, import, resolutions, 0)\n+    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, Resolution)]) {\n+        self.update_recursive(module_id, resolutions, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n-        import: Option<LocalImportId>,\n         resolutions: &[(Name, Resolution)],\n         depth: usize,\n     ) {\n@@ -462,7 +455,7 @@ where\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |= scope.push_res(name.clone(), res, import);\n+            changed |= scope.push_res(name.clone(), res, depth == 0 && res.declaration);\n         }\n \n         if !changed {\n@@ -475,9 +468,9 @@ where\n             .flat_map(|v| v.iter())\n             .cloned()\n             .collect::<Vec<_>>();\n-        for (glob_importing_module, glob_import) in glob_imports {\n+        for (glob_importing_module, _glob_import) in glob_imports {\n             // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+            self.update_recursive(glob_importing_module, resolutions, depth + 1);\n         }\n     }\n \n@@ -719,9 +712,9 @@ where\n             def: PerNs::types(\n                 ModuleId { krate: self.def_collector.def_map.krate, local_id: res }.into(),\n             ),\n-            import: None,\n+            declaration: true,\n         };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n+        self.def_collector.update(self.module_id, &[(name, resolution)]);\n         res\n     }\n \n@@ -791,8 +784,8 @@ where\n                 PerNs::types(def.into())\n             }\n         };\n-        let resolution = Resolution { def, import: None };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n+        let resolution = Resolution { def, declaration: true };\n+        self.def_collector.update(self.module_id, &[(name, resolution)])\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {"}]}