{"sha": "69070058cd2fdb57ebbbbef94892cfb5688ce27f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MDcwMDU4Y2QyZmRiNTdlYmJiYmVmOTQ4OTJjZmI1Njg4Y2UyN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-11T04:45:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-11T04:45:15Z"}, "message": "Auto merge of #62580 - Centril:rollup-remihe0, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #61665 (core: check for pointer equality when comparing Eq slices)\n - #61923 (Prerequisites from dep graph refactoring #2)\n - #62270 (Move async-await tests from run-pass to ui)\n - #62425 (filedesc: don't use ioctl(FIOCLEX) on Linux)\n - #62476 (Continue refactoring macro expansion and resolution)\n - #62519 (Regression test for HRTB bug (issue 30786).)\n - #62557 (Fix typo in libcore/intrinsics.rs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2cecc439269108897d4bec08cc5cfe119c3f8fdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cecc439269108897d4bec08cc5cfe119c3f8fdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69070058cd2fdb57ebbbbef94892cfb5688ce27f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69070058cd2fdb57ebbbbef94892cfb5688ce27f", "html_url": "https://github.com/rust-lang/rust/commit/69070058cd2fdb57ebbbbef94892cfb5688ce27f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69070058cd2fdb57ebbbbef94892cfb5688ce27f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35cacbce1661366250a877da4fa5b6b4cb03542e", "url": "https://api.github.com/repos/rust-lang/rust/commits/35cacbce1661366250a877da4fa5b6b4cb03542e", "html_url": "https://github.com/rust-lang/rust/commit/35cacbce1661366250a877da4fa5b6b4cb03542e"}, {"sha": "f9034ce8bc42e2cfed14373a1e0952e4ac67da4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9034ce8bc42e2cfed14373a1e0952e4ac67da4d", "html_url": "https://github.com/rust-lang/rust/commit/f9034ce8bc42e2cfed14373a1e0952e4ac67da4d"}], "stats": {"total": 2480, "additions": 1338, "deletions": 1142}, "files": [{"sha": "8db241e4b4ebf7f0e67713dc0240b112745a83c0", "filename": "src/doc/unstable-book/src/language-features/on-unimplemented.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -98,7 +98,8 @@ application of these fields based on a variety of attributes when using\n    `crate_local`) or matching against a particular method. Currently used\n    for `try`.\n  - `from_desugaring`: usable both as boolean (whether the flag is present)\n-   or matching against a particular desugaring.\n+   or matching against a particular desugaring. The desugaring is identified\n+   with its variant name in the `DesugaringKind` enum.\n \n For example, the `Iterator` trait can be annotated in the following way:\n "}, {"sha": "513e22a788cdf373afe52c45266ec7cdca705553", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -705,7 +705,8 @@ extern \"rust-intrinsic\" {\n                          they should be used through stabilized interfaces \\\n                          in the rest of the standard library\",\n                issue = \"0\")]\n-    #[rustc_deprecated(reason = \"no longer used by rustc, will be removed - use MaybeUnint instead\",\n+    #[rustc_deprecated(reason = \"no longer used by rustc, will be removed - use MaybeUninit \\\n+                                 instead\",\n                        since = \"1.38.0\")]\n     pub fn init<T>() -> T;\n "}, {"sha": "293a2dd94922fbc88047d803359c252385669d03", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1244,19 +1244,22 @@ mod builtin {\n \n     /// Attribute macro applied to a function to turn it into a unit test.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n     #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n     #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro bench($item:item) { /* compiler built-in */ }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n     #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n                reason = \"custom test frameworks are an unstable feature\")]\n+    #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n     #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }"}, {"sha": "76fec1020f1eff572d8c8c5890efeffce81bc207", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -8,12 +8,12 @@\n #[rustc_on_unimplemented(\n    on(all(\n        any(from_method=\"from_error\", from_method=\"from_ok\"),\n-       from_desugaring=\"?\"),\n+       from_desugaring=\"QuestionMark\"),\n       message=\"the `?` operator can only be used in a \\\n                function that returns `Result` or `Option` \\\n                (or another type that implements `{Try}`)\",\n       label=\"cannot use the `?` operator in a function that returns `{Self}`\"),\n-   on(all(from_method=\"into_result\", from_desugaring=\"?\"),\n+   on(all(from_method=\"into_result\", from_desugaring=\"QuestionMark\"),\n       message=\"the `?` operator can only be applied to values \\\n                that implement `{Try}`\",\n       label=\"the `?` operator cannot be applied to type `{Self}`\")"}, {"sha": "363ae088275586239e95a53f337b0e9c2ab1905b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -5342,13 +5342,24 @@ impl<A, B> SlicePartialEq<B> for [A]\n             return false;\n         }\n \n-        for i in 0..self.len() {\n-            if !self[i].eq(&other[i]) {\n-                return false;\n-            }\n+        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n+    }\n+}\n+\n+// Use an equal-pointer optimization when types are `Eq`\n+impl<A> SlicePartialEq<A> for [A]\n+    where A: PartialEq<A> + Eq\n+{\n+    default fn equal(&self, other: &[A]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+\n+        if self.as_ptr() == other.as_ptr() {\n+            return true;\n         }\n \n-        true\n+        self.iter().zip(other.iter()).all(|(x, y)| x == y)\n     }\n }\n \n@@ -5457,7 +5468,7 @@ impl SliceOrd<u8> for [u8] {\n #[doc(hidden)]\n /// Trait implemented for types that can be compared for equality using\n /// their bytewise representation\n-trait BytewiseEquality { }\n+trait BytewiseEquality: Eq + Copy { }\n \n macro_rules! impl_marker_for {\n     ($traitname:ident, $($ty:ty)*) => {"}, {"sha": "7eea336cbbfa1e3804f0c7fc6c68e533433a1695", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -7,6 +7,7 @@ use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, Ordering};\n use std::env;\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n+use std::mem;\n use crate::ty::{self, TyCtxt};\n use crate::util::common::{ProfileQueriesMsg, profq_msg};\n use parking_lot::{Mutex, Condvar};\n@@ -61,11 +62,11 @@ struct DepGraphData {\n \n     colors: DepNodeColorMap,\n \n-    /// A set of loaded diagnostics that have been emitted.\n-    emitted_diagnostics: Mutex<FxHashSet<DepNodeIndex>>,\n+    /// A set of loaded diagnostics that is in the progress of being emitted.\n+    emitting_diagnostics: Mutex<FxHashSet<DepNodeIndex>>,\n \n     /// Used to wait for diagnostics to be emitted.\n-    emitted_diagnostics_cond_var: Condvar,\n+    emitting_diagnostics_cond_var: Condvar,\n \n     /// When we load, there may be `.o` files, cached MIR, or other such\n     /// things available to us. If we find that they are not dirty, we\n@@ -99,8 +100,8 @@ impl DepGraph {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n                 current: Lock::new(CurrentDepGraph::new(prev_graph_node_count)),\n-                emitted_diagnostics: Default::default(),\n-                emitted_diagnostics_cond_var: Condvar::new(),\n+                emitting_diagnostics: Default::default(),\n+                emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n                 loaded_from_cache: Default::default(),\n@@ -744,7 +745,7 @@ impl DepGraph {\n \n         // There may be multiple threads trying to mark the same dep node green concurrently\n \n-        let (dep_node_index, did_allocation) = {\n+        let dep_node_index = {\n             let mut current = data.current.borrow_mut();\n \n             // Copy the fingerprint from the previous graph,\n@@ -758,71 +759,86 @@ impl DepGraph {\n \n         // ... emitting any stored diagnostic ...\n \n+        // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n+        // Maybe store a list on disk and encode this fact in the DepNodeState\n         let diagnostics = tcx.queries.on_disk_cache\n-                                .load_diagnostics(tcx, prev_dep_node_index);\n+                             .load_diagnostics(tcx, prev_dep_node_index);\n+\n+        #[cfg(not(parallel_compiler))]\n+        debug_assert!(data.colors.get(prev_dep_node_index).is_none(),\n+                      \"DepGraph::try_mark_previous_green() - Duplicate DepNodeColor \\\n+                      insertion for {:?}\", dep_node);\n \n         if unlikely!(diagnostics.len() > 0) {\n             self.emit_diagnostics(\n                 tcx,\n                 data,\n                 dep_node_index,\n-                did_allocation,\n+                prev_dep_node_index,\n                 diagnostics\n             );\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n         // Multiple threads can all write the same color here\n-        #[cfg(not(parallel_compiler))]\n-        debug_assert!(data.colors.get(prev_dep_node_index).is_none(),\n-                      \"DepGraph::try_mark_previous_green() - Duplicate DepNodeColor \\\n-                      insertion for {:?}\", dep_node);\n-\n         data.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n \n         debug!(\"try_mark_previous_green({:?}) - END - successfully marked as green\", dep_node);\n         Some(dep_node_index)\n     }\n \n-    /// Atomically emits some loaded diagnotics, assuming that this only gets called with\n-    /// `did_allocation` set to `true` on a single thread.\n+    /// Atomically emits some loaded diagnostics.\n+    /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n     fn emit_diagnostics<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         data: &DepGraphData,\n         dep_node_index: DepNodeIndex,\n-        did_allocation: bool,\n+        prev_dep_node_index: SerializedDepNodeIndex,\n         diagnostics: Vec<Diagnostic>,\n     ) {\n-        if did_allocation || !cfg!(parallel_compiler) {\n-            // Only the thread which did the allocation emits the error messages\n-            let handle = tcx.sess.diagnostic();\n+        let mut emitting = data.emitting_diagnostics.lock();\n+\n+        if data.colors.get(prev_dep_node_index) == Some(DepNodeColor::Green(dep_node_index)) {\n+            // The node is already green so diagnostics must have been emitted already\n+            return;\n+        }\n+\n+        if emitting.insert(dep_node_index) {\n+            // We were the first to insert the node in the set so this thread\n+            // must emit the diagnostics and signal other potentially waiting\n+            // threads after.\n+            mem::drop(emitting);\n \n             // Promote the previous diagnostics to the current session.\n             tcx.queries.on_disk_cache\n-                .store_diagnostics(dep_node_index, diagnostics.clone().into());\n+               .store_diagnostics(dep_node_index, diagnostics.clone().into());\n+\n+            let handle = tcx.sess.diagnostic();\n \n             for diagnostic in diagnostics {\n                 DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();\n             }\n \n-            #[cfg(parallel_compiler)]\n-            {\n-                // Mark the diagnostics and emitted and wake up waiters\n-                data.emitted_diagnostics.lock().insert(dep_node_index);\n-                data.emitted_diagnostics_cond_var.notify_all();\n-            }\n+            // Mark the node as green now that diagnostics are emitted\n+            data.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n+\n+            // Remove the node from the set\n+            data.emitting_diagnostics.lock().remove(&dep_node_index);\n+\n+            // Wake up waiters\n+            data.emitting_diagnostics_cond_var.notify_all();\n         } else {\n-            // The other threads will wait for the diagnostics to be emitted\n+            // We must wait for the other thread to finish emitting the diagnostic\n \n-            let mut emitted_diagnostics = data.emitted_diagnostics.lock();\n             loop {\n-                if emitted_diagnostics.contains(&dep_node_index) {\n+                data.emitting_diagnostics_cond_var.wait(&mut emitting);\n+                if data.colors\n+                       .get(prev_dep_node_index) == Some(DepNodeColor::Green(dep_node_index)) {\n                     break;\n                 }\n-                data.emitted_diagnostics_cond_var.wait(&mut emitted_diagnostics);\n             }\n         }\n     }\n@@ -1027,7 +1043,7 @@ impl CurrentDepGraph {\n             hash: self.anon_id_seed.combine(hasher.finish()),\n         };\n \n-        self.intern_node(target_dep_node, task_deps.reads, Fingerprint::ZERO).0\n+        self.intern_node(target_dep_node, task_deps.reads, Fingerprint::ZERO)\n     }\n \n     fn alloc_node(\n@@ -1037,19 +1053,19 @@ impl CurrentDepGraph {\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n         debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n-        self.intern_node(dep_node, edges, fingerprint).0\n+        self.intern_node(dep_node, edges, fingerprint)\n     }\n \n     fn intern_node(\n         &mut self,\n         dep_node: DepNode,\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n-    ) -> (DepNodeIndex, bool) {\n+    ) -> DepNodeIndex {\n         debug_assert_eq!(self.node_to_node_index.len(), self.data.len());\n \n         match self.node_to_node_index.entry(dep_node) {\n-            Entry::Occupied(entry) => (*entry.get(), false),\n+            Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let dep_node_index = DepNodeIndex::new(self.data.len());\n                 self.data.push(DepNodeData {\n@@ -1058,7 +1074,7 @@ impl CurrentDepGraph {\n                     fingerprint\n                 });\n                 entry.insert(dep_node_index);\n-                (dep_node_index, true)\n+                dep_node_index\n             }\n         }\n     }"}, {"sha": "7e7bb5f61a3241ad91cf53000dec3ff92a46f718", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -60,10 +60,9 @@ use syntax::attr;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::errors;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::print::pprust;\n-use syntax::source_map::{self, respan, ExpnInfo, CompilerDesugaringKind, Spanned};\n-use syntax::source_map::CompilerDesugaringKind::CondTemporary;\n+use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n@@ -872,17 +871,15 @@ impl<'a> LoweringContext<'a> {\n     /// allowed inside this span.\n     fn mark_span_with_reason(\n         &self,\n-        reason: CompilerDesugaringKind,\n+        reason: DesugaringKind,\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            def_site: Some(span),\n+        span.fresh_expansion(Mark::root(), ExpnInfo {\n+            def_site: span,\n             allow_internal_unstable,\n-            ..ExpnInfo::default(source_map::CompilerDesugaring(reason), span, self.sess.edition())\n-        });\n-        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n+            ..ExpnInfo::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n+        })\n     }\n \n     fn with_anonymous_lifetime_mode<R>(\n@@ -1188,7 +1185,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         let unstable_span = self.mark_span_with_reason(\n-            CompilerDesugaringKind::Async,\n+            DesugaringKind::Async,\n             span,\n             self.allow_gen_future.clone(),\n         );\n@@ -1733,7 +1730,7 @@ impl<'a> LoweringContext<'a> {\n         // Not tracking it makes lints in rustc and clippy very fragile, as\n         // frequently opened issues show.\n         let exist_ty_span = self.mark_span_with_reason(\n-            CompilerDesugaringKind::ExistentialType,\n+            DesugaringKind::ExistentialType,\n             span,\n             None,\n         );\n@@ -2603,7 +2600,7 @@ impl<'a> LoweringContext<'a> {\n         let span = output.span();\n \n         let exist_ty_span = self.mark_span_with_reason(\n-            CompilerDesugaringKind::Async,\n+            DesugaringKind::Async,\n             span,\n             None,\n         );\n@@ -3275,7 +3272,7 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 let desugared_span =\n-                    this.mark_span_with_reason(CompilerDesugaringKind::Async, span, None);\n+                    this.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n                 // Construct an argument representing `__argN: <ty>` to replace the argument of the\n                 // async function.\n@@ -4410,7 +4407,9 @@ impl<'a> LoweringContext<'a> {\n                     _ => {\n                         // Lower condition:\n                         let cond = self.lower_expr(cond);\n-                        let span_block = self.mark_span_with_reason(CondTemporary, cond.span, None);\n+                        let span_block = self.mark_span_with_reason(\n+                            DesugaringKind::CondTemporary, cond.span, None\n+                        );\n                         // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                         // to preserve drop semantics since `if cond { ... }` does not\n                         // let temporaries live outside of `cond`.\n@@ -4469,7 +4468,9 @@ impl<'a> LoweringContext<'a> {\n \n                         // Lower condition:\n                         let cond = this.with_loop_condition_scope(|this| this.lower_expr(cond));\n-                        let span_block = this.mark_span_with_reason(CondTemporary, cond.span, None);\n+                        let span_block = this.mark_span_with_reason(\n+                            DesugaringKind::CondTemporary, cond.span, None\n+                        );\n                         // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                         // to preserve drop semantics since `while cond { ... }` does not\n                         // let temporaries live outside of `cond`.\n@@ -4508,7 +4509,7 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::TryBlock(ref body) => {\n                 self.with_catch_scope(body.id, |this| {\n                     let unstable_span = this.mark_span_with_reason(\n-                        CompilerDesugaringKind::TryBlock,\n+                        DesugaringKind::TryBlock,\n                         body.span,\n                         this.allow_try_trait.clone(),\n                     );\n@@ -4836,7 +4837,7 @@ impl<'a> LoweringContext<'a> {\n                 let mut head = self.lower_expr(head);\n                 let head_sp = head.span;\n                 let desugared_span = self.mark_span_with_reason(\n-                    CompilerDesugaringKind::ForLoop,\n+                    DesugaringKind::ForLoop,\n                     head_sp,\n                     None,\n                 );\n@@ -4990,13 +4991,13 @@ impl<'a> LoweringContext<'a> {\n                 // }\n \n                 let unstable_span = self.mark_span_with_reason(\n-                    CompilerDesugaringKind::QuestionMark,\n+                    DesugaringKind::QuestionMark,\n                     e.span,\n                     self.allow_try_trait.clone(),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n                 let try_span = self.mark_span_with_reason(\n-                    CompilerDesugaringKind::QuestionMark,\n+                    DesugaringKind::QuestionMark,\n                     try_span,\n                     self.allow_try_trait.clone(),\n                 );\n@@ -5811,12 +5812,12 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n         let span = self.mark_span_with_reason(\n-            CompilerDesugaringKind::Await,\n+            DesugaringKind::Await,\n             await_span,\n             None,\n         );\n         let gen_future_span = self.mark_span_with_reason(\n-            CompilerDesugaringKind::Await,\n+            DesugaringKind::Await,\n             await_span,\n             self.allow_gen_future.clone(),\n         );"}, {"sha": "6b93bd96a2718e435707c579835d9882ac52e419", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 19, "deletions": 58, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,6 +1,5 @@\n use crate::hir::map::definitions::*;\n-use crate::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n-use crate::session::CrateDisambiguator;\n+use crate::hir::def_id::DefIndex;\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n@@ -12,51 +11,30 @@ use syntax_pos::Span;\n /// Creates `DefId`s for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n-    parent_def: Option<DefIndex>,\n+    parent_def: DefIndex,\n     expansion: Mark,\n-    pub visit_macro_invoc: Option<&'a mut dyn FnMut(MacroInvocationData)>,\n-}\n-\n-pub struct MacroInvocationData {\n-    pub mark: Mark,\n-    pub def_index: DefIndex,\n }\n \n impl<'a> DefCollector<'a> {\n     pub fn new(definitions: &'a mut Definitions, expansion: Mark) -> Self {\n-        DefCollector {\n-            definitions,\n-            expansion,\n-            parent_def: None,\n-            visit_macro_invoc: None,\n-        }\n-    }\n-\n-    pub fn collect_root(&mut self,\n-                        crate_name: &str,\n-                        crate_disambiguator: CrateDisambiguator) {\n-        let root = self.definitions.create_root_def(crate_name,\n-                                                    crate_disambiguator);\n-        assert_eq!(root, CRATE_DEF_INDEX);\n-        self.parent_def = Some(root);\n+        let parent_def = definitions.invocation_parent(expansion);\n+        DefCollector { definitions, parent_def, expansion }\n     }\n \n     fn create_def(&mut self,\n                   node_id: NodeId,\n                   data: DefPathData,\n                   span: Span)\n                   -> DefIndex {\n-        let parent_def = self.parent_def.unwrap();\n+        let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions\n-            .create_def_with_parent(parent_def, node_id, data, self.expansion, span)\n+        self.definitions.create_def_with_parent(parent_def, node_id, data, self.expansion, span)\n     }\n \n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n-        let parent = self.parent_def;\n-        self.parent_def = Some(parent_def);\n+        let orig_parent_def = std::mem::replace(&mut self.parent_def, parent_def);\n         f(self);\n-        self.parent_def = parent;\n+        self.parent_def = orig_parent_def;\n     }\n \n     fn visit_async_fn(\n@@ -97,12 +75,7 @@ impl<'a> DefCollector<'a> {\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId) {\n-        if let Some(ref mut visit) = self.visit_macro_invoc {\n-            visit(MacroInvocationData {\n-                mark: id.placeholder_to_mark(),\n-                def_index: self.parent_def.unwrap(),\n-            })\n-        }\n+        self.definitions.set_invocation_parent(id.placeholder_to_mark(), self.parent_def);\n     }\n }\n \n@@ -275,36 +248,24 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n-        let parent_def = self.parent_def;\n-\n-        match expr.node {\n+        let parent_def = match expr.node {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n             ExprKind::Closure(_, asyncness, ..) => {\n-                let closure_def = self.create_def(expr.id,\n-                                          DefPathData::ClosureExpr,\n-                                          expr.span);\n-                self.parent_def = Some(closure_def);\n-\n                 // Async closures desugar to closures inside of closures, so\n                 // we must create two defs.\n-                if let IsAsync::Async { closure_id, .. } = asyncness {\n-                    let async_def = self.create_def(closure_id,\n-                                                    DefPathData::ClosureExpr,\n-                                                    expr.span);\n-                    self.parent_def = Some(async_def);\n+                let closure_def = self.create_def(expr.id, DefPathData::ClosureExpr, expr.span);\n+                match asyncness {\n+                    IsAsync::Async { closure_id, .. } =>\n+                        self.create_def(closure_id, DefPathData::ClosureExpr, expr.span),\n+                    IsAsync::NotAsync => closure_def,\n                 }\n             }\n-            ExprKind::Async(_, async_id, _) => {\n-                let async_def = self.create_def(async_id,\n-                                                DefPathData::ClosureExpr,\n-                                                expr.span);\n-                self.parent_def = Some(async_def);\n-            }\n-            _ => {}\n+            ExprKind::Async(_, async_id, _) =>\n+                self.create_def(async_id, DefPathData::ClosureExpr, expr.span),\n+            _ => self.parent_def,\n         };\n \n-        visit::walk_expr(self, expr);\n-        self.parent_def = parent_def;\n+        self.with_parent(parent_def, |this| visit::walk_expr(this, expr));\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {"}, {"sha": "9188a78e489ef03107e2a8940605161747c683ec", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -100,6 +100,9 @@ pub struct Definitions {\n     expansions_that_defined: FxHashMap<DefIndex, Mark>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n     def_index_to_span: FxHashMap<DefIndex, Span>,\n+    /// When collecting definitions from an AST fragment produced by a macro invocation `Mark`\n+    /// we know what parent node that fragment should be attached to thanks to this table.\n+    invocation_parents: FxHashMap<Mark, DefIndex>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -434,6 +437,7 @@ impl Definitions {\n         assert!(self.def_index_to_node.is_empty());\n         self.def_index_to_node.push(ast::CRATE_NODE_ID);\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n+        self.set_invocation_parent(Mark::root(), root_index);\n \n         // Allocate some other DefIndices that always must exist.\n         GlobalMetaDataKind::allocate_def_indices(self);\n@@ -526,6 +530,15 @@ impl Definitions {\n     pub fn add_parent_module_of_macro_def(&mut self, mark: Mark, module: DefId) {\n         self.parent_modules_of_macro_defs.insert(mark, module);\n     }\n+\n+    pub fn invocation_parent(&self, invoc_id: Mark) -> DefIndex {\n+        self.invocation_parents[&invoc_id]\n+    }\n+\n+    pub fn set_invocation_parent(&mut self, invoc_id: Mark, parent: DefIndex) {\n+        let old_parent = self.invocation_parents.insert(invoc_id, parent);\n+        assert!(old_parent.is_none(), \"parent def-index is reset for an invocation\");\n+    }\n }\n \n impl DefPathData {"}, {"sha": "43b1dbb6216d7498b5c7f11c4df8afbbe3defa60", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,5 +1,5 @@\n use self::collector::NodeCollector;\n-pub use self::def_collector::{DefCollector, MacroInvocationData};\n+pub use self::def_collector::DefCollector;\n pub use self::definitions::{\n     Definitions, DefKey, DefPath, DefPathData, DisambiguatedDefPathData, DefPathHash\n };"}, {"sha": "e0e7988a744c634e679b6f26a0e9180ffe60057a", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -89,7 +89,6 @@ impl_stable_hash_for!(enum ::syntax::ext::base::MacroKind {\n     Bang,\n     Attr,\n     Derive,\n-    ProcMacroStub,\n });\n \n \n@@ -399,7 +398,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::Transparency {\n \n impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n     call_site,\n-    format,\n+    kind,\n     def_site,\n     default_transparency,\n     allow_internal_unstable,\n@@ -408,13 +407,13 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n     edition\n });\n \n-impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n-    MacroAttribute(sym),\n-    MacroBang(sym),\n-    CompilerDesugaring(kind)\n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnKind {\n+    Root,\n+    Macro(kind, descr),\n+    Desugaring(kind)\n });\n \n-impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::DesugaringKind {\n     CondTemporary,\n     Async,\n     Await,"}, {"sha": "770d5155777bb5045050aac6142740839c46a482", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -5,7 +5,7 @@ use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::ty::{self, Ty, Infer, TyVar};\n use crate::ty::print::Print;\n-use syntax::source_map::CompilerDesugaringKind;\n+use syntax::source_map::DesugaringKind;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n@@ -194,12 +194,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ));\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n             if let Some(simple_ident) = pattern.simple_ident() {\n-                match pattern.span.compiler_desugaring_kind() {\n+                match pattern.span.desugaring_kind() {\n                     None => labels.push((\n                         pattern.span,\n                         format!(\"consider giving `{}` {}\", simple_ident, suffix),\n                     )),\n-                    Some(CompilerDesugaringKind::ForLoop) => labels.push((\n+                    Some(DesugaringKind::ForLoop) => labels.push((\n                         pattern.span,\n                         \"the element type for this iterator is not specified\".to_owned(),\n                     )),"}, {"sha": "0b514f5927d30ad9980ad0f7e3a4e9d1a21a79fc", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -247,10 +247,10 @@ impl EarlyLintPass for LintPassImpl {\n }\n \n fn is_lint_pass_expansion(expn_info: &ExpnInfo) -> bool {\n-    if expn_info.format.name() == sym::impl_lint_pass {\n+    if expn_info.kind.descr() == sym::impl_lint_pass {\n         true\n     } else if let Some(info) = expn_info.call_site.ctxt().outer_expn_info() {\n-        info.format.name() == sym::declare_lint_pass\n+        info.kind.descr() == sym::declare_lint_pass\n     } else {\n         false\n     }"}, {"sha": "e76c24932008d12c37c8b6ee3ecb8befbf0e760d", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -35,9 +35,10 @@ use crate::util::nodemap::NodeMap;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use std::{hash, ptr};\n use syntax::ast;\n-use syntax::source_map::{MultiSpan, ExpnFormat, CompilerDesugaringKind};\n+use syntax::source_map::{MultiSpan, ExpnKind, DesugaringKind};\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n use syntax::edition::Edition;\n+use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n \n@@ -883,36 +884,30 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n         None => return false,\n     };\n \n-    match info.format {\n-        ExpnFormat::MacroAttribute(..) => true, // definitely a plugin\n-        ExpnFormat::CompilerDesugaring(CompilerDesugaringKind::ForLoop) => false,\n-        ExpnFormat::CompilerDesugaring(_) => true, // well, it's \"external\"\n-        ExpnFormat::MacroBang(..) => {\n-            let def_site = match info.def_site {\n-                Some(span) => span,\n-                // no span for the def_site means it's an external macro\n-                None => return true,\n-            };\n-\n-            match sess.source_map().span_to_snippet(def_site) {\n+    match info.kind {\n+        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n+        ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n+        ExpnKind::Macro(MacroKind::Bang, _) => {\n+            if info.def_site.is_dummy() {\n+                // dummy span for the def_site means it's an external macro\n+                return true;\n+            }\n+            match sess.source_map().span_to_snippet(info.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n                 // no snippet = external macro or compiler-builtin expansion\n                 Err(_) => true,\n             }\n         }\n+        ExpnKind::Macro(..) => true, // definitely a plugin\n     }\n }\n \n /// Returns whether `span` originates in a derive macro's expansion\n pub fn in_derive_expansion(span: Span) -> bool {\n-    let info = match span.ctxt().outer_expn_info() {\n-        Some(info) => info,\n-        // no ExpnInfo means this span doesn't come from a macro\n-        None => return false,\n-    };\n-\n-    match info.format {\n-        ExpnFormat::MacroAttribute(symbol) => symbol.as_str().starts_with(\"derive(\"),\n-        _ => false,\n+    if let Some(info) = span.ctxt().outer_expn_info() {\n+        if let ExpnKind::Macro(MacroKind::Derive, _) = info.kind {\n+            return true;\n+        }\n     }\n+    false\n }"}, {"sha": "ff868bf2a2ad2437fbef13967c35822f76e12fe3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -928,7 +928,7 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// `__next` from a `for` loop.\n     #[inline]\n     pub fn from_compiler_desugaring(&self) -> bool {\n-        self.source_info.span.compiler_desugaring_kind().is_some()\n+        self.source_info.span.desugaring_kind().is_some()\n     }\n \n     /// Creates a new `LocalDecl` for a temporary."}, {"sha": "352d318ba7931ab5940670e70f9d0974a217c202", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -36,7 +36,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnFormat};\n+use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnKind};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n@@ -61,12 +61,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // We want to ignore desugarings here: spans are equivalent even\n             // if one is the result of a desugaring and the other is not.\n             let mut span = error.obligation.cause.span;\n-            if let Some(ExpnInfo {\n-                format: ExpnFormat::CompilerDesugaring(_),\n-                def_site: Some(def_span),\n-                ..\n-            }) = span.ctxt().outer_expn_info() {\n-                span = def_span;\n+            if let Some(ExpnInfo { kind: ExpnKind::Desugaring(_), def_site, .. })\n+                    = span.ctxt().outer_expn_info() {\n+                span = def_site;\n             }\n \n             error_map.entry(span).or_default().push(\n@@ -373,9 +370,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             flags.push((sym::parent_trait, Some(t)));\n         }\n \n-        if let Some(k) = obligation.cause.span.compiler_desugaring_kind() {\n+        if let Some(k) = obligation.cause.span.desugaring_kind() {\n             flags.push((sym::from_desugaring, None));\n-            flags.push((sym::from_desugaring, Some(k.name().to_string())));\n+            flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n         }\n         let generics = self.tcx.generics_of(def_id);\n         let self_ty = trait_ref.self_ty();"}, {"sha": "a508d9846bce3c059c74863c15b827f2c5904a1b", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -588,41 +588,41 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n \n         let expn_info_tag = u8::decode(self)?;\n \n-        let ctxt = match expn_info_tag {\n+        // FIXME(mw): This method does not restore `MarkData::parent` or\n+        // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n+        // don't seem to be used after HIR lowering, so everything should be fine\n+        // as long as incremental compilation does not kick in before that.\n+        let location = || Span::new(lo, hi, SyntaxContext::empty());\n+        let recover_from_expn_info = |this: &Self, expn_info, pos| {\n+            let span = location().fresh_expansion(Mark::root(), expn_info);\n+            this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n+            span\n+        };\n+        Ok(match expn_info_tag {\n             TAG_NO_EXPANSION_INFO => {\n-                SyntaxContext::empty()\n+                location()\n             }\n             TAG_EXPANSION_INFO_INLINE => {\n-                let pos = AbsoluteBytePos::new(self.opaque.position());\n-                let expn_info: ExpnInfo = Decodable::decode(self)?;\n-                let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                self.synthetic_expansion_infos.borrow_mut().insert(pos, ctxt);\n-                ctxt\n+                let expn_info = Decodable::decode(self)?;\n+                recover_from_expn_info(\n+                    self, expn_info, AbsoluteBytePos::new(self.opaque.position())\n+                )\n             }\n             TAG_EXPANSION_INFO_SHORTHAND => {\n                 let pos = AbsoluteBytePos::decode(self)?;\n-                let cached_ctxt = self.synthetic_expansion_infos\n-                                      .borrow()\n-                                      .get(&pos)\n-                                      .cloned();\n-\n+                let cached_ctxt = self.synthetic_expansion_infos.borrow().get(&pos).cloned();\n                 if let Some(ctxt) = cached_ctxt {\n-                    ctxt\n+                    Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_info = self.with_position(pos.to_usize(), |this| {\n-                         ExpnInfo::decode(this)\n-                    })?;\n-                    let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                    self.synthetic_expansion_infos.borrow_mut().insert(pos, ctxt);\n-                    ctxt\n+                    let expn_info =\n+                        self.with_position(pos.to_usize(), |this| ExpnInfo::decode(this))?;\n+                    recover_from_expn_info(self, expn_info, pos)\n                 }\n             }\n             _ => {\n                 unreachable!()\n             }\n-        };\n-\n-        Ok(Span::new(lo, hi, ctxt))\n+        })\n     }\n }\n "}, {"sha": "9803ee99f1a47714f4412fb70ded9142bd574b12", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -8,13 +8,13 @@ use syntax::{\n     },\n     attr,\n     source_map::{\n-        respan, ExpnInfo, MacroAttribute,\n+        respan, ExpnInfo, ExpnKind,\n     },\n     ext::{\n-        base::{ExtCtxt, Resolver},\n+        base::{ExtCtxt, MacroKind, Resolver},\n         build::AstBuilder,\n         expand::ExpansionConfig,\n-        hygiene::{Mark, SyntaxContext},\n+        hygiene::Mark,\n     },\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n@@ -84,15 +84,12 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n         }\n         self.found = true;\n \n-        // Create a fresh Mark for the new macro expansion we are about to do\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo::with_unstable(\n-            MacroAttribute(sym::global_allocator), item.span, self.sess.edition, &[sym::rustc_attrs]\n+        // Create a new expansion for the generated allocator code.\n+        let span = item.span.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+            ExpnKind::Macro(MacroKind::Attr, sym::global_allocator), item.span, self.sess.edition,\n+            [sym::rustc_attrs][..].into(),\n         ));\n \n-        // Tie the span to the macro expansion info we just created\n-        let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n-\n         // Create an expansion config\n         let ecfg = ExpansionConfig::default(self.crate_name.take().unwrap());\n "}, {"sha": "9a581cb03ecd030aa330f9445f3656a4b6efaa54", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -33,7 +33,7 @@ use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n-use syntax::source_map::CompilerDesugaringKind;\n+use syntax::source_map::DesugaringKind;\n use syntax_pos::{MultiSpan, Span};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n@@ -734,8 +734,8 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 },\n                 moved_lp.ty));\n         }\n-        if let (Some(CompilerDesugaringKind::ForLoop), Ok(snippet)) = (\n-            move_span.compiler_desugaring_kind(),\n+        if let (Some(DesugaringKind::ForLoop), Ok(snippet)) = (\n+            move_span.desugaring_kind(),\n             self.tcx.sess.source_map().span_to_snippet(move_span),\n          ) {\n             if !snippet.starts_with(\"&\") {"}, {"sha": "361b5cd9357125731da3fa9c75b42713ad511054", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -723,39 +723,37 @@ impl EmitterWriter {\n                 for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n                     // Only show macro locations that are local\n                     // and display them like a span_note\n-                    if let Some(def_site) = trace.def_site_span {\n-                        if def_site.is_dummy() {\n-                            continue;\n-                        }\n-                        if always_backtrace {\n-                            new_labels.push((def_site,\n-                                             format!(\"in this expansion of `{}`{}\",\n-                                                     trace.macro_decl_name,\n-                                                     if backtrace_len > 2 {\n-                                                         // if backtrace_len == 1 it'll be pointed\n-                                                         // at by \"in this macro invocation\"\n-                                                         format!(\" (#{})\", i + 1)\n-                                                     } else {\n-                                                         String::new()\n-                                                     })));\n-                        }\n-                        // Check to make sure we're not in any <*macros>\n-                        if !sm.span_to_filename(def_site).is_macros() &&\n-                           !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                           !trace.macro_decl_name.starts_with(\"#[\") ||\n-                           always_backtrace {\n-                            new_labels.push((trace.call_site,\n-                                             format!(\"in this macro invocation{}\",\n-                                                     if backtrace_len > 2 && always_backtrace {\n-                                                         // only specify order when the macro\n-                                                         // backtrace is multiple levels deep\n-                                                         format!(\" (#{})\", i + 1)\n-                                                     } else {\n-                                                         String::new()\n-                                                     })));\n-                            if !always_backtrace {\n-                                break;\n-                            }\n+                    if trace.def_site_span.is_dummy() {\n+                        continue;\n+                    }\n+                    if always_backtrace {\n+                        new_labels.push((trace.def_site_span,\n+                                            format!(\"in this expansion of `{}`{}\",\n+                                                    trace.macro_decl_name,\n+                                                    if backtrace_len > 2 {\n+                                                        // if backtrace_len == 1 it'll be pointed\n+                                                        // at by \"in this macro invocation\"\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                    }\n+                    // Check to make sure we're not in any <*macros>\n+                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n+                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n+                        !trace.macro_decl_name.starts_with(\"#[\") ||\n+                        always_backtrace {\n+                        new_labels.push((trace.call_site,\n+                                            format!(\"in this macro invocation{}\",\n+                                                    if backtrace_len > 2 && always_backtrace {\n+                                                        // only specify order when the macro\n+                                                        // backtrace is multiple levels deep\n+                                                        format!(\" (#{})\", i + 1)\n+                                                    } else {\n+                                                        String::new()\n+                                                    })));\n+                        if !always_backtrace {\n+                            break;\n                         }\n                     }\n                 }"}, {"sha": "7b5fce4abbc4bf6a7d77f29763682dd018e062aa", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n-use syntax::source_map::CompilerDesugaringKind;\n+use syntax::source_map::DesugaringKind;\n \n use super::nll::explain_borrow::BorrowExplanation;\n use super::nll::region_infer::{RegionName, RegionNameSource};\n@@ -174,7 +174,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         format!(\"variable moved due to use{}\", move_spans.describe()),\n                     );\n                 }\n-                if Some(CompilerDesugaringKind::ForLoop) == move_span.compiler_desugaring_kind() {\n+                if Some(DesugaringKind::ForLoop) == move_span.desugaring_kind() {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         err.span_suggestion(\n                             move_span,"}, {"sha": "31a9766af303adc840e7d3a6c01f533339865448", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -335,7 +335,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             }\n \n             let span = local_decl.source_info.span;\n-            if span.compiler_desugaring_kind().is_some() {\n+            if span.desugaring_kind().is_some() {\n                 // If the `mut` arises as part of a desugaring, we should ignore it.\n                 continue;\n             }"}, {"sha": "16fd8cccc8920dc12822f03f464280a84c63dc9b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -9,7 +9,7 @@ use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleIm\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use crate::{resolve_error, resolve_struct_error, ResolutionError};\n+use crate::{resolve_error, resolve_struct_error, ResolutionError, Determinacy};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n@@ -29,8 +29,7 @@ use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n-use syntax::ext::base::Determinacy::Undetermined;\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::is_builtin_attr;\n@@ -231,9 +230,9 @@ impl<'a> Resolver<'a> {\n                     source: source.ident,\n                     target: ident,\n                     source_bindings: PerNS {\n-                        type_ns: Cell::new(Err(Undetermined)),\n-                        value_ns: Cell::new(Err(Undetermined)),\n-                        macro_ns: Cell::new(Err(Undetermined)),\n+                        type_ns: Cell::new(Err(Determinacy::Undetermined)),\n+                        value_ns: Cell::new(Err(Determinacy::Undetermined)),\n+                        macro_ns: Cell::new(Err(Determinacy::Undetermined)),\n                     },\n                     target_bindings: PerNS {\n                         type_ns: Cell::new(None),\n@@ -456,23 +455,7 @@ impl<'a> Resolver<'a> {\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                if attr::contains_name(&item.attrs, sym::proc_macro) ||\n-                   attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n-                    let res = Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), res.def_id());\n-                    self.define(parent, ident, MacroNS, (res, vis, sp, expansion));\n-                }\n-                if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n-                    if let Some(trait_attr) =\n-                            attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n-                        if let Some(ident) = trait_attr.ident() {\n-                            let res = Res::Def(\n-                                DefKind::Macro(MacroKind::ProcMacroStub),\n-                                res.def_id(),\n-                            );\n-                            self.define(parent, ident, MacroNS, (res, vis, ident.span, expansion));\n-                        }\n-                    }\n-                }\n+                self.define_macro(item, expansion, &mut LegacyScope::Empty);\n             }\n \n             // These items live in the type namespace.\n@@ -772,14 +755,8 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n-        self.opt_get_macro(res).expect(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\")\n-    }\n-\n-    crate fn opt_get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n+    pub fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         let def_id = match res {\n-            Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) =>\n-                return Some(self.non_macro_attr(true)), // some dummy extension\n             Res::Def(DefKind::Macro(..), def_id) => def_id,\n             Res::NonMacroAttr(attr_kind) =>\n                 return Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n@@ -946,12 +923,19 @@ pub struct BuildReducedGraphVisitor<'a, 'b> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n-        let mark = id.placeholder_to_mark();\n-        self.resolver.current_module.unresolved_invocations.borrow_mut().insert(mark);\n-        let invocation = self.resolver.invocations[&mark];\n-        invocation.module.set(self.resolver.current_module);\n-        invocation.parent_legacy_scope.set(self.current_legacy_scope);\n-        invocation\n+        let invoc_id = id.placeholder_to_mark();\n+\n+        self.resolver.current_module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+\n+        let invocation_data = self.resolver.arenas.alloc_invocation_data(InvocationData {\n+            module: self.resolver.current_module,\n+            parent_legacy_scope: self.current_legacy_scope,\n+            output_legacy_scope: Cell::new(None),\n+        });\n+        let old_invocation_data = self.resolver.invocations.insert(invoc_id, invocation_data);\n+        assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n+\n+        invocation_data\n     }\n }\n "}, {"sha": "1216a083700d93839a68bb439aa5ddd7cb8f01cd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -15,11 +15,12 @@\n \n pub use rustc::hir::def::{Namespace, PerNS};\n \n+use Determinacy::*;\n use GenericParameters::*;\n use RibKind::*;\n use smallvec::smallvec;\n \n-use rustc::hir::map::{Definitions, DefCollector};\n+use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n@@ -40,8 +41,7 @@ use rustc_metadata::cstore::CStore;\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n-use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -93,6 +93,18 @@ enum Weak {\n     No,\n }\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum Determinacy {\n+    Determined,\n+    Undetermined,\n+}\n+\n+impl Determinacy {\n+    fn determined(determined: bool) -> Determinacy {\n+        if determined { Determinacy::Determined } else { Determinacy::Undetermined }\n+    }\n+}\n+\n enum ScopeSet {\n     Import(Namespace),\n     AbsolutePath(Namespace),\n@@ -1663,10 +1675,13 @@ pub struct Resolver<'a> {\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n+    dummy_ext_bang: Lrc<SyntaxExtension>,\n+    dummy_ext_derive: Lrc<SyntaxExtension>,\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n+    proc_macro_stubs: NodeSet,\n \n     /// Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n@@ -1901,8 +1916,7 @@ impl<'a> Resolver<'a> {\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n \n         let mut definitions = Definitions::default();\n-        DefCollector::new(&mut definitions, Mark::root())\n-            .collect_root(crate_name, session.local_crate_disambiguator());\n+        definitions.create_root_def(crate_name, session.local_crate_disambiguator());\n \n         let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> =\n             session.opts.externs.iter().map(|kv| (Ident::from_str(kv.0), Default::default()))\n@@ -1926,9 +1940,8 @@ impl<'a> Resolver<'a> {\n         macro_defs.insert(Mark::root(), root_def_id);\n \n         let features = session.features_untracked();\n-        let non_macro_attr = |mark_used| Lrc::new(SyntaxExtension::default(\n-            SyntaxExtensionKind::NonMacroAttr { mark_used }, session.edition()\n-        ));\n+        let non_macro_attr =\n+            |mark_used| Lrc::new(SyntaxExtension::non_macro_attr(mark_used, session.edition()));\n \n         Resolver {\n             session,\n@@ -2003,6 +2016,8 @@ impl<'a> Resolver<'a> {\n             macro_use_prelude: FxHashMap::default(),\n             all_macros: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n+            dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n+            dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocations,\n             macro_defs,\n@@ -2011,6 +2026,7 @@ impl<'a> Resolver<'a> {\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: Default::default(),\n             unused_macros: Default::default(),\n+            proc_macro_stubs: Default::default(),\n             current_type_ascription: Vec::new(),\n             injected_crate: None,\n             active_features:\n@@ -2028,6 +2044,14 @@ impl<'a> Resolver<'a> {\n         self.non_macro_attrs[mark_used as usize].clone()\n     }\n \n+    fn dummy_ext(&self, macro_kind: MacroKind) -> Lrc<SyntaxExtension> {\n+        match macro_kind {\n+            MacroKind::Bang => self.dummy_ext_bang.clone(),\n+            MacroKind::Derive => self.dummy_ext_derive.clone(),\n+            MacroKind::Attr => self.non_macro_attr(true),\n+        }\n+    }\n+\n     /// Runs the function on each namespace.\n     fn per_ns<F: FnMut(&mut Self, Namespace)>(&mut self, mut f: F) {\n         f(self, TypeNS);\n@@ -2223,6 +2247,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         if !module.no_implicit_prelude {\n+            ident.span.adjust(Mark::root());\n             if ns == TypeNS {\n                 if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     return Some(LexicalScopeBinding::Item(binding));"}, {"sha": "fc1becfe309603045710389c58f79377cf783db3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 172, "deletions": 176, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,4 +1,4 @@\n-use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n+use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n use crate::{Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n use crate::{is_known_tool, resolve_error};\n@@ -8,16 +8,16 @@ use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n-use rustc::hir::map::{self, DefCollector};\n+use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, Ident, ItemKind};\n use syntax::attr::{self, StabilityLevel};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Determinacy};\n+use syntax::ext::base::{self, Indeterminate};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, Mark};\n+use syntax::ext::hygiene::{self, Mark, ExpnInfo, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{feature_err, emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::{AttributeGate, GateIssue, Stability, BUILTIN_ATTRIBUTES};\n@@ -32,14 +32,14 @@ use rustc_data_structures::sync::Lrc;\n \n type Res = def::Res<ast::NodeId>;\n \n+// FIXME: Merge this with `ParentScope`.\n #[derive(Clone, Debug)]\n pub struct InvocationData<'a> {\n-    def_index: DefIndex,\n     /// The module in which the macro was invoked.\n-    crate module: Cell<Module<'a>>,\n+    crate module: Module<'a>,\n     /// The legacy scope in which the macro was invoked.\n     /// The invocation path is resolved in this scope.\n-    crate parent_legacy_scope: Cell<LegacyScope<'a>>,\n+    crate parent_legacy_scope: LegacyScope<'a>,\n     /// The legacy scope *produced* by expanding this macro invocation,\n     /// includes all the macro_rules items, other invocations, etc generated by it.\n     /// `None` if the macro is not expanded yet.\n@@ -49,10 +49,9 @@ pub struct InvocationData<'a> {\n impl<'a> InvocationData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n         InvocationData {\n-            module: Cell::new(graph_root),\n-            def_index: CRATE_DEF_INDEX,\n-            parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-            output_legacy_scope: Cell::new(Some(LegacyScope::Empty)),\n+            module: graph_root,\n+            parent_legacy_scope: LegacyScope::Empty,\n+            output_legacy_scope: Cell::new(None),\n         }\n     }\n }\n@@ -74,9 +73,6 @@ pub struct LegacyBinding<'a> {\n /// can potentially expand into macro definitions.\n #[derive(Copy, Clone, Debug)]\n pub enum LegacyScope<'a> {\n-    /// Created when invocation data is allocated in the arena;\n-    /// must be replaced with a proper scope later.\n-    Uninitialized,\n     /// Empty \"root\" scope at the crate start containing no names.\n     Empty,\n     /// The scope introduced by a `macro_rules!` macro definition.\n@@ -102,30 +98,48 @@ fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKi\n     #[derive(PartialEq)]\n     enum SubNS { Bang, AttrLike }\n     let sub_ns = |kind| match kind {\n-        MacroKind::Bang => Some(SubNS::Bang),\n-        MacroKind::Attr | MacroKind::Derive => Some(SubNS::AttrLike),\n-        MacroKind::ProcMacroStub => None,\n+        MacroKind::Bang => SubNS::Bang,\n+        MacroKind::Attr | MacroKind::Derive => SubNS::AttrLike,\n     };\n-    let requirement = requirement.and_then(|kind| sub_ns(kind));\n-    let candidate = candidate.and_then(|kind| sub_ns(kind));\n+    let candidate = candidate.map(sub_ns);\n+    let requirement = requirement.map(sub_ns);\n     // \"No specific sub-namespace\" means \"matches anything\" for both requirements and candidates.\n     candidate.is_none() || requirement.is_none() || candidate == requirement\n }\n \n // We don't want to format a path using pretty-printing,\n // `format!(\"{}\", path)`, because that tries to insert\n // line-breaks and is slow.\n-fn fast_print_path(path: &ast::Path) -> String {\n-    let mut path_str = String::with_capacity(64);\n-    for (i, segment) in path.segments.iter().enumerate() {\n-        if i != 0 {\n-            path_str.push_str(\"::\");\n+fn fast_print_path(path: &ast::Path) -> Symbol {\n+    if path.segments.len() == 1 {\n+        return path.segments[0].ident.name\n+    } else {\n+        let mut path_str = String::with_capacity(64);\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            if i != 0 {\n+                path_str.push_str(\"::\");\n+            }\n+            if segment.ident.name != kw::PathRoot {\n+                path_str.push_str(&segment.ident.as_str())\n+            }\n         }\n-        if segment.ident.name != kw::PathRoot {\n-            path_str.push_str(&segment.ident.as_str())\n+        Symbol::intern(&path_str)\n+    }\n+}\n+\n+fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n+    if attr::contains_name(&item.attrs, sym::proc_macro) {\n+        return Some((MacroKind::Bang, item.ident, item.span));\n+    } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        return Some((MacroKind::Attr, item.ident, item.span));\n+    } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n+        if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n+            if let Some(ident) = nested_meta.ident() {\n+                return Some((MacroKind::Derive, ident, ident.span));\n+            }\n         }\n     }\n-    path_str\n+    None\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n@@ -134,13 +148,16 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n-        let mark = Mark::fresh(Mark::root());\n+        let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::default(\n+            ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n+        ));\n+        let mark = span.ctxt().outer();\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n+        self.definitions.set_invocation_parent(mark, module.def_id().unwrap().index);\n         self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n-            module: Cell::new(module),\n-            def_index: module.def_id().unwrap().index,\n-            parent_legacy_scope: Cell::new(LegacyScope::Empty),\n-            output_legacy_scope: Cell::new(Some(LegacyScope::Empty)),\n+            module,\n+            parent_legacy_scope: LegacyScope::Empty,\n+            output_legacy_scope: Cell::new(None),\n         }));\n         mark\n     }\n@@ -157,16 +174,20 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]) {\n-        let invocation = self.invocations[&mark];\n-        self.collect_def_ids(mark, invocation, fragment);\n+        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, mark));\n \n-        self.current_module = invocation.module.get();\n+        let invocation = self.invocations[&mark];\n+        self.current_module = invocation.module;\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         self.current_module.unresolved_invocations.borrow_mut().extend(derives);\n+        let parent_def = self.definitions.invocation_parent(mark);\n+        for &derive_invoc_id in derives {\n+            self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n+        }\n         self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n-            current_legacy_scope: invocation.parent_legacy_scope.get(),\n+            current_legacy_scope: invocation.parent_legacy_scope,\n             expansion: mark,\n         };\n         fragment.visit_with(&mut visitor);\n@@ -198,36 +219,23 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n+                                -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n         let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n-            InvocationKind::Attr { attr: None, .. } =>\n-                return Ok(None),\n-            InvocationKind::Attr { attr: Some(ref attr), ref traits, after_derive, .. } =>\n-                (&attr.path, MacroKind::Attr, traits.clone(), after_derive),\n+            InvocationKind::Attr { ref attr, ref derives, after_derive, .. } =>\n+                (&attr.path, MacroKind::Attr, derives.clone(), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n                 (&mac.node.path, MacroKind::Bang, Vec::new(), false),\n             InvocationKind::Derive { ref path, .. } =>\n                 (path, MacroKind::Derive, Vec::new(), false),\n+            InvocationKind::DeriveContainer { .. } =>\n+                return Ok(None),\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        let (res, ext) = match self.resolve_macro_to_res(path, kind, &parent_scope, true, force) {\n-            Ok((res, ext)) => (res, ext),\n-            // Replace unresolved attributes with used inert attributes for better recovery.\n-            Err(Determinacy::Determined) if kind == MacroKind::Attr =>\n-                (Res::Err, self.non_macro_attr(true)),\n-            Err(determinacy) => return Err(determinacy),\n-        };\n+        let (ext, res) = self.smart_resolve_macro_path(path, kind, &parent_scope, true, force)?;\n \n         let span = invoc.span();\n-        let path = fast_print_path(path);\n-        let format = match kind {\n-            MacroKind::Derive => format!(\"derive({})\", path),\n-            _ => path.clone(),\n-        };\n-        invoc.expansion_data.mark.set_expn_info(ext.expn_info(span, &format));\n-\n-        self.check_stability_and_deprecation(&ext, &path, span);\n+        invoc.expansion_data.mark.set_expn_info(ext.expn_info(span, fast_print_path(path)));\n \n         if let Res::Def(_, def_id) = res {\n             if after_derive {\n@@ -243,13 +251,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         Ok(Some(ext))\n     }\n \n-    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n-                          derives_in_scope: Vec<ast::Path>, force: bool)\n-                          -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        Ok(self.resolve_macro_to_res(path, kind, &parent_scope, false, force)?.1)\n-    }\n-\n     fn check_unused_macros(&self) {\n         for (&node_id, &span) in self.unused_macros.iter() {\n             self.session.buffer_lint(\n@@ -267,91 +268,95 @@ impl<'a> Resolver<'a> {\n     fn invoc_parent_scope(&self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n         let invoc = self.invocations[&invoc_id];\n         ParentScope {\n-            module: invoc.module.get().nearest_item_scope(),\n+            module: invoc.module.nearest_item_scope(),\n             expansion: invoc_id.parent(),\n-            legacy: invoc.parent_legacy_scope.get(),\n+            legacy: invoc.parent_legacy_scope,\n             derives,\n         }\n     }\n \n-    fn resolve_macro_to_res(\n+    /// Resolve macro path with error reporting and recovery.\n+    fn smart_resolve_macro_path(\n         &mut self,\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n         trace: bool,\n         force: bool,\n-    ) -> Result<(Res, Lrc<SyntaxExtension>), Determinacy> {\n-        let res = self.resolve_macro_to_res_inner(path, kind, parent_scope, trace, force);\n+    ) -> Result<(Lrc<SyntaxExtension>, Res), Indeterminate> {\n+        let (ext, res) = match self.resolve_macro_path(path, kind, parent_scope, trace, force) {\n+            Ok((Some(ext), res)) => (ext, res),\n+            // Use dummy syntax extensions for unresolved macros for better recovery.\n+            Ok((None, res)) => (self.dummy_ext(kind), res),\n+            Err(Determinacy::Determined) => (self.dummy_ext(kind), Res::Err),\n+            Err(Determinacy::Undetermined) => return Err(Indeterminate),\n+        };\n \n         // Report errors and enforce feature gates for the resolved macro.\n         let features = self.session.features_untracked();\n-        if res != Err(Determinacy::Undetermined) {\n-            // Do not report duplicated errors on every undetermined resolution.\n-            for segment in &path.segments {\n-                if let Some(args) = &segment.args {\n-                    self.session.span_err(args.span(), \"generic arguments in macro path\");\n-                }\n-                if kind == MacroKind::Attr && !features.rustc_attrs &&\n-                   segment.ident.as_str().starts_with(\"rustc\") {\n-                    let msg = \"attributes starting with `rustc` are \\\n-                               reserved for use by the `rustc` compiler\";\n-                    emit_feature_err(\n-                        &self.session.parse_sess,\n-                        sym::rustc_attrs,\n-                        segment.ident.span,\n-                        GateIssue::Language,\n-                        msg,\n-                    );\n-                }\n+        for segment in &path.segments {\n+            if let Some(args) = &segment.args {\n+                self.session.span_err(args.span(), \"generic arguments in macro path\");\n+            }\n+            if kind == MacroKind::Attr && !features.rustc_attrs &&\n+               segment.ident.as_str().starts_with(\"rustc\") {\n+                let msg =\n+                    \"attributes starting with `rustc` are reserved for use by the `rustc` compiler\";\n+                emit_feature_err(\n+                    &self.session.parse_sess,\n+                    sym::rustc_attrs,\n+                    segment.ident.span,\n+                    GateIssue::Language,\n+                    msg,\n+                );\n             }\n         }\n \n-        let res = res?;\n-\n         match res {\n-            Res::Def(DefKind::Macro(macro_kind), def_id) => {\n+            Res::Def(DefKind::Macro(_), def_id) => {\n                 if let Some(node_id) = self.definitions.as_local_node_id(def_id) {\n                     self.unused_macros.remove(&node_id);\n-                }\n-                if macro_kind == MacroKind::ProcMacroStub {\n-                    let msg = \"can't use a procedural macro from the same crate that defines it\";\n-                    self.session.span_err(path.span, msg);\n-                    return Err(Determinacy::Determined);\n+                    if self.proc_macro_stubs.contains(&node_id) {\n+                        self.session.span_err(\n+                            path.span,\n+                            \"can't use a procedural macro from the same crate that defines it\",\n+                        );\n+                    }\n                 }\n             }\n             Res::NonMacroAttr(attr_kind) => {\n-                if kind == MacroKind::Attr {\n-                    if attr_kind == NonMacroAttrKind::Custom {\n-                        assert!(path.segments.len() == 1);\n-                        if !features.custom_attribute {\n-                            let msg = format!(\"The attribute `{}` is currently unknown to the \\\n-                                               compiler and may have meaning added to it in the \\\n-                                               future\", path);\n-                            self.report_unknown_attribute(\n-                                path.span,\n-                                &path.segments[0].ident.as_str(),\n-                                &msg,\n-                                sym::custom_attribute,\n-                            );\n-                        }\n+                if attr_kind == NonMacroAttrKind::Custom {\n+                    assert!(path.segments.len() == 1);\n+                    if !features.custom_attribute {\n+                        let msg = format!(\"The attribute `{}` is currently unknown to the \\\n+                                            compiler and may have meaning added to it in the \\\n+                                            future\", path);\n+                        self.report_unknown_attribute(\n+                            path.span,\n+                            &path.segments[0].ident.as_str(),\n+                            &msg,\n+                            sym::custom_attribute,\n+                        );\n                     }\n-                } else {\n-                    // Not only attributes, but anything in macro namespace can result in\n-                    // `Res::NonMacroAttr` definition (e.g., `inline!()`), so we must report\n-                    // an error for those cases.\n-                    let msg = format!(\"expected a macro, found {}\", res.descr());\n-                    self.session.span_err(path.span, &msg);\n-                    return Err(Determinacy::Determined);\n                 }\n             }\n-            Res::Err => {\n-                return Err(Determinacy::Determined);\n-            }\n+            Res::Err => {}\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n-        }\n+        };\n+\n+        self.check_stability_and_deprecation(&ext, path);\n \n-        Ok((res, self.get_macro(res)))\n+        Ok(if ext.macro_kind() != kind {\n+            let expected = if kind == MacroKind::Attr { \"attribute\" } else  { kind.descr() };\n+            let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path);\n+            self.session.struct_span_err(path.span, &msg)\n+                        .span_label(path.span, format!(\"not {} {}\", kind.article(), expected))\n+                        .emit();\n+            // Use dummy syntax extensions for unexpected macro kinds for better recovery.\n+            (self.dummy_ext(kind), Res::Err)\n+        } else {\n+            (ext, res)\n+        })\n     }\n \n     fn report_unknown_attribute(&self, span: Span, name: &str, msg: &str, feature: Symbol) {\n@@ -408,14 +413,14 @@ impl<'a> Resolver<'a> {\n         err.emit();\n     }\n \n-    pub fn resolve_macro_to_res_inner(\n+    pub fn resolve_macro_path(\n         &mut self,\n         path: &ast::Path,\n         kind: MacroKind,\n         parent_scope: &ParentScope<'a>,\n         trace: bool,\n         force: bool,\n-    ) -> Result<Res, Determinacy> {\n+    ) -> Result<(Option<Lrc<SyntaxExtension>>, Res), Determinacy> {\n         let path_span = path.span;\n         let mut path = Segment::from_path(path);\n \n@@ -427,7 +432,7 @@ impl<'a> Resolver<'a> {\n             path.insert(0, Segment::from_ident(root));\n         }\n \n-        if path.len() > 1 {\n+        let res = if path.len() > 1 {\n             let res = match self.resolve_path(&path, Some(MacroNS), parent_scope,\n                                               false, path_span, CrateLint::No) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n@@ -463,7 +468,9 @@ impl<'a> Resolver<'a> {\n             let res = binding.map(|binding| binding.res());\n             self.prohibit_imported_non_macro_attrs(binding.ok(), res.ok(), path_span);\n             res\n-        }\n+        };\n+\n+        res.map(|res| (self.get_macro(res), res))\n     }\n \n     // Resolve an identifier in lexical scope.\n@@ -592,16 +599,16 @@ impl<'a> Resolver<'a> {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in &parent_scope.derives {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n-                        match self.resolve_macro_to_res(derive, MacroKind::Derive,\n-                                                        &parent_scope, true, force) {\n-                            Ok((_, ext)) => if ext.helper_attrs.contains(&ident.name) {\n+                        match self.resolve_macro_path(derive, MacroKind::Derive,\n+                                                      &parent_scope, true, force) {\n+                            Ok((Some(ext), _)) => if ext.helper_attrs.contains(&ident.name) {\n                                 let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n                                                ty::Visibility::Public, derive.span, Mark::root())\n                                                .to_name_binding(self.arenas);\n                                 result = Ok((binding, Flags::empty()));\n                                 break;\n                             }\n-                            Err(Determinacy::Determined) => {}\n+                            Ok(_) | Err(Determinacy::Determined) => {}\n                             Err(Determinacy::Undetermined) =>\n                                 result = Err(Determinacy::Undetermined),\n                         }\n@@ -837,10 +844,9 @@ impl<'a> Resolver<'a> {\n                         binding.parent_legacy_scope\n                     ),\n                     LegacyScope::Invocation(invoc) => WhereToResolve::MacroRules(\n-                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope.get())\n+                        invoc.output_legacy_scope.get().unwrap_or(invoc.parent_legacy_scope)\n                     ),\n                     LegacyScope::Empty => WhereToResolve::Module(parent_scope.module),\n-                    LegacyScope::Uninitialized => unreachable!(),\n                 }\n                 WhereToResolve::CrateRoot => match ns {\n                     TypeNS => {\n@@ -853,6 +859,7 @@ impl<'a> Resolver<'a> {\n                     match self.hygienic_lexical_parent(module, &mut ident.span) {\n                         Some(parent_module) => WhereToResolve::Module(parent_module),\n                         None => {\n+                            ident.span.adjust(Mark::root());\n                             use_prelude = !module.no_implicit_prelude;\n                             match ns {\n                                 TypeNS => WhereToResolve::ExternPrelude,\n@@ -862,7 +869,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n                 }\n-                WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n+                WhereToResolve::MacroUsePrelude => WhereToResolve::StdLibPrelude,\n                 WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n                 WhereToResolve::BuiltinAttrs => WhereToResolve::LegacyPluginHelpers,\n                 WhereToResolve::LegacyPluginHelpers => break, // nowhere else to search\n@@ -872,7 +879,7 @@ impl<'a> Resolver<'a> {\n                 WhereToResolve::StdLibPrelude => match ns {\n                     TypeNS => WhereToResolve::BuiltinTypes,\n                     ValueNS => break, // nowhere else to search\n-                    MacroNS => unreachable!(),\n+                    MacroNS => WhereToResolve::BuiltinMacros,\n                 }\n                 WhereToResolve::BuiltinTypes => break, // nowhere else to search\n             };\n@@ -999,7 +1006,8 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn check_stability_and_deprecation(&self, ext: &SyntaxExtension, path: &str, span: Span) {\n+    fn check_stability_and_deprecation(&self, ext: &SyntaxExtension, path: &ast::Path) {\n+        let span = path.span;\n         if let Some(stability) = &ext.stability {\n             if let StabilityLevel::Unstable { reason, issue } = stability.level {\n                 let feature = stability.feature;\n@@ -1008,14 +1016,14 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if let Some(depr) = &stability.rustc_depr {\n-                let (message, lint) = stability::rustc_deprecation_message(depr, path);\n+                let (message, lint) = stability::rustc_deprecation_message(depr, &path.to_string());\n                 stability::early_report_deprecation(\n                     self.session, &message, depr.suggestion, lint, span\n                 );\n             }\n         }\n         if let Some(depr) = &ext.deprecation {\n-            let (message, lint) = stability::deprecation_message(depr, path);\n+            let (message, lint) = stability::deprecation_message(depr, &path.to_string());\n             stability::early_report_deprecation(self.session, &message, None, lint, span);\n         }\n     }\n@@ -1092,36 +1100,11 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn collect_def_ids(&mut self,\n-                       mark: Mark,\n-                       invocation: &'a InvocationData<'a>,\n-                       fragment: &AstFragment) {\n-        let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n-        let InvocationData { def_index, .. } = *invocation;\n-\n-        let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n-            invocations.entry(invoc.mark).or_insert_with(|| {\n-                arenas.alloc_invocation_data(InvocationData {\n-                    def_index: invoc.def_index,\n-                    module: Cell::new(graph_root),\n-                    parent_legacy_scope: Cell::new(LegacyScope::Uninitialized),\n-                    output_legacy_scope: Cell::new(None),\n-                })\n-            });\n-        };\n-\n-        let mut def_collector = DefCollector::new(&mut self.definitions, mark);\n-        def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n-        def_collector.with_parent(def_index, |def_collector| {\n-            fragment.visit_with(def_collector)\n-        });\n-    }\n-\n     crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`.\n         if ident.name == sym::cfg || ident.name == sym::cfg_attr || ident.name == sym::derive {\n-            let macro_kind = self.opt_get_macro(res).map(|ext| ext.macro_kind());\n+            let macro_kind = self.get_macro(res).map(|ext| ext.macro_kind());\n             if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n                 self.session.span_err(\n                     ident.span, &format!(\"name `{}` is reserved in attribute namespace\", ident)\n@@ -1134,19 +1117,32 @@ impl<'a> Resolver<'a> {\n                         item: &ast::Item,\n                         expansion: Mark,\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n-        self.local_macro_def_scopes.insert(item.id, self.current_module);\n-        let ident = item.ident;\n+        let (ext, ident, span, is_legacy) = match &item.node {\n+            ItemKind::MacroDef(def) => {\n+                let ext = Lrc::new(macro_rules::compile(\n+                    &self.session.parse_sess,\n+                    &self.session.features_untracked(),\n+                    item,\n+                    self.session.edition(),\n+                ));\n+                (ext, item.ident, item.span, def.legacy)\n+            }\n+            ItemKind::Fn(..) => match proc_macro_stub(item) {\n+                Some((macro_kind, ident, span)) => {\n+                    self.proc_macro_stubs.insert(item.id);\n+                    (self.dummy_ext(macro_kind), ident, span, false)\n+                }\n+                None => return,\n+            }\n+            _ => unreachable!(),\n+        };\n \n         let def_id = self.definitions.local_def_id(item.id);\n-        let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n-                                               &self.session.features_untracked(),\n-                                               item, self.session.edition()));\n-        let macro_kind = ext.macro_kind();\n-        let res = Res::Def(DefKind::Macro(macro_kind), def_id);\n+        let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id);\n         self.macro_map.insert(def_id, ext);\n+        self.local_macro_def_scopes.insert(item.id, self.current_module);\n \n-        let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };\n-        if def.legacy {\n+        if is_legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n             let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n@@ -1155,7 +1151,7 @@ impl<'a> Resolver<'a> {\n             } else {\n                 ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n             };\n-            let binding = (res, vis, item.span, expansion).to_name_binding(self.arenas);\n+            let binding = (res, vis, span, expansion).to_name_binding(self.arenas);\n             self.set_binding_parent_module(binding, self.current_module);\n             let legacy_binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n                 parent_legacy_scope: *current_legacy_scope, binding, ident\n@@ -1165,18 +1161,18 @@ impl<'a> Resolver<'a> {\n             if is_macro_export {\n                 let module = self.graph_root;\n                 self.define(module, ident, MacroNS,\n-                            (res, vis, item.span, expansion, IsMacroExport));\n+                            (res, vis, span, expansion, IsMacroExport));\n             } else {\n                 self.check_reserved_macro_name(ident, res);\n-                self.unused_macros.insert(item.id, item.span);\n+                self.unused_macros.insert(item.id, span);\n             }\n         } else {\n             let module = self.current_module;\n             let vis = self.resolve_visibility(&item.vis);\n             if vis != ty::Visibility::Public {\n-                self.unused_macros.insert(item.id, item.span);\n+                self.unused_macros.insert(item.id, span);\n             }\n-            self.define(module, ident, MacroNS, (res, vis, item.span, expansion));\n+            self.define(module, ident, MacroNS, (res, vis, span, expansion));\n         }\n     }\n }"}, {"sha": "5edfe923e68a2ad2d74d1d0634863cea1ae2357e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,6 +2,7 @@ use ImportDirectiveSubclass::*;\n \n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, Weak};\n+use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use crate::{Resolver, Segment};\n@@ -27,7 +28,6 @@ use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n \n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n-use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;"}, {"sha": "2c8f7a44f5a27d69771b51a33493f56d7b795264", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -37,7 +37,6 @@ use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{arg_to_string, ty_to_string};\n-use syntax::source_map::MacroAttribute;\n use syntax_pos::*;\n \n use json_dumper::JsonDumper;\n@@ -842,10 +841,10 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         let callsite = span.source_callsite();\n         let callsite_span = self.span_from_span(callsite);\n         let callee = span.source_callee()?;\n-        let callee_span = callee.def_site?;\n \n         // Ignore attribute macros, their spans are usually mangled\n-        if let MacroAttribute(_) = callee.format {\n+        if let ExpnKind::Macro(MacroKind::Attr, _) |\n+               ExpnKind::Macro(MacroKind::Derive, _) = callee.kind {\n             return None;\n         }\n \n@@ -856,7 +855,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             .sess\n             .imported_macro_spans\n             .borrow()\n-            .get(&callee_span)\n+            .get(&callee.def_site)\n         {\n             let &(ref mac_name, mac_span) = mac;\n             let mac_span = self.span_from_span(mac_span);\n@@ -867,10 +866,10 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             });\n         }\n \n-        let callee_span = self.span_from_span(callee_span);\n+        let callee_span = self.span_from_span(callee.def_site);\n         Some(MacroRef {\n             span: callsite_span,\n-            qualname: callee.format.name().to_string(), // FIXME: generate the real qualname\n+            qualname: callee.kind.descr().to_string(), // FIXME: generate the real qualname\n             callee_span,\n         })\n     }"}, {"sha": "de42a6a35c89a343d012f41e26fdacfbc9f29fca", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -15,7 +15,7 @@ use syntax::ast;\n use syntax::source_map::Spanned;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n-use syntax_pos::hygiene::CompilerDesugaringKind;\n+use syntax_pos::hygiene::DesugaringKind;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n@@ -184,7 +184,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // In the case of `if`- and `while`-expressions we've already checked\n                             // that `scrutinee: bool`. We know that the pattern is `true`,\n                             // so an error here would be a duplicate and from the wrong POV.\n-                            s.is_compiler_desugaring(CompilerDesugaringKind::CondTemporary)\n+                            s.is_desugaring(DesugaringKind::CondTemporary)\n                         })\n                         .is_some());\n                 }"}, {"sha": "d32ee67f7458811a4f724651e5b7a16c1f1905b0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -119,7 +119,7 @@ use rustc::ty::subst::{UnpackedKind, Subst, InternalSubsts, SubstsRef, UserSelfT\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n-use syntax_pos::hygiene::CompilerDesugaringKind;\n+use syntax_pos::hygiene::DesugaringKind;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n@@ -2165,7 +2165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If span arose from a desugaring of `if` or `while`, then it is the condition itself,\n             // which diverges, that we are about to lint on. This gives suboptimal diagnostics.\n             // Instead, stop here so that the `if`- or `while`-expression's block is linted instead.\n-            !span.is_compiler_desugaring(CompilerDesugaringKind::CondTemporary) {\n+            !span.is_desugaring(DesugaringKind::CondTemporary) {\n             self.diverges.set(Diverges::WarnedAlways);\n \n             debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);"}, {"sha": "72e6614dc06526b64391aaa9ade2349276838716", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -4199,7 +4199,6 @@ pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n             MacroKind::Bang => (i, TypeKind::Macro),\n             MacroKind::Attr => (i, TypeKind::Attr),\n             MacroKind::Derive => (i, TypeKind::Derive),\n-            MacroKind::ProcMacroStub => unreachable!(),\n         },\n         Res::Def(DefKind::TraitAlias, i) => (i, TypeKind::TraitAlias),\n         Res::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),"}, {"sha": "9affc08141d09bd89f51e79df6295e3ad74355e9", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -92,7 +92,6 @@ impl<'a> From<&'a clean::Item> for ItemType {\n                 MacroKind::Bang            => ItemType::Macro,\n                 MacroKind::Attr            => ItemType::ProcAttribute,\n                 MacroKind::Derive          => ItemType::ProcDerive,\n-                MacroKind::ProcMacroStub   => unreachable!(),\n             }\n             clean::StrippedItem(..)        => unreachable!(),\n         }"}, {"sha": "5c6847b414136765a69b208a99a0d9cb66a41cb6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2471,7 +2471,6 @@ impl<'a> fmt::Display for Item<'a> {\n                 MacroKind::Bang => write!(fmt, \"Macro \")?,\n                 MacroKind::Attr => write!(fmt, \"Attribute Macro \")?,\n                 MacroKind::Derive => write!(fmt, \"Derive Macro \")?,\n-                MacroKind::ProcMacroStub => unreachable!(),\n             }\n             clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n             clean::StaticItem(..) | clean::ForeignStaticItem(..) => write!(fmt, \"Static \")?,\n@@ -5092,7 +5091,6 @@ fn item_proc_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item, m\n             }\n             write!(w, \"</pre>\")?;\n         }\n-        _ => {}\n     }\n     document(w, cx, it)\n }"}, {"sha": "c527ed02bc05be9eca32140022b03c8f3ce11078", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -429,15 +429,11 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     cx.enter_resolver(|resolver| {\n-        let parent_scope = resolver.dummy_parent_scope();\n-        if let Ok(res) = resolver.resolve_macro_to_res_inner(&path, MacroKind::Bang,\n-                                                            &parent_scope, false, false) {\n-            if let Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = res {\n-                // skip proc-macro stubs, they'll cause `get_macro` to crash\n-            } else {\n-                if let SyntaxExtensionKind::LegacyBang(..) = resolver.get_macro(res).kind {\n-                    return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-                }\n+        if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n+            &path, MacroKind::Bang, &resolver.dummy_parent_scope(), false, false\n+        ) {\n+            if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n+                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n             }\n         }\n         if let Some(res) = resolver.all_macros.get(&Symbol::intern(path_str)) {"}, {"sha": "009d681ed8353de12c8edbffe6ac12ff5e7679d1", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -406,11 +406,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 // Struct and variant constructors and proc macro stubs always show up alongside\n                 // their definitions, we've already processed them so just discard these.\n-                match path.res {\n-                    Res::Def(DefKind::Ctor(..), _)\n-                    | Res::SelfCtor(..)\n-                    | Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) => return,\n-                    _ => {}\n+                if let Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) = path.res {\n+                    return;\n                 }\n \n                 // If there was a private module in the current path then don't bother inlining"}, {"sha": "0cecdd7ffa0b78624b20e486758876121edf0f15", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -175,6 +175,7 @@ impl FileDesc {\n                   target_os = \"emscripten\",\n                   target_os = \"fuchsia\",\n                   target_os = \"l4re\",\n+                  target_os = \"linux\",\n                   target_os = \"haiku\")))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n@@ -187,6 +188,7 @@ impl FileDesc {\n               target_os = \"emscripten\",\n               target_os = \"fuchsia\",\n               target_os = \"l4re\",\n+              target_os = \"linux\",\n               target_os = \"haiku\"))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {"}, {"sha": "37d5885db60c3c3d81b649b72df15261c6902cc1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 30, "deletions": 60, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -10,12 +10,12 @@ use crate::parse::token;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n use crate::{ThinVec, MACRO_ARGUMENTS};\n-use crate::tokenstream::{self, TokenStream};\n+use crate::tokenstream::{self, TokenStream, TokenTree};\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnInfo, ExpnFormat};\n+use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -24,6 +24,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::default::Default;\n \n+pub use syntax_pos::hygiene::MacroKind;\n \n #[derive(Debug,Clone)]\n pub enum Annotatable {\n@@ -218,7 +219,6 @@ pub trait TTMacroExpander {\n         ecx: &'cx mut ExtCtxt<'_>,\n         span: Span,\n         input: TokenStream,\n-        def_span: Option<Span>,\n     ) -> Box<dyn MacResult+'cx>;\n }\n \n@@ -235,7 +235,6 @@ impl<F> TTMacroExpander for F\n         ecx: &'cx mut ExtCtxt<'_>,\n         span: Span,\n         input: TokenStream,\n-        _def_span: Option<Span>,\n     ) -> Box<dyn MacResult+'cx> {\n         struct AvoidInterpolatedIdents;\n \n@@ -518,37 +517,6 @@ impl MacResult for DummyResult {\n     }\n }\n \n-/// Represents different kinds of macro invocations that can be resolved.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum MacroKind {\n-    /// A bang macro - foo!()\n-    Bang,\n-    /// An attribute macro - #[foo]\n-    Attr,\n-    /// A derive attribute macro - #[derive(Foo)]\n-    Derive,\n-    /// A view of a procedural macro from the same crate that defines it.\n-    ProcMacroStub,\n-}\n-\n-impl MacroKind {\n-    pub fn descr(self) -> &'static str {\n-        match self {\n-            MacroKind::Bang => \"macro\",\n-            MacroKind::Attr => \"attribute macro\",\n-            MacroKind::Derive => \"derive macro\",\n-            MacroKind::ProcMacroStub => \"crate-local procedural macro\",\n-        }\n-    }\n-\n-    pub fn article(self) -> &'static str {\n-        match self {\n-            MacroKind::Attr => \"an\",\n-            _ => \"a\",\n-        }\n-    }\n-}\n-\n /// A syntax extension kind.\n pub enum SyntaxExtensionKind {\n     /// A token-based function-like macro.\n@@ -672,19 +640,31 @@ impl SyntaxExtension {\n         }\n     }\n \n-    fn expn_format(&self, symbol: Symbol) -> ExpnFormat {\n-        match self.kind {\n-            SyntaxExtensionKind::Bang(..) |\n-            SyntaxExtensionKind::LegacyBang(..) => ExpnFormat::MacroBang(symbol),\n-            _ => ExpnFormat::MacroAttribute(symbol),\n+    pub fn dummy_bang(edition: Edition) -> SyntaxExtension {\n+        fn expander<'cx>(_: &'cx mut ExtCtxt<'_>, span: Span, _: &[TokenTree])\n+                         -> Box<dyn MacResult + 'cx> {\n+            DummyResult::any(span)\n+        }\n+        SyntaxExtension::default(SyntaxExtensionKind::LegacyBang(Box::new(expander)), edition)\n+    }\n+\n+    pub fn dummy_derive(edition: Edition) -> SyntaxExtension {\n+        fn expander(_: &mut ExtCtxt<'_>, _: Span, _: &ast::MetaItem, _: Annotatable)\n+                    -> Vec<Annotatable> {\n+            Vec::new()\n         }\n+        SyntaxExtension::default(SyntaxExtensionKind::Derive(Box::new(expander)), edition)\n+    }\n+\n+    pub fn non_macro_attr(mark_used: bool, edition: Edition) -> SyntaxExtension {\n+        SyntaxExtension::default(SyntaxExtensionKind::NonMacroAttr { mark_used }, edition)\n     }\n \n-    pub fn expn_info(&self, call_site: Span, format: &str) -> ExpnInfo {\n+    pub fn expn_info(&self, call_site: Span, descr: Symbol) -> ExpnInfo {\n         ExpnInfo {\n             call_site,\n-            format: self.expn_format(Symbol::intern(format)),\n-            def_site: Some(self.span),\n+            kind: ExpnKind::Macro(self.macro_kind(), descr),\n+            def_site: self.span,\n             default_transparency: self.default_transparency,\n             allow_internal_unstable: self.allow_internal_unstable.clone(),\n             allow_internal_unsafe: self.allow_internal_unsafe,\n@@ -696,6 +676,9 @@ impl SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n+/// Error type that denotes indeterminacy.\n+pub struct Indeterminate;\n+\n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n \n@@ -709,26 +692,11 @@ pub trait Resolver {\n     fn resolve_imports(&mut self);\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n-    fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n-                          derives_in_scope: Vec<ast::Path>, force: bool)\n-                          -> Result<Lrc<SyntaxExtension>, Determinacy>;\n+                                -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n \n     fn check_unused_macros(&self);\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum Determinacy {\n-    Determined,\n-    Undetermined,\n-}\n-\n-impl Determinacy {\n-    pub fn determined(determined: bool) -> Determinacy {\n-        if determined { Determinacy::Determined } else { Determinacy::Undetermined }\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct ModuleData {\n     pub mod_path: Vec<ast::Ident>,\n@@ -753,6 +721,7 @@ pub struct ExtCtxt<'a> {\n     pub resolver: &'a mut dyn Resolver,\n     pub current_expansion: ExpansionData,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n+    pub allow_derive_markers: Lrc<[Symbol]>,\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -772,6 +741,7 @@ impl<'a> ExtCtxt<'a> {\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n             },\n             expansions: FxHashMap::default(),\n+            allow_derive_markers: [sym::rustc_attrs, sym::structural_match][..].into(),\n         }\n     }\n \n@@ -810,7 +780,7 @@ impl<'a> ExtCtxt<'a> {\n         let mut last_macro = None;\n         loop {\n             if ctxt.outer_expn_info().map_or(None, |info| {\n-                if info.format.name() == sym::include {\n+                if info.kind.descr() == sym::include {\n                     // Stop going up the backtrace once include! is encountered\n                     return None;\n                 }"}, {"sha": "1c15deab37377fb5391adbcfcd5d1ebcfa486463", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,14 +1,13 @@\n use crate::attr::HasAttrs;\n use crate::ast;\n-use crate::source_map::{ExpnInfo, ExpnFormat};\n-use crate::ext::base::ExtCtxt;\n+use crate::source_map::{ExpnInfo, ExpnKind};\n+use crate::ext::base::{ExtCtxt, MacroKind};\n use crate::ext::build::AstBuilder;\n use crate::parse::parser::PathStyle;\n use crate::symbol::{Symbol, sym};\n use crate::errors::Applicability;\n \n use syntax_pos::Span;\n-\n use rustc_data_structures::fx::FxHashSet;\n \n pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n@@ -46,22 +45,20 @@ pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) ->\n pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T)\n     where T: HasAttrs,\n {\n-    let (mut names, mut pretty_name) = (FxHashSet::default(), \"derive(\".to_owned());\n+    let (mut names, mut pretty_name) = (FxHashSet::default(), String::new());\n     for (i, path) in traits.iter().enumerate() {\n         if i > 0 {\n             pretty_name.push_str(\", \");\n         }\n         pretty_name.push_str(&path.to_string());\n         names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n     }\n-    pretty_name.push(')');\n \n-    cx.current_expansion.mark.set_expn_info(ExpnInfo::with_unstable(\n-        ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)), span, cx.parse_sess.edition,\n-        &[sym::rustc_attrs, sym::structural_match],\n+    let span = span.fresh_expansion(cx.current_expansion.mark, ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n+        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n     ));\n \n-    let span = span.with_ctxt(cx.backtrace());\n     item.visit_attrs(|attrs| {\n         if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n             let meta = cx.meta_word(span, sym::structural_match);"}, {"sha": "7fc62e357c5c4a9b81eb4facfd5d4773c5a62e5b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 172, "deletions": 228, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -5,7 +5,7 @@ use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::derive::{add_derived_markers, collect_derives};\n-use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::ext::hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnKind};\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n use crate::mut_visit::*;\n@@ -158,8 +158,8 @@ ast_fragments! {\n }\n \n impl AstFragmentKind {\n-    fn dummy(self, span: Span) -> Option<AstFragment> {\n-        self.make_from(DummyResult::any(span))\n+    fn dummy(self, span: Span) -> AstFragment {\n+        self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n \n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I)\n@@ -199,25 +199,34 @@ pub enum InvocationKind {\n         span: Span,\n     },\n     Attr {\n-        attr: Option<ast::Attribute>,\n-        traits: Vec<Path>,\n+        attr: ast::Attribute,\n         item: Annotatable,\n+        // Required for resolving derive helper attributes.\n+        derives: Vec<Path>,\n         // We temporarily report errors for attribute macros placed after derives\n         after_derive: bool,\n     },\n     Derive {\n         path: Path,\n         item: Annotatable,\n+        item_with_markers: Annotatable,\n+    },\n+    /// \"Invocation\" that contains all derives from an item,\n+    /// broken into multiple `Derive` invocations when expanded.\n+    /// FIXME: Find a way to remove it.\n+    DeriveContainer {\n+        derives: Vec<Path>,\n+        item: Annotatable,\n     },\n }\n \n impl Invocation {\n     pub fn span(&self) -> Span {\n-        match self.kind {\n-            InvocationKind::Bang { span, .. } => span,\n-            InvocationKind::Attr { attr: Some(ref attr), .. } => attr.span,\n-            InvocationKind::Attr { attr: None, .. } => DUMMY_SP,\n-            InvocationKind::Derive { ref path, .. } => path.span,\n+        match &self.kind {\n+            InvocationKind::Bang { span, .. } => *span,\n+            InvocationKind::Attr { attr, .. } => attr.span,\n+            InvocationKind::Derive { path, .. } => path.span,\n+            InvocationKind::DeriveContainer { item, .. } => item.span(),\n         }\n     }\n }\n@@ -312,9 +321,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n             let ext = match self.cx.resolver.resolve_macro_invocation(&invoc, scope, force) {\n-                Ok(ext) => Some(ext),\n-                Err(Determinacy::Determined) => None,\n-                Err(Determinacy::Undetermined) => {\n+                Ok(ext) => ext,\n+                Err(Indeterminate) => {\n                     undetermined_invocations.push(invoc);\n                     continue\n                 }\n@@ -323,73 +331,62 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             progress = true;\n             let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n-\n             self.cx.current_expansion.mark = scope;\n+\n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n-                if let Some(ext) = ext {\n-                    let (invoc_fragment_kind, invoc_span) = (invoc.fragment_kind, invoc.span());\n-                    let fragment = self.expand_invoc(invoc, &*ext).unwrap_or_else(|| {\n-                        invoc_fragment_kind.dummy(invoc_span).unwrap()\n-                    });\n-                    self.collect_invocations(fragment, &[])\n-                } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n-                    if !item.derive_allowed() {\n-                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n-                            .expect(\"`derive` attribute should exist\");\n-                        let span = attr.span;\n-                        let mut err = self.cx.mut_span_err(span,\n-                                                           \"`derive` may only be applied to \\\n-                                                            structs, enums and unions\");\n-                        if let ast::AttrStyle::Inner = attr.style {\n-                            let trait_list = traits.iter()\n-                                .map(|t| t.to_string()).collect::<Vec<_>>();\n-                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                            err.span_suggestion(\n-                                span, \"try an outer attribute\", suggestion,\n-                                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                                Applicability::MaybeIncorrect\n-                            );\n-                        }\n-                        err.emit();\n+                let fragment = self.expand_invoc(invoc, &ext.kind);\n+                self.collect_invocations(fragment, &[])\n+            } else if let InvocationKind::DeriveContainer { derives: traits, item } = invoc.kind {\n+                if !item.derive_allowed() {\n+                    let attr = attr::find_by_name(item.attrs(), sym::derive)\n+                        .expect(\"`derive` attribute should exist\");\n+                    let span = attr.span;\n+                    let mut err = self.cx.mut_span_err(span,\n+                                                        \"`derive` may only be applied to \\\n+                                                        structs, enums and unions\");\n+                    if let ast::AttrStyle::Inner = attr.style {\n+                        let trait_list = traits.iter()\n+                            .map(|t| t.to_string()).collect::<Vec<_>>();\n+                        let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+                        err.span_suggestion(\n+                            span, \"try an outer attribute\", suggestion,\n+                            // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n+                            Applicability::MaybeIncorrect\n+                        );\n                     }\n+                    err.emit();\n+                }\n \n-                    let mut item = self.fully_configure(item);\n-                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                    let mut item_with_markers = item.clone();\n-                    add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n-                    let derives = derives.entry(invoc.expansion_data.mark).or_default();\n-\n-                    derives.reserve(traits.len());\n-                    invocations.reserve(traits.len());\n-                    for path in &traits {\n-                        let mark = Mark::fresh(self.cx.current_expansion.mark);\n-                        derives.push(mark);\n-                        let item = match self.cx.resolver.resolve_macro_path(\n-                                path, MacroKind::Derive, Mark::root(), Vec::new(), false) {\n-                            Ok(ext) => match ext.kind {\n-                                SyntaxExtensionKind::LegacyDerive(..) => item_with_markers.clone(),\n-                                _ => item.clone(),\n-                            },\n-                            _ => item.clone(),\n-                        };\n-                        invocations.push(Invocation {\n-                            kind: InvocationKind::Derive { path: path.clone(), item },\n-                            fragment_kind: invoc.fragment_kind,\n-                            expansion_data: ExpansionData {\n-                                mark,\n-                                ..invoc.expansion_data.clone()\n-                            },\n-                        });\n-                    }\n-                    let fragment = invoc.fragment_kind\n-                        .expect_from_annotatables(::std::iter::once(item_with_markers));\n-                    self.collect_invocations(fragment, derives)\n-                } else {\n-                    unreachable!()\n+                let mut item = self.fully_configure(item);\n+                item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n+                let mut item_with_markers = item.clone();\n+                add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n+                let derives = derives.entry(invoc.expansion_data.mark).or_default();\n+\n+                derives.reserve(traits.len());\n+                invocations.reserve(traits.len());\n+                for path in traits {\n+                    let mark = Mark::fresh(self.cx.current_expansion.mark, None);\n+                    derives.push(mark);\n+                    invocations.push(Invocation {\n+                        kind: InvocationKind::Derive {\n+                            path,\n+                            item: item.clone(),\n+                            item_with_markers: item_with_markers.clone(),\n+                        },\n+                        fragment_kind: invoc.fragment_kind,\n+                        expansion_data: ExpansionData {\n+                            mark,\n+                            ..invoc.expansion_data.clone()\n+                        },\n+                    });\n                 }\n+                let fragment = invoc.fragment_kind\n+                    .expect_from_annotatables(::std::iter::once(item_with_markers));\n+                self.collect_invocations(fragment, derives)\n             } else {\n-                self.collect_invocations(invoc.fragment_kind.dummy(invoc.span()).unwrap(), &[])\n+                unreachable!()\n             };\n \n             if expanded_fragments.len() < depth {\n@@ -485,28 +482,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<AstFragment> {\n-        if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n-           !self.cx.ecfg.macros_in_extern() {\n-            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext.kind {} else {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtensionKind) -> AstFragment {\n+        let (fragment_kind, span) = (invoc.fragment_kind, invoc.span());\n+        if fragment_kind == AstFragmentKind::ForeignItems && !self.cx.ecfg.macros_in_extern() {\n+            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext {} else {\n                 emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n-                                 invoc.span(), GateIssue::Language,\n+                                 span, GateIssue::Language,\n                                  \"macro invocations in `extern {}` blocks are experimental\");\n             }\n         }\n \n-        let result = match invoc.kind {\n-            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext)?,\n-            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext)?,\n-            InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext)?,\n-        };\n-\n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n             let info = self.cx.current_expansion.mark.expn_info().unwrap();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n             let mut err = self.cx.struct_span_err(info.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                         info.format.name()));\n+                         info.kind.descr()));\n             err.help(&format!(\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                 suggested_limit));\n@@ -515,61 +506,87 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             FatalError.raise();\n         }\n \n-        Some(result)\n-    }\n-\n-    fn expand_attr_invoc(&mut self,\n-                         invoc: Invocation,\n-                         ext: &SyntaxExtension)\n-                         -> Option<AstFragment> {\n-        let (attr, mut item) = match invoc.kind {\n-            InvocationKind::Attr { attr, item, .. } => (attr?, item),\n-            _ => unreachable!(),\n-        };\n-\n-        match &ext.kind {\n-            SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n-                attr::mark_known(&attr);\n-                if *mark_used {\n-                    attr::mark_used(&attr);\n+        match invoc.kind {\n+            InvocationKind::Bang { mac, .. } => match ext {\n+                SyntaxExtensionKind::Bang(expander) => {\n+                    self.gate_proc_macro_expansion_kind(span, fragment_kind);\n+                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                    let result =\n+                        self.parse_ast_fragment(tok_result, fragment_kind, &mac.node.path, span);\n+                    self.gate_proc_macro_expansion(span, &result);\n+                    result\n                 }\n-                item.visit_attrs(|attrs| attrs.push(attr));\n-                Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n-            }\n-            SyntaxExtensionKind::LegacyAttr(expander) => {\n-                let meta = attr.parse_meta(self.cx.parse_sess)\n-                               .map_err(|mut e| { e.emit(); }).ok()?;\n-                let item = expander.expand(self.cx, attr.span, &meta, item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(item))\n-            }\n-            SyntaxExtensionKind::Attr(expander) => {\n-                self.gate_proc_macro_attr_item(attr.span, &item);\n-                let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n-                    Annotatable::Item(item) => token::NtItem(item),\n-                    Annotatable::TraitItem(item) => token::NtTraitItem(item.into_inner()),\n-                    Annotatable::ImplItem(item) => token::NtImplItem(item.into_inner()),\n-                    Annotatable::ForeignItem(item) => token::NtForeignItem(item.into_inner()),\n-                    Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n-                    Annotatable::Expr(expr) => token::NtExpr(expr),\n-                })), DUMMY_SP).into();\n-                let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n-                let tok_result = expander.expand(self.cx, attr.span, input, item_tok);\n-                let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,\n-                                                  &attr.path, attr.span);\n-                self.gate_proc_macro_expansion(attr.span, &res);\n-                res\n+                SyntaxExtensionKind::LegacyBang(expander) => {\n+                    let tok_result = expander.expand(self.cx, span, mac.node.stream());\n+                    if let Some(result) = fragment_kind.make_from(tok_result) {\n+                        result\n+                    } else {\n+                        let msg = format!(\"non-{kind} macro in {kind} position: {path}\",\n+                                          kind = fragment_kind.name(), path = mac.node.path);\n+                        self.cx.span_err(span, &msg);\n+                        self.cx.trace_macros_diag();\n+                        fragment_kind.dummy(span)\n+                    }\n+                }\n+                _ => unreachable!()\n             }\n-            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n-                self.cx.span_err(attr.span, &format!(\"`{}` is a derive macro\", attr.path));\n-                self.cx.trace_macros_diag();\n-                invoc.fragment_kind.dummy(attr.span)\n+            InvocationKind::Attr { attr, mut item, .. } => match ext {\n+                SyntaxExtensionKind::Attr(expander) => {\n+                    self.gate_proc_macro_attr_item(span, &item);\n+                    let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n+                        Annotatable::Item(item) => token::NtItem(item),\n+                        Annotatable::TraitItem(item) => token::NtTraitItem(item.into_inner()),\n+                        Annotatable::ImplItem(item) => token::NtImplItem(item.into_inner()),\n+                        Annotatable::ForeignItem(item) => token::NtForeignItem(item.into_inner()),\n+                        Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n+                        Annotatable::Expr(expr) => token::NtExpr(expr),\n+                    })), DUMMY_SP).into();\n+                    let input = self.extract_proc_macro_attr_input(attr.tokens, span);\n+                    let tok_result = expander.expand(self.cx, span, input, item_tok);\n+                    let res = self.parse_ast_fragment(tok_result, fragment_kind, &attr.path, span);\n+                    self.gate_proc_macro_expansion(span, &res);\n+                    res\n+                }\n+                SyntaxExtensionKind::LegacyAttr(expander) => {\n+                    match attr.parse_meta(self.cx.parse_sess) {\n+                        Ok(meta) => {\n+                            let item = expander.expand(self.cx, span, &meta, item);\n+                            fragment_kind.expect_from_annotatables(item)\n+                        }\n+                        Err(mut err) => {\n+                            err.emit();\n+                            fragment_kind.dummy(span)\n+                        }\n+                    }\n+                }\n+                SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n+                    attr::mark_known(&attr);\n+                    if *mark_used {\n+                        attr::mark_used(&attr);\n+                    }\n+                    item.visit_attrs(|attrs| attrs.push(attr));\n+                    fragment_kind.expect_from_annotatables(iter::once(item))\n+                }\n+                _ => unreachable!()\n             }\n-            _ => {\n-                let msg = &format!(\"macro `{}` may not be used in attributes\", attr.path);\n-                self.cx.span_err(attr.span, msg);\n-                self.cx.trace_macros_diag();\n-                invoc.fragment_kind.dummy(attr.span)\n+            InvocationKind::Derive { path, item, item_with_markers } => match ext {\n+                SyntaxExtensionKind::Derive(expander) |\n+                SyntaxExtensionKind::LegacyDerive(expander) => {\n+                    let (path, item) = match ext {\n+                        SyntaxExtensionKind::LegacyDerive(..) => (path, item_with_markers),\n+                        _ => (path, item),\n+                    };\n+                    if !item.derive_allowed() {\n+                        return fragment_kind.dummy(span);\n+                    }\n+                    let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span, path };\n+                    let span = span.with_ctxt(self.cx.backtrace());\n+                    let items = expander.expand(self.cx, span, &meta, item);\n+                    fragment_kind.expect_from_annotatables(items)\n+                }\n+                _ => unreachable!()\n             }\n+            InvocationKind::DeriveContainer { .. } => unreachable!()\n         }\n     }\n \n@@ -616,14 +633,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    fn gate_proc_macro_expansion(&self, span: Span, fragment: &Option<AstFragment>) {\n+    fn gate_proc_macro_expansion(&self, span: Span, fragment: &AstFragment) {\n         if self.cx.ecfg.proc_macro_hygiene() {\n             return\n         }\n-        let fragment = match fragment {\n-            Some(fragment) => fragment,\n-            None => return,\n-        };\n \n         fragment.visit_with(&mut DisallowMacros {\n             span,\n@@ -655,58 +668,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    /// Expand a macro invocation. Returns the resulting expanded AST fragment.\n-    fn expand_bang_invoc(&mut self,\n-                         invoc: Invocation,\n-                         ext: &SyntaxExtension)\n-                         -> Option<AstFragment> {\n-        let kind = invoc.fragment_kind;\n-        let (mac, span) = match invoc.kind {\n-            InvocationKind::Bang { mac, span } => (mac, span),\n-            _ => unreachable!(),\n-        };\n-        let path = &mac.node.path;\n-\n-        let opt_expanded = match &ext.kind {\n-            SyntaxExtensionKind::Bang(expander) => {\n-                self.gate_proc_macro_expansion_kind(span, kind);\n-                let tok_result = expander.expand(self.cx, span, mac.node.stream());\n-                let result = self.parse_ast_fragment(tok_result, kind, path, span);\n-                self.gate_proc_macro_expansion(span, &result);\n-                result\n-            }\n-            SyntaxExtensionKind::LegacyBang(expander) => {\n-                let tok_result = expander.expand(self.cx, span, mac.node.stream(), Some(ext.span));\n-                kind.make_from(tok_result)\n-            }\n-\n-            SyntaxExtensionKind::Attr(..) |\n-            SyntaxExtensionKind::LegacyAttr(..) |\n-            SyntaxExtensionKind::NonMacroAttr { .. } => {\n-                self.cx.span_err(path.span,\n-                                 &format!(\"`{}` can only be used in attributes\", path));\n-                self.cx.trace_macros_diag();\n-                kind.dummy(span)\n-            }\n-\n-            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n-                self.cx.span_err(path.span, &format!(\"`{}` is a derive macro\", path));\n-                self.cx.trace_macros_diag();\n-                kind.dummy(span)\n-            }\n-        };\n-\n-        if opt_expanded.is_some() {\n-            opt_expanded\n-        } else {\n-            let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                              name = path.segments[0].ident.name, kind = kind.name());\n-            self.cx.span_err(path.span, &msg);\n-            self.cx.trace_macros_diag();\n-            kind.dummy(span)\n-        }\n-    }\n-\n     fn gate_proc_macro_expansion_kind(&self, span: Span, kind: AstFragmentKind) {\n         let kind = match kind {\n             AstFragmentKind::Expr => \"expressions\",\n@@ -731,47 +692,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         );\n     }\n \n-    /// Expand a derive invocation. Returns the resulting expanded AST fragment.\n-    fn expand_derive_invoc(&mut self,\n-                           invoc: Invocation,\n-                           ext: &SyntaxExtension)\n-                           -> Option<AstFragment> {\n-        let (path, item) = match invoc.kind {\n-            InvocationKind::Derive { path, item } => (path, item),\n-            _ => unreachable!(),\n-        };\n-        if !item.derive_allowed() {\n-            return None;\n-        }\n-\n-        match &ext.kind {\n-            SyntaxExtensionKind::Derive(expander) |\n-            SyntaxExtensionKind::LegacyDerive(expander) => {\n-                let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span: path.span, path };\n-                let span = meta.span.with_ctxt(self.cx.backtrace());\n-                let items = expander.expand(self.cx, span, &meta, item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(items))\n-            }\n-            _ => {\n-                let msg = &format!(\"macro `{}` may not be used for derive attributes\", path);\n-                self.cx.span_err(path.span, msg);\n-                self.cx.trace_macros_diag();\n-                invoc.fragment_kind.dummy(path.span)\n-            }\n-        }\n-    }\n-\n     fn parse_ast_fragment(&mut self,\n                           toks: TokenStream,\n                           kind: AstFragmentKind,\n                           path: &Path,\n                           span: Span)\n-                          -> Option<AstFragment> {\n+                          -> AstFragment {\n         let mut parser = self.cx.new_parser_from_tts(&toks.into_trees().collect::<Vec<_>>());\n         match parser.parse_ast_fragment(kind, false) {\n             Ok(fragment) => {\n                 parser.ensure_complete_parse(path, kind.name(), span);\n-                Some(fragment)\n+                fragment\n             }\n             Err(mut err) => {\n                 err.set_span(span);\n@@ -881,7 +812,17 @@ struct InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        let mark = Mark::fresh(self.cx.current_expansion.mark);\n+        // Expansion info for all the collected invocations is set upon their resolution,\n+        // with exception of the derive container case which is not resolved and can get\n+        // its expansion info immediately.\n+        let expn_info = match &kind {\n+            InvocationKind::DeriveContainer { item, .. } => Some(ExpnInfo::default(\n+                ExpnKind::Macro(MacroKind::Attr, sym::derive),\n+                item.span(), self.cx.parse_sess.edition,\n+            )),\n+            _ => None,\n+        };\n+        let mark = Mark::fresh(self.cx.current_expansion.mark, expn_info);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,\n@@ -900,12 +841,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(&mut self,\n                     attr: Option<ast::Attribute>,\n-                    traits: Vec<Path>,\n+                    derives: Vec<Path>,\n                     item: Annotatable,\n                     kind: AstFragmentKind,\n                     after_derive: bool)\n                     -> AstFragment {\n-        self.collect(kind, InvocationKind::Attr { attr, traits, item, after_derive })\n+        self.collect(kind, match attr {\n+            Some(attr) => InvocationKind::Attr { attr, item, derives, after_derive },\n+            None => InvocationKind::DeriveContainer { derives, item },\n+        })\n     }\n \n     fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>, after_derive: &mut bool)"}, {"sha": "5c6438a7ef5343e0e8ff91cbb51ea8b926ffd1cf", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -88,6 +88,7 @@ impl<'a> ParserAnyMacro<'a> {\n \n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n+    span: Span,\n     lhses: Vec<quoted::TokenTree>,\n     rhses: Vec<quoted::TokenTree>,\n     valid: bool,\n@@ -99,12 +100,11 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         cx: &'cx mut ExtCtxt<'_>,\n         sp: Span,\n         input: TokenStream,\n-        def_span: Option<Span>,\n     ) -> Box<dyn MacResult + 'cx> {\n         if !self.valid {\n             return DummyResult::any(sp);\n         }\n-        generic_extension(cx, sp, def_span, self.name, input, &self.lhses, &self.rhses)\n+        generic_extension(cx, sp, self.span, self.name, input, &self.lhses, &self.rhses)\n     }\n }\n \n@@ -117,7 +117,7 @@ fn trace_macros_note(cx: &mut ExtCtxt<'_>, sp: Span, message: String) {\n fn generic_extension<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n-    def_span: Option<Span>,\n+    def_span: Span,\n     name: ast::Ident,\n     arg: TokenStream,\n     lhses: &[quoted::TokenTree],\n@@ -199,10 +199,8 @@ fn generic_extension<'cx>(\n     let span = token.span.substitute_dummy(sp);\n     let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n     err.span_label(span, label);\n-    if let Some(sp) = def_span {\n-        if cx.source_map().span_to_filename(sp).is_real() && !sp.is_dummy() {\n-            err.span_label(cx.source_map().def_span(sp), \"when calling this macro\");\n-        }\n+    if !def_span.is_dummy() && cx.source_map().span_to_filename(def_span).is_real() {\n+        err.span_label(cx.source_map().def_span(def_span), \"when calling this macro\");\n     }\n \n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n@@ -377,7 +375,7 @@ pub fn compile(\n     }\n \n     let expander: Box<_> =\n-        Box::new(MacroRulesMacroExpander { name: def.ident, lhses, rhses, valid });\n+        Box::new(MacroRulesMacroExpander { name: def.ident, span: def.span, lhses, rhses, valid });\n \n     let (default_transparency, transparency_error) =\n         attr::find_transparency(&def.attrs, body.legacy);"}, {"sha": "ec0222d90eb7a2430cc71fdd284b6f0f88806f0e", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -170,7 +170,7 @@ struct DiagnosticSpanMacroExpansion {\n     macro_decl_name: String,\n \n     /// span where macro was defined (if known)\n-    def_site_span: Option<DiagnosticSpan>,\n+    def_site_span: DiagnosticSpan,\n }\n \n #[derive(RustcEncodable)]\n@@ -300,14 +300,13 @@ impl DiagnosticSpan {\n                                      None,\n                                      backtrace,\n                                      je);\n-            let def_site_span = bt.def_site_span.map(|sp| {\n-                Self::from_span_full(sp,\n+            let def_site_span =\n+                Self::from_span_full(bt.def_site_span,\n                                      false,\n                                      None,\n                                      None,\n                                      vec![].into_iter(),\n-                                     je)\n-            });\n+                                     je);\n             Box::new(DiagnosticSpanMacroExpansion {\n                 span: call_site,\n                 macro_decl_name: bt.macro_decl_name,"}, {"sha": "bbf62ef1e2361d3cbb79857832e7971291186c71", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -7,10 +7,8 @@\n //! within the SourceMap, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n \n-\n pub use syntax_pos::*;\n-pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo};\n-pub use ExpnFormat::*;\n+pub use syntax_pos::hygiene::{ExpnKind, ExpnInfo};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;"}, {"sha": "d86b76f71eca7d155ae79f701555c6a091a5fda1", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,26 +1,15 @@\n use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n-use crate::ext::hygiene::{Mark, SyntaxContext};\n+use crate::ext::hygiene::{Mark, MacroKind};\n use crate::symbol::{Ident, Symbol, kw, sym};\n-use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, respan};\n+use crate::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n use crate::ptr::P;\n use crate::tokenstream::TokenStream;\n \n use std::cell::Cell;\n use std::iter;\n-use syntax_pos::{DUMMY_SP, Span};\n-\n-/// Craft a span that will be ignored by the stability lint's\n-/// call to source_map's `is_internal` check.\n-/// The expanded code uses the unstable `#[prelude_import]` attribute.\n-fn ignored_span(sp: Span, edition: Edition) -> Span {\n-    let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo::with_unstable(\n-        MacroAttribute(Symbol::intern(\"std_inject\")), sp, edition, &[sym::prelude_import]\n-    ));\n-    sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n-}\n+use syntax_pos::DUMMY_SP;\n \n pub fn injected_crate_name() -> Option<&'static str> {\n     INJECTED_CRATE_NAME.with(|name| name.get())\n@@ -86,7 +75,11 @@ pub fn maybe_inject_crates_ref(\n \n     INJECTED_CRATE_NAME.with(|opt_name| opt_name.set(Some(name)));\n \n-    let span = ignored_span(DUMMY_SP, edition);\n+    let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n+        [sym::prelude_import][..].into(),\n+    ));\n+\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,"}, {"sha": "799d64a9962371070fc5ba68223ce07ed1714388", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -15,13 +15,13 @@ use smallvec::{smallvec, SmallVec};\n use syntax_pos::{DUMMY_SP, NO_EXPANSION, Span, SourceFile, BytePos};\n \n use crate::attr::{self, HasAttrs};\n-use crate::source_map::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned, respan};\n+use crate::source_map::{self, SourceMap, ExpnInfo, ExpnKind, dummy_spanned, respan};\n use crate::config;\n use crate::entry::{self, EntryPointType};\n use crate::ext::base::{ExtCtxt, Resolver};\n use crate::ext::build::AstBuilder;\n use crate::ext::expand::ExpansionConfig;\n-use crate::ext::hygiene::{self, Mark, SyntaxContext};\n+use crate::ext::hygiene::{self, Mark, SyntaxContext, MacroKind};\n use crate::mut_visit::{*, ExpectOne};\n use crate::feature_gate::Features;\n use crate::util::map_in_place::MapInPlace;\n@@ -43,7 +43,6 @@ struct TestCtxt<'a> {\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     is_libtest: bool,\n-    ctxt: SyntaxContext,\n     features: &'a Features,\n     test_runner: Option<ast::Path>,\n \n@@ -259,8 +258,6 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     cleaner.visit_crate(krate);\n \n-    let mark = Mark::fresh(Mark::root());\n-\n     let mut econfig = ExpansionConfig::default(\"test\".to_string());\n     econfig.features = Some(features);\n \n@@ -274,30 +271,17 @@ fn generate_test_harness(sess: &ParseSess,\n         is_libtest: attr::find_crate_name(&krate.attrs)\n             .map(|s| s == sym::test).unwrap_or(false),\n         toplevel_reexport: None,\n-        ctxt: SyntaxContext::empty().apply_mark(mark),\n         features,\n         test_runner\n     };\n \n-    mark.set_expn_info(ExpnInfo::with_unstable(\n-        MacroAttribute(sym::test_case), DUMMY_SP, sess.edition,\n-        &[sym::main, sym::test, sym::rustc_attrs],\n-    ));\n-\n     TestHarnessGenerator {\n         cx,\n         tests: Vec::new(),\n         tested_submods: Vec::new(),\n     }.visit_crate(krate);\n }\n \n-/// Craft a span that will be ignored by the stability lint's\n-/// call to source_map's `is_internal` check.\n-/// The expanded code calls some unstable functions in the test crate.\n-fn ignored_span(cx: &TestCtxt<'_>, sp: Span) -> Span {\n-    sp.with_ctxt(cx.ctxt)\n-}\n-\n enum HasTestSignature {\n     Yes,\n     No(BadTestSignature),\n@@ -314,12 +298,15 @@ enum BadTestSignature {\n /// Creates a function item for use as the main function of a test build.\n /// This function will call the `test_runner` as specified by the crate attribute\n fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n-    // Writing this out by hand with 'ignored_span':\n+    // Writing this out by hand:\n     //        pub fn main() {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = ignored_span(cx, DUMMY_SP);\n+    let sp = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n+        [sym::main, sym::test, sym::rustc_attrs][..].into(),\n+    ));\n     let ecx = &cx.ext_cx;\n     let test_id = Ident::with_empty_ctxt(sym::test);\n "}, {"sha": "da0f8ca6da0908121f7a213caa8f10e5a04795f8", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -72,6 +72,7 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n+\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n             register(sym::$name, SyntaxExtension::default(\n@@ -125,24 +126,31 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         trace_macros: trace_macros::expand_trace_macros,\n     }\n \n+    let allow_internal_unstable = Some([sym::test, sym::rustc_attrs][..].into());\n     register(sym::test_case, SyntaxExtension {\n         stability: Some(Stability::unstable(\n             sym::custom_test_frameworks,\n             Some(Symbol::intern(EXPLAIN_CUSTOM_TEST_FRAMEWORKS)),\n             50297,\n         )),\n+        allow_internal_unstable: allow_internal_unstable.clone(),\n         ..SyntaxExtension::default(\n             SyntaxExtensionKind::LegacyAttr(Box::new(test_case::expand)), edition\n         )\n     });\n-    register(sym::test, SyntaxExtension::default(\n-        SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_test)), edition\n-    ));\n-    register(sym::bench, SyntaxExtension::default(\n-        SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_bench)), edition\n-    ));\n-\n-    // format_args uses `unstable` things internally.\n+    register(sym::test, SyntaxExtension {\n+        allow_internal_unstable: allow_internal_unstable.clone(),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_test)), edition\n+        )\n+    });\n+    register(sym::bench, SyntaxExtension {\n+        allow_internal_unstable,\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_bench)), edition\n+        )\n+    });\n+\n     let allow_internal_unstable = Some([sym::fmt_internals][..].into());\n     register(sym::format_args, SyntaxExtension {\n         allow_internal_unstable: allow_internal_unstable.clone(),"}, {"sha": "2f78644dff2aa89e2673fcce79f0a3d4e5c069e9", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -4,8 +4,8 @@ use crate::deriving;\n \n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::source_map::{ExpnInfo, MacroAttribute, respan};\n-use syntax::ext::base::ExtCtxt;\n+use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n+use syntax::ext::base::{ExtCtxt, MacroKind};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::ext::hygiene::Mark;\n@@ -346,12 +346,10 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo::with_unstable(\n-        MacroAttribute(sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n-        &[sym::rustc_attrs, Symbol::intern(\"proc_macro_internals\")],\n+    let span = DUMMY_SP.fresh_expansion(Mark::root(), ExpnInfo::allow_unstable(\n+        ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n+        [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n     ));\n-    let span = DUMMY_SP.apply_mark(mark);\n \n     let hidden = cx.meta_list_item_word(span, sym::hidden);\n     let doc = cx.meta_list(span, sym::doc, vec![hidden]);"}, {"sha": "c5c5ef57b3122a67cae7f5c493ee33991a9aa8db", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -3,13 +3,12 @@\n \n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::SyntaxContext;\n use syntax::attr;\n use syntax::ast;\n use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n-use syntax::source_map::{ExpnInfo, MacroAttribute};\n use std::iter;\n \n pub fn expand_test(\n@@ -60,15 +59,8 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let (sp, attr_sp) = {\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo::with_unstable(\n-            MacroAttribute(sym::test), attr_sp, cx.parse_sess.edition,\n-            &[sym::rustc_attrs, sym::test],\n-        ));\n-        (item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark)),\n-         attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n-    };\n+    let ctxt = SyntaxContext::empty().apply_mark(cx.current_expansion.mark);\n+    let (sp, attr_sp) = (item.span.with_ctxt(ctxt), attr_sp.with_ctxt(ctxt));\n \n     // Gensym \"test\" so we can extern crate without conflicting with any local names\n     let test_id = cx.ident_of(\"test\").gensym();"}, {"sha": "af2cf42e04bb9a28814bc386d371a642a98bd17b", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -11,12 +11,11 @@\n \n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::SyntaxContext;\n use syntax::ast;\n use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n-use syntax::source_map::{ExpnInfo, MacroAttribute};\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n@@ -26,17 +25,8 @@ pub fn expand(\n ) -> Vec<Annotatable> {\n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = {\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo::with_unstable(\n-            MacroAttribute(sym::test_case), attr_sp, ecx.parse_sess.edition,\n-            &[sym::test, sym::rustc_attrs],\n-        ));\n-        attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n-    };\n-\n+    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.mark));\n     let mut item = anno_item.expect_item();\n-\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n         item.ident = item.ident.gensym();"}, {"sha": "5df14439230906e338d5e33ebb5481dd92896175", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 120, "deletions": 114, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -26,20 +26,20 @@\n // trigger runtime aborts. (Fortunately these are obvious and easy to fix.)\n \n use crate::GLOBALS;\n-use crate::Span;\n+use crate::{Span, DUMMY_SP};\n use crate::edition::Edition;\n use crate::symbol::{kw, Symbol};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n-#[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Debug)]\n struct SyntaxContextData {\n     outer_mark: Mark,\n     transparency: Transparency,\n@@ -53,12 +53,15 @@ struct SyntaxContextData {\n }\n \n /// A mark is a unique ID associated with a macro expansion.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct Mark(u32);\n \n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n struct MarkData {\n     parent: Mark,\n+    /// Each mark should have an associated expansion info, but sometimes there's a delay between\n+    /// creation of a mark and obtaining its info (e.g. macros are collected first and then\n+    /// resolved later), so we use an `Option` here.\n     expn_info: Option<ExpnInfo>,\n }\n \n@@ -82,11 +85,8 @@ pub enum Transparency {\n }\n \n impl Mark {\n-    pub fn fresh(parent: Mark) -> Self {\n-        HygieneData::with(|data| {\n-            data.marks.push(MarkData { parent, expn_info: None });\n-            Mark(data.marks.len() as u32 - 1)\n-        })\n+    pub fn fresh(parent: Mark, expn_info: Option<ExpnInfo>) -> Self {\n+        HygieneData::with(|data| data.fresh_mark(parent, expn_info))\n     }\n \n     /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n@@ -117,7 +117,11 @@ impl Mark {\n \n     #[inline]\n     pub fn set_expn_info(self, info: ExpnInfo) {\n-        HygieneData::with(|data| data.marks[self.0 as usize].expn_info = Some(info))\n+        HygieneData::with(|data| {\n+            let old_info = &mut data.marks[self.0 as usize].expn_info;\n+            assert!(old_info.is_none(), \"expansion info is reset for a mark\");\n+            *old_info = Some(info);\n+        })\n     }\n \n     pub fn is_descendant_of(self, ancestor: Mark) -> bool {\n@@ -130,42 +134,14 @@ impl Mark {\n         HygieneData::with(|data| data.is_descendant_of(self, data.outer(ctxt)))\n     }\n \n-    /// Computes a mark such that both input marks are descendants of (or equal to) the returned\n-    /// mark. That is, the following holds:\n-    ///\n-    /// ```rust\n-    /// let la = least_ancestor(a, b);\n-    /// assert!(a.is_descendant_of(la))\n-    /// assert!(b.is_descendant_of(la))\n-    /// ```\n-    pub fn least_ancestor(mut a: Mark, mut b: Mark) -> Mark {\n-        HygieneData::with(|data| {\n-            // Compute the path from a to the root\n-            let mut a_path = FxHashSet::<Mark>::default();\n-            while a != Mark::root() {\n-                a_path.insert(a);\n-                a = data.marks[a.0 as usize].parent;\n-            }\n-\n-            // While the path from b to the root hasn't intersected, move up the tree\n-            while !a_path.contains(&b) {\n-                b = data.marks[b.0 as usize].parent;\n-            }\n-\n-            b\n-        })\n-    }\n-\n     // Used for enabling some compatibility fallback in resolve.\n     #[inline]\n     pub fn looks_like_proc_macro_derive(self) -> bool {\n         HygieneData::with(|data| {\n             if data.default_transparency(self) == Transparency::Opaque {\n-                if let Some(expn_info) = &data.marks[self.0 as usize].expn_info {\n-                    if let ExpnFormat::MacroAttribute(name) = expn_info.format {\n-                        if name.as_str().starts_with(\"derive(\") {\n-                            return true;\n-                        }\n+                if let Some(expn_info) = data.expn_info(self) {\n+                    if let ExpnKind::Macro(MacroKind::Derive, _) = expn_info.kind {\n+                        return true;\n                     }\n                 }\n             }\n@@ -182,11 +158,11 @@ crate struct HygieneData {\n }\n \n impl HygieneData {\n-    crate fn new() -> Self {\n+    crate fn new(edition: Edition) -> Self {\n         HygieneData {\n             marks: vec![MarkData {\n                 parent: Mark::root(),\n-                expn_info: None,\n+                expn_info: Some(ExpnInfo::default(ExpnKind::Root, DUMMY_SP, edition)),\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n                 outer_mark: Mark::root(),\n@@ -204,8 +180,21 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n+    fn fresh_mark(&mut self, parent: Mark, expn_info: Option<ExpnInfo>) -> Mark {\n+        self.marks.push(MarkData { parent, expn_info });\n+        Mark(self.marks.len() as u32 - 1)\n+    }\n+\n     fn expn_info(&self, mark: Mark) -> Option<&ExpnInfo> {\n-        self.marks[mark.0 as usize].expn_info.as_ref()\n+        if mark != Mark::root() {\n+            Some(self.marks[mark.0 as usize].expn_info.as_ref()\n+                     .expect(\"no expansion info for a mark\"))\n+        } else {\n+            // FIXME: Some code relies on `expn_info().is_none()` meaning \"no expansion\".\n+            // Introduce a method for checking for \"no expansion\" instead and always return\n+            // `ExpnInfo` from this function instead of the `Option`.\n+            None\n+        }\n     }\n \n     fn is_descendant_of(&self, mut mark: Mark, ancestor: Mark) -> bool {\n@@ -219,7 +208,7 @@ impl HygieneData {\n     }\n \n     fn default_transparency(&self, mark: Mark) -> Transparency {\n-        self.marks[mark.0 as usize].expn_info.as_ref().map_or(\n+        self.expn_info(mark).map_or(\n             Transparency::SemiTransparent, |einfo| einfo.default_transparency\n         )\n     }\n@@ -420,33 +409,6 @@ impl SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n-    // Allocate a new SyntaxContext with the given ExpnInfo. This is used when\n-    // deserializing Spans from the incr. comp. cache.\n-    // FIXME(mw): This method does not restore MarkData::parent or\n-    // SyntaxContextData::prev_ctxt or SyntaxContextData::opaque. These things\n-    // don't seem to be used after HIR lowering, so everything should be fine\n-    // as long as incremental compilation does not kick in before that.\n-    pub fn allocate_directly(expansion_info: ExpnInfo) -> Self {\n-        HygieneData::with(|data| {\n-            data.marks.push(MarkData {\n-                parent: Mark::root(),\n-                expn_info: Some(expansion_info),\n-            });\n-\n-            let mark = Mark(data.marks.len() as u32 - 1);\n-\n-            data.syntax_contexts.push(SyntaxContextData {\n-                outer_mark: mark,\n-                transparency: Transparency::SemiTransparent,\n-                prev_ctxt: SyntaxContext::empty(),\n-                opaque: SyntaxContext::empty(),\n-                opaque_and_semitransparent: SyntaxContext::empty(),\n-                dollar_crate_name: kw::DollarCrate,\n-            });\n-            SyntaxContext(data.syntax_contexts.len() as u32 - 1)\n-        })\n-    }\n-\n     /// Extend a syntax context with a given mark and default transparency for that mark.\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark(self, mark))\n@@ -639,8 +601,23 @@ impl fmt::Debug for SyntaxContext {\n     }\n }\n \n-/// Extra information for tracking spans of macro and syntax sugar expansion\n-#[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n+impl Span {\n+    /// Creates a fresh expansion with given properties.\n+    /// Expansions are normally created by macros, but in some cases expansions are created for\n+    /// other compiler-generated code to set per-span properties like allowed unstable features.\n+    /// The returned span belongs to the created expansion and has the new properties,\n+    /// but its location is inherited from the current span.\n+    pub fn fresh_expansion(self, parent: Mark, expn_info: ExpnInfo) -> Span {\n+        HygieneData::with(|data| {\n+            let mark = data.fresh_mark(parent, Some(expn_info));\n+            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), mark))\n+        })\n+    }\n+}\n+\n+/// A subset of properties from both macro definition and macro call available through global data.\n+/// Avoid using this if you have access to the original definition or call structures.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExpnInfo {\n     // --- The part unique to each expansion.\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n@@ -653,16 +630,14 @@ pub struct ExpnInfo {\n     /// call_site span would have its own ExpnInfo, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n-    /// The format with which the macro was invoked.\n-    pub format: ExpnFormat,\n+    /// The kind of this expansion - macro or compiler desugaring.\n+    pub kind: ExpnKind,\n \n     // --- The part specific to the macro/desugaring definition.\n     // --- FIXME: Share it between expansions with the same definition.\n-    /// The span of the macro definition itself. The macro may not\n-    /// have a sensible definition span (e.g., something defined\n-    /// completely inside libsyntax) in which case this is None.\n+    /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n-    pub def_site: Option<Span>,\n+    pub def_site: Span,\n     /// Transparency used by `apply_mark` for mark with this expansion info by default.\n     pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n@@ -681,11 +656,11 @@ pub struct ExpnInfo {\n \n impl ExpnInfo {\n     /// Constructs an expansion info with default properties.\n-    pub fn default(format: ExpnFormat, call_site: Span, edition: Edition) -> ExpnInfo {\n+    pub fn default(kind: ExpnKind, call_site: Span, edition: Edition) -> ExpnInfo {\n         ExpnInfo {\n             call_site,\n-            format,\n-            def_site: None,\n+            kind,\n+            def_site: DUMMY_SP,\n             default_transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n@@ -694,38 +669,68 @@ impl ExpnInfo {\n         }\n     }\n \n-    pub fn with_unstable(format: ExpnFormat, call_site: Span, edition: Edition,\n-                         allow_internal_unstable: &[Symbol]) -> ExpnInfo {\n+    pub fn allow_unstable(kind: ExpnKind, call_site: Span, edition: Edition,\n+                          allow_internal_unstable: Lrc<[Symbol]>) -> ExpnInfo {\n         ExpnInfo {\n-            allow_internal_unstable: Some(allow_internal_unstable.into()),\n-            ..ExpnInfo::default(format, call_site, edition)\n+            allow_internal_unstable: Some(allow_internal_unstable),\n+            ..ExpnInfo::default(kind, call_site, edition)\n         }\n     }\n }\n \n-/// The source of expansion.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub enum ExpnFormat {\n-    /// e.g., #[derive(...)] <item>\n-    MacroAttribute(Symbol),\n-    /// e.g., `format!()`\n-    MacroBang(Symbol),\n+/// Expansion kind.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum ExpnKind {\n+    /// No expansion, aka root expansion. Only `Mark::root()` has this kind.\n+    Root,\n+    /// Expansion produced by a macro.\n+    /// FIXME: Some code injected by the compiler before HIR lowering also gets this kind.\n+    Macro(MacroKind, Symbol),\n     /// Desugaring done by the compiler during HIR lowering.\n-    CompilerDesugaring(CompilerDesugaringKind)\n+    Desugaring(DesugaringKind)\n }\n \n-impl ExpnFormat {\n-    pub fn name(&self) -> Symbol {\n+impl ExpnKind {\n+    pub fn descr(&self) -> Symbol {\n         match *self {\n-            ExpnFormat::MacroBang(name) | ExpnFormat::MacroAttribute(name) => name,\n-            ExpnFormat::CompilerDesugaring(kind) => kind.name(),\n+            ExpnKind::Root => kw::PathRoot,\n+            ExpnKind::Macro(_, descr) => descr,\n+            ExpnKind::Desugaring(kind) => Symbol::intern(kind.descr()),\n+        }\n+    }\n+}\n+\n+/// The kind of macro invocation or definition.\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum MacroKind {\n+    /// A bang macro `foo!()`.\n+    Bang,\n+    /// An attribute macro `#[foo]`.\n+    Attr,\n+    /// A derive macro `#[derive(Foo)]`\n+    Derive,\n+}\n+\n+impl MacroKind {\n+    pub fn descr(self) -> &'static str {\n+        match self {\n+            MacroKind::Bang => \"macro\",\n+            MacroKind::Attr => \"attribute macro\",\n+            MacroKind::Derive => \"derive macro\",\n+        }\n+    }\n+\n+    pub fn article(self) -> &'static str {\n+        match self {\n+            MacroKind::Attr => \"an\",\n+            _ => \"a\",\n         }\n     }\n }\n \n /// The kind of compiler desugaring.\n-#[derive(Clone, Copy, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub enum CompilerDesugaringKind {\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum DesugaringKind {\n     /// We desugar `if c { i } else { e }` to `match $ExprKind::Use(c) { true => i, _ => e }`.\n     /// However, we do not want to blame `c` for unreachability but rather say that `i`\n     /// is unreachable. This desugaring kind allows us to avoid blaming `c`.\n@@ -742,17 +747,18 @@ pub enum CompilerDesugaringKind {\n     ForLoop,\n }\n \n-impl CompilerDesugaringKind {\n-    pub fn name(self) -> Symbol {\n-        Symbol::intern(match self {\n-            CompilerDesugaringKind::CondTemporary => \"if and while condition\",\n-            CompilerDesugaringKind::Async => \"async\",\n-            CompilerDesugaringKind::Await => \"await\",\n-            CompilerDesugaringKind::QuestionMark => \"?\",\n-            CompilerDesugaringKind::TryBlock => \"try block\",\n-            CompilerDesugaringKind::ExistentialType => \"existential type\",\n-            CompilerDesugaringKind::ForLoop => \"for loop\",\n-        })\n+impl DesugaringKind {\n+    /// The description wording should combine well with \"desugaring of {}\".\n+    fn descr(self) -> &'static str {\n+        match self {\n+            DesugaringKind::CondTemporary => \"`if` or `while` condition\",\n+            DesugaringKind::Async => \"`async` block or function\",\n+            DesugaringKind::Await => \"`await` expression\",\n+            DesugaringKind::QuestionMark => \"operator `?`\",\n+            DesugaringKind::TryBlock => \"`try` block\",\n+            DesugaringKind::ExistentialType => \"`existential type`\",\n+            DesugaringKind::ForLoop => \"`for` loop\",\n+        }\n     }\n }\n "}, {"sha": "5ccfe5f0b8b1a8303a415ab903f94a28288090fd", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -27,7 +27,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n-pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnFormat, CompilerDesugaringKind};\n+pub use hygiene::{Mark, SyntaxContext, ExpnInfo, ExpnKind, MacroKind, DesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -60,7 +60,7 @@ impl Globals {\n         Globals {\n             symbol_interner: Lock::new(symbol::Interner::fresh()),\n             span_interner: Lock::new(span_encoding::SpanInterner::default()),\n-            hygiene_data: Lock::new(hygiene::HygieneData::new()),\n+            hygiene_data: Lock::new(hygiene::HygieneData::new(edition)),\n             edition,\n         }\n     }\n@@ -403,10 +403,10 @@ impl Span {\n     }\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`.\n-    pub fn is_compiler_desugaring(&self, kind: CompilerDesugaringKind) -> bool {\n+    pub fn is_desugaring(&self, kind: DesugaringKind) -> bool {\n         match self.ctxt().outer_expn_info() {\n-            Some(info) => match info.format {\n-                ExpnFormat::CompilerDesugaring(k) => k == kind,\n+            Some(info) => match info.kind {\n+                ExpnKind::Desugaring(k) => k == kind,\n                 _ => false,\n             },\n             None => false,\n@@ -415,10 +415,10 @@ impl Span {\n \n     /// Returns the compiler desugaring that created this span, or `None`\n     /// if this span is not from a desugaring.\n-    pub fn compiler_desugaring_kind(&self) -> Option<CompilerDesugaringKind> {\n+    pub fn desugaring_kind(&self) -> Option<DesugaringKind> {\n         match self.ctxt().outer_expn_info() {\n-            Some(info) => match info.format {\n-                ExpnFormat::CompilerDesugaring(k) => Some(k),\n+            Some(info) => match info.kind {\n+                ExpnKind::Desugaring(k) => Some(k),\n                 _ => None\n             },\n             None => None\n@@ -441,14 +441,18 @@ impl Span {\n         while let Some(info) = self.ctxt().outer_expn_info() {\n             // Don't print recursive invocations.\n             if !info.call_site.source_equal(&prev_span) {\n-                let (pre, post) = match info.format {\n-                    ExpnFormat::MacroAttribute(..) => (\"#[\", \"]\"),\n-                    ExpnFormat::MacroBang(..) => (\"\", \"!\"),\n-                    ExpnFormat::CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n+                let (pre, post) = match info.kind {\n+                    ExpnKind::Root => break,\n+                    ExpnKind::Desugaring(..) => (\"desugaring of \", \"\"),\n+                    ExpnKind::Macro(macro_kind, _) => match macro_kind {\n+                        MacroKind::Bang => (\"\", \"!\"),\n+                        MacroKind::Attr => (\"#[\", \"]\"),\n+                        MacroKind::Derive => (\"#[derive(\", \")]\"),\n+                    }\n                 };\n                 result.push(MacroBacktrace {\n                     call_site: info.call_site,\n-                    macro_decl_name: format!(\"{}{}{}\", pre, info.format.name(), post),\n+                    macro_decl_name: format!(\"{}{}{}\", pre, info.kind.descr(), post),\n                     def_site_span: info.def_site,\n                 });\n             }\n@@ -1363,8 +1367,8 @@ pub struct MacroBacktrace {\n     /// name of macro that was applied (e.g., \"foo!\" or \"#[derive(Eq)]\")\n     pub macro_decl_name: String,\n \n-    /// span where macro was defined (if known)\n-    pub def_site_span: Option<Span>,\n+    /// span where macro was defined (possibly dummy)\n+    pub def_site_span: Span,\n }\n \n // _____________________________________________________________________________"}, {"sha": "581fd47c4b3b582f8668065373f0cde443e762c4", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -508,6 +508,7 @@ symbols! {\n         proc_macro_expr,\n         proc_macro_gen,\n         proc_macro_hygiene,\n+        proc_macro_internals,\n         proc_macro_mod,\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n@@ -631,6 +632,7 @@ symbols! {\n         static_nobundle,\n         static_recursion,\n         std,\n+        std_inject,\n         str,\n         stringify,\n         stmt,"}, {"sha": "36cee82893a06066e2440f0eddad40eb8f5fdef6", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -28,8 +28,7 @@ impl TTMacroExpander for Expander {\n     fn expand<'cx>(&self,\n                    ecx: &'cx mut ExtCtxt,\n                    sp: Span,\n-                   _: TokenStream,\n-                   _: Option<Span>) -> Box<dyn MacResult+'cx> {\n+                   _: TokenStream) -> Box<dyn MacResult+'cx> {\n         let args = self.args.iter().map(|i| pprust::meta_list_item_to_string(i))\n             .collect::<Vec<_>>().join(\", \");\n         MacEager::expr(ecx.expr_str(sp, Symbol::intern(&args)))"}, {"sha": "c21886f26f467e2176460fc166f95d0d9ee3cc6c", "filename": "src/test/run-pass/auxiliary/arc_wake.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/35cacbce1661366250a877da4fa5b6b4cb03542e/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35cacbce1661366250a877da4fa5b6b4cb03542e/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs?ref=35cacbce1661366250a877da4fa5b6b4cb03542e", "patch": "@@ -1,64 +0,0 @@\n-// edition:2018\n-\n-use std::sync::Arc;\n-use std::task::{\n-    Waker, RawWaker, RawWakerVTable,\n-};\n-\n-macro_rules! waker_vtable {\n-    ($ty:ident) => {\n-        &RawWakerVTable::new(\n-            clone_arc_raw::<$ty>,\n-            wake_arc_raw::<$ty>,\n-            wake_by_ref_arc_raw::<$ty>,\n-            drop_arc_raw::<$ty>,\n-        )\n-    };\n-}\n-\n-pub trait ArcWake {\n-    fn wake(self: Arc<Self>);\n-\n-    fn wake_by_ref(arc_self: &Arc<Self>) {\n-        arc_self.clone().wake()\n-    }\n-\n-    fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n-    {\n-        let ptr = Arc::into_raw(wake) as *const ();\n-\n-        unsafe {\n-            Waker::from_raw(RawWaker::new(ptr, waker_vtable!(Self)))\n-        }\n-    }\n-}\n-\n-unsafe fn increase_refcount<T: ArcWake>(data: *const ()) {\n-    // Retain Arc by creating a copy\n-    let arc: Arc<T> = Arc::from_raw(data as *const T);\n-    let arc_clone = arc.clone();\n-    // Forget the Arcs again, so that the refcount isn't decrased\n-    let _ = Arc::into_raw(arc);\n-    let _ = Arc::into_raw(arc_clone);\n-}\n-\n-unsafe fn clone_arc_raw<T: ArcWake>(data: *const ()) -> RawWaker {\n-    increase_refcount::<T>(data);\n-    RawWaker::new(data, waker_vtable!(T))\n-}\n-\n-unsafe fn drop_arc_raw<T: ArcWake>(data: *const ()) {\n-    // Drop Arc\n-    let _: Arc<T> = Arc::from_raw(data as *const T);\n-}\n-\n-unsafe fn wake_arc_raw<T: ArcWake>(data: *const ()) {\n-    let arc: Arc<T> = Arc::from_raw(data as *const T);\n-    ArcWake::wake(arc);\n-}\n-\n-unsafe fn wake_by_ref_arc_raw<T: ArcWake>(data: *const ()) {\n-    let arc: Arc<T> = Arc::from_raw(data as *const T);\n-    ArcWake::wake_by_ref(&arc);\n-    let _ = Arc::into_raw(arc);\n-}"}, {"sha": "4bd0b092b55a718b2d9bf52c8b2ddbac40f7d80f", "filename": "src/test/rustdoc/proc-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Frustdoc%2Fproc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fproc-macro.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -7,7 +7,7 @@\n // @has some_macros/index.html\n // @has - '//a/[@href=\"attr.some_proc_attr.html\"]' 'some_proc_attr'\n \n-//! include a link to [some_proc_attr] to make sure it works.\n+//! include a link to [some_proc_macro] to make sure it works.\n \n extern crate proc_macro;\n "}, {"sha": "d0d4eb032fcb1e0a1fc8f2e843a439b30c803565", "filename": "src/test/ui/async-await/async-fn-size-moved-locals.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size-moved-locals.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -7,6 +7,9 @@\n //\n // See issue #59123 for a full explanation.\n \n+// ignore-wasm32-bare (sizes don't match)\n+// run-pass\n+\n // edition:2018\n \n #![feature(async_await)]", "previous_filename": "src/test/run-pass/async-await/async-fn-size-moved-locals.rs"}, {"sha": "c6b2ed13b0a8dab5539d7a8ab4d75dda07c1339c", "filename": "src/test/ui/async-await/async-fn-size.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-size.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,9 +1,10 @@\n+// run-pass\n+// aux-build:arc_wake.rs\n // edition:2018\n \n #![feature(async_await)]\n \n-#[path = \"../auxiliary/arc_wake.rs\"]\n-mod arc_wake;\n+extern crate arc_wake;\n \n use std::pin::Pin;\n use std::future::Future;", "previous_filename": "src/test/run-pass/async-await/async-fn-size.rs"}, {"sha": "a7da058de3081f7aa48cb3e3e98a327c566d8ac2", "filename": "src/test/ui/async-await/futures-api.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fasync-await%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fasync-await%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ffutures-api.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,3 +1,5 @@\n+// run-pass\n+\n // aux-build:arc_wake.rs\n \n extern crate arc_wake;", "previous_filename": "src/test/run-pass/futures-api.rs"}, {"sha": "ad0b49fa4a219368211e25bd8e23591674d19bb5", "filename": "src/test/ui/async-await/issue-60709.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fasync-await%2Fissue-60709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fasync-await%2Fissue-60709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-60709.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,6 +2,8 @@\n // handled incorrectly in generators.\n // compile-flags: -Copt-level=z -Cdebuginfo=2 --edition=2018\n \n+// run-pass\n+\n #![feature(async_await)]\n #![allow(unused)]\n ", "previous_filename": "src/test/run-pass/async-await/issue-60709.rs"}, {"sha": "70345351bd09d9e406564d7a41037a7779683614", "filename": "src/test/ui/derives/auxiliary/derive-marker-tricky.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fderives%2Fauxiliary%2Fderive-marker-tricky.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fderives%2Fauxiliary%2Fderive-marker-tricky.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fauxiliary%2Fderive-marker-tricky.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,15 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_derive(NoMarker)]\n+pub fn f(input: TokenStream) -> TokenStream {\n+    if input.to_string().contains(\"rustc_copy_clone_marker\") {\n+        panic!(\"found `#[rustc_copy_clone_marker]`\");\n+    }\n+    TokenStream::new()\n+}"}, {"sha": "730ea4714c789169264e1afde7f9c5a870700aca", "filename": "src/test/ui/derives/derive-marker-tricky.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fderives%2Fderive-marker-tricky.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fderives%2Fderive-marker-tricky.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-marker-tricky.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,16 @@\n+// Test that `#[rustc_copy_clone_marker]` is not injected when a user-defined derive shadows\n+// a built-in derive in non-trivial scope (e.g. in a nested module).\n+\n+// check-pass\n+// aux-build:derive-marker-tricky.rs\n+\n+extern crate derive_marker_tricky;\n+\n+mod m {\n+    use derive_marker_tricky::NoMarker as Copy;\n+\n+    #[derive(Copy)]\n+    struct S;\n+}\n+\n+fn main() {}"}, {"sha": "ab5cda43bfc8249636b0758be8faa826a9780822", "filename": "src/test/ui/feature-gates/feature-gate-asm.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'asm': inline assembly is not stab\n   --> $DIR/feature-gate-asm.rs:3:9\n    |\n LL |         asm!(\"\");\n-   |         ^^^^^^^^^\n+   |         ^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29722\n    = help: add `#![feature(asm)]` to the crate attributes to enable"}, {"sha": "7519cad9a96ad770b2a2e0bb515618396edadff4", "filename": "src/test/ui/feature-gates/feature-gate-asm2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'asm': inline assembly is not stab\n   --> $DIR/feature-gate-asm2.rs:5:26\n    |\n LL |         println!(\"{:?}\", asm!(\"\"));\n-   |                          ^^^^^^^^\n+   |                          ^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29722\n    = help: add `#![feature(asm)]` to the crate attributes to enable"}, {"sha": "8639f622cd732e58f0c8ae30c662aa1cef6131f0", "filename": "src/test/ui/feature-gates/feature-gate-concat_idents.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'concat_idents': `concat_idents` i\n   --> $DIR/feature-gate-concat_idents.rs:5:13\n    |\n LL |     let a = concat_idents!(X, Y_1);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29599\n    = help: add `#![feature(concat_idents)]` to the crate attributes to enable\n@@ -11,7 +11,7 @@ error[E0658]: use of unstable library feature 'concat_idents': `concat_idents` i\n   --> $DIR/feature-gate-concat_idents.rs:6:13\n    |\n LL |     let b = concat_idents!(X, Y_2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29599\n    = help: add `#![feature(concat_idents)]` to the crate attributes to enable"}, {"sha": "4ae5e3e73087bd4f9fe2310241856a809882da93", "filename": "src/test/ui/feature-gates/feature-gate-concat_idents2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'concat_idents': `concat_idents` i\n   --> $DIR/feature-gate-concat_idents2.rs:4:5\n    |\n LL |     concat_idents!(a, b);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29599\n    = help: add `#![feature(concat_idents)]` to the crate attributes to enable"}, {"sha": "367638693d70a56cfc4a80d088153390257317e4", "filename": "src/test/ui/feature-gates/feature-gate-concat_idents3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents3.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'concat_idents': `concat_idents` i\n   --> $DIR/feature-gate-concat_idents3.rs:7:20\n    |\n LL |     assert_eq!(10, concat_idents!(X, Y_1));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29599\n    = help: add `#![feature(concat_idents)]` to the crate attributes to enable\n@@ -11,7 +11,7 @@ error[E0658]: use of unstable library feature 'concat_idents': `concat_idents` i\n   --> $DIR/feature-gate-concat_idents3.rs:8:20\n    |\n LL |     assert_eq!(20, concat_idents!(X, Y_2));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29599\n    = help: add `#![feature(concat_idents)]` to the crate attributes to enable"}, {"sha": "38304e7f3f934e210d6666fe684cdf304609d59b", "filename": "src/test/ui/feature-gates/feature-gate-custom_test_frameworks.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-custom_test_frameworks.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: use of unstable library feature 'custom_test_frameworks': custom test frameworks are an unstable feature\n-  --> $DIR/feature-gate-custom_test_frameworks.rs:3:1\n+  --> $DIR/feature-gate-custom_test_frameworks.rs:3:3\n    |\n LL | #[test_case]\n-   | ^^^^^^^^^^^^\n+   |   ^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/50297\n    = help: add `#![feature(custom_test_frameworks)]` to the crate attributes to enable"}, {"sha": "b211e2f8ed8a222da71a867aeae819a40aba16ae", "filename": "src/test/ui/feature-gates/feature-gate-format_args_nl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-format_args_nl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-format_args_nl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-format_args_nl.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'format_args_nl': `format_args_nl`\n   --> $DIR/feature-gate-format_args_nl.rs:2:5\n    |\n LL |     format_args_nl!(\"\");\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(format_args_nl)]` to the crate attributes to enable\n "}, {"sha": "733b8d08f77dd2dce464e4fc4bab1f53df168839", "filename": "src/test/ui/feature-gates/feature-gate-global_asm.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-global_asm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-global_asm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-global_asm.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'global_asm': `global_asm!` is not\n   --> $DIR/feature-gate-global_asm.rs:1:1\n    |\n LL | global_asm!(\"\");\n-   | ^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/35119\n    = help: add `#![feature(global_asm)]` to the crate attributes to enable"}, {"sha": "fa57c20ecd5d51539797ac5625e49ee5b4fc3eb4", "filename": "src/test/ui/feature-gates/feature-gate-log_syntax.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'log_syntax': `log_syntax!` is not\n   --> $DIR/feature-gate-log_syntax.rs:2:5\n    |\n LL |     log_syntax!()\n-   |     ^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29598\n    = help: add `#![feature(log_syntax)]` to the crate attributes to enable"}, {"sha": "0443b988b41dc172e8aa5786ea05a30e3379f775", "filename": "src/test/ui/feature-gates/feature-gate-log_syntax2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-log_syntax2.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'log_syntax': `log_syntax!` is not\n   --> $DIR/feature-gate-log_syntax2.rs:4:22\n    |\n LL |     println!(\"{:?}\", log_syntax!());\n-   |                      ^^^^^^^^^^^^^\n+   |                      ^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29598\n    = help: add `#![feature(log_syntax)]` to the crate attributes to enable"}, {"sha": "9ce2fb58ab0aded52533d382d7c945c2aecc5dc9", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -7,12 +7,12 @@ mod unknown { pub macro rustc() {} }\n \n #[rustc::unknown]\n //~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n-//~| ERROR macro `rustc::unknown` may not be used in attributes\n+//~| ERROR expected attribute, found macro `rustc::unknown`\n fn f() {}\n \n #[unknown::rustc]\n //~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n-//~| ERROR macro `unknown::rustc` may not be used in attributes\n+//~| ERROR expected attribute, found macro `unknown::rustc`\n fn g() {}\n \n #[rustc_dummy]"}, {"sha": "7c5aa5381e8c7b9b5780cad1f7f9d07e1649c68a", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -7,11 +7,11 @@ LL | #[rustc::unknown]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n-error: macro `rustc::unknown` may not be used in attributes\n-  --> $DIR/feature-gate-rustc-attrs.rs:8:1\n+error: expected attribute, found macro `rustc::unknown`\n+  --> $DIR/feature-gate-rustc-attrs.rs:8:3\n    |\n LL | #[rustc::unknown]\n-   | ^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^^^ not an attribute\n \n error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n   --> $DIR/feature-gate-rustc-attrs.rs:13:12\n@@ -22,11 +22,11 @@ LL | #[unknown::rustc]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n \n-error: macro `unknown::rustc` may not be used in attributes\n-  --> $DIR/feature-gate-rustc-attrs.rs:13:1\n+error: expected attribute, found macro `unknown::rustc`\n+  --> $DIR/feature-gate-rustc-attrs.rs:13:3\n    |\n LL | #[unknown::rustc]\n-   | ^^^^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^^^ not an attribute\n \n error[E0658]: attributes starting with `rustc` are reserved for use by the `rustc` compiler\n   --> $DIR/feature-gate-rustc-attrs.rs:20:3"}, {"sha": "cca081875271893697e685be35405b1da67ccb6c", "filename": "src/test/ui/feature-gates/feature-gate-trace_macros.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trace_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trace_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trace_macros.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'trace_macros': `trace_macros` is\n   --> $DIR/feature-gate-trace_macros.rs:2:5\n    |\n LL |     trace_macros!(true);\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29598\n    = help: add `#![feature(trace_macros)]` to the crate attributes to enable"}, {"sha": "9a4f87728224515de44b7db4362ce1270264abe0", "filename": "src/test/ui/hrtb/issue-30786.migrate.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,11 @@\n+error: implementation of `Stream` is not general enough\n+  --> $DIR/issue-30786.rs:107:22\n+   |\n+LL |     let map = source.map(|x: &_| x);\n+   |                      ^^^\n+   |\n+   = note: `Stream` would have to be implemented for the type `&'0 mut Map<Repeat, [closure@$DIR/issue-30786.rs:107:26: 107:35]>`, for any lifetime `'0`\n+   = note: but `Stream` is actually implemented for the type `&'1 mut Map<Repeat, [closure@$DIR/issue-30786.rs:107:26: 107:35]>`, for some specific lifetime `'1`\n+\n+error: aborting due to previous error\n+"}, {"sha": "5c865d76851d388fcf1a7fc482a99ef546564b11", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,14 @@\n+error: higher-ranked subtype error\n+  --> $DIR/issue-30786.rs:111:18\n+   |\n+LL |     let filter = map.filter(|x: &_| true);\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/issue-30786.rs:113:17\n+   |\n+LL |     let count = filter.count(); // Assert that we still have a valid stream.\n+   |                 ^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "321b83c3459d0c9a0d648400a2be19a97d7f987e", "filename": "src/test/ui/hrtb/issue-30786.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,115 @@\n+// rust-lang/rust#30786: the use of `for<'b> &'b mut A: Stream<Item=T`\n+// should act as assertion that item does not borrow from its stream;\n+// but an earlier buggy rustc allowed `.map(|x: &_| x)` which does\n+// have such an item.\n+//\n+// This tests double-checks that we do not allow such behavior to leak\n+// through again.\n+\n+// revisions: migrate nll\n+\n+// Since we are testing nll (and migration) explicitly as a separate\n+// revisions, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[nll]compile-flags: -Z borrowck=mir\n+\n+pub trait Stream {\n+    type Item;\n+    fn next(self) -> Option<Self::Item>;\n+}\n+\n+// Example stream\n+pub struct Repeat(u64);\n+\n+impl<'a> Stream for &'a mut Repeat {\n+    type Item = &'a u64;\n+    fn next(self) -> Option<Self::Item> {\n+        Some(&self.0)\n+    }\n+}\n+\n+pub struct Map<S, F> {\n+    stream: S,\n+    func: F,\n+}\n+\n+impl<'a, A, F, T> Stream for &'a mut Map<A, F>\n+where &'a mut A: Stream,\n+      F: FnMut(<&'a mut A as Stream>::Item) -> T,\n+{\n+    type Item = T;\n+    fn next(self) -> Option<T> {\n+        match self.stream.next() {\n+            Some(item) => Some((self.func)(item)),\n+            None => None,\n+        }\n+    }\n+}\n+\n+pub struct Filter<S, F> {\n+    stream: S,\n+    func: F,\n+}\n+\n+impl<'a, A, F, T> Stream for &'a mut Filter<A, F>\n+where for<'b> &'b mut A: Stream<Item=T>, // <---- BAD\n+      F: FnMut(&T) -> bool,\n+{\n+    type Item = <&'a mut A as Stream>::Item;\n+    fn next(self) -> Option<Self::Item> {\n+        while let Some(item) = self.stream.next() {\n+            if (self.func)(&item) {\n+                return Some(item);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+pub trait StreamExt where for<'b> &'b mut Self: Stream {\n+    fn map<F>(self, func: F) -> Map<Self, F>\n+    where Self: Sized,\n+    for<'a> &'a mut Map<Self, F>: Stream,\n+    {\n+        Map {\n+            func: func,\n+            stream: self,\n+        }\n+    }\n+\n+    fn filter<F>(self, func: F) -> Filter<Self, F>\n+    where Self: Sized,\n+    for<'a> &'a mut Filter<Self, F>: Stream,\n+    {\n+        Filter {\n+            func: func,\n+            stream: self,\n+        }\n+    }\n+\n+    fn count(mut self) -> usize\n+    where Self: Sized,\n+    {\n+        let mut count = 0;\n+        while let Some(_) = self.next() {\n+            count += 1;\n+        }\n+        count\n+    }\n+}\n+\n+impl<T> StreamExt for T where for<'a> &'a mut T: Stream { }\n+\n+fn main() {\n+    let source = Repeat(10);\n+    let map = source.map(|x: &_| x);\n+    //[migrate]~^ ERROR implementation of `Stream` is not general enough\n+    //[migrate]~| NOTE  `Stream` would have to be implemented for the type `&'0 mut Map\n+    //[migrate]~| NOTE  but `Stream` is actually implemented for the type `&'1\n+    let filter = map.filter(|x: &_| true);\n+    //[nll]~^ ERROR higher-ranked subtype error\n+    let count = filter.count(); // Assert that we still have a valid stream.\n+    //[nll]~^ ERROR higher-ranked subtype error\n+}"}, {"sha": "81b0b7faa5ba7795c00c75919c660753c880a902", "filename": "src/test/ui/hygiene/auxiliary/stdlib-prelude.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fstdlib-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fstdlib-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fstdlib-prelude.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,3 @@\n+#![feature(decl_macro)]\n+\n+pub macro stdlib_macro() {}"}, {"sha": "06d62656e957fcc2ff9abfe4ce474e7ce81e7cbf", "filename": "src/test/ui/hygiene/extern-prelude-from-opaque-fail.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,28 @@\n+#![feature(decl_macro)]\n+\n+macro a() {\n+    extern crate core as my_core;\n+    mod v {\n+        // Early resolution.\n+        use my_core; //~ ERROR unresolved import `my_core`\n+    }\n+    mod u {\n+        // Late resolution.\n+        fn f() { my_core::mem::drop(0); }\n+        //~^ ERROR failed to resolve: use of undeclared type or module `my_core`\n+    }\n+}\n+\n+a!();\n+\n+mod v {\n+    // Early resolution.\n+    use my_core; //~ ERROR unresolved import `my_core`\n+}\n+mod u {\n+    // Late resolution.\n+    fn f() { my_core::mem::drop(0); }\n+    //~^ ERROR failed to resolve: use of undeclared type or module `my_core`\n+}\n+\n+fn main() {}"}, {"sha": "65133eb1e1873e537bf01b5c55eb8d0c3d545d3e", "filename": "src/test/ui/hygiene/extern-prelude-from-opaque-fail.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,37 @@\n+error[E0432]: unresolved import `my_core`\n+  --> $DIR/extern-prelude-from-opaque-fail.rs:20:9\n+   |\n+LL |     use my_core;\n+   |         ^^^^^^^\n+   |         |\n+   |         no `my_core` in the root\n+   |         help: a similar name exists in the module: `my_core`\n+\n+error[E0432]: unresolved import `my_core`\n+  --> $DIR/extern-prelude-from-opaque-fail.rs:7:13\n+   |\n+LL |         use my_core;\n+   |             ^^^^^^^ no `my_core` in the root\n+...\n+LL | a!();\n+   | ----- in this macro invocation\n+\n+error[E0433]: failed to resolve: use of undeclared type or module `my_core`\n+  --> $DIR/extern-prelude-from-opaque-fail.rs:11:18\n+   |\n+LL |         fn f() { my_core::mem::drop(0); }\n+   |                  ^^^^^^^ use of undeclared type or module `my_core`\n+...\n+LL | a!();\n+   | ----- in this macro invocation\n+\n+error[E0433]: failed to resolve: use of undeclared type or module `my_core`\n+  --> $DIR/extern-prelude-from-opaque-fail.rs:24:14\n+   |\n+LL |     fn f() { my_core::mem::drop(0); }\n+   |              ^^^^^^^ use of undeclared type or module `my_core`\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0432, E0433.\n+For more information about an error, try `rustc --explain E0432`."}, {"sha": "c8c5c72bf95c43d056f38de7c63c6190f0065919", "filename": "src/test/ui/hygiene/stdlib-prelude-from-opaque-early.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fstdlib-prelude-from-opaque-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fstdlib-prelude-from-opaque-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fstdlib-prelude-from-opaque-early.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+// aux-build:stdlib-prelude.rs\n+\n+#![feature(decl_macro)]\n+#![feature(prelude_import)]\n+\n+extern crate stdlib_prelude;\n+\n+#[prelude_import]\n+use stdlib_prelude::*;\n+\n+macro mac() {\n+    mod m {\n+        use std::mem; // OK (extern prelude)\n+        stdlib_macro!(); // OK (stdlib prelude)\n+    }\n+}\n+\n+mac!();\n+\n+fn main() {}"}, {"sha": "cf65de2bc2395211486fd9af6de1d0d1d9f4ee81", "filename": "src/test/ui/hygiene/stdlib-prelude-from-opaque-late.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fstdlib-prelude-from-opaque-late.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fhygiene%2Fstdlib-prelude-from-opaque-late.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fstdlib-prelude-from-opaque-late.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![feature(decl_macro)]\n+\n+macro mac() {\n+    mod m {\n+        fn f() {\n+            std::mem::drop(0); // OK (extern prelude)\n+            drop(0); // OK (stdlib prelude)\n+        }\n+    }\n+}\n+\n+mac!();\n+\n+fn main() {}"}, {"sha": "0729e14d5b2738d93554425e15e102b9f698e259", "filename": "src/test/ui/macros/derive-in-eager-expansion-hang.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fderive-in-eager-expansion-hang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fderive-in-eager-expansion-hang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fderive-in-eager-expansion-hang.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for the issue #44692\n+\n+macro_rules! hang { () => {\n+    { //~ ERROR format argument must be a string literal\n+        #[derive(Clone)]\n+        struct S;\n+\n+        \"\"\n+    }\n+}}\n+\n+fn main() {\n+    format_args!(hang!());\n+}"}, {"sha": "1ef9427666bc5958abbad5da82f963ea36257226", "filename": "src/test/ui/macros/derive-in-eager-expansion-hang.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fderive-in-eager-expansion-hang.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fderive-in-eager-expansion-hang.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fderive-in-eager-expansion-hang.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -0,0 +1,17 @@\n+error: format argument must be a string literal\n+  --> $DIR/derive-in-eager-expansion-hang.rs:4:5\n+   |\n+LL | /     {\n+LL | |         #[derive(Clone)]\n+LL | |         struct S;\n+LL | |\n+LL | |         \"\"\n+LL | |     }\n+   | |_____^\n+help: you might be missing a string literal to format with\n+   |\n+LL |     format_args!(\"{}\", hang!());\n+   |                  ^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "4c2ad7d2fe9e7c5b65efc4d9beb19acdd1d165db", "filename": "src/test/ui/macros/macro-deprecation.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-deprecation.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,13 +2,13 @@ warning: use of deprecated item 'local_deprecated': local deprecation note\n   --> $DIR/macro-deprecation.rs:11:5\n    |\n LL |     local_deprecated!();\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^\n    |\n    = note: #[warn(deprecated)] on by default\n \n warning: use of deprecated item 'deprecated_macro': deprecation note\n   --> $DIR/macro-deprecation.rs:12:5\n    |\n LL |     deprecated_macro!();\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^\n "}, {"sha": "2539a6d51561caa8788c21431c94d919b1a9ad70", "filename": "src/test/ui/macros/macro-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-error.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -8,7 +8,7 @@ error: non-type macro in type position: cfg\n   --> $DIR/macro-error.rs:8:12\n    |\n LL |     let _: cfg!(foo) = ();\n-   |            ^^^\n+   |            ^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0f93fcdaa5f5709ffe0d491ed40c6d1abfb1dad9", "filename": "src/test/ui/macros/macro-path-prelude-fail-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,4 +1,4 @@\n-#[derive(inline)] //~ ERROR expected a macro, found built-in attribute\n+#[derive(inline)] //~ ERROR expected derive macro, found built-in attribute `inline`\n struct S;\n \n fn main() {}"}, {"sha": "dfd6818b6785a73f8fa8a9cc45be3511f27cc03c", "filename": "src/test/ui/macros/macro-path-prelude-fail-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,8 +1,8 @@\n-error: expected a macro, found built-in attribute\n+error: expected derive macro, found built-in attribute `inline`\n   --> $DIR/macro-path-prelude-fail-4.rs:1:10\n    |\n LL | #[derive(inline)]\n-   |          ^^^^^^\n+   |          ^^^^^^ not a derive macro\n \n error: aborting due to previous error\n "}, {"sha": "21c48bfe5e78cfd5641f049917ec53450c7e1b94", "filename": "src/test/ui/macros/macro-stability.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,39 +2,39 @@ error[E0658]: use of unstable library feature 'local_unstable'\n   --> $DIR/macro-stability.rs:19:5\n    |\n LL |     local_unstable!();\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(local_unstable)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'local_unstable'\n   --> $DIR/macro-stability.rs:20:5\n    |\n LL |     local_unstable_modern!();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(local_unstable)]` to the crate attributes to enable\n \n error[E0658]: use of unstable library feature 'unstable_macros'\n   --> $DIR/macro-stability.rs:21:5\n    |\n LL |     unstable_macro!();\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(unstable_macros)]` to the crate attributes to enable\n \n warning: use of deprecated item 'deprecated_macro': deprecation reason\n   --> $DIR/macro-stability.rs:24:5\n    |\n LL |     deprecated_macro!();\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^\n    |\n    = note: #[warn(deprecated)] on by default\n \n warning: use of deprecated item 'local_deprecated': local deprecation reason\n   --> $DIR/macro-stability.rs:26:5\n    |\n LL |     local_deprecated!();\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "fc05012377b2a33121d58da57683f772b1d399d9", "filename": "src/test/ui/macros/trace_faulty_macros.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -45,8 +45,6 @@ LL |     my_recursive_macro!();\n    = note: to `my_recursive_macro ! (  ) ;`\n    = note: expanding `my_recursive_macro! {  }`\n    = note: to `my_recursive_macro ! (  ) ;`\n-   = note: expanding `my_recursive_macro! {  }`\n-   = note: to `my_recursive_macro ! (  ) ;`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7a9e472c6c3eeccfee2a099ff32634e22a73fcf3", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -25,22 +25,32 @@ fn check_bang1() {\n     my_macro!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n }\n fn check_bang2() {\n-    my_macro_attr!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n+    my_macro_attr!(); //~ ERROR cannot find macro `my_macro_attr!` in this scope\n+    crate::my_macro_attr!(); //~ ERROR can't use a procedural macro from the same crate that defines\n+                             //~| ERROR expected macro, found attribute macro `crate::my_macro_attr`\n }\n fn check_bang3() {\n-    MyTrait!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n+    MyTrait!(); //~ ERROR cannot find macro `MyTrait!` in this scope\n+    crate::MyTrait!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n+                       //~| ERROR expected macro, found derive macro `crate::MyTrait`\n }\n \n-#[my_macro] //~ ERROR can't use a procedural macro from the same crate that defines it\n+#[my_macro] //~ ERROR attribute `my_macro` is currently unknown\n+#[crate::my_macro] //~ ERROR can't use a procedural macro from the same crate that defines it\n+                   //~| ERROR expected attribute, found macro `crate::my_macro`\n fn check_attr1() {}\n #[my_macro_attr] //~ ERROR can't use a procedural macro from the same crate that defines it\n fn check_attr2() {}\n #[MyTrait] //~ ERROR can't use a procedural macro from the same crate that defines it\n+           //~| ERROR expected attribute, found derive macro `MyTrait`\n fn check_attr3() {}\n \n-#[derive(my_macro)] //~ ERROR can't use a procedural macro from the same crate that defines it\n+#[derive(my_macro)] //~ ERROR cannot find derive macro `my_macro` in this scope\n+#[derive(crate::my_macro)] //~ ERROR can't use a procedural macro from the same crate that defines\n+                           //~| ERROR expected derive macro, found macro `crate::my_macro`\n struct CheckDerive1;\n #[derive(my_macro_attr)] //~ ERROR can't use a procedural macro from the same crate that defines it\n+                         //~| ERROR expected derive macro, found attribute macro `my_macro_attr`\n struct CheckDerive2;\n #[derive(MyTrait)] //~ ERROR can't use a procedural macro from the same crate that defines it\n struct CheckDerive3;"}, {"sha": "8a5e346c2b59fc8df0d3437bd9cee738a6d03645", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.stderr", "status": "modified", "additions": 82, "deletions": 18, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -5,52 +5,116 @@ LL |     my_macro!();\n    |     ^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:28:5\n+  --> $DIR/macro-namespace-reserved-2.rs:29:5\n    |\n-LL |     my_macro_attr!();\n-   |     ^^^^^^^^^^^^^\n+LL |     crate::my_macro_attr!();\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n-error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:31:5\n+error: expected macro, found attribute macro `crate::my_macro_attr`\n+  --> $DIR/macro-namespace-reserved-2.rs:29:5\n    |\n-LL |     MyTrait!();\n-   |     ^^^^^^^\n+LL |     crate::my_macro_attr!();\n+   |     ^^^^^^^^^^^^^^^^^^^^ not a macro\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:34:3\n+  --> $DIR/macro-namespace-reserved-2.rs:34:5\n    |\n-LL | #[my_macro]\n-   |   ^^^^^^^^\n+LL |     crate::MyTrait!();\n+   |     ^^^^^^^^^^^^^^\n+\n+error: expected macro, found derive macro `crate::MyTrait`\n+  --> $DIR/macro-namespace-reserved-2.rs:34:5\n+   |\n+LL |     crate::MyTrait!();\n+   |     ^^^^^^^^^^^^^^ not a macro\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:36:3\n+  --> $DIR/macro-namespace-reserved-2.rs:42:3\n    |\n LL | #[my_macro_attr]\n    |   ^^^^^^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:38:3\n+  --> $DIR/macro-namespace-reserved-2.rs:44:3\n    |\n LL | #[MyTrait]\n    |   ^^^^^^^\n \n+error: expected attribute, found derive macro `MyTrait`\n+  --> $DIR/macro-namespace-reserved-2.rs:44:3\n+   |\n+LL | #[MyTrait]\n+   |   ^^^^^^^ not an attribute\n+\n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:41:10\n+  --> $DIR/macro-namespace-reserved-2.rs:49:10\n    |\n-LL | #[derive(my_macro)]\n-   |          ^^^^^^^^\n+LL | #[derive(crate::my_macro)]\n+   |          ^^^^^^^^^^^^^^^\n+\n+error: expected derive macro, found macro `crate::my_macro`\n+  --> $DIR/macro-namespace-reserved-2.rs:49:10\n+   |\n+LL | #[derive(crate::my_macro)]\n+   |          ^^^^^^^^^^^^^^^ not a derive macro\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:43:10\n+  --> $DIR/macro-namespace-reserved-2.rs:52:10\n    |\n LL | #[derive(my_macro_attr)]\n    |          ^^^^^^^^^^^^^\n \n+error: expected derive macro, found attribute macro `my_macro_attr`\n+  --> $DIR/macro-namespace-reserved-2.rs:52:10\n+   |\n+LL | #[derive(my_macro_attr)]\n+   |          ^^^^^^^^^^^^^ not a derive macro\n+\n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:45:10\n+  --> $DIR/macro-namespace-reserved-2.rs:55:10\n    |\n LL | #[derive(MyTrait)]\n    |          ^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error[E0658]: The attribute `my_macro` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/macro-namespace-reserved-2.rs:38:3\n+   |\n+LL | #[my_macro]\n+   |   ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add `#![feature(custom_attribute)]` to the crate attributes to enable\n+\n+error: can't use a procedural macro from the same crate that defines it\n+  --> $DIR/macro-namespace-reserved-2.rs:39:3\n+   |\n+LL | #[crate::my_macro]\n+   |   ^^^^^^^^^^^^^^^\n+\n+error: expected attribute, found macro `crate::my_macro`\n+  --> $DIR/macro-namespace-reserved-2.rs:39:3\n+   |\n+LL | #[crate::my_macro]\n+   |   ^^^^^^^^^^^^^^^ not an attribute\n+\n+error: cannot find derive macro `my_macro` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:48:10\n+   |\n+LL | #[derive(my_macro)]\n+   |          ^^^^^^^^\n+\n+error: cannot find macro `my_macro_attr!` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:28:5\n+   |\n+LL |     my_macro_attr!();\n+   |     ^^^^^^^^^^^^^\n+\n+error: cannot find macro `MyTrait!` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:33:5\n+   |\n+LL |     MyTrait!();\n+   |     ^^^^^^^\n+\n+error: aborting due to 19 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "c581a16dbb038ad7bdc6615e3b4f8ff022063718", "filename": "src/test/ui/rust-unstable-column-gated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Frust-unstable-column-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Frust-unstable-column-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-unstable-column-gated.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature '__rust_unstable_column': internal\n   --> $DIR/rust-unstable-column-gated.rs:2:20\n    |\n LL |     println!(\"{}\", __rust_unstable_column!());\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(__rust_unstable_column)]` to the crate attributes to enable\n "}, {"sha": "b5666e4ea7072044a753d42143b32111c1d8cc9f", "filename": "src/test/ui/tool-attributes/tool-attributes-misplaced-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.rs?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,6 +1,6 @@\n-#[derive(rustfmt::skip)] //~ ERROR expected a macro, found tool attribute\n+#[derive(rustfmt::skip)] //~ ERROR expected derive macro, found tool attribute `rustfmt::skip`\n struct S;\n \n fn main() {\n-    rustfmt::skip!(); //~ ERROR expected a macro, found tool attribute\n+    rustfmt::skip!(); //~ ERROR expected macro, found tool attribute `rustfmt::skip`\n }"}, {"sha": "6d0f826e621c5ebca64e9ce74982fc9a00d2e08d", "filename": "src/test/ui/tool-attributes/tool-attributes-misplaced-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -1,14 +1,14 @@\n-error: expected a macro, found tool attribute\n+error: expected derive macro, found tool attribute `rustfmt::skip`\n   --> $DIR/tool-attributes-misplaced-2.rs:1:10\n    |\n LL | #[derive(rustfmt::skip)]\n-   |          ^^^^^^^^^^^^^\n+   |          ^^^^^^^^^^^^^ not a derive macro\n \n-error: expected a macro, found tool attribute\n+error: expected macro, found tool attribute `rustfmt::skip`\n   --> $DIR/tool-attributes-misplaced-2.rs:5:5\n    |\n LL |     rustfmt::skip!();\n-   |     ^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^ not a macro\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7b9542730713cf4a58157418201c3d89bd810e35", "filename": "src/test/ui/trace_macros-gate.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ftrace_macros-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69070058cd2fdb57ebbbbef94892cfb5688ce27f/src%2Ftest%2Fui%2Ftrace_macros-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrace_macros-gate.stderr?ref=69070058cd2fdb57ebbbbef94892cfb5688ce27f", "patch": "@@ -2,7 +2,7 @@ error[E0658]: use of unstable library feature 'trace_macros': `trace_macros` is\n   --> $DIR/trace_macros-gate.rs:4:5\n    |\n LL |     trace_macros!();\n-   |     ^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29598\n    = help: add `#![feature(trace_macros)]` to the crate attributes to enable\n@@ -17,7 +17,7 @@ error[E0658]: use of unstable library feature 'trace_macros': `trace_macros` is\n   --> $DIR/trace_macros-gate.rs:6:5\n    |\n LL |     trace_macros!(true);\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29598\n    = help: add `#![feature(trace_macros)]` to the crate attributes to enable\n@@ -26,7 +26,7 @@ error[E0658]: use of unstable library feature 'trace_macros': `trace_macros` is\n   --> $DIR/trace_macros-gate.rs:7:5\n    |\n LL |     trace_macros!(false);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29598\n    = help: add `#![feature(trace_macros)]` to the crate attributes to enable\n@@ -35,7 +35,7 @@ error[E0658]: use of unstable library feature 'trace_macros': `trace_macros` is\n   --> $DIR/trace_macros-gate.rs:10:26\n    |\n LL |         ($x: ident) => { trace_macros!($x) }\n-   |                          ^^^^^^^^^^^^^^^^^\n+   |                          ^^^^^^^^^^^^\n ...\n LL |     expando!(true);\n    |     --------------- in this macro invocation"}]}