{"sha": "2e7e131b8e4ee2addf7f0ae64108a4da8210b369", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlN2UxMzFiOGU0ZWUyYWRkZjdmMGFlNjQxMDhhNGRhODIxMGIzNjk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-20T06:36:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-20T06:36:00Z"}, "message": "Rollup merge of #60772 - timvermeulen:slice_iter_nth_back, r=scottmcm\n\nImplement nth_back for slice::{Iter, IterMut}\n\nPart of #54054.\n\nI implemented `nth_back` as straightforwardly as I could, and then slightly changed `nth` to match `nth_back`. I believe I did so correctly, but please double-check \ud83d\ude42\n\nI also added the helper methods `zst_shrink`, `next_unchecked`, and `next_back_unchecked` to get rid of some duplicated code. These changes hopefully make this code easier to understand for new contributors like me.\n\nI noticed the `is_empty!` and `len!` macros which sole purpose seems to be inlining, according to the comment right above them, but the `is_empty` and `len` methods are already marked with `#[inline(always)]`. Does that mean we could replace these macros with method calls, without affecting anything? I'd love to get rid of them.", "tree": {"sha": "8dcbda7e14fc1eaaef6a1593c9b4673405d9864e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dcbda7e14fc1eaaef6a1593c9b4673405d9864e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e7e131b8e4ee2addf7f0ae64108a4da8210b369", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdCylQCRBK7hj4Ov3rIwAAdHIIAAG77yGaOx8abbGwMD+F42Oy\nqxDVRlNhtDOOnmdpcycUgeowQN4k5bcB4hzuX/yKiPTgUldjYEnztIz0AroO5ev4\ndrHxwK9WCdVstRhZVYr68Wn5tHWQezWSajFaFstRyR6zWwuBN7Y7T61oXO1moG3s\nRQJXP7wVTz3RnEWASP0geoLO7GNsGBJhyU5MeqHejtTqI6YVXLVoGulmsQ9EdawN\nO84YGMTNEnxB43c/9XL7m2x/VewwFvVxbj9JGosxDRqLCgl1SkX37Frwdk4gcVgQ\n6w/QCwgklFoSIxLOhyBrAQW3tMYUSfMb+13hAPhviY5rEHWrcbiyCAXDYBNYl1c=\n=zDM9\n-----END PGP SIGNATURE-----\n", "payload": "tree 8dcbda7e14fc1eaaef6a1593c9b4673405d9864e\nparent 3e08f1b57ea6df87ee2d01f31339958998f8ea26\nparent 97a6c932e02fcd7f55fdad9aef76c5619f91f481\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1561012560 +0200\ncommitter GitHub <noreply@github.com> 1561012560 +0200\n\nRollup merge of #60772 - timvermeulen:slice_iter_nth_back, r=scottmcm\n\nImplement nth_back for slice::{Iter, IterMut}\n\nPart of #54054.\n\nI implemented `nth_back` as straightforwardly as I could, and then slightly changed `nth` to match `nth_back`. I believe I did so correctly, but please double-check \ud83d\ude42\n\nI also added the helper methods `zst_shrink`, `next_unchecked`, and `next_back_unchecked` to get rid of some duplicated code. These changes hopefully make this code easier to understand for new contributors like me.\n\nI noticed the `is_empty!` and `len!` macros which sole purpose seems to be inlining, according to the comment right above them, but the `is_empty` and `len` methods are already marked with `#[inline(always)]`. Does that mean we could replace these macros with method calls, without affecting anything? I'd love to get rid of them.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7e131b8e4ee2addf7f0ae64108a4da8210b369", "html_url": "https://github.com/rust-lang/rust/commit/2e7e131b8e4ee2addf7f0ae64108a4da8210b369", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e7e131b8e4ee2addf7f0ae64108a4da8210b369/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e08f1b57ea6df87ee2d01f31339958998f8ea26", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e08f1b57ea6df87ee2d01f31339958998f8ea26", "html_url": "https://github.com/rust-lang/rust/commit/3e08f1b57ea6df87ee2d01f31339958998f8ea26"}, {"sha": "97a6c932e02fcd7f55fdad9aef76c5619f91f481", "url": "https://api.github.com/repos/rust-lang/rust/commits/97a6c932e02fcd7f55fdad9aef76c5619f91f481", "html_url": "https://github.com/rust-lang/rust/commit/97a6c932e02fcd7f55fdad9aef76c5619f91f481"}], "stats": {"total": 89, "additions": 68, "deletions": 21}, "files": [{"sha": "c6d44324ef5ee16a8eb81464f3420ccc3ece5fc7", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2e7e131b8e4ee2addf7f0ae64108a4da8210b369/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7e131b8e4ee2addf7f0ae64108a4da8210b369/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2e7e131b8e4ee2addf7f0ae64108a4da8210b369", "patch": "@@ -3019,6 +3019,28 @@ macro_rules! iterator {\n         {$( $mut_:tt )*},\n         {$($extra:tt)*}\n     ) => {\n+        // Returns the first element and moves the start of the iterator forwards by 1.\n+        // Greatly improves performance compared to an inlined function. The iterator\n+        // must not be empty.\n+        macro_rules! next_unchecked {\n+            ($self: ident) => {& $( $mut_ )* *$self.post_inc_start(1)}\n+        }\n+\n+        // Returns the last element and moves the end of the iterator backwards by 1.\n+        // Greatly improves performance compared to an inlined function. The iterator\n+        // must not be empty.\n+        macro_rules! next_back_unchecked {\n+            ($self: ident) => {& $( $mut_ )* *$self.pre_dec_end(1)}\n+        }\n+\n+        // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n+        // backwards by `n`. `n` must not exceed `self.len()`.\n+        macro_rules! zst_shrink {\n+            ($self: ident, $n: ident) => {\n+                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;\n+            }\n+        }\n+\n         impl<'a, T> $name<'a, T> {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n@@ -3028,12 +3050,11 @@ macro_rules! iterator {\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n             // returning the old start.\n-            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n-                    // This is *reducing* the length.  `ptr` never changes with ZST.\n-                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n+                    zst_shrink!(self, offset);\n                     self.ptr\n                 } else {\n                     let old = self.ptr;\n@@ -3044,11 +3065,11 @@ macro_rules! iterator {\n \n             // Helper function for moving the end of the iterator backwards by `offset` elements,\n             // returning the new end.\n-            // Unsafe because the offset must be in-bounds or one-past-the-end.\n+            // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n-                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n+                    zst_shrink!(self, offset);\n                     self.ptr\n                 } else {\n                     self.end = self.end.offset(-offset);\n@@ -3085,7 +3106,7 @@ macro_rules! iterator {\n                     if is_empty!(self) {\n                         None\n                     } else {\n-                        Some(& $( $mut_ )* *self.post_inc_start(1))\n+                        Some(next_unchecked!(self))\n                     }\n                 }\n             }\n@@ -3114,11 +3135,10 @@ macro_rules! iterator {\n                     }\n                     return None;\n                 }\n-                // We are in bounds. `offset` does the right thing even for ZSTs.\n+                // We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                 unsafe {\n-                    let elem = Some(& $( $mut_ )* *self.ptr.add(n));\n-                    self.post_inc_start((n as isize).wrapping_add(1));\n-                    elem\n+                    self.post_inc_start(n as isize);\n+                    Some(next_unchecked!(self))\n                 }\n             }\n \n@@ -3135,13 +3155,13 @@ macro_rules! iterator {\n                 let mut accum = init;\n                 unsafe {\n                     while len!(self) >= 4 {\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n                     }\n                     while !is_empty!(self) {\n-                        accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n+                        accum = f(accum, next_unchecked!(self))?;\n                     }\n                 }\n                 Try::from_ok(accum)\n@@ -3212,11 +3232,25 @@ macro_rules! iterator {\n                     if is_empty!(self) {\n                         None\n                     } else {\n-                        Some(& $( $mut_ )* *self.pre_dec_end(1))\n+                        Some(next_back_unchecked!(self))\n                     }\n                 }\n             }\n \n+            #[inline]\n+            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n+                if n >= len!(self) {\n+                    // This iterator is now empty.\n+                    self.end = self.ptr;\n+                    return None;\n+                }\n+                // We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n+                unsafe {\n+                    self.pre_dec_end(n as isize);\n+                    Some(next_back_unchecked!(self))\n+                }\n+            }\n+\n             #[inline]\n             fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n                 Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n@@ -3225,14 +3259,14 @@ macro_rules! iterator {\n                 let mut accum = init;\n                 unsafe {\n                     while len!(self) >= 4 {\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n                     }\n                     // inlining is_empty everywhere makes a huge performance difference\n                     while !is_empty!(self) {\n-                        accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n+                        accum = f(accum, next_back_unchecked!(self))?;\n                     }\n                 }\n                 Try::from_ok(accum)"}, {"sha": "03e65d2fe0b81022ec341bdcfb4f89a54c9af5b1", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e7e131b8e4ee2addf7f0ae64108a4da8210b369/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7e131b8e4ee2addf7f0ae64108a4da8210b369/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=2e7e131b8e4ee2addf7f0ae64108a4da8210b369", "patch": "@@ -88,6 +88,19 @@ fn test_iterator_nth() {\n     assert_eq!(iter.nth(1).unwrap(), &v[4]);\n }\n \n+#[test]\n+fn test_iterator_nth_back() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().nth_back(i).unwrap(), &v[v.len() - i - 1]);\n+    }\n+    assert_eq!(v.iter().nth_back(v.len()), None);\n+\n+    let mut iter = v.iter();\n+    assert_eq!(iter.nth_back(2).unwrap(), &v[2]);\n+    assert_eq!(iter.nth_back(1).unwrap(), &v[0]);\n+}\n+\n #[test]\n fn test_iterator_last() {\n     let v: &[_] = &[0, 1, 2, 3, 4];"}]}