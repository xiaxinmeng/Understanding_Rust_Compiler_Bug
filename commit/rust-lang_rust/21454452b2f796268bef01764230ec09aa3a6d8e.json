{"sha": "21454452b2f796268bef01764230ec09aa3a6d8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNDU0NDUyYjJmNzk2MjY4YmVmMDE3NjQyMzBlYzA5YWEzYTZkOGU=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2014-03-04T06:00:46Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2014-03-04T07:41:57Z"}, "message": "rustc: Streamline error messages for i18n, using `plural` whenever possible.", "tree": {"sha": "9fb303f15569cbc33b9796c052c18e57ac9fde97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb303f15569cbc33b9796c052c18e57ac9fde97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21454452b2f796268bef01764230ec09aa3a6d8e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21454452b2f796268bef01764230ec09aa3a6d8e", "html_url": "https://github.com/rust-lang/rust/commit/21454452b2f796268bef01764230ec09aa3a6d8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21454452b2f796268bef01764230ec09aa3a6d8e/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c0d0987be7967bef3f6a368452a7b65038dbf17", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c0d0987be7967bef3f6a368452a7b65038dbf17", "html_url": "https://github.com/rust-lang/rust/commit/3c0d0987be7967bef3f6a368452a7b65038dbf17"}], "stats": {"total": 221, "additions": 114, "deletions": 107}, "files": [{"sha": "8871f0bf61fb2d85a90bb7efbfdc6f5e27d7f4c1", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/21454452b2f796268bef01764230ec09aa3a6d8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21454452b2f796268bef01764230ec09aa3a6d8e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=21454452b2f796268bef01764230ec09aa3a6d8e", "patch": "@@ -376,17 +376,14 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                     ast_map::NodeExpr(e) => e.span,\n                     _ => fail!(\"transmute has non-expr arg\"),\n                 };\n-                let pluralize = |n| if 1 == n { \"\" } else { \"s\" };\n                 ccx.sess.span_fatal(sp,\n-                                    format!(\"transmute called on types with \\\n-                                          different sizes: {} ({} bit{}) to \\\n-                                          {} ({} bit{})\",\n-                                         ty_to_str(ccx.tcx, in_type),\n-                                         in_type_size,\n-                                         pluralize(in_type_size),\n-                                         ty_to_str(ccx.tcx, out_type),\n-                                         out_type_size,\n-                                         pluralize(out_type_size)));\n+                    format!(\"transmute called on types with different sizes: \\\n+                             {intype} ({insize, plural, =1{# bit} other{# bits}}) to \\\n+                             {outtype} ({outsize, plural, =1{# bit} other{# bits}})\",\n+                            intype = ty_to_str(ccx.tcx, in_type),\n+                            insize = in_type_size as uint,\n+                            outtype = ty_to_str(ccx.tcx, out_type),\n+                            outsize = out_type_size as uint));\n             }\n \n             if !return_type_is_void(ccx, out_type) {"}, {"sha": "6aeedad3012c90f08318f73fddb66caf78791a74", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/21454452b2f796268bef01764230ec09aa3a6d8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21454452b2f796268bef01764230ec09aa3a6d8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=21454452b2f796268bef01764230ec09aa3a6d8e", "patch": "@@ -247,12 +247,13 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n     if arg_len > 0 {\n         // N-ary variant.\n         if arg_len != subpats_len {\n-            let s = format!(\"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                         subpats_len,\n-                         if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n-                         kind_name,\n-                         arg_len,\n-                         if arg_len == 1u { ~\"\" } else { ~\"s\" });\n+            let s = format!(\"this pattern has \\\n+                             {npat, plural, =1{# field} other{# fields}}, \\\n+                             but the corresponding {kind} has \\\n+                             {narg, plural, =1{# field} other{# fields}}\",\n+                         npat = subpats_len,\n+                         kind = kind_name,\n+                         narg = arg_len);\n             tcx.sess.span_err(pat.span, s);\n             error_happened = true;\n         }\n@@ -266,11 +267,11 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n         }\n     } else if subpats_len > 0 {\n         tcx.sess.span_err(pat.span,\n-                          format!(\"this pattern has {} field{}, but the corresponding {} has no \\\n-                                fields\",\n-                               subpats_len,\n-                               if subpats_len == 1u { \"\" } else { \"s\" },\n-                               kind_name));\n+                          format!(\"this pattern has \\\n+                                   {npat, plural, =1{# field} other{# fields}}, \\\n+                                   but the corresponding {kind} has no fields\",\n+                               npat = subpats_len,\n+                               kind = kind_name));\n         error_happened = true;\n     }\n "}, {"sha": "f68bdcf3131cf428f5bc7d1849f3778be17c079c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 93, "deletions": 84, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/21454452b2f796268bef01764230ec09aa3a6d8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21454452b2f796268bef01764230ec09aa3a6d8e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=21454452b2f796268bef01764230ec09aa3a6d8e", "patch": "@@ -813,24 +813,26 @@ fn compare_impl_method(tcx: ty::ctxt,\n     if num_impl_m_type_params != num_trait_m_type_params {\n         tcx.sess.span_err(\n             impl_m_span,\n-            format!(\"method `{}` has {} type parameter(s), but its trait \\\n-                    declaration has {} type parameter(s)\",\n-                    token::get_ident(trait_m.ident),\n-                    num_impl_m_type_params,\n-                    num_trait_m_type_params));\n+            format!(\"method `{method}` has {nimpl, plural, =1{# type parameter} \\\n+                                                        other{# type parameters}}, \\\n+                     but its trait declaration has {ntrait, plural, =1{# type parameter} \\\n+                                                                 other{# type parameters}}\",\n+                    method = token::get_ident(trait_m.ident),\n+                    nimpl = num_impl_m_type_params,\n+                    ntrait = num_trait_m_type_params));\n         return;\n     }\n \n     if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n         tcx.sess.span_err(\n             impl_m_span,\n-            format!(\"method `{}` has {} parameter{} \\\n-                  but the declaration in trait `{}` has {}\",\n-                 token::get_ident(trait_m.ident),\n-                 impl_m.fty.sig.inputs.len(),\n-                 if impl_m.fty.sig.inputs.len() == 1 { \"\" } else { \"s\" },\n-                 ty::item_path_str(tcx, trait_m.def_id),\n-                 trait_m.fty.sig.inputs.len()));\n+            format!(\"method `{method}` has {nimpl, plural, =1{# parameter} \\\n+                                                        other{# parameters}} \\\n+                     but the declaration in trait `{trait}` has {ntrait}\",\n+                 method = token::get_ident(trait_m.ident),\n+                 nimpl = impl_m.fty.sig.inputs.len(),\n+                 trait = ty::item_path_str(tcx, trait_m.def_id),\n+                 ntrait = trait_m.fty.sig.inputs.len()));\n         return;\n     }\n \n@@ -865,13 +867,16 @@ fn compare_impl_method(tcx: ty::ctxt,\n         {\n             tcx.sess.span_err(\n                 impl_m_span,\n-                format!(\"in method `{}`, \\\n-                        type parameter {} has {} trait bound(s), but the \\\n-                        corresponding type parameter in \\\n-                        the trait declaration has {} trait bound(s)\",\n-                        token::get_ident(trait_m.ident),\n-                        i, impl_param_def.bounds.trait_bounds.len(),\n-                        trait_param_def.bounds.trait_bounds.len()));\n+                format!(\"in method `{method}`, \\\n+                        type parameter {typaram} has \\\n+                        {nimpl, plural, =1{# trait bound} other{# trait bounds}}, \\\n+                        but the corresponding type parameter in \\\n+                        the trait declaration has \\\n+                        {ntrait, plural, =1{# trait bound} other{# trait bounds}}\",\n+                        method = token::get_ident(trait_m.ident),\n+                        typaram = i,\n+                        nimpl = impl_param_def.bounds.trait_bounds.len(),\n+                        ntrait = trait_param_def.bounds.trait_bounds.len()));\n             return;\n         }\n     }\n@@ -1507,10 +1512,12 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n                 function_context.tcx()\n                     .sess\n                     .span_err(path.span,\n-                              format!(\"expected {} lifetime parameter(s), \\\n-                                      found {} lifetime parameter(s)\",\n-                                      trait_region_parameter_count,\n-                                      supplied_region_parameter_count));\n+                              format!(\"expected {nexpected, plural, =1{# lifetime parameter} \\\n+                                                                 other{# lifetime parameters}}, \\\n+                                       found {nsupplied, plural, =1{# lifetime parameter} \\\n+                                                              other{# lifetime parameters}}\",\n+                                      nexpected = trait_region_parameter_count,\n+                                      nsupplied = supplied_region_parameter_count));\n             }\n \n             // Make sure the number of type parameters supplied on the trait\n@@ -1522,49 +1529,47 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n                                                   .len();\n             let supplied_ty_param_count = trait_segment.types.len();\n             if supplied_ty_param_count < required_ty_param_count {\n-                let trait_count_suffix = if required_ty_param_count == 1 {\n-                    \"\"\n-                } else {\n-                    \"s\"\n-                };\n-                let supplied_count_suffix = if supplied_ty_param_count == 1 {\n-                    \"\"\n+                let msg = if required_ty_param_count < generics.type_param_defs().len() {\n+                    format!(\"the {trait_or_impl} referenced by this path needs at least \\\n+                             {nexpected, plural, =1{# type parameter} \\\n+                                              other{# type parameters}}, \\\n+                             but {nsupplied, plural, =1{# type parameter} \\\n+                                                  other{# type parameters}} were supplied\",\n+                            trait_or_impl = name,\n+                            nexpected = required_ty_param_count,\n+                            nsupplied = supplied_ty_param_count)\n                 } else {\n-                    \"s\"\n+                    format!(\"the {trait_or_impl} referenced by this path needs \\\n+                             {nexpected, plural, =1{# type parameter} \\\n+                                              other{# type parameters}}, \\\n+                             but {nsupplied, plural, =1{# type parameter} \\\n+                                                  other{# type parameters}} were supplied\",\n+                            trait_or_impl = name,\n+                            nexpected = required_ty_param_count,\n+                            nsupplied = supplied_ty_param_count)\n                 };\n-                let needs = if required_ty_param_count < generics.type_param_defs().len() {\n-                    \"needs at least\"\n-                } else {\n-                    \"needs\"\n-                };\n-                function_context.tcx().sess.span_err(path.span,\n-                    format!(\"the {} referenced by this path {} {} type \\\n-                            parameter{}, but {} type parameter{} were supplied\",\n-                            name, needs,\n-                            required_ty_param_count, trait_count_suffix,\n-                            supplied_ty_param_count, supplied_count_suffix))\n+                function_context.tcx().sess.span_err(path.span, msg)\n             } else if supplied_ty_param_count > formal_ty_param_count {\n-                let trait_count_suffix = if formal_ty_param_count == 1 {\n-                    \"\"\n+                let msg = if required_ty_param_count < generics.type_param_defs().len() {\n+                    format!(\"the {trait_or_impl} referenced by this path needs at most \\\n+                             {nexpected, plural, =1{# type parameter} \\\n+                                              other{# type parameters}}, \\\n+                             but {nsupplied, plural, =1{# type parameter} \\\n+                                                  other{# type parameters}} were supplied\",\n+                            trait_or_impl = name,\n+                            nexpected = formal_ty_param_count,\n+                            nsupplied = supplied_ty_param_count)\n                 } else {\n-                    \"s\"\n+                    format!(\"the {trait_or_impl} referenced by this path needs \\\n+                             {nexpected, plural, =1{# type parameter} \\\n+                                              other{# type parameters}}, \\\n+                             but {nsupplied, plural, =1{# type parameter} \\\n+                                                  other{# type parameters}} were supplied\",\n+                            trait_or_impl = name,\n+                            nexpected = formal_ty_param_count,\n+                            nsupplied = supplied_ty_param_count)\n                 };\n-                let supplied_count_suffix = if supplied_ty_param_count == 1 {\n-                    \"\"\n-                } else {\n-                    \"s\"\n-                };\n-                let needs = if required_ty_param_count < generics.type_param_defs().len() {\n-                    \"needs at most\"\n-                } else {\n-                    \"needs\"\n-                };\n-                function_context.tcx().sess.span_err(path.span,\n-                    format!(\"the {} referenced by this path {} {} type \\\n-                            parameter{}, but {} type parameter{} were supplied\",\n-                            name, needs,\n-                            formal_ty_param_count, trait_count_suffix,\n-                            supplied_ty_param_count, supplied_count_suffix))\n+                function_context.tcx().sess.span_err(path.span, msg)\n             }\n         }\n         _ => {\n@@ -1665,24 +1670,25 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 fn_inputs.map(|a| *a)\n             } else {\n                 let msg = format!(\n-                    \"this function takes at least {} parameter{} \\\n-                     but {} parameter{} supplied\",\n-                     expected_arg_count,\n-                     if expected_arg_count == 1 {\"\"} else {\"s\"},\n-                     supplied_arg_count,\n-                     if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n+                    \"this function takes at least {nexpected, plural, =1{# parameter} \\\n+                                                                   other{# parameters}} \\\n+                     but {nsupplied, plural, =1{# parameter was} \\\n+                                          other{# parameters were}} supplied\",\n+                     nexpected = expected_arg_count,\n+                     nsupplied = supplied_arg_count);\n \n                 tcx.sess.span_err(sp, msg);\n \n                 err_args(supplied_arg_count)\n             }\n         } else {\n             let msg = format!(\n-                \"this function takes {} parameter{} \\\n-                 but {} parameter{} supplied\",\n-                 expected_arg_count, if expected_arg_count == 1 {\"\"} else {\"s\"},\n-                 supplied_arg_count,\n-                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n+                \"this function takes {nexpected, plural, =1{# parameter} \\\n+                                                      other{# parameters}} \\\n+                 but {nsupplied, plural, =1{# parameter was} \\\n+                                      other{# parameters were}} supplied\",\n+                 nexpected = expected_arg_count,\n+                 nsupplied = supplied_arg_count);\n \n             tcx.sess.span_err(sp, msg);\n \n@@ -2384,13 +2390,9 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 }\n \n                 tcx.sess.span_err(span,\n-                                  format!(\"missing field{}: {}\",\n-                                       if missing_fields.len() == 1 {\n-                                           \"\"\n-                                       } else {\n-                                           \"s\"\n-                                       },\n-                                       missing_fields.connect(\", \")));\n+                    format!(\"missing {nfields, plural, =1{field} other{fields}}: {fields}\",\n+                            nfields = missing_fields.len(),\n+                            fields = missing_fields.connect(\", \")));\n              }\n         }\n \n@@ -3556,8 +3558,12 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n \n     let hint = ty::lookup_repr_hint(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id });\n     if hint != attr::ReprAny && vs.len() <= 1 {\n-        ccx.tcx.sess.span_err(sp, format!(\"unsupported representation for {}variant enum\",\n-                                          if vs.len() == 1 { \"uni\" } else { \"zero-\" }))\n+        let msg = if vs.len() == 1 {\n+            \"unsupported representation for univariant enum\"\n+        } else {\n+            \"unsupported representation for zero-variant enum\"\n+        };\n+        ccx.tcx.sess.span_err(sp, msg)\n     }\n \n     let variants = do_check(ccx, vs, id, hint);\n@@ -3666,9 +3672,12 @@ pub fn instantiate_path(fcx: @FnCtxt,\n         if num_supplied_regions != 0 {\n             fcx.ccx.tcx.sess.span_err(\n                 span,\n-                format!(\"expected {} lifetime parameter(s), \\\n-                        found {} lifetime parameter(s)\",\n-                        num_expected_regions, num_supplied_regions));\n+                format!(\"expected {nexpected, plural, =1{# lifetime parameter} \\\n+                                                   other{# lifetime parameters}}, \\\n+                         found {nsupplied, plural, =1{# lifetime parameter} \\\n+                                                other{# lifetime parameters}}\",\n+                        nexpected = num_expected_regions,\n+                        nsupplied = num_supplied_regions));\n         }\n \n         opt_vec::from(fcx.infcx().next_region_vars("}, {"sha": "12e54d09de5f383804efa2ced63c1978ac233e2e", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21454452b2f796268bef01764230ec09aa3a6d8e/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21454452b2f796268bef01764230ec09aa3a6d8e/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=21454452b2f796268bef01764230ec09aa3a6d8e", "patch": "@@ -43,10 +43,10 @@ impl Trait<int> for S2 {\n fn foo<'a>() {\n     let _ = S::new::<int,f64>(1, 1.0);\n     //~^ ERROR the impl referenced by this path needs 1 type parameter, but 0 type parameters were supplied\n-    let _ = S::<'a,int>::new::<f64>(1, 1.0); //~ ERROR expected 0 lifetime parameter(s)\n+    let _ = S::<'a,int>::new::<f64>(1, 1.0); //~ ERROR expected 0 lifetime parameters\n     let _: S2 = Trait::new::<int,f64>(1, 1.0);\n     //~^ ERROR the trait referenced by this path needs 1 type parameter, but 0 type parameters were supplied\n-    let _: S2 = Trait::<'a,int>::new::<f64>(1, 1.0); //~ ERROR expected 0 lifetime parameter(s)\n+    let _: S2 = Trait::<'a,int>::new::<f64>(1, 1.0); //~ ERROR expected 0 lifetime parameters\n }\n \n fn main() {}"}]}