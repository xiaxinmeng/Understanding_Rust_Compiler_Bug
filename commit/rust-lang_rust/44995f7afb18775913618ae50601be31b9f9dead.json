{"sha": "44995f7afb18775913618ae50601be31b9f9dead", "node_id": "C_kwDOAAsO6NoAKDQ0OTk1ZjdhZmIxODc3NTkxMzYxOGFlNTA2MDFiZTMxYjlmOWRlYWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-08T09:04:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-08T09:04:06Z"}, "message": "Auto merge of #89619 - michaelwoerister:incr-vtables, r=nagisa\n\nTurn vtable_allocation() into a query\n\nThis PR removes the untracked vtable-const-allocation cache from the `tcx` and turns the `vtable_allocation()` method into a query.\n\nThe change is pretty straightforward and should be backportable without too much effort.\n\nFixes https://github.com/rust-lang/rust/issues/89598.", "tree": {"sha": "77ac1030bbb38e9c80d35297293ca06b10e166fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77ac1030bbb38e9c80d35297293ca06b10e166fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44995f7afb18775913618ae50601be31b9f9dead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44995f7afb18775913618ae50601be31b9f9dead", "html_url": "https://github.com/rust-lang/rust/commit/44995f7afb18775913618ae50601be31b9f9dead", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44995f7afb18775913618ae50601be31b9f9dead/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3013b26947e956352f95edfa39251319520cb06c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3013b26947e956352f95edfa39251319520cb06c", "html_url": "https://github.com/rust-lang/rust/commit/3013b26947e956352f95edfa39251319520cb06c"}, {"sha": "b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "html_url": "https://github.com/rust-lang/rust/commit/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573"}], "stats": {"total": 207, "additions": 125, "deletions": 82}, "files": [{"sha": "36b3725ef42bce5ad62f38288b64dad9b5c62be1", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -68,7 +68,7 @@ pub(crate) fn get_vtable<'tcx>(\n     ty: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let alloc_id = fx.tcx.vtable_allocation(ty, trait_ref);\n+    let alloc_id = fx.tcx.vtable_allocation((ty, trait_ref));\n     let data_id =\n         data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.module, alloc_id, Mutability::Not);\n     let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);"}, {"sha": "3267d3206f73f45bb55e5f4f8e87b5293091d3fb", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -72,7 +72,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n         return val;\n     }\n \n-    let vtable_alloc_id = tcx.vtable_allocation(ty, trait_ref);\n+    let vtable_alloc_id = tcx.vtable_allocation((ty, trait_ref));\n     let vtable_allocation = tcx.global_alloc(vtable_alloc_id).unwrap_memory();\n     let vtable_const = cx.const_data_from_alloc(vtable_allocation);\n     let align = cx.data_layout().pointer_align.abi;"}, {"sha": "131674decc96109087069099fa4c2df6ada2e10c", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -30,7 +30,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ensure_monomorphic_enough(*self.tcx, ty)?;\n         ensure_monomorphic_enough(*self.tcx, poly_trait_ref)?;\n \n-        let vtable_allocation = self.tcx.vtable_allocation(ty, poly_trait_ref);\n+        let vtable_allocation = self.tcx.vtable_allocation((ty, poly_trait_ref));\n \n         let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_allocation))?;\n "}, {"sha": "e3eda8483b692368784bffacf496addfa61ac172", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -1012,6 +1012,13 @@ rustc_queries! {\n             key.1, key.0 }\n     }\n \n+    query vtable_allocation(key: (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>)) -> mir::interpret::AllocId {\n+        desc { |tcx| \"vtable const allocation for <{} as {}>\",\n+            key.0,\n+            key.1.map(|trait_ref| format!(\"{}\", trait_ref)).unwrap_or(\"_\".to_owned())\n+        }\n+    }\n+\n     query codegen_fulfill_obligation(\n         key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n     ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {"}, {"sha": "83d7c307bdfe9c7f0e29fdc439fe417634fc2cca", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -8,7 +8,7 @@ use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n use crate::middle;\n use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::interpret::{self, AllocId, Allocation, ConstValue, Scalar};\n+use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::thir::Thir;\n use crate::traits;\n@@ -1047,10 +1047,6 @@ pub struct GlobalCtxt<'tcx> {\n     pub(crate) alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n     output_filenames: Arc<OutputFilenames>,\n-\n-    // FIXME(eddyb) this doesn't belong here and should be using a query.\n-    pub(super) vtables_cache:\n-        Lock<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), AllocId>>,\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -1189,7 +1185,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             const_stability_interner: Default::default(),\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             output_filenames: Arc::new(output_filenames),\n-            vtables_cache: Default::default(),\n         }\n     }\n "}, {"sha": "e95493acbb734a5f340b6a28ef6689eefeae7d77", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -2051,6 +2051,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         type_uninhabited_from: inhabitedness::type_uninhabited_from,\n         const_param_default: consts::const_param_default,\n+        vtable_allocation: vtable::vtable_allocation_provider,\n         ..*providers\n     };\n }"}, {"sha": "2610a76b2810bf9fca2cc3f395e0ac277cd81331", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -2208,6 +2208,7 @@ forward_display_to_print! {\n     // because `for<'tcx>` isn't possible yet.\n     ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>,\n     ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+    ty::Binder<'tcx, ty::ExistentialTraitRef<'tcx>>,\n     ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n     ty::Binder<'tcx, TraitRefPrintOnlyTraitName<'tcx>>,\n     ty::Binder<'tcx, ty::FnSig<'tcx>>,"}, {"sha": "f766cad2b3d2181d6a09794cb39d3dacdf68d4b0", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 60, "deletions": 73, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -43,85 +43,72 @@ pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;\n pub const COMMON_VTABLE_ENTRIES_ALIGN: usize = 2;\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Retrieves an allocation that represents the contents of a vtable.\n-    /// There's a cache within `TyCtxt` so it will be deduplicated.\n-    pub fn vtable_allocation(\n-        self,\n-        ty: Ty<'tcx>,\n-        poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n-    ) -> AllocId {\n-        let tcx = self;\n-        let vtables_cache = tcx.vtables_cache.lock();\n-        if let Some(alloc_id) = vtables_cache.get(&(ty, poly_trait_ref)).cloned() {\n-            return alloc_id;\n-        }\n-        drop(vtables_cache);\n-\n-        let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n-            let trait_ref = poly_trait_ref.with_self_ty(tcx, ty);\n-            let trait_ref = tcx.erase_regions(trait_ref);\n+/// Retrieves an allocation that represents the contents of a vtable.\n+/// Since this is a query, allocations are cached and not duplicated.\n+pub(super) fn vtable_allocation_provider<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n+) -> AllocId {\n+    let (ty, poly_trait_ref) = key;\n \n-            tcx.vtable_entries(trait_ref)\n-        } else {\n-            COMMON_VTABLE_ENTRIES\n-        };\n+    let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n+        let trait_ref = poly_trait_ref.with_self_ty(tcx, ty);\n+        let trait_ref = tcx.erase_regions(trait_ref);\n \n-        let layout = tcx\n-            .layout_of(ty::ParamEnv::reveal_all().and(ty))\n-            .expect(\"failed to build vtable representation\");\n-        assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n-        let size = layout.size.bytes();\n-        let align = layout.align.abi.bytes();\n+        tcx.vtable_entries(trait_ref)\n+    } else {\n+        COMMON_VTABLE_ENTRIES\n+    };\n \n-        let ptr_size = tcx.data_layout.pointer_size;\n-        let ptr_align = tcx.data_layout.pointer_align.abi;\n+    let layout = tcx\n+        .layout_of(ty::ParamEnv::reveal_all().and(ty))\n+        .expect(\"failed to build vtable representation\");\n+    assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n+    let size = layout.size.bytes();\n+    let align = layout.align.abi.bytes();\n \n-        let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n-        let mut vtable =\n-            Allocation::uninit(vtable_size, ptr_align, /* panic_on_fail */ true).unwrap();\n+    let ptr_size = tcx.data_layout.pointer_size;\n+    let ptr_align = tcx.data_layout.pointer_align.abi;\n \n-        // No need to do any alignment checks on the memory accesses below, because we know the\n-        // allocation is correctly aligned as we created it above. Also we're only offsetting by\n-        // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n+    let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n+    let mut vtable = Allocation::uninit(vtable_size, ptr_align, /* panic_on_fail */ true).unwrap();\n \n-        for (idx, entry) in vtable_entries.iter().enumerate() {\n-            let idx: u64 = u64::try_from(idx).unwrap();\n-            let scalar = match entry {\n-                VtblEntry::MetadataDropInPlace => {\n-                    let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n-                    let fn_alloc_id = tcx.create_fn_alloc(instance);\n-                    let fn_ptr = Pointer::from(fn_alloc_id);\n-                    ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n-                }\n-                VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n-                VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n-                VtblEntry::Vacant => continue,\n-                VtblEntry::Method(instance) => {\n-                    // Prepare the fn ptr we write into the vtable.\n-                    let instance = instance.polymorphize(tcx);\n-                    let fn_alloc_id = tcx.create_fn_alloc(instance);\n-                    let fn_ptr = Pointer::from(fn_alloc_id);\n-                    ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n-                }\n-                VtblEntry::TraitVPtr(trait_ref) => {\n-                    let super_trait_ref = trait_ref.map_bound(|trait_ref| {\n-                        ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref)\n-                    });\n-                    let supertrait_alloc_id = self.vtable_allocation(ty, Some(super_trait_ref));\n-                    let vptr = Pointer::from(supertrait_alloc_id);\n-                    ScalarMaybeUninit::from_pointer(vptr, &tcx)\n-                }\n-            };\n-            vtable\n-                .write_scalar(&tcx, alloc_range(ptr_size * idx, ptr_size), scalar)\n-                .expect(\"failed to build vtable representation\");\n-        }\n+    // No need to do any alignment checks on the memory accesses below, because we know the\n+    // allocation is correctly aligned as we created it above. Also we're only offsetting by\n+    // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n \n-        vtable.mutability = Mutability::Not;\n-        let alloc_id = tcx.create_memory_alloc(tcx.intern_const_alloc(vtable));\n-        let mut vtables_cache = self.vtables_cache.lock();\n-        vtables_cache.insert((ty, poly_trait_ref), alloc_id);\n-        alloc_id\n+    for (idx, entry) in vtable_entries.iter().enumerate() {\n+        let idx: u64 = u64::try_from(idx).unwrap();\n+        let scalar = match entry {\n+            VtblEntry::MetadataDropInPlace => {\n+                let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n+                let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                let fn_ptr = Pointer::from(fn_alloc_id);\n+                ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n+            }\n+            VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n+            VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n+            VtblEntry::Vacant => continue,\n+            VtblEntry::Method(instance) => {\n+                // Prepare the fn ptr we write into the vtable.\n+                let instance = instance.polymorphize(tcx);\n+                let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                let fn_ptr = Pointer::from(fn_alloc_id);\n+                ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n+            }\n+            VtblEntry::TraitVPtr(trait_ref) => {\n+                let super_trait_ref = trait_ref\n+                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+                let supertrait_alloc_id = tcx.vtable_allocation((ty, Some(super_trait_ref)));\n+                let vptr = Pointer::from(supertrait_alloc_id);\n+                ScalarMaybeUninit::from_pointer(vptr, &tcx)\n+            }\n+        };\n+        vtable\n+            .write_scalar(&tcx, alloc_range(ptr_size * idx, ptr_size), scalar)\n+            .expect(\"failed to build vtable representation\");\n     }\n+\n+    vtable.mutability = Mutability::Not;\n+    tcx.create_memory_alloc(tcx.intern_const_alloc(vtable))\n }"}, {"sha": "344892875961aa36d6239d2f0f7c9e2b1645f36d", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -72,6 +72,17 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "8dacba63351ef36e31ca82a15cc7bac3ab81f468", "filename": "src/test/incremental/reorder_vtable.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/44995f7afb18775913618ae50601be31b9f9dead/src%2Ftest%2Fincremental%2Freorder_vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44995f7afb18775913618ae50601be31b9f9dead/src%2Ftest%2Fincremental%2Freorder_vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Freorder_vtable.rs?ref=44995f7afb18775913618ae50601be31b9f9dead", "patch": "@@ -0,0 +1,41 @@\n+// revisions:rpass1 rpass2\n+\n+// This test case makes sure re-order the methods in a vtable will\n+// trigger recompilation of codegen units that instantiate it.\n+//\n+// See https://github.com/rust-lang/rust/issues/89598\n+\n+trait Foo {\n+    #[cfg(rpass1)]\n+    fn method1(&self) -> u32;\n+\n+    fn method2(&self) -> u32;\n+\n+    #[cfg(rpass2)]\n+    fn method1(&self) -> u32;\n+}\n+\n+impl Foo for u32 {\n+    fn method1(&self) -> u32 { 17 }\n+    fn method2(&self) -> u32 { 42 }\n+}\n+\n+fn main() {\n+    // Before #89598 was fixed, the vtable allocation would be cached during\n+    // a MIR optimization pass and then the codegen pass for the main object\n+    // file would not register a dependency on it (because of the missing\n+    // dep-tracking).\n+    //\n+    // In the rpass2 session, the main object file would not be re-compiled,\n+    // thus the mod1::foo(x) call would pass in an outdated vtable, while the\n+    // mod1 object would expect the new, re-ordered vtable, resulting in a\n+    // call to the wrong method.\n+    let x: &dyn Foo = &0u32;\n+    assert_eq!(mod1::foo(x), 17);\n+}\n+\n+mod mod1 {\n+    pub(super) fn foo(x: &dyn super::Foo) -> u32 {\n+        x.method1()\n+    }\n+}"}]}