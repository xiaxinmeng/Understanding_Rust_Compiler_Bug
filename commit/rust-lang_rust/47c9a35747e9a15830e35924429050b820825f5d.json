{"sha": "47c9a35747e9a15830e35924429050b820825f5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YzlhMzU3NDdlOWExNTgzMGUzNTkyNDQyOTA1MGI4MjA4MjVmNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-17T09:16:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-17T09:16:43Z"}, "message": "auto merge of #10830 : alexcrichton/rust/spsc-queue, r=brson\n\nThis pull request completely rewrites std::comm and all associated users. Some major bullet points\r\n\r\n* Everything now works natively\r\n* oneshots have been removed\r\n* shared ports have been removed\r\n* try_recv no longer blocks (recv_opt blocks)\r\n* constructors are now Chan::new and SharedChan::new\r\n* failure is propagated on send\r\n* stream channels are 3x faster\r\n\r\nI have acquired the following measurements on this patch. I compared against Go, but remember that Go's channels are fundamentally different than ours in that sends are by-default blocking. This means that it's not really a totally fair comparison, but it's good to see ballpark numbers for anyway\r\n\r\n```\r\n          oneshot         stream          shared1\r\nstd         2.111           3.073          1.730 \r\nmy          6.639           1.037          1.238 \r\nnative      5.748           1.017          1.250 \r\ngo8         1.774           3.575          2.948 \r\ngo8-inf     slow            0.837          1.376 \r\ngo8-128     4.832           1.430          1.504 \r\ngo1         1.528           1.439          1.251 \r\ngo2         1.753           3.845          3.166 \r\n```\r\n\r\nI had three benchmarks:\r\n\r\n* oneshot - N times, create a \"oneshot channel\", send on it, then receive on it (no task spawning)\r\n* stream - N times, send from one task to another task, wait for both to complete\r\n* shared1 - create N threads, each of which sends M times, and a port receives N*M times.\r\n\r\nThe rows are as follows:\r\n\r\n* `std` - the current libstd implementation (before this pull request)\r\n* `my` - this pull request's implementation (in M:N mode)\r\n* `native` - this pull request's implementation (in 1:1 mode)\r\n* `goN` - go's implementation with GOMAXPROCS=N. The only relevant value is 8 (I had 8 cores on this machine)\r\n* `goN-X` - go's implementation where the channels in question were created with buffers of size `X` to behave more similarly to rust's channels.", "tree": {"sha": "51c4caf9e358ecdab5a0dbba70ecf8fe4dc1ba11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c4caf9e358ecdab5a0dbba70ecf8fe4dc1ba11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47c9a35747e9a15830e35924429050b820825f5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47c9a35747e9a15830e35924429050b820825f5d", "html_url": "https://github.com/rust-lang/rust/commit/47c9a35747e9a15830e35924429050b820825f5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47c9a35747e9a15830e35924429050b820825f5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c41a823ccb1e7cea0a29f9048533aaa78c40de6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c41a823ccb1e7cea0a29f9048533aaa78c40de6", "html_url": "https://github.com/rust-lang/rust/commit/2c41a823ccb1e7cea0a29f9048533aaa78c40de6"}, {"sha": "39a6c9d6376f96cc8b905f00b88d20e42961206c", "url": "https://api.github.com/repos/rust-lang/rust/commits/39a6c9d6376f96cc8b905f00b88d20e42961206c", "html_url": "https://github.com/rust-lang/rust/commit/39a6c9d6376f96cc8b905f00b88d20e42961206c"}], "stats": {"total": 6649, "additions": 3519, "deletions": 3130}, "files": [{"sha": "6213a0cfe1c25f67406ac112ef092dd3afb8d7a8", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -121,17 +121,16 @@ receiving messages. Pipes are low-level communication building-blocks and so\n come in a variety of forms, each one appropriate for a different use case. In\n what follows, we cover the most commonly used varieties.\n \n-The simplest way to create a pipe is to use the `comm::stream`\n+The simplest way to create a pipe is to use `Chan::new`\n function to create a `(Port, Chan)` pair. In Rust parlance, a *channel*\n is a sending endpoint of a pipe, and a *port* is the receiving\n endpoint. Consider the following example of calculating two results\n concurrently:\n \n ~~~~\n # use std::task::spawn;\n-# use std::comm::{stream, Port, Chan};\n \n-let (port, chan): (Port<int>, Chan<int>) = stream();\n+let (port, chan): (Port<int>, Chan<int>) = Chan::new();\n \n do spawn || {\n     let result = some_expensive_computation();\n@@ -150,8 +149,7 @@ stream for sending and receiving integers (the left-hand side of the `let`,\n a tuple into its component parts).\n \n ~~~~\n-# use std::comm::{stream, Chan, Port};\n-let (port, chan): (Port<int>, Chan<int>) = stream();\n+let (port, chan): (Port<int>, Chan<int>) = Chan::new();\n ~~~~\n \n The child task will use the channel to send data to the parent task,\n@@ -160,9 +158,8 @@ spawns the child task.\n \n ~~~~\n # use std::task::spawn;\n-# use std::comm::stream;\n # fn some_expensive_computation() -> int { 42 }\n-# let (port, chan) = stream();\n+# let (port, chan) = Chan::new();\n do spawn || {\n     let result = some_expensive_computation();\n     chan.send(result);\n@@ -180,25 +177,23 @@ computation, then waits for the child's result to arrive on the\n port:\n \n ~~~~\n-# use std::comm::{stream};\n # fn some_other_expensive_computation() {}\n-# let (port, chan) = stream::<int>();\n+# let (port, chan) = Chan::<int>::new();\n # chan.send(0);\n some_other_expensive_computation();\n let result = port.recv();\n ~~~~\n \n-The `Port` and `Chan` pair created by `stream` enables efficient communication\n-between a single sender and a single receiver, but multiple senders cannot use\n-a single `Chan`, and multiple receivers cannot use a single `Port`.  What if our\n-example needed to compute multiple results across a number of tasks? The\n-following program is ill-typed:\n+The `Port` and `Chan` pair created by `Chan::new` enables efficient\n+communication between a single sender and a single receiver, but multiple\n+senders cannot use a single `Chan`, and multiple receivers cannot use a single\n+`Port`.  What if our example needed to compute multiple results across a number\n+of tasks? The following program is ill-typed:\n \n ~~~ {.xfail-test}\n # use std::task::{spawn};\n-# use std::comm::{stream, Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n-let (port, chan) = stream();\n+let (port, chan) = Chan::new();\n \n do spawn {\n     chan.send(some_expensive_computation());\n@@ -216,10 +211,8 @@ Instead we can use a `SharedChan`, a type that allows a single\n \n ~~~\n # use std::task::spawn;\n-# use std::comm::{stream, SharedChan};\n \n-let (port, chan) = stream();\n-let chan = SharedChan::new(chan);\n+let (port, chan) = SharedChan::new();\n \n for init_val in range(0u, 3) {\n     // Create a new channel handle to distribute to the child task\n@@ -238,23 +231,22 @@ Here we transfer ownership of the channel into a new `SharedChan` value.  Like\n as an *affine* or *linear* type). Unlike with `Chan`, though, the programmer\n may duplicate a `SharedChan`, with the `clone()` method.  A cloned\n `SharedChan` produces a new handle to the same channel, allowing multiple\n-tasks to send data to a single port.  Between `spawn`, `stream` and\n+tasks to send data to a single port.  Between `spawn`, `Chan` and\n `SharedChan`, we have enough tools to implement many useful concurrency\n patterns.\n \n Note that the above `SharedChan` example is somewhat contrived since\n-you could also simply use three `stream` pairs, but it serves to\n+you could also simply use three `Chan` pairs, but it serves to\n illustrate the point. For reference, written with multiple streams, it\n might look like the example below.\n \n ~~~\n # use std::task::spawn;\n-# use std::comm::stream;\n # use std::vec;\n \n // Create a vector of ports, one for each child task\n let ports = vec::from_fn(3, |init_val| {\n-    let (port, chan) = stream();\n+    let (port, chan) = Chan::new();\n     do spawn {\n         chan.send(some_expensive_computation(init_val));\n     }\n@@ -341,7 +333,7 @@ fn main() {\n     let numbers_arc = Arc::new(numbers);\n \n     for num in range(1u, 10) {\n-        let (port, chan)  = stream();\n+        let (port, chan)  = Chan::new();\n         chan.send(numbers_arc.clone());\n \n         do spawn {\n@@ -370,7 +362,7 @@ and a clone of it is sent to each task\n # use std::rand;\n # let numbers=vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n-# let (port, chan)  = stream();\n+# let (port, chan)  = Chan::new();\n chan.send(numbers_arc.clone());\n ~~~\n copying only the wrapper and not its contents.\n@@ -382,7 +374,7 @@ Each task recovers the underlying data by\n # use std::rand;\n # let numbers=vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc=Arc::new(numbers);\n-# let (port, chan)  = stream();\n+# let (port, chan)  = Chan::new();\n # chan.send(numbers_arc.clone());\n # let local_arc : Arc<~[f64]> = port.recv();\n let task_numbers = local_arc.get();\n@@ -499,7 +491,7 @@ Here is the code for the parent task:\n # }\n # fn main() {\n \n-let (from_child, to_child) = DuplexStream();\n+let (from_child, to_child) = DuplexStream::new();\n \n do spawn {\n     stringifier(&to_child);"}, {"sha": "78d0973fdfe2eb6f13bfb0c39ea6c0c003aca42f", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -77,6 +77,7 @@\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n     \"libstd/rt/mpsc_queue.rs\", # BSD\n+    \"libstd/rt/spsc_queue.rs\", # BSD\n     \"libstd/rt/mpmc_bounded_queue.rs\", # BSD\n ]\n "}, {"sha": "6add053fa81816475de95b9f3d9a3f488271bdb3", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -597,15 +597,14 @@ mod tests {\n \n     use arc::*;\n \n-    use std::comm;\n     use std::task;\n \n     #[test]\n     fn manually_share_arc() {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = Arc::new(v);\n \n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n \n         do task::spawn {\n             let arc_v: Arc<~[int]> = p.recv();\n@@ -626,7 +625,7 @@ mod tests {\n     fn test_mutex_arc_condvar() {\n         let arc = ~MutexArc::new(false);\n         let arc2 = ~arc.clone();\n-        let (p,c) = comm::oneshot();\n+        let (p,c) = Chan::new();\n         do task::spawn {\n             // wait until parent gets in\n             p.recv();\n@@ -636,9 +635,8 @@ mod tests {\n             })\n         }\n \n-        let mut c = Some(c);\n         arc.access_cond(|state, cond| {\n-            c.take_unwrap().send(());\n+            c.send(());\n             assert!(!*state);\n             while !*state {\n                 cond.wait();\n@@ -650,7 +648,7 @@ mod tests {\n     fn test_arc_condvar_poison() {\n         let arc = ~MutexArc::new(1);\n         let arc2 = ~arc.clone();\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n \n         do spawn {\n             let _ = p.recv();\n@@ -687,7 +685,7 @@ mod tests {\n     pub fn test_mutex_arc_unwrap_poison() {\n         let arc = MutexArc::new(1);\n         let arc2 = ~(&arc).clone();\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         do task::spawn {\n             arc2.access(|one| {\n                 c.send(());\n@@ -804,7 +802,7 @@ mod tests {\n     fn test_rw_arc() {\n         let arc = RWArc::new(0);\n         let arc2 = arc.clone();\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n \n         do task::spawn {\n             arc2.write(|num| {\n@@ -832,7 +830,7 @@ mod tests {\n         });\n \n         // Wait for children to pass their asserts\n-        for r in children.iter() {\n+        for r in children.mut_iter() {\n             r.recv();\n         }\n \n@@ -855,7 +853,7 @@ mod tests {\n         // Reader tasks\n         let mut reader_convos = ~[];\n         10.times(|| {\n-            let ((rp1, rc1), (rp2, rc2)) = (comm::stream(), comm::stream());\n+            let ((rp1, rc1), (rp2, rc2)) = (Chan::new(), Chan::new());\n             reader_convos.push((rc1, rp2));\n             let arcn = arc.clone();\n             do task::spawn {\n@@ -869,7 +867,7 @@ mod tests {\n \n         // Writer task\n         let arc2 = arc.clone();\n-        let ((wp1, wc1), (wp2, wc2)) = (comm::stream(), comm::stream());\n+        let ((wp1, wc1), (wp2, wc2)) = (Chan::new(), Chan::new());\n         do task::spawn || {\n             wp1.recv();\n             arc2.write_cond(|state, cond| {\n@@ -897,14 +895,14 @@ mod tests {\n                 assert_eq!(*state, 42);\n                 *state = 31337;\n                 // send to other readers\n-                for &(ref rc, _) in reader_convos.iter() {\n+                for &(ref mut rc, _) in reader_convos.mut_iter() {\n                     rc.send(())\n                 }\n             });\n             let read_mode = arc.downgrade(write_mode);\n             read_mode.read(|state| {\n                 // complete handshake with other readers\n-                for &(_, ref rp) in reader_convos.iter() {\n+                for &(_, ref mut rp) in reader_convos.mut_iter() {\n                     rp.recv()\n                 }\n                 wc1.send(()); // tell writer to try again\n@@ -926,7 +924,7 @@ mod tests {\n         //     \"blk(&Condvar { order: opt_lock, ..*cond })\"\n         // with just \"blk(cond)\".\n         let x = RWArc::new(true);\n-        let (wp, wc) = comm::stream();\n+        let (wp, wc) = Chan::new();\n \n         // writer task\n         let xw = x.clone();\n@@ -951,7 +949,7 @@ mod tests {\n             });\n             // make a reader task to trigger the \"reader cloud lock\" handoff\n             let xr = x.clone();\n-            let (rp, rc) = comm::stream();\n+            let (rp, rc) = Chan::new();\n             do task::spawn {\n                 rc.send(());\n                 xr.read(|_state| { })"}, {"sha": "09dd85fe0de4687ac0bea3e0a45b8d0108a1ca10", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 42, "deletions": 77, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -16,11 +16,6 @@ Higher level communication abstractions.\n \n #[allow(missing_doc)];\n \n-\n-use std::comm::{GenericChan, GenericSmartChan, GenericPort};\n-use std::comm::{Chan, Port, Peekable};\n-use std::comm;\n-\n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T, U> {\n     priv chan: Chan<T>,\n@@ -29,108 +24,73 @@ pub struct DuplexStream<T, U> {\n \n // Allow these methods to be used without import:\n impl<T:Send,U:Send> DuplexStream<T, U> {\n+    /// Creates a bidirectional stream.\n+    pub fn new() -> (DuplexStream<T, U>, DuplexStream<U, T>) {\n+        let (p1, c2) = Chan::new();\n+        let (p2, c1) = Chan::new();\n+        (DuplexStream { chan: c1, port: p1 },\n+         DuplexStream { chan: c2, port: p2 })\n+    }\n     pub fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n     pub fn try_send(&self, x: T) -> bool {\n         self.chan.try_send(x)\n     }\n-    pub fn recv(&self, ) -> U {\n+    pub fn recv(&self) -> U {\n         self.port.recv()\n     }\n     pub fn try_recv(&self) -> Option<U> {\n         self.port.try_recv()\n     }\n-    pub fn peek(&self) -> bool {\n-        self.port.peek()\n-    }\n-}\n-\n-impl<T:Send,U:Send> GenericChan<T> for DuplexStream<T, U> {\n-    fn send(&self, x: T) {\n-        self.chan.send(x)\n-    }\n-}\n-\n-impl<T:Send,U:Send> GenericSmartChan<T> for DuplexStream<T, U> {\n-    fn try_send(&self, x: T) -> bool {\n-        self.chan.try_send(x)\n-    }\n-}\n-\n-impl<T:Send,U:Send> GenericPort<U> for DuplexStream<T, U> {\n-    fn recv(&self) -> U {\n-        self.port.recv()\n-    }\n-\n-    fn try_recv(&self) -> Option<U> {\n-        self.port.try_recv()\n-    }\n-}\n-\n-impl<T:Send,U:Send> Peekable<U> for DuplexStream<T, U> {\n-    fn peek(&self) -> bool {\n-        self.port.peek()\n+    pub fn recv_opt(&self) -> Option<U> {\n+        self.port.recv_opt()\n     }\n }\n \n-/// Creates a bidirectional stream.\n-pub fn DuplexStream<T:Send,U:Send>()\n-    -> (DuplexStream<T, U>, DuplexStream<U, T>)\n-{\n-    let (p1, c2) = comm::stream();\n-    let (p2, c1) = comm::stream();\n-    (DuplexStream {\n-        chan: c1,\n-        port: p1\n-    },\n-     DuplexStream {\n-         chan: c2,\n-         port: p2\n-     })\n-}\n-\n /// An extension of `pipes::stream` that provides synchronous message sending.\n pub struct SyncChan<T> { priv duplex_stream: DuplexStream<T, ()> }\n /// An extension of `pipes::stream` that acknowledges each message received.\n pub struct SyncPort<T> { priv duplex_stream: DuplexStream<(), T> }\n \n-impl<T: Send> GenericChan<T> for SyncChan<T> {\n-    fn send(&self, val: T) {\n+impl<T: Send> SyncChan<T> {\n+    pub fn send(&self, val: T) {\n         assert!(self.try_send(val), \"SyncChan.send: receiving port closed\");\n     }\n-}\n \n-impl<T: Send> GenericSmartChan<T> for SyncChan<T> {\n-    /// Sends a message, or report if the receiver has closed the connection before receiving.\n-    fn try_send(&self, val: T) -> bool {\n-        self.duplex_stream.try_send(val) && self.duplex_stream.try_recv().is_some()\n+    /// Sends a message, or report if the receiver has closed the connection\n+    /// before receiving.\n+    pub fn try_send(&self, val: T) -> bool {\n+        self.duplex_stream.try_send(val) && self.duplex_stream.recv_opt().is_some()\n     }\n }\n \n-impl<T: Send> GenericPort<T> for SyncPort<T> {\n-    fn recv(&self) -> T {\n-        self.try_recv().expect(\"SyncPort.recv: sending channel closed\")\n+impl<T: Send> SyncPort<T> {\n+    pub fn recv(&self) -> T {\n+        self.recv_opt().expect(\"SyncPort.recv: sending channel closed\")\n     }\n \n-    fn try_recv(&self) -> Option<T> {\n-        self.duplex_stream.try_recv().map(|val| {\n+    pub fn recv_opt(&self) -> Option<T> {\n+        self.duplex_stream.recv_opt().map(|val| {\n             self.duplex_stream.try_send(());\n             val\n         })\n     }\n-}\n \n-impl<T: Send> Peekable<T> for SyncPort<T> {\n-    fn peek(&self) -> bool {\n-        self.duplex_stream.peek()\n+    pub fn try_recv(&self) -> Option<T> {\n+        self.duplex_stream.try_recv().map(|val| {\n+            self.duplex_stream.try_send(());\n+            val\n+        })\n     }\n }\n \n-/// Creates a stream whose channel, upon sending a message, blocks until the message is received.\n+/// Creates a stream whose channel, upon sending a message, blocks until the\n+/// message is received.\n pub fn rendezvous<T: Send>() -> (SyncPort<T>, SyncChan<T>) {\n-    let (chan_stream, port_stream) = DuplexStream();\n-    (SyncPort { duplex_stream: port_stream }, SyncChan { duplex_stream: chan_stream })\n+    let (chan_stream, port_stream) = DuplexStream::new();\n+    (SyncPort { duplex_stream: port_stream },\n+     SyncChan { duplex_stream: chan_stream })\n }\n \n #[cfg(test)]\n@@ -141,7 +101,7 @@ mod test {\n \n     #[test]\n     pub fn DuplexStream1() {\n-        let (left, right) = DuplexStream();\n+        let (mut left, mut right) = DuplexStream::new();\n \n         left.send(~\"abc\");\n         right.send(123);\n@@ -152,9 +112,10 @@ mod test {\n \n     #[test]\n     pub fn basic_rendezvous_test() {\n-        let (port, chan) = rendezvous();\n+        let (mut port, chan) = rendezvous();\n \n         do spawn {\n+            let mut chan = chan;\n             chan.send(\"abc\");\n         }\n \n@@ -165,8 +126,9 @@ mod test {\n     fn recv_a_lot() {\n         // Rendezvous streams should be able to handle any number of messages being sent\n         do run_in_uv_task {\n-            let (port, chan) = rendezvous();\n+            let (mut port, chan) = rendezvous();\n             do spawn {\n+                let mut chan = chan;\n                 1000000.times(|| { chan.send(()) })\n             }\n             1000000.times(|| { port.recv() })\n@@ -175,8 +137,9 @@ mod test {\n \n     #[test]\n     fn send_and_fail_and_try_recv() {\n-        let (port, chan) = rendezvous();\n+        let (mut port, chan) = rendezvous();\n         do spawn {\n+            let mut chan = chan;\n             chan.duplex_stream.send(()); // Can't access this field outside this module\n             fail!()\n         }\n@@ -185,8 +148,9 @@ mod test {\n \n     #[test]\n     fn try_send_and_recv_then_fail_before_ack() {\n-        let (port, chan) = rendezvous();\n+        let (port, mut chan) = rendezvous();\n         do spawn {\n+            let mut port = port;\n             port.duplex_stream.recv();\n             fail!()\n         }\n@@ -196,8 +160,9 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn send_and_recv_then_fail_before_ack() {\n-        let (port, chan) = rendezvous();\n+        let (port, mut chan) = rendezvous();\n         do spawn {\n+            let mut port = port;\n             port.duplex_stream.recv();\n             fail!()\n         }"}, {"sha": "eb61b7781f1ba329228be28760065610227a6a1b", "filename": "src/libextra/future.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -25,7 +25,6 @@\n \n #[allow(missing_doc)];\n \n-use std::comm::{PortOne, oneshot};\n use std::util::replace;\n \n /// A type encapsulating the result of a computation which may not be complete\n@@ -104,7 +103,7 @@ impl<A> Future<A> {\n }\n \n impl<A:Send> Future<A> {\n-    pub fn from_port(port: PortOne<A>) -> Future<A> {\n+    pub fn from_port(port: Port<A>) -> Future<A> {\n         /*!\n          * Create a future from a port\n          *\n@@ -125,7 +124,7 @@ impl<A:Send> Future<A> {\n          * value of the future.\n          */\n \n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             chan.send(blk());\n@@ -139,7 +138,6 @@ impl<A:Send> Future<A> {\n mod test {\n     use future::Future;\n \n-    use std::comm::oneshot;\n     use std::task;\n \n     #[test]\n@@ -150,7 +148,7 @@ mod test {\n \n     #[test]\n     fn test_from_port() {\n-        let (po, ch) = oneshot();\n+        let (po, ch) = Chan::new();\n         ch.send(~\"whale\");\n         let mut f = Future::from_port(po);\n         assert_eq!(f.get(), ~\"whale\");"}, {"sha": "6e582982962773f4e515ac05b396a2057a27ce39", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -19,9 +19,6 @@\n \n \n use std::borrow;\n-use std::comm;\n-use std::comm::SendDeferred;\n-use std::comm::{GenericPort, Peekable};\n use std::unstable::sync::{Exclusive, UnsafeArc};\n use std::unstable::atomics;\n use std::unstable::finally::Finally;\n@@ -34,48 +31,53 @@ use std::util::NonCopyable;\n \n // Each waiting task receives on one of these.\n #[doc(hidden)]\n-type WaitEnd = comm::PortOne<()>;\n+type WaitEnd = Port<()>;\n #[doc(hidden)]\n-type SignalEnd = comm::ChanOne<()>;\n+type SignalEnd = Chan<()>;\n // A doubly-ended queue of waiting tasks.\n #[doc(hidden)]\n-struct WaitQueue { head: comm::Port<SignalEnd>,\n-                   tail: comm::Chan<SignalEnd> }\n+struct WaitQueue { head: Port<SignalEnd>,\n+                   tail: Chan<SignalEnd> }\n \n impl WaitQueue {\n     fn new() -> WaitQueue {\n-        let (block_head, block_tail) = comm::stream();\n+        let (block_head, block_tail) = Chan::new();\n         WaitQueue { head: block_head, tail: block_tail }\n     }\n \n     // Signals one live task from the queue.\n     fn signal(&self) -> bool {\n-        // The peek is mandatory to make sure recv doesn't block.\n-        if self.head.peek() {\n-            // Pop and send a wakeup signal. If the waiter was killed, its port\n-            // will have closed. Keep trying until we get a live task.\n-            if self.head.recv().try_send_deferred(()) {\n-                true\n-            } else {\n-                self.signal()\n+        match self.head.try_recv() {\n+            Some(ch) => {\n+                // Send a wakeup signal. If the waiter was killed, its port will\n+                // have closed. Keep trying until we get a live task.\n+                if ch.try_send_deferred(()) {\n+                    true\n+                } else {\n+                    self.signal()\n+                }\n             }\n-        } else {\n-            false\n+            None => false\n         }\n     }\n \n     fn broadcast(&self) -> uint {\n         let mut count = 0;\n-        while self.head.peek() {\n-            if self.head.recv().try_send_deferred(()) {\n-                count += 1;\n+        loop {\n+            match self.head.try_recv() {\n+                None => break,\n+                Some(ch) => {\n+                    if ch.try_send_deferred(()) {\n+                        count += 1;\n+                    }\n+                }\n             }\n         }\n         count\n     }\n \n     fn wait_end(&self) -> WaitEnd {\n-        let (wait_end, signal_end) = comm::oneshot();\n+        let (wait_end, signal_end) = Chan::new();\n         self.tail.send_deferred(signal_end);\n         wait_end\n     }\n@@ -282,8 +284,7 @@ impl<'a> Condvar<'a> {\n                               condvar_id,\n                               \"cond.signal_on()\",\n                               || {\n-                let queue = queue.take_unwrap();\n-                queue.broadcast()\n+                queue.take_unwrap().broadcast()\n             })\n         }\n     }\n@@ -676,7 +677,6 @@ mod tests {\n     use sync::*;\n \n     use std::cast;\n-    use std::comm;\n     use std::result;\n     use std::task;\n \n@@ -711,7 +711,7 @@ mod tests {\n     #[test]\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n         do task::spawn {\n@@ -723,7 +723,7 @@ mod tests {\n         let _ = p.recv();\n \n         /* Parent waits and child signals */\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n         do task::spawn {\n@@ -740,8 +740,8 @@ mod tests {\n         // time, and shake hands.\n         let s = Semaphore::new(2);\n         let s2 = s.clone();\n-        let (p1,c1) = comm::stream();\n-        let (p2,c2) = comm::stream();\n+        let (p1,c1) = Chan::new();\n+        let (p2,c2) = Chan::new();\n         do task::spawn {\n             s2.access(|| {\n                 let _ = p2.recv();\n@@ -760,7 +760,7 @@ mod tests {\n         do task::spawn_sched(task::SingleThreaded) {\n             let s = Semaphore::new(1);\n             let s2 = s.clone();\n-            let (p, c) = comm::stream();\n+            let (p, c) = Chan::new();\n             let mut child_data = Some((s2, c));\n             s.access(|| {\n                 let (s2, c) = child_data.take_unwrap();\n@@ -782,7 +782,7 @@ mod tests {\n     fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         let m = Mutex::new();\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n@@ -829,7 +829,7 @@ mod tests {\n             cond.wait();\n         });\n         // Parent wakes up child\n-        let (port,chan) = comm::stream();\n+        let (port,chan) = Chan::new();\n         let m3 = m.clone();\n         do task::spawn {\n             m3.lock_cond(|cond| {\n@@ -852,7 +852,7 @@ mod tests {\n \n         num_waiters.times(|| {\n             let mi = m.clone();\n-            let (port, chan) = comm::stream();\n+            let (port, chan) = Chan::new();\n             ports.push(port);\n             do task::spawn {\n                 mi.lock_cond(|cond| {\n@@ -864,13 +864,13 @@ mod tests {\n         });\n \n         // wait until all children get in the mutex\n-        for port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.mut_iter() { let _ = port.recv(); }\n         m.lock_cond(|cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n         // wait until all children wake up\n-        for port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.mut_iter() { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -915,8 +915,8 @@ mod tests {\n         let m2 = m.clone();\n \n         let result: result::Result<(), ~Any> = do task::try {\n-            let (p, c) = comm::stream();\n-            do task::spawn || { // linked\n+            let (p, c) = Chan::new();\n+            do task::spawn { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::deschedule();\n                 fail!();\n@@ -940,19 +940,17 @@ mod tests {\n \n         let m = Mutex::new();\n         let m2 = m.clone();\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n \n         let result: result::Result<(), ~Any> = do task::try {\n             let mut sibling_convos = ~[];\n             2.times(|| {\n-                let (p, c) = comm::stream();\n+                let (p, c) = Chan::new();\n                 sibling_convos.push(p);\n                 let mi = m2.clone();\n                 // spawn sibling task\n                 do task::spawn { // linked\n-                    let mut c = Some(c);\n                     mi.lock_cond(|cond| {\n-                        let c = c.take_unwrap();\n                         c.send(()); // tell sibling to go ahead\n                         (|| {\n                             cond.wait(); // block forever\n@@ -964,7 +962,7 @@ mod tests {\n                     })\n                 }\n             });\n-            for p in sibling_convos.iter() {\n+            for p in sibling_convos.mut_iter() {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             m2.lock(|| { });\n@@ -973,8 +971,8 @@ mod tests {\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        let r = p.recv();\n-        for p in r.iter() { p.recv(); } // wait on all its siblings\n+        let mut r = p.recv();\n+        for p in r.mut_iter() { p.recv(); } // wait on all its siblings\n         m.lock_cond(|cond| {\n             let woken = cond.broadcast();\n             assert_eq!(woken, 0);\n@@ -995,11 +993,12 @@ mod tests {\n         })\n     }\n     #[test]\n+    #[ignore(reason = \"linked failure?\")]\n     fn test_mutex_different_conds() {\n         let result = do task::try {\n             let m = Mutex::new_with_condvars(2);\n             let m2 = m.clone();\n-            let (p, c) = comm::stream();\n+            let (p, c) = Chan::new();\n             do task::spawn {\n                 m2.lock_cond(|cond| {\n                     c.send(());\n@@ -1060,7 +1059,7 @@ mod tests {\n                                  mode2: RWLockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n-        let (p, c) = comm::stream();\n+        let (p, c) = Chan::new();\n         let x2 = x.clone();\n         let mut sharedstate = ~0;\n         {\n@@ -1111,8 +1110,8 @@ mod tests {\n                                  make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = x.clone();\n-        let (p1, c1) = comm::stream();\n-        let (p2, c2) = comm::stream();\n+        let (p1, c1) = Chan::new();\n+        let (p2, c2) = Chan::new();\n         do task::spawn {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n@@ -1177,7 +1176,7 @@ mod tests {\n             cond.wait();\n         });\n         // Parent wakes up child\n-        let (port, chan) = comm::stream();\n+        let (port, chan) = Chan::new();\n         let x3 = x.clone();\n         do task::spawn {\n             x3.write_cond(|cond| {\n@@ -1214,7 +1213,7 @@ mod tests {\n \n         num_waiters.times(|| {\n             let xi = x.clone();\n-            let (port, chan) = comm::stream();\n+            let (port, chan) = Chan::new();\n             ports.push(port);\n             do task::spawn {\n                 lock_cond(&xi, dg1, |cond| {\n@@ -1226,13 +1225,13 @@ mod tests {\n         });\n \n         // wait until all children get in the mutex\n-        for port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.mut_iter() { let _ = port.recv(); }\n         lock_cond(&x, dg2, |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n         // wait until all children wake up\n-        for port in ports.iter() { let _ = port.recv(); }\n+        for port in ports.mut_iter() { let _ = port.recv(); }\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {"}, {"sha": "f0c9833adf8046b9d2e3ca4ccbb2abed3a3a9fa3", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -14,8 +14,6 @@\n /// parallelism.\n \n \n-use std::comm::{Chan, GenericChan, GenericPort};\n-use std::comm;\n use std::task::SchedMode;\n use std::task;\n use std::vec;\n@@ -35,7 +33,7 @@ pub struct TaskPool<T> {\n #[unsafe_destructor]\n impl<T> Drop for TaskPool<T> {\n     fn drop(&mut self) {\n-        for channel in self.channels.iter() {\n+        for channel in self.channels.mut_iter() {\n             channel.send(Quit);\n         }\n     }\n@@ -54,7 +52,7 @@ impl<T> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n         let channels = vec::from_fn(n_tasks, |i| {\n-            let (port, chan) = comm::stream::<Msg<T>>();\n+            let (port, chan) = Chan::<Msg<T>>::new();\n             let init_fn = init_fn_factory();\n \n             let task_body: proc() = proc() {"}, {"sha": "974d4dc1dc520117a3ec6201a284118c59ff46f1", "filename": "src/libextra/test.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -29,7 +29,6 @@ use time::precise_time_ns;\n use treemap::TreeMap;\n \n use std::clone::Clone;\n-use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n use std::io;\n use std::io::File;\n use std::io::Writer;\n@@ -746,8 +745,7 @@ fn run_tests(opts: &TestOpts,\n     remaining.reverse();\n     let mut pending = 0;\n \n-    let (p, ch) = stream();\n-    let ch = SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n \n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n@@ -872,7 +870,7 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: proc()) {\n-        do task::spawn {\n+        do spawn {\n             let mut task = task::task();\n             task.name(match desc.name {\n                 DynTestName(ref name) => SendStrOwned(name.clone()),\n@@ -1206,7 +1204,6 @@ mod tests {\n                StaticTestName, DynTestName, DynTestFn};\n     use test::{TestOpts, run_test};\n \n-    use std::comm::{stream, SharedChan};\n     use tempfile::TempDir;\n \n     #[test]\n@@ -1220,8 +1217,7 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert!(res != TrOk);\n@@ -1238,8 +1234,7 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert_eq!(res, TrIgnored);\n@@ -1256,8 +1251,7 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert_eq!(res, TrOk);\n@@ -1274,8 +1268,7 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert_eq!(res, TrFailed);"}, {"sha": "8713dbde9205a08330665e0ee0fe22f1d75802be", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -15,8 +15,7 @@ use json::ToJson;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use arc::{Arc,RWArc};\n use treemap::TreeMap;\n-use std::comm::{PortOne, oneshot};\n-use std::{str, task};\n+use std::str;\n use std::io;\n use std::io::{File, Decorator};\n use std::io::mem::MemWriter;\n@@ -252,7 +251,7 @@ pub struct Exec {\n \n enum Work<'a, T> {\n     WorkValue(T),\n-    WorkFromTask(&'a Prep<'a>, PortOne<(Exec, T)>),\n+    WorkFromTask(&'a Prep<'a>, Port<(Exec, T)>),\n }\n \n fn json_encode<'a, T:Encodable<json::Encoder<'a>>>(t: &T) -> ~str {\n@@ -427,11 +426,11 @@ impl<'a> Prep<'a> {\n \n             _ => {\n                 debug!(\"Cache miss!\");\n-                let (port, chan) = oneshot();\n+                let (port, chan) = Chan::new();\n                 let blk = bo.take_unwrap();\n \n                 // XXX: What happens if the task fails?\n-                do task::spawn {\n+                do spawn {\n                     let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n@@ -453,7 +452,7 @@ impl<'a, T:Send +\n     pub fn from_value(elt: T) -> Work<'a, T> {\n         WorkValue(elt)\n     }\n-    pub fn from_task(prep: &'a Prep<'a>, port: PortOne<(Exec, T)>)\n+    pub fn from_task(prep: &'a Prep<'a>, port: Port<(Exec, T)>)\n         -> Work<'a, T> {\n         WorkFromTask(prep, port)\n     }"}, {"sha": "c5be6776eef117583855f96e9fc62840bb13becd", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -27,6 +27,7 @@ use driver::driver::{compile_input};\n use driver::session;\n use middle::lint;\n \n+use std::cast;\n use std::comm;\n use std::io;\n use std::io::Reader;\n@@ -303,7 +304,8 @@ impl diagnostic::Emitter for RustcEmitter {\n             msg: &str,\n             lvl: diagnostic::level) {\n         if lvl == diagnostic::fatal {\n-            self.ch_capture.send(fatal)\n+            let this = unsafe { cast::transmute_mut(self) };\n+            this.ch_capture.send(fatal)\n         }\n \n         diagnostic::DefaultEmitter.emit(cmsp, msg, lvl)\n@@ -333,8 +335,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n     #[cfg(not(rtopt))]\n     static STACK_SIZE: uint = 20000000; // 20MB\n \n-    let (p, ch) = stream();\n-    let ch = SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n     let ch_capture = ch.clone();\n     let mut task_builder = task::task();\n     task_builder.name(\"rustc\");"}, {"sha": "04da17d4ec441247d19ae160d5a2f47e680fe889", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -174,71 +174,70 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n         let loc = loc.unwrap();\n \n         local_data::get(cache_key, |cache| {\n-            cache.unwrap().read(|cache| {\n-                let abs_root = root(cache, loc.as_slice());\n-                let rel_root = match path.segments[0].name.as_slice() {\n-                    \"self\" => Some(~\"./\"),\n-                    _ => None,\n-                };\n-\n-                if print_all {\n-                    let amt = path.segments.len() - 1;\n-                    match rel_root {\n-                        Some(root) => {\n-                            let mut root = root;\n-                            for seg in path.segments.slice_to(amt).iter() {\n-                                if \"super\" == seg.name || \"self\" == seg.name {\n-                                    write!(w, \"{}::\", seg.name);\n-                                } else {\n-                                    root.push_str(seg.name);\n-                                    root.push_str(\"/\");\n-                                    write!(w, \"<a class='mod'\n-                                                  href='{}index.html'>{}</a>::\",\n-                                           root,\n-                                           seg.name);\n-                                }\n-                            }\n-                        }\n-                        None => {\n-                            for seg in path.segments.slice_to(amt).iter() {\n+            let cache = cache.unwrap().get();\n+            let abs_root = root(cache, loc.as_slice());\n+            let rel_root = match path.segments[0].name.as_slice() {\n+                \"self\" => Some(~\"./\"),\n+                _ => None,\n+            };\n+\n+            if print_all {\n+                let amt = path.segments.len() - 1;\n+                match rel_root {\n+                    Some(root) => {\n+                        let mut root = root;\n+                        for seg in path.segments.slice_to(amt).iter() {\n+                            if \"super\" == seg.name || \"self\" == seg.name {\n                                 write!(w, \"{}::\", seg.name);\n+                            } else {\n+                                root.push_str(seg.name);\n+                                root.push_str(\"/\");\n+                                write!(w, \"<a class='mod'\n+                                              href='{}index.html'>{}</a>::\",\n+                                       root,\n+                                       seg.name);\n                             }\n                         }\n                     }\n+                    None => {\n+                        for seg in path.segments.slice_to(amt).iter() {\n+                            write!(w, \"{}::\", seg.name);\n+                        }\n+                    }\n                 }\n+            }\n \n-                match info(cache) {\n-                    // This is a documented path, link to it!\n-                    Some((ref fqp, shortty)) if abs_root.is_some() => {\n-                        let mut url = abs_root.unwrap();\n-                        let to_link = fqp.slice_to(fqp.len() - 1);\n-                        for component in to_link.iter() {\n-                            url.push_str(*component);\n-                            url.push_str(\"/\");\n+            match info(cache) {\n+                // This is a documented path, link to it!\n+                Some((ref fqp, shortty)) if abs_root.is_some() => {\n+                    let mut url = abs_root.unwrap();\n+                    let to_link = fqp.slice_to(fqp.len() - 1);\n+                    for component in to_link.iter() {\n+                        url.push_str(*component);\n+                        url.push_str(\"/\");\n+                    }\n+                    match shortty {\n+                        \"mod\" => {\n+                            url.push_str(*fqp.last());\n+                            url.push_str(\"/index.html\");\n                         }\n-                        match shortty {\n-                            \"mod\" => {\n-                                url.push_str(*fqp.last());\n-                                url.push_str(\"/index.html\");\n-                            }\n-                            _ => {\n-                                url.push_str(shortty);\n-                                url.push_str(\".\");\n-                                url.push_str(*fqp.last());\n-                                url.push_str(\".html\");\n-                            }\n+                        _ => {\n+                            url.push_str(shortty);\n+                            url.push_str(\".\");\n+                            url.push_str(*fqp.last());\n+                            url.push_str(\".html\");\n                         }\n-\n-                        write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n-                               shortty, url, fqp.connect(\"::\"), last.name);\n                     }\n \n-                    _ => {\n-                        write!(w, \"{}\", last.name);\n-                    }\n+                    write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n+                           shortty, url, fqp.connect(\"::\"), last.name);\n                 }\n-                write!(w, \"{}\", generics);\n-            })\n+\n+                _ => {\n+                    write!(w, \"{}\", last.name);\n+                }\n+            }\n+            write!(w, \"{}\", generics);\n         })\n     })\n }\n@@ -263,9 +262,8 @@ impl fmt::Default for clean::Type {\n         match *g {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n                 local_data::get(cache_key, |cache| {\n-                    cache.unwrap().read(|m| {\n-                        f.buf.write(m.typarams.get(&id).as_bytes());\n-                    })\n+                    let m = cache.unwrap().get();\n+                    f.buf.write(m.typarams.get(&id).as_bytes());\n                 })\n             }\n             clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {"}, {"sha": "82122c4c32fb59e76d8dd8e0b21f1fa58099219a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 85, "deletions": 181, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -33,21 +33,17 @@\n //! These tasks are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-use std::comm::{SharedPort, SharedChan};\n-use std::comm;\n use std::fmt;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n use std::io::buffered::BufferedWriter;\n use std::io;\n use std::io::fs;\n use std::io::File;\n-use std::os;\n use std::str;\n-use std::task;\n use std::vec;\n \n-use extra::arc::RWArc;\n+use extra::arc::Arc;\n use extra::json::ToJson;\n use extra::sort;\n \n@@ -121,7 +117,7 @@ enum Implementor {\n ///\n /// This structure purposefully does not implement `Clone` because it's intended\n /// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to both `Send` and `Freeze` so it may be stored in a `RWArc` instance and\n+/// to both `Send` and `Freeze` so it may be stored in a `Arc` instance and\n /// shared among the various rendering tasks.\n pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n@@ -197,7 +193,7 @@ struct IndexItem {\n \n // TLS keys used to carry information around during rendering.\n \n-local_data_key!(pub cache_key: RWArc<Cache>)\n+local_data_key!(pub cache_key: Arc<Cache>)\n local_data_key!(pub current_location_key: ~[~str])\n \n /// Generates the documentation for `crate` into the directory `dst`\n@@ -640,22 +636,6 @@ impl<'a> Cache {\n     }\n }\n \n-enum Progress {\n-    JobNew,\n-    JobDone,\n-}\n-\n-/// A helper object to unconditionally send a value on a chanel.\n-struct ChannelGuard {\n-    channel: SharedChan<Progress>,\n-}\n-\n-impl Drop for ChannelGuard {\n-    fn drop(&mut self) {\n-        self.channel.send(JobDone)\n-    }\n-}\n-\n impl Context {\n     /// Recurse in the directory structure and change the \"root path\" to make\n     /// sure it always points to the top (relatively)\n@@ -680,97 +660,26 @@ impl Context {\n         return ret;\n     }\n \n-    /// Main method for rendering a crate. This parallelizes the task of\n-    /// rendering a crate, and requires ownership of the crate in order to break\n-    /// it up into its separate components.\n-    fn crate(self, mut crate: clean::Crate, cache: Cache) {\n-        enum Work {\n-            Die,\n-            Process(Context, clean::Item),\n-        }\n-        let workers = match os::getenv(\"RUSTDOC_WORKERS\") {\n-            Some(s) => {\n-                match from_str::<uint>(s) {\n-                    Some(n) => n, None => fail!(\"{} not a number\", s)\n-                }\n-            }\n-            None => 10,\n-        };\n-\n+    /// Main method for rendering a crate.\n+    ///\n+    /// This currently isn't parallelized, but it'd be pretty easy to add\n+    /// parallelization to this function.\n+    fn crate(mut self, mut crate: clean::Crate, cache: Cache) {\n         let mut item = match crate.module.take() {\n             Some(i) => i,\n             None => return\n         };\n         item.name = Some(crate.name);\n \n-        let (port, chan) = comm::stream::<Work>();\n-        let port = SharedPort::new(port);\n-        let chan = SharedChan::new(chan);\n-        let (prog_port, prog_chan) = comm::stream();\n-        let prog_chan = SharedChan::new(prog_chan);\n-        let cache = RWArc::new(cache);\n-\n-        // Each worker thread receives work from a shared port and publishes\n-        // new work onto the corresponding shared port. All of the workers are\n-        // using the same channel/port. Through this, the crate is recursed on\n-        // in a hierarchical fashion, and parallelization is only achieved if\n-        // one node in the hierarchy has more than one child (very common).\n-        for i in range(0, workers) {\n-            let port = port.clone();\n-            let chan = chan.clone();\n-            let prog_chan = prog_chan.clone();\n-\n-            let mut task = task::task();\n-            task.name(format!(\"worker{}\", i));\n-            let cache = cache.clone();\n-            do task.spawn {\n-                worker(cache, &port, &chan, &prog_chan);\n-            }\n-\n-            fn worker(cache: RWArc<Cache>,\n-                      port: &SharedPort<Work>,\n-                      chan: &SharedChan<Work>,\n-                      prog_chan: &SharedChan<Progress>) {\n-                local_data::set(cache_key, cache);\n-\n-                loop {\n-                    match port.recv() {\n-                        Process(cx, item) => {\n-                            let mut cx = cx;\n-\n-                            // If we fail, everything else should still get\n-                            // completed.\n-                            let _guard = ChannelGuard {\n-                                channel: prog_chan.clone(),\n-                            };\n-                            cx.item(item, |cx, item| {\n-                                prog_chan.send(JobNew);\n-                                chan.send(Process(cx.clone(), item));\n-                            })\n-                        }\n-                        Die => break,\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Send off the initial job\n-        chan.send(Process(self, item));\n-        let mut jobs = 1;\n+        // using a rwarc makes this parallelizable in the future\n+        local_data::set(cache_key, Arc::new(cache));\n \n-        // Keep track of the number of jobs active in the system and kill\n-        // everything once there are no more jobs remaining.\n-        loop {\n-            match prog_port.recv() {\n-                JobNew => jobs += 1,\n-                JobDone => jobs -= 1,\n-            }\n-\n-            if jobs == 0 { break }\n-        }\n-\n-        for _ in range(0, workers) {\n-            chan.send(Die);\n+        let mut work = ~[item];\n+        while work.len() > 0 {\n+            let item = work.pop();\n+            self.item(item, |_cx, item| {\n+                work.push(item);\n+            })\n         }\n     }\n \n@@ -1210,29 +1119,28 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n     }\n \n     local_data::get(cache_key, |cache| {\n-        cache.unwrap().read(|cache| {\n-            match cache.implementors.find(&it.id) {\n-                Some(implementors) => {\n-                    write!(w, \"\n-                        <h2 id='implementors'>Implementors</h2>\n-                        <ul class='item-list'>\n-                    \");\n-                    for i in implementors.iter() {\n-                        match *i {\n-                            PathType(ref ty) => {\n-                                write!(w, \"<li><code>{}</code></li>\", *ty);\n-                            }\n-                            OtherType(ref generics, ref trait_, ref for_) => {\n-                                write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n-                                       *generics, *trait_, *for_);\n-                            }\n+        let cache = cache.unwrap().get();\n+        match cache.implementors.find(&it.id) {\n+            Some(implementors) => {\n+                write!(w, \"\n+                    <h2 id='implementors'>Implementors</h2>\n+                    <ul class='item-list'>\n+                \");\n+                for i in implementors.iter() {\n+                    match *i {\n+                        PathType(ref ty) => {\n+                            write!(w, \"<li><code>{}</code></li>\", *ty);\n+                        }\n+                        OtherType(ref generics, ref trait_, ref for_) => {\n+                            write!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                                   *generics, *trait_, *for_);\n                         }\n                     }\n-                    write!(w, \"</ul>\");\n                 }\n-                None => {}\n+                write!(w, \"</ul>\");\n             }\n-        })\n+            None => {}\n+        }\n     })\n }\n \n@@ -1422,36 +1330,34 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n \n fn render_methods(w: &mut Writer, it: &clean::Item) {\n     local_data::get(cache_key, |cache| {\n-        let cache = cache.unwrap();\n-        cache.read(|c| {\n-            match c.impls.find(&it.id) {\n-                Some(v) => {\n-                    let mut non_trait = v.iter().filter(|p| {\n-                        p.n0_ref().trait_.is_none()\n-                    });\n-                    let non_trait = non_trait.to_owned_vec();\n-                    let mut traits = v.iter().filter(|p| {\n-                        p.n0_ref().trait_.is_some()\n-                    });\n-                    let traits = traits.to_owned_vec();\n-\n-                    if non_trait.len() > 0 {\n-                        write!(w, \"<h2 id='methods'>Methods</h2>\");\n-                        for &(ref i, ref dox) in non_trait.move_iter() {\n-                            render_impl(w, i, dox);\n-                        }\n+        let c = cache.unwrap().get();\n+        match c.impls.find(&it.id) {\n+            Some(v) => {\n+                let mut non_trait = v.iter().filter(|p| {\n+                    p.n0_ref().trait_.is_none()\n+                });\n+                let non_trait = non_trait.to_owned_vec();\n+                let mut traits = v.iter().filter(|p| {\n+                    p.n0_ref().trait_.is_some()\n+                });\n+                let traits = traits.to_owned_vec();\n+\n+                if non_trait.len() > 0 {\n+                    write!(w, \"<h2 id='methods'>Methods</h2>\");\n+                    for &(ref i, ref dox) in non_trait.move_iter() {\n+                        render_impl(w, i, dox);\n                     }\n-                    if traits.len() > 0 {\n-                        write!(w, \"<h2 id='implementations'>Trait \\\n-                                   Implementations</h2>\");\n-                        for &(ref i, ref dox) in traits.move_iter() {\n-                            render_impl(w, i, dox);\n-                        }\n+                }\n+                if traits.len() > 0 {\n+                    write!(w, \"<h2 id='implementations'>Trait \\\n+                               Implementations</h2>\");\n+                    for &(ref i, ref dox) in traits.move_iter() {\n+                        render_impl(w, i, dox);\n                     }\n                 }\n-                None => {}\n             }\n-        })\n+            None => {}\n+        }\n     })\n }\n \n@@ -1502,27 +1408,26 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n             Some(id) => id,\n         };\n         local_data::get(cache_key, |cache| {\n-            cache.unwrap().read(|cache| {\n-                match cache.traits.find(&trait_id) {\n-                    Some(t) => {\n-                        let name = meth.name.clone();\n-                        match t.methods.iter().find(|t| t.item().name == name) {\n-                            Some(method) => {\n-                                match method.item().doc_value() {\n-                                    Some(s) => {\n-                                        write!(w,\n-                                               \"<div class='docblock'>{}</div>\",\n-                                               Markdown(s));\n-                                    }\n-                                    None => {}\n+            let cache = cache.unwrap().get();\n+            match cache.traits.find(&trait_id) {\n+                Some(t) => {\n+                    let name = meth.name.clone();\n+                    match t.methods.iter().find(|t| t.item().name == name) {\n+                        Some(method) => {\n+                            match method.item().doc_value() {\n+                                Some(s) => {\n+                                    write!(w,\n+                                           \"<div class='docblock'>{}</div>\",\n+                                           Markdown(s));\n                                 }\n+                                None => {}\n                             }\n-                            None => {}\n                         }\n+                        None => {}\n                     }\n-                    None => {}\n                 }\n-            })\n+                None => {}\n+            }\n         })\n     }\n \n@@ -1532,22 +1437,21 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n         None => {}\n         Some(id) => {\n             local_data::get(cache_key, |cache| {\n-                cache.unwrap().read(|cache| {\n-                    match cache.traits.find(&id) {\n-                        Some(t) => {\n-                            for method in t.methods.iter() {\n-                                let n = method.item().name.clone();\n-                                match i.methods.iter().find(|m| m.name == n) {\n-                                    Some(..) => continue,\n-                                    None => {}\n-                                }\n-\n-                                docmeth(w, method.item());\n+                let cache = cache.unwrap().get();\n+                match cache.traits.find(&id) {\n+                    Some(t) => {\n+                        for method in t.methods.iter() {\n+                            let n = method.item().name.clone();\n+                            match i.methods.iter().find(|m| m.name == n) {\n+                                Some(..) => continue,\n+                                None => {}\n                             }\n+\n+                            docmeth(w, method.item());\n                         }\n-                        None => {}\n                     }\n-                })\n+                    None => {}\n+                }\n             })\n         }\n     }"}, {"sha": "ce543eafd2f644d611a1c76ed00863debd803c69", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -646,7 +646,6 @@ impl Drop for UdpWatcher {\n \n #[cfg(test)]\n mod test {\n-    use std::comm::oneshot;\n     use std::rt::test::*;\n     use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n                         RtioUdpSocket};\n@@ -689,7 +688,7 @@ mod test {\n \n     #[test]\n     fn listen_ip4() {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n         let addr = next_test_ip4();\n \n         do spawn {\n@@ -725,7 +724,7 @@ mod test {\n \n     #[test]\n     fn listen_ip6() {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n         let addr = next_test_ip6();\n \n         do spawn {\n@@ -761,7 +760,7 @@ mod test {\n \n     #[test]\n     fn udp_recv_ip4() {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n         let client = next_test_ip4();\n         let server = next_test_ip4();\n \n@@ -793,7 +792,7 @@ mod test {\n \n     #[test]\n     fn udp_recv_ip6() {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n         let client = next_test_ip6();\n         let server = next_test_ip6();\n \n@@ -828,7 +827,7 @@ mod test {\n         use std::rt::rtio::*;\n         let addr = next_test_ip4();\n         static MAX: uint = 5000;\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n@@ -865,7 +864,7 @@ mod test {\n     fn test_udp_twice() {\n         let server_addr = next_test_ip4();\n         let client_addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let mut client = UdpWatcher::bind(local_loop(), client_addr).unwrap();\n@@ -896,8 +895,8 @@ mod test {\n         let client_in_addr = next_test_ip4();\n         static MAX: uint = 500_000;\n \n-        let (p1, c1) = oneshot();\n-        let (p2, c2) = oneshot();\n+        let (p1, c1) = Chan::new();\n+        let (p2, c2) = Chan::new();\n \n         do spawn {\n             let l = local_loop();\n@@ -953,12 +952,12 @@ mod test {\n     #[test]\n     fn test_read_and_block() {\n         let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n-            let (port2, chan2) = stream();\n+            let (port2, chan2) = Chan::new();\n             chan.send(port2);\n             let mut stream = acceptor.accept().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -1026,7 +1025,7 @@ mod test {\n     // thread, close itself, and then come back to the last thread.\n     #[test]\n     fn test_homing_closes_correctly() {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do task::spawn_sched(task::SingleThreaded) {\n             let listener = UdpWatcher::bind(local_loop(), next_test_ip4()).unwrap();\n@@ -1048,9 +1047,9 @@ mod test {\n         use std::rt::sched::{Shutdown, TaskFromFriend};\n         use std::rt::sleeper_list::SleeperList;\n         use std::rt::task::Task;\n-        use std::rt::task::UnwindResult;\n         use std::rt::thread::Thread;\n         use std::rt::deque::BufferPool;\n+        use std::task::TaskResult;\n         use std::unstable::run_in_bare_thread;\n         use uvio::UvEventLoop;\n \n@@ -1072,12 +1071,12 @@ mod test {\n             let handle2 = sched2.make_handle();\n             let tasksFriendHandle = sched2.make_handle();\n \n-            let on_exit: proc(UnwindResult) = proc(exit_status) {\n+            let on_exit: proc(TaskResult) = proc(exit_status) {\n                 let mut handle1 = handle1;\n                 let mut handle2 = handle2;\n                 handle1.send(Shutdown);\n                 handle2.send(Shutdown);\n-                assert!(exit_status.is_success());\n+                assert!(exit_status.is_ok());\n             };\n \n             unsafe fn local_io() -> &'static mut IoFactory {\n@@ -1148,7 +1147,7 @@ mod test {\n \n     #[should_fail] #[test]\n     fn tcp_stream_fail_cleanup() {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n         let addr = next_test_ip4();\n \n         do spawn {\n@@ -1172,7 +1171,7 @@ mod test {\n     #[should_fail] #[test]\n     fn udp_fail_other_task() {\n         let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         // force the handle to be created on a different scheduler, failure in\n         // the original task will force a homing operation back to this\n@@ -1190,7 +1189,7 @@ mod test {\n     #[test]\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure1() {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n         let addr = next_test_ip4();\n \n         do spawn {\n@@ -1208,7 +1207,7 @@ mod test {\n     #[test]\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure2() {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n         let addr = next_test_ip4();\n \n         do spawn {\n@@ -1229,7 +1228,7 @@ mod test {\n     #[test]\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure3() {\n-        let (port, chan) = stream();\n+        let (port, chan) = Chan::new();\n         let addr = next_test_ip4();\n \n         do spawn {"}, {"sha": "814205cbbf1ccf8f3233a24971b52ba2cca0efd5", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -231,7 +231,6 @@ impl HomingIO for PipeAcceptor {\n \n #[cfg(test)]\n mod tests {\n-    use std::comm::oneshot;\n     use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n     use std::rt::test::next_test_unix;\n \n@@ -274,7 +273,7 @@ mod tests {\n     fn connect() {\n         let path = next_test_unix();\n         let path2 = path.clone();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n@@ -298,7 +297,7 @@ mod tests {\n     fn connect_fail() {\n         let path = next_test_unix();\n         let path2 = path.clone();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();"}, {"sha": "f082aef003c60bcf00f1526999b551ced7984991", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -11,7 +11,7 @@\n use std::libc::c_int;\n use std::io::signal::Signum;\n use std::rt::sched::{SchedHandle, Scheduler};\n-use std::comm::{SharedChan, SendDeferred};\n+use std::comm::SharedChan;\n use std::rt::local::Local;\n use std::rt::rtio::RtioSignal;\n \n@@ -78,13 +78,11 @@ mod test {\n     use super::*;\n     use super::super::local_loop;\n     use std::io::signal;\n-    use std::comm::{SharedChan, stream};\n \n     #[test]\n     fn closing_channel_during_drop_doesnt_kill_everything() {\n         // see issue #10375, relates to timers as well.\n-        let (port, chan) = stream();\n-        let chan = SharedChan::new(chan);\n+        let (port, chan) = SharedChan::new();\n         let _signal = SignalWatcher::new(local_loop(), signal::Interrupt,\n                                          chan);\n "}, {"sha": "ab143d6e8b077ada20042d4497e0cc8381f167e3", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{oneshot, stream, PortOne, ChanOne, SendDeferred};\n use std::libc::c_int;\n use std::rt::BlockedTask;\n use std::rt::local::Local;\n@@ -24,12 +23,13 @@ pub struct TimerWatcher {\n     handle: *uvll::uv_timer_t,\n     home: SchedHandle,\n     action: Option<NextAction>,\n+    id: uint, // see comments in timer_cb\n }\n \n pub enum NextAction {\n     WakeTask(BlockedTask),\n-    SendOnce(ChanOne<()>),\n-    SendMany(Chan<()>),\n+    SendOnce(Chan<()>),\n+    SendMany(Chan<()>, uint),\n }\n \n impl TimerWatcher {\n@@ -42,6 +42,7 @@ impl TimerWatcher {\n             handle: handle,\n             action: None,\n             home: get_handle_to_current_scheduler!(),\n+            id: 0,\n         };\n         return me.install();\n     }\n@@ -73,6 +74,7 @@ impl RtioTimer for TimerWatcher {\n         // we must temporarily un-home ourselves, then destroy the action, and\n         // then re-home again.\n         let missile = self.fire_homing_missile();\n+        self.id += 1;\n         self.stop();\n         let _missile = match util::replace(&mut self.action, None) {\n             None => missile, // no need to do a homing dance\n@@ -95,13 +97,14 @@ impl RtioTimer for TimerWatcher {\n         self.stop();\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n-        let (port, chan) = oneshot();\n+    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+        let (port, chan) = Chan::new();\n \n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n         let _prev_action = {\n             let _m = self.fire_homing_missile();\n+            self.id += 1;\n             self.stop();\n             self.start(msecs, 0);\n             util::replace(&mut self.action, Some(SendOnce(chan)))\n@@ -111,15 +114,16 @@ impl RtioTimer for TimerWatcher {\n     }\n \n     fn period(&mut self, msecs: u64) -> Port<()> {\n-        let (port, chan) = stream();\n+        let (port, chan) = Chan::new();\n \n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n         let _prev_action = {\n             let _m = self.fire_homing_missile();\n+            self.id += 1;\n             self.stop();\n             self.start(msecs, msecs);\n-            util::replace(&mut self.action, Some(SendMany(chan)))\n+            util::replace(&mut self.action, Some(SendMany(chan, self.id)))\n         };\n \n         return port;\n@@ -136,10 +140,21 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n             let sched: ~Scheduler = Local::take();\n             sched.resume_blocked_task_immediately(task);\n         }\n-        SendOnce(chan) => chan.send_deferred(()),\n-        SendMany(chan) => {\n-            chan.send_deferred(());\n-            timer.action = Some(SendMany(chan));\n+        SendOnce(chan) => { chan.try_send_deferred(()); }\n+        SendMany(chan, id) => {\n+            chan.try_send_deferred(());\n+\n+            // Note that the above operation could have performed some form of\n+            // scheduling. This means that the timer may have decided to insert\n+            // some other action to happen. This 'id' keeps track of the updates\n+            // to the timer, so we only reset the action back to sending on this\n+            // channel if the id has remained the same. This is essentially a\n+            // bug in that we have mutably aliasable memory, but that's libuv\n+            // for you. We're guaranteed to all be running on the same thread,\n+            // so there's no need for any synchronization here.\n+            if timer.id == id {\n+                timer.action = Some(SendMany(chan, id));\n+            }\n         }\n     }\n }\n@@ -181,8 +196,8 @@ mod test {\n         let oport = timer.oneshot(1);\n         let pport = timer.period(1);\n         timer.sleep(1);\n-        assert_eq!(oport.try_recv(), None);\n-        assert_eq!(pport.try_recv(), None);\n+        assert_eq!(oport.recv_opt(), None);\n+        assert_eq!(pport.recv_opt(), None);\n         timer.oneshot(1).recv();\n     }\n \n@@ -231,7 +246,7 @@ mod test {\n         let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.try_recv();\n+            timer_port.recv_opt();\n         }\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n@@ -245,7 +260,7 @@ mod test {\n         let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.try_recv();\n+            timer_port.recv_opt();\n         }\n \n         timer.oneshot(1);\n@@ -257,7 +272,7 @@ mod test {\n         let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.try_recv();\n+            timer_port.recv_opt();\n         }\n \n         timer.sleep(1);\n@@ -269,7 +284,7 @@ mod test {\n             let mut timer = TimerWatcher::new(local_loop());\n             timer.oneshot(1000)\n         };\n-        assert_eq!(port.try_recv(), None);\n+        assert_eq!(port.recv_opt(), None);\n     }\n \n     #[test]\n@@ -278,7 +293,7 @@ mod test {\n             let mut timer = TimerWatcher::new(local_loop());\n             timer.period(1000)\n         };\n-        assert_eq!(port.try_recv(), None);\n+        assert_eq!(port.recv_opt(), None);\n     }\n \n     #[test]"}, {"sha": "c5ed464de23c5a972c65ea83d808a87ebc063fea", "filename": "src/libstd/comm.rs", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=2c41a823ccb1e7cea0a29f9048533aaa78c40de6", "patch": "@@ -1,311 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Message passing\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use clone::Clone;\n-use iter::Iterator;\n-use kinds::Send;\n-use option::Option;\n-use rtcomm = rt::comm;\n-\n-/// A trait for things that can send multiple messages.\n-pub trait GenericChan<T> {\n-    /// Sends a message.\n-    fn send(&self, x: T);\n-}\n-\n-/// Things that can send multiple messages and can detect when the receiver\n-/// is closed\n-pub trait GenericSmartChan<T> {\n-    /// Sends a message, or report if the receiver has closed the connection.\n-    fn try_send(&self, x: T) -> bool;\n-}\n-\n-/// Trait for non-rescheduling send operations, similar to `send_deferred` on ChanOne.\n-pub trait SendDeferred<T> {\n-    fn send_deferred(&self, val: T);\n-    fn try_send_deferred(&self, val: T) -> bool;\n-}\n-\n-/// A trait for things that can receive multiple messages.\n-pub trait GenericPort<T> {\n-    /// Receives a message, or fails if the connection closes.\n-    fn recv(&self) -> T;\n-\n-    /// Receives a message, or returns `none` if\n-    /// the connection is closed or closes.\n-    fn try_recv(&self) -> Option<T>;\n-\n-    /// Returns an iterator that breaks once the connection closes.\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~rust\n-    /// do spawn {\n-    ///     for x in port.recv_iter() {\n-    ///         if pred(x) { break; }\n-    ///         println!(\"{}\", x);\n-    ///     }\n-    /// }\n-    /// ~~~\n-    fn recv_iter<'a>(&'a self) -> RecvIterator<'a, Self> {\n-        RecvIterator { port: self }\n-    }\n-}\n-\n-pub struct RecvIterator<'a, P> {\n-    priv port: &'a P,\n-}\n-\n-impl<'a, T, P: GenericPort<T>> Iterator<T> for RecvIterator<'a, P> {\n-    fn next(&mut self) -> Option<T> {\n-        self.port.try_recv()\n-    }\n-}\n-\n-/// Ports that can `peek`\n-pub trait Peekable<T> {\n-    /// Returns true if a message is available\n-    fn peek(&self) -> bool;\n-}\n-\n-/* priv is disabled to allow users to get at traits like Select. */\n-pub struct PortOne<T> { /* priv */ x: rtcomm::PortOne<T> }\n-pub struct ChanOne<T> { /* priv */ x: rtcomm::ChanOne<T> }\n-\n-pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n-    let (p, c) = rtcomm::oneshot();\n-    (PortOne { x: p }, ChanOne { x: c })\n-}\n-\n-pub struct Port<T> { /* priv */ x: rtcomm::Port<T> }\n-pub struct Chan<T> { /* priv */ x: rtcomm::Chan<T> }\n-\n-pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n-    let (p, c) = rtcomm::stream();\n-    (Port { x: p }, Chan { x: c })\n-}\n-\n-impl<T: Send> ChanOne<T> {\n-    pub fn send(self, val: T) {\n-        let ChanOne { x: c } = self;\n-        c.send(val)\n-    }\n-\n-    pub fn try_send(self, val: T) -> bool {\n-        let ChanOne { x: c } = self;\n-        c.try_send(val)\n-    }\n-\n-    pub fn send_deferred(self, val: T) {\n-        let ChanOne { x: c } = self;\n-        c.send_deferred(val)\n-    }\n-\n-    pub fn try_send_deferred(self, val: T) -> bool {\n-        let ChanOne{ x: c } = self;\n-        c.try_send_deferred(val)\n-    }\n-}\n-\n-impl<T: Send> PortOne<T> {\n-    pub fn recv(self) -> T {\n-        let PortOne { x: p } = self;\n-        p.recv()\n-    }\n-\n-    pub fn try_recv(self) -> Option<T> {\n-        let PortOne { x: p } = self;\n-        p.try_recv()\n-    }\n-}\n-\n-impl<T: Send> Peekable<T>  for PortOne<T> {\n-    fn peek(&self) -> bool {\n-        let &PortOne { x: ref p } = self;\n-        p.peek()\n-    }\n-}\n-\n-impl<T: Send> GenericChan<T> for Chan<T> {\n-    fn send(&self, val: T) {\n-        let &Chan { x: ref c } = self;\n-        c.send(val)\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for Chan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        let &Chan { x: ref c } = self;\n-        c.try_send(val)\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for Chan<T> {\n-    fn send_deferred(&self, val: T) {\n-        let &Chan { x: ref c } = self;\n-        c.send_deferred(val)\n-    }\n-\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        let &Chan { x: ref c } = self;\n-        c.try_send_deferred(val)\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for Port<T> {\n-    fn recv(&self) -> T {\n-        let &Port { x: ref p } = self;\n-        p.recv()\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        let &Port { x: ref p } = self;\n-        p.try_recv()\n-    }\n-}\n-\n-impl<T: Send> Peekable<T> for Port<T> {\n-    fn peek(&self) -> bool {\n-        let &Port { x: ref p } = self;\n-        p.peek()\n-    }\n-}\n-\n-\n-pub struct SharedChan<T> { /* priv */ x: rtcomm::SharedChan<T> }\n-\n-impl<T: Send> SharedChan<T> {\n-    pub fn new(c: Chan<T>) -> SharedChan<T> {\n-        let Chan { x: c } = c;\n-        SharedChan { x: rtcomm::SharedChan::new(c) }\n-    }\n-}\n-\n-impl<T: Send> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, val: T) {\n-        let &SharedChan { x: ref c } = self;\n-        c.send(val)\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        let &SharedChan { x: ref c } = self;\n-        c.try_send(val)\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for SharedChan<T> {\n-    fn send_deferred(&self, val: T) {\n-        let &SharedChan { x: ref c } = self;\n-        c.send_deferred(val)\n-    }\n-\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        let &SharedChan { x: ref c } = self;\n-        c.try_send_deferred(val)\n-    }\n-}\n-\n-impl<T: Send> Clone for SharedChan<T> {\n-    fn clone(&self) -> SharedChan<T> {\n-        let &SharedChan { x: ref c } = self;\n-        SharedChan { x: c.clone() }\n-    }\n-}\n-\n-pub struct SharedPort<T> { /* priv */ x: rtcomm::SharedPort<T> }\n-\n-impl<T: Send> SharedPort<T> {\n-    pub fn new(p: Port<T>) -> SharedPort<T> {\n-        let Port { x: p } = p;\n-        SharedPort { x: rtcomm::SharedPort::new(p) }\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for SharedPort<T> {\n-    fn recv(&self) -> T {\n-        let &SharedPort { x: ref p } = self;\n-        p.recv()\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        let &SharedPort { x: ref p } = self;\n-        p.try_recv()\n-    }\n-}\n-\n-impl<T: Send> Clone for SharedPort<T> {\n-    fn clone(&self) -> SharedPort<T> {\n-        let &SharedPort { x: ref p } = self;\n-        SharedPort { x: p.clone() }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use comm::*;\n-    use prelude::*;\n-\n-    #[test]\n-    fn test_nested_recv_iter() {\n-        let (port, chan) = stream::<int>();\n-        let (total_port, total_chan) = oneshot::<int>();\n-\n-        do spawn {\n-            let mut acc = 0;\n-            for x in port.recv_iter() {\n-                acc += x;\n-                for x in port.recv_iter() {\n-                    acc += x;\n-                    for x in port.try_recv().move_iter() {\n-                        acc += x;\n-                        total_chan.send(acc);\n-                    }\n-                }\n-            }\n-        }\n-\n-        chan.send(3);\n-        chan.send(1);\n-        chan.send(2);\n-        assert_eq!(total_port.recv(), 6);\n-    }\n-\n-    #[test]\n-    fn test_recv_iter_break() {\n-        let (port, chan) = stream::<int>();\n-        let (count_port, count_chan) = oneshot::<int>();\n-\n-        do spawn {\n-            let mut count = 0;\n-            for x in port.recv_iter() {\n-                if count >= 3 {\n-                    count_chan.send(count);\n-                    break;\n-                } else {\n-                    count += x;\n-                }\n-            }\n-        }\n-\n-        chan.send(2);\n-        chan.send(2);\n-        chan.send(2);\n-        chan.send(2);\n-        assert_eq!(count_port.recv(), 4);\n-    }\n-}"}, {"sha": "bd1d6fed901caf9b382bdbe949133582ab09bcea", "filename": "src/libstd/comm/imp.rs", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fcomm%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fcomm%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fimp.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -0,0 +1,337 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! One of the major goals behind this channel implementation is to work\n+//! seamlessly on and off the runtime. This also means that the code isn't\n+//! littered with \"if is_green() { ... } else { ... }\". Right now, the rest of\n+//! the runtime isn't quite ready to for this abstraction to be done very\n+//! nicely, so the conditional \"if green\" blocks are all contained in this inner\n+//! module.\n+//!\n+//! The goal of this module is to mirror what the runtime \"should be\", not the\n+//! state that it is currently in today. You'll notice that there is no mention\n+//! of schedulers or is_green inside any of the channel code, it is currently\n+//! entirely contained in this one module.\n+//!\n+//! In the ideal world, nothing in this module exists and it is all implemented\n+//! elsewhere in the runtime (in the proper location). All of this code is\n+//! structured in order to easily refactor this to the correct location whenever\n+//! we have the trait objects in place to serve as the boundary of the\n+//! abstraction.\n+\n+use iter::{range, Iterator};\n+use ops::Drop;\n+use option::{Some, None, Option};\n+use rt::local::Local;\n+use rt::sched::{SchedHandle, Scheduler, TaskFromFriend};\n+use rt::thread::Thread;\n+use rt;\n+use unstable::mutex::Mutex;\n+use unstable::sync::UnsafeArc;\n+\n+// A task handle is a method of waking up a blocked task. The handle itself\n+// is completely opaque and only has a wake() method defined on it. This\n+// method will wake the method regardless of the context of the thread which\n+// is currently calling wake().\n+//\n+// This abstraction should be able to be created when putting a task to\n+// sleep. This should basically be a method on whatever the local Task is,\n+// consuming the local Task.\n+\n+pub struct TaskHandle {\n+    priv inner: TaskRepr\n+}\n+enum TaskRepr {\n+    Green(rt::BlockedTask, *mut SchedHandle),\n+    Native(NativeWakeupStyle),\n+}\n+enum NativeWakeupStyle {\n+    ArcWakeup(UnsafeArc<Mutex>),    // shared mutex to synchronize on\n+    LocalWakeup(*mut Mutex),        // synchronize on the task-local mutex\n+}\n+\n+impl TaskHandle {\n+    // Signal that this handle should be woken up. The `can_resched`\n+    // argument indicates whether the current task could possibly be\n+    // rescheduled or not. This does not have a lot of meaning for the\n+    // native case, but for an M:N case it indicates whether a context\n+    // switch can happen or not.\n+    pub fn wake(self, can_resched: bool) {\n+        match self.inner {\n+            Green(task, handle) => {\n+                // If we have a local scheduler, then use that to run the\n+                // blocked task, otherwise we can use the handle to send the\n+                // task back to its home.\n+                if rt::in_green_task_context() {\n+                    if can_resched {\n+                        task.wake().map(Scheduler::run_task);\n+                    } else {\n+                        let mut s: ~Scheduler = Local::take();\n+                        s.enqueue_blocked_task(task);\n+                        Local::put(s);\n+                    }\n+                } else {\n+                    let task = match task.wake() {\n+                        Some(task) => task, None => return\n+                    };\n+                    // XXX: this is not an easy section of code to refactor.\n+                    //      If this handle is owned by the Task (which it\n+                    //      should be), then this would be a use-after-free\n+                    //      because once the task is pushed onto the message\n+                    //      queue, the handle is gone.\n+                    //\n+                    //      Currently the handle is instead owned by the\n+                    //      Port/Chan pair, which means that because a\n+                    //      channel is invoking this method the handle will\n+                    //      continue to stay alive for the entire duration\n+                    //      of this method. This will require thought when\n+                    //      moving the handle into the task.\n+                    unsafe { (*handle).send(TaskFromFriend(task)) }\n+                }\n+            }\n+\n+            // Note that there are no use-after-free races in this code. In\n+            // the arc-case, we own the lock, and in the local case, we're\n+            // using a lock so it's guranteed that they aren't running while\n+            // we hold the lock.\n+            Native(ArcWakeup(lock)) => {\n+                unsafe {\n+                    let lock = lock.get();\n+                    (*lock).lock();\n+                    (*lock).signal();\n+                    (*lock).unlock();\n+                }\n+            }\n+            Native(LocalWakeup(lock)) => {\n+                unsafe {\n+                    (*lock).lock();\n+                    (*lock).signal();\n+                    (*lock).unlock();\n+                }\n+            }\n+        }\n+    }\n+\n+    // Trashes handle to this task. This ensures that necessary memory is\n+    // deallocated, and there may be some extra assertions as well.\n+    pub fn trash(self) {\n+        match self.inner {\n+            Green(task, _) => task.assert_already_awake(),\n+            Native(..) => {}\n+        }\n+    }\n+}\n+\n+// This structure is an abstraction of what should be stored in the local\n+// task itself. This data is currently stored inside of each channel, but\n+// this should rather be stored in each task (and channels will still\n+// continue to lazily initialize this data).\n+\n+pub struct TaskData {\n+    priv handle: Option<SchedHandle>,\n+    priv lock: Mutex,\n+}\n+\n+impl TaskData {\n+    pub fn new() -> TaskData {\n+        TaskData {\n+            handle: None,\n+            lock: unsafe { Mutex::empty() },\n+        }\n+    }\n+}\n+\n+impl Drop for TaskData {\n+    fn drop(&mut self) {\n+        unsafe { self.lock.destroy() }\n+    }\n+}\n+\n+// Now this is the really fun part. This is where all the M:N/1:1-agnostic\n+// along with recv/select-agnostic blocking information goes. A \"blocking\n+// context\" is really just a stack-allocated structure (which is probably\n+// fine to be a stack-trait-object).\n+//\n+// This has some particularly strange interfaces, but the reason for all\n+// this is to support selection/recv/1:1/M:N all in one bundle.\n+\n+pub struct BlockingContext<'a> {\n+    priv inner: BlockingRepr<'a>\n+}\n+\n+enum BlockingRepr<'a> {\n+    GreenBlock(rt::BlockedTask, &'a mut Scheduler),\n+    NativeBlock(Option<UnsafeArc<Mutex>>),\n+}\n+\n+impl<'a> BlockingContext<'a> {\n+    // Creates one blocking context. The data provided should in theory be\n+    // acquired from the local task, but it is instead acquired from the\n+    // channel currently.\n+    //\n+    // This function will call `f` with a blocking context, plus the data\n+    // that it is given. This function will then return whether this task\n+    // should actually go to sleep or not. If `true` is returned, then this\n+    // function does not return until someone calls `wake()` on the task.\n+    // If `false` is returned, then this function immediately returns.\n+    //\n+    // # Safety note\n+    //\n+    // Note that this stack closure may not be run on the same stack as when\n+    // this function was called. This means that the environment of this\n+    // stack closure could be unsafely aliased. This is currently prevented\n+    // through the guarantee that this function will never return before `f`\n+    // finishes executing.\n+    pub fn one(data: &mut TaskData,\n+               f: |BlockingContext, &mut TaskData| -> bool) {\n+        if rt::in_green_task_context() {\n+            let sched: ~Scheduler = Local::take();\n+            sched.deschedule_running_task_and_then(|sched, task| {\n+                let ctx = BlockingContext { inner: GreenBlock(task, sched) };\n+                // no need to do something on success/failure other than\n+                // returning because the `block` function for a BlockingContext\n+                // takes care of reawakening itself if the blocking procedure\n+                // fails. If this function is successful, then we're already\n+                // blocked, and if it fails, the task will already be\n+                // rescheduled.\n+                f(ctx, data);\n+            });\n+        } else {\n+            unsafe { data.lock.lock(); }\n+            let ctx = BlockingContext { inner: NativeBlock(None) };\n+            if f(ctx, data) {\n+                unsafe { data.lock.wait(); }\n+            }\n+            unsafe { data.lock.unlock(); }\n+        }\n+    }\n+\n+    // Creates many blocking contexts. The intended use case for this\n+    // function is selection over a number of ports. This will create `amt`\n+    // blocking contexts, yielding them to `f` in turn. If `f` returns\n+    // false, then this function aborts and returns immediately. If `f`\n+    // repeatedly returns `true` `amt` times, then this function will block.\n+    pub fn many(amt: uint, f: |BlockingContext| -> bool) {\n+        if rt::in_green_task_context() {\n+            let sched: ~Scheduler = Local::take();\n+            sched.deschedule_running_task_and_then(|sched, task| {\n+                for handle in task.make_selectable(amt) {\n+                    let ctx = BlockingContext {\n+                        inner: GreenBlock(handle, sched)\n+                    };\n+                    // see comment above in `one` for why no further action is\n+                    // necessary here\n+                    if !f(ctx) { break }\n+                }\n+            });\n+        } else {\n+            // In the native case, our decision to block must be shared\n+            // amongst all of the channels. It may be possible to\n+            // stack-allocate this mutex (instead of putting it in an\n+            // UnsafeArc box), but for now in order to prevent\n+            // use-after-free trivially we place this into a box and then\n+            // pass that around.\n+            unsafe {\n+                let mtx = UnsafeArc::new(Mutex::new());\n+                (*mtx.get()).lock();\n+                let success = range(0, amt).all(|_| {\n+                    f(BlockingContext {\n+                        inner: NativeBlock(Some(mtx.clone()))\n+                    })\n+                });\n+                if success {\n+                    (*mtx.get()).wait();\n+                }\n+                (*mtx.get()).unlock();\n+            }\n+        }\n+    }\n+\n+    // This function will consume this BlockingContext, and optionally block\n+    // if according to the atomic `decision` function. The semantics of this\n+    // functions are:\n+    //\n+    //  * `slot` is required to be a `None`-slot (which is owned by the\n+    //    channel)\n+    //  * The `slot` will be filled in with a blocked version of the current\n+    //    task (with `wake`-ability if this function is successful).\n+    //  * If the `decision` function returns true, then this function\n+    //    immediately returns having relinquished ownership of the task.\n+    //  * If the `decision` function returns false, then the `slot` is reset\n+    //    to `None` and the task is re-scheduled if necessary (remember that\n+    //    the task will not resume executing before the outer `one` or\n+    //    `many` function has returned. This function is expected to have a\n+    //    release memory fence in order for the modifications of `to_wake` to be\n+    //    visible to other tasks. Code which attempts to read `to_wake` should\n+    //    have an acquiring memory fence to guarantee that this write is\n+    //    visible.\n+    //\n+    // This function will return whether the blocking occurred or not.\n+    pub fn block(self,\n+                 data: &mut TaskData,\n+                 slot: &mut Option<TaskHandle>,\n+                 decision: || -> bool) -> bool {\n+        assert!(slot.is_none());\n+        match self.inner {\n+            GreenBlock(task, sched) => {\n+                if data.handle.is_none() {\n+                    data.handle = Some(sched.make_handle());\n+                }\n+                let handle = data.handle.get_mut_ref() as *mut SchedHandle;\n+                *slot = Some(TaskHandle { inner: Green(task, handle) });\n+\n+                if !decision() {\n+                    match slot.take_unwrap().inner {\n+                        Green(task, _) => sched.enqueue_blocked_task(task),\n+                        Native(..) => unreachable!()\n+                    }\n+                    false\n+                } else {\n+                    true\n+                }\n+            }\n+            NativeBlock(shared) => {\n+                *slot = Some(TaskHandle {\n+                    inner: Native(match shared {\n+                        Some(arc) => ArcWakeup(arc),\n+                        None => LocalWakeup(&mut data.lock as *mut Mutex),\n+                    })\n+                });\n+\n+                if !decision() {\n+                    *slot = None;\n+                    false\n+                } else {\n+                    true\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Agnostic method of forcing a yield of the current task\n+pub fn yield_now() {\n+    if rt::in_green_task_context() {\n+        let sched: ~Scheduler = Local::take();\n+        sched.yield_now();\n+    } else {\n+        Thread::yield_now();\n+    }\n+}\n+\n+// Agnostic method of \"maybe yielding\" in order to provide fairness\n+pub fn maybe_yield() {\n+    if rt::in_green_task_context() {\n+        let sched: ~Scheduler = Local::take();\n+        sched.maybe_yield();\n+    } else {\n+        // the OS decides fairness, nothing for us to do.\n+    }\n+}"}, {"sha": "4cbc6c7cbb7ba187da741bec18e8248493dd7200", "filename": "src/libstd/comm/mod.rs", "status": "added", "additions": 1376, "deletions": 0, "changes": 1376, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -0,0 +1,1376 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rust Communication Primitives\n+//!\n+//! Rust makes it very difficult to share data among tasks to prevent race\n+//! conditions and to improve parallelism, but there is often a need for\n+//! communication between concurrent tasks. The primitives defined in this\n+//! module are the building blocks for synchronization in rust.\n+//!\n+//! This module currently provides three main types:\n+//!\n+//! * `Chan`\n+//! * `Port`\n+//! * `SharedChan`\n+//!\n+//! The `Chan` and `SharedChan` types are used to send data to a `Port`. A\n+//! `SharedChan` is clone-able such that many tasks can send simultaneously to\n+//! one receiving port. These communication primitives are *task blocking*, not\n+//! *thread blocking*. This means that if one task is blocked on a channel,\n+//! other tasks can continue to make progress.\n+//!\n+//! Rust channels can be used as if they have an infinite internal buffer. What\n+//! this means is that the `send` operation will never block. `Port`s, on the\n+//! other hand, will block the task if there is no data to be received.\n+//!\n+//! ## Failure Propagation\n+//!\n+//! In addition to being a core primitive for communicating in rust, channels\n+//! and ports are the points at which failure is propagated among tasks.\n+//! Whenever the one half of channel is closed, the other half will have its\n+//! next operation `fail!`. The purpose of this is to allow propagation of\n+//! failure among tasks that are linked to one another via channels.\n+//!\n+//! There are methods on all of `Chan`, `SharedChan`, and `Port` to perform\n+//! their respective operations without failing, however.\n+//!\n+//! ## Outside the Runtime\n+//!\n+//! All channels and ports work seamlessly inside and outside of the rust\n+//! runtime. This means that code may use channels to communicate information\n+//! inside and outside of the runtime. For example, if rust were embedded as an\n+//! FFI module in another application, the rust runtime would probably be\n+//! running in its own external thread pool. Channels created can communicate\n+//! from the native application threads to the rust threads through the use of\n+//! native mutexes and condition variables.\n+//!\n+//! What this means is that if a native thread is using a channel, execution\n+//! will be blocked accordingly by blocking the OS thread.\n+//!\n+//! # Example\n+//!\n+//! ```rust\n+//! // Create a simple streaming channel\n+//! let (port, chan) = Chan::new();\n+//! do spawn {\n+//!     chan.send(10);\n+//! }\n+//! assert_eq!(port.recv(), 10);\n+//!\n+//! // Create a shared channel which can be sent along from many tasks\n+//! let (port, chan) = SharedChan::new();\n+//! for i in range(0, 10) {\n+//!     let chan = chan.clone();\n+//!     do spawn {\n+//!         chan.send(i);\n+//!     }\n+//! }\n+//!\n+//! for _ in range(0, 10) {\n+//!     let j = port.recv();\n+//!     assert!(0 <= j && j < 10);\n+//! }\n+//!\n+//! // The call to recv() will fail!() because the channel has already hung\n+//! // up (or been deallocated)\n+//! let (port, chan) = Chan::new();\n+//! drop(chan);\n+//! port.recv();\n+//! ```\n+\n+// A description of how Rust's channel implementation works\n+//\n+// Channels are supposed to be the basic building block for all other\n+// concurrent primitives that are used in Rust. As a result, the channel type\n+// needs to be highly optimized, flexible, and broad enough for use everywhere.\n+//\n+// The choice of implementation of all channels is to be built on lock-free data\n+// structures. The channels themselves are then consequently also lock-free data\n+// structures. As always with lock-free code, this is a very \"here be dragons\"\n+// territory, especially because I'm unaware of any academic papers which have\n+// gone into great length about channels of these flavors.\n+//\n+// ## Flavors of channels\n+//\n+// Rust channels come in two flavors: streams and shared channels. A stream has\n+// one sender and one receiver while a shared channel could have multiple\n+// senders. This choice heavily influences the design of the protocol set\n+// forth for both senders/receivers.\n+//\n+// ## Concurrent queues\n+//\n+// The basic idea of Rust's Chan/Port types is that send() never blocks, but\n+// recv() obviously blocks. This means that under the hood there must be some\n+// shared and concurrent queue holding all of the actual data.\n+//\n+// With two flavors of channels, two flavors of queues are also used. We have\n+// chosen to use queues from a well-known author which are abbreviated as SPSC\n+// and MPSC (single producer, single consumer and multiple producer, single\n+// consumer). SPSC queues are used for streams while MPSC queues are used for\n+// shared channels.\n+//\n+// ### SPSC optimizations\n+//\n+// The SPSC queue found online is essentially a linked list of nodes where one\n+// half of the nodes are the \"queue of data\" and the other half of nodes are a\n+// cache of unused nodes. The unused nodes are used such that an allocation is\n+// not required on every push() and a free doesn't need to happen on every\n+// pop().\n+//\n+// As found online, however, the cache of nodes is of an infinite size. This\n+// means that if a channel at one point in its life had 50k items in the queue,\n+// then the queue will always have the capacity for 50k items. I believed that\n+// this was an unnecessary limitation of the implementation, so I have altered\n+// the queue to optionally have a bound on the cache size.\n+//\n+// By default, streams will have an unbounded SPSC queue with a small-ish cache\n+// size. The hope is that the cache is still large enough to have very fast\n+// send() operations while not too large such that millions of channels can\n+// coexist at once.\n+//\n+// ### MPSC optimizations\n+//\n+// Right now the MPSC queue has not been optimized. Like the SPSC queue, it uses\n+// a linked list under the hood to earn its unboundedness, but I have not put\n+// forth much effort into having a cache of nodes similar to the SPSC queue.\n+//\n+// For now, I believe that this is \"ok\" because shared channels are not the most\n+// common type, but soon we may wish to revisit this queue choice and determine\n+// another candidate for backend storage of shared channels.\n+//\n+// ## Overview of the Implementation\n+//\n+// Now that there's a little background on the concurrent queues used, it's\n+// worth going into much more detail about the channels themselves. The basic\n+// pseudocode for a send/recv are:\n+//\n+//\n+//      send(t)                             recv()\n+//        queue.push(t)                       return if queue.pop()\n+//        if increment() == -1                deschedule {\n+//          wakeup()                            if decrement() > 0\n+//                                                cancel_deschedule()\n+//                                            }\n+//                                            queue.pop()\n+//\n+// As mentioned before, there are no locks in this implementation, only atomic\n+// instructions are used.\n+//\n+// ### The internal atomic counter\n+//\n+// Every channel/port/shared channel have a shared counter with their\n+// counterparts to keep track of the size of the queue. This counter is used to\n+// abort descheduling by the receiver and to know when to wake up on the sending\n+// side.\n+//\n+// As seen in the pseudocode, senders will increment this count and receivers\n+// will decrement the count. The theory behind this is that if a sender sees a\n+// -1 count, it will wake up the receiver, and if the receiver sees a 1+ count,\n+// then it doesn't need to block.\n+//\n+// The recv() method has a beginning call to pop(), and if successful, it needs\n+// to decrement the count. It is a crucial implementation detail that this\n+// decrement does *not* happen to the shared counter. If this were the case,\n+// then it would be possible for the counter to be very negative when there were\n+// no receivers waiting, in which case the senders would have to determine when\n+// it was actually appropriate to wake up a receiver.\n+//\n+// Instead, the \"steal count\" is kept track of separately (not atomically\n+// because it's only used by ports), and then the decrement() call when\n+// descheduling will lump in all of the recent steals into one large decrement.\n+//\n+// The implication of this is that if a sender sees a -1 count, then there's\n+// guaranteed to be a waiter waiting!\n+//\n+// ## Native Implementation\n+//\n+// A major goal of these channels is to work seamlessly on and off the runtime.\n+// All of the previous race conditions have been worded in terms of\n+// scheduler-isms (which is obviously not available without the runtime).\n+//\n+// For now, native usage of channels (off the runtime) will fall back onto\n+// mutexes/cond vars for descheduling/atomic decisions. The no-contention path\n+// is still entirely lock-free, the \"deschedule\" blocks above are surrounded by\n+// a mutex and the \"wakeup\" blocks involve grabbing a mutex and signaling on a\n+// condition variable.\n+//\n+// ## Select\n+//\n+// Being able to support selection over channels has greatly influenced this\n+// design, and not only does selection need to work inside the runtime, but also\n+// outside the runtime.\n+//\n+// The implementation is fairly straightforward. The goal of select() is not to\n+// return some data, but only to return which channel can receive data without\n+// blocking. The implementation is essentially the entire blocking procedure\n+// followed by an increment as soon as its woken up. The cancellation procedure\n+// involves an increment and swapping out of to_wake to acquire ownership of the\n+// task to unblock.\n+//\n+// Sadly this current implementation requires multiple allocations, so I have\n+// seen the throughput of select() be much worse than it should be. I do not\n+// believe that there is anything fundamental which needs to change about these\n+// channels, however, in order to support a more efficient select().\n+//\n+// # Conclusion\n+//\n+// And now that you've seen all the races that I found and attempted to fix,\n+// here's the code for you to find some more!\n+\n+use cast;\n+use clone::Clone;\n+use container::Container;\n+use int;\n+use iter::Iterator;\n+use kinds::Send;\n+use ops::Drop;\n+use option::{Option, Some, None};\n+use rt::thread::Thread;\n+use unstable::atomics::{AtomicInt, AtomicBool, SeqCst, Relaxed};\n+use vec::{ImmutableVector, OwnedVector};\n+\n+use spsc = rt::spsc_queue;\n+use mpsc = rt::mpsc_queue;\n+\n+use self::imp::{TaskHandle, TaskData, BlockingContext};\n+pub use self::select::Select;\n+\n+macro_rules! test (\n+    { fn $name:ident() $b:block $($a:attr)*} => (\n+        mod $name {\n+            #[allow(unused_imports)];\n+\n+            use util;\n+            use super::super::*;\n+            use prelude::*;\n+\n+            fn f() $b\n+\n+            $($a)* #[test] fn uv() { f() }\n+            $($a)* #[test]\n+            #[ignore(cfg(windows))] // FIXME(#11003)\n+            fn native() {\n+                use unstable::run_in_bare_thread;\n+                run_in_bare_thread(f);\n+            }\n+        }\n+    )\n+)\n+\n+mod imp;\n+mod select;\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Helper type to abstract ports for channels and shared channels\n+///////////////////////////////////////////////////////////////////////////////\n+\n+enum Consumer<T> {\n+    SPSC(spsc::Consumer<T, Packet>),\n+    MPSC(mpsc::Consumer<T, Packet>),\n+}\n+\n+impl<T: Send> Consumer<T>{\n+    unsafe fn packet(&self) -> *mut Packet {\n+        match *self {\n+            SPSC(ref c) => c.packet(),\n+            MPSC(ref c) => c.packet(),\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Public structs\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// The receiving-half of Rust's channel type. This half can only be owned by\n+/// one task\n+pub struct Port<T> {\n+    priv queue: Consumer<T>,\n+}\n+\n+/// An iterator over messages received on a port, this iterator will block\n+/// whenever `next` is called, waiting for a new message, and `None` will be\n+/// returned when the corresponding channel has hung up.\n+pub struct PortIterator<'a, T> {\n+    priv port: &'a Port<T>\n+}\n+\n+/// The sending-half of Rust's channel type. This half can only be owned by one\n+/// task\n+pub struct Chan<T> {\n+    priv queue: spsc::Producer<T, Packet>,\n+}\n+\n+/// The sending-half of Rust's channel type. This half can be shared among many\n+/// tasks by creating copies of itself through the `clone` method.\n+pub struct SharedChan<T> {\n+    priv queue: mpsc::Producer<T, Packet>,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Internal struct definitions\n+///////////////////////////////////////////////////////////////////////////////\n+\n+struct Packet {\n+    cnt: AtomicInt, // How many items are on this channel\n+    steals: int,    // How many times has a port received without blocking?\n+    to_wake: Option<TaskHandle>, // Task to wake up\n+\n+    data: TaskData,\n+\n+    // This lock is used to wake up native threads blocked in select. The\n+    // `lock` field is not used because the thread blocking in select must\n+    // block on only one mutex.\n+    //selection_lock: Option<UnsafeArc<Mutex>>,\n+\n+    // The number of channels which are currently using this packet. This is\n+    // used to reference count shared channels.\n+    channels: AtomicInt,\n+\n+    selecting: AtomicBool,\n+    selection_id: uint,\n+    select_next: *mut Packet,\n+    select_prev: *mut Packet,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// All implementations -- the fun part\n+///////////////////////////////////////////////////////////////////////////////\n+\n+static DISCONNECTED: int = int::min_value;\n+static RESCHED_FREQ: int = 200;\n+\n+impl Packet {\n+    fn new() -> Packet {\n+        Packet {\n+            cnt: AtomicInt::new(0),\n+            steals: 0,\n+            to_wake: None,\n+            data: TaskData::new(),\n+            channels: AtomicInt::new(1),\n+\n+            selecting: AtomicBool::new(false),\n+            selection_id: 0,\n+            select_next: 0 as *mut Packet,\n+            select_prev: 0 as *mut Packet,\n+        }\n+    }\n+\n+    // Increments the channel size count, preserving the disconnected state if\n+    // the other end has disconnected.\n+    fn increment(&mut self) -> int {\n+        match self.cnt.fetch_add(1, SeqCst) {\n+            DISCONNECTED => {\n+                // see the comment in 'try' for a shared channel for why this\n+                // window of \"not disconnected\" is \"ok\".\n+                self.cnt.store(DISCONNECTED, SeqCst);\n+                DISCONNECTED\n+            }\n+            n => n\n+        }\n+    }\n+\n+    // Decrements the reference count of the channel, returning whether the task\n+    // should block or not. This assumes that the task is ready to sleep in that\n+    // the `to_wake` field has already been filled in. Once this decrement\n+    // happens, the task could wake up on the other end.\n+    //\n+    // From an implementation perspective, this is also when our \"steal count\"\n+    // gets merged into the \"channel count\". Our steal count is reset to 0 after\n+    // this function completes.\n+    //\n+    // As with increment(), this preserves the disconnected state if the\n+    // channel is disconnected.\n+    fn decrement(&mut self) -> bool {\n+        let steals = self.steals;\n+        self.steals = 0;\n+        match self.cnt.fetch_sub(1 + steals, SeqCst) {\n+            DISCONNECTED => {\n+                self.cnt.store(DISCONNECTED, SeqCst);\n+                false\n+            }\n+            n => {\n+                assert!(n >= 0);\n+                n - steals <= 0\n+            }\n+        }\n+    }\n+\n+    // Helper function for select, tests whether this port can receive without\n+    // blocking (obviously not an atomic decision).\n+    fn can_recv(&self) -> bool {\n+        let cnt = self.cnt.load(SeqCst);\n+        cnt == DISCONNECTED || cnt - self.steals > 0\n+    }\n+\n+    // This function must have had at least an acquire fence before it to be\n+    // properly called.\n+    fn wakeup(&mut self, can_resched: bool) {\n+        self.to_wake.take_unwrap().wake(can_resched);\n+        self.selecting.store(false, Relaxed);\n+    }\n+\n+    // Aborts the selection process for a port. This happens as part of select()\n+    // once the task has reawoken. This will place the channel back into a\n+    // consistent state which is ready to be received from again.\n+    //\n+    // The method of doing this is a little subtle. These channels have the\n+    // invariant that if -1 is seen, then to_wake is always Some(..) and should\n+    // be woken up. This aborting process at least needs to add 1 to the\n+    // reference count, but that is not guaranteed to make the count positive\n+    // (our steal count subtraction could mean that after the addition the\n+    // channel count is still negative).\n+    //\n+    // In order to get around this, we force our channel count to go above 0 by\n+    // adding a large number >= 1 to it. This way no sender will see -1 unless\n+    // we are indeed blocking. This \"extra lump\" we took out of the channel\n+    // becomes our steal count (which will get re-factored into the count on the\n+    // next blocking recv)\n+    //\n+    // The return value of this method is whether there is data on this channel\n+    // to receive or not.\n+    fn abort_selection(&mut self, take_to_wake: bool) -> bool {\n+        // make sure steals + 1 makes the count go non-negative\n+        let steals = {\n+            let cnt = self.cnt.load(SeqCst);\n+            if cnt < 0 && cnt != DISCONNECTED {-cnt} else {0}\n+        };\n+        let prev = self.cnt.fetch_add(steals + 1, SeqCst);\n+\n+        // If we were previously disconnected, then we know for sure that there\n+        // is no task in to_wake, so just keep going\n+        if prev == DISCONNECTED {\n+            assert!(self.to_wake.is_none());\n+            self.cnt.store(DISCONNECTED, SeqCst);\n+            self.selecting.store(false, SeqCst);\n+            true // there is data, that data is that we're disconnected\n+        } else {\n+            let cur = prev + steals + 1;\n+            assert!(cur >= 0);\n+\n+            // If the previous count was negative, then we just made things go\n+            // positive, hence we passed the -1 boundary and we're responsible\n+            // for removing the to_wake() field and trashing it.\n+            if prev < 0 {\n+                if take_to_wake {\n+                    self.to_wake.take_unwrap().trash();\n+                } else {\n+                    assert!(self.to_wake.is_none());\n+                }\n+\n+                // We woke ourselves up, we're responsible for cancelling\n+                assert!(self.selecting.load(Relaxed));\n+                self.selecting.store(false, Relaxed);\n+            }\n+            assert_eq!(self.steals, 0);\n+            self.steals = steals;\n+\n+            // if we were previously positive, then there's surely data to\n+            // receive\n+            prev >= 0\n+        }\n+    }\n+\n+    // Decrement the reference count on a channel. This is called whenever a\n+    // Chan is dropped and may end up waking up a receiver. It's the receiver's\n+    // responsibility on the other end to figure out that we've disconnected.\n+    unsafe fn drop_chan(&mut self) {\n+        match self.channels.fetch_sub(1, SeqCst) {\n+            1 => {\n+                match self.cnt.swap(DISCONNECTED, SeqCst) {\n+                    -1 => { self.wakeup(false); }\n+                    DISCONNECTED => {}\n+                    n => { assert!(n >= 0); }\n+                }\n+            }\n+            n if n > 1 => {},\n+            n => fail!(\"bad number of channels left {}\", n),\n+        }\n+    }\n+}\n+\n+impl Drop for Packet {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Note that this load is not only an assert for correctness about\n+            // disconnection, but also a proper fence before the read of\n+            // `to_wake`, so this assert cannot be removed with also removing\n+            // the `to_wake` assert.\n+            assert_eq!(self.cnt.load(SeqCst), DISCONNECTED);\n+            assert!(self.to_wake.is_none());\n+            assert_eq!(self.channels.load(SeqCst), 0);\n+        }\n+    }\n+}\n+\n+impl<T: Send> Chan<T> {\n+    /// Creates a new port/channel pair. All data send on the channel returned\n+    /// will become available on the port as well. See the documentation of\n+    /// `Port` and `Chan` to see what's possible with them.\n+    pub fn new() -> (Port<T>, Chan<T>) {\n+        // arbitrary 128 size cache -- this is just a max cache size, not a\n+        // maximum buffer size\n+        let (c, p) = spsc::queue(128, Packet::new());\n+        let c = SPSC(c);\n+        (Port { queue: c }, Chan { queue: p })\n+    }\n+\n+    /// Sends a value along this channel to be received by the corresponding\n+    /// port.\n+    ///\n+    /// Rust channels are infinitely buffered so this method will never block.\n+    /// This method may trigger a rescheduling, however, in order to wake up a\n+    /// blocked receiver (if one is present). If no scheduling is desired, then\n+    /// the `send_deferred` guarantees that there will be no reschedulings.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will fail if the other end of the channel has hung up.\n+    /// This means that if the corresponding port has fallen out of scope, this\n+    /// function will trigger a fail message saying that a message is being sent\n+    /// on a closed channel.\n+    ///\n+    /// Note that if this function does *not* fail, it does not mean that the\n+    /// data will be successfully received. All sends are placed into a queue,\n+    /// so it is possible for a send to succeed (the other end is alive), but\n+    /// then the other end could immediately disconnect.\n+    ///\n+    /// The purpose of this functionality is to propagate failure among tasks.\n+    /// If failure is not desired, then consider using the `try_send` method\n+    pub fn send(&self, t: T) {\n+        if !self.try_send(t) {\n+            fail!(\"sending on a closed channel\");\n+        }\n+    }\n+\n+    /// This function is equivalent in the semantics of `send`, but it\n+    /// guarantees that a rescheduling will never occur when this method is\n+    /// called.\n+    pub fn send_deferred(&self, t: T) {\n+        if !self.try_send_deferred(t) {\n+            fail!(\"sending on a closed channel\");\n+        }\n+    }\n+\n+    /// Attempts to send a value on this channel, returning whether it was\n+    /// successfully sent.\n+    ///\n+    /// A successful send occurs when it is determined that the other end of the\n+    /// channel has not hung up already. An unsuccessful send would be one where\n+    /// the corresponding port has already been deallocated. Note that a return\n+    /// value of `false` means that the data will never be received, but a\n+    /// return value of `true` does *not* mean that the data will be received.\n+    /// It is possible for the corresponding port to hang up immediately after\n+    /// this function returns `true`.\n+    ///\n+    /// Like `send`, this method will never block. If the failure of send cannot\n+    /// be tolerated, then this method should be used instead.\n+    pub fn try_send(&self, t: T) -> bool { self.try(t, true) }\n+\n+    /// This function is equivalent in the semantics of `try_send`, but it\n+    /// guarantees that a rescheduling will never occur when this method is\n+    /// called.\n+    pub fn try_send_deferred(&self, t: T) -> bool { self.try(t, false) }\n+\n+    fn try(&self, t: T, can_resched: bool) -> bool {\n+        unsafe {\n+            let this = cast::transmute_mut(self);\n+            this.queue.push(t);\n+            let packet = this.queue.packet();\n+            match (*packet).increment() {\n+                // As described above, -1 == wakeup\n+                -1 => { (*packet).wakeup(can_resched); true }\n+                // Also as above, SPSC queues must be >= -2\n+                -2 => true,\n+                // We succeeded if we sent data\n+                DISCONNECTED => this.queue.is_empty(),\n+                // In order to prevent starvation of other tasks in situations\n+                // where a task sends repeatedly without ever receiving, we\n+                // occassionally yield instead of doing a send immediately.\n+                // Only doing this if we're doing a rescheduling send, otherwise\n+                // the caller is expecting not to context switch.\n+                //\n+                // Note that we don't unconditionally attempt to yield because\n+                // the TLS overhead can be a bit much.\n+                n => {\n+                    assert!(n >= 0);\n+                    if can_resched && n > 0 && n % RESCHED_FREQ == 0 {\n+                        imp::maybe_yield();\n+                    }\n+                    true\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Chan<T> {\n+    fn drop(&mut self) {\n+        unsafe { (*self.queue.packet()).drop_chan(); }\n+    }\n+}\n+\n+impl<T: Send> SharedChan<T> {\n+    /// Creates a new shared channel and port pair. The purpose of a shared\n+    /// channel is to be cloneable such that many tasks can send data at the\n+    /// same time. All data sent on any channel will become available on the\n+    /// provided port as well.\n+    pub fn new() -> (Port<T>, SharedChan<T>) {\n+        let (c, p) = mpsc::queue(Packet::new());\n+        let c = MPSC(c);\n+        (Port { queue: c }, SharedChan { queue: p })\n+    }\n+\n+    /// Equivalent method to `send` on the `Chan` type (using the same\n+    /// semantics)\n+    pub fn send(&self, t: T) {\n+        if !self.try_send(t) {\n+            fail!(\"sending on a closed channel\");\n+        }\n+    }\n+\n+    /// This function is equivalent in the semantics of `send`, but it\n+    /// guarantees that a rescheduling will never occur when this method is\n+    /// called.\n+    pub fn send_deferred(&self, t: T) {\n+        if !self.try_send_deferred(t) {\n+            fail!(\"sending on a closed channel\");\n+        }\n+    }\n+\n+    /// Equivalent method to `try_send` on the `Chan` type (using the same\n+    /// semantics)\n+    pub fn try_send(&self, t: T) -> bool { self.try(t, true) }\n+\n+    /// This function is equivalent in the semantics of `try_send`, but it\n+    /// guarantees that a rescheduling will never occur when this method is\n+    /// called.\n+    pub fn try_send_deferred(&self, t: T) -> bool { self.try(t, false) }\n+\n+    fn try(&self, t: T, can_resched: bool) -> bool {\n+        unsafe {\n+            // Note that the multiple sender case is a little tricker\n+            // semantically than the single sender case. The logic for\n+            // incrementing is \"add and if disconnected store disconnected\".\n+            // This could end up leading some senders to believe that there\n+            // wasn't a disconnect if in fact there was a disconnect. This means\n+            // that while one thread is attempting to re-store the disconnected\n+            // states, other threads could walk through merrily incrementing\n+            // this very-negative disconnected count. To prevent senders from\n+            // spuriously attempting to send when the channels is actually\n+            // disconnected, the count has a ranged check here.\n+            //\n+            // This is also done for another reason. Remember that the return\n+            // value of this function is:\n+            //\n+            //  `true` == the data *may* be received, this essentially has no\n+            //            meaning\n+            //  `false` == the data will *never* be received, this has a lot of\n+            //             meaning\n+            //\n+            // In the SPSC case, we have a check of 'queue.is_empty()' to see\n+            // whether the data was actually received, but this same condition\n+            // means nothing in a multi-producer context. As a result, this\n+            // preflight check serves as the definitive \"this will never be\n+            // received\". Once we get beyond this check, we have permanently\n+            // entered the realm of \"this may be received\"\n+            let packet = self.queue.packet();\n+            if (*packet).cnt.load(Relaxed) < DISCONNECTED + 1024 {\n+                return false\n+            }\n+\n+            let this = cast::transmute_mut(self);\n+            this.queue.push(t);\n+\n+            match (*packet).increment() {\n+                DISCONNECTED => {} // oh well, we tried\n+                -1 => { (*packet).wakeup(can_resched); }\n+                n => {\n+                    if can_resched && n > 0 && n % RESCHED_FREQ == 0 {\n+                        imp::maybe_yield();\n+                    }\n+                }\n+            }\n+            true\n+        }\n+    }\n+}\n+\n+impl<T: Send> Clone for SharedChan<T> {\n+    fn clone(&self) -> SharedChan<T> {\n+        unsafe { (*self.queue.packet()).channels.fetch_add(1, SeqCst); }\n+        SharedChan { queue: self.queue.clone() }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for SharedChan<T> {\n+    fn drop(&mut self) {\n+        unsafe { (*self.queue.packet()).drop_chan(); }\n+    }\n+}\n+\n+impl<T: Send> Port<T> {\n+    /// Blocks waiting for a value on this port\n+    ///\n+    /// This function will block if necessary to wait for a corresponding send\n+    /// on the channel from its paired `Chan` structure. This port will be woken\n+    /// up when data is ready, and the data will be returned.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Similar to channels, this method will trigger a task failure if the\n+    /// other end of the channel has hung up (been deallocated). The purpose of\n+    /// this is to propagate failure among tasks.\n+    ///\n+    /// If failure is not desired, then there are two options:\n+    ///\n+    /// * If blocking is still desired, the `recv_opt` method will return `None`\n+    ///   when the other end hangs up\n+    ///\n+    /// * If blocking is not desired, then the `try_recv` method will attempt to\n+    ///   peek at a value on this port.\n+    pub fn recv(&self) -> T {\n+        match self.recv_opt() {\n+            Some(t) => t,\n+            None => fail!(\"receiving on a closed channel\"),\n+        }\n+    }\n+\n+    /// Attempts to return a pending value on this port without blocking\n+    ///\n+    /// This method will never block the caller in order to wait for data to\n+    /// become available. Instead, this will always return immediately with a\n+    /// possible option of pending data on the channel.\n+    ///\n+    /// This is useful for a flavor of \"optimistic check\" before deciding to\n+    /// block on a port.\n+    ///\n+    /// This function cannot fail.\n+    pub fn try_recv(&self) -> Option<T> {\n+        self.try_recv_inc(true)\n+    }\n+\n+    fn try_recv_inc(&self, increment: bool) -> Option<T> {\n+        // This is a \"best effort\" situation, so if a queue is inconsistent just\n+        // don't worry about it.\n+        let this = unsafe { cast::transmute_mut(self) };\n+        let ret = match this.queue {\n+            SPSC(ref mut queue) => queue.pop(),\n+            MPSC(ref mut queue) => match queue.pop() {\n+                mpsc::Data(t) => Some(t),\n+                mpsc::Empty => None,\n+\n+                // This is a bit of an interesting case. The channel is\n+                // reported as having data available, but our pop() has\n+                // failed due to the queue being in an inconsistent state.\n+                // This means that there is some pusher somewhere which has\n+                // yet to complete, but we are guaranteed that a pop will\n+                // eventually succeed. In this case, we spin in a yield loop\n+                // because the remote sender should finish their enqueue\n+                // operation \"very quickly\".\n+                //\n+                // Note that this yield loop does *not* attempt to do a green\n+                // yield (regardless of the context), but *always* performs an\n+                // OS-thread yield. The reasoning for this is that the pusher in\n+                // question which is causing the inconsistent state is\n+                // guaranteed to *not* be a blocked task (green tasks can't get\n+                // pre-empted), so it must be on a different OS thread. Also,\n+                // `try_recv` is normally a \"guaranteed no rescheduling\" context\n+                // in a green-thread situation. By yielding control of the\n+                // thread, we will hopefully allow time for the remote task on\n+                // the other OS thread to make progress.\n+                //\n+                // Avoiding this yield loop would require a different queue\n+                // abstraction which provides the guarantee that after M\n+                // pushes have succeeded, at least M pops will succeed. The\n+                // current queues guarantee that if there are N active\n+                // pushes, you can pop N times once all N have finished.\n+                mpsc::Inconsistent => {\n+                    let data;\n+                    loop {\n+                        Thread::yield_now();\n+                        match queue.pop() {\n+                            mpsc::Data(t) => { data = t; break }\n+                            mpsc::Empty => fail!(\"inconsistent => empty\"),\n+                            mpsc::Inconsistent => {}\n+                        }\n+                    }\n+                    Some(data)\n+                }\n+            }\n+        };\n+        if increment && ret.is_some() {\n+            unsafe { (*this.queue.packet()).steals += 1; }\n+        }\n+        return ret;\n+    }\n+\n+    /// Attempt to wait for a value on this port, but does not fail if the\n+    /// corresponding channel has hung up.\n+    ///\n+    /// This implementation of iterators for ports will always block if there is\n+    /// not data available on the port, but it will not fail in the case that\n+    /// the channel has been deallocated.\n+    ///\n+    /// In other words, this function has the same semantics as the `recv`\n+    /// method except for the failure aspect.\n+    ///\n+    /// If the channel has hung up, then `None` is returned. Otherwise `Some` of\n+    /// the value found on the port is returned.\n+    pub fn recv_opt(&self) -> Option<T> {\n+        // optimistic preflight check (scheduling is expensive)\n+        match self.try_recv() { None => {}, data => return data }\n+\n+        let packet;\n+        let this;\n+        unsafe {\n+            this = cast::transmute_mut(self);\n+            packet = this.queue.packet();\n+            BlockingContext::one(&mut (*packet).data, |ctx, data| {\n+                ctx.block(data, &mut (*packet).to_wake, || (*packet).decrement())\n+            });\n+        }\n+\n+        let data = self.try_recv_inc(false);\n+        if data.is_none() &&\n+           unsafe { (*packet).cnt.load(SeqCst) } != DISCONNECTED {\n+            fail!(\"bug: woke up too soon\");\n+        }\n+        return data;\n+    }\n+\n+    /// Returns an iterator which will block waiting for messages, but never\n+    /// `fail!`. It will return `None` when the channel has hung up.\n+    pub fn iter<'a>(&'a self) -> PortIterator<'a, T> {\n+        PortIterator { port: self }\n+    }\n+}\n+\n+impl<'a, T: Send> Iterator<T> for PortIterator<'a, T> {\n+    fn next(&mut self) -> Option<T> { self.port.recv_opt() }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Port<T> {\n+    fn drop(&mut self) {\n+        // All we need to do is store that we're disconnected. If the channel\n+        // half has already disconnected, then we'll just deallocate everything\n+        // when the shared packet is deallocated.\n+        unsafe {\n+            (*self.queue.packet()).cnt.store(DISCONNECTED, SeqCst);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+\n+    use task;\n+    use rt::thread::Thread;\n+    use super::*;\n+    use rt::test::*;\n+\n+    test!(fn smoke() {\n+        let (p, c) = Chan::new();\n+        c.send(1);\n+        assert_eq!(p.recv(), 1);\n+    })\n+\n+    test!(fn drop_full() {\n+        let (_p, c) = Chan::new();\n+        c.send(~1);\n+    })\n+\n+    test!(fn drop_full_shared() {\n+        let (_p, c) = SharedChan::new();\n+        c.send(~1);\n+    })\n+\n+    test!(fn smoke_shared() {\n+        let (p, c) = SharedChan::new();\n+        c.send(1);\n+        assert_eq!(p.recv(), 1);\n+        let c = c.clone();\n+        c.send(1);\n+        assert_eq!(p.recv(), 1);\n+    })\n+\n+    #[test]\n+    fn smoke_threads() {\n+        let (p, c) = Chan::new();\n+        do task::spawn_sched(task::SingleThreaded) {\n+            c.send(1);\n+        }\n+        assert_eq!(p.recv(), 1);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn smoke_port_gone() {\n+        let (p, c) = Chan::new();\n+        drop(p);\n+        c.send(1);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn smoke_shared_port_gone() {\n+        let (p, c) = SharedChan::new();\n+        drop(p);\n+        c.send(1);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn smoke_shared_port_gone2() {\n+        let (p, c) = SharedChan::new();\n+        drop(p);\n+        let c2 = c.clone();\n+        drop(c);\n+        c2.send(1);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn port_gone_concurrent() {\n+        let (p, c) = Chan::new();\n+        do task::spawn_sched(task::SingleThreaded) {\n+            p.recv();\n+        }\n+        loop { c.send(1) }\n+    }\n+\n+    #[test] #[should_fail]\n+    fn port_gone_concurrent_shared() {\n+        let (p, c) = SharedChan::new();\n+        let c1 = c.clone();\n+        do task::spawn_sched(task::SingleThreaded) {\n+            p.recv();\n+        }\n+        loop {\n+            c.send(1);\n+            c1.send(1);\n+        }\n+    }\n+\n+    #[test] #[should_fail]\n+    fn smoke_chan_gone() {\n+        let (p, c) = Chan::<int>::new();\n+        drop(c);\n+        p.recv();\n+    }\n+\n+    #[test] #[should_fail]\n+    fn smoke_chan_gone_shared() {\n+        let (p, c) = SharedChan::<()>::new();\n+        let c2 = c.clone();\n+        drop(c);\n+        drop(c2);\n+        p.recv();\n+    }\n+\n+    #[test] #[should_fail]\n+    fn chan_gone_concurrent() {\n+        let (p, c) = Chan::new();\n+        do task::spawn_sched(task::SingleThreaded) {\n+            c.send(1);\n+            c.send(1);\n+        }\n+        loop { p.recv(); }\n+    }\n+\n+    #[test]\n+    fn stress() {\n+        let (p, c) = Chan::new();\n+        do task::spawn_sched(task::SingleThreaded) {\n+            for _ in range(0, 10000) { c.send(1); }\n+        }\n+        for _ in range(0, 10000) {\n+            assert_eq!(p.recv(), 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn stress_shared() {\n+        static AMT: uint = 10000;\n+        static NTHREADS: uint = 8;\n+        let (p, c) = SharedChan::<int>::new();\n+        let (p1, c1) = Chan::new();\n+\n+        do spawn {\n+            for _ in range(0, AMT * NTHREADS) {\n+                assert_eq!(p.recv(), 1);\n+            }\n+            assert_eq!(p.try_recv(), None);\n+            c1.send(());\n+        }\n+\n+        for _ in range(0, NTHREADS) {\n+            let c = c.clone();\n+            do task::spawn_sched(task::SingleThreaded) {\n+                for _ in range(0, AMT) { c.send(1); }\n+            }\n+        }\n+        p1.recv();\n+\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME(#11003)\n+    fn send_from_outside_runtime() {\n+        let (p, c) = Chan::<int>::new();\n+        let (p1, c1) = Chan::new();\n+        do spawn {\n+            c1.send(());\n+            for _ in range(0, 40) {\n+                assert_eq!(p.recv(), 1);\n+            }\n+        }\n+        p1.recv();\n+        let t = do Thread::start {\n+            for _ in range(0, 40) {\n+                c.send(1);\n+            }\n+        };\n+        t.join();\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME(#11003)\n+    fn recv_from_outside_runtime() {\n+        let (p, c) = Chan::<int>::new();\n+        let t = do Thread::start {\n+            for _ in range(0, 40) {\n+                assert_eq!(p.recv(), 1);\n+            }\n+        };\n+        for _ in range(0, 40) {\n+            c.send(1);\n+        }\n+        t.join();\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME(#11003)\n+    fn no_runtime() {\n+        let (p1, c1) = Chan::<int>::new();\n+        let (p2, c2) = Chan::<int>::new();\n+        let t1 = do Thread::start {\n+            assert_eq!(p1.recv(), 1);\n+            c2.send(2);\n+        };\n+        let t2 = do Thread::start {\n+            c1.send(1);\n+            assert_eq!(p2.recv(), 2);\n+        };\n+        t1.join();\n+        t2.join();\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_close_port_first() {\n+        // Simple test of closing without sending\n+        do run_in_newsched_task {\n+            let (port, _chan) = Chan::<int>::new();\n+            { let _p = port; }\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_close_chan_first() {\n+        // Simple test of closing without sending\n+        do run_in_newsched_task {\n+            let (_port, chan) = Chan::<int>::new();\n+            { let _c = chan; }\n+        }\n+    }\n+\n+    #[test] #[should_fail]\n+    fn oneshot_single_thread_send_port_close() {\n+        // Testing that the sender cleans up the payload if receiver is closed\n+        let (port, chan) = Chan::<~int>::new();\n+        { let _p = port; }\n+        chan.send(~0);\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_recv_chan_close() {\n+        // Receiving on a closed chan will fail\n+        do run_in_newsched_task {\n+            let res = do spawntask_try {\n+                let (port, chan) = Chan::<~int>::new();\n+                { let _c = chan; }\n+                port.recv();\n+            };\n+            // What is our res?\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_send_then_recv() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<~int>::new();\n+            chan.send(~10);\n+            assert!(port.recv() == ~10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_send_open() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<int>::new();\n+            assert!(chan.try_send(10));\n+            assert!(port.recv() == 10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_send_closed() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<int>::new();\n+            { let _p = port; }\n+            assert!(!chan.try_send(10));\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_recv_open() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<int>::new();\n+            chan.send(10);\n+            assert!(port.try_recv() == Some(10));\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_try_recv_closed() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<int>::new();\n+            { let _c = chan; }\n+            assert!(port.recv_opt() == None);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_data() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<int>::new();\n+            assert!(port.try_recv().is_none());\n+            chan.send(10);\n+            assert!(port.try_recv().is_some());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_close() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<int>::new();\n+            { let _c = chan; }\n+            assert!(port.try_recv().is_none());\n+            assert!(port.try_recv().is_none());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_single_thread_peek_open() {\n+        do run_in_newsched_task {\n+            let (port, _) = Chan::<int>::new();\n+            assert!(port.try_recv().is_none());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_task_recv_then_send() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<~int>::new();\n+            do spawntask {\n+                assert!(port.recv() == ~10);\n+            }\n+\n+            chan.send(~10);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_task_recv_then_close() {\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::<~int>::new();\n+            do spawntask_later {\n+                let _chan = chan;\n+            }\n+            let res = do spawntask_try {\n+                assert!(port.recv() == ~10);\n+            };\n+            assert!(res.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_close_stress() {\n+        stress_factor().times(|| {\n+            do run_in_newsched_task {\n+                let (port, chan) = Chan::<int>::new();\n+                let thread = do spawntask_thread {\n+                    let _p = port;\n+                };\n+                let _chan = chan;\n+                thread.join();\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_send_close_stress() {\n+        stress_factor().times(|| {\n+            let (port, chan) = Chan::<int>::new();\n+            do spawn {\n+                let _p = port;\n+            }\n+            do task::try {\n+                chan.send(1);\n+            };\n+        })\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_recv_close_stress() {\n+        stress_factor().times(|| {\n+            let (port, chan) = Chan::<int>::new();\n+            do spawn {\n+                let port = port;\n+                let res = do task::try {\n+                    port.recv();\n+                };\n+                assert!(res.is_err());\n+            };\n+            do spawn {\n+                let chan = chan;\n+                do spawn {\n+                    let _chan = chan;\n+                }\n+            };\n+        })\n+    }\n+\n+    #[test]\n+    fn oneshot_multi_thread_send_recv_stress() {\n+        stress_factor().times(|| {\n+            let (port, chan) = Chan::<~int>::new();\n+            do spawn {\n+                chan.send(~10);\n+            }\n+            do spawn {\n+                assert!(port.recv() == ~10);\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn stream_send_recv_stress() {\n+        stress_factor().times(|| {\n+            let (port, chan) = Chan::<~int>::new();\n+\n+            send(chan, 0);\n+            recv(port, 0);\n+\n+            fn send(chan: Chan<~int>, i: int) {\n+                if i == 10 { return }\n+\n+                do spawntask_random {\n+                    chan.send(~i);\n+                    send(chan, i + 1);\n+                }\n+            }\n+\n+            fn recv(port: Port<~int>, i: int) {\n+                if i == 10 { return }\n+\n+                do spawntask_random {\n+                    assert!(port.recv() == ~i);\n+                    recv(port, i + 1);\n+                };\n+            }\n+        })\n+    }\n+\n+    #[test]\n+    fn recv_a_lot() {\n+        // Regression test that we don't run out of stack in scheduler context\n+        do run_in_newsched_task {\n+            let (port, chan) = Chan::new();\n+            10000.times(|| { chan.send(()) });\n+            10000.times(|| { port.recv() });\n+        }\n+    }\n+\n+    #[test]\n+    fn shared_chan_stress() {\n+        do run_in_mt_newsched_task {\n+            let (port, chan) = SharedChan::new();\n+            let total = stress_factor() + 100;\n+            total.times(|| {\n+                let chan_clone = chan.clone();\n+                do spawntask_random {\n+                    chan_clone.send(());\n+                }\n+            });\n+\n+            total.times(|| {\n+                port.recv();\n+            });\n+        }\n+    }\n+\n+    #[test]\n+    fn test_nested_recv_iter() {\n+        let (port, chan) = Chan::<int>::new();\n+        let (total_port, total_chan) = Chan::<int>::new();\n+\n+        do spawn {\n+            let mut acc = 0;\n+            for x in port.iter() {\n+                acc += x;\n+            }\n+            total_chan.send(acc);\n+        }\n+\n+        chan.send(3);\n+        chan.send(1);\n+        chan.send(2);\n+        drop(chan);\n+        assert_eq!(total_port.recv(), 6);\n+    }\n+\n+    #[test]\n+    fn test_recv_iter_break() {\n+        let (port, chan) = Chan::<int>::new();\n+        let (count_port, count_chan) = Chan::<int>::new();\n+\n+        do spawn {\n+            let mut count = 0;\n+            for x in port.iter() {\n+                if count >= 3 {\n+                    break;\n+                } else {\n+                    count += x;\n+                }\n+            }\n+            count_chan.send(count);\n+        }\n+\n+        chan.send(2);\n+        chan.send(2);\n+        chan.send(2);\n+        chan.try_send(2);\n+        drop(chan);\n+        assert_eq!(count_port.recv(), 4);\n+    }\n+}"}, {"sha": "4d6b540f2a5cb615f890ed9b1c4fe2c4b44eeefd", "filename": "src/libstd/comm/select.rs", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -0,0 +1,503 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Selection over an array of ports\n+//!\n+//! This module contains the implementation machinery necessary for selecting\n+//! over a number of ports. One large goal of this module is to provide an\n+//! efficient interface to selecting over any port of any type.\n+//!\n+//! This is achieved through an architecture of a \"port set\" in which ports are\n+//! added to a set and then the entire set is waited on at once. The set can be\n+//! waited on multiple times to prevent re-adding each port to the set.\n+//!\n+//! Usage of this module is currently encouraged to go through the use of the\n+//! `select!` macro. This macro allows naturally binding of variables to the\n+//! received values of ports in a much more natural syntax then usage of the\n+//! `Select` structure directly.\n+//!\n+//! # Example\n+//!\n+//! ```rust\n+//! let (mut p1, c1) = Chan::new();\n+//! let (mut p2, c2) = Chan::new();\n+//!\n+//! c1.send(1);\n+//! c2.send(2);\n+//!\n+//! select! (\n+//!     val = p1.recv() => {\n+//!         assert_eq!(val, 1);\n+//!     }\n+//!     val = p2.recv() => {\n+//!         assert_eq!(val, 2);\n+//!     }\n+//! )\n+\n+#[allow(dead_code)];\n+\n+use cast;\n+use iter::Iterator;\n+use kinds::Send;\n+use ops::Drop;\n+use option::{Some, None, Option};\n+use ptr::RawPtr;\n+use super::imp::BlockingContext;\n+use super::{Packet, Port, imp};\n+use uint;\n+use unstable::atomics::{Relaxed, SeqCst};\n+\n+macro_rules! select {\n+    (\n+        $name1:pat = $port1:ident.$meth1:ident() => $code1:expr,\n+        $($name:pat = $port:ident.$meth:ident() => $code:expr),*\n+    ) => ({\n+        use std::comm::Select;\n+        let sel = Select::new();\n+        let mut $port1 = sel.add(&mut $port1);\n+        $( let mut $port = sel.add(&mut $port); )*\n+        let ret = sel.wait();\n+        if ret == $port1.id { let $name1 = $port1.$meth1(); $code1 }\n+        $( else if ret == $port.id { let $name = $port.$meth(); $code } )*\n+        else { unreachable!() }\n+    })\n+}\n+\n+/// The \"port set\" of the select interface. This structure is used to manage a\n+/// set of ports which are being selected over.\n+#[no_freeze]\n+#[no_send]\n+pub struct Select {\n+    priv head: *mut Packet,\n+    priv tail: *mut Packet,\n+    priv next_id: uint,\n+}\n+\n+/// A handle to a port which is currently a member of a `Select` set of ports.\n+/// This handle is used to keep the port in the set as well as interact with the\n+/// underlying port.\n+pub struct Handle<'port, T> {\n+    id: uint,\n+    priv selector: &'port Select,\n+    priv port: &'port mut Port<T>,\n+}\n+\n+struct PacketIterator { priv cur: *mut Packet }\n+\n+impl Select {\n+    /// Creates a new selection structure. This set is initially empty and\n+    /// `wait` will fail!() if called.\n+    ///\n+    /// Usage of this struct directly can sometimes be burdensome, and usage is\n+    /// rather much easier through the `select!` macro.\n+    pub fn new() -> Select {\n+        Select {\n+            head: 0 as *mut Packet,\n+            tail: 0 as *mut Packet,\n+            next_id: 1,\n+        }\n+    }\n+\n+    /// Adds a new port to this set, returning a handle which is then used to\n+    /// receive on the port.\n+    ///\n+    /// Note that this port parameter takes `&mut Port` instead of `&Port`. None\n+    /// of the methods of receiving on a port require `&mut self`, but `&mut` is\n+    /// used here in order to have the compiler guarantee that the same port is\n+    /// not added to this set more than once.\n+    ///\n+    /// When the returned handle falls out of scope, the port will be removed\n+    /// from this set. While the handle is in this set, usage of the port can be\n+    /// done through the `Handle`'s receiving methods.\n+    pub fn add<'a, T: Send>(&'a self, port: &'a mut Port<T>) -> Handle<'a, T> {\n+        let this = unsafe { cast::transmute_mut(self) };\n+        let id = this.next_id;\n+        this.next_id += 1;\n+        unsafe {\n+            let packet = port.queue.packet();\n+            assert!(!(*packet).selecting.load(Relaxed));\n+            assert_eq!((*packet).selection_id, 0);\n+            (*packet).selection_id = id;\n+            if this.head.is_null() {\n+                this.head = packet;\n+                this.tail = packet;\n+            } else {\n+                (*packet).select_prev = this.tail;\n+                assert!((*packet).select_next.is_null());\n+                (*this.tail).select_next = packet;\n+                this.tail = packet;\n+            }\n+        }\n+        Handle { id: id, selector: this, port: port }\n+    }\n+\n+    /// Waits for an event on this port set. The returned valus is *not* and\n+    /// index, but rather an id. This id can be queried against any active\n+    /// `Handle` structures (each one has a public `id` field). The handle with\n+    /// the matching `id` will have some sort of event available on it. The\n+    /// event could either be that data is available or the corresponding\n+    /// channel has been closed.\n+    pub fn wait(&self) -> uint {\n+        // Note that this is currently an inefficient implementation. We in\n+        // theory have knowledge about all ports in the set ahead of time, so\n+        // this method shouldn't really have to iterate over all of them yet\n+        // again. The idea with this \"port set\" interface is to get the\n+        // interface right this time around, and later this implementation can\n+        // be optimized.\n+        //\n+        // This implementation can be summarized by:\n+        //\n+        //      fn select(ports) {\n+        //          if any port ready { return ready index }\n+        //          deschedule {\n+        //              block on all ports\n+        //          }\n+        //          unblock on all ports\n+        //          return ready index\n+        //      }\n+        //\n+        // Most notably, the iterations over all of the ports shouldn't be\n+        // necessary.\n+        unsafe {\n+            let mut amt = 0;\n+            for p in self.iter() {\n+                assert!(!(*p).selecting.load(Relaxed));\n+                amt += 1;\n+                if (*p).can_recv() {\n+                    return (*p).selection_id;\n+                }\n+            }\n+            assert!(amt > 0);\n+\n+            let mut ready_index = amt;\n+            let mut ready_id = uint::max_value;\n+            let mut iter = self.iter().enumerate();\n+\n+            // Acquire a number of blocking contexts, and block on each one\n+            // sequentially until one fails. If one fails, then abort\n+            // immediately so we can go unblock on all the other ports.\n+            BlockingContext::many(amt, |ctx| {\n+                let (i, packet) = iter.next().unwrap();\n+                (*packet).selecting.store(true, SeqCst);\n+                if !ctx.block(&mut (*packet).data,\n+                              &mut (*packet).to_wake,\n+                              || (*packet).decrement()) {\n+                    (*packet).abort_selection(false);\n+                    (*packet).selecting.store(false, SeqCst);\n+                    ready_index = i;\n+                    ready_id = (*packet).selection_id;\n+                    false\n+                } else {\n+                    true\n+                }\n+            });\n+\n+            // Abort the selection process on each port. If the abort process\n+            // returns `true`, then that means that the port is ready to receive\n+            // some data. Note that this also means that the port may have yet\n+            // to have fully read the `to_wake` field and woken us up (although\n+            // the wakeup is guaranteed to fail).\n+            //\n+            // This situation happens in the window of where a sender invokes\n+            // increment(), sees -1, and then decides to wake up the task. After\n+            // all this is done, the sending thread will set `selecting` to\n+            // `false`. Until this is done, we cannot return. If we were to\n+            // return, then a sender could wake up a port which has gone back to\n+            // sleep after this call to `select`.\n+            //\n+            // Note that it is a \"fairly small window\" in which an increment()\n+            // views that it should wake a thread up until the `selecting` bit\n+            // is set to false. For now, the implementation currently just spins\n+            // in a yield loop. This is very distasteful, but this\n+            // implementation is already nowhere near what it should ideally be.\n+            // A rewrite should focus on avoiding a yield loop, and for now this\n+            // implementation is tying us over to a more efficient \"don't\n+            // iterate over everything every time\" implementation.\n+            for packet in self.iter().take(ready_index) {\n+                if (*packet).abort_selection(true) {\n+                    ready_id = (*packet).selection_id;\n+                    while (*packet).selecting.load(Relaxed) {\n+                        imp::yield_now();\n+                    }\n+                }\n+            }\n+\n+            // Sanity check for now to make sure that everyone is turned off.\n+            for packet in self.iter() {\n+                assert!(!(*packet).selecting.load(Relaxed));\n+            }\n+\n+            assert!(ready_id != uint::max_value);\n+            return ready_id;\n+        }\n+    }\n+\n+    unsafe fn remove(&self, packet: *mut Packet) {\n+        let this = cast::transmute_mut(self);\n+        assert!(!(*packet).selecting.load(Relaxed));\n+        if (*packet).select_prev.is_null() {\n+            assert_eq!(packet, this.head);\n+            this.head = (*packet).select_next;\n+        } else {\n+            (*(*packet).select_prev).select_next = (*packet).select_next;\n+        }\n+        if (*packet).select_next.is_null() {\n+            assert_eq!(packet, this.tail);\n+            this.tail = (*packet).select_prev;\n+        } else {\n+            (*(*packet).select_next).select_prev = (*packet).select_prev;\n+        }\n+        (*packet).select_next = 0 as *mut Packet;\n+        (*packet).select_prev = 0 as *mut Packet;\n+        (*packet).selection_id = 0;\n+    }\n+\n+    fn iter(&self) -> PacketIterator { PacketIterator { cur: self.head } }\n+}\n+\n+impl<'port, T: Send> Handle<'port, T> {\n+    /// Receive a value on the underlying port. Has the same semantics as\n+    /// `Port.recv`\n+    pub fn recv(&mut self) -> T { self.port.recv() }\n+    /// Block to receive a value on the underlying port, returning `Some` on\n+    /// success or `None` if the channel disconnects. This function has the same\n+    /// semantics as `Port.recv_opt`\n+    pub fn recv_opt(&mut self) -> Option<T> { self.port.recv_opt() }\n+    /// Immediately attempt to receive a value on a port, this function will\n+    /// never block. Has the same semantics as `Port.try_recv`.\n+    pub fn try_recv(&mut self) -> Option<T> { self.port.try_recv() }\n+}\n+\n+#[unsafe_destructor]\n+impl Drop for Select {\n+    fn drop(&mut self) {\n+        assert!(self.head.is_null());\n+        assert!(self.tail.is_null());\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'port, T: Send> Drop for Handle<'port, T> {\n+    fn drop(&mut self) {\n+        unsafe { self.selector.remove(self.port.queue.packet()) }\n+    }\n+}\n+\n+impl Iterator<*mut Packet> for PacketIterator {\n+    fn next(&mut self) -> Option<*mut Packet> {\n+        if self.cur.is_null() {\n+            None\n+        } else {\n+            let ret = Some(self.cur);\n+            unsafe { self.cur = (*self.cur).select_next; }\n+            ret\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::super::*;\n+    use prelude::*;\n+\n+    test!(fn smoke() {\n+        let (mut p1, c1) = Chan::<int>::new();\n+        let (mut p2, c2) = Chan::<int>::new();\n+        c1.send(1);\n+        select! (\n+            foo = p1.recv() => { assert_eq!(foo, 1); },\n+            _bar = p2.recv() => { fail!() }\n+        )\n+        c2.send(2);\n+        select! (\n+            _foo = p1.recv() => { fail!() },\n+            bar = p2.recv() => { assert_eq!(bar, 2) }\n+        )\n+        drop(c1);\n+        select! (\n+            foo = p1.recv_opt() => { assert_eq!(foo, None); },\n+            _bar = p2.recv() => { fail!() }\n+        )\n+        drop(c2);\n+        select! (\n+            bar = p2.recv_opt() => { assert_eq!(bar, None); },\n+        )\n+    })\n+\n+    test!(fn smoke2() {\n+        let (mut p1, _c1) = Chan::<int>::new();\n+        let (mut p2, _c2) = Chan::<int>::new();\n+        let (mut p3, _c3) = Chan::<int>::new();\n+        let (mut p4, _c4) = Chan::<int>::new();\n+        let (mut p5, c5) = Chan::<int>::new();\n+        c5.send(4);\n+        select! (\n+            _foo = p1.recv() => { fail!(\"1\") },\n+            _foo = p2.recv() => { fail!(\"2\") },\n+            _foo = p3.recv() => { fail!(\"3\") },\n+            _foo = p4.recv() => { fail!(\"4\") },\n+            foo = p5.recv() => { assert_eq!(foo, 4); }\n+        )\n+    })\n+\n+    test!(fn closed() {\n+        let (mut p1, _c1) = Chan::<int>::new();\n+        let (mut p2, c2) = Chan::<int>::new();\n+        drop(c2);\n+\n+        select! (\n+            _a1 = p1.recv_opt() => { fail!() },\n+            a2 = p2.recv_opt() => { assert_eq!(a2, None); }\n+        )\n+    })\n+\n+    #[test]\n+    fn unblocks() {\n+        use std::io::timer;\n+\n+        let (mut p1, c1) = Chan::<int>::new();\n+        let (mut p2, _c2) = Chan::<int>::new();\n+        let (p3, c3) = Chan::<int>::new();\n+\n+        do spawn {\n+            timer::sleep(3);\n+            c1.send(1);\n+            p3.recv();\n+            timer::sleep(3);\n+        }\n+\n+        select! (\n+            a = p1.recv() => { assert_eq!(a, 1); },\n+            _b = p2.recv() => { fail!() }\n+        )\n+        c3.send(1);\n+        select! (\n+            a = p1.recv_opt() => { assert_eq!(a, None); },\n+            _b = p2.recv() => { fail!() }\n+        )\n+    }\n+\n+    #[test]\n+    fn both_ready() {\n+        use std::io::timer;\n+\n+        let (mut p1, c1) = Chan::<int>::new();\n+        let (mut p2, c2) = Chan::<int>::new();\n+        let (p3, c3) = Chan::<()>::new();\n+\n+        do spawn {\n+            timer::sleep(3);\n+            c1.send(1);\n+            c2.send(2);\n+            p3.recv();\n+        }\n+\n+        select! (\n+            a = p1.recv() => { assert_eq!(a, 1); },\n+            a = p2.recv() => { assert_eq!(a, 2); }\n+        )\n+        select! (\n+            a = p1.recv() => { assert_eq!(a, 1); },\n+            a = p2.recv() => { assert_eq!(a, 2); }\n+        )\n+        c3.send(());\n+    }\n+\n+    #[test]\n+    fn stress() {\n+        static AMT: int = 10000;\n+        let (mut p1, c1) = Chan::<int>::new();\n+        let (mut p2, c2) = Chan::<int>::new();\n+        let (p3, c3) = Chan::<()>::new();\n+\n+        do spawn {\n+            for i in range(0, AMT) {\n+                if i % 2 == 0 {\n+                    c1.send(i);\n+                } else {\n+                    c2.send(i);\n+                }\n+                p3.recv();\n+            }\n+        }\n+\n+        for i in range(0, AMT) {\n+            select! (\n+                i1 = p1.recv() => { assert!(i % 2 == 0 && i == i1); },\n+                i2 = p2.recv() => { assert!(i % 2 == 1 && i == i2); }\n+            )\n+            c3.send(());\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME(#11003)\n+    fn stress_native() {\n+        use std::rt::thread::Thread;\n+        use std::unstable::run_in_bare_thread;\n+        static AMT: int = 10000;\n+\n+        do run_in_bare_thread {\n+            let (mut p1, c1) = Chan::<int>::new();\n+            let (mut p2, c2) = Chan::<int>::new();\n+            let (p3, c3) = Chan::<()>::new();\n+\n+            let t = do Thread::start {\n+                for i in range(0, AMT) {\n+                    if i % 2 == 0 {\n+                        c1.send(i);\n+                    } else {\n+                        c2.send(i);\n+                    }\n+                    p3.recv();\n+                }\n+            };\n+\n+            for i in range(0, AMT) {\n+                select! (\n+                    i1 = p1.recv() => { assert!(i % 2 == 0 && i == i1); },\n+                    i2 = p2.recv() => { assert!(i % 2 == 1 && i == i2); }\n+                )\n+                c3.send(());\n+            }\n+            t.join();\n+        }\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(windows))] // FIXME(#11003)\n+    fn native_both_ready() {\n+        use std::rt::thread::Thread;\n+        use std::unstable::run_in_bare_thread;\n+\n+        do run_in_bare_thread {\n+            let (mut p1, c1) = Chan::<int>::new();\n+            let (mut p2, c2) = Chan::<int>::new();\n+            let (p3, c3) = Chan::<()>::new();\n+\n+            let t = do Thread::start {\n+                c1.send(1);\n+                c2.send(2);\n+                p3.recv();\n+            };\n+\n+            select! (\n+                a = p1.recv() => { assert_eq!(a, 1); },\n+                b = p2.recv() => { assert_eq!(b, 2); }\n+            )\n+            select! (\n+                a = p1.recv() => { assert_eq!(a, 1); },\n+                b = p2.recv() => { assert_eq!(b, 2); }\n+            )\n+            c3.send(());\n+            t.join();\n+        }\n+    }\n+}"}, {"sha": "7f94af8307eae8ee6ce2f97a2ae5f2863af1469b", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::*;\n \n-use comm::{GenericPort, GenericChan, GenericSmartChan};\n+use comm::{Port, Chan};\n use cmp;\n use io;\n use option::{None, Option, Some};\n@@ -30,15 +30,15 @@ use vec::{bytes, CopyableVector, MutableVector, ImmutableVector};\n ///     None => println!(\"At the end of the stream!\")\n /// }\n /// ```\n-pub struct PortReader<P> {\n+pub struct PortReader {\n     priv buf: Option<~[u8]>,  // A buffer of bytes received but not consumed.\n     priv pos: uint,           // How many of the buffered bytes have already be consumed.\n-    priv port: P,             // The port to pull data from.\n+    priv port: Port<~[u8]>,   // The port to pull data from.\n     priv closed: bool,        // Whether the pipe this port connects to has been closed.\n }\n \n-impl<P: GenericPort<~[u8]>> PortReader<P> {\n-    pub fn new(port: P) -> PortReader<P> {\n+impl PortReader {\n+    pub fn new(port: Port<~[u8]>) -> PortReader<P> {\n         PortReader {\n             buf: None,\n             pos: 0,\n@@ -48,7 +48,7 @@ impl<P: GenericPort<~[u8]>> PortReader<P> {\n     }\n }\n \n-impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n+impl Reader for PortReader {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         let mut num_read = 0;\n         loop {\n@@ -67,7 +67,7 @@ impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n                 break;\n             }\n             self.pos = 0;\n-            self.buf = self.port.try_recv();\n+            self.buf = self.port.recv_opt();\n             self.closed = self.buf.is_none();\n         }\n         if self.closed && num_read == 0 {\n@@ -89,17 +89,17 @@ impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n /// let writer = ChanWriter::new(chan);\n /// writer.write(\"hello, world\".as_bytes());\n /// ```\n-pub struct ChanWriter<C> {\n-    chan: C,\n+pub struct ChanWriter {\n+    chan: Chan<~[u8]>,\n }\n \n-impl<C: GenericSmartChan<~[u8]>> ChanWriter<C> {\n+impl ChanWriter {\n     pub fn new(chan: C) -> ChanWriter<C> {\n         ChanWriter { chan: chan }\n     }\n }\n \n-impl<C: GenericSmartChan<~[u8]>> Writer for ChanWriter<C> {\n+impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) {\n         if !self.chan.try_send(buf.to_owned()) {\n             io::io_error::cond.raise(io::IoError {\n@@ -111,28 +111,6 @@ impl<C: GenericSmartChan<~[u8]>> Writer for ChanWriter<C> {\n     }\n }\n \n-pub struct ReaderPort<R>;\n-\n-impl<R: Reader> ReaderPort<R> {\n-    pub fn new(_reader: R) -> ReaderPort<R> { fail!() }\n-}\n-\n-impl<R: Reader> GenericPort<~[u8]> for ReaderPort<R> {\n-    fn recv(&self) -> ~[u8] { fail!() }\n-\n-    fn try_recv(&self) -> Option<~[u8]> { fail!() }\n-}\n-\n-pub struct WriterChan<W>;\n-\n-impl<W: Writer> WriterChan<W> {\n-    pub fn new(_writer: W) -> WriterChan<W> { fail!() }\n-}\n-\n-impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n-    fn send(&self, _x: ~[u8]) { fail!() }\n-}\n-\n \n #[cfg(test)]\n mod test {\n@@ -144,7 +122,7 @@ mod test {\n \n     #[test]\n     fn test_port_reader() {\n-        let (port, chan) = comm::stream();\n+        let (port, chan) = Chan::new();\n         do task::spawn {\n           chan.send(~[1u8, 2u8]);\n           chan.send(~[]);\n@@ -199,7 +177,7 @@ mod test {\n \n     #[test]\n     fn test_chan_writer() {\n-        let (port, chan) = comm::stream();\n+        let (port, chan) = Chan::new();\n         let mut writer = ChanWriter::new(chan);\n         writer.write_be_u32(42);\n "}, {"sha": "2e9056a6aee48d8f5eb07df3d1e0ffb5006f3175", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -318,9 +318,6 @@ mod option;\n /// Basic stream compression. XXX: Belongs with other flate code\n pub mod flate;\n \n-/// Interop between byte streams and pipes. Not sure where it belongs\n-pub mod comm_adapters;\n-\n /// Extension traits\n pub mod extensions;\n "}, {"sha": "a6230ede7e34887f74da1524b070627e1e80f715", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 59, "deletions": 82, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -151,7 +151,6 @@ mod test {\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n     use prelude::*;\n-    use rt::comm::oneshot;\n \n     #[test] #[ignore]\n     fn bind_error() {\n@@ -195,7 +194,7 @@ mod test {\n     fn smoke_test_ip4() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -206,19 +205,17 @@ mod test {\n                 assert!(buf[0] == 99);\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let mut stream = TcpStream::connect(addr);\n-                stream.write([99]);\n-            }\n+            port.recv();\n+            let mut stream = TcpStream::connect(addr);\n+            stream.write([99]);\n         }\n     }\n \n     #[test]\n     fn smoke_test_ip6() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -229,19 +226,17 @@ mod test {\n                 assert!(buf[0] == 99);\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let mut stream = TcpStream::connect(addr);\n-                stream.write([99]);\n-            }\n+            port.recv();\n+            let mut stream = TcpStream::connect(addr);\n+            stream.write([99]);\n         }\n     }\n \n     #[test]\n     fn read_eof_ip4() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -252,19 +247,17 @@ mod test {\n                 assert!(nread.is_none());\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn read_eof_ip6() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -275,19 +268,17 @@ mod test {\n                 assert!(nread.is_none());\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn read_eof_twice_ip4() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -308,19 +299,17 @@ mod test {\n                 })\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn read_eof_twice_ip6() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -341,19 +330,17 @@ mod test {\n                 })\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn write_close_ip4() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -377,19 +364,17 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n     #[test]\n     fn write_close_ip6() {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -413,11 +398,9 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let _stream = TcpStream::connect(addr);\n-                // Close\n-            }\n+            port.recv();\n+            let _stream = TcpStream::connect(addr);\n+            // Close\n         }\n     }\n \n@@ -426,7 +409,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let max = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -438,13 +421,11 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                port.recv();\n-                max.times(|| {\n-                    let mut stream = TcpStream::connect(addr);\n-                    stream.write([99]);\n-                });\n-            }\n+            port.recv();\n+            max.times(|| {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            });\n         }\n     }\n \n@@ -453,7 +434,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let max = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -465,13 +446,11 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                port.recv();\n-                max.times(|| {\n-                    let mut stream = TcpStream::connect(addr);\n-                    stream.write([99]);\n-                });\n-            }\n+            port.recv();\n+            max.times(|| {\n+                let mut stream = TcpStream::connect(addr);\n+                stream.write([99]);\n+            });\n         }\n     }\n \n@@ -480,7 +459,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -520,7 +499,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -560,7 +539,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -599,7 +578,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -653,7 +632,7 @@ mod test {\n     #[cfg(test)]\n     fn peer_name(addr: SocketAddr) {\n         do run_in_mt_newsched_task {\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n@@ -662,20 +641,18 @@ mod test {\n                 acceptor.accept();\n             }\n \n-            do spawntask {\n-                port.recv();\n-                let stream = TcpStream::connect(addr);\n+            port.recv();\n+            let stream = TcpStream::connect(addr);\n \n-                assert!(stream.is_some());\n-                let mut stream = stream.unwrap();\n+            assert!(stream.is_some());\n+            let mut stream = stream.unwrap();\n \n-                // Make sure peer_name gives us the\n-                // address/port of the peer we've\n-                // connected to.\n-                let peer_name = stream.peer_name();\n-                assert!(peer_name.is_some());\n-                assert_eq!(addr, peer_name.unwrap());\n-            }\n+            // Make sure peer_name gives us the\n+            // address/port of the peer we've\n+            // connected to.\n+            let peer_name = stream.peer_name();\n+            assert!(peer_name.is_some());\n+            assert_eq!(addr, peer_name.unwrap());\n         }\n     }\n "}, {"sha": "1e56f964bea529a03e536714ff8591e0377e285d", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -107,8 +107,7 @@ mod test {\n     use rt::test::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n-    use option::{Some, None};\n-    use rt::comm::oneshot;\n+    use prelude::*;\n \n     #[test]  #[ignore]\n     fn bind_error() {\n@@ -131,7 +130,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n@@ -151,14 +150,12 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                match UdpSocket::bind(client_ip) {\n-                    Some(ref mut client) => {\n-                        port.recv();\n-                        client.sendto([99], server_ip)\n-                    }\n-                    None => fail!()\n+            match UdpSocket::bind(client_ip) {\n+                Some(ref mut client) => {\n+                    port.recv();\n+                    client.sendto([99], server_ip)\n                 }\n+                None => fail!()\n             }\n         }\n     }\n@@ -168,7 +165,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n@@ -188,14 +185,12 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                match UdpSocket::bind(client_ip) {\n-                    Some(ref mut client) => {\n-                        port.recv();\n-                        client.sendto([99], server_ip)\n-                    }\n-                    None => fail!()\n+            match UdpSocket::bind(client_ip) {\n+                Some(ref mut client) => {\n+                    port.recv();\n+                    client.sendto([99], server_ip)\n                 }\n+                None => fail!()\n             }\n         }\n     }\n@@ -205,7 +200,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n@@ -226,16 +221,14 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                match UdpSocket::bind(client_ip) {\n-                    Some(client) => {\n-                        let client = ~client;\n-                        let mut stream = client.connect(server_ip);\n-                        port.recv();\n-                        stream.write([99]);\n-                    }\n-                    None => fail!()\n+            match UdpSocket::bind(client_ip) {\n+                Some(client) => {\n+                    let client = ~client;\n+                    let mut stream = client.connect(server_ip);\n+                    port.recv();\n+                    stream.write([99]);\n                 }\n+                None => fail!()\n             }\n         }\n     }\n@@ -245,7 +238,7 @@ mod test {\n         do run_in_mt_newsched_task {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n@@ -266,16 +259,14 @@ mod test {\n                 }\n             }\n \n-            do spawntask {\n-                match UdpSocket::bind(client_ip) {\n-                    Some(client) => {\n-                        let client = ~client;\n-                        let mut stream = client.connect(server_ip);\n-                        port.recv();\n-                        stream.write([99]);\n-                    }\n-                    None => fail!()\n+            match UdpSocket::bind(client_ip) {\n+                Some(client) => {\n+                    let client = ~client;\n+                    let mut stream = client.connect(server_ip);\n+                    port.recv();\n+                    stream.write([99]);\n                 }\n+                None => fail!()\n             }\n         }\n     }"}, {"sha": "49770b80060b870de546bc574104d1bb8dccaf39", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -152,25 +152,22 @@ mod tests {\n     use super::*;\n     use rt::test::*;\n     use io::*;\n-    use rt::comm::oneshot;\n \n     fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n         do run_in_mt_newsched_task {\n             let path1 = next_test_unix();\n             let path2 = path1.clone();\n-            let (port, chan) = oneshot();\n             let (client, server) = (client, server);\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n                 chan.send(());\n                 server(acceptor.accept().unwrap());\n             }\n \n-            do spawntask {\n-                port.recv();\n-                client(UnixStream::connect(&path2).unwrap());\n-            }\n+            port.recv();\n+            client(UnixStream::connect(&path2).unwrap());\n         }\n     }\n \n@@ -251,7 +248,7 @@ mod tests {\n             let times = 10;\n             let path1 = next_test_unix();\n             let path2 = path1.clone();\n-            let (port, chan) = oneshot();\n+            let (port, chan) = Chan::new();\n \n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n@@ -264,13 +261,11 @@ mod tests {\n                 })\n             }\n \n-            do spawntask {\n-                port.recv();\n-                times.times(|| {\n-                    let mut stream = UnixStream::connect(&path2);\n-                    stream.write([100]);\n-                })\n-            }\n+            port.recv();\n+            times.times(|| {\n+                let mut stream = UnixStream::connect(&path2);\n+                stream.write([100]);\n+            })\n         }\n     }\n "}, {"sha": "c568a19dfa23381ea4b12233adc0c8f3ecf42926", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -20,7 +20,7 @@ definitions for a number of signals.\n */\n \n use clone::Clone;\n-use comm::{Port, SharedChan, stream};\n+use comm::{Port, SharedChan};\n use container::{Map, MutableMap};\n use hashmap;\n use io::io_error;\n@@ -93,9 +93,9 @@ impl Listener {\n     /// Creates a new listener for signals. Once created, signals are bound via\n     /// the `register` method (otherwise nothing will ever be received)\n     pub fn new() -> Listener {\n-        let (port, chan) = stream();\n+        let (port, chan) = SharedChan::new();\n         Listener {\n-            chan: SharedChan::new(chan),\n+            chan: chan,\n             port: port,\n             handles: hashmap::HashMap::new(),\n         }\n@@ -149,7 +149,6 @@ mod test {\n     use libc;\n     use io::timer;\n     use super::{Listener, Interrupt};\n-    use comm::{GenericPort, Peekable};\n \n     // kill is only available on Unixes\n     #[cfg(unix)]\n@@ -198,9 +197,7 @@ mod test {\n         s2.unregister(Interrupt);\n         sigint();\n         timer::sleep(10);\n-        if s2.port.peek() {\n-            fail!(\"Unexpected {:?}\", s2.port.recv());\n-        }\n+        assert!(s2.port.try_recv().is_none());\n     }\n \n     #[cfg(windows)]"}, {"sha": "5fb64ab3d09dbdc2de9827c30ea92e68b5da0ae9", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -38,7 +38,7 @@ loop {\n \n */\n \n-use comm::{Port, PortOne};\n+use comm::Port;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use io::io_error;\n@@ -86,7 +86,7 @@ impl Timer {\n     /// Note that this invalidates any previous port which has been created by\n     /// this timer, and that the returned port will be invalidated once the\n     /// timer is destroyed (when it falls out of scope).\n-    pub fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n+    pub fn oneshot(&mut self, msecs: u64) -> Port<()> {\n         self.obj.oneshot(msecs)\n     }\n "}, {"sha": "53e26e435b7df7eeef1ad53eaab8f655322a0e32", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -156,7 +156,6 @@ pub mod trie;\n \n pub mod task;\n pub mod comm;\n-pub mod select;\n pub mod local_data;\n \n \n@@ -203,15 +202,16 @@ pub mod rt;\n mod std {\n     pub use clone;\n     pub use cmp;\n+    pub use comm;\n     pub use condition;\n     pub use fmt;\n+    pub use io;\n     pub use kinds;\n     pub use local_data;\n     pub use logging;\n     pub use logging;\n     pub use option;\n     pub use os;\n-    pub use io;\n     pub use rt;\n     pub use str;\n     pub use to_bytes;"}, {"sha": "fa836f26c0bac000021ef1e5b1a085ad741e26d0", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -87,7 +87,7 @@ pub use vec::{OwnedVector, OwnedCopyableVector,OwnedEqVector, MutableVector};\n pub use vec::{Vector, VectorVector, CopyableVector, ImmutableVector};\n \n // Reexported runtime types\n-pub use comm::{stream, Port, Chan, GenericChan, GenericSmartChan, GenericPort, Peekable};\n+pub use comm::{Port, Chan, SharedChan};\n pub use task::spawn;\n \n /// Disposes of a value."}, {"sha": "1eaf1a29fa8940da910110bb90efb6866b36fd27", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -135,8 +135,10 @@ impl Drop for OSRng {\n \n #[cfg(test)]\n mod test {\n+    use prelude::*;\n     use super::*;\n     use rand::Rng;\n+    use task;\n \n     #[test]\n     fn test_os_rng() {\n@@ -151,16 +153,10 @@ mod test {\n \n     #[test]\n     fn test_os_rng_tasks() {\n-        use task;\n-        use comm;\n-        use comm::{GenericChan, GenericPort};\n-        use option::{None, Some};\n-        use iter::{Iterator, range};\n-        use vec::{ImmutableVector, OwnedVector};\n \n         let mut chans = ~[];\n         for _ in range(0, 20) {\n-            let (p, c) = comm::stream();\n+            let (p, c) = Chan::new();\n             chans.push(c);\n             do task::spawn {\n                 // wait until all the tasks are ready to go."}, {"sha": "2fa349942928e15d3da5eddaa0ce954ce118ee91", "filename": "src/libstd/rt/comm.rs", "status": "removed", "additions": 0, "deletions": 1141, "changes": 1141, "blob_url": "https://github.com/rust-lang/rust/blob/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=2c41a823ccb1e7cea0a29f9048533aaa78c40de6", "patch": "@@ -1,1141 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Ports and channels.\n-\n-use option::*;\n-use cast;\n-use ops::Drop;\n-use rt::kill::BlockedTask;\n-use kinds::Send;\n-use rt;\n-use rt::sched::Scheduler;\n-use rt::local::Local;\n-use rt::select::{SelectInner, SelectPortInner};\n-use select::{Select, SelectPort};\n-use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Relaxed, SeqCst};\n-use unstable::sync::UnsafeArc;\n-use util;\n-use util::Void;\n-use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable, SendDeferred};\n-use cell::RefCell;\n-use clone::Clone;\n-use tuple::ImmutableTuple;\n-\n-/// A combined refcount / BlockedTask-as-uint pointer.\n-///\n-/// Can be equal to the following values:\n-///\n-/// * 2 - both endpoints are alive\n-/// * 1 - either the sender or the receiver is dead, determined by context\n-/// * <ptr> - A pointer to a blocked Task (see BlockedTask::cast_{to,from}_uint)\n-type State = uint;\n-\n-static STATE_BOTH: State = 2;\n-static STATE_ONE: State = 1;\n-\n-/// The heap-allocated structure shared between two endpoints.\n-struct Packet<T> {\n-    state: AtomicUint,\n-    payload: Option<T>,\n-}\n-\n-// A one-shot channel.\n-pub struct ChanOne<T> {\n-    priv void_packet: *mut Void,\n-    priv suppress_finalize: bool\n-}\n-\n-/// A one-shot port.\n-pub struct PortOne<T> {\n-    priv void_packet: *mut Void,\n-    priv suppress_finalize: bool\n-}\n-\n-pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n-    let packet: ~Packet<T> = ~Packet {\n-        state: AtomicUint::new(STATE_BOTH),\n-        payload: None\n-    };\n-\n-    unsafe {\n-        let packet: *mut Void = cast::transmute(packet);\n-        let port = PortOne {\n-            void_packet: packet,\n-            suppress_finalize: false\n-        };\n-        let chan = ChanOne {\n-            void_packet: packet,\n-            suppress_finalize: false\n-        };\n-        return (port, chan);\n-    }\n-}\n-\n-impl<T: Send> ChanOne<T> {\n-    #[inline]\n-    fn packet(&self) -> *mut Packet<T> {\n-        unsafe {\n-            let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n-            let p: *mut Packet<T> = &mut **p;\n-            return p;\n-        }\n-    }\n-\n-    /// Send a message on the one-shot channel. If a receiver task is blocked\n-    /// waiting for the message, will wake it up and reschedule to it.\n-    pub fn send(self, val: T) {\n-        self.try_send(val);\n-    }\n-\n-    /// As `send`, but also returns whether or not the receiver endpoint is still open.\n-    pub fn try_send(self, val: T) -> bool {\n-        self.try_send_inner(val, true)\n-    }\n-\n-    /// Send a message without immediately rescheduling to a blocked receiver.\n-    /// This can be useful in contexts where rescheduling is forbidden, or to\n-    /// optimize for when the sender expects to still have useful work to do.\n-    pub fn send_deferred(self, val: T) {\n-        self.try_send_deferred(val);\n-    }\n-\n-    /// As `send_deferred` and `try_send` together.\n-    pub fn try_send_deferred(self, val: T) -> bool {\n-        self.try_send_inner(val, false)\n-    }\n-\n-    // 'do_resched' configures whether the scheduler immediately switches to\n-    // the receiving task, or leaves the sending task still running.\n-    fn try_send_inner(mut self, val: T, do_resched: bool) -> bool {\n-        if do_resched {\n-            rtassert!(!rt::in_sched_context());\n-        }\n-\n-        // In order to prevent starvation of other tasks in situations\n-        // where a task sends repeatedly without ever receiving, we\n-        // occassionally yield instead of doing a send immediately.\n-        // Only doing this if we're doing a rescheduling send,\n-        // otherwise the caller is expecting not to context switch.\n-        if do_resched {\n-            // XXX: This TLS hit should be combined with other uses of the scheduler below\n-            let sched: ~Scheduler = Local::take();\n-            sched.maybe_yield();\n-        }\n-\n-        let mut recvr_active = true;\n-        let packet = self.packet();\n-\n-        unsafe {\n-\n-            // Install the payload\n-            rtassert!((*packet).payload.is_none());\n-            (*packet).payload = Some(val);\n-\n-            // Atomically swap out the old state to figure out what\n-            // the port's up to, issuing a release barrier to prevent\n-            // reordering of the payload write. This also issues an\n-            // acquire barrier that keeps the subsequent access of the\n-            // ~Task pointer from being reordered.\n-            let oldstate = (*packet).state.swap(STATE_ONE, SeqCst);\n-\n-            // Suppress the synchronizing actions in the finalizer. We're\n-            // done with the packet. NB: In case of do_resched, this *must*\n-            // happen before waking up a blocked task (or be unkillable),\n-            // because we might get a kill signal during the reschedule.\n-            self.suppress_finalize = true;\n-\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Port is not waiting yet. Nothing to do\n-                }\n-                STATE_ONE => {\n-                    // Port has closed. Need to clean up.\n-                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n-                    recvr_active = false;\n-                }\n-                task_as_state => {\n-                    // Port is blocked. Wake it up.\n-                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    if do_resched {\n-                        recvr.wake().map(|woken_task| {\n-                            Scheduler::run_task(woken_task);\n-                        });\n-                    } else {\n-                        let mut sched = Local::borrow(None::<Scheduler>);\n-                        sched.get().enqueue_blocked_task(recvr);\n-                    }\n-                }\n-            }\n-        }\n-\n-        return recvr_active;\n-    }\n-}\n-\n-impl<T: Send> PortOne<T> {\n-    fn packet(&self) -> *mut Packet<T> {\n-        unsafe {\n-            let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n-            let p: *mut Packet<T> = &mut **p;\n-            return p;\n-        }\n-    }\n-\n-    /// Wait for a message on the one-shot port. Fails if the send end is closed.\n-    pub fn recv(self) -> T {\n-        match self.try_recv() {\n-            Some(val) => val,\n-            None => {\n-                fail!(\"receiving on closed channel\");\n-            }\n-        }\n-    }\n-\n-    /// As `recv`, but returns `None` if the send end is closed rather than failing.\n-    pub fn try_recv(mut self) -> Option<T> {\n-        // Optimistic check. If data was sent already, we don't even need to block.\n-        // No release barrier needed here; we're not handing off our task pointer yet.\n-        if !self.optimistic_check() {\n-            // No data available yet.\n-            // Switch to the scheduler to put the ~Task into the Packet state.\n-            let sched: ~Scheduler = Local::take();\n-            sched.deschedule_running_task_and_then(|sched, task| {\n-                self.block_on(sched, task);\n-            })\n-        }\n-\n-        // Task resumes.\n-        self.recv_ready()\n-    }\n-}\n-\n-impl<T: Send> SelectInner for PortOne<T> {\n-    #[inline] #[cfg(not(test))]\n-    fn optimistic_check(&mut self) -> bool {\n-        unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n-    }\n-\n-    #[inline] #[cfg(test)]\n-    fn optimistic_check(&mut self) -> bool {\n-        // The optimistic check is never necessary for correctness. For testing\n-        // purposes, making it randomly return false simulates a racing sender.\n-        use rand::{Rand};\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        let actually_check = Rand::rand(&mut sched.get().rng);\n-        if actually_check {\n-            unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        unsafe {\n-            // Atomically swap the task pointer into the Packet state, issuing\n-            // an acquire barrier to prevent reordering of the subsequent read\n-            // of the payload. Also issues a release barrier to prevent\n-            // reordering of any previous writes to the task structure.\n-            let task_as_state = task.cast_to_uint();\n-            let oldstate = (*self.packet()).state.swap(task_as_state, SeqCst);\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Data has not been sent. Now we're blocked.\n-                    rtdebug!(\"non-rendezvous recv\");\n-                    false\n-                }\n-                STATE_ONE => {\n-                    // Re-record that we are the only owner of the packet.\n-                    // No barrier needed, even if the task gets reawoken\n-                    // on a different core -- this is analogous to writing a\n-                    // payload; a barrier in enqueueing the task protects it.\n-                    // NB(#8132). This *must* occur before the enqueue below.\n-                    // FIXME(#6842, #8130) This is usually only needed for the\n-                    // assertion in recv_ready, except in the case of select().\n-                    // This won't actually ever have cacheline contention, but\n-                    // maybe should be optimized out with a cfg(test) anyway?\n-                    (*self.packet()).state.store(STATE_ONE, Relaxed);\n-\n-                    rtdebug!(\"rendezvous recv\");\n-\n-                    // Channel is closed. Switch back and check the data.\n-                    // NB: We have to drop back into the scheduler event loop here\n-                    // instead of switching immediately back or we could end up\n-                    // triggering infinite recursion on the scheduler's stack.\n-                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    sched.enqueue_blocked_task(recvr);\n-                    true\n-                }\n-                _ => rtabort!(\"can't block_on; a task is already blocked\")\n-            }\n-        }\n-    }\n-\n-    // This is the only select trait function that's not also used in recv.\n-    fn unblock_from(&mut self) -> bool {\n-        let packet = self.packet();\n-        unsafe {\n-            // In case the data is available, the acquire barrier here matches\n-            // the release barrier the sender used to release the payload.\n-            match (*packet).state.load(Acquire) {\n-                // Impossible. We removed STATE_BOTH when blocking on it, and\n-                // no self-respecting sender would put it back.\n-                STATE_BOTH    => rtabort!(\"refcount already 2 in unblock_from\"),\n-                // Here, a sender already tried to wake us up. Perhaps they\n-                // even succeeded! Data is available.\n-                STATE_ONE     => true,\n-                // Still registered as blocked. Need to \"unblock\" the pointer.\n-                task_as_state => {\n-                    // In the window between the load and the CAS, a sender\n-                    // might take the pointer and set the refcount to ONE. If\n-                    // that happens, we shouldn't clobber that with BOTH!\n-                    // Acquire barrier again for the same reason as above.\n-                    match (*packet).state.compare_and_swap(task_as_state, STATE_BOTH,\n-                                                           Acquire) {\n-                        STATE_BOTH => rtabort!(\"refcount became 2 in unblock_from\"),\n-                        STATE_ONE  => true, // Lost the race. Data available.\n-                        same_ptr   => {\n-                            // We successfully unblocked our task pointer.\n-                            rtassert!(task_as_state == same_ptr);\n-                            let handle = BlockedTask::cast_from_uint(task_as_state);\n-                            // Because we are already awake, the handle we\n-                            // gave to this port shall already be empty.\n-                            handle.assert_already_awake();\n-                            false\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: Send> Select for PortOne<T> { }\n-\n-impl<T: Send> SelectPortInner<T> for PortOne<T> {\n-    fn recv_ready(mut self) -> Option<T> {\n-        let packet = self.packet();\n-\n-        // No further memory barrier is needed here to access the\n-        // payload. Some scenarios:\n-        //\n-        // 1) We encountered STATE_ONE above - the atomic_xchg was the acq barrier. We're fine.\n-        // 2) We encountered STATE_BOTH above and blocked. The sending task then ran us\n-        //    and ran on its thread. The sending task issued a read barrier when taking the\n-        //    pointer to the receiving task.\n-        // 3) We encountered STATE_BOTH above and blocked, but the receiving task (this task)\n-        //    is pinned to some other scheduler, so the sending task had to give us to\n-        //    a different scheduler for resuming. That send synchronized memory.\n-        unsafe {\n-            // See corresponding store() above in block_on for rationale.\n-            // FIXME(#8130) This can happen only in test builds.\n-            // This load is not required for correctness and may be compiled out.\n-            rtassert!((*packet).state.load(Relaxed) == STATE_ONE);\n-\n-            let payload = (*packet).payload.take();\n-\n-            // The sender has closed up shop. Drop the packet.\n-            let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n-            // Suppress the synchronizing actions in the finalizer. We're done with the packet.\n-            self.suppress_finalize = true;\n-            return payload;\n-        }\n-    }\n-}\n-\n-impl<T: Send> SelectPort<T> for PortOne<T> { }\n-\n-impl<T: Send> Peekable<T> for PortOne<T> {\n-    fn peek(&self) -> bool {\n-        unsafe {\n-            let packet: *mut Packet<T> = self.packet();\n-            let oldstate = (*packet).state.load(SeqCst);\n-            match oldstate {\n-                STATE_BOTH => false,\n-                STATE_ONE => (*packet).payload.is_some(),\n-                _ => rtabort!(\"peeked on a blocked task\")\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for ChanOne<T> {\n-    fn drop(&mut self) {\n-        if self.suppress_finalize { return }\n-\n-        unsafe {\n-            let oldstate = (*self.packet()).state.swap(STATE_ONE, SeqCst);\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Port still active. It will destroy the Packet.\n-                },\n-                STATE_ONE => {\n-                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n-                },\n-                task_as_state => {\n-                    // The port is blocked waiting for a message we will never send. Wake it.\n-                    rtassert!((*self.packet()).payload.is_none());\n-                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    recvr.wake().map(|woken_task| {\n-                        Scheduler::run_task(woken_task);\n-                    });\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: Send> Drop for PortOne<T> {\n-    fn drop(&mut self) {\n-        if self.suppress_finalize { return }\n-\n-        unsafe {\n-            let oldstate = (*self.packet()).state.swap(STATE_ONE, SeqCst);\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Chan still active. It will destroy the packet.\n-                },\n-                STATE_ONE => {\n-                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n-                }\n-                task_as_state => {\n-                    // This case occurs during unwinding, when the blocked\n-                    // receiver was killed awake. The task can't still be\n-                    // blocked (we are it), but we need to free the handle.\n-                    let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    recvr.assert_already_awake();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct StreamPayload<T> {\n-    val: T,\n-    next: PortOne<StreamPayload<T>>\n-}\n-\n-type StreamChanOne<T> = ChanOne<StreamPayload<T>>;\n-type StreamPortOne<T> = PortOne<StreamPayload<T>>;\n-\n-/// A channel with unbounded size.\n-pub struct Chan<T> {\n-    // FIXME #5372. Using RefCell because we don't take &mut self\n-    next: RefCell<StreamChanOne<T>>\n-}\n-\n-/// An port with unbounded size.\n-pub struct Port<T> {\n-    // FIXME #5372. Using RefCell because we don't take &mut self\n-    next: RefCell<Option<StreamPortOne<T>>>\n-}\n-\n-pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n-    let (pone, cone) = oneshot();\n-    let port = Port { next: RefCell::new(Some(pone)) };\n-    let chan = Chan { next: RefCell::new(cone) };\n-    return (port, chan);\n-}\n-\n-impl<T: Send> Chan<T> {\n-    fn try_send_inner(&self, val: T, do_resched: bool) -> bool {\n-        let (next_pone, mut cone) = oneshot();\n-        let mut b = self.next.borrow_mut();\n-        util::swap(&mut cone, b.get());\n-        cone.try_send_inner(StreamPayload { val: val, next: next_pone }, do_resched)\n-    }\n-}\n-\n-impl<T: Send> GenericChan<T> for Chan<T> {\n-    fn send(&self, val: T) {\n-        self.try_send(val);\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for Chan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        self.try_send_inner(val, true)\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for Chan<T> {\n-    fn send_deferred(&self, val: T) {\n-        self.try_send_deferred(val);\n-    }\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        self.try_send_inner(val, false)\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for Port<T> {\n-    fn recv(&self) -> T {\n-        match self.try_recv() {\n-            Some(val) => val,\n-            None => {\n-                fail!(\"receiving on closed channel\");\n-            }\n-        }\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        let mut b = self.next.borrow_mut();\n-        b.get().take().map_default(None, |pone| {\n-            match pone.try_recv() {\n-                Some(StreamPayload { val, next }) => {\n-                    *b.get() = Some(next);\n-                    Some(val)\n-                }\n-                None => None\n-            }\n-        })\n-    }\n-}\n-\n-impl<T: Send> Peekable<T> for Port<T> {\n-    fn peek(&self) -> bool {\n-        self.next.with_mut(|p| p.get_mut_ref().peek())\n-    }\n-}\n-\n-// XXX: Kind of gross. A Port<T> should be selectable so you can make an array\n-// of them, but a &Port<T> should also be selectable so you can select2 on it\n-// alongside a PortOne<U> without passing the port by value in recv_ready.\n-\n-impl<'a, T: Send> SelectInner for &'a Port<T> {\n-    #[inline]\n-    fn optimistic_check(&mut self) -> bool {\n-        self.next.with_mut(|pone| { pone.get_mut_ref().optimistic_check() })\n-    }\n-\n-    #[inline]\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        let mut b = self.next.borrow_mut();\n-        b.get().get_mut_ref().block_on(sched, task)\n-    }\n-\n-    #[inline]\n-    fn unblock_from(&mut self) -> bool {\n-        self.next.with_mut(|pone| { pone.get_mut_ref().unblock_from() })\n-    }\n-}\n-\n-impl<'a, T: Send> Select for &'a Port<T> { }\n-\n-impl<T: Send> SelectInner for Port<T> {\n-    #[inline]\n-    fn optimistic_check(&mut self) -> bool {\n-        (&*self).optimistic_check()\n-    }\n-\n-    #[inline]\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        (&*self).block_on(sched, task)\n-    }\n-\n-    #[inline]\n-    fn unblock_from(&mut self) -> bool {\n-        (&*self).unblock_from()\n-    }\n-}\n-\n-impl<T: Send> Select for Port<T> { }\n-\n-impl<'a, T: Send> SelectPortInner<T> for &'a Port<T> {\n-    fn recv_ready(self) -> Option<T> {\n-        let mut b = self.next.borrow_mut();\n-        match b.get().take_unwrap().recv_ready() {\n-            Some(StreamPayload { val, next }) => {\n-                *b.get() = Some(next);\n-                Some(val)\n-            }\n-            None => None\n-        }\n-    }\n-}\n-\n-impl<'a, T: Send> SelectPort<T> for &'a Port<T> { }\n-\n-pub struct SharedChan<T> {\n-    // Just like Chan, but a shared AtomicOption\n-    priv next: UnsafeArc<AtomicOption<StreamChanOne<T>>>\n-}\n-\n-impl<T: Send> SharedChan<T> {\n-    pub fn new(chan: Chan<T>) -> SharedChan<T> {\n-        let next = chan.next.unwrap();\n-        let next = AtomicOption::new(~next);\n-        SharedChan { next: UnsafeArc::new(next) }\n-    }\n-}\n-\n-impl<T: Send> SharedChan<T> {\n-    fn try_send_inner(&self, val: T, do_resched: bool) -> bool {\n-        unsafe {\n-            let (next_pone, next_cone) = oneshot();\n-            let cone = (*self.next.get()).swap(~next_cone, SeqCst);\n-            cone.unwrap().try_send_inner(StreamPayload { val: val, next: next_pone },\n-                                         do_resched)\n-        }\n-    }\n-}\n-\n-impl<T: Send> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, val: T) {\n-        self.try_send(val);\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        self.try_send_inner(val, true)\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for SharedChan<T> {\n-    fn send_deferred(&self, val: T) {\n-        self.try_send_deferred(val);\n-    }\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        self.try_send_inner(val, false)\n-    }\n-}\n-\n-impl<T: Send> Clone for SharedChan<T> {\n-    fn clone(&self) -> SharedChan<T> {\n-        SharedChan {\n-            next: self.next.clone()\n-        }\n-    }\n-}\n-\n-pub struct SharedPort<T> {\n-    // The next port on which we will receive the next port on which we will receive T\n-    priv next_link: UnsafeArc<AtomicOption<PortOne<StreamPortOne<T>>>>\n-}\n-\n-impl<T: Send> SharedPort<T> {\n-    pub fn new(port: Port<T>) -> SharedPort<T> {\n-        // Put the data port into a new link pipe\n-        let next_data_port = port.next.unwrap().unwrap();\n-        let (next_link_port, next_link_chan) = oneshot();\n-        next_link_chan.send(next_data_port);\n-        let next_link = AtomicOption::new(~next_link_port);\n-        SharedPort { next_link: UnsafeArc::new(next_link) }\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for SharedPort<T> {\n-    fn recv(&self) -> T {\n-        match self.try_recv() {\n-            Some(val) => val,\n-            None => {\n-                fail!(\"receiving on a closed channel\");\n-            }\n-        }\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        unsafe {\n-            let (next_link_port, next_link_chan) = oneshot();\n-            let link_port = (*self.next_link.get()).swap(~next_link_port, SeqCst);\n-            let link_port = link_port.unwrap();\n-            let data_port = link_port.recv();\n-            let (next_data_port, res) = match data_port.try_recv() {\n-                Some(StreamPayload { val, next }) => {\n-                    (next, Some(val))\n-                }\n-                None => {\n-                    let (next_data_port, _) = oneshot();\n-                    (next_data_port, None)\n-                }\n-            };\n-            next_link_chan.send(next_data_port);\n-            return res;\n-        }\n-    }\n-}\n-\n-impl<T: Send> Clone for SharedPort<T> {\n-    fn clone(&self) -> SharedPort<T> {\n-        SharedPort {\n-            next_link: self.next_link.clone()\n-        }\n-    }\n-}\n-\n-// FIXME #7760: Need better name\n-type MegaPipe<T> = (SharedPort<T>, SharedChan<T>);\n-\n-pub fn megapipe<T: Send>() -> MegaPipe<T> {\n-    let (port, chan) = stream();\n-    (SharedPort::new(port), SharedChan::new(chan))\n-}\n-\n-impl<T: Send> GenericChan<T> for MegaPipe<T> {\n-    fn send(&self, val: T) {\n-        self.second_ref().send(val)\n-    }\n-}\n-\n-impl<T: Send> GenericSmartChan<T> for MegaPipe<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        self.second_ref().try_send(val)\n-    }\n-}\n-\n-impl<T: Send> GenericPort<T> for MegaPipe<T> {\n-    fn recv(&self) -> T {\n-        self.first_ref().recv()\n-    }\n-\n-    fn try_recv(&self) -> Option<T> {\n-        self.first_ref().try_recv()\n-    }\n-}\n-\n-impl<T: Send> SendDeferred<T> for MegaPipe<T> {\n-    fn send_deferred(&self, val: T) {\n-        self.second_ref().send_deferred(val)\n-    }\n-    fn try_send_deferred(&self, val: T) -> bool {\n-        self.second_ref().try_send_deferred(val)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use option::*;\n-    use rt::test::*;\n-    use num::Times;\n-    use rt::util;\n-\n-    #[test]\n-    fn oneshot_single_thread_close_port_first() {\n-        // Simple test of closing without sending\n-        do run_in_newsched_task {\n-            let (port, _chan) = oneshot::<int>();\n-            { let _p = port; }\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_close_chan_first() {\n-        // Simple test of closing without sending\n-        do run_in_newsched_task {\n-            let (_port, chan) = oneshot::<int>();\n-            { let _c = chan; }\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_send_port_close() {\n-        // Testing that the sender cleans up the payload if receiver is closed\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<~int>();\n-            { let _p = port; }\n-            chan.send(~0);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_recv_chan_close() {\n-        // Receiving on a closed chan will fail\n-        do run_in_newsched_task {\n-            let res = do spawntask_try {\n-                let (port, chan) = oneshot::<~int>();\n-                { let _c = chan; }\n-                port.recv();\n-            };\n-            // What is our res?\n-            rtdebug!(\"res is: {:?}\", res.is_err());\n-            assert!(res.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_send_then_recv() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<~int>();\n-            chan.send(~10);\n-            assert!(port.recv() == ~10);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_try_send_open() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            assert!(chan.try_send(10));\n-            assert!(port.recv() == 10);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_try_send_closed() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            { let _p = port; }\n-            assert!(!chan.try_send(10));\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_try_recv_open() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            chan.send(10);\n-            assert!(port.try_recv() == Some(10));\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_try_recv_closed() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            { let _c = chan; }\n-            assert!(port.try_recv() == None);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_peek_data() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            assert!(!port.peek());\n-            chan.send(10);\n-            assert!(port.peek());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_peek_close() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<int>();\n-            { let _c = chan; }\n-            assert!(!port.peek());\n-            assert!(!port.peek());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_peek_open() {\n-        do run_in_newsched_task {\n-            let (port, _) = oneshot::<int>();\n-            assert!(!port.peek());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_task_recv_then_send() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<~int>();\n-            do spawntask {\n-                assert!(port.recv() == ~10);\n-            }\n-\n-            chan.send(~10);\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_task_recv_then_close() {\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot::<~int>();\n-            do spawntask_later {\n-                let _ = chan;\n-            }\n-            let res = do spawntask_try {\n-                assert!(port.recv() == ~10);\n-            };\n-            assert!(res.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_thread_close_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = oneshot::<int>();\n-                let thread = do spawntask_thread {\n-                    let _ = port;\n-                };\n-                let _chan = chan;\n-                thread.join();\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_thread_send_close_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = oneshot::<int>();\n-                let thread1 = do spawntask_thread {\n-                    let _ = port;\n-                };\n-                let thread2 = do spawntask_thread {\n-                    chan.send(1);\n-                };\n-                thread1.join();\n-                thread2.join();\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_thread_recv_close_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = oneshot::<int>();\n-                let thread1 = do spawntask_thread {\n-                    let port = port;\n-                    let res = do spawntask_try {\n-                        port.recv();\n-                    };\n-                    assert!(res.is_err());\n-                };\n-                let thread2 = do spawntask_thread {\n-                    let chan = chan;\n-                    do spawntask {\n-                        let _ = chan;\n-                    }\n-                };\n-                thread1.join();\n-                thread2.join();\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn oneshot_multi_thread_send_recv_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = oneshot::<~int>();\n-                let thread1 = do spawntask_thread {\n-                    chan.send(~10);\n-                };\n-                let thread2 = do spawntask_thread {\n-                    assert!(port.recv() == ~10);\n-                };\n-                thread1.join();\n-                thread2.join();\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn stream_send_recv_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        stress_factor().times(|| {\n-            do run_in_mt_newsched_task {\n-                let (port, chan) = stream::<~int>();\n-\n-                send(chan, 0);\n-                recv(port, 0);\n-\n-                fn send(chan: Chan<~int>, i: int) {\n-                    if i == 10 { return }\n-\n-                    do spawntask_random {\n-                        chan.send(~i);\n-                        send(chan, i + 1);\n-                    }\n-                }\n-\n-                fn recv(port: Port<~int>, i: int) {\n-                    if i == 10 { return }\n-\n-                    do spawntask_random {\n-                        assert!(port.recv() == ~i);\n-                        recv(port, i + 1);\n-                    };\n-                }\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn recv_a_lot() {\n-        // Regression test that we don't run out of stack in scheduler context\n-        do run_in_newsched_task {\n-            let (port, chan) = stream();\n-            10000.times(|| { chan.send(()) });\n-            10000.times(|| { port.recv() });\n-        }\n-    }\n-\n-    #[test]\n-    fn shared_chan_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do run_in_mt_newsched_task {\n-            let (port, chan) = stream();\n-            let chan = SharedChan::new(chan);\n-            let total = stress_factor() + 100;\n-            total.times(|| {\n-                let chan_clone = chan.clone();\n-                do spawntask_random {\n-                    chan_clone.send(());\n-                }\n-            });\n-\n-            total.times(|| {\n-                port.recv();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn shared_port_stress() {\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = stream();\n-            let (port, chan) = stream();\n-            let end_chan = SharedChan::new(end_chan);\n-            let port = SharedPort::new(port);\n-            let total = stress_factor() + 100;\n-            total.times(|| {\n-                let end_chan_clone = end_chan.clone();\n-                let port_clone = port.clone();\n-                do spawntask_random {\n-                    port_clone.recv();\n-                    end_chan_clone.send(());\n-                }\n-            });\n-\n-            total.times(|| {\n-                chan.send(());\n-            });\n-\n-            total.times(|| {\n-                end_port.recv();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn shared_port_close_simple() {\n-        do run_in_mt_newsched_task {\n-            let (port, chan) = stream::<()>();\n-            let port = SharedPort::new(port);\n-            { let _chan = chan; }\n-            assert!(port.try_recv().is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn shared_port_close() {\n-        do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = stream::<bool>();\n-            let (port, chan) = stream::<()>();\n-            let end_chan = SharedChan::new(end_chan);\n-            let port = SharedPort::new(port);\n-            let chan = SharedChan::new(chan);\n-            let send_total = 10;\n-            let recv_total = 20;\n-            do spawntask_random {\n-                send_total.times(|| {\n-                    let chan_clone = chan.clone();\n-                    do spawntask_random {\n-                        chan_clone.send(());\n-                    }\n-                });\n-            }\n-            let end_chan_clone = end_chan.clone();\n-            do spawntask_random {\n-                recv_total.times(|| {\n-                    let port_clone = port.clone();\n-                    let end_chan_clone = end_chan_clone.clone();\n-                    do spawntask_random {\n-                        let recvd = port_clone.try_recv().is_some();\n-                        end_chan_clone.send(recvd);\n-                    }\n-                });\n-            }\n-\n-            let mut recvd = 0;\n-            recv_total.times(|| {\n-                recvd += if end_port.recv() { 1 } else { 0 };\n-            });\n-\n-            assert!(recvd == send_total);\n-        }\n-    }\n-\n-    #[test]\n-    fn megapipe_stress() {\n-        use rand;\n-        use rand::Rng;\n-\n-        if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-\n-        do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = stream::<()>();\n-            let end_chan = SharedChan::new(end_chan);\n-            let pipe = megapipe();\n-            let total = stress_factor() + 10;\n-            let mut rng = rand::rng();\n-            total.times(|| {\n-                let msgs = rng.gen_range(0u, 10);\n-                let pipe_clone = pipe.clone();\n-                let end_chan_clone = end_chan.clone();\n-                do spawntask_random {\n-                    msgs.times(|| {\n-                        pipe_clone.send(());\n-                    });\n-                    msgs.times(|| {\n-                        pipe_clone.recv();\n-                    });\n-                }\n-\n-                end_chan_clone.send(());\n-            });\n-\n-            total.times(|| {\n-                end_port.recv();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn send_deferred() {\n-        use unstable::sync::atomic;\n-\n-        // Tests no-rescheduling of send_deferred on all types of channels.\n-        do run_in_newsched_task {\n-            let (pone, cone) = oneshot();\n-            let (pstream, cstream) = stream();\n-            let (pshared, cshared) = stream();\n-            let cshared = SharedChan::new(cshared);\n-            let mp = megapipe();\n-\n-            do spawntask { pone.recv(); }\n-            do spawntask { pstream.recv(); }\n-            do spawntask { pshared.recv(); }\n-            let p_mp = mp.clone();\n-            do spawntask { p_mp.recv(); }\n-\n-            unsafe {\n-                let _guard = atomic();\n-                cone.send_deferred(());\n-                cstream.send_deferred(());\n-                cshared.send_deferred(());\n-                mp.send_deferred(());\n-            }\n-        }\n-    }\n-\n-}"}, {"sha": "f4f128cf5aac1053852c2475d59fa99f229d920d", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -153,8 +153,9 @@ There are two known issues with the current scheme for exit code propagation.\n use cast;\n use option::{Option, Some, None};\n use prelude::*;\n+use iter;\n+use task::TaskResult;\n use rt::task::Task;\n-use rt::task::UnwindResult;\n use unstable::atomics::{AtomicUint, SeqCst};\n use unstable::sync::UnsafeArc;\n \n@@ -169,11 +170,21 @@ pub enum BlockedTask {\n pub struct Death {\n     // Action to be done with the exit code. If set, also makes the task wait\n     // until all its watched children exit before collecting the status.\n-    on_exit:         Option<proc(UnwindResult)>,\n+    on_exit:         Option<proc(TaskResult)>,\n     // nesting level counter for unstable::atomically calls (0 == can deschedule).\n     priv wont_sleep:      int,\n }\n \n+pub struct BlockedTaskIterator {\n+    priv inner: UnsafeArc<AtomicUint>,\n+}\n+\n+impl Iterator<BlockedTask> for BlockedTaskIterator {\n+    fn next(&mut self) -> Option<BlockedTask> {\n+        Some(Shared(self.inner.clone()))\n+    }\n+}\n+\n impl BlockedTask {\n     /// Returns Some if the task was successfully woken; None if already killed.\n     pub fn wake(self) -> Option<~Task> {\n@@ -194,19 +205,17 @@ impl BlockedTask {\n     }\n \n     /// Converts one blocked task handle to a list of many handles to the same.\n-    pub fn make_selectable(self, num_handles: uint) -> ~[BlockedTask] {\n-        let handles = match self {\n+    pub fn make_selectable(self, num_handles: uint)\n+        -> iter::Take<BlockedTaskIterator>\n+    {\n+        let arc = match self {\n             Owned(task) => {\n-                let flag = unsafe {\n-                    AtomicUint::new(cast::transmute(task))\n-                };\n-                UnsafeArc::newN(flag, num_handles)\n+                let flag = unsafe { AtomicUint::new(cast::transmute(task)) };\n+                UnsafeArc::new(flag)\n             }\n-            Shared(arc) => arc.cloneN(num_handles),\n+            Shared(arc) => arc.clone(),\n         };\n-        // Even if the task was unkillable before, we use 'Killable' because\n-        // multiple pipes will have handles. It does not really mean killable.\n-        handles.move_iter().map(|x| Shared(x)).collect()\n+        BlockedTaskIterator{ inner: arc }.take(num_handles)\n     }\n \n     // This assertion has two flavours because the wake involves an atomic op.\n@@ -254,10 +263,10 @@ impl Death {\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, result: UnwindResult) {\n+    pub fn collect_failure(&mut self, result: TaskResult) {\n         match self.on_exit.take() {\n+            Some(f) => f(result),\n             None => {}\n-            Some(on_exit) => on_exit(result),\n         }\n     }\n "}, {"sha": "925aa802ad5c299626bb616a16e1644f8b0f3590", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -77,10 +77,9 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n /// it wherever possible.\n #[cfg(not(windows), not(target_os = \"android\"))]\n pub mod compiled {\n-    #[cfg(not(test))]\n-    use libc::c_void;\n     use cast;\n     use option::{Option, Some, None};\n+    #[cfg(not(test))] use libc::c_void;\n \n     #[cfg(test)]\n     pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;"}, {"sha": "10e457368f007e3e36ccdb8f2e33a2fd7105b192", "filename": "src/libstd/rt/message_queue.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=2c41a823ccb1e7cea0a29f9048533aaa78c40de6", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A concurrent queue that supports multiple producers and a\n-//! single consumer.\n-\n-use kinds::Send;\n-use vec::OwnedVector;\n-use option::Option;\n-use clone::Clone;\n-use rt::mpsc_queue::Queue;\n-\n-pub struct MessageQueue<T> {\n-    priv queue: Queue<T>\n-}\n-\n-impl<T: Send> MessageQueue<T> {\n-    pub fn new() -> MessageQueue<T> {\n-        MessageQueue {\n-            queue: Queue::new()\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn push(&mut self, value: T) {\n-        self.queue.push(value)\n-    }\n-\n-    #[inline]\n-    pub fn pop(&mut self) -> Option<T> {\n-        self.queue.pop()\n-    }\n-\n-    /// A pop that may sometimes miss enqueued elements, but is much faster\n-    /// to give up without doing any synchronization\n-    #[inline]\n-    pub fn casual_pop(&mut self) -> Option<T> {\n-        self.queue.pop()\n-    }\n-}\n-\n-impl<T: Send> Clone for MessageQueue<T> {\n-    fn clone(&self) -> MessageQueue<T> {\n-        MessageQueue {\n-            queue: self.queue.clone()\n-        }\n-    }\n-}"}, {"sha": "5d2179e8b9693ba0c6159e92483fa1de4b8109e8", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -65,7 +65,7 @@ use ptr::RawPtr;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown};\n use rt::sleeper_list::SleeperList;\n-use rt::task::UnwindResult;\n+use task::TaskResult;\n use rt::task::{Task, SchedTask, GreenTask, Sched};\n use send_str::SendStrStatic;\n use unstable::atomics::{AtomicInt, AtomicBool, SeqCst};\n@@ -91,8 +91,6 @@ pub use self::kill::BlockedTask;\n // XXX: these probably shouldn't be public...\n #[doc(hidden)]\n pub mod shouldnt_be_public {\n-    pub use super::select::SelectInner;\n-    pub use super::select::{SelectInner, SelectPortInner};\n     pub use super::local_ptr::native::maybe_tls_key;\n     #[cfg(not(windows), not(target_os = \"android\"))]\n     pub use super::local_ptr::compiled::RT_TLS_PTR;\n@@ -123,11 +121,11 @@ pub mod rtio;\n /// or task-local storage.\n pub mod local;\n \n-/// A parallel queue.\n-pub mod message_queue;\n-\n /// A mostly lock-free multi-producer, single consumer queue.\n-mod mpsc_queue;\n+pub mod mpsc_queue;\n+\n+/// A lock-free single-producer, single consumer queue.\n+pub mod spsc_queue;\n \n /// A lock-free multi-producer, multi-consumer bounded queue.\n mod mpmc_bounded_queue;\n@@ -169,11 +167,6 @@ pub mod rc;\n /// scheduler and task context\n pub mod tube;\n \n-/// Simple reimplementation of std::comm\n-pub mod comm;\n-\n-mod select;\n-\n /// The runtime needs to be able to put a pointer into thread-local storage.\n mod local_ptr;\n \n@@ -349,7 +342,7 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n     // When the main task exits, after all the tasks in the main\n     // task tree, shut down the schedulers and set the exit code.\n     let handles = handles;\n-    let on_exit: proc(UnwindResult) = proc(exit_success) {\n+    let on_exit: proc(TaskResult) = proc(exit_success) {\n         unsafe {\n             assert!(!(*exited_already.get()).swap(true, SeqCst),\n                     \"the runtime already exited\");\n@@ -361,7 +354,7 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n         }\n \n         unsafe {\n-            let exit_code = if exit_success.is_success() {\n+            let exit_code = if exit_success.is_ok() {\n                 use rt::util;\n \n                 // If we're exiting successfully, then return the global"}, {"sha": "1e04e5eb78d59932d5cf34a25623b73485412d2a", "filename": "src/libstd/rt/mpmc_bounded_queue.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -1,5 +1,4 @@\n-/* Multi-producer/multi-consumer bounded queue\n- * Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n+/* Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions are met:\n  *\n@@ -163,7 +162,6 @@ mod tests {\n     use prelude::*;\n     use option::*;\n     use task;\n-    use comm;\n     use super::Queue;\n \n     #[test]\n@@ -174,10 +172,9 @@ mod tests {\n         assert_eq!(None, q.pop());\n \n         for _ in range(0, nthreads) {\n-            let (port, chan)  = comm::stream();\n-            chan.send(q.clone());\n+            let q = q.clone();\n             do task::spawn_sched(task::SingleThreaded) {\n-                let mut q = port.recv();\n+                let mut q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n                 }\n@@ -186,12 +183,11 @@ mod tests {\n \n         let mut completion_ports = ~[];\n         for _ in range(0, nthreads) {\n-            let (completion_port, completion_chan) = comm::stream();\n+            let (completion_port, completion_chan) = Chan::new();\n             completion_ports.push(completion_port);\n-            let (port, chan)  = comm::stream();\n-            chan.send(q.clone());\n+            let q = q.clone();\n             do task::spawn_sched(task::SingleThreaded) {\n-                let mut q = port.recv();\n+                let mut q = q;\n                 let mut i = 0u;\n                 loop {\n                     match q.pop() {\n@@ -206,7 +202,7 @@ mod tests {\n             }\n         }\n \n-        for completion_port in completion_ports.iter() {\n+        for completion_port in completion_ports.mut_iter() {\n             assert_eq!(nmsgs, completion_port.recv());\n         }\n     }"}, {"sha": "d575028af704399d07cf8cc70ffe18a542143cb9", "filename": "src/libstd/rt/mpsc_queue.rs", "status": "modified", "additions": 120, "deletions": 110, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmpsc_queue.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -1,5 +1,4 @@\n-/* Multi-producer/single-consumer queue\n- * Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n+/* Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n  * Redistribution and use in source and binary forms, with or without\n  * modification, are permitted provided that the following conditions are met:\n  *\n@@ -27,177 +26,188 @@\n  */\n \n //! A mostly lock-free multi-producer, single consumer queue.\n-// http://www.1024cores.net/home/lock-free-algorithms/queues/intrusive-mpsc-node-based-queue\n \n-use unstable::sync::UnsafeArc;\n-use unstable::atomics::{AtomicPtr,Relaxed,Release,Acquire};\n-use ptr::{mut_null, to_mut_unsafe_ptr};\n+// http://www.1024cores.net/home/lock-free-algorithms\n+//                         /queues/non-intrusive-mpsc-node-based-queue\n+\n use cast;\n-use option::*;\n use clone::Clone;\n use kinds::Send;\n+use ops::Drop;\n+use option::{Option, None, Some};\n+use unstable::atomics::{AtomicPtr, Release, Acquire, AcqRel, Relaxed};\n+use unstable::sync::UnsafeArc;\n+\n+pub enum PopResult<T> {\n+    /// Some data has been popped\n+    Data(T),\n+    /// The queue is empty\n+    Empty,\n+    /// The queue is in an inconsistent state. Popping data should succeed, but\n+    /// some pushers have yet to make enough progress in order allow a pop to\n+    /// succeed. It is recommended that a pop() occur \"in the near future\" in\n+    /// order to see if the sender has made progress or not\n+    Inconsistent,\n+}\n \n struct Node<T> {\n     next: AtomicPtr<Node<T>>,\n     value: Option<T>,\n }\n \n-impl<T> Node<T> {\n-    fn empty() -> Node<T> {\n-        Node{next: AtomicPtr::new(mut_null()), value: None}\n-    }\n-\n-    fn with_value(value: T) -> Node<T> {\n-        Node{next: AtomicPtr::new(mut_null()), value: Some(value)}\n-    }\n-}\n-\n-struct State<T> {\n-    pad0: [u8, ..64],\n+struct State<T, P> {\n     head: AtomicPtr<Node<T>>,\n-    pad1: [u8, ..64],\n-    stub: Node<T>,\n-    pad2: [u8, ..64],\n     tail: *mut Node<T>,\n-    pad3: [u8, ..64],\n+    packet: P,\n }\n \n-struct Queue<T> {\n-    priv state: UnsafeArc<State<T>>,\n+pub struct Consumer<T, P> {\n+    priv state: UnsafeArc<State<T, P>>,\n }\n \n-impl<T: Send> Clone for Queue<T> {\n-    fn clone(&self) -> Queue<T> {\n-        Queue {\n-            state: self.state.clone()\n-        }\n-    }\n+pub struct Producer<T, P> {\n+    priv state: UnsafeArc<State<T, P>>,\n }\n \n-impl<T: Send> State<T> {\n-    pub fn new() -> State<T> {\n-        State{\n-            pad0: [0, ..64],\n-            head: AtomicPtr::new(mut_null()),\n-            pad1: [0, ..64],\n-            stub: Node::<T>::empty(),\n-            pad2: [0, ..64],\n-            tail: mut_null(),\n-            pad3: [0, ..64],\n-        }\n+impl<T: Send, P: Send> Clone for Producer<T, P> {\n+    fn clone(&self) -> Producer<T, P> {\n+        Producer { state: self.state.clone() }\n     }\n+}\n \n-    fn init(&mut self) {\n-        let stub = self.get_stub_unsafe();\n-        self.head.store(stub, Relaxed);\n-        self.tail = stub;\n+pub fn queue<T: Send, P: Send>(p: P) -> (Consumer<T, P>, Producer<T, P>) {\n+    unsafe {\n+        let (a, b) = UnsafeArc::new2(State::new(p));\n+        (Consumer { state: a }, Producer { state: b })\n     }\n+}\n \n-    fn get_stub_unsafe(&mut self) -> *mut Node<T> {\n-        to_mut_unsafe_ptr(&mut self.stub)\n+impl<T> Node<T> {\n+    unsafe fn new(v: Option<T>) -> *mut Node<T> {\n+        cast::transmute(~Node {\n+            next: AtomicPtr::new(0 as *mut Node<T>),\n+            value: v,\n+        })\n     }\n+}\n \n-    fn push(&mut self, value: T) {\n-        unsafe {\n-            let node = cast::transmute(~Node::with_value(value));\n-            self.push_node(node);\n+impl<T: Send, P: Send> State<T, P> {\n+    pub unsafe fn new(p: P) -> State<T, P> {\n+        let stub = Node::new(None);\n+        State {\n+            head: AtomicPtr::new(stub),\n+            tail: stub,\n+            packet: p,\n         }\n     }\n \n-    fn push_node(&mut self, node: *mut Node<T>) {\n-        unsafe {\n-            (*node).next.store(mut_null(), Release);\n-            let prev = self.head.swap(node, Relaxed);\n-            (*prev).next.store(node, Release);\n-        }\n+    unsafe fn push(&mut self, t: T) {\n+        let n = Node::new(Some(t));\n+        let prev = self.head.swap(n, AcqRel);\n+        (*prev).next.store(n, Release);\n     }\n \n-    fn pop(&mut self) -> Option<T> {\n-        unsafe {\n-            let mut tail = self.tail;\n-            let mut next = (*tail).next.load(Acquire);\n-            let stub = self.get_stub_unsafe();\n-            if tail == stub {\n-                if mut_null() == next {\n-                    return None\n-                }\n-                self.tail = next;\n-                tail = next;\n-                next = (*next).next.load(Acquire);\n-            }\n-            if next != mut_null() {\n-                let tail: ~Node<T> = cast::transmute(tail);\n-                self.tail = next;\n-                return tail.value\n-            }\n-            let head = self.head.load(Relaxed);\n-            if tail != head {\n-                return None\n-            }\n-            self.push_node(stub);\n-            next = (*tail).next.load(Acquire);\n-            if next != mut_null() {\n-                let tail: ~Node<T> = cast::transmute(tail);\n-                self.tail = next;\n-                return tail.value\n-            }\n+    unsafe fn pop(&mut self) -> PopResult<T> {\n+        let tail = self.tail;\n+        let next = (*tail).next.load(Acquire);\n+\n+        if !next.is_null() {\n+            self.tail = next;\n+            assert!((*tail).value.is_none());\n+            assert!((*next).value.is_some());\n+            let ret = (*next).value.take_unwrap();\n+            let _: ~Node<T> = cast::transmute(tail);\n+            return Data(ret);\n         }\n-        None\n+\n+        if self.head.load(Acquire) == tail {Empty} else {Inconsistent}\n+    }\n+\n+    unsafe fn is_empty(&mut self) -> bool {\n+        return (*self.tail).next.load(Acquire).is_null();\n     }\n }\n \n-impl<T: Send> Queue<T> {\n-    pub fn new() -> Queue<T> {\n+#[unsafe_destructor]\n+impl<T: Send, P: Send> Drop for State<T, P> {\n+    fn drop(&mut self) {\n         unsafe {\n-            let q = Queue{state: UnsafeArc::new(State::new())};\n-            (*q.state.get()).init();\n-            q\n+            let mut cur = self.tail;\n+            while !cur.is_null() {\n+                let next = (*cur).next.load(Relaxed);\n+                let _: ~Node<T> = cast::transmute(cur);\n+                cur = next;\n+            }\n         }\n     }\n+}\n \n+impl<T: Send, P: Send> Producer<T, P> {\n     pub fn push(&mut self, value: T) {\n         unsafe { (*self.state.get()).push(value) }\n     }\n+    pub fn is_empty(&self) -> bool {\n+        unsafe{ (*self.state.get()).is_empty() }\n+    }\n+    pub unsafe fn packet(&self) -> *mut P {\n+        &mut (*self.state.get()).packet as *mut P\n+    }\n+}\n \n-    pub fn pop(&mut self) -> Option<T> {\n-        unsafe{ (*self.state.get()).pop() }\n+impl<T: Send, P: Send> Consumer<T, P> {\n+    pub fn pop(&mut self) -> PopResult<T> {\n+        unsafe { (*self.state.get()).pop() }\n+    }\n+    pub fn casual_pop(&mut self) -> Option<T> {\n+        match self.pop() {\n+            Data(t) => Some(t),\n+            Empty | Inconsistent => None,\n+        }\n+    }\n+    pub unsafe fn packet(&self) -> *mut P {\n+        &mut (*self.state.get()).packet as *mut P\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use option::*;\n+\n     use task;\n-    use comm;\n-    use super::Queue;\n+    use super::{queue, Data, Empty, Inconsistent};\n+\n+    #[test]\n+    fn test_full() {\n+        let (_, mut p) = queue(());\n+        p.push(~1);\n+        p.push(~2);\n+    }\n \n     #[test]\n     fn test() {\n         let nthreads = 8u;\n         let nmsgs = 1000u;\n-        let mut q = Queue::new();\n-        assert_eq!(None, q.pop());\n+        let (mut c, p) = queue(());\n+        match c.pop() {\n+            Empty => {}\n+            Inconsistent | Data(..) => fail!()\n+        }\n \n         for _ in range(0, nthreads) {\n-            let (port, chan)  = comm::stream();\n-            chan.send(q.clone());\n+            let q = p.clone();\n             do task::spawn_sched(task::SingleThreaded) {\n-                let mut q = port.recv();\n+                let mut q = q;\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }\n             }\n         }\n \n         let mut i = 0u;\n-        loop {\n-            match q.pop() {\n-                None => {},\n-                Some(_) => {\n-                    i += 1;\n-                    if i == nthreads*nmsgs { break }\n-                }\n+        while i < nthreads * nmsgs {\n+            match c.pop() {\n+                Empty | Inconsistent => {},\n+                Data(_) => { i += 1 }\n             }\n         }\n     }"}, {"sha": "b54231421e3969be21f725ab179998cc9b2a41e3", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -10,7 +10,7 @@\n \n use c_str::CString;\n use cast;\n-use comm::{SharedChan, PortOne, Port};\n+use comm::{SharedChan, Port};\n use libc::c_int;\n use libc;\n use ops::Drop;\n@@ -222,7 +222,7 @@ pub trait RtioUdpSocket : RtioSocket {\n \n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n-    fn oneshot(&mut self, msecs: u64) -> PortOne<()>;\n+    fn oneshot(&mut self, msecs: u64) -> Port<()>;\n     fn period(&mut self, msecs: u64) -> Port<()>;\n }\n "}, {"sha": "ac3aeb5a4bb3d8a0d804d7799fd3ab1737f19ce3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 57, "deletions": 48, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -17,7 +17,6 @@ use super::stack::{StackPool};\n use super::rtio::EventLoop;\n use super::context::Context;\n use super::task::{Task, AnySched, Sched};\n-use super::message_queue::MessageQueue;\n use rt::kill::BlockedTask;\n use rt::deque;\n use rt::local_ptr;\n@@ -29,6 +28,7 @@ use iter::range;\n use unstable::mutex::Mutex;\n use vec::{OwnedVector};\n \n+use mpsc = super::mpsc_queue;\n \n /// A scheduler is responsible for coordinating the execution of Tasks\n /// on a single thread. The scheduler runs inside a slightly modified\n@@ -47,7 +47,9 @@ pub struct Scheduler {\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n-    message_queue: MessageQueue<SchedMessage>,\n+    message_queue: mpsc::Consumer<SchedMessage, ()>,\n+    /// Producer used to clone sched handles from\n+    message_producer: mpsc::Producer<SchedMessage, ()>,\n     /// A shared list of sleeping schedulers. We'll use this to wake\n     /// up schedulers when pushing work onto the work queue.\n     sleeper_list: SleeperList,\n@@ -104,7 +106,7 @@ enum EffortLevel {\n     GiveItYourBest\n }\n \n-static MAX_YIELD_CHECKS: uint = 200;\n+static MAX_YIELD_CHECKS: uint = 20000;\n \n fn reset_yield_check(rng: &mut XorShiftRng) -> uint {\n     let r: uint = Rand::rand(rng);\n@@ -135,9 +137,11 @@ impl Scheduler {\n                        friend: Option<SchedHandle>)\n         -> Scheduler {\n \n+        let (consumer, producer) = mpsc::queue(());\n         let mut sched = Scheduler {\n             sleeper_list: sleeper_list,\n-            message_queue: MessageQueue::new(),\n+            message_queue: consumer,\n+            message_producer: producer,\n             sleepy: false,\n             no_sleep: false,\n             event_loop: event_loop,\n@@ -218,7 +222,7 @@ impl Scheduler {\n \n         // Should not have any messages\n         let message = stask.sched.get_mut_ref().message_queue.pop();\n-        rtassert!(message.is_none());\n+        rtassert!(match message { mpsc::Empty => true, _ => false });\n \n         stask.destroyed = true;\n     }\n@@ -315,10 +319,27 @@ impl Scheduler {\n     fn interpret_message_queue(mut ~self, effort: EffortLevel) -> Option<~Scheduler> {\n \n         let msg = if effort == DontTryTooHard {\n-            // Do a cheap check that may miss messages\n             self.message_queue.casual_pop()\n         } else {\n-            self.message_queue.pop()\n+            // When popping our message queue, we could see an \"inconsistent\"\n+            // state which means that we *should* be able to pop data, but we\n+            // are unable to at this time. Our options are:\n+            //\n+            //  1. Spin waiting for data\n+            //  2. Ignore this and pretend we didn't find a message\n+            //\n+            // If we choose route 1, then if the pusher in question is currently\n+            // pre-empted, we're going to take up our entire time slice just\n+            // spinning on this queue. If we choose route 2, then the pusher in\n+            // question is still guaranteed to make a send() on its async\n+            // handle, so we will guaranteed wake up and see its message at some\n+            // point.\n+            //\n+            // I have chosen to take route #2.\n+            match self.message_queue.pop() {\n+                mpsc::Data(t) => Some(t),\n+                mpsc::Empty | mpsc::Inconsistent => None\n+            }\n         };\n \n         match msg {\n@@ -793,7 +814,7 @@ impl Scheduler {\n \n         return SchedHandle {\n             remote: remote,\n-            queue: self.message_queue.clone(),\n+            queue: self.message_producer.clone(),\n             sched_id: self.sched_id()\n         };\n     }\n@@ -813,7 +834,7 @@ pub enum SchedMessage {\n \n pub struct SchedHandle {\n     priv remote: ~RemoteCallback,\n-    priv queue: MessageQueue<SchedMessage>,\n+    priv queue: mpsc::Producer<SchedMessage, ()>,\n     sched_id: uint\n }\n \n@@ -915,17 +936,17 @@ fn new_sched_rng() -> XorShiftRng {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use rt::test::*;\n-    use unstable::run_in_bare_thread;\n+\n     use borrow::to_uint;\n-    use rt::sched::{Scheduler};\n     use rt::deque::BufferPool;\n-    use rt::thread::Thread;\n-    use rt::task::{Task, Sched};\n     use rt::basic;\n+    use rt::sched::{Scheduler};\n+    use rt::task::{Task, Sched};\n+    use rt::test::*;\n+    use rt::thread::Thread;\n     use rt::util;\n-    use option::{Some};\n-    use rt::task::UnwindResult;\n+    use task::TaskResult;\n+    use unstable::run_in_bare_thread;\n \n     #[test]\n     fn trivial_run_in_newsched_task_test() {\n@@ -1010,8 +1031,8 @@ mod test {\n                 assert!(Task::on_appropriate_sched());\n             };\n \n-            let on_exit: proc(UnwindResult) = proc(exit_status) {\n-                rtassert!(exit_status.is_success())\n+            let on_exit: proc(TaskResult) = proc(exit_status) {\n+                rtassert!(exit_status.is_ok())\n             };\n             task.death.on_exit = Some(on_exit);\n \n@@ -1027,7 +1048,6 @@ mod test {\n         use rt::sleeper_list::SleeperList;\n         use rt::sched::Shutdown;\n         use borrow;\n-        use rt::comm::*;\n \n         do run_in_bare_thread {\n \n@@ -1089,7 +1109,7 @@ mod test {\n             rtdebug!(\"task4 id: **{}**\", borrow::to_uint(task4));\n \n             // Signal from the special task that we are done.\n-            let (port, chan) = oneshot::<()>();\n+            let (port, chan) = Chan::<()>::new();\n \n             let normal_task = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task2*\");\n@@ -1160,10 +1180,8 @@ mod test {\n \n     #[test]\n     fn handle() {\n-        use rt::comm::*;\n-\n         do run_in_bare_thread {\n-            let (port, chan) = oneshot::<()>();\n+            let (port, chan) = Chan::new();\n \n             let thread_one = do Thread::start {\n                 let chan = chan;\n@@ -1230,15 +1248,14 @@ mod test {\n \n     #[test]\n     fn multithreading() {\n-        use rt::comm::*;\n         use num::Times;\n         use vec::OwnedVector;\n         use container::Container;\n \n         do run_in_mt_newsched_task {\n             let mut ports = ~[];\n             10.times(|| {\n-                let (port, chan) = oneshot();\n+                let (port, chan) = Chan::new();\n                 do spawntask_later {\n                     chan.send(());\n                 }\n@@ -1253,21 +1270,17 @@ mod test {\n \n      #[test]\n     fn thread_ring() {\n-        use rt::comm::*;\n-        use comm::{GenericPort, GenericChan};\n-\n         do run_in_mt_newsched_task {\n-            let (end_port, end_chan) = oneshot();\n+            let (end_port, end_chan) = Chan::new();\n \n             let n_tasks = 10;\n             let token = 2000;\n \n-            let (p, ch1) = stream();\n-            let mut p = p;\n+            let (mut p, ch1) = Chan::new();\n             ch1.send((token, end_chan));\n             let mut i = 2;\n             while i <= n_tasks {\n-                let (next_p, ch) = stream();\n+                let (next_p, ch) = Chan::new();\n                 let imm_i = i;\n                 let imm_p = p;\n                 do spawntask_random {\n@@ -1276,23 +1289,23 @@ mod test {\n                 p = next_p;\n                 i += 1;\n             }\n-            let imm_p = p;\n-            let imm_ch = ch1;\n+            let p = p;\n             do spawntask_random {\n-                roundtrip(1, n_tasks, &imm_p, &imm_ch);\n+                roundtrip(1, n_tasks, &p, &ch1);\n             }\n \n             end_port.recv();\n         }\n \n         fn roundtrip(id: int, n_tasks: int,\n-                     p: &Port<(int, ChanOne<()>)>, ch: &Chan<(int, ChanOne<()>)>) {\n+                     p: &Port<(int, Chan<()>)>,\n+                     ch: &Chan<(int, Chan<()>)>) {\n             while (true) {\n                 match p.recv() {\n                     (1, end_chan) => {\n-                                debug!(\"{}\\n\", id);\n-                                end_chan.send(());\n-                                return;\n+                        debug!(\"{}\\n\", id);\n+                        end_chan.send(());\n+                        return;\n                     }\n                     (token, end_chan) => {\n                         debug!(\"thread: {}   got token: {}\", id, token);\n@@ -1331,16 +1344,14 @@ mod test {\n \n     // FIXME: #9407: xfail-test\n     fn dont_starve_1() {\n-        use rt::comm::oneshot;\n-\n         stress_factor().times(|| {\n             do run_in_mt_newsched_task {\n-                let (port, chan) = oneshot();\n+                let (port, chan) = Chan::new();\n \n                 // This task should not be able to starve the sender;\n                 // The sender should get stolen to another thread.\n                 do spawntask {\n-                    while !port.peek() { }\n+                    while port.try_recv().is_none() { }\n                 }\n \n                 chan.send(());\n@@ -1350,17 +1361,15 @@ mod test {\n \n     #[test]\n     fn dont_starve_2() {\n-        use rt::comm::oneshot;\n-\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n-                let (port, chan) = oneshot();\n-                let (_port2, chan2) = stream();\n+                let (port, chan) = Chan::new();\n+                let (_port2, chan2) = Chan::new();\n \n                 // This task should not be able to starve the other task.\n                 // The sends should eventually yield.\n                 do spawntask {\n-                    while !port.peek() {\n+                    while port.try_recv().is_none() {\n                         chan2.send(());\n                     }\n                 }"}, {"sha": "6cde0a1f2169f5f6f47c38040d1dc15570e5f7f4", "filename": "src/libstd/rt/select.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=2c41a823ccb1e7cea0a29f9048533aaa78c40de6", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Module for private, abstraction-leaking select traits. Wrapped in std::select.\n-\n-use rt::kill::BlockedTask;\n-use rt::sched::Scheduler;\n-use option::Option;\n-\n-pub trait SelectInner {\n-    // Returns true if data was available.\n-    fn optimistic_check(&mut self) -> bool;\n-    // Returns true if data was available. If so, shall also wake() the task.\n-    fn block_on(&mut self, &mut Scheduler, BlockedTask) -> bool;\n-    // Returns true if data was available.\n-    fn unblock_from(&mut self) -> bool;\n-}\n-\n-pub trait SelectPortInner<T> {\n-    fn recv_ready(self) -> Option<T>;\n-}\n-"}, {"sha": "f14533d726a789bb909d571fcd5c26289989ca6e", "filename": "src/libstd/rt/spsc_queue.rs", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fspsc_queue.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -0,0 +1,296 @@\n+/* Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *    1. Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *    2. Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY DMITRY VYUKOV \"AS IS\" AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n+ * SHALL DMITRY VYUKOV OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * The views and conclusions contained in the software and documentation are\n+ * those of the authors and should not be interpreted as representing official\n+ * policies, either expressed or implied, of Dmitry Vyukov.\n+ */\n+\n+// http://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n+use cast;\n+use kinds::Send;\n+use ops::Drop;\n+use option::{Some, None, Option};\n+use unstable::atomics::{AtomicPtr, Relaxed, AtomicUint, Acquire, Release};\n+use unstable::sync::UnsafeArc;\n+\n+// Node within the linked list queue of messages to send\n+struct Node<T> {\n+    // XXX: this could be an uninitialized T if we're careful enough, and\n+    //      that would reduce memory usage (and be a bit faster).\n+    //      is it worth it?\n+    value: Option<T>,           // nullable for re-use of nodes\n+    next: AtomicPtr<Node<T>>,   // next node in the queue\n+}\n+\n+// The producer/consumer halves both need access to the `tail` field, and if\n+// they both have access to that we may as well just give them both access\n+// to this whole structure.\n+struct State<T, P> {\n+    // consumer fields\n+    tail: *mut Node<T>, // where to pop from\n+    tail_prev: AtomicPtr<Node<T>>, // where to pop from\n+\n+    // producer fields\n+    head: *mut Node<T>,      // where to push to\n+    first: *mut Node<T>,     // where to get new nodes from\n+    tail_copy: *mut Node<T>, // between first/tail\n+\n+    // Cache maintenance fields. Additions and subtractions are stored\n+    // separately in order to allow them to use nonatomic addition/subtraction.\n+    cache_bound: uint,\n+    cache_additions: AtomicUint,\n+    cache_subtractions: AtomicUint,\n+\n+    packet: P,\n+}\n+\n+pub struct Producer<T, P> {\n+    priv state: UnsafeArc<State<T, P>>,\n+}\n+\n+pub struct Consumer<T, P> {\n+    priv state: UnsafeArc<State<T, P>>,\n+}\n+\n+pub fn queue<T: Send, P: Send>(bound: uint,\n+                               p: P) -> (Consumer<T, P>, Producer<T, P>)\n+{\n+    let n1 = Node::new();\n+    let n2 = Node::new();\n+    unsafe { (*n1).next.store(n2, Relaxed) }\n+    let state = State {\n+        tail: n2,\n+        tail_prev: AtomicPtr::new(n1),\n+        head: n2,\n+        first: n1,\n+        tail_copy: n1,\n+        cache_bound: bound,\n+        cache_additions: AtomicUint::new(0),\n+        cache_subtractions: AtomicUint::new(0),\n+        packet: p,\n+    };\n+    let (arc1, arc2) = UnsafeArc::new2(state);\n+    (Consumer { state: arc1 }, Producer { state: arc2 })\n+}\n+\n+impl<T: Send> Node<T> {\n+    fn new() -> *mut Node<T> {\n+        unsafe {\n+            cast::transmute(~Node {\n+                value: None,\n+                next: AtomicPtr::new(0 as *mut Node<T>),\n+            })\n+        }\n+    }\n+}\n+\n+impl<T: Send, P: Send> Producer<T, P> {\n+    pub fn push(&mut self, t: T) {\n+        unsafe { (*self.state.get()).push(t) }\n+    }\n+    pub fn is_empty(&self) -> bool {\n+        unsafe { (*self.state.get()).is_empty() }\n+    }\n+    pub unsafe fn packet(&self) -> *mut P {\n+        &mut (*self.state.get()).packet as *mut P\n+    }\n+}\n+\n+impl<T: Send, P: Send> Consumer<T, P> {\n+    pub fn pop(&mut self) -> Option<T> {\n+        unsafe { (*self.state.get()).pop() }\n+    }\n+    pub unsafe fn packet(&self) -> *mut P {\n+        &mut (*self.state.get()).packet as *mut P\n+    }\n+}\n+\n+impl<T: Send, P: Send> State<T, P> {\n+    // remember that there is only one thread executing `push` (and only one\n+    // thread executing `pop`)\n+    unsafe fn push(&mut self, t: T) {\n+        // Acquire a node (which either uses a cached one or allocates a new\n+        // one), and then append this to the 'head' node.\n+        let n = self.alloc();\n+        assert!((*n).value.is_none());\n+        (*n).value = Some(t);\n+        (*n).next.store(0 as *mut Node<T>, Relaxed);\n+        (*self.head).next.store(n, Release);\n+        self.head = n;\n+    }\n+\n+    unsafe fn alloc(&mut self) -> *mut Node<T> {\n+        // First try to see if we can consume the 'first' node for our uses.\n+        // We try to avoid as many atomic instructions as possible here, so\n+        // the addition to cache_subtractions is not atomic (plus we're the\n+        // only one subtracting from the cache).\n+        if self.first != self.tail_copy {\n+            if self.cache_bound > 0 {\n+                let b = self.cache_subtractions.load(Relaxed);\n+                self.cache_subtractions.store(b + 1, Relaxed);\n+            }\n+            let ret = self.first;\n+            self.first = (*ret).next.load(Relaxed);\n+            return ret;\n+        }\n+        // If the above fails, then update our copy of the tail and try\n+        // again.\n+        self.tail_copy = self.tail_prev.load(Acquire);\n+        if self.first != self.tail_copy {\n+            if self.cache_bound > 0 {\n+                let b = self.cache_subtractions.load(Relaxed);\n+                self.cache_subtractions.store(b + 1, Relaxed);\n+            }\n+            let ret = self.first;\n+            self.first = (*ret).next.load(Relaxed);\n+            return ret;\n+        }\n+        // If all of that fails, then we have to allocate a new node\n+        // (there's nothing in the node cache).\n+        Node::new()\n+    }\n+\n+    // remember that there is only one thread executing `pop` (and only one\n+    // thread executing `push`)\n+    unsafe fn pop(&mut self) -> Option<T> {\n+        // The `tail` node is not actually a used node, but rather a\n+        // sentinel from where we should start popping from. Hence, look at\n+        // tail's next field and see if we can use it. If we do a pop, then\n+        // the current tail node is a candidate for going into the cache.\n+        let tail = self.tail;\n+        let next = (*tail).next.load(Acquire);\n+        if next.is_null() { return None }\n+        assert!((*next).value.is_some());\n+        let ret = (*next).value.take();\n+\n+        self.tail = next;\n+        if self.cache_bound == 0 {\n+            self.tail_prev.store(tail, Release);\n+        } else {\n+            // XXX: this is dubious with overflow.\n+            let additions = self.cache_additions.load(Relaxed);\n+            let subtractions = self.cache_subtractions.load(Relaxed);\n+            let size = additions - subtractions;\n+\n+            if size < self.cache_bound {\n+                self.tail_prev.store(tail, Release);\n+                self.cache_additions.store(additions + 1, Relaxed);\n+            } else {\n+                (*self.tail_prev.load(Relaxed)).next.store(next, Relaxed);\n+                // We have successfully erased all references to 'tail', so\n+                // now we can safely drop it.\n+                let _: ~Node<T> = cast::transmute(tail);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    unsafe fn is_empty(&self) -> bool {\n+        let tail = self.tail;\n+        let next = (*tail).next.load(Acquire);\n+        return next.is_null();\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send, P: Send> Drop for State<T, P> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let mut cur = self.first;\n+            while !cur.is_null() {\n+                let next = (*cur).next.load(Relaxed);\n+                let _n: ~Node<T> = cast::transmute(cur);\n+                cur = next;\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::queue;\n+    use task;\n+\n+    #[test]\n+    fn smoke() {\n+        let (mut c, mut p) = queue(0, ());\n+        p.push(1);\n+        p.push(2);\n+        assert_eq!(c.pop(), Some(1));\n+        assert_eq!(c.pop(), Some(2));\n+        assert_eq!(c.pop(), None);\n+        p.push(3);\n+        p.push(4);\n+        assert_eq!(c.pop(), Some(3));\n+        assert_eq!(c.pop(), Some(4));\n+        assert_eq!(c.pop(), None);\n+    }\n+\n+    #[test]\n+    fn drop_full() {\n+        let (_, mut p) = queue(0, ());\n+        p.push(~1);\n+        p.push(~2);\n+    }\n+\n+    #[test]\n+    fn smoke_bound() {\n+        let (mut c, mut p) = queue(1, ());\n+        p.push(1);\n+        p.push(2);\n+        assert_eq!(c.pop(), Some(1));\n+        assert_eq!(c.pop(), Some(2));\n+        assert_eq!(c.pop(), None);\n+        p.push(3);\n+        p.push(4);\n+        assert_eq!(c.pop(), Some(3));\n+        assert_eq!(c.pop(), Some(4));\n+        assert_eq!(c.pop(), None);\n+    }\n+\n+    #[test]\n+    fn stress() {\n+        stress_bound(0);\n+        stress_bound(1);\n+\n+        fn stress_bound(bound: uint) {\n+            let (c, mut p) = queue(bound, ());\n+            do task::spawn_sched(task::SingleThreaded) {\n+                let mut c = c;\n+                for _ in range(0, 100000) {\n+                    loop {\n+                        match c.pop() {\n+                            Some(1) => break,\n+                            Some(_) => fail!(),\n+                            None => {}\n+                        }\n+                    }\n+                }\n+            }\n+            for _ in range(0, 100000) {\n+                p.push(1);\n+            }\n+        }\n+    }\n+}"}, {"sha": "62e012f9f41204ffe402dd086ce28cd2c99708c5", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 10, "deletions": 53, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -20,21 +20,22 @@ use prelude::*;\n use borrow;\n use cast::transmute;\n use cleanup;\n+use io::Writer;\n use libc::{c_void, uintptr_t, c_char, size_t};\n use local_data;\n use option::{Option, Some, None};\n use rt::borrowck::BorrowRecord;\n use rt::borrowck;\n-use rt::context::Context;\n use rt::context;\n+use rt::context::Context;\n use rt::env;\n-use io::Writer;\n use rt::kill::Death;\n use rt::local::Local;\n use rt::logging::StdErrLogger;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n use send_str::SendStr;\n+use task::TaskResult;\n use unstable::finally::Finally;\n use unstable::mutex::Mutex;\n \n@@ -91,46 +92,17 @@ pub enum SchedHome {\n pub struct GarbageCollector;\n pub struct LocalStorage(Option<local_data::Map>);\n \n-/// Represents the reason for the current unwinding process\n-pub enum UnwindResult {\n-    /// The task is ending successfully\n-    Success,\n-\n-    /// The Task is failing with reason `~Any`\n-    Failure(~Any),\n-}\n-\n-impl UnwindResult {\n-    /// Returns `true` if this `UnwindResult` is a failure\n-    #[inline]\n-    pub fn is_failure(&self) -> bool {\n-        match *self {\n-            Success => false,\n-            Failure(_) => true\n-        }\n-    }\n-\n-    /// Returns `true` if this `UnwindResult` is a success\n-    #[inline]\n-    pub fn is_success(&self) -> bool {\n-        match *self {\n-            Success => true,\n-            Failure(_) => false\n-        }\n-    }\n-}\n-\n pub struct Unwinder {\n     unwinding: bool,\n     cause: Option<~Any>\n }\n \n impl Unwinder {\n-    fn to_unwind_result(&mut self) -> UnwindResult {\n+    fn result(&mut self) -> TaskResult {\n         if self.unwinding {\n-            Failure(self.cause.take().unwrap())\n+            Err(self.cause.take().unwrap())\n         } else {\n-            Success\n+            Ok(())\n         }\n     }\n }\n@@ -327,7 +299,7 @@ impl Task {\n         // Cleanup the dynamic borrowck debugging info\n         borrowck::clear_task_borrow_list();\n \n-        self.death.collect_failure(self.unwinder.to_unwind_result());\n+        self.death.collect_failure(self.unwinder.result());\n         self.destroyed = true;\n     }\n \n@@ -692,6 +664,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n mod test {\n     use super::*;\n     use rt::test::*;\n+    use prelude::*;\n \n     #[test]\n     fn local_heap() {\n@@ -744,35 +717,19 @@ mod test {\n         }\n     }\n \n-    #[test]\n-    fn comm_oneshot() {\n-        use comm::*;\n-\n-        do run_in_newsched_task {\n-            let (port, chan) = oneshot();\n-            chan.send(10);\n-            assert!(port.recv() == 10);\n-        }\n-    }\n-\n     #[test]\n     fn comm_stream() {\n-        use comm::*;\n-\n         do run_in_newsched_task() {\n-            let (port, chan) = stream();\n+            let (port, chan) = Chan::new();\n             chan.send(10);\n             assert!(port.recv() == 10);\n         }\n     }\n \n     #[test]\n     fn comm_shared_chan() {\n-        use comm::*;\n-\n         do run_in_newsched_task() {\n-            let (port, chan) = stream();\n-            let chan = SharedChan::new(chan);\n+            let (port, chan) = SharedChan::new();\n             chan.send(10);\n             assert!(port.recv() == 10);\n         }"}, {"sha": "2b48b396c99e9fe5439bc1169b27e0db1b6c10be", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -21,14 +21,14 @@ use rand::Rng;\n use rand;\n use result::{Result, Ok, Err};\n use rt::basic;\n-use rt::comm::oneshot;\n use rt::deque::BufferPool;\n+use comm::Chan;\n use rt::new_event_loop;\n use rt::sched::Scheduler;\n use rt::sleeper_list::SleeperList;\n use rt::task::Task;\n-use rt::task::UnwindResult;\n use rt::thread::Thread;\n+use task::TaskResult;\n use unstable::{run_in_bare_thread};\n use vec;\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n@@ -82,10 +82,10 @@ pub fn run_in_uv_task_core(f: proc()) {\n     let mut sched = ~new_test_uv_sched();\n     let exit_handle = sched.make_handle();\n \n-    let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n+    let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n         let mut exit_handle = exit_handle;\n         exit_handle.send(Shutdown);\n-        rtassert!(exit_status.is_success());\n+        rtassert!(exit_status.is_ok());\n     };\n     let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n     task.death.on_exit = Some(on_exit);\n@@ -99,10 +99,10 @@ pub fn run_in_newsched_task_core(f: proc()) {\n     let mut sched = ~new_test_sched();\n     let exit_handle = sched.make_handle();\n \n-    let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n+    let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n         let mut exit_handle = exit_handle;\n         exit_handle.send(Shutdown);\n-        rtassert!(exit_status.is_success());\n+        rtassert!(exit_status.is_ok());\n     };\n     let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n     task.death.on_exit = Some(on_exit);\n@@ -240,14 +240,14 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n         }\n \n         let handles = handles;  // Work around not being able to capture mut\n-        let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n+        let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n             // Tell schedulers to exit\n             let mut handles = handles;\n             for handle in handles.mut_iter() {\n                 handle.send(Shutdown);\n             }\n \n-            rtassert!(exit_status.is_success());\n+            rtassert!(exit_status.is_ok());\n         };\n         let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n                                             None,\n@@ -311,8 +311,8 @@ pub fn spawntask_random(f: proc()) {\n \n pub fn spawntask_try(f: proc()) -> Result<(),()> {\n \n-    let (port, chan) = oneshot();\n-    let on_exit: proc(UnwindResult) = proc(exit_status) {\n+    let (port, chan) = Chan::new();\n+    let on_exit: proc(TaskResult) = proc(exit_status) {\n         chan.send(exit_status)\n     };\n \n@@ -322,7 +322,7 @@ pub fn spawntask_try(f: proc()) -> Result<(),()> {\n     Scheduler::run_task(new_task);\n \n     let exit_status = port.recv();\n-    if exit_status.is_success() { Ok(()) } else { Err(()) }\n+    if exit_status.is_ok() { Ok(()) } else { Err(()) }\n \n }\n "}, {"sha": "6128f310a2ebf27b51ddbf9bed20575fe26914a4", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 113, "deletions": 78, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -21,42 +21,32 @@ use kinds::Send;\n use libc;\n use ops::Drop;\n use option::{Option, Some, None};\n-use ptr;\n use uint;\n \n-#[cfg(windows)]\n-use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T,\n-                                   LPVOID, DWORD, LPDWORD, HANDLE};\n-\n-#[cfg(windows)] type rust_thread = HANDLE;\n-#[cfg(unix)] type rust_thread = libc::pthread_t;\n-#[cfg(windows)] type rust_thread_return = DWORD;\n-#[cfg(unix)] type rust_thread_return = *libc::c_void;\n-\n-type StartFn = extern \"C\" fn(*libc::c_void) -> rust_thread_return;\n+type StartFn = extern \"C\" fn(*libc::c_void) -> imp::rust_thread_return;\n \n /// This struct represents a native thread's state. This is used to join on an\n /// existing thread created in the join-able state.\n pub struct Thread<T> {\n-    priv native: rust_thread,\n+    priv native: imp::rust_thread,\n     priv joined: bool,\n     priv packet: ~Option<T>,\n }\n \n-static DEFAULT_STACK_SIZE: libc::size_t = 1024*1024;\n+static DEFAULT_STACK_SIZE: libc::size_t = 1024 * 1024;\n \n // This is the starting point of rust os threads. The first thing we do\n // is make sure that we don't trigger __morestack (also why this has a\n // no_split_stack annotation), and then we extract the main function\n // and invoke it.\n #[no_split_stack]\n-extern fn thread_start(main: *libc::c_void) -> rust_thread_return {\n+extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n     use rt::context;\n     unsafe {\n         context::record_stack_bounds(0, uint::max_value);\n         let f: ~proc() = cast::transmute(main);\n         (*f)();\n-        cast::transmute(0 as rust_thread_return)\n+        cast::transmute(0 as imp::rust_thread_return)\n     }\n }\n \n@@ -88,7 +78,7 @@ impl Thread<()> {\n             *cast::transmute::<&~Option<T>, **mut Option<T>>(&packet)\n         };\n         let main: proc() = proc() unsafe { *packet2 = Some(main()); };\n-        let native = unsafe { native_thread_create(~main) };\n+        let native = unsafe { imp::create(~main) };\n \n         Thread {\n             native: native,\n@@ -105,18 +95,24 @@ impl Thread<()> {\n     /// there are detached thread still running around.\n     pub fn spawn(main: proc()) {\n         unsafe {\n-            let handle = native_thread_create(~main);\n-            native_thread_detach(handle);\n+            let handle = imp::create(~main);\n+            imp::detach(handle);\n         }\n     }\n+\n+    /// Relinquishes the CPU slot that this OS-thread is currently using,\n+    /// allowing another thread to run for awhile.\n+    pub fn yield_now() {\n+        unsafe { imp::yield_now(); }\n+    }\n }\n \n impl<T: Send> Thread<T> {\n     /// Wait for this thread to finish, returning the result of the thread's\n     /// calculation.\n     pub fn join(mut self) -> T {\n         assert!(!self.joined);\n-        unsafe { native_thread_join(self.native) };\n+        unsafe { imp::join(self.native) };\n         self.joined = true;\n         assert!(self.packet.is_some());\n         self.packet.take_unwrap()\n@@ -129,80 +125,119 @@ impl<T: Send> Drop for Thread<T> {\n         // This is required for correctness. If this is not done then the thread\n         // would fill in a return box which no longer exists.\n         if !self.joined {\n-            unsafe { native_thread_join(self.native) };\n+            unsafe { imp::join(self.native) };\n         }\n     }\n }\n \n #[cfg(windows)]\n-unsafe fn native_thread_create(p: ~proc()) -> rust_thread {\n-    let arg: *mut libc::c_void = cast::transmute(p);\n-    CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start,\n-                 arg, 0, ptr::mut_null())\n-}\n-\n-#[cfg(windows)]\n-unsafe fn native_thread_join(native: rust_thread) {\n-    use libc::consts::os::extra::INFINITE;\n-    WaitForSingleObject(native, INFINITE);\n-}\n+mod imp {\n+    use super::DEFAULT_STACK_SIZE;\n+\n+    use cast;\n+    use libc;\n+    use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n+                                       LPVOID, DWORD, LPDWORD, HANDLE};\n+    use ptr;\n+\n+    pub type rust_thread = HANDLE;\n+    pub type rust_thread_return = DWORD;\n+\n+    pub unsafe fn create(p: ~proc()) -> rust_thread {\n+        let arg: *mut libc::c_void = cast::transmute(p);\n+        CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, super::thread_start,\n+                     arg, 0, ptr::mut_null())\n+    }\n \n-#[cfg(windows)]\n-unsafe fn native_thread_detach(native: rust_thread) {\n-    assert!(libc::CloseHandle(native) != 0);\n-}\n+    pub unsafe fn join(native: rust_thread) {\n+        use libc::consts::os::extra::INFINITE;\n+        WaitForSingleObject(native, INFINITE);\n+    }\n \n-#[cfg(unix)]\n-unsafe fn native_thread_create(p: ~proc()) -> rust_thread {\n-    use unstable::intrinsics;\n-    use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n+    pub unsafe fn detach(native: rust_thread) {\n+        assert!(libc::CloseHandle(native) != 0);\n+    }\n \n-    let mut native: libc::pthread_t = intrinsics::uninit();\n-    let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n-    assert_eq!(pthread_attr_init(&mut attr), 0);\n-    assert_eq!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE), 0);\n-    assert_eq!(pthread_attr_setdetachstate(&mut attr, PTHREAD_CREATE_JOINABLE), 0);\n+    pub unsafe fn yield_now() {\n+        // This function will return 0 if there are no other threads to execute,\n+        // but this also means that the yield was useless so this isn't really a\n+        // case that needs to be worried about.\n+        SwitchToThread();\n+    }\n \n-    let arg: *libc::c_void = cast::transmute(p);\n-    assert_eq!(pthread_create(&mut native, &attr, thread_start, arg), 0);\n-    native\n+    extern \"system\" {\n+        fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                        dwStackSize: SIZE_T,\n+                        lpStartAddress: super::StartFn,\n+                        lpParameter: LPVOID,\n+                        dwCreationFlags: DWORD,\n+                        lpThreadId: LPDWORD) -> HANDLE;\n+        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n+        fn SwitchToThread() -> BOOL;\n+    }\n }\n \n #[cfg(unix)]\n-unsafe fn native_thread_join(native: rust_thread) {\n-    assert_eq!(pthread_join(native, ptr::null()), 0);\n-}\n+mod imp {\n+    use cast;\n+    use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n+    use libc;\n+    use ptr;\n+    use super::DEFAULT_STACK_SIZE;\n+    use unstable::intrinsics;\n \n-#[cfg(unix)]\n-fn native_thread_detach(native: rust_thread) {\n-    unsafe { assert_eq!(pthread_detach(native), 0) }\n-}\n+    pub type rust_thread = libc::pthread_t;\n+    pub type rust_thread_return = *libc::c_void;\n+\n+    pub unsafe fn create(p: ~proc()) -> rust_thread {\n+        let mut native: libc::pthread_t = intrinsics::uninit();\n+        let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n+        assert_eq!(pthread_attr_init(&mut attr), 0);\n+        assert_eq!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE), 0);\n+        assert_eq!(pthread_attr_setdetachstate(&mut attr,\n+                                               PTHREAD_CREATE_JOINABLE), 0);\n+\n+        let arg: *libc::c_void = cast::transmute(p);\n+        assert_eq!(pthread_create(&mut native, &attr,\n+                                  super::thread_start, arg), 0);\n+        native\n+    }\n \n-#[cfg(windows)]\n-extern \"system\" {\n-    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n-                    dwStackSize: SIZE_T,\n-                    lpStartAddress: StartFn,\n-                    lpParameter: LPVOID,\n-                    dwCreationFlags: DWORD,\n-                    lpThreadId: LPDWORD) -> HANDLE;\n-    fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-}\n+    pub unsafe fn join(native: rust_thread) {\n+        assert_eq!(pthread_join(native, ptr::null()), 0);\n+    }\n \n-#[cfg(unix)]\n-extern {\n-    fn pthread_create(native: *mut libc::pthread_t,\n-                      attr: *libc::pthread_attr_t,\n-                      f: StartFn,\n-                      value: *libc::c_void) -> libc::c_int;\n-    fn pthread_join(native: libc::pthread_t,\n-                    value: **libc::c_void) -> libc::c_int;\n-    fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n-    fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n-                                 stack_size: libc::size_t) -> libc::c_int;\n-    fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n-                                   state: libc::c_int) -> libc::c_int;\n-    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n+    pub unsafe fn detach(native: rust_thread) {\n+        assert_eq!(pthread_detach(native), 0);\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"android\")]\n+    pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n+\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"android\"))]\n+    pub unsafe fn yield_now() { assert_eq!(pthread_yield(), 0); }\n+\n+    extern {\n+        fn pthread_create(native: *mut libc::pthread_t,\n+                          attr: *libc::pthread_attr_t,\n+                          f: super::StartFn,\n+                          value: *libc::c_void) -> libc::c_int;\n+        fn pthread_join(native: libc::pthread_t,\n+                        value: **libc::c_void) -> libc::c_int;\n+        fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n+        fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n+                                     stack_size: libc::size_t) -> libc::c_int;\n+        fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n+                                       state: libc::c_int) -> libc::c_int;\n+        fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n+\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"android\")]\n+        fn sched_yield() -> libc::c_int;\n+        #[cfg(not(target_os = \"macos\"), not(target_os = \"android\"))]\n+        fn pthread_yield() -> libc::c_int;\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "70ad752ea935b4f52057cc68f2d941e46b2ebd78", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,7 +12,7 @@\n \n #[allow(missing_doc)];\n \n-use comm::{stream, SharedChan};\n+use comm::SharedChan;\n use io::Reader;\n use io::process::ProcessExit;\n use io::process;\n@@ -220,8 +220,7 @@ impl Process {\n         // in parallel so we don't deadlock while blocking on one\n         // or the other. FIXME (#2625): Surely there's a much more\n         // clever way to do this.\n-        let (p, ch) = stream();\n-        let ch = SharedChan::new(ch);\n+        let (p, ch) = SharedChan::new();\n         let ch_clone = ch.clone();\n \n         do spawn {"}, {"sha": "cca64244db569f814ba9b95218047e251ee6947d", "filename": "src/libstd/select.rs", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c41a823ccb1e7cea0a29f9048533aaa78c40de6/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=2c41a823ccb1e7cea0a29f9048533aaa78c40de6", "patch": "@@ -1,306 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use comm;\n-use container::Container;\n-use iter::{Iterator, DoubleEndedIterator};\n-use kinds::Send;\n-use ops::Drop;\n-use option::*;\n-use rt::local::Local;\n-use rt::rtio::EventLoop;\n-use rt::sched::Scheduler;\n-use rt::shouldnt_be_public::{SelectInner, SelectPortInner};\n-use vec::{OwnedVector, MutableVector};\n-\n-/// Trait for message-passing primitives that can be select()ed on.\n-pub trait Select : SelectInner { }\n-\n-/// Trait for message-passing primitives that can use the select2() convenience wrapper.\n-// (This is separate from the above trait to enable heterogeneous lists of ports\n-// that implement Select on different types to use select().)\n-pub trait SelectPort<T> : SelectPortInner<T> { }\n-\n-/// A helper type that throws away a value on a port.\n-struct PortGuard<T> {\n-    port: Option<comm::PortOne<T>>,\n-}\n-\n-#[unsafe_destructor]\n-impl<T:Send> Drop for PortGuard<T> {\n-    fn drop(&mut self) {\n-        let _ = self.port.take_unwrap().recv();\n-    }\n-}\n-\n-/// Receive a message from any one of many ports at once. Returns the index of the\n-/// port whose data is ready. (If multiple are ready, returns the lowest index.)\n-pub fn select<A: Select>(ports: &mut [A]) -> uint {\n-    if ports.is_empty() {\n-        fail!(\"can't select on an empty list\");\n-    }\n-\n-    for (index, port) in ports.mut_iter().enumerate() {\n-        if port.optimistic_check() {\n-            return index;\n-        }\n-    }\n-\n-    // If one of the ports already contains data when we go to block on it, we\n-    // don't bother enqueueing on the rest of them, so we shouldn't bother\n-    // unblocking from it either. This is just for efficiency, not correctness.\n-    // (If not, we need to unblock from all of them. Length is a placeholder.)\n-    let mut ready_index = ports.len();\n-\n-    // XXX: We're using deschedule...and_then in an unsafe way here (see #8132),\n-    // in that we need to continue mutating the ready_index in the environment\n-    // after letting the task get woken up. The and_then closure needs to delay\n-    // the task from resuming until all ports have become blocked_on.\n-    let (p,c) = comm::oneshot();\n-\n-    {\n-        let _guard = PortGuard {\n-            port: Some(p),\n-        };\n-\n-        let mut c = Some(c);\n-        let sched: ~Scheduler = Local::take();\n-        sched.deschedule_running_task_and_then(|sched, task| {\n-            let task_handles = task.make_selectable(ports.len());\n-\n-            for (index, (port, task_handle)) in\n-                    ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n-                // If one of the ports has data by now, it will wake the handle.\n-                if port.block_on(sched, task_handle) {\n-                    ready_index = index;\n-                    break;\n-                }\n-            }\n-\n-            let c = c.take_unwrap();\n-            do sched.event_loop.callback {\n-                c.send_deferred(())\n-            }\n-        })\n-    }\n-\n-    // Task resumes. Now unblock ourselves from all the ports we blocked on.\n-    // If the success index wasn't reset, 'take' will just take all of them.\n-    // Iterate in reverse so the 'earliest' index that's ready gets returned.\n-    for (index, port) in ports.mut_slice(0, ready_index).mut_iter().enumerate().invert() {\n-        if port.unblock_from() {\n-            ready_index = index;\n-        }\n-    }\n-\n-    assert!(ready_index < ports.len());\n-    return ready_index;\n-}\n-\n-/* FIXME(#5121, #7914) This all should be legal, but rust is not clever enough yet.\n-\n-impl <'a> Select for &'a mut Select {\n-    fn optimistic_check(&mut self) -> bool { self.optimistic_check() }\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        self.block_on(sched, task)\n-    }\n-    fn unblock_from(&mut self) -> bool { self.unblock_from() }\n-}\n-\n-pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n-        -> Either<(Option<TA>, B), (A, Option<TB>)> {\n-    let result = {\n-        let mut ports = [&mut a as &mut Select, &mut b as &mut Select];\n-        select(ports)\n-    };\n-    match result {\n-        0 => Left ((a.recv_ready(), b)),\n-        1 => Right((a, b.recv_ready())),\n-        x => fail!(\"impossible case in select2: {:?}\", x)\n-    }\n-}\n-\n-*/\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use clone::Clone;\n-    use num::Times;\n-    use option::*;\n-    use rt::comm::*;\n-    use rt::test::*;\n-    use vec::*;\n-    use comm::GenericChan;\n-    use task;\n-    use iter::{Iterator, range};\n-\n-    #[test] #[should_fail]\n-    fn select_doesnt_get_trolled() {\n-        select::<PortOne<()>>([]);\n-    }\n-\n-    /* non-blocking select tests */\n-\n-    #[cfg(test)]\n-    fn select_helper(num_ports: uint, send_on_chans: &[uint]) {\n-        // Unfortunately this does not actually test the block_on early-break\n-        // codepath in select -- racing between the sender and the receiver in\n-        // separate tasks is necessary to get around the optimistic check.\n-        let (ports, chans) = unzip(range(0, num_ports).map(|_| oneshot::<()>()));\n-        let mut dead_chans = ~[];\n-        let mut ports = ports;\n-        for (i, chan) in chans.move_iter().enumerate() {\n-            if send_on_chans.contains(&i) {\n-                chan.send(());\n-            } else {\n-                dead_chans.push(chan);\n-            }\n-        }\n-        let ready_index = select(ports);\n-        assert!(send_on_chans.contains(&ready_index));\n-        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n-        let _ = dead_chans;\n-\n-        // Same thing with streams instead.\n-        // FIXME(#7971): This should be in a macro but borrowck isn't smart enough.\n-        let (ports, chans) = unzip(range(0, num_ports).map(|_| stream::<()>()));\n-        let mut dead_chans = ~[];\n-        let mut ports = ports;\n-        for (i, chan) in chans.move_iter().enumerate() {\n-            if send_on_chans.contains(&i) {\n-                chan.send(());\n-            } else {\n-                dead_chans.push(chan);\n-            }\n-        }\n-        let ready_index = select(ports);\n-        assert!(send_on_chans.contains(&ready_index));\n-        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n-        let _ = dead_chans;\n-    }\n-\n-    #[test]\n-    fn select_one() {\n-        do run_in_uv_task { select_helper(1, [0]) }\n-    }\n-\n-    #[test]\n-    fn select_two() {\n-        // NB. I would like to have a test that tests the first one that is\n-        // ready is the one that's returned, but that can't be reliably tested\n-        // with the randomized behaviour of optimistic_check.\n-        do run_in_uv_task { select_helper(2, [1]) }\n-        do run_in_uv_task { select_helper(2, [0]) }\n-        do run_in_uv_task { select_helper(2, [1,0]) }\n-    }\n-\n-    #[test]\n-    fn select_a_lot() {\n-        do run_in_uv_task { select_helper(12, [7,8,9]) }\n-    }\n-\n-    #[test]\n-    fn select_stream() {\n-        use util;\n-        use comm::GenericChan;\n-\n-        // Sends 10 buffered packets, and uses select to retrieve them all.\n-        // Puts the port in a different spot in the vector each time.\n-        do run_in_uv_task {\n-            let (ports, _) = unzip(range(0u, 10).map(|_| stream::<int>()));\n-            let (port, chan) = stream();\n-            10.times(|| { chan.send(31337); });\n-            let mut ports = ports;\n-            let mut port = Some(port);\n-            let order = [5u,0,4,3,2,6,9,8,7,1];\n-            for &index in order.iter() {\n-                // put the port in the vector at any index\n-                util::swap(port.get_mut_ref(), &mut ports[index]);\n-                assert!(select(ports) == index);\n-                // get it back out\n-                util::swap(port.get_mut_ref(), &mut ports[index]);\n-                // NB. Not recv(), because optimistic_check randomly fails.\n-                assert!(port.get_ref().recv_ready().unwrap() == 31337);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn select_simple() {\n-        do run_in_uv_task {\n-            select_helper(2, [1])\n-        }\n-    }\n-\n-    /* blocking select tests */\n-\n-    #[test]\n-    fn select_blocking() {\n-        do run_in_uv_task {\n-            let (p1,_c) = oneshot();\n-            let (p2,c2) = oneshot();\n-            let mut ports = [p1,p2];\n-\n-            let (p3,c3) = oneshot();\n-            let (p4,c4) = oneshot();\n-\n-            do task::spawn {\n-                p3.recv();   // handshake parent\n-                c4.send(()); // normal receive\n-                task::deschedule();\n-                c2.send(()); // select receive\n-            }\n-\n-            // Try to block before child sends on c2.\n-            c3.send(());\n-            p4.recv();\n-            assert!(select(ports) == 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn select_racing_senders() {\n-        static NUM_CHANS: uint = 10;\n-\n-        select_racing_senders_helper(~[0,1,2,3,4,5,6,7,8,9]);\n-        select_racing_senders_helper(~[0,1,2]);\n-        select_racing_senders_helper(~[3,4,5,6]);\n-        select_racing_senders_helper(~[7,8,9]);\n-\n-        fn select_racing_senders_helper(send_on_chans: ~[uint]) {\n-            use rt::test::spawntask_random;\n-\n-            do run_in_uv_task {\n-                // A bit of stress, since ordinarily this is just smoke and mirrors.\n-                4.times(|| {\n-                    let send_on_chans = send_on_chans.clone();\n-                    do task::spawn {\n-                        let mut ports = ~[];\n-                        for i in range(0u, NUM_CHANS) {\n-                            let (p,c) = oneshot();\n-                            ports.push(p);\n-                            if send_on_chans.contains(&i) {\n-                                do spawntask_random {\n-                                    task::deschedule();\n-                                    c.send(());\n-                                }\n-                            }\n-                        }\n-                        // nondeterministic result, but should succeed\n-                        select(ports);\n-                    }\n-                })\n-            }\n-        }\n-    }\n-}"}, {"sha": "0e56f42f5b9c013650e2c2cc2390556c61467ff6", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 21, "deletions": 51, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -55,11 +55,10 @@\n \n use prelude::*;\n \n-use comm::{stream, Chan, GenericChan, GenericPort, Port, Peekable};\n+use comm::{Chan, Port};\n use result::{Result, Ok, Err};\n use rt::in_green_task_context;\n use rt::local::Local;\n-use rt::task::{UnwindResult, Success, Failure};\n use send_str::{SendStr, IntoSendStr};\n use util;\n \n@@ -81,33 +80,6 @@ pub mod spawn;\n /// children tasks complete, recommend using a result future.\n pub type TaskResult = Result<(), ~Any>;\n \n-pub struct TaskResultPort {\n-    priv port: Port<UnwindResult>\n-}\n-\n-fn to_task_result(res: UnwindResult) -> TaskResult {\n-    match res {\n-        Success => Ok(()), Failure(a) => Err(a),\n-    }\n-}\n-\n-impl GenericPort<TaskResult> for TaskResultPort {\n-    #[inline]\n-    fn recv(&self) -> TaskResult {\n-        to_task_result(self.port.recv())\n-    }\n-\n-    #[inline]\n-    fn try_recv(&self) -> Option<TaskResult> {\n-        self.port.try_recv().map(to_task_result)\n-    }\n-}\n-\n-impl Peekable<TaskResult> for TaskResultPort {\n-    #[inline]\n-    fn peek(&self) -> bool { self.port.peek() }\n-}\n-\n /// Scheduler modes\n #[deriving(Eq)]\n pub enum SchedMode {\n@@ -150,7 +122,7 @@ pub struct SchedOpts {\n  */\n pub struct TaskOpts {\n     priv watched: bool,\n-    priv notify_chan: Option<Chan<UnwindResult>>,\n+    priv notify_chan: Option<Chan<TaskResult>>,\n     name: Option<SendStr>,\n     sched: SchedOpts,\n     stack_size: Option<uint>\n@@ -232,7 +204,7 @@ impl TaskBuilder {\n     ///\n     /// # Failure\n     /// Fails if a future_result was already set for this task.\n-    pub fn future_result(&mut self) -> TaskResultPort {\n+    pub fn future_result(&mut self) -> Port<TaskResult> {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -243,12 +215,12 @@ impl TaskBuilder {\n         }\n \n         // Construct the future and give it to the caller.\n-        let (notify_pipe_po, notify_pipe_ch) = stream::<UnwindResult>();\n+        let (notify_pipe_po, notify_pipe_ch) = Chan::new();\n \n         // Reconfigure self to use a notify channel.\n         self.opts.notify_chan = Some(notify_pipe_ch);\n \n-        TaskResultPort { port: notify_pipe_po }\n+        notify_pipe_po\n     }\n \n     /// Name the task-to-be. Currently the name is used for identification\n@@ -341,7 +313,7 @@ impl TaskBuilder {\n      * Fails if a future_result was already set for this task.\n      */\n     pub fn try<T:Send>(mut self, f: proc() -> T) -> Result<T, ~Any> {\n-        let (po, ch) = stream::<T>();\n+        let (po, ch) = Chan::new();\n \n         let result = self.future_result();\n \n@@ -466,7 +438,7 @@ pub fn failing() -> bool {\n // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n \n #[cfg(test)]\n-fn block_forever() { let (po, _ch) = stream::<()>(); po.recv(); }\n+fn block_forever() { let (po, _ch) = Chan::<()>::new(); po.recv(); }\n \n #[test]\n fn test_unnamed_task() {\n@@ -528,9 +500,8 @@ fn test_send_named_task() {\n \n #[test]\n fn test_run_basic() {\n-    let (po, ch) = stream::<()>();\n-    let builder = task();\n-    do builder.spawn {\n+    let (po, ch) = Chan::new();\n+    do task().spawn {\n         ch.send(());\n     }\n     po.recv();\n@@ -543,7 +514,7 @@ struct Wrapper {\n \n #[test]\n fn test_add_wrapper() {\n-    let (po, ch) = stream::<()>();\n+    let (po, ch) = Chan::new();\n     let mut b0 = task();\n     do b0.add_wrapper |body| {\n         let ch = ch;\n@@ -608,8 +579,7 @@ fn get_sched_id() -> int {\n \n #[test]\n fn test_spawn_sched() {\n-    let (po, ch) = stream::<()>();\n-    let ch = SharedChan::new(ch);\n+    let (po, ch) = SharedChan::new();\n \n     fn f(i: int, ch: SharedChan<()>) {\n         let parent_sched_id = get_sched_id();\n@@ -632,14 +602,14 @@ fn test_spawn_sched() {\n \n #[test]\n fn test_spawn_sched_childs_on_default_sched() {\n-    let (po, ch) = stream();\n+    let (po, ch) = Chan::new();\n \n     // Assuming tests run on the default scheduler\n     let default_id = get_sched_id();\n \n     do spawn_sched(SingleThreaded) {\n-        let parent_sched_id = get_sched_id();\n         let ch = ch;\n+        let parent_sched_id = get_sched_id();\n         do spawn {\n             let child_sched_id = get_sched_id();\n             assert!(parent_sched_id != child_sched_id);\n@@ -660,8 +630,8 @@ fn test_spawn_sched_blocking() {\n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers\n         20u.times(|| {\n-            let (start_po, start_ch) = stream();\n-            let (fin_po, fin_ch) = stream();\n+            let (start_po, start_ch) = Chan::new();\n+            let (fin_po, fin_ch) = Chan::new();\n \n             let mut lock = Mutex::new();\n             let lock2 = lock.clone();\n@@ -686,14 +656,14 @@ fn test_spawn_sched_blocking() {\n                 let mut val = 20;\n                 while val > 0 {\n                     val = po.recv();\n-                    ch.send(val - 1);\n+                    ch.try_send(val - 1);\n                 }\n             }\n \n-            let (setup_po, setup_ch) = stream();\n-            let (parent_po, parent_ch) = stream();\n+            let (setup_po, setup_ch) = Chan::new();\n+            let (parent_po, parent_ch) = Chan::new();\n             do spawn {\n-                let (child_po, child_ch) = stream();\n+                let (child_po, child_ch) = Chan::new();\n                 setup_ch.send(child_ch);\n                 pingpong(&child_po, &parent_ch);\n             };\n@@ -712,12 +682,12 @@ fn test_spawn_sched_blocking() {\n \n #[cfg(test)]\n fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n-    let (p, ch) = stream::<uint>();\n+    let (p, ch) = Chan::<uint>::new();\n \n     let x = ~1;\n     let x_in_parent = ptr::to_unsafe_ptr(&*x) as uint;\n \n-    do spawnfn || {\n+    do spawnfn {\n         let x_in_child = ptr::to_unsafe_ptr(&*x) as uint;\n         ch.send(x_in_child);\n     }"}, {"sha": "1148774020a14b083f73d6b5d5e3064ff7061312", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -77,18 +77,15 @@\n \n use prelude::*;\n \n-use comm::{GenericChan, oneshot};\n+use comm::Chan;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n use rt::task::{Task, Sched};\n-use rt::task::UnwindResult;\n use rt::thread::Thread;\n use rt::{in_green_task_context, new_event_loop};\n-use task::SingleThreaded;\n-use task::TaskOpts;\n+use task::{SingleThreaded, TaskOpts, TaskResult};\n \n #[cfg(test)] use task::default_task_opts;\n-#[cfg(test)] use comm;\n #[cfg(test)] use task;\n \n pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n@@ -132,7 +129,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n             // Create a task that will later be used to join with the new scheduler\n             // thread when it is ready to terminate\n-            let (thread_port, thread_chan) = oneshot();\n+            let (thread_port, thread_chan) = Chan::new();\n             let join_task = do Task::build_child(None) {\n                 debug!(\"running join task\");\n                 let thread: Thread<()> = thread_port.recv();\n@@ -173,8 +170,8 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n     if opts.notify_chan.is_some() {\n         let notify_chan = opts.notify_chan.take_unwrap();\n-        let on_exit: proc(UnwindResult) = proc(task_result) {\n-            notify_chan.send(task_result)\n+        let on_exit: proc(TaskResult) = proc(task_result) {\n+            notify_chan.try_send(task_result);\n         };\n         task.death.on_exit = Some(on_exit);\n     }\n@@ -187,7 +184,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n #[test]\n fn test_spawn_raw_simple() {\n-    let (po, ch) = stream();\n+    let (po, ch) = Chan::new();\n     do spawn_raw(default_task_opts()) {\n         ch.send(());\n     }\n@@ -208,21 +205,21 @@ fn test_spawn_raw_unsupervise() {\n \n #[test]\n fn test_spawn_raw_notify_success() {\n-    let (notify_po, notify_ch) = comm::stream();\n+    let (notify_po, notify_ch) = Chan::new();\n \n     let opts = task::TaskOpts {\n         notify_chan: Some(notify_ch),\n         .. default_task_opts()\n     };\n     do spawn_raw(opts) {\n     }\n-    assert!(notify_po.recv().is_success());\n+    assert!(notify_po.recv().is_ok());\n }\n \n #[test]\n fn test_spawn_raw_notify_failure() {\n     // New bindings for these\n-    let (notify_po, notify_ch) = comm::stream();\n+    let (notify_po, notify_ch) = Chan::new();\n \n     let opts = task::TaskOpts {\n         watched: false,\n@@ -232,5 +229,5 @@ fn test_spawn_raw_notify_failure() {\n     do spawn_raw(opts) {\n         fail!();\n     }\n-    assert!(notify_po.recv().is_failure());\n+    assert!(notify_po.recv().is_err());\n }"}, {"sha": "043d99eb1b82b46ecc2429750a03f79f78ad87cb", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -10,10 +10,7 @@\n \n #[doc(hidden)];\n \n-use comm::{GenericChan, GenericPort};\n-use comm;\n use prelude::*;\n-use task;\n use libc::uintptr_t;\n \n pub mod dynamic_lib;\n@@ -38,15 +35,7 @@ a normal large stack.\n */\n pub fn run_in_bare_thread(f: proc()) {\n     use rt::thread::Thread;\n-\n-    let (port, chan) = comm::stream();\n-    // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n-    // necessary since rust_raw_thread_join is blocking\n-    do task::spawn_sched(task::SingleThreaded) {\n-        Thread::start(f).join();\n-        chan.send(());\n-    }\n-    port.recv();\n+    Thread::start(f).join()\n }\n \n #[test]"}, {"sha": "50fae1e0239a6183238f5b1420a38fc8fcca6f7b", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use cast;\n-use comm;\n+use comm::{Chan, Port};\n use ptr;\n use option::{Option,Some,None};\n use task;\n@@ -56,7 +56,7 @@ struct ArcData<T> {\n     // drops the last refcount on an arc. Unfortunately this can't be a proper\n     // pipe protocol because the unwrapper has to access both stages at once.\n     // FIXME(#7544): Maybe use AtomicPtr instead (to avoid xchg in take() later)?\n-    unwrapper: AtomicOption<(comm::ChanOne<()>, comm::PortOne<bool>)>,\n+    unwrapper: AtomicOption<(Chan<()>, Port<bool>)>,\n     // FIXME(#3224) should be able to make this non-option to save memory\n     data: Option<T>,\n }\n@@ -70,7 +70,7 @@ unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n \n /// A helper object used by `UnsafeArc::unwrap`.\n struct ChannelAndDataGuard<T> {\n-    channel: Option<comm::ChanOne<bool>>,\n+    channel: Option<Chan<bool>>,\n     data: Option<~ArcData<T>>,\n }\n \n@@ -92,7 +92,7 @@ impl<T> Drop for ChannelAndDataGuard<T> {\n }\n \n impl<T> ChannelAndDataGuard<T> {\n-    fn unwrap(mut self) -> (comm::ChanOne<bool>, ~ArcData<T>) {\n+    fn unwrap(mut self) -> (Chan<bool>, ~ArcData<T>) {\n         (self.channel.take_unwrap(), self.data.take_unwrap())\n     }\n }\n@@ -167,8 +167,8 @@ impl<T: Send> UnsafeArc<T> {\n             // The ~ dtor needs to run if this code succeeds.\n             let mut data: ~ArcData<T> = cast::transmute(this.data);\n             // Set up the unwrap protocol.\n-            let (p1,c1) = comm::oneshot(); // ()\n-            let (p2,c2) = comm::oneshot(); // bool\n+            let (p1,c1) = Chan::new(); // ()\n+            let (p2,c2) = Chan::new(); // bool\n             // Try to put our server end in the unwrapper slot.\n             // This needs no barrier -- it's protected by the release barrier on\n             // the xadd, and the acquire+release barrier in the destructor's xadd.\n@@ -269,7 +269,7 @@ impl<T> Drop for UnsafeArc<T>{\n                 // reference. In effect, being here means we're the only\n                 // *awake* task with the data.\n                 match data.unwrapper.take(Acquire) {\n-                    Some(~(message,response)) => {\n+                    Some(~(message, response)) => {\n                         // Send 'ready' and wait for a response.\n                         message.send(());\n                         // Unkillable wait. Message guaranteed to come.\n@@ -508,7 +508,6 @@ impl<T:Send> Exclusive<T> {\n \n #[cfg(test)]\n mod tests {\n-    use comm;\n     use option::*;\n     use prelude::*;\n     use super::{Exclusive, UnsafeArc, atomic};\n@@ -541,18 +540,18 @@ mod tests {\n \n             for _ in range(0u, num_tasks) {\n                 let total = total.clone();\n-                let (port, chan) = comm::stream();\n+                let (port, chan) = Chan::new();\n                 futures.push(port);\n \n-                do task::spawn || {\n+                do task::spawn {\n                     for _ in range(0u, count) {\n                         total.with(|count| **count += 1);\n                     }\n                     chan.send(());\n                 }\n             };\n \n-            for f in futures.iter() { f.recv() }\n+            for f in futures.mut_iter() { f.recv() }\n \n             total.with(|total| assert!(**total == num_tasks * count));\n         }\n@@ -625,7 +624,7 @@ mod tests {\n         // When an unwrap and a try_unwrap race, the unwrapper should always win.\n         let x = UnsafeArc::new(~~\"hello\");\n         let x2 = x.clone();\n-        let (p,c) = comm::stream();\n+        let (p,c) = Chan::new();\n         do task::spawn {\n             c.send(());\n             assert!(x2.unwrap() == ~~\"hello\");"}, {"sha": "ed896af69b41fb1537c1806acfab511715f660d6", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -11,7 +11,7 @@\n use std::task;\n \n pub fn foo<T:Send + Clone>(x: T) -> Port<T> {\n-    let (p, c) = stream();\n+    let (p, c) = Chan::new();\n     do task::spawn() {\n         c.send(x.clone());\n     }"}, {"sha": "50cb00b25d4b116ead9b024dc9b2978127c984b5", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -20,7 +20,6 @@\n \n extern mod extra;\n \n-use std::comm::{Port, Chan, SharedChan};\n use std::comm;\n use std::os;\n use std::task;\n@@ -38,7 +37,7 @@ fn server(requests: &Port<request>, responses: &Chan<uint>) {\n     let mut count = 0u;\n     let mut done = false;\n     while !done {\n-        match requests.try_recv() {\n+        match requests.recv_opt() {\n           Some(get_count) => { responses.send(count.clone()); }\n           Some(bytes(b)) => {\n             //error!(\"server: received {:?} bytes\", b);\n@@ -53,10 +52,8 @@ fn server(requests: &Port<request>, responses: &Chan<uint>) {\n }\n \n fn run(args: &[~str]) {\n-    let (from_child, to_parent) = comm::stream();\n-    let (from_parent, to_child) = comm::stream();\n-\n-    let to_child = SharedChan::new(to_child);\n+    let (from_child, to_parent) = Chan::new();\n+    let (from_parent, to_child) = SharedChan::new();\n \n     let size = from_str::<uint>(args[1]).unwrap();\n     let workers = from_str::<uint>(args[2]).unwrap();"}, {"sha": "3cf1a97a36e041821f6a598c89f3f9d3d0d22d87", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -16,7 +16,6 @@\n \n extern mod extra;\n \n-use std::comm::{SharedChan, Chan, stream};\n use std::os;\n use std::task;\n use std::uint;\n@@ -33,7 +32,7 @@ fn server(requests: &Port<request>, responses: &Chan<uint>) {\n     let mut count: uint = 0;\n     let mut done = false;\n     while !done {\n-        match requests.try_recv() {\n+        match requests.recv_opt() {\n           Some(get_count) => { responses.send(count.clone()); }\n           Some(bytes(b)) => {\n             //error!(\"server: received {:?} bytes\", b);\n@@ -48,17 +47,15 @@ fn server(requests: &Port<request>, responses: &Chan<uint>) {\n }\n \n fn run(args: &[~str]) {\n-    let (from_child, to_parent) = stream();\n-    let (from_parent, to_child) = stream();\n-    let to_child = SharedChan::new(to_child);\n+    let (from_child, to_parent) = Chan::new();\n \n     let size = from_str::<uint>(args[1]).unwrap();\n     let workers = from_str::<uint>(args[2]).unwrap();\n     let num_bytes = 100;\n     let start = extra::time::precise_time_s();\n     let mut worker_results = ~[];\n-    for _ in range(0u, workers) {\n-        let to_child = to_child.clone();\n+    let from_parent = if workers == 1 {\n+        let (from_parent, to_child) = Chan::new();\n         let mut builder = task::task();\n         worker_results.push(builder.future_result());\n         do builder.spawn {\n@@ -68,7 +65,23 @@ fn run(args: &[~str]) {\n             }\n             //error!(\"worker {:?} exiting\", i);\n         };\n-    }\n+        from_parent\n+    } else {\n+        let (from_parent, to_child) = SharedChan::new();\n+        for _ in range(0u, workers) {\n+            let to_child = to_child.clone();\n+            let mut builder = task::task();\n+            worker_results.push(builder.future_result());\n+            do builder.spawn {\n+                for _ in range(0u, size / workers) {\n+                    //error!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n+                    to_child.send(bytes(num_bytes));\n+                }\n+                //error!(\"worker {:?} exiting\", i);\n+            };\n+        }\n+        from_parent\n+    };\n     do task::spawn || {\n         server(&from_parent, &to_parent);\n     }\n@@ -78,8 +91,8 @@ fn run(args: &[~str]) {\n     }\n \n     //error!(\"sending stop message\");\n-    to_child.send(stop);\n-    move_out(to_child);\n+    //to_child.send(stop);\n+    //move_out(to_child);\n     let result = from_child.recv();\n     let end = extra::time::precise_time_s();\n     let elapsed = end - start;"}, {"sha": "90d81aa7c3ee688379ce664b24165934c58702cf", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -24,9 +24,9 @@ fn ping_pong_bench(n: uint, m: uint) {\n     // Create pairs of tasks that pingpong back and forth.\n     fn run_pair(n: uint) {\n         // Create a stream A->B\n-        let (pa,ca) = stream::<()>();\n+        let (pa,ca) = Chan::<()>::new();\n         // Create a stream B->A\n-        let (pb,cb) = stream::<()>();\n+        let (pb,cb) = Chan::<()>::new();\n \n         do spawntask_later() || {\n             let chan = ca;"}, {"sha": "ab607d9aebc758da867cc357cbc8982ebb5f89e5", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use std::os;\n use std::uint;\n use std::rt::test::spawntask_later;\n-use std::comm::oneshot;\n \n // A simple implementation of parfib. One subtree is found in a new\n // task and communicated over a oneshot pipe, the other is found\n@@ -24,7 +23,7 @@ fn parfib(n: uint) -> uint {\n         return 1;\n     }\n \n-    let (port,chan) = oneshot::<uint>();\n+    let (port,chan) = Chan::new();\n     do spawntask_later {\n         chan.send(parfib(n-1));\n     };"}, {"sha": "7801a64fcedba40df1948d838eecda2d7e7322ad", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,7 +12,6 @@\n \n extern mod extra;\n \n-use std::comm::{stream, SharedChan};\n use std::option;\n use std::os;\n use std::task;\n@@ -138,10 +137,8 @@ fn creature(\n fn rendezvous(nn: uint, set: ~[color]) {\n \n     // these ports will allow us to hear from the creatures\n-    let (from_creatures, to_rendezvous) = stream::<CreatureInfo>();\n-    let to_rendezvous = SharedChan::new(to_rendezvous);\n-    let (from_creatures_log, to_rendezvous_log) = stream::<~str>();\n-    let to_rendezvous_log = SharedChan::new(to_rendezvous_log);\n+    let (from_creatures, to_rendezvous) = SharedChan::<CreatureInfo>::new();\n+    let (from_creatures_log, to_rendezvous_log) = SharedChan::<~str>::new();\n \n     // these channels will be passed to the creatures so they can talk to us\n \n@@ -154,7 +151,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n             let col = *col;\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n-            let (from_rendezvous, to_creature) = stream();\n+            let (from_rendezvous, to_creature) = Chan::new();\n             do task::spawn {\n                 creature(ii,\n                          col,"}, {"sha": "96de609787345b687e3105c26de5f125a8851dff", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -17,7 +17,6 @@ extern mod extra;\n \n use extra::sort;\n use std::cmp::Ord;\n-use std::comm::{stream, Port, Chan};\n use std::comm;\n use std::hashmap::HashMap;\n use std::option;\n@@ -165,7 +164,7 @@ fn main() {\n \n     // initialize each sequence sorter\n     let sizes = ~[1u,2,3,4,6,12,18];\n-    let mut streams = vec::from_fn(sizes.len(), |_| Some(stream::<~str>()));\n+    let mut streams = vec::from_fn(sizes.len(), |_| Some(Chan::<~str>::new()));\n     let mut from_child = ~[];\n     let to_child   = sizes.iter().zip(streams.mut_iter()).map(|(sz, stream_ref)| {\n         let sz = *sz;\n@@ -174,7 +173,7 @@ fn main() {\n \n         from_child.push(from_child_);\n \n-        let (from_parent, to_child) = comm::stream();\n+        let (from_parent, to_child) = Chan::new();\n \n         do spawn {\n             make_sequence_processor(sz, &from_parent, &to_parent_);"}, {"sha": "aa060ceb0973f1ab7c97ce64795b3516a324358c", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -21,7 +21,6 @@\n extern mod extra;\n \n use extra::{time, getopts};\n-use std::comm::{stream, SharedChan};\n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n@@ -34,8 +33,7 @@ fn fib(n: int) -> int {\n         } else if n <= 2 {\n             c.send(1);\n         } else {\n-            let (pp, cc) = stream();\n-            let cc = SharedChan::new(cc);\n+            let (pp, cc) = SharedChan::new();\n             let ch = cc.clone();\n             task::spawn(proc() pfib(&ch, n - 1));\n             let ch = cc.clone();\n@@ -44,8 +42,7 @@ fn fib(n: int) -> int {\n         }\n     }\n \n-    let (p, ch) = stream();\n-    let ch = SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n     let _t = task::spawn(proc() pfib(&ch, n) );\n     p.recv()\n }"}, {"sha": "6293b6ce8669ba365cf19df091908fa00933064c", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -13,14 +13,14 @@\n use std::os;\n \n fn start(n_tasks: int, token: int) {\n-    let (p, ch1) = stream();\n+    let (p, ch1) = Chan::new();\n     let mut p = p;\n     let ch1 = ch1;\n     ch1.send(token);\n     //  XXX could not get this to work with a range closure\n     let mut i = 2;\n     while i <= n_tasks {\n-        let (next_p, ch) = stream();\n+        let (next_p, ch) = Chan::new();\n         let imm_i = i;\n         let imm_p = p;\n         do spawn {"}, {"sha": "dc31ef06fa6f20143f2b1dd8fbd0e19922d34ceb", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -48,9 +48,9 @@ fn main() {\n         args.clone()\n     };\n \n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     child_generation(from_str::<uint>(args[1]).unwrap(), c);\n-    if p.try_recv().is_none() {\n+    if p.recv_opt().is_none() {\n         fail!(\"it happened when we slumbered\");\n     }\n }"}, {"sha": "015d31bf42cce021520639c9ddcc6bd8c1e445c8", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm;\n-\n fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     let x = Some(p);\n     c.send(false);\n     match x {"}, {"sha": "c82f752a4548ec58c8de023cf3d04dd341660ada", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -11,18 +11,16 @@\n // Tests (negatively) the ability for the Self type in default methods\n // to use capabilities granted by builtin kinds as supertraits.\n \n-use std::comm;\n-\n trait Foo : Freeze {\n-    fn foo(self, chan: comm::Chan<Self>) {\n+    fn foo(self, mut chan: Chan<Self>) {\n         chan.send(self); //~ ERROR does not fulfill `Send`\n     }\n }\n \n impl <T: Freeze> Foo for T { }\n \n fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     1193182.foo(c);\n     assert!(p.recv() == 1193182);\n }"}, {"sha": "1eff31b2aa4b95ce283d9cc673436979371ed9c0", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -13,8 +13,6 @@\n // Test that a class with an unsendable field can't be\n // sent\n \n-use std::comm;\n-\n struct foo {\n   i: int,\n   j: @~str,\n@@ -29,6 +27,6 @@ fn foo(i:int, j: @~str) -> foo {\n \n fn main() {\n   let cat = ~\"kitty\";\n-    let (_, ch) = comm::stream(); //~ ERROR does not fulfill `Send`\n+  let (_, ch) = Chan::new(); //~ ERROR does not fulfill `Send`\n   ch.send(foo(42, @(cat))); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "7dc12c70b9be4acde885eed5d82cb73a05c6f6f6", "filename": "src/test/run-pass/builtin-superkinds-capabilities-transitive.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -14,20 +14,18 @@\n // a Send. Basically this just makes sure rustc is using\n // each_bound_trait_and_supertraits in type_contents correctly.\n \n-use std::comm;\n-\n trait Bar : Send { }\n trait Foo : Bar { }\n \n impl <T: Send> Foo for T { }\n impl <T: Send> Bar for T { }\n \n-fn foo<T: Foo>(val: T, chan: comm::Chan<T>) {\n+fn foo<T: Foo>(val: T, chan: Chan<T>) {\n     chan.send(val);\n }\n \n pub fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     foo(31337, c);\n     assert!(p.recv() == 31337);\n }"}, {"sha": "f94d1af84f623e8f5f926b21ddb9a14a030615ce", "filename": "src/test/run-pass/builtin-superkinds-capabilities-xc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -17,20 +17,19 @@\n \n extern mod trait_superkinds_in_metadata;\n use trait_superkinds_in_metadata::{RequiresRequiresFreezeAndSend, RequiresFreeze};\n-use std::comm;\n \n #[deriving(Eq)]\n struct X<T>(T);\n \n impl <T: Freeze> RequiresFreeze for X<T> { }\n impl <T: Freeze+Send> RequiresRequiresFreezeAndSend for X<T> { }\n \n-fn foo<T: RequiresRequiresFreezeAndSend>(val: T, chan: comm::Chan<T>) {\n+fn foo<T: RequiresRequiresFreezeAndSend>(val: T, chan: Chan<T>) {\n     chan.send(val);\n }\n \n fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     foo(X(31337), c);\n     assert!(p.recv() == X(31337));\n }"}, {"sha": "fa3903b41d1ba1e9b600a5fda6258b378b98aba5", "filename": "src/test/run-pass/builtin-superkinds-capabilities.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,18 +12,16 @@\n // builtin-kinds, e.g., if a trait requires Send to implement, then\n // at usage site of that trait, we know we have the Send capability.\n \n-use std::comm;\n-\n trait Foo : Send { }\n \n impl <T: Send> Foo for T { }\n \n-fn foo<T: Foo>(val: T, chan: comm::Chan<T>) {\n+fn foo<T: Foo>(val: T, chan: Chan<T>) {\n     chan.send(val);\n }\n \n pub fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     foo(31337, c);\n     assert!(p.recv() == 31337);\n }"}, {"sha": "a71bedfefe021cd78a59171a7097cb2c2430d66d", "filename": "src/test/run-pass/builtin-superkinds-self-type.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -11,18 +11,16 @@\n // Tests the ability for the Self type in default methods to use\n // capabilities granted by builtin kinds as supertraits.\n \n-use std::comm;\n-\n trait Foo : Send {\n-    fn foo(self, chan: comm::Chan<Self>) {\n+    fn foo(self, chan: Chan<Self>) {\n         chan.send(self);\n     }\n }\n \n impl <T: Send> Foo for T { }\n \n pub fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     1193182.foo(c);\n     assert!(p.recv() == 1193182);\n }"}, {"sha": "0d9fdea4a9d51027f313dfaac49f15a0f81449ee", "filename": "src/test/run-pass/capture_nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture_nil.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -27,7 +27,7 @@\n use std::task;\n \n fn foo(x: ()) -> Port<()> {\n-    let (p, c) = stream::<()>();\n+    let (p, c) = Chan::<()>::new();\n     do task::spawn() {\n         c.send(x);\n     }"}, {"sha": "3a92f4ba3f401412545f1f2661c2dd2aab8e5455", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -15,7 +15,7 @@ fn foo(blk: proc()) {\n }\n \n pub fn main() {\n-    let (p,c) = comm::stream();\n+    let (p,c) = Chan::new();\n     do foo {\n         c.send(());\n     }"}, {"sha": "25e31f0b548b5c78747bef747c31fbb4b0f6c6d7", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -11,8 +11,8 @@\n use std::task;\n \n pub fn main() {\n-    let (p, ch) = stream();\n-    let _t = task::spawn(proc() child(&ch));\n+    let (p, ch) = Chan::new();\n+    let _t = task::spawn(proc() { child(&ch) });\n     let y = p.recv();\n     error!(\"received\");\n     error!(\"{:?}\", y);"}, {"sha": "49aa8d18e90ecad23d5890527ed16ad73bb49ca9", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -21,7 +21,6 @@\n pub fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n \n mod map_reduce {\n-    use std::comm::{stream, SharedChan};\n     use std::hashmap::HashMap;\n     use std::str;\n     use std::task;\n@@ -43,12 +42,13 @@ mod map_reduce {\n     fn map_task(ctrl: SharedChan<ctrl_proto>, input: ~str) {\n         let intermediates = @mut HashMap::new();\n \n-        fn emit(im: &mut HashMap<~str, int>, ctrl: SharedChan<ctrl_proto>, key: ~str,\n+        fn emit(im: &mut HashMap<~str, int>,\n+                ctrl: SharedChan<ctrl_proto>, key: ~str,\n                 _val: ~str) {\n             if im.contains_key(&key) {\n                 return;\n             }\n-            let (pp, cc) = stream();\n+            let (pp, cc) = Chan::new();\n             error!(\"sending find_reducer\");\n             ctrl.send(find_reducer(key.as_bytes().to_owned(), cc));\n             error!(\"receiving\");\n@@ -63,8 +63,7 @@ mod map_reduce {\n     }\n \n     pub fn map_reduce(inputs: ~[~str]) {\n-        let (ctrl_port, ctrl_chan) = stream();\n-        let ctrl_chan = SharedChan::new(ctrl_chan);\n+        let (ctrl_port, ctrl_chan) = SharedChan::new();\n \n         // This task becomes the master control task. It spawns others\n         // to do the rest.\n@@ -81,10 +80,11 @@ mod map_reduce {\n             match ctrl_port.recv() {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n-                let c = match reducers.find(&str::from_utf8_owned(k)) {\n-                  Some(&_c) => _c,\n-                  None => 0\n-                };\n+                let mut c;\n+                match reducers.find(&str::from_utf8(k).to_owned()) {\n+                  Some(&_c) => { c = _c; }\n+                  None => { c = 0; }\n+                }\n                 cc.send(c);\n               }\n             }"}, {"sha": "4922ab18f8d45bca609903e0f914c4b48762a96c", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -14,6 +14,7 @@ enum Msg\n fn foo(name: ~str, samples_chan: Chan<Msg>) {\n     do task::spawn\n     {\n+        let mut samples_chan = samples_chan;\n         let callback: SamplesFn = proc(buffer) {\n             for i in range(0u, buffer.len()) {\n                 error!(\"{}: {}\", i, buffer[i])"}, {"sha": "53b45ba99caf01d0da257785c7d3d3f467b469e0", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let (port, chan) = stream();\n+    let (port, chan) = Chan::new();\n \n     do spawn {\n         println(port.recv());"}, {"sha": "c3f871c79124bae7b74f99610cb09f8f9efff5c8", "filename": "src/test/run-pass/issue-4448.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4448.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm;\n use std::task;\n \n pub fn main() {\n-    let (port, chan) = comm::stream::<&'static str>();\n+    let (port, chan) = Chan::<&'static str>::new();\n \n     do task::spawn {\n         assert_eq!(port.recv(), \"hello, world\");"}, {"sha": "aa009a91aecf318d0ddff2387fff88bd35b4d078", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -7,8 +7,10 @@ fn producer(c: &Chan<~[u8]>) {\n }\n \n pub fn main() {\n-    let (p, ch) = stream::<~[u8]>();\n-    let _prod = task::spawn(proc() producer(&ch) );\n+    let (p, ch) = Chan::<~[u8]>::new();\n+    let _prod = task::spawn(proc() {\n+        producer(&ch)\n+    });\n \n     let _data: ~[u8] = p.recv();\n }"}, {"sha": "6a88b804c22ee81cc2d9e166b9e43ddbf6def354", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -25,7 +25,7 @@ impl fmt::Default for Foo {\n }\n \n pub fn main() {\n-    let (p,c) = stream();\n+    let (p,c) = Chan::new();\n     do spawn {\n         let f = Foo(@mut 0);\n         debug!(\"{}\", f);"}, {"sha": "7ede574a4d5bef69a7443cb14c556105148b29b2", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -25,10 +25,10 @@ fn test(f: int) -> test {\n }\n \n pub fn main() {\n-    let (p, c) = stream();\n+    let (p, c) = Chan::new();\n \n     do task::spawn() {\n-        let (pp, cc) = stream();\n+        let (pp, cc) = Chan::new();\n         c.send(cc);\n \n         let _r = pp.recv();"}, {"sha": "a8dc4a68e94449f34478f4a0845614ce41d4f113", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -14,8 +14,8 @@ struct Command<K, V> {\n     val: V\n }\n \n-fn cache_server<K:Send,V:Send>(c: Chan<Chan<Command<K, V>>>) {\n-    let (_ctrl_port, ctrl_chan) = stream();\n+fn cache_server<K:Send,V:Send>(mut c: Chan<Chan<Command<K, V>>>) {\n+    let (_ctrl_port, ctrl_chan) = Chan::new();\n     c.send(ctrl_chan);\n }\n pub fn main() { }"}, {"sha": "0c7091a44547ef51aad9557cb5832250781c38a2", "filename": "src/test/run-pass/sendable-class.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendable-class.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -10,8 +10,6 @@\n \n // Test that a class with only sendable fields can be sent\n \n-use std::comm;\n-\n struct foo {\n   i: int,\n   j: char,\n@@ -25,6 +23,6 @@ fn foo(i:int, j: char) -> foo {\n }\n \n pub fn main() {\n-    let (_po, ch) = comm::stream();\n+    let (_po, ch) = Chan::new();\n     ch.send(foo(42, 'c'));\n }"}, {"sha": "67d1836b545cf90e398e085883b7135c66cb6371", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -23,6 +23,6 @@ fn iotask(_cx: &ctx, ip: ~str) {\n }\n \n pub fn main() {\n-    let (_p, ch) = stream::<int>();\n+    let (_p, ch) = Chan::<int>::new();\n     task::spawn(proc() iotask(&ch, ~\"localhost\") );\n }"}, {"sha": "671ef16c5eba4cb9e080e6953af84cf68085433a", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,8 +12,6 @@\n \n extern mod extra;\n \n-use std::comm::Chan;\n-use std::comm;\n use std::task;\n \n pub fn main() { test05(); }\n@@ -28,8 +26,8 @@ fn test05_start(ch : &Chan<int>) {\n }\n \n fn test05() {\n-    let (po, ch) = comm::stream();\n-    task::spawn(proc() test05_start(&ch) );\n+    let (po, ch) = Chan::new();\n+    task::spawn(proc() { test05_start(&ch) });\n     let mut value: int = po.recv();\n     error!(\"{}\", value);\n     value = po.recv();"}, {"sha": "fc8c6069152a56967e5051ace43a1d0696352277", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,11 +12,10 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n-fn start(c: &comm::Chan<comm::Chan<~str>>) {\n-    let (p, ch) = comm::stream();\n+fn start(c: &Chan<Chan<~str>>) {\n+    let (p, ch) = Chan::new();\n     c.send(ch);\n \n     let mut a;\n@@ -30,10 +29,10 @@ fn start(c: &comm::Chan<comm::Chan<~str>>) {\n }\n \n pub fn main() {\n-    let (p, ch) = comm::stream();\n-    let _child = task::spawn(proc() start(&ch) );\n+    let (p, ch) = Chan::new();\n+    let _child = task::spawn(proc() { start(&ch) });\n \n-    let c = p.recv();\n+    let mut c = p.recv();\n     c.send(~\"A\");\n     c.send(~\"B\");\n     task::deschedule();"}, {"sha": "6f5990e7d167eab198c70affc65c0eccec787351", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,16 +12,17 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n-fn start(c: &comm::Chan<comm::Chan<int>>) {\n-    let (_p, ch) = comm::stream();\n+fn start(c: &Chan<Chan<int>>) {\n+    let (_p, ch) = Chan::new();\n     c.send(ch);\n }\n \n pub fn main() {\n-    let (p, ch) = comm::stream();\n-    let _child = task::spawn(proc() start(&ch) );\n+    let (mut p, ch) = Chan::new();\n+    let _child = task::spawn(proc() {\n+        start(&ch)\n+    });\n     let _c = p.recv();\n }"}, {"sha": "ce30071aaf4456cc2760d86908306036b82a7002", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -19,7 +19,7 @@ fn start(_task_number: int) { info!(\"Started / Finished task.\"); }\n fn test00() {\n     let i: int = 0;\n     let mut builder = task::task();\n-    let result = builder.future_result();\n+    let mut result = builder.future_result();\n     do builder.spawn {\n         start(i)\n     }"}, {"sha": "ce3cd59bfb13fb5b8f7093d5c7fc97a64b69c54f", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,17 +12,16 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n-fn start(c: &comm::Chan<int>, start: int, number_of_messages: int) {\n+fn start(c: &Chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n pub fn main() {\n     info!(\"Check that we don't deadlock.\");\n-    let (_p, ch) = comm::stream();\n-    task::try(proc() start(&ch, 0, 10) );\n+    let (_p, ch) = Chan::new();\n+    task::try(proc() { start(&ch, 0, 10) });\n     info!(\"Joined task\");\n }"}, {"sha": "2a7a0c25a21c20dd33d2b5d6ec49abcace36b435", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -10,19 +10,17 @@\n \n // xfail-fast\n \n-use std::comm;\n use std::task;\n \n pub fn main() {\n-    let (po, ch) = comm::stream();\n-    let ch = comm::SharedChan::new(ch);\n+    let (po, ch) = SharedChan::new();\n \n     // Spawn 10 tasks each sending us back one int.\n     let mut i = 10;\n     while (i > 0) {\n         info!(\"{}\", i);\n         let ch = ch.clone();\n-        task::spawn({let i = i; proc() child(i, &ch)});\n+        task::spawn({let i = i; proc() { child(i, &ch) }});\n         i = i - 1;\n     }\n \n@@ -39,7 +37,7 @@ pub fn main() {\n     info!(\"main thread exiting\");\n }\n \n-fn child(x: int, ch: &comm::SharedChan<int>) {\n+fn child(x: int, ch: &SharedChan<int>) {\n     info!(\"{}\", x);\n     ch.send(x);\n }"}, {"sha": "9f0d9908f7f5586d8260aaacffb240f3db0be4dd", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,10 +12,9 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n-fn start(c: &comm::Chan<int>, i0: int) {\n+fn start(c: &Chan<int>, i0: int) {\n     let mut i = i0;\n     while i > 0 {\n         c.send(0);\n@@ -28,7 +27,10 @@ pub fn main() {\n     // is likely to terminate before the child completes, so from\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n-    let (p, ch) = comm::stream();\n-    task::spawn(proc() start(&ch, 10));\n+    let (p, ch) = Chan::new();\n+    task::spawn(proc() {\n+        let mut ch = ch;\n+        start(&ch, 10)\n+    });\n     p.recv();\n }"}, {"sha": "42d445dc24c2e8cab89fa0c090887d32e58eede4", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm;\n use std::cmp;\n \n // Tests of ports and channels on various types\n fn test_rec() {\n     struct R {val0: int, val1: u8, val2: char}\n \n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     let r0: R = R {val0: 0, val1: 1u8, val2: '2'};\n     ch.send(r0);\n     let mut r1: R;\n@@ -26,7 +25,7 @@ fn test_rec() {\n }\n \n fn test_vec() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     let v0: ~[int] = ~[0, 1, 2];\n     ch.send(v0);\n     let v1 = po.recv();\n@@ -36,7 +35,7 @@ fn test_vec() {\n }\n \n fn test_str() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     let s0 = ~\"test\";\n     ch.send(s0);\n     let s1 = po.recv();\n@@ -80,7 +79,7 @@ impl cmp::Eq for t {\n }\n \n fn test_tag() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     ch.send(tag1);\n     ch.send(tag2(10));\n     ch.send(tag3(10, 11u8, 'A'));\n@@ -94,10 +93,10 @@ fn test_tag() {\n }\n \n fn test_chan() {\n-    let (po, ch) = comm::stream();\n-    let (po0, ch0) = comm::stream();\n+    let (po, ch) = Chan::new();\n+    let (po0, ch0) = Chan::new();\n     ch.send(ch0);\n-    let ch1 = po.recv();\n+    let mut ch1 = po.recv();\n     // Does the transmitted channel still work?\n \n     ch1.send(10);"}, {"sha": "9679aebcc9c56284170e98a6367c8f0bcc71a3e2", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,8 +12,6 @@\n \n extern mod extra;\n \n-use std::comm::SharedChan;\n-use std::comm;\n use std::task;\n \n pub fn main() { info!(\"===== WITHOUT THREADS =====\"); test00(); }\n@@ -35,8 +33,7 @@ fn test00() {\n \n     info!(\"Creating tasks\");\n \n-    let (po, ch) = comm::stream();\n-    let ch = comm::SharedChan::new(ch);\n+    let (po, ch) = SharedChan::new();\n \n     let mut i: int = 0;\n \n@@ -47,8 +44,11 @@ fn test00() {\n         let mut builder = task::task();\n         results.push(builder.future_result());\n         builder.spawn({\n+            let ch = ch;\n             let i = i;\n-            proc() test00_start(&ch, i, number_of_messages)\n+            proc() {\n+                test00_start(&ch, i, number_of_messages)\n+            }\n         });\n         i = i + 1;\n     }"}, {"sha": "3ac4c0e00876880249a6a31e24a89cf7dc53f1cb", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -10,14 +10,12 @@\n \n #[allow(dead_assignment)];\n \n-use std::comm;\n-\n pub fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, c) = comm::stream();\n+    let (p, c) = Chan::new();\n     c.send(1);\n     c.send(2);\n     c.send(3);"}, {"sha": "c63bf12db2b33a1015acbfe4afdc8da0eab11b9e", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -10,14 +10,12 @@\n \n extern mod extra;\n \n-use std::comm;\n-\n pub fn main() { test00(); }\n \n fn test00() {\n     let _r: int = 0;\n     let mut sum: int = 0;\n-    let (p, c) = comm::stream();\n+    let (p, c) = Chan::new();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(i + 0); i += 1; }"}, {"sha": "45994e78d9405e337c931e0e00b7010ec1cd22bf", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -10,20 +10,16 @@\n \n #[allow(dead_assignment)];\n \n-use std::comm::SharedChan;\n-use std::comm;\n-\n pub fn main() { test00(); }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = comm::stream();\n-    let ch = SharedChan::new(ch);\n-    let c0 = ch.clone();\n-    let c1 = ch.clone();\n-    let c2 = ch.clone();\n-    let c3 = ch.clone();\n+    let (p, ch) = SharedChan::new();\n+    let mut c0 = ch.clone();\n+    let mut c1 = ch.clone();\n+    let mut c2 = ch.clone();\n+    let mut c3 = ch.clone();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n     while i < number_of_messages {"}, {"sha": "43ac3957ae2ed8f3604bae6266b5bc98106846e0", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -14,21 +14,20 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: &comm::SharedChan<int>, start: int, number_of_messages: int) {\n+fn test00_start(c: &SharedChan<int>, start: int,\n+                number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }\n \n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = comm::stream();\n-    let ch = comm::SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n     let number_of_messages: int = 10;\n \n     let c = ch.clone();"}, {"sha": "a2463ff76815f2f175bd3e60f1f8572a8f53318e", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,26 +12,26 @@\n \n extern mod extra;\n \n-use std::comm;\n use std::task;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: &comm::Chan<int>, number_of_messages: int) {\n+fn test00_start(c: &Chan<int>, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(i + 0); i += 1; }\n }\n \n fn test00() {\n     let r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = comm::stream();\n+    let (p, ch) = Chan::new();\n     let number_of_messages: int = 10;\n \n     let mut builder = task::task();\n     let result = builder.future_result();\n     do builder.spawn {\n-        test00_start(&ch, number_of_messages);\n+        let mut ch = ch;\n+        test00_start(&mut ch, number_of_messages);\n     }\n \n     let mut i: int = 0;"}, {"sha": "3277400704910cd7b8432d7f26b71c0ceca27827", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -11,13 +11,11 @@\n \n extern mod extra;\n \n-use std::comm;\n-\n // rustboot can't transmit nils across channels because they don't have\n // any size, but rustc currently can because they do have size. Whether\n // or not this is desirable I don't know, but here's a regression test.\n pub fn main() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     ch.send(());\n     let n: () = po.recv();\n     assert_eq!(n, ());"}, {"sha": "1ed0c23fd7a4ce4cb8c4e1ffb629922558bded70", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,7 +12,7 @@ use std::ptr;\n use std::task;\n \n pub fn main() {\n-    let (p, ch) = stream::<uint>();\n+    let (p, ch) = Chan::<uint>::new();\n \n     let x = ~1;\n     let x_in_parent = ptr::to_unsafe_ptr(&(*x)) as uint;"}, {"sha": "d3bb8128a3b9e7725f10b3a7a28203132d3c4e4a", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -38,7 +38,7 @@ fn test_tempdir() {\n }\n \n fn test_rm_tempdir() {\n-    let (rd, wr) = stream();\n+    let (rd, wr) = Chan::new();\n     let f: proc() = proc() {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n         wr.send(tmp.path().clone());"}, {"sha": "7e13d96094756e5d3787ae65603f9da75009ee3b", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -18,7 +18,6 @@\n extern mod extra;\n \n use extra::arc;\n-use std::comm;\n use std::task;\n \n trait Pet {\n@@ -70,13 +69,13 @@ fn main() {\n                          ~dogge1 as ~Pet:Freeze+Send,\n                          ~fishe  as ~Pet:Freeze+Send,\n                          ~dogge2 as ~Pet:Freeze+Send]);\n-    let (p1,c1) = comm::stream();\n+    let (p1,c1) = Chan::new();\n     let arc1 = arc.clone();\n     do task::spawn { check_legs(arc1); c1.send(()); }\n-    let (p2,c2) = comm::stream();\n+    let (p2,c2) = Chan::new();\n     let arc2 = arc.clone();\n     do task::spawn { check_names(arc2); c2.send(()); }\n-    let (p3,c3) = comm::stream();\n+    let (p3,c3) = Chan::new();\n     let arc3 = arc.clone();\n     do task::spawn { check_pedigree(arc3); c3.send(()); }\n     p1.recv();"}, {"sha": "e95f9184a6302d43c1e65bec19b871bc9908d858", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -13,10 +13,8 @@\n   message.\n  */\n \n-use std::comm;\n-\n pub fn main() {\n-    let (po, ch) = comm::stream();\n+    let (po, ch) = Chan::new();\n     ch.send(42);\n     let r = po.recv();\n     error!(\"{:?}\", r);"}, {"sha": "d1c45a336fa7abea0df21d68663c3b236eed9afc", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::comm::{SharedChan, stream};\n use std::task;\n \n fn child(c: &SharedChan<~uint>, i: uint) {\n     c.send(~i);\n }\n \n pub fn main() {\n-    let (p, ch) = stream();\n-    let ch = SharedChan::new(ch);\n+    let (p, ch) = SharedChan::new();\n     let n = 100u;\n     let mut expected = 0u;\n     for i in range(0u, n) {\n         let ch = ch.clone();\n-        task::spawn(proc() child(&ch, i) );\n+        task::spawn(proc() {\n+            child(&ch, i)\n+        });\n         expected += i;\n     }\n "}, {"sha": "a1c0050e725b1e5fef845ad3b3bb5000e31c8667", "filename": "src/test/run-pass/unique-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let (p, c) = stream();\n+    let (p, c) = Chan::new();\n     c.send(~100);\n     let v = p.recv();\n     assert_eq!(v, ~100);"}, {"sha": "f46769fa28e98910b39a78144d9be195dd653604", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,7 +12,6 @@\n \n extern mod extra;\n \n-use std::comm::{stream, SharedChan};\n use std::task;\n \n struct complainer {\n@@ -40,8 +39,7 @@ fn f(c: SharedChan<bool>) {\n }\n \n pub fn main() {\n-    let (p, c) = stream();\n-    let c = SharedChan::new(c);\n+    let (p, c) = SharedChan::new();\n     task::spawn(proc() f(c.clone()));\n     error!(\"hiiiiiiiii\");\n     assert!(p.recv());"}, {"sha": "4ec30d6e02a0bbde441183e5c2bf64e915abcc30", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n pub fn main() {\n     let mut builder = task::task();\n-    let result = builder.future_result();\n+    let mut result = builder.future_result();\n     builder.spawn(child);\n     error!(\"1\");\n     task::deschedule();"}, {"sha": "c08c62b47a2258558961eebc0a86b921a7bca6ed", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c9a35747e9a15830e35924429050b820825f5d/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=47c9a35747e9a15830e35924429050b820825f5d", "patch": "@@ -12,7 +12,7 @@ use std::task;\n \n pub fn main() {\n     let mut builder = task::task();\n-    let result = builder.future_result();\n+    let mut result = builder.future_result();\n     builder.spawn(child);\n     error!(\"1\");\n     task::deschedule();"}]}