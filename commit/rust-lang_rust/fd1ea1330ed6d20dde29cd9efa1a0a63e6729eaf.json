{"sha": "fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMWVhMTMzMGVkNmQyMGRkZTI5Y2Q5ZWZhMWEwYTYzZTY3MjllYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-05T12:53:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-05T12:53:01Z"}, "message": "Auto merge of #36736 - srinivasreddy:method, r=nrc\n\nrun rustfmt on librustc_typeck/check/method  folder", "tree": {"sha": "33509a295f05a6fb3f2c4e9a0cfba8a67dd7297e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33509a295f05a6fb3f2c4e9a0cfba8a67dd7297e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf", "html_url": "https://github.com/rust-lang/rust/commit/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26d8b6f762a5d2ebd2939cb8e7fe4bea949350f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/26d8b6f762a5d2ebd2939cb8e7fe4bea949350f4", "html_url": "https://github.com/rust-lang/rust/commit/26d8b6f762a5d2ebd2939cb8e7fe4bea949350f4"}, {"sha": "dcb6b15061ad5359d294d3c8484d857bd6884805", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcb6b15061ad5359d294d3c8484d857bd6884805", "html_url": "https://github.com/rust-lang/rust/commit/dcb6b15061ad5359d294d3c8484d857bd6884805"}], "stats": {"total": 1114, "additions": 565, "deletions": 549}, "files": [{"sha": "722089cd50c0ce99e3bf1c2289fb42cdcef041b2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 142, "deletions": 146, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf", "patch": "@@ -23,7 +23,7 @@ use rustc::hir;\n \n use std::ops::Deref;\n \n-struct ConfirmContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a>{\n+struct ConfirmContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     self_expr: &'gcx hir::Expr,\n@@ -55,8 +55,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           unadjusted_self_ty: Ty<'tcx>,\n                           pick: probe::Pick<'tcx>,\n                           supplied_method_types: Vec<Ty<'tcx>>)\n-                          -> ty::MethodCallee<'tcx>\n-    {\n+                          -> ty::MethodCallee<'tcx> {\n         debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, supplied_method_types={:?})\",\n                unadjusted_self_ty,\n                pick,\n@@ -72,17 +71,20 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n            span: Span,\n            self_expr: &'gcx hir::Expr,\n            call_expr: &'gcx hir::Expr)\n-           -> ConfirmContext<'a, 'gcx, 'tcx>\n-    {\n-        ConfirmContext { fcx: fcx, span: span, self_expr: self_expr, call_expr: call_expr }\n+           -> ConfirmContext<'a, 'gcx, 'tcx> {\n+        ConfirmContext {\n+            fcx: fcx,\n+            span: span,\n+            self_expr: self_expr,\n+            call_expr: call_expr,\n+        }\n     }\n \n     fn confirm(&mut self,\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n                supplied_method_types: Vec<Ty<'tcx>>)\n-               -> ty::MethodCallee<'tcx>\n-    {\n+               -> ty::MethodCallee<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n \n@@ -91,18 +93,13 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Create substitutions for the method's type parameters.\n         let rcvr_substs = self.fresh_receiver_substs(self_ty, &pick);\n-        let all_substs =\n-            self.instantiate_method_substs(\n-                &pick,\n-                supplied_method_types,\n-                rcvr_substs);\n+        let all_substs = self.instantiate_method_substs(&pick, supplied_method_types, rcvr_substs);\n \n         debug!(\"all_substs={:?}\", all_substs);\n \n         // Create the final signature for the method, replacing late-bound regions.\n-        let InstantiatedMethodSig {\n-            method_sig, method_predicates\n-        } = self.instantiate_method_sig(&pick, all_substs);\n+        let InstantiatedMethodSig { method_sig, method_predicates } =\n+            self.instantiate_method_sig(&pick, all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n@@ -111,12 +108,13 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Create the method type\n         let def_id = pick.item.def_id();\n         let method_ty = pick.item.as_opt_method().unwrap();\n-        let fty = self.tcx.mk_fn_def(def_id, all_substs,\n+        let fty = self.tcx.mk_fn_def(def_id,\n+                                     all_substs,\n                                      self.tcx.mk_bare_fn(ty::BareFnTy {\n-            sig: ty::Binder(method_sig),\n-            unsafety: method_ty.fty.unsafety,\n-            abi: method_ty.fty.abi.clone(),\n-        }));\n+                                         sig: ty::Binder(method_sig),\n+                                         unsafety: method_ty.fty.unsafety,\n+                                         abi: method_ty.fty.abi.clone(),\n+                                     }));\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n         self.add_obligations(fty, all_substs, &method_predicates);\n@@ -125,7 +123,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let callee = ty::MethodCallee {\n             def_id: def_id,\n             ty: fty,\n-            substs: all_substs\n+            substs: all_substs,\n         };\n \n         if let Some(hir::MutMutable) = pick.autoref {\n@@ -141,14 +139,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn adjust_self_ty(&mut self,\n                       unadjusted_self_ty: Ty<'tcx>,\n                       pick: &probe::Pick<'tcx>)\n-                      -> Ty<'tcx>\n-    {\n+                      -> Ty<'tcx> {\n         let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n             let autoref = AutoPtr(region, mutbl);\n-            (Some(autoref), pick.unsize.map(|target| {\n-                target.adjust_for_autoref(self.tcx, Some(autoref))\n-            }))\n+            (Some(autoref),\n+             pick.unsize.map(|target| target.adjust_for_autoref(self.tcx, Some(autoref))))\n         } else {\n             // No unsizing should be performed without autoref (at\n             // least during method dispach). This is because we\n@@ -168,11 +164,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         autoderef.finalize(LvaluePreference::NoPreference, Some(self.self_expr));\n \n         // Write out the final adjustment.\n-        self.write_adjustment(self.self_expr.id, AdjustDerefRef(AutoDerefRef {\n-            autoderefs: pick.autoderefs,\n-            autoref: autoref,\n-            unsize: unsize\n-        }));\n+        self.write_adjustment(self.self_expr.id,\n+                              AdjustDerefRef(AutoDerefRef {\n+                                  autoderefs: pick.autoderefs,\n+                                  autoref: autoref,\n+                                  unsize: unsize,\n+                              }));\n \n         if let Some(target) = unsize {\n             target\n@@ -193,13 +190,13 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn fresh_receiver_substs(&mut self,\n                              self_ty: Ty<'tcx>,\n                              pick: &probe::Pick<'tcx>)\n-                             -> &'tcx Substs<'tcx>\n-    {\n+                             -> &'tcx Substs<'tcx> {\n         match pick.kind {\n             probe::InherentImplPick => {\n                 let impl_def_id = pick.item.container().id();\n                 assert!(self.tcx.impl_trait_ref(impl_def_id).is_none(),\n-                        \"impl {:?} is not an inherent impl\", impl_def_id);\n+                        \"impl {:?} is not an inherent impl\",\n+                        impl_def_id);\n                 self.impl_self_ty(self.span, impl_def_id).substs\n             }\n \n@@ -216,10 +213,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // argument type), but those cases have already\n                     // been ruled out when we deemed the trait to be\n                     // \"object safe\".\n-                    let original_poly_trait_ref =\n-                        principal.with_self_ty(this.tcx, object_ty);\n-                    let upcast_poly_trait_ref =\n-                        this.upcast(original_poly_trait_ref, trait_def_id);\n+                    let original_poly_trait_ref = principal.with_self_ty(this.tcx, object_ty);\n+                    let upcast_poly_trait_ref = this.upcast(original_poly_trait_ref, trait_def_id);\n                     let upcast_trait_ref =\n                         this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n                     debug!(\"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n@@ -242,10 +237,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 // the impl ([$A,$B,$C]) not the receiver type ([$C]).\n                 let impl_polytype = self.impl_self_ty(self.span, impl_def_id);\n                 let impl_trait_ref =\n-                    self.instantiate_type_scheme(\n-                        self.span,\n-                        impl_polytype.substs,\n-                        &self.tcx.impl_trait_ref(impl_def_id).unwrap());\n+                    self.instantiate_type_scheme(self.span,\n+                                                 impl_polytype.substs,\n+                                                 &self.tcx.impl_trait_ref(impl_def_id).unwrap());\n                 impl_trait_ref.substs\n             }\n \n@@ -268,20 +262,20 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn extract_existential_trait_ref<R, F>(&mut self,\n-                                           self_ty: Ty<'tcx>,\n-                                           mut closure: F) -> R\n+    fn extract_existential_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R\n         where F: FnMut(&mut ConfirmContext<'a, 'gcx, 'tcx>,\n                        Ty<'tcx>,\n-                       ty::PolyExistentialTraitRef<'tcx>) -> R,\n+                       ty::PolyExistentialTraitRef<'tcx>)\n+                       -> R\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to\n         // yield an object-type (e.g., `&Object` or `Box<Object>`\n         // etc).\n \n         // FIXME: this feels, like, super dubious\n-        self.fcx.autoderef(self.span, self_ty)\n+        self.fcx\n+            .autoderef(self.span, self_ty)\n             .filter_map(|(ty, _)| {\n                 match ty.sty {\n                     ty::TyTrait(ref data) => Some(closure(self, ty, data.principal)),\n@@ -290,19 +284,17 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             })\n             .next()\n             .unwrap_or_else(|| {\n-                span_bug!(\n-                    self.span,\n-                    \"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                    self_ty)\n+                span_bug!(self.span,\n+                          \"self-type `{}` for ObjectPick never dereferenced to an object\",\n+                          self_ty)\n             })\n     }\n \n     fn instantiate_method_substs(&mut self,\n                                  pick: &probe::Pick<'tcx>,\n                                  mut supplied_method_types: Vec<Ty<'tcx>>,\n                                  substs: &Substs<'tcx>)\n-                                 -> &'tcx Substs<'tcx>\n-    {\n+                                 -> &'tcx Substs<'tcx> {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n@@ -312,23 +304,24 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         if num_supplied_types > 0 && num_supplied_types != num_method_types {\n             if num_method_types == 0 {\n-                struct_span_err!(self.tcx.sess, self.span, E0035,\n+                struct_span_err!(self.tcx.sess,\n+                                 self.span,\n+                                 E0035,\n                                  \"does not take type parameters\")\n                     .span_label(self.span, &\"called with unneeded type parameters\")\n                     .emit();\n             } else {\n-                struct_span_err!(self.tcx.sess, self.span, E0036,\n-                    \"incorrect number of type parameters given for this method: \\\n-                     expected {}, found {}\",\n-                    num_method_types, num_supplied_types)\n+                struct_span_err!(self.tcx.sess,\n+                                 self.span,\n+                                 E0036,\n+                                 \"incorrect number of type parameters given for this method: \\\n+                                  expected {}, found {}\",\n+                                 num_method_types,\n+                                 num_supplied_types)\n                     .span_label(self.span,\n                                 &format!(\"Passed {} type argument{}, expected {}\",\n                                          num_supplied_types,\n-                                         if num_supplied_types != 1 {\n-                                            \"s\"\n-                                         } else {\n-                                            \"\"\n-                                         },\n+                                         if num_supplied_types != 1 { \"s\" } else { \"\" },\n                                          num_method_types))\n                     .emit();\n             }\n@@ -340,14 +333,17 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         //\n         // FIXME -- permit users to manually specify lifetimes\n         let supplied_start = substs.params().len() + method.generics.regions.len();\n-        Substs::for_item(self.tcx, method.def_id, |def, _| {\n+        Substs::for_item(self.tcx,\n+                         method.def_id,\n+                         |def, _| {\n             let i = def.index as usize;\n             if i < substs.params().len() {\n                 substs.region_at(i)\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n-        }, |def, cur_substs| {\n+        },\n+                         |def, cur_substs| {\n             let i = def.index as usize;\n             if i < substs.params().len() {\n                 substs.type_at(i)\n@@ -359,21 +355,17 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn unify_receivers(&mut self,\n-                       self_ty: Ty<'tcx>,\n-                       method_self_ty: Ty<'tcx>)\n-    {\n-        match self.sub_types(false, TypeOrigin::Misc(self.span),\n-                             self_ty, method_self_ty) {\n+    fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {\n+        match self.sub_types(false, TypeOrigin::Misc(self.span), self_ty, method_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n             }\n             Err(_) => {\n-                span_bug!(\n-                    self.span,\n-                    \"{} was a subtype of {} but now is not?\",\n-                    self_ty, method_self_ty);\n+                span_bug!(self.span,\n+                          \"{} was a subtype of {} but now is not?\",\n+                          self_ty,\n+                          method_self_ty);\n             }\n         }\n     }\n@@ -384,37 +376,39 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick<'tcx>,\n                               all_substs: &'tcx Substs<'tcx>)\n-                              -> InstantiatedMethodSig<'tcx>\n-    {\n+                              -> InstantiatedMethodSig<'tcx> {\n         debug!(\"instantiate_method_sig(pick={:?}, all_substs={:?})\",\n                pick,\n                all_substs);\n \n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n-        let method_predicates = pick.item.as_opt_method().unwrap()\n-                                    .predicates.instantiate(self.tcx, all_substs);\n-        let method_predicates = self.normalize_associated_types_in(self.span,\n-                                                                   &method_predicates);\n+        let method_predicates = pick.item\n+            .as_opt_method()\n+            .unwrap()\n+            .predicates\n+            .instantiate(self.tcx, all_substs);\n+        let method_predicates = self.normalize_associated_types_in(self.span, &method_predicates);\n \n-        debug!(\"method_predicates after subst = {:?}\",\n-               method_predicates);\n+        debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(\n-            &pick.item.as_opt_method().unwrap().fty.sig);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&pick.item\n+            .as_opt_method()\n+            .unwrap()\n+            .fty\n+            .sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n                method_sig);\n \n         let method_sig = self.instantiate_type_scheme(self.span, all_substs, &method_sig);\n-        debug!(\"type scheme substituted, method_sig={:?}\",\n-               method_sig);\n+        debug!(\"type scheme substituted, method_sig={:?}\", method_sig);\n \n         InstantiatedMethodSig {\n             method_sig: method_sig,\n@@ -431,9 +425,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                all_substs,\n                method_predicates);\n \n-        self.add_obligations_for_parameters(\n-            traits::ObligationCause::misc(self.span, self.body_id),\n-            method_predicates);\n+        self.add_obligations_for_parameters(traits::ObligationCause::misc(self.span, self.body_id),\n+                                            method_predicates);\n \n         // this is a projection from a trait reference, so we have to\n         // make sure that the trait reference inputs are well-formed.\n@@ -472,21 +465,24 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n             let autoderef_count = match self.tables\n-                                            .borrow()\n-                                            .adjustments\n-                                            .get(&expr.id) {\n+                .borrow()\n+                .adjustments\n+                .get(&expr.id) {\n                 Some(&AdjustDerefRef(ref adj)) => adj.autoderefs,\n                 Some(_) | None => 0,\n             };\n \n             debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?} \\\n                                                       autoderef_count={}\",\n-                   i, expr, autoderef_count);\n+                   i,\n+                   expr,\n+                   autoderef_count);\n \n             if autoderef_count > 0 {\n                 let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n                 autoderef.nth(autoderef_count).unwrap_or_else(|| {\n-                    span_bug!(expr.span, \"expr was deref-able {} times but now isn't?\",\n+                    span_bug!(expr.span,\n+                              \"expr was deref-able {} times but now isn't?\",\n                               autoderef_count);\n                 });\n                 autoderef.finalize(PreferMutLvalue, Some(expr));\n@@ -508,53 +504,54 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // (ab)use the normal type checking paths.\n                     let adj = self.tables.borrow().adjustments.get(&base_expr.id).cloned();\n                     let (autoderefs, unsize) = match adj {\n-                        Some(AdjustDerefRef(adr)) => match adr.autoref {\n-                            None => {\n-                                assert!(adr.unsize.is_none());\n-                                (adr.autoderefs, None)\n-                            }\n-                            Some(AutoPtr(..)) => {\n-                                (adr.autoderefs, adr.unsize.map(|target| {\n-                                    target.builtin_deref(false, NoPreference)\n-                                            .expect(\"fixup: AutoPtr is not &T\").ty\n-                                }))\n+                        Some(AdjustDerefRef(adr)) => {\n+                            match adr.autoref {\n+                                None => {\n+                                    assert!(adr.unsize.is_none());\n+                                    (adr.autoderefs, None)\n+                                }\n+                                Some(AutoPtr(..)) => {\n+                                    (adr.autoderefs,\n+                                     adr.unsize.map(|target| {\n+                                         target.builtin_deref(false, NoPreference)\n+                                             .expect(\"fixup: AutoPtr is not &T\")\n+                                             .ty\n+                                     }))\n+                                }\n+                                Some(_) => {\n+                                    span_bug!(base_expr.span,\n+                                              \"unexpected adjustment autoref {:?}\",\n+                                              adr);\n+                                }\n                             }\n-                            Some(_) => {\n-                                span_bug!(\n-                                    base_expr.span,\n-                                    \"unexpected adjustment autoref {:?}\",\n-                                    adr);\n-                            }\n-                        },\n+                        }\n                         None => (0, None),\n                         Some(_) => {\n-                            span_bug!(\n-                                base_expr.span,\n-                                \"unexpected adjustment type\");\n+                            span_bug!(base_expr.span, \"unexpected adjustment type\");\n                         }\n                     };\n \n                     let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n                         (target, true)\n                     } else {\n                         (self.adjust_expr_ty(base_expr,\n-                            Some(&AdjustDerefRef(AutoDerefRef {\n-                                autoderefs: autoderefs,\n-                                autoref: None,\n-                                unsize: None\n-                            }))), false)\n+                                             Some(&AdjustDerefRef(AutoDerefRef {\n+                                                 autoderefs: autoderefs,\n+                                                 autoref: None,\n+                                                 unsize: None,\n+                                             }))),\n+                         false)\n                     };\n                     let index_expr_ty = self.node_ty(index_expr.id);\n \n-                    let result = self.try_index_step(\n-                        ty::MethodCall::expr(expr.id),\n-                        expr,\n-                        &base_expr,\n-                        adjusted_base_ty,\n-                        autoderefs,\n-                        unsize,\n-                        PreferMutLvalue,\n-                        index_expr_ty);\n+                    let result = self.try_index_step(ty::MethodCall::expr(expr.id),\n+                                                     expr,\n+                                                     &base_expr,\n+                                                     adjusted_base_ty,\n+                                                     autoderefs,\n+                                                     unsize,\n+                                                     PreferMutLvalue,\n+                                                     index_expr_ty);\n \n                     if let Some((input_ty, return_ty)) = result {\n                         self.demand_suptype(index_expr.span, input_ty, index_expr_ty);\n@@ -569,9 +566,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     let method_call = ty::MethodCall::expr(expr.id);\n                     if self.tables.borrow().method_map.contains_key(&method_call) {\n                         let method = self.try_overloaded_deref(expr.span,\n-                            Some(&base_expr),\n-                            self.node_ty(base_expr.id),\n-                            PreferMutLvalue);\n+                                                               Some(&base_expr),\n+                                                               self.node_ty(base_expr.id),\n+                                                               PreferMutLvalue);\n                         let method = method.expect(\"re-trying deref failed\");\n                         self.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n@@ -597,28 +594,27 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn upcast(&mut self,\n               source_trait_ref: ty::PolyTraitRef<'tcx>,\n               target_trait_def_id: DefId)\n-              -> ty::PolyTraitRef<'tcx>\n-    {\n-        let upcast_trait_refs = self.tcx.upcast_choices(source_trait_ref.clone(),\n-                                                        target_trait_def_id);\n+              -> ty::PolyTraitRef<'tcx> {\n+        let upcast_trait_refs = self.tcx\n+            .upcast_choices(source_trait_ref.clone(), target_trait_def_id);\n \n         // must be exactly one trait ref or we'd get an ambig error etc\n         if upcast_trait_refs.len() != 1 {\n-            span_bug!(\n-                self.span,\n-                \"cannot uniquely upcast `{:?}` to `{:?}`: `{:?}`\",\n-                source_trait_ref,\n-                target_trait_def_id,\n-                upcast_trait_refs);\n+            span_bug!(self.span,\n+                      \"cannot uniquely upcast `{:?}` to `{:?}`: `{:?}`\",\n+                      source_trait_ref,\n+                      target_trait_def_id,\n+                      upcast_trait_refs);\n         }\n \n         upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T\n-        where T : TypeFoldable<'tcx>\n+        where T: TypeFoldable<'tcx>\n     {\n-        self.fcx.replace_late_bound_regions_with_fresh_var(\n-            self.span, infer::FnCall, value).0\n+        self.fcx\n+            .replace_late_bound_regions_with_fresh_var(self.span, infer::FnCall, value)\n+            .0\n     }\n }"}, {"sha": "f084b85a45f81ba735247291d445f9d717115a63", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf", "patch": "@@ -41,7 +41,8 @@ pub enum MethodError<'tcx> {\n     Ambiguity(Vec<CandidateSource>),\n \n     // Using a `Fn`/`FnMut`/etc method on a raw closure type before we have inferred its kind.\n-    ClosureAmbiguity(/* DefId of fn trait */ DefId),\n+    ClosureAmbiguity(// DefId of fn trait\n+                     DefId),\n \n     // Found an applicable method, but it is not visible.\n     PrivateMatch(Def),\n@@ -53,19 +54,20 @@ pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n     pub unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n     pub out_of_scope_traits: Vec<DefId>,\n-    pub mode: probe::Mode\n+    pub mode: probe::Mode,\n }\n \n impl<'tcx> NoMatchData<'tcx> {\n     pub fn new(static_candidates: Vec<CandidateSource>,\n                unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n                out_of_scope_traits: Vec<DefId>,\n-               mode: probe::Mode) -> Self {\n+               mode: probe::Mode)\n+               -> Self {\n         NoMatchData {\n             static_candidates: static_candidates,\n             unsatisfied_predicates: unsatisfied_predicates,\n             out_of_scope_traits: out_of_scope_traits,\n-            mode: mode\n+            mode: mode,\n         }\n     }\n }\n@@ -75,7 +77,8 @@ impl<'tcx> NoMatchData<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum CandidateSource {\n     ImplSource(DefId),\n-    TraitSource(/* trait id */ DefId),\n+    TraitSource(// trait id\n+                DefId),\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -86,8 +89,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          self_ty: ty::Ty<'tcx>,\n                          call_expr_id: ast::NodeId,\n                          allow_private: bool)\n-                         -> bool\n-    {\n+                         -> bool {\n         let mode = probe::Mode::MethodCall;\n         match self.probe_method(span, mode, method_name, self_ty, call_expr_id) {\n             Ok(..) => true,\n@@ -119,8 +121,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          supplied_method_types: Vec<ty::Ty<'tcx>>,\n                          call_expr: &'gcx hir::Expr,\n                          self_expr: &'gcx hir::Expr)\n-                         -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>>\n-    {\n+                         -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n                method_name,\n                self_ty,\n@@ -135,7 +136,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n         }\n \n-        Ok(self.confirm_method(span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n+        Ok(self.confirm_method(span,\n+                               self_expr,\n+                               call_expr,\n+                               self_ty,\n+                               pick,\n+                               supplied_method_types))\n     }\n \n     pub fn lookup_method_in_trait(&self,\n@@ -145,10 +151,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   trait_def_id: DefId,\n                                   self_ty: ty::Ty<'tcx>,\n                                   opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                  -> Option<ty::MethodCallee<'tcx>>\n-    {\n-        self.lookup_method_in_trait_adjusted(span, self_expr, m_name, trait_def_id,\n-                                             0, false, self_ty, opt_input_types)\n+                                  -> Option<ty::MethodCallee<'tcx>> {\n+        self.lookup_method_in_trait_adjusted(span,\n+                                             self_expr,\n+                                             m_name,\n+                                             trait_def_id,\n+                                             0,\n+                                             false,\n+                                             self_ty,\n+                                             opt_input_types)\n     }\n \n     /// `lookup_in_trait_adjusted` is used for overloaded operators.\n@@ -171,8 +182,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            unsize: bool,\n                                            self_ty: ty::Ty<'tcx>,\n                                            opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n-                                           -> Option<ty::MethodCallee<'tcx>>\n-    {\n+                                           -> Option<ty::MethodCallee<'tcx>> {\n         debug!(\"lookup_in_trait_adjusted(self_ty={:?}, self_expr={:?}, \\\n                 m_name={}, trait_def_id={:?})\",\n                self_ty,\n@@ -188,9 +198,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(trait_def.generics.regions.is_empty());\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n-            self.region_var_for_def(span, def)\n-        }, |def, substs| {\n+        let substs = Substs::for_item(self.tcx,\n+                                      trait_def_id,\n+                                      |def, _| self.region_var_for_def(span, def),\n+                                      |def, substs| {\n             if def.index == 0 {\n                 self_ty\n             } else if let Some(ref input_types) = opt_input_types {\n@@ -204,9 +215,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Construct an obligation\n         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-        let obligation = traits::Obligation::misc(span,\n-                                                  self.body_id,\n-                                                  poly_trait_ref.to_predicate());\n+        let obligation =\n+            traits::Obligation::misc(span, self.body_id, poly_trait_ref.to_predicate());\n \n         // Now we want to know if this can be matched\n         let mut selcx = traits::SelectionContext::new(self);\n@@ -224,26 +234,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert_eq!(method_ty.generics.regions.len(), 0);\n \n         debug!(\"lookup_in_trait_adjusted: method_item={:?} method_ty={:?}\",\n-               method_item, method_ty);\n+               method_item,\n+               method_ty);\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n-                                                                    infer::FnCall,\n-                                                                    &method_ty.fty.sig).0;\n+        let fn_sig =\n+            self.replace_late_bound_regions_with_fresh_var(span, infer::FnCall, &method_ty.fty.sig)\n+                .0;\n         let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n         let transformed_self_ty = fn_sig.inputs[0];\n         let def_id = method_item.def_id();\n-        let fty = tcx.mk_fn_def(def_id, trait_ref.substs,\n+        let fty = tcx.mk_fn_def(def_id,\n+                                trait_ref.substs,\n                                 tcx.mk_bare_fn(ty::BareFnTy {\n-            sig: ty::Binder(fn_sig),\n-            unsafety: method_ty.fty.unsafety,\n-            abi: method_ty.fty.abi.clone(),\n-        }));\n+                                    sig: ty::Binder(fn_sig),\n+                                    unsafety: method_ty.fty.unsafety,\n+                                    abi: method_ty.fty.abi.clone(),\n+                                }));\n \n         debug!(\"lookup_in_trait_adjusted: matched method fty={:?} obligation={:?}\",\n                fty,\n@@ -259,9 +271,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // any late-bound regions appearing in its bounds.\n         let method_bounds = self.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n         assert!(!method_bounds.has_escaping_regions());\n-        self.add_obligations_for_parameters(\n-            traits::ObligationCause::misc(span, self.body_id),\n-            &method_bounds);\n+        self.add_obligations_for_parameters(traits::ObligationCause::misc(span, self.body_id),\n+                                            &method_bounds);\n \n         // Also register an obligation for the method type being well-formed.\n         self.register_wf_obligation(fty, span, traits::MiscObligation);\n@@ -273,12 +284,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Insert any adjustments needed (always an autoref of some mutability).\n         match self_expr {\n-            None => { }\n+            None => {}\n \n             Some(self_expr) => {\n                 debug!(\"lookup_in_trait_adjusted: inserting adjustment if needed \\\n                        (self-id={}, autoderefs={}, unsize={}, explicit_self={:?})\",\n-                       self_expr.id, autoderefs, unsize,\n+                       self_expr.id,\n+                       autoderefs,\n+                       unsize,\n                        method_ty.explicit_self);\n \n                 match method_ty.explicit_self {\n@@ -294,31 +307,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         match transformed_self_ty.sty {\n                             ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n                                 self.write_adjustment(self_expr.id,\n-                                    AdjustDerefRef(AutoDerefRef {\n-                                        autoderefs: autoderefs,\n-                                        autoref: Some(AutoPtr(region, mutbl)),\n-                                        unsize: if unsize {\n-                                            Some(transformed_self_ty)\n-                                        } else {\n-                                            None\n-                                        }\n-                                    }));\n+                                                      AdjustDerefRef(AutoDerefRef {\n+                                                          autoderefs: autoderefs,\n+                                                          autoref: Some(AutoPtr(region, mutbl)),\n+                                                          unsize: if unsize {\n+                                                              Some(transformed_self_ty)\n+                                                          } else {\n+                                                              None\n+                                                          },\n+                                                      }));\n                             }\n \n                             _ => {\n-                                span_bug!(\n-                                    span,\n-                                    \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty);\n+                                span_bug!(span,\n+                                          \"trait method is &self but first arg is: {}\",\n+                                          transformed_self_ty);\n                             }\n                         }\n                     }\n \n                     _ => {\n-                        span_bug!(\n-                            span,\n-                            \"unexpected explicit self type in operator method: {:?}\",\n-                            method_ty.explicit_self);\n+                        span_bug!(span,\n+                                  \"unexpected explicit self type in operator method: {:?}\",\n+                                  method_ty.explicit_self);\n                     }\n                 }\n             }\n@@ -327,7 +338,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let callee = ty::MethodCallee {\n             def_id: def_id,\n             ty: fty,\n-            substs: trait_ref.substs\n+            substs: trait_ref.substs,\n         };\n \n         debug!(\"callee = {:?}\", callee);\n@@ -340,8 +351,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         method_name: ast::Name,\n                         self_ty: ty::Ty<'tcx>,\n                         expr_id: ast::NodeId)\n-                        -> Result<Def, MethodError<'tcx>>\n-    {\n+                        -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n         let pick = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n \n@@ -364,9 +374,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn impl_or_trait_item(&self,\n                               def_id: DefId,\n                               item_name: ast::Name)\n-                              -> Option<ty::ImplOrTraitItem<'tcx>>\n-    {\n-        self.tcx.impl_or_trait_items(def_id)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>> {\n+        self.tcx\n+            .impl_or_trait_items(def_id)\n             .iter()\n             .map(|&did| self.tcx.impl_or_trait_item(did))\n             .find(|m| m.name() == item_name)"}, {"sha": "43837de2f345d2ec1b22a23dd7198fa441ad9560", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 224, "deletions": 241, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf", "patch": "@@ -13,7 +13,7 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n-use check::{FnCtxt};\n+use check::FnCtxt;\n use hir::def_id::DefId;\n use hir::def::Def;\n use rustc::ty::subst::{Subst, Substs};\n@@ -31,7 +31,7 @@ use std::rc::Rc;\n use self::CandidateKind::*;\n pub use self::PickKind::*;\n \n-struct ProbeContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     mode: Mode,\n@@ -52,7 +52,7 @@ struct ProbeContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n-    unsatisfied_predicates: Vec<TraitRef<'tcx>>\n+    unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n@@ -66,7 +66,7 @@ impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n struct CandidateStep<'tcx> {\n     self_ty: Ty<'tcx>,\n     autoderefs: usize,\n-    unsize: bool\n+    unsize: bool,\n }\n \n #[derive(Debug)]\n@@ -80,12 +80,17 @@ struct Candidate<'tcx> {\n #[derive(Debug)]\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(&'tcx Substs<'tcx>,\n-                          /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n-    ExtensionImplCandidate(/* Impl */ DefId, &'tcx Substs<'tcx>,\n-                           /* Normalize obligations */ Vec<traits::PredicateObligation<'tcx>>),\n+                          // Normalize obligations\n+                          Vec<traits::PredicateObligation<'tcx>>),\n+    ExtensionImplCandidate(// Impl\n+                           DefId,\n+                           &'tcx Substs<'tcx>,\n+                           // Normalize obligations\n+                           Vec<traits::PredicateObligation<'tcx>>),\n     ObjectCandidate,\n     TraitCandidate,\n-    WhereClauseCandidate(/* Trait */ ty::PolyTraitRef<'tcx>),\n+    WhereClauseCandidate(// Trait\n+                         ty::PolyTraitRef<'tcx>),\n }\n \n #[derive(Debug)]\n@@ -115,10 +120,12 @@ pub struct Pick<'tcx> {\n #[derive(Clone,Debug)]\n pub enum PickKind<'tcx> {\n     InherentImplPick,\n-    ExtensionImplPick(/* Impl */ DefId),\n+    ExtensionImplPick(// Impl\n+                      DefId),\n     ObjectPick,\n     TraitPick,\n-    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>),\n+    WhereClausePick(// Trait\n+                    ty::PolyTraitRef<'tcx>),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError<'tcx>>;\n@@ -132,7 +139,7 @@ pub enum Mode {\n     // An expression of the form `Type::item` or `<T>::item`.\n     // No autoderefs are performed, lookup is done based on the type each\n     // implementation is for, and static methods are included.\n-    Path\n+    Path,\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -142,8 +149,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         item_name: ast::Name,\n                         self_ty: Ty<'tcx>,\n                         scope_expr_id: ast::NodeId)\n-                        -> PickResult<'tcx>\n-    {\n+                        -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n                self_ty,\n                item_name,\n@@ -159,31 +165,38 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let steps = if mode == Mode::MethodCall {\n             match self.create_steps(span, self_ty) {\n                 Some(steps) => steps,\n-                None =>return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(), Vec::new(),\n-                                                                        Vec::new(), mode))),\n+                None => {\n+                    return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n+                                                                     Vec::new(),\n+                                                                     Vec::new(),\n+                                                                     mode)))\n+                }\n             }\n         } else {\n             vec![CandidateStep {\n-                self_ty: self_ty,\n-                autoderefs: 0,\n-                unsize: false\n-            }]\n+                     self_ty: self_ty,\n+                     autoderefs: 0,\n+                     unsize: false,\n+                 }]\n         };\n \n         // Create a list of simplified self types, if we can.\n         let mut simplified_steps = Vec::new();\n         for step in &steps {\n             match ty::fast_reject::simplify_type(self.tcx, step.self_ty, true) {\n-                None => { break; }\n-                Some(simplified_type) => { simplified_steps.push(simplified_type); }\n+                None => {\n+                    break;\n+                }\n+                Some(simplified_type) => {\n+                    simplified_steps.push(simplified_type);\n+                }\n             }\n         }\n-        let opt_simplified_steps =\n-            if simplified_steps.len() < steps.len() {\n-                None // failed to convert at least one of the steps\n-            } else {\n-                Some(simplified_steps)\n-            };\n+        let opt_simplified_steps = if simplified_steps.len() < steps.len() {\n+            None // failed to convert at least one of the steps\n+        } else {\n+            Some(simplified_steps)\n+        };\n \n         debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n                self_ty,\n@@ -192,31 +205,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // this creates one big transaction so that all type variables etc\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n-            let mut probe_cx = ProbeContext::new(self,\n-                                                 span,\n-                                                 mode,\n-                                                 item_name,\n-                                                 steps,\n-                                                 opt_simplified_steps);\n+            let mut probe_cx =\n+                ProbeContext::new(self, span, mode, item_name, steps, opt_simplified_steps);\n             probe_cx.assemble_inherent_candidates();\n             probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n             probe_cx.pick()\n         })\n     }\n \n-    fn create_steps(&self,\n-                    span: Span,\n-                    self_ty: Ty<'tcx>)\n-                    -> Option<Vec<CandidateStep<'tcx>>>\n-    {\n+    fn create_steps(&self, span: Span, self_ty: Ty<'tcx>) -> Option<Vec<CandidateStep<'tcx>>> {\n         // FIXME: we don't need to create the entire steps in one pass\n \n         let mut autoderef = self.autoderef(span, self_ty);\n-        let mut steps: Vec<_> = autoderef.by_ref().map(|(ty, d)| CandidateStep {\n-            self_ty: ty,\n-            autoderefs: d,\n-            unsize: false\n-        }).collect();\n+        let mut steps: Vec<_> = autoderef.by_ref()\n+            .map(|(ty, d)| {\n+                CandidateStep {\n+                    self_ty: ty,\n+                    autoderefs: d,\n+                    unsize: false,\n+                }\n+            })\n+            .collect();\n \n         let final_ty = autoderef.unambiguous_final_ty();\n         match final_ty.sty {\n@@ -226,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 steps.push(CandidateStep {\n                     self_ty: self.tcx.mk_slice(elem_ty),\n                     autoderefs: dereferences,\n-                    unsize: true\n+                    unsize: true,\n                 });\n             }\n             ty::TyError => return None,\n@@ -246,8 +255,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n            item_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>)\n-           -> ProbeContext<'a, 'gcx, 'tcx>\n-    {\n+           -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx: fcx,\n             span: span,\n@@ -284,8 +292,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n-        debug!(\"assemble_probe: self_ty={:?}\",\n-               self_ty);\n+        debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n \n         match self_ty.sty {\n             ty::TyTrait(box ref data) => {\n@@ -371,8 +378,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = self.tcx.lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            _ => {\n-            }\n+            _ => {}\n         }\n     }\n \n@@ -405,7 +411,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let item = match self.impl_or_trait_item(impl_def_id) {\n             Some(m) => m,\n-            None => { return; } // No method with correct name on this impl\n+            None => {\n+                return;\n+            } // No method with correct name on this impl\n         };\n \n         if !self.has_applicable_self(&item) {\n@@ -415,7 +423,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         if !item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n             self.private_candidate = Some(item.def());\n-            return\n+            return;\n         }\n \n         let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n@@ -458,9 +466,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n-            let xform_self_ty = this.xform_self_ty(&item,\n-                                                   new_trait_ref.self_ty(),\n-                                                   new_trait_ref.substs);\n+            let xform_self_ty =\n+                this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -476,8 +483,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n-        let bounds: Vec<_> =\n-            self.parameter_environment.caller_bounds\n+        let bounds: Vec<_> = self.parameter_environment\n+            .caller_bounds\n             .iter()\n             .filter_map(|predicate| {\n                 match *predicate {\n@@ -486,7 +493,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             ty::TyParam(ref p) if *p == param_ty => {\n                                 Some(trait_predicate.to_poly_trait_ref())\n                             }\n-                            _ => None\n+                            _ => None,\n                         }\n                     }\n                     ty::Predicate::Equate(..) |\n@@ -495,21 +502,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::TypeOutlives(..) => {\n-                        None\n-                    }\n+                    ty::Predicate::TypeOutlives(..) => None,\n                 }\n             })\n             .collect();\n \n         self.elaborate_bounds(&bounds, |this, poly_trait_ref, item| {\n-            let trait_ref =\n-                this.erase_late_bound_regions(&poly_trait_ref);\n+            let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);\n \n-            let xform_self_ty =\n-                this.xform_self_ty(&item,\n-                                   trait_ref.self_ty(),\n-                                   trait_ref.substs);\n+            let xform_self_ty = this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n \n             if let Some(ref m) = item.as_opt_method() {\n                 debug!(\"found match: trait_ref={:?} substs={:?} m={:?}\",\n@@ -540,24 +541,20 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n-    fn elaborate_bounds<F>(\n-        &mut self,\n-        bounds: &[ty::PolyTraitRef<'tcx>],\n-        mut mk_cand: F,\n-    ) where\n-        F: for<'b> FnMut(\n-            &mut ProbeContext<'b, 'gcx, 'tcx>,\n-            ty::PolyTraitRef<'tcx>,\n-            ty::ImplOrTraitItem<'tcx>,\n-        ),\n+    fn elaborate_bounds<F>(&mut self, bounds: &[ty::PolyTraitRef<'tcx>], mut mk_cand: F)\n+        where F: for<'b> FnMut(&mut ProbeContext<'b, 'gcx, 'tcx>,\n+                               ty::PolyTraitRef<'tcx>,\n+                               ty::ImplOrTraitItem<'tcx>)\n     {\n         debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n \n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n             let item = match self.impl_or_trait_item(bound_trait_ref.def_id()) {\n                 Some(v) => v,\n-                None => { continue; }\n+                None => {\n+                    continue;\n+                }\n             };\n \n             if !self.has_applicable_self(&item) {\n@@ -570,8 +567,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n                                                          expr_id: ast::NodeId)\n-                                                         -> Result<(), MethodError<'tcx>>\n-    {\n+                                                         -> Result<(), MethodError<'tcx>> {\n         let mut duplicates = FnvHashSet();\n         let opt_applicable_traits = self.tcx.trait_map.get(&expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n@@ -600,20 +596,19 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_extension_candidates_for_trait(&mut self,\n                                                trait_def_id: DefId)\n-                                               -> Result<(), MethodError<'tcx>>\n-    {\n+                                               -> Result<(), MethodError<'tcx>> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n                trait_def_id);\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n-        let trait_items =\n-            self.tcx.trait_items(trait_def_id);\n-        let maybe_item =\n-            trait_items.iter()\n-                       .find(|item| item.name() == self.item_name);\n+        let trait_items = self.tcx.trait_items(trait_def_id);\n+        let maybe_item = trait_items.iter()\n+            .find(|item| item.name() == self.item_name);\n         let item = match maybe_item {\n             Some(i) => i,\n-            None => { return Ok(()); }\n+            None => {\n+                return Ok(());\n+            }\n         };\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n@@ -636,8 +631,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: DefId,\n-                                                     item: ty::ImplOrTraitItem<'tcx>)\n-    {\n+                                                     item: ty::ImplOrTraitItem<'tcx>) {\n         let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n@@ -655,18 +649,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             debug!(\"impl_substs={:?}\", impl_substs);\n \n-            let impl_trait_ref =\n-                self.tcx.impl_trait_ref(impl_def_id)\n+            let impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id)\n                 .unwrap() // we know this is a trait impl\n                 .subst(self.tcx, impl_substs);\n \n             debug!(\"impl_trait_ref={:?}\", impl_trait_ref);\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&item,\n-                                   impl_trait_ref.self_ty(),\n-                                   impl_trait_ref.substs);\n+                self.xform_self_ty(&item, impl_trait_ref.self_ty(), impl_trait_ref.substs);\n \n             // Normalize the receiver. We can't use normalize_associated_types_in\n             // as it will pollute the fcx's fulfillment context after this probe\n@@ -690,14 +681,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn impl_can_possibly_match(&self, impl_def_id: DefId) -> bool {\n         let simplified_steps = match self.opt_simplified_steps {\n             Some(ref simplified_steps) => simplified_steps,\n-            None => { return true; }\n+            None => {\n+                return true;\n+            }\n         };\n \n         let impl_type = self.tcx.lookup_item_type(impl_def_id);\n         let impl_simplified_type =\n             match ty::fast_reject::simplify_type(self.tcx, impl_type.ty, false) {\n                 Some(simplified_type) => simplified_type,\n-                None => { return true; }\n+                None => {\n+                    return true;\n+                }\n             };\n \n         simplified_steps.contains(&impl_simplified_type)\n@@ -706,8 +701,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: DefId,\n                                    item: ty::ImplOrTraitItem<'tcx>)\n-                                   -> Result<(), MethodError<'tcx>>\n-    {\n+                                   -> Result<(), MethodError<'tcx>> {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n         let tcx = self.tcx;\n         let kind = if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n@@ -746,19 +740,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // for the purposes of our method lookup, we only take\n             // receiver type into account, so we can just substitute\n             // fresh types here to use during substitution and subtyping.\n-            let substs = Substs::for_item(self.tcx, trait_def_id, |def, _| {\n-                self.region_var_for_def(self.span, def)\n-            }, |def, substs| {\n+            let substs = Substs::for_item(self.tcx,\n+                                          trait_def_id,\n+                                          |def, _| self.region_var_for_def(self.span, def),\n+                                          |def, substs| {\n                 if def.index == 0 {\n                     step.self_ty\n                 } else {\n                     self.type_var_for_def(self.span, def, substs)\n                 }\n             });\n \n-            let xform_self_ty = self.xform_self_ty(&item,\n-                                                   step.self_ty,\n-                                                   substs);\n+            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 item: item.clone(),\n@@ -772,48 +765,43 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: DefId,\n-                                      item: ty::ImplOrTraitItem<'tcx>)\n-    {\n+                                      item: ty::ImplOrTraitItem<'tcx>) {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={:?}, \\\n                item={:?})\",\n                trait_def_id,\n                item);\n \n         for step in self.steps.iter() {\n-            debug!(\"assemble_projection_candidates: step={:?}\",\n-                   step);\n+            debug!(\"assemble_projection_candidates: step={:?}\", step);\n \n             let (def_id, substs) = match step.self_ty.sty {\n-                ty::TyProjection(ref data) => {\n-                    (data.trait_ref.def_id, data.trait_ref.substs)\n-                }\n+                ty::TyProjection(ref data) => (data.trait_ref.def_id, data.trait_ref.substs),\n                 ty::TyAnon(def_id, substs) => (def_id, substs),\n                 _ => continue,\n             };\n \n             debug!(\"assemble_projection_candidates: def_id={:?} substs={:?}\",\n-                   def_id, substs);\n+                   def_id,\n+                   substs);\n \n             let trait_predicates = self.tcx.lookup_predicates(def_id);\n             let bounds = trait_predicates.instantiate(self.tcx, substs);\n             let predicates = bounds.predicates;\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n                    predicates);\n-            for poly_bound in\n-                traits::elaborate_predicates(self.tcx, predicates)\n+            for poly_bound in traits::elaborate_predicates(self.tcx, predicates)\n                 .filter_map(|p| p.to_opt_poly_trait_ref())\n-                .filter(|b| b.def_id() == trait_def_id)\n-            {\n+                .filter(|b| b.def_id() == trait_def_id) {\n                 let bound = self.erase_late_bound_regions(&poly_bound);\n \n                 debug!(\"assemble_projection_candidates: def_id={:?} substs={:?} bound={:?}\",\n-                       def_id, substs, bound);\n+                       def_id,\n+                       substs,\n+                       bound);\n \n                 if self.can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n-                    let xform_self_ty = self.xform_self_ty(&item,\n-                                                           bound.self_ty(),\n-                                                           bound.substs);\n+                    let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n \n                     debug!(\"assemble_projection_candidates: bound={:?} xform_self_ty={:?}\",\n                            bound,\n@@ -832,20 +820,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: DefId,\n-                                        item: ty::ImplOrTraitItem<'tcx>)\n-    {\n+                                        item: ty::ImplOrTraitItem<'tcx>) {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n \n         let caller_predicates = self.parameter_environment.caller_bounds.clone();\n         for poly_bound in traits::elaborate_predicates(self.tcx, caller_predicates)\n-                          .filter_map(|p| p.to_opt_poly_trait_ref())\n-                          .filter(|b| b.def_id() == trait_def_id)\n-        {\n+            .filter_map(|p| p.to_opt_poly_trait_ref())\n+            .filter(|b| b.def_id() == trait_def_id) {\n             let bound = self.erase_late_bound_regions(&poly_bound);\n-            let xform_self_ty = self.xform_self_ty(&item,\n-                                                   bound.self_ty(),\n-                                                   bound.substs);\n+            let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n \n             debug!(\"assemble_where_clause_candidates: bound={:?} xform_self_ty={:?}\",\n                    bound,\n@@ -882,19 +866,24 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.item.container().id()],\n-            Some(Err(MethodError::Ambiguity(v))) => v.into_iter().map(|source| {\n-                match source {\n-                    TraitSource(id) => id,\n-                    ImplSource(impl_id) => {\n-                        match tcx.trait_id_of_impl(impl_id) {\n-                            Some(id) => id,\n-                            None =>\n-                                span_bug!(span,\n-                                          \"found inherent method when looking at traits\")\n+            Some(Err(MethodError::Ambiguity(v))) => {\n+                v.into_iter()\n+                    .map(|source| {\n+                        match source {\n+                            TraitSource(id) => id,\n+                            ImplSource(impl_id) => {\n+                                match tcx.trait_id_of_impl(impl_id) {\n+                                    Some(id) => id,\n+                                    None => {\n+                                        span_bug!(span,\n+                                                  \"found inherent method when looking at traits\")\n+                                    }\n+                                }\n+                            }\n                         }\n-                    }\n-                }\n-            }).collect(),\n+                    })\n+                    .collect()\n+            }\n             Some(Err(MethodError::NoMatch(NoMatchData { out_of_scope_traits: others, .. }))) => {\n                 assert!(others.is_empty());\n                 vec![]\n@@ -910,8 +899,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return Err(MethodError::PrivateMatch(def));\n         }\n \n-        Err(MethodError::NoMatch(NoMatchData::new(static_candidates, unsatisfied_predicates,\n-                                                  out_of_scope_traits, self.mode)))\n+        Err(MethodError::NoMatch(NoMatchData::new(static_candidates,\n+                                                  unsatisfied_predicates,\n+                                                  out_of_scope_traits,\n+                                                  self.mode)))\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n@@ -935,64 +926,64 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.pick_autorefd_method(step)\n     }\n \n-    fn pick_by_value_method(&mut self,\n-                            step: &CandidateStep<'tcx>)\n-                            -> Option<PickResult<'tcx>>\n-    {\n-        /*!\n-         * For each type `T` in the step list, this attempts to find a\n-         * method where the (transformed) self type is exactly `T`. We\n-         * do however do one transformation on the adjustment: if we\n-         * are passing a region pointer in, we will potentially\n-         * *reborrow* it to a shorter lifetime. This allows us to\n-         * transparently pass `&mut` pointers, in particular, without\n-         * consuming them for their entire lifetime.\n-         */\n+    fn pick_by_value_method(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n+        //! For each type `T` in the step list, this attempts to find a\n+        //! method where the (transformed) self type is exactly `T`. We\n+        //! do however do one transformation on the adjustment: if we\n+        //! are passing a region pointer in, we will potentially\n+        //! *reborrow* it to a shorter lifetime. This allows us to\n+        //! transparently pass `&mut` pointers, in particular, without\n+        //! consuming them for their entire lifetime.\n \n         if step.unsize {\n             return None;\n         }\n \n-        self.pick_method(step.self_ty).map(|r| r.map(|mut pick| {\n-            pick.autoderefs = step.autoderefs;\n+        self.pick_method(step.self_ty).map(|r| {\n+            r.map(|mut pick| {\n+                pick.autoderefs = step.autoderefs;\n \n-            // Insert a `&*` or `&mut *` if this is a reference type:\n-            if let ty::TyRef(_, mt) = step.self_ty.sty {\n-                pick.autoderefs += 1;\n-                pick.autoref = Some(mt.mutbl);\n-            }\n+                // Insert a `&*` or `&mut *` if this is a reference type:\n+                if let ty::TyRef(_, mt) = step.self_ty.sty {\n+                    pick.autoderefs += 1;\n+                    pick.autoref = Some(mt.mutbl);\n+                }\n \n-            pick\n-        }))\n+                pick\n+            })\n+        })\n     }\n \n-    fn pick_autorefd_method(&mut self,\n-                            step: &CandidateStep<'tcx>)\n-                            -> Option<PickResult<'tcx>>\n-    {\n+    fn pick_autorefd_method(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n         let tcx = self.tcx;\n \n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n         let region = tcx.mk_region(ty::ReErased);\n \n         // Search through mutabilities in order to find one where pick works:\n-        [hir::MutImmutable, hir::MutMutable].iter().filter_map(|&m| {\n-            let autoref_ty = tcx.mk_ref(region, ty::TypeAndMut {\n-                ty: step.self_ty,\n-                mutbl: m\n-            });\n-            self.pick_method(autoref_ty).map(|r| r.map(|mut pick| {\n-                pick.autoderefs = step.autoderefs;\n-                pick.autoref = Some(m);\n-                pick.unsize = if step.unsize {\n-                    Some(step.self_ty)\n-                } else {\n-                    None\n-                };\n-                pick\n-            }))\n-        }).nth(0)\n+        [hir::MutImmutable, hir::MutMutable]\n+            .iter()\n+            .filter_map(|&m| {\n+                let autoref_ty = tcx.mk_ref(region,\n+                                            ty::TypeAndMut {\n+                                                ty: step.self_ty,\n+                                                mutbl: m,\n+                                            });\n+                self.pick_method(autoref_ty).map(|r| {\n+                    r.map(|mut pick| {\n+                        pick.autoderefs = step.autoderefs;\n+                        pick.autoref = Some(m);\n+                        pick.unsize = if step.unsize {\n+                            Some(step.self_ty)\n+                        } else {\n+                            None\n+                        };\n+                        pick\n+                    })\n+                })\n+            })\n+            .nth(0)\n     }\n \n     fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -1008,7 +999,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n \n         debug!(\"searching extension candidates\");\n-        let res = self.consider_candidates(self_ty, &self.extension_candidates,\n+        let res = self.consider_candidates(self_ty,\n+                                           &self.extension_candidates,\n                                            &mut possibly_unsatisfied_predicates);\n         if let None = res {\n             self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n@@ -1021,18 +1013,18 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                            probes: &[Candidate<'tcx>],\n                            possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n                            -> Option<PickResult<'tcx>> {\n-        let mut applicable_candidates: Vec<_> =\n-            probes.iter()\n-                  .filter(|&probe| self.consider_probe(self_ty,\n-                                                       probe,possibly_unsatisfied_predicates))\n-                  .collect();\n+        let mut applicable_candidates: Vec<_> = probes.iter()\n+            .filter(|&probe| self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n+            .collect();\n \n         debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n \n         if applicable_candidates.len() > 1 {\n             match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n-                Some(pick) => { return Some(Ok(pick)); }\n-                None => { }\n+                Some(pick) => {\n+                    return Some(Ok(pick));\n+                }\n+                None => {}\n             }\n         }\n \n@@ -1041,21 +1033,22 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        applicable_candidates.pop().map(|probe| {\n-            Ok(probe.to_unadjusted_pick())\n-        })\n+        applicable_candidates.pop().map(|probe| Ok(probe.to_unadjusted_pick()))\n     }\n \n-    fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>,\n-                      possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>) -> bool {\n-        debug!(\"consider_probe: self_ty={:?} probe={:?}\",\n-               self_ty,\n-               probe);\n+    fn consider_probe(&self,\n+                      self_ty: Ty<'tcx>,\n+                      probe: &Candidate<'tcx>,\n+                      possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n+                      -> bool {\n+        debug!(\"consider_probe: self_ty={:?} probe={:?}\", self_ty, probe);\n \n         self.probe(|_| {\n             // First check that the self type can be related.\n-            match self.sub_types(false, TypeOrigin::Misc(DUMMY_SP),\n-                                 self_ty, probe.xform_self_ty) {\n+            match self.sub_types(false,\n+                                 TypeOrigin::Misc(DUMMY_SP),\n+                                 self_ty,\n+                                 probe.xform_self_ty) {\n                 Ok(InferOk { obligations, .. }) => {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty())\n@@ -1093,14 +1086,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // Check whether the impl imposes obligations we have to worry about.\n             let impl_bounds = self.tcx.lookup_predicates(impl_def_id);\n             let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n-            let traits::Normalized { value: impl_bounds,\n-                                        obligations: norm_obligations } =\n+            let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n                 traits::normalize(selcx, cause.clone(), &impl_bounds);\n \n             // Convert the bounds into obligations.\n-            let obligations =\n-                traits::predicates_for_generics(cause.clone(),\n-                                                &impl_bounds);\n+            let obligations = traits::predicates_for_generics(cause.clone(), &impl_bounds);\n             debug!(\"impl_obligations={:?}\", obligations);\n \n             // Evaluate those obligations to see if they might possibly hold.\n@@ -1136,14 +1126,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///\n     /// Now imagine the receiver is `Vec<_>`. It doesn't really matter at this time which impl we\n     /// use, so it's ok to just commit to \"using the method from the trait Foo\".\n-    fn collapse_candidates_to_trait_pick(&self,\n-                                         probes: &[&Candidate<'tcx>])\n-                                         -> Option<Pick<'tcx>> {\n+    fn collapse_candidates_to_trait_pick(&self, probes: &[&Candidate<'tcx>]) -> Option<Pick<'tcx>> {\n         // Do all probes correspond to the same trait?\n         let container = probes[0].item.container();\n         match container {\n             ty::TraitContainer(_) => {}\n-            ty::ImplContainer(_) => return None\n+            ty::ImplContainer(_) => return None,\n         }\n         if probes[1..].iter().any(|p| p.item.container() != container) {\n             return None;\n@@ -1156,7 +1144,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             import_id: probes[0].import_id,\n             autoderefs: 0,\n             autoref: None,\n-            unsize: None\n+            unsize: None,\n         })\n     }\n \n@@ -1165,13 +1153,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {\n         // \"fast track\" -- check for usage of sugar\n         match *item {\n-            ty::ImplOrTraitItem::MethodTraitItem(ref method) =>\n+            ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n                 match method.explicit_self {\n                     ty::ExplicitSelfCategory::Static => self.mode == Mode::Path,\n                     ty::ExplicitSelfCategory::ByValue |\n                     ty::ExplicitSelfCategory::ByReference(..) |\n                     ty::ExplicitSelfCategory::ByBox => true,\n-                },\n+                }\n+            }\n             ty::ImplOrTraitItem::ConstTraitItem(..) => self.mode == Mode::Path,\n             _ => false,\n         }\n@@ -1191,11 +1180,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                      item: &ty::ImplOrTraitItem<'tcx>,\n                      impl_ty: Ty<'tcx>,\n                      substs: &Substs<'tcx>)\n-                     -> Ty<'tcx>\n-    {\n+                     -> Ty<'tcx> {\n         match item.as_opt_method() {\n-            Some(ref method) => self.xform_method_self_ty(method, impl_ty,\n-                                                          substs),\n+            Some(ref method) => self.xform_method_self_ty(method, impl_ty, substs),\n             None => impl_ty,\n         }\n     }\n@@ -1204,8 +1191,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             method: &Rc<ty::Method<'tcx>>,\n                             impl_ty: Ty<'tcx>,\n                             substs: &Substs<'tcx>)\n-                            -> Ty<'tcx>\n-    {\n+                            -> Ty<'tcx> {\n         debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n                impl_ty,\n                method.fty.sig.0.inputs.get(0),\n@@ -1218,8 +1204,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // are given do not include type/lifetime parameters for the\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n-        assert_eq!(substs.types().count(), method.generics.parent_types as usize);\n-        assert_eq!(substs.regions().count(), method.generics.parent_regions as usize);\n+        assert_eq!(substs.types().count(),\n+                   method.generics.parent_types as usize);\n+        assert_eq!(substs.regions().count(),\n+                   method.generics.parent_regions as usize);\n \n         if self.mode == Mode::Path {\n             return impl_ty;\n@@ -1233,7 +1221,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         if method.generics.types.is_empty() && method.generics.regions.is_empty() {\n             xform_self_ty.subst(self.tcx, substs)\n         } else {\n-            let substs = Substs::for_item(self.tcx, method.def_id, |def, _| {\n+            let substs = Substs::for_item(self.tcx,\n+                                          method.def_id,\n+                                          |def, _| {\n                 let i = def.index as usize;\n                 if i < substs.params().len() {\n                     substs.region_at(i)\n@@ -1242,7 +1232,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     // `impl_self_ty()` for an explanation.\n                     self.tcx.mk_region(ty::ReErased)\n                 }\n-            }, |def, cur_substs| {\n+            },\n+                                          |def, cur_substs| {\n                 let i = def.index as usize;\n                 if i < substs.params().len() {\n                     substs.type_at(i)\n@@ -1255,13 +1246,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n-    fn impl_ty_and_substs(&self,\n-                          impl_def_id: DefId)\n-                          -> (Ty<'tcx>, &'tcx Substs<'tcx>)\n-    {\n+    fn impl_ty_and_substs(&self, impl_def_id: DefId) -> (Ty<'tcx>, &'tcx Substs<'tcx>) {\n         let impl_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n \n-        let substs = Substs::for_item(self.tcx, impl_def_id,\n+        let substs = Substs::for_item(self.tcx,\n+                                      impl_def_id,\n                                       |_, _| self.tcx.mk_region(ty::ReErased),\n                                       |_, _| self.next_ty_var());\n \n@@ -1287,16 +1276,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///    and/or tracking the substitution and\n     ///    so forth.\n     fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n-        where T : TypeFoldable<'tcx>\n+        where T: TypeFoldable<'tcx>\n     {\n         self.tcx.erase_late_bound_regions(value)\n     }\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    fn impl_or_trait_item(&self, def_id: DefId)\n-                          -> Option<ty::ImplOrTraitItem<'tcx>>\n-    {\n+    fn impl_or_trait_item(&self, def_id: DefId) -> Option<ty::ImplOrTraitItem<'tcx>> {\n         self.fcx.impl_or_trait_item(def_id, self.item_name)\n     }\n }\n@@ -1307,9 +1294,7 @@ impl<'tcx> Candidate<'tcx> {\n             item: self.item.clone(),\n             kind: match self.kind {\n                 InherentImplCandidate(..) => InherentImplPick,\n-                ExtensionImplCandidate(def_id, ..) => {\n-                    ExtensionImplPick(def_id)\n-                }\n+                ExtensionImplCandidate(def_id, ..) => ExtensionImplPick(def_id),\n                 ObjectCandidate => ObjectPick,\n                 TraitCandidate => TraitPick,\n                 WhereClauseCandidate(ref trait_ref) => {\n@@ -1326,15 +1311,13 @@ impl<'tcx> Candidate<'tcx> {\n             import_id: self.import_id,\n             autoderefs: 0,\n             autoref: None,\n-            unsize: None\n+            unsize: None,\n         }\n     }\n \n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n-            InherentImplCandidate(..) => {\n-                ImplSource(self.item.container().id())\n-            }\n+            InherentImplCandidate(..) => ImplSource(self.item.container().id()),\n             ExtensionImplCandidate(def_id, ..) => ImplSource(def_id),\n             ObjectCandidate |\n             TraitCandidate |"}, {"sha": "e93f990b810717b430c7d43a0708d679499ff016", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 130, "deletions": 103, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=fd1ea1330ed6d20dde29cd9efa1a0a63e6729eaf", "patch": "@@ -13,15 +13,15 @@\n \n use CrateCtxt;\n \n-use check::{FnCtxt};\n+use check::FnCtxt;\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use hir::def::Def;\n use hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::ty::subst::Substs;\n use rustc::traits::{Obligation, SelectionContext};\n-use util::nodemap::{FnvHashSet};\n+use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n use errors::DiagnosticBuilder;\n@@ -43,25 +43,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match ty.sty {\n             // Not all of these (e.g. unsafe fns) implement FnOnce\n             // so we look for these beforehand\n-            ty::TyClosure(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => true,\n+            ty::TyClosure(..) |\n+            ty::TyFnDef(..) |\n+            ty::TyFnPtr(_) => true,\n             // If it's not a simple function, look for things which implement FnOnce\n             _ => {\n                 let fn_once = match tcx.lang_items.require(FnOnceTraitLangItem) {\n                     Ok(fn_once) => fn_once,\n-                    Err(..) => return false\n+                    Err(..) => return false,\n                 };\n \n-                self.autoderef(span, ty).any(|(ty, _)| self.probe(|_| {\n-                    let fn_once_substs =\n-                        Substs::new_trait(tcx, ty, &[self.next_ty_var()]);\n-                    let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n-                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                    let obligation = Obligation::misc(span,\n-                                                      self.body_id,\n-                                                      poly_trait_ref\n-                                                      .to_predicate());\n-                    SelectionContext::new(self).evaluate_obligation(&obligation)\n-                }))\n+                self.autoderef(span, ty).any(|(ty, _)| {\n+                    self.probe(|_| {\n+                        let fn_once_substs = Substs::new_trait(tcx, ty, &[self.next_ty_var()]);\n+                        let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n+                        let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                        let obligation =\n+                            Obligation::misc(span, self.body_id, poly_trait_ref.to_predicate());\n+                        SelectionContext::new(self).evaluate_obligation(&obligation)\n+                    })\n+                })\n             }\n         }\n     }\n@@ -71,15 +72,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                rcvr_ty: Ty<'tcx>,\n                                item_name: ast::Name,\n                                rcvr_expr: Option<&hir::Expr>,\n-                               error: MethodError<'tcx>)\n-    {\n+                               error: MethodError<'tcx>) {\n         // avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n-            return\n+            return;\n         }\n \n-        let report_candidates = |err: &mut DiagnosticBuilder,\n-                                 mut sources: Vec<CandidateSource>| {\n+        let report_candidates = |err: &mut DiagnosticBuilder, mut sources: Vec<CandidateSource>| {\n \n             sources.sort();\n             sources.dedup();\n@@ -93,15 +92,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n                         let item = self.impl_or_trait_item(impl_did, item_name)\n                             .or_else(|| {\n-                                self.impl_or_trait_item(\n-                                    self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n-\n-                                    item_name\n-                                )\n-                            }).unwrap();\n-                        let note_span = self.tcx.map.span_if_local(item.def_id()).or_else(|| {\n-                            self.tcx.map.span_if_local(impl_did)\n-                        });\n+                                self.impl_or_trait_item(self.tcx\n+                                                            .impl_trait_ref(impl_did)\n+                                                            .unwrap()\n+                                                            .def_id,\n+\n+                                                        item_name)\n+                            })\n+                            .unwrap();\n+                        let note_span = self.tcx\n+                            .map\n+                            .span_if_local(item.def_id())\n+                            .or_else(|| self.tcx.map.span_if_local(impl_did));\n \n                         let impl_ty = self.impl_self_ty(span, impl_did).ty;\n \n@@ -128,7 +130,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     CandidateSource::TraitSource(trait_did) => {\n                         let item = self.impl_or_trait_item(trait_did, item_name).unwrap();\n                         let item_span = self.tcx.map.def_id_span(item.def_id(), span);\n-                        span_note!(err, item_span,\n+                        span_note!(err,\n+                                   item_span,\n                                    \"candidate #{} is defined in the trait `{}`\",\n                                    idx + 1,\n                                    self.tcx.item_path_str(trait_did));\n@@ -144,48 +147,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n                                                unsatisfied_predicates,\n                                                out_of_scope_traits,\n-                                               mode, .. }) => {\n+                                               mode,\n+                                               .. }) => {\n                 let tcx = self.tcx;\n \n-                let mut err = self.type_error_struct(\n-                    span,\n-                    |actual| {\n-                        format!(\"no {} named `{}` found for type `{}` \\\n-                                 in the current scope\",\n-                                if mode == Mode::MethodCall { \"method\" }\n-                                else { \"associated item\" },\n-                                item_name,\n-                                actual)\n-                    },\n-                    rcvr_ty);\n+                let mut err = self.type_error_struct(span,\n+                                                     |actual| {\n+                    format!(\"no {} named `{}` found for type `{}` in the current scope\",\n+                            if mode == Mode::MethodCall {\n+                                \"method\"\n+                            } else {\n+                                \"associated item\"\n+                            },\n+                            item_name,\n+                            actual)\n+                },\n+                                                     rcvr_ty);\n \n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as (x.f)(...).\n                 if let Some(expr) = rcvr_expr {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         match ty.sty {\n                             ty::TyAdt(def, substs) if !def.is_enum() => {\n-                                if let Some(field) = def.struct_variant().\n-                                                         find_field_named(item_name) {\n+                                if let Some(field) = def.struct_variant()\n+                                    .find_field_named(item_name) {\n                                     let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n                                     let expr_string = match snippet {\n                                         Ok(expr_string) => expr_string,\n-                                        _ => \"s\".into() // Default to a generic placeholder for the\n-                                                        // expression when we can't generate a\n-                                                        // string snippet\n+                                        _ => \"s\".into(), // Default to a generic placeholder for the\n+                                        // expression when we can't generate a\n+                                        // string snippet\n                                     };\n \n                                     let field_ty = field.ty(tcx, substs);\n \n                                     if self.is_fn_ty(&field_ty, span) {\n-                                        err.span_note(span, &format!(\n-                                            \"use `({0}.{1})(...)` if you meant to call the \\\n-                                             function stored in the `{1}` field\",\n-                                            expr_string, item_name));\n+                                        err.span_note(span,\n+                                                      &format!(\"use `({0}.{1})(...)` if you \\\n+                                                                meant to call the function \\\n+                                                                stored in the `{1}` field\",\n+                                                               expr_string,\n+                                                               item_name));\n                                     } else {\n-                                        err.span_note(span, &format!(\n-                                            \"did you mean to write `{0}.{1}`?\",\n-                                            expr_string, item_name));\n+                                        err.span_note(span,\n+                                                      &format!(\"did you mean to write `{0}.{1}`?\",\n+                                                               expr_string,\n+                                                               item_name));\n                                     }\n                                     break;\n                                 }\n@@ -204,10 +212,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     if let Some(expr) = rcvr_expr {\n-                        if let Ok (expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        if let Ok(expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n-                        }\n-                        else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n+                        } else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n                             if let Some(segment) = path.segments.last() {\n                                 report_function!(expr.span, segment.name);\n                             }\n@@ -216,34 +223,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if !static_sources.is_empty() {\n-                    err.note(\n-                        \"found the following associated functions; to be used as \\\n-                         methods, functions must have a `self` parameter\");\n+                    err.note(\"found the following associated functions; to be used as methods, \\\n+                              functions must have a `self` parameter\");\n \n                     report_candidates(&mut err, static_sources);\n                 }\n \n                 if !unsatisfied_predicates.is_empty() {\n                     let bound_list = unsatisfied_predicates.iter()\n-                        .map(|p| format!(\"`{} : {}`\",\n-                                         p.self_ty(),\n-                                         p))\n+                        .map(|p| format!(\"`{} : {}`\", p.self_ty(), p))\n                         .collect::<Vec<_>>()\n                         .join(\", \");\n-                    err.note(\n-                        &format!(\"the method `{}` exists but the \\\n-                                 following trait bounds were not satisfied: {}\",\n-                                 item_name,\n-                                 bound_list));\n+                    err.note(&format!(\"the method `{}` exists but the following trait bounds \\\n+                                       were not satisfied: {}\",\n+                                      item_name,\n+                                      bound_list));\n                 }\n \n-                self.suggest_traits_to_import(&mut err, span, rcvr_ty, item_name,\n-                                              rcvr_expr, out_of_scope_traits);\n+                self.suggest_traits_to_import(&mut err,\n+                                              span,\n+                                              rcvr_ty,\n+                                              item_name,\n+                                              rcvr_expr,\n+                                              out_of_scope_traits);\n                 err.emit();\n             }\n \n             MethodError::Ambiguity(sources) => {\n-                let mut err = struct_span_err!(self.sess(), span, E0034,\n+                let mut err = struct_span_err!(self.sess(),\n+                                               span,\n+                                               E0034,\n                                                \"multiple applicable items in scope\");\n                 err.span_label(span, &format!(\"multiple `{}` found\", item_name));\n \n@@ -255,11 +264,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n                                    invoked on this closure as we have not yet inferred what \\\n                                    kind of closure it is\",\n-                                   item_name,\n-                                   self.tcx.item_path_str(trait_def_id));\n+                                  item_name,\n+                                  self.tcx.item_path_str(trait_def_id));\n                 let msg = if let Some(callee) = rcvr_expr {\n                     format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n-                            msg, pprust::expr_to_string(callee))\n+                            msg,\n+                            pprust::expr_to_string(callee))\n                 } else {\n                     msg\n                 };\n@@ -279,18 +289,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 rcvr_ty: Ty<'tcx>,\n                                 item_name: ast::Name,\n                                 rcvr_expr: Option<&hir::Expr>,\n-                                valid_out_of_scope_traits: Vec<DefId>)\n-    {\n+                                valid_out_of_scope_traits: Vec<DefId>) {\n         if !valid_out_of_scope_traits.is_empty() {\n             let mut candidates = valid_out_of_scope_traits;\n             candidates.sort();\n             candidates.dedup();\n-            let msg = format!(\n-                \"items from traits can only be used if the trait is in scope; \\\n-                 the following {traits_are} implemented but not in scope, \\\n-                 perhaps add a `use` for {one_of_them}:\",\n-                traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n-                one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n+            let msg = format!(\"items from traits can only be used if the trait is in scope; the \\\n+                               following {traits_are} implemented but not in scope, perhaps add \\\n+                               a `use` for {one_of_them}:\",\n+                              traits_are = if candidates.len() == 1 {\n+                                  \"trait is\"\n+                              } else {\n+                                  \"traits are\"\n+                              },\n+                              one_of_them = if candidates.len() == 1 {\n+                                  \"it\"\n+                              } else {\n+                                  \"one of them\"\n+                              });\n \n             err.help(&msg[..]);\n \n@@ -303,7 +319,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if candidates.len() > limit {\n                 err.note(&format!(\"and {} others\", candidates.len() - limit));\n             }\n-            return\n+            return;\n         }\n \n         let type_is_local = self.type_derefs_to_local(span, rcvr_ty, rcvr_expr);\n@@ -319,8 +335,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                (type_is_local || info.def_id.is_local())\n-                    && self.impl_or_trait_item(info.def_id, item_name).is_some()\n+                (type_is_local || info.def_id.is_local()) &&\n+                self.impl_or_trait_item(info.def_id, item_name).is_some()\n             })\n             .collect::<Vec<_>>();\n \n@@ -332,13 +348,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // FIXME #21673 this help message could be tuned to the case\n             // of a type parameter: suggest adding a trait bound rather\n             // than implementing.\n-            let msg = format!(\n-                \"items from traits can only be used if the trait is implemented and in scope; \\\n-                 the following {traits_define} an item `{name}`, \\\n-                 perhaps you need to implement {one_of_them}:\",\n-                traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n-                one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n-                name = item_name);\n+            let msg = format!(\"items from traits can only be used if the trait is implemented \\\n+                               and in scope; the following {traits_define} an item `{name}`, \\\n+                               perhaps you need to implement {one_of_them}:\",\n+                              traits_define = if candidates.len() == 1 {\n+                                  \"trait defines\"\n+                              } else {\n+                                  \"traits define\"\n+                              },\n+                              one_of_them = if candidates.len() == 1 {\n+                                  \"it\"\n+                              } else {\n+                                  \"one of them\"\n+                              },\n+                              name = item_name);\n \n             err.help(&msg[..]);\n \n@@ -355,7 +378,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_derefs_to_local(&self,\n                             span: Span,\n                             rcvr_ty: Ty<'tcx>,\n-                            rcvr_expr: Option<&hir::Expr>) -> bool {\n+                            rcvr_expr: Option<&hir::Expr>)\n+                            -> bool {\n         fn is_local(ty: Ty) -> bool {\n             match ty.sty {\n                 ty::TyAdt(def, _) => def.did.is_local(),\n@@ -368,7 +392,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // non-local (there are \"edge\" cases, e.g. (LocalType,), but\n                 // the noise from these sort of types is usually just really\n                 // annoying, rather than any sort of help).\n-                _ => false\n+                _ => false,\n             }\n         }\n \n@@ -391,9 +415,7 @@ pub struct TraitInfo {\n \n impl TraitInfo {\n     fn new(def_id: DefId) -> TraitInfo {\n-        TraitInfo {\n-            def_id: def_id,\n-        }\n+        TraitInfo { def_id: def_id }\n     }\n }\n impl PartialEq for TraitInfo {\n@@ -403,7 +425,9 @@ impl PartialEq for TraitInfo {\n }\n impl Eq for TraitInfo {}\n impl PartialOrd for TraitInfo {\n-    fn partial_cmp(&self, other: &TraitInfo) -> Option<Ordering> { Some(self.cmp(other)) }\n+    fn partial_cmp(&self, other: &TraitInfo) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n }\n impl Ord for TraitInfo {\n     fn cmp(&self, other: &TraitInfo) -> Ordering {\n@@ -426,7 +450,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         // Crate-local:\n         //\n         // meh.\n-        struct Visitor<'a, 'tcx:'a> {\n+        struct Visitor<'a, 'tcx: 'a> {\n             map: &'a hir_map::Map<'tcx>,\n             traits: &'a mut AllTraitsVec,\n         }\n@@ -443,7 +467,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n         }\n         ccx.tcx.map.krate().visit_all_items(&mut Visitor {\n             map: &ccx.tcx.map,\n-            traits: &mut traits\n+            traits: &mut traits,\n         });\n \n         // Cross-crate:\n@@ -469,7 +493,10 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n             }\n         }\n         for cnum in ccx.tcx.sess.cstore.crates() {\n-            let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+            let def_id = DefId {\n+                krate: cnum,\n+                index: CRATE_DEF_INDEX,\n+            };\n             handle_external_def(ccx, &mut traits, &mut external_mods, Def::Mod(def_id));\n         }\n \n@@ -480,13 +507,13 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n     assert!(borrow.is_some());\n     AllTraits {\n         borrow: borrow,\n-        idx: 0\n+        idx: 0,\n     }\n }\n \n pub struct AllTraits<'a> {\n     borrow: cell::Ref<'a, Option<AllTraitsVec>>,\n-    idx: usize\n+    idx: usize,\n }\n \n impl<'a> Iterator for AllTraits<'a> {"}]}