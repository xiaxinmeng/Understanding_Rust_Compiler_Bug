{"sha": "be3a5a1beccaebdae7deb46870eb4e711464c738", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlM2E1YTFiZWNjYWViZGFlN2RlYjQ2ODcwZWI0ZTcxMTQ2NGM3Mzg=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-12-17T19:58:25Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-12-26T20:43:04Z"}, "message": "BTreeMap: rename the area access methods", "tree": {"sha": "a2832cedc99dfaef7c2cb5c905f5016dc04eaf78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2832cedc99dfaef7c2cb5c905f5016dc04eaf78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be3a5a1beccaebdae7deb46870eb4e711464c738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be3a5a1beccaebdae7deb46870eb4e711464c738", "html_url": "https://github.com/rust-lang/rust/commit/be3a5a1beccaebdae7deb46870eb4e711464c738", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be3a5a1beccaebdae7deb46870eb4e711464c738/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89524d0f8e28080197a85e06d143b7d6f131b67e", "url": "https://api.github.com/repos/rust-lang/rust/commits/89524d0f8e28080197a85e06d143b7d6f131b67e", "html_url": "https://github.com/rust-lang/rust/commit/89524d0f8e28080197a85e06d143b7d6f131b67e"}], "stats": {"total": 98, "additions": 48, "deletions": 50}, "files": [{"sha": "b3641a7a0c6973a8cd52e2dd2a9a6645d1e6f06d", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/be3a5a1beccaebdae7deb46870eb4e711464c738/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be3a5a1beccaebdae7deb46870eb4e711464c738/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=be3a5a1beccaebdae7deb46870eb4e711464c738", "patch": "@@ -489,7 +489,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     ///\n     /// # Safety\n     /// `index` is in bounds of 0..CAPACITY\n-    unsafe fn key_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    unsafe fn key_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n     where\n         I: SliceIndex<[MaybeUninit<K>], Output = Output>,\n     {\n@@ -503,7 +503,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     ///\n     /// # Safety\n     /// `index` is in bounds of 0..CAPACITY\n-    unsafe fn val_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    unsafe fn val_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n     where\n         I: SliceIndex<[MaybeUninit<V>], Output = Output>,\n     {\n@@ -519,7 +519,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     ///\n     /// # Safety\n     /// `index` is in bounds of 0..CAPACITY + 1\n-    unsafe fn edge_area_mut_at<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n+    unsafe fn edge_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output\n     where\n         I: SliceIndex<[MaybeUninit<BoxedNode<K, V>>], Output = Output>,\n     {\n@@ -583,8 +583,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            self.key_area_mut_at(idx).write(key);\n-            self.val_area_mut_at(idx).write(val);\n+            self.key_area_mut(idx).write(key);\n+            self.val_area_mut(idx).write(val);\n         }\n     }\n \n@@ -593,8 +593,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         let new_len = self.len() + 1;\n         assert!(new_len <= CAPACITY);\n         unsafe {\n-            slice_insert(self.key_area_mut_at(..new_len), 0, key);\n-            slice_insert(self.val_area_mut_at(..new_len), 0, val);\n+            slice_insert(self.key_area_mut(..new_len), 0, key);\n+            slice_insert(self.val_area_mut(..new_len), 0, val);\n             *self.len_mut() = new_len as u16;\n         }\n     }\n@@ -627,9 +627,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n-            self.key_area_mut_at(idx).write(key);\n-            self.val_area_mut_at(idx).write(val);\n-            self.edge_area_mut_at(idx + 1).write(edge.node);\n+            self.key_area_mut(idx).write(key);\n+            self.val_area_mut(idx).write(val);\n+            self.edge_area_mut(idx + 1).write(edge.node);\n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n@@ -642,9 +642,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         assert!(new_len <= CAPACITY);\n \n         unsafe {\n-            slice_insert(self.key_area_mut_at(..new_len), 0, key);\n-            slice_insert(self.val_area_mut_at(..new_len), 0, val);\n-            slice_insert(self.edge_area_mut_at(..new_len + 1), 0, edge.node);\n+            slice_insert(self.key_area_mut(..new_len), 0, key);\n+            slice_insert(self.val_area_mut(..new_len), 0, val);\n+            slice_insert(self.edge_area_mut(..new_len + 1), 0, edge.node);\n             *self.len_mut() = new_len as u16;\n         }\n \n@@ -662,12 +662,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let idx = self.len() - 1;\n \n         unsafe {\n-            let key = self.key_area_mut_at(idx).assume_init_read();\n-            let val = self.val_area_mut_at(idx).assume_init_read();\n+            let key = self.key_area_mut(idx).assume_init_read();\n+            let val = self.val_area_mut(idx).assume_init_read();\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let node = internal.edge_area_mut_at(idx + 1).assume_init_read();\n+                    let node = internal.edge_area_mut(idx + 1).assume_init_read();\n                     let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // Currently, clearing the parent link is superfluous, because we will\n                     // insert the node elsewhere and set its parent link again.\n@@ -690,12 +690,12 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         let old_len = self.len();\n \n         unsafe {\n-            let key = slice_remove(self.key_area_mut_at(..old_len), 0);\n-            let val = slice_remove(self.val_area_mut_at(..old_len), 0);\n+            let key = slice_remove(self.key_area_mut(..old_len), 0);\n+            let val = slice_remove(self.val_area_mut(..old_len), 0);\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let node = slice_remove(internal.edge_area_mut_at(..old_len + 1), 0);\n+                    let node = slice_remove(internal.edge_area_mut(..old_len + 1), 0);\n                     let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // Currently, clearing the parent link is superfluous, because we will\n                     // insert the node elsewhere and set its parent link again.\n@@ -919,11 +919,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         let new_len = self.node.len() + 1;\n \n         unsafe {\n-            slice_insert(self.node.key_area_mut_at(..new_len), self.idx, key);\n-            slice_insert(self.node.val_area_mut_at(..new_len), self.idx, val);\n+            slice_insert(self.node.key_area_mut(..new_len), self.idx, key);\n+            slice_insert(self.node.val_area_mut(..new_len), self.idx, val);\n             *self.node.len_mut() = new_len as u16;\n \n-            self.node.val_area_mut_at(self.idx).assume_init_mut()\n+            self.node.val_area_mut(self.idx).assume_init_mut()\n         }\n     }\n }\n@@ -978,9 +978,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         let new_len = self.node.len() + 1;\n \n         unsafe {\n-            slice_insert(self.node.key_area_mut_at(..new_len), self.idx, key);\n-            slice_insert(self.node.val_area_mut_at(..new_len), self.idx, val);\n-            slice_insert(self.node.edge_area_mut_at(..new_len + 1), self.idx + 1, edge.node);\n+            slice_insert(self.node.key_area_mut(..new_len), self.idx, key);\n+            slice_insert(self.node.val_area_mut(..new_len), self.idx, val);\n+            slice_insert(self.node.edge_area_mut(..new_len + 1), self.idx + 1, edge.node);\n             *self.node.len_mut() = new_len as u16;\n \n             self.node.correct_childrens_parent_links(self.idx + 1..new_len + 1);\n@@ -1085,7 +1085,7 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeTyp\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn key_mut(&mut self) -> &mut K {\n-        unsafe { self.node.key_area_mut_at(self.idx).assume_init_mut() }\n+        unsafe { self.node.key_area_mut(self.idx).assume_init_mut() }\n     }\n \n     pub fn into_val_mut(self) -> &'a mut V {\n@@ -1127,16 +1127,16 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         let new_len = self.node.len() - self.idx - 1;\n         new_node.len = new_len as u16;\n         unsafe {\n-            let k = self.node.key_area_mut_at(self.idx).assume_init_read();\n-            let v = self.node.val_area_mut_at(self.idx).assume_init_read();\n+            let k = self.node.key_area_mut(self.idx).assume_init_read();\n+            let v = self.node.val_area_mut(self.idx).assume_init_read();\n \n             ptr::copy_nonoverlapping(\n-                self.node.key_area_mut_at(self.idx + 1..).as_ptr(),\n+                self.node.key_area_mut(self.idx + 1..).as_ptr(),\n                 new_node.keys.as_mut_ptr(),\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n-                self.node.val_area_mut_at(self.idx + 1..).as_ptr(),\n+                self.node.val_area_mut(self.idx + 1..).as_ptr(),\n                 new_node.vals.as_mut_ptr(),\n                 new_len,\n             );\n@@ -1173,8 +1173,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         let old_len = self.node.len();\n         unsafe {\n-            let k = slice_remove(self.node.key_area_mut_at(..old_len), self.idx);\n-            let v = slice_remove(self.node.val_area_mut_at(..old_len), self.idx);\n+            let k = slice_remove(self.node.key_area_mut(..old_len), self.idx);\n+            let v = slice_remove(self.node.val_area_mut(..old_len), self.idx);\n             *self.node.len_mut() = (old_len - 1) as u16;\n             ((k, v), self.left_edge())\n         }\n@@ -1195,7 +1195,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             let kv = self.split_leaf_data(&mut new_node.data);\n             let new_len = usize::from(new_node.data.len);\n             ptr::copy_nonoverlapping(\n-                self.node.edge_area_mut_at(self.idx + 1..).as_ptr(),\n+                self.node.edge_area_mut(self.idx + 1..).as_ptr(),\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n@@ -1321,25 +1321,23 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n         unsafe {\n             *left_node.len_mut() = new_left_len as u16;\n \n-            let parent_key =\n-                slice_remove(parent_node.key_area_mut_at(..old_parent_len), parent_idx);\n-            left_node.key_area_mut_at(old_left_len).write(parent_key);\n+            let parent_key = slice_remove(parent_node.key_area_mut(..old_parent_len), parent_idx);\n+            left_node.key_area_mut(old_left_len).write(parent_key);\n             ptr::copy_nonoverlapping(\n-                right_node.key_area_mut_at(..).as_ptr(),\n-                left_node.key_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n+                right_node.key_area_mut(..).as_ptr(),\n+                left_node.key_area_mut(old_left_len + 1..).as_mut_ptr(),\n                 right_len,\n             );\n \n-            let parent_val =\n-                slice_remove(parent_node.val_area_mut_at(..old_parent_len), parent_idx);\n-            left_node.val_area_mut_at(old_left_len).write(parent_val);\n+            let parent_val = slice_remove(parent_node.val_area_mut(..old_parent_len), parent_idx);\n+            left_node.val_area_mut(old_left_len).write(parent_val);\n             ptr::copy_nonoverlapping(\n-                right_node.val_area_mut_at(..).as_ptr(),\n-                left_node.val_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n+                right_node.val_area_mut(..).as_ptr(),\n+                left_node.val_area_mut(old_left_len + 1..).as_mut_ptr(),\n                 right_len,\n             );\n \n-            slice_remove(&mut parent_node.edge_area_mut_at(..old_parent_len + 1), parent_idx + 1);\n+            slice_remove(&mut parent_node.edge_area_mut(..old_parent_len + 1), parent_idx + 1);\n             parent_node.correct_childrens_parent_links(parent_idx + 1..old_parent_len);\n             *parent_node.len_mut() -= 1;\n \n@@ -1349,8 +1347,8 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();\n                 let mut right_node = right_node.cast_to_internal_unchecked();\n                 ptr::copy_nonoverlapping(\n-                    right_node.edge_area_mut_at(..).as_ptr(),\n-                    left_node.edge_area_mut_at(old_left_len + 1..).as_mut_ptr(),\n+                    right_node.edge_area_mut(..).as_ptr(),\n+                    left_node.edge_area_mut(old_left_len + 1..).as_mut_ptr(),\n                     right_len + 1,\n                 );\n \n@@ -1458,7 +1456,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n             match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n                     // Make room for stolen edges.\n-                    let right_edges = right.edge_area_mut_at(..).as_mut_ptr();\n+                    let right_edges = right.edge_area_mut(..).as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), old_right_len + 1);\n                     right.correct_childrens_parent_links(count..new_right_len + 1);\n \n@@ -1518,7 +1516,7 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                     move_edges(right.reborrow_mut(), 0, left, old_left_len + 1, count);\n \n                     // Fill gap where stolen edges used to be.\n-                    let right_edges = right.edge_area_mut_at(..).as_mut_ptr();\n+                    let right_edges = right.edge_area_mut(..).as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n                     right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n@@ -1551,8 +1549,8 @@ unsafe fn move_edges<'a, K: 'a, V: 'a>(\n     count: usize,\n ) {\n     unsafe {\n-        let source_ptr = source.edge_area_mut_at(..).as_ptr();\n-        let dest_ptr = dest.edge_area_mut_at(dest_offset..).as_mut_ptr();\n+        let source_ptr = source.edge_area_mut(..).as_ptr();\n+        let dest_ptr = dest.edge_area_mut(dest_offset..).as_mut_ptr();\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr, count);\n         dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n     }"}]}