{"sha": "f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NzVmYjU0ZjhlODY3OGY4YzM0ZDdlYWFhMmM5MjdiM2I2YmNhYzc=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-11-15T08:08:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-15T08:08:36Z"}, "message": "Merge pull request #2216 from LaurentMazare/master\n\nHandle methods with an obvious negation in the non-minimal bool lint", "tree": {"sha": "208b871f606bab2627669cf85c9742e84a823803", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/208b871f606bab2627669cf85c9742e84a823803"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaC/YECRBK7hj4Ov3rIwAAdHIIAIquPC7eTxPwlujf3KhUMWQA\nLiUucEHQ183nu4HrGvMG9Jt7NVF0YNpxV/RW5bDlS1fpya/1BCPNl3ZeciefiYhO\nEl0D/EwoZZqkWGpOW6E7Cl7ISnamFRKR17GhGhbA6hKKS1R3PLIC4xEzAg9FjCSW\ne5HnmiY1lHDUQHu9JC7RFmYvn2hnF/DJOPEFnYOc3rXXkAycRvU//5sZZNsd17zv\n1DRjo3LEln/Q/9J2AlaVtwgHftq7INTTWaibnXFP0apwa1MB2LFv3R8NBUjan/s/\nuIB8Mh/Oig8lhFJGFd2Rb9WW07h2e6kwvagAjv3zdCOdxPnH7xm75kjY5exPJj0=\n=AGye\n-----END PGP SIGNATURE-----\n", "payload": "tree 208b871f606bab2627669cf85c9742e84a823803\nparent 1f6e2a63d89e485df6a3ee9df3e8ffbfddf26330\nparent 25783fa485933158870260b68bff94998d95ca48\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1510733316 +0100\ncommitter GitHub <noreply@github.com> 1510733316 +0100\n\nMerge pull request #2216 from LaurentMazare/master\n\nHandle methods with an obvious negation in the non-minimal bool lint"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7", "html_url": "https://github.com/rust-lang/rust/commit/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f6e2a63d89e485df6a3ee9df3e8ffbfddf26330", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f6e2a63d89e485df6a3ee9df3e8ffbfddf26330", "html_url": "https://github.com/rust-lang/rust/commit/1f6e2a63d89e485df6a3ee9df3e8ffbfddf26330"}, {"sha": "25783fa485933158870260b68bff94998d95ca48", "url": "https://api.github.com/repos/rust-lang/rust/commits/25783fa485933158870260b68bff94998d95ca48", "html_url": "https://github.com/rust-lang/rust/commit/25783fa485933158870260b68bff94998d95ca48"}], "stats": {"total": 171, "additions": 129, "deletions": 42}, "files": [{"sha": "9310cca4aeee81a29a16564f7dc223e741d503fc", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 83, "deletions": 42, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7", "patch": "@@ -44,6 +44,12 @@ declare_lint! {\n     \"boolean expressions that contain terminals which can be eliminated\"\n }\n \n+// For each pairs, both orders are considered.\n+const METHODS_WITH_NEGATION: [(&str, &str); 2] = [\n+    (\"is_some\", \"is_none\"),\n+    (\"is_err\", \"is_ok\"),\n+];\n+\n #[derive(Copy, Clone)]\n pub struct NonminimalBool;\n \n@@ -153,8 +159,16 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n     }\n }\n \n-fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n-    fn recurse(brackets: bool, cx: &LateContext, suggestion: &Bool, terminals: &[&Expr], mut s: String) -> String {\n+// The boolean part of the return indicates whether some simplifications have been applied.\n+fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n+    fn recurse(\n+        brackets: bool,\n+        cx: &LateContext,\n+        suggestion: &Bool,\n+        terminals: &[&Expr],\n+        mut s: String,\n+        simplified: &mut bool,\n+    ) -> String {\n         use quine_mc_cluskey::Bool::*;\n         let snip = |e: &Expr| snippet_opt(cx, e.span).expect(\"don't try to improve booleans created by macros\");\n         match *suggestion {\n@@ -169,49 +183,70 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n             Not(ref inner) => match **inner {\n                 And(_) | Or(_) => {\n                     s.push('!');\n-                    recurse(true, cx, inner, terminals, s)\n+                    recurse(true, cx, inner, terminals, s, simplified)\n                 },\n-                Term(n) => if let ExprBinary(binop, ref lhs, ref rhs) = terminals[n as usize].node {\n-                    let op = match binop.node {\n-                        BiEq => \" != \",\n-                        BiNe => \" == \",\n-                        BiLt => \" >= \",\n-                        BiGt => \" <= \",\n-                        BiLe => \" > \",\n-                        BiGe => \" < \",\n-                        _ => {\n+                Term(n) => match terminals[n as usize].node {\n+                    ExprBinary(binop, ref lhs, ref rhs) => {\n+                        let op = match binop.node {\n+                            BiEq => \" != \",\n+                            BiNe => \" == \",\n+                            BiLt => \" >= \",\n+                            BiGt => \" <= \",\n+                            BiLe => \" > \",\n+                            BiGe => \" < \",\n+                            _ => {\n+                                s.push('!');\n+                                return recurse(true, cx, inner, terminals, s, simplified);\n+                            },\n+                        };\n+                        *simplified = true;\n+                        s.push_str(&snip(lhs));\n+                        s.push_str(op);\n+                        s.push_str(&snip(rhs));\n+                        s\n+                    },\n+                    ExprMethodCall(ref path, _, ref args) if args.len() == 1 => {\n+                        let negation = METHODS_WITH_NEGATION\n+                            .iter().cloned()\n+                            .flat_map(|(a, b)| vec![(a, b), (b, a)])\n+                            .find(|&(a, _)| a == path.name.as_str());\n+                        if let Some((_, negation_method)) = negation {\n+                            *simplified = true;\n+                            s.push_str(&snip(&args[0]));\n+                            s.push('.');\n+                            s.push_str(negation_method);\n+                            s.push_str(\"()\");\n+                            s\n+                        } else {\n                             s.push('!');\n-                            return recurse(true, cx, inner, terminals, s);\n-                        },\n-                    };\n-                    s.push_str(&snip(lhs));\n-                    s.push_str(op);\n-                    s.push_str(&snip(rhs));\n-                    s\n-                } else {\n-                    s.push('!');\n-                    recurse(false, cx, inner, terminals, s)\n+                            recurse(false, cx, inner, terminals, s, simplified)\n+                        }\n+                    },\n+                    _ => {\n+                        s.push('!');\n+                        recurse(false, cx, inner, terminals, s, simplified)\n+                    },\n                 },\n                 _ => {\n                     s.push('!');\n-                    recurse(false, cx, inner, terminals, s)\n+                    recurse(false, cx, inner, terminals, s, simplified)\n                 },\n             },\n             And(ref v) => {\n                 if brackets {\n                     s.push('(');\n                 }\n                 if let Or(_) = v[0] {\n-                    s = recurse(true, cx, &v[0], terminals, s);\n+                    s = recurse(true, cx, &v[0], terminals, s, simplified);\n                 } else {\n-                    s = recurse(false, cx, &v[0], terminals, s);\n+                    s = recurse(false, cx, &v[0], terminals, s, simplified);\n                 }\n                 for inner in &v[1..] {\n                     s.push_str(\" && \");\n                     if let Or(_) = *inner {\n-                        s = recurse(true, cx, inner, terminals, s);\n+                        s = recurse(true, cx, inner, terminals, s, simplified);\n                     } else {\n-                        s = recurse(false, cx, inner, terminals, s);\n+                        s = recurse(false, cx, inner, terminals, s, simplified);\n                     }\n                 }\n                 if brackets {\n@@ -223,10 +258,10 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n                 if brackets {\n                     s.push('(');\n                 }\n-                s = recurse(false, cx, &v[0], terminals, s);\n+                s = recurse(false, cx, &v[0], terminals, s, simplified);\n                 for inner in &v[1..] {\n                     s.push_str(\" || \");\n-                    s = recurse(false, cx, inner, terminals, s);\n+                    s = recurse(false, cx, inner, terminals, s, simplified);\n                 }\n                 if brackets {\n                     s.push(')');\n@@ -249,7 +284,9 @@ fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> String {\n             },\n         }\n     }\n-    recurse(false, cx, suggestion, terminals, String::new())\n+    let mut simplified = false;\n+    let s = recurse(false, cx, suggestion, terminals, String::new(), &mut simplified);\n+    (s, simplified)\n }\n \n fn simple_negate(b: Bool) -> Bool {\n@@ -359,7 +396,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                 db.span_suggestion(\n                                     e.span,\n                                     \"it would look like the following\",\n-                                    suggest(self.cx, suggestion, &h2q.terminals),\n+                                    suggest(self.cx, suggestion, &h2q.terminals).0,\n                                 );\n                             },\n                         );\n@@ -376,22 +413,26 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                     improvements.push(suggestion);\n                 }\n             }\n-            if !improvements.is_empty() {\n+            let nonminimal_bool_lint = |suggestions| {\n                 span_lint_and_then(\n                     self.cx,\n                     NONMINIMAL_BOOL,\n                     e.span,\n                     \"this boolean expression can be simplified\",\n-                    |db| {\n-                        db.span_suggestions(\n-                            e.span,\n-                            \"try\",\n-                            improvements\n-                                .into_iter()\n-                                .map(|suggestion| suggest(self.cx, suggestion, &h2q.terminals))\n-                                .collect(),\n-                        );\n-                    },\n+                    |db| { db.span_suggestions(e.span, \"try\", suggestions); },\n+                );\n+            };\n+            if improvements.is_empty() {\n+                let suggest = suggest(self.cx, &expr, &h2q.terminals);\n+                if suggest.1 {\n+                    nonminimal_bool_lint(vec![suggest.0])\n+                }\n+            } else {\n+                nonminimal_bool_lint(\n+                    improvements\n+                        .into_iter()\n+                        .map(|suggestion| suggest(self.cx, suggestion, &h2q.terminals).0)\n+                        .collect()\n                 );\n             }\n         }"}, {"sha": "52ce90dd63debd6986944b633f7a236d50a98b65", "filename": "tests/ui/booleans.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7/tests%2Fui%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7/tests%2Fui%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbooleans.rs?ref=f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7", "patch": "@@ -38,3 +38,19 @@ fn equality_stuff() {\n     let _ = a > b && a == b;\n     let _ = a != b || !(a != b || c == d);\n }\n+\n+#[allow(unused, many_single_char_names)]\n+fn methods_with_negation() {\n+    let a: Option<i32> = unimplemented!();\n+    let b: Result<i32, i32> = unimplemented!();\n+    let _ = a.is_some();\n+    let _ = !a.is_some();\n+    let _ = a.is_none();\n+    let _ = !a.is_none();\n+    let _ = b.is_err();\n+    let _ = !b.is_err();\n+    let _ = b.is_ok();\n+    let _ = !b.is_ok();\n+    let c = false;\n+    let _ = !(a.is_some() && !c);\n+}"}, {"sha": "05696ba0f59b5aa297553dc05811f54558684782", "filename": "tests/ui/booleans.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7/tests%2Fui%2Fbooleans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7/tests%2Fui%2Fbooleans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbooleans.stderr?ref=f975fb54f8e8678f8c34d7eaaa2c927b3b6bcac7", "patch": "@@ -130,3 +130,33 @@ help: try\n 39 |     let _ = !(a == b && c == d);\n    |             ^^^^^^^^^^^^^^^^^^^\n \n+error: this boolean expression can be simplified\n+  --> $DIR/booleans.rs:47:13\n+   |\n+47 |     let _ = !a.is_some();\n+   |             ^^^^^^^^^^^^ help: try: `a.is_none()`\n+\n+error: this boolean expression can be simplified\n+  --> $DIR/booleans.rs:49:13\n+   |\n+49 |     let _ = !a.is_none();\n+   |             ^^^^^^^^^^^^ help: try: `a.is_some()`\n+\n+error: this boolean expression can be simplified\n+  --> $DIR/booleans.rs:51:13\n+   |\n+51 |     let _ = !b.is_err();\n+   |             ^^^^^^^^^^^ help: try: `b.is_ok()`\n+\n+error: this boolean expression can be simplified\n+  --> $DIR/booleans.rs:53:13\n+   |\n+53 |     let _ = !b.is_ok();\n+   |             ^^^^^^^^^^ help: try: `b.is_err()`\n+\n+error: this boolean expression can be simplified\n+  --> $DIR/booleans.rs:55:13\n+   |\n+55 |     let _ = !(a.is_some() && !c);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: try: `c || a.is_none()`\n+"}]}