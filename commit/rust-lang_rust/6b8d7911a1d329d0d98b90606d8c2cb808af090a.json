{"sha": "6b8d7911a1d329d0d98b90606d8c2cb808af090a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiOGQ3OTExYTFkMzI5ZDBkOThiOTA2MDZkOGMyY2I4MDhhZjA5MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-08T17:36:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-08T17:36:25Z"}, "message": "Auto merge of #77346 - Caduser2020:master, r=Mark-Simulacrum\n\n`#[deny(unsafe_op_in_unsafe_fn)]` in sys/sgx\n\nThis is part of #73904.\n\nEnclose unsafe operations in unsafe blocks in `libstd/sys/sgx`.", "tree": {"sha": "9635c5d8d15bbf53be6ba18bc7847369c5824f81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9635c5d8d15bbf53be6ba18bc7847369c5824f81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b8d7911a1d329d0d98b90606d8c2cb808af090a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8d7911a1d329d0d98b90606d8c2cb808af090a", "html_url": "https://github.com/rust-lang/rust/commit/6b8d7911a1d329d0d98b90606d8c2cb808af090a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b8d7911a1d329d0d98b90606d8c2cb808af090a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccea570488694e502c1a7ca8f3f0866c9b763ce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccea570488694e502c1a7ca8f3f0866c9b763ce4", "html_url": "https://github.com/rust-lang/rust/commit/ccea570488694e502c1a7ca8f3f0866c9b763ce4"}, {"sha": "1fb0a1d50123de3599ee1802e49cc7c616529735", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb0a1d50123de3599ee1802e49cc7c616529735", "html_url": "https://github.com/rust-lang/rust/commit/1fb0a1d50123de3599ee1802e49cc7c616529735"}], "stats": {"total": 289, "additions": 170, "deletions": 119}, "files": [{"sha": "a0eb12c3d154a7148abc7a45a0731ffe7db675d8", "filename": "library/std/src/sys/sgx/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -45,7 +45,7 @@ unsafe extern \"C\" fn tcs_init(secondary: bool) {\n         // We need to wait until the initialization is done.\n         BUSY => {\n             while RELOC_STATE.load(Ordering::Acquire) == BUSY {\n-                core::arch::x86_64::_mm_pause()\n+                core::hint::spin_loop();\n             }\n         }\n         // Initialization is done."}, {"sha": "13d96e9a633d34a344384e1dd760d702d346fd17", "filename": "library/std/src/sys/sgx/abi/tls.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -87,18 +87,21 @@ impl Tls {\n     }\n \n     pub unsafe fn activate(&self) -> ActiveTls<'_> {\n-        set_tls_ptr(self as *const Tls as _);\n+        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n+        unsafe { set_tls_ptr(self as *const Tls as _) };\n         ActiveTls { tls: self }\n     }\n \n     #[allow(unused)]\n     pub unsafe fn activate_persistent(self: Box<Self>) {\n-        set_tls_ptr((&*self) as *const Tls as _);\n+        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n+        unsafe { set_tls_ptr((&*self) as *const Tls as _) };\n         mem::forget(self);\n     }\n \n     unsafe fn current<'a>() -> &'a Tls {\n-        &*(get_tls_ptr() as *const Tls)\n+        // FIXME: Needs safety information. See entry.S for `set_tls_ptr` definition.\n+        unsafe { &*(get_tls_ptr() as *const Tls) }\n     }\n \n     pub fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {"}, {"sha": "9fdb1b4584479090c4e31de2d44989e090d9f1de", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -89,9 +89,12 @@ pub unsafe trait UserSafe {\n     /// * the pointed-to range is not in user memory.\n     unsafe fn from_raw_sized(ptr: *mut u8, size: usize) -> NonNull<Self> {\n         assert!(ptr.wrapping_add(size) >= ptr);\n-        let ret = Self::from_raw_sized_unchecked(ptr, size);\n-        Self::check_ptr(ret);\n-        NonNull::new_unchecked(ret as _)\n+        // SAFETY: The caller has guaranteed the pointer is valid\n+        let ret = unsafe { Self::from_raw_sized_unchecked(ptr, size) };\n+        unsafe {\n+            Self::check_ptr(ret);\n+            NonNull::new_unchecked(ret as _)\n+        }\n     }\n \n     /// Checks if a pointer may point to `Self` in user memory.\n@@ -112,7 +115,7 @@ pub unsafe trait UserSafe {\n         let is_aligned = |p| -> bool { 0 == (p as usize) & (Self::align_of() - 1) };\n \n         assert!(is_aligned(ptr as *const u8));\n-        assert!(is_user_range(ptr as _, mem::size_of_val(&*ptr)));\n+        assert!(is_user_range(ptr as _, mem::size_of_val(unsafe { &*ptr })));\n         assert!(!ptr.is_null());\n     }\n }\n@@ -135,11 +138,23 @@ unsafe impl<T: UserSafeSized> UserSafe for [T] {\n         mem::align_of::<T>()\n     }\n \n+    /// # Safety\n+    /// Behavior is undefined if any of these conditions are violated:\n+    /// * `ptr` must be [valid] for writes of `size` many bytes, and it must be\n+    ///   properly aligned.\n+    ///\n+    /// [valid]: core::ptr#safety\n+    /// # Panics\n+    ///\n+    /// This function panics if:\n+    ///\n+    /// * the element size is not a factor of the size\n     unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n         let elem_size = mem::size_of::<T>();\n         assert_eq!(size % elem_size, 0);\n         let len = size / elem_size;\n-        slice::from_raw_parts_mut(ptr as _, len)\n+        // SAFETY: The caller must uphold the safety contract for `from_raw_sized_unchecked`\n+        unsafe { slice::from_raw_parts_mut(ptr as _, len) }\n     }\n }\n \n@@ -170,13 +185,15 @@ trait NewUserRef<T: ?Sized> {\n \n impl<T: ?Sized> NewUserRef<*mut T> for NonNull<UserRef<T>> {\n     unsafe fn new_userref(v: *mut T) -> Self {\n-        NonNull::new_unchecked(v as _)\n+        // SAFETY: The caller has guaranteed the pointer is valid\n+        unsafe { NonNull::new_unchecked(v as _) }\n     }\n }\n \n impl<T: ?Sized> NewUserRef<NonNull<T>> for NonNull<UserRef<T>> {\n     unsafe fn new_userref(v: NonNull<T>) -> Self {\n-        NonNull::new_userref(v.as_ptr())\n+        // SAFETY: The caller has guaranteed the pointer is valid\n+        unsafe { NonNull::new_userref(v.as_ptr()) }\n     }\n }\n \n@@ -231,8 +248,9 @@ where\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw(ptr: *mut T) -> Self {\n-        T::check_ptr(ptr);\n-        User(NonNull::new_userref(ptr))\n+        // SAFETY: the caller must uphold the safety contract for `from_raw`.\n+        unsafe { T::check_ptr(ptr) };\n+        User(unsafe { NonNull::new_userref(ptr) })\n     }\n \n     /// Converts this value into a raw pointer. The value will no longer be\n@@ -280,7 +298,9 @@ where\n     /// * The pointed-to range does not fit in the address space\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n-        User(NonNull::new_userref(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>())))\n+        User(unsafe {\n+            NonNull::new_userref(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()))\n+        })\n     }\n }\n \n@@ -301,8 +321,9 @@ where\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_ptr<'a>(ptr: *const T) -> &'a Self {\n-        T::check_ptr(ptr);\n-        &*(ptr as *const Self)\n+        // SAFETY: The caller must uphold the safety contract for `from_ptr`.\n+        unsafe { T::check_ptr(ptr) };\n+        unsafe { &*(ptr as *const Self) }\n     }\n \n     /// Creates a `&mut UserRef<[T]>` from a raw pointer. See the struct\n@@ -318,8 +339,9 @@ where\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_mut_ptr<'a>(ptr: *mut T) -> &'a mut Self {\n-        T::check_ptr(ptr);\n-        &mut *(ptr as *mut Self)\n+        // SAFETY: The caller must uphold the safety contract for `from_mut_ptr`.\n+        unsafe { T::check_ptr(ptr) };\n+        unsafe { &mut *(ptr as *mut Self) }\n     }\n \n     /// Copies `val` into user memory.\n@@ -394,7 +416,10 @@ where\n     /// * The pointed-to range does not fit in the address space\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts<'a>(ptr: *const T, len: usize) -> &'a Self {\n-        &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *const Self)\n+        // SAFETY: The caller must uphold the safety contract for `from_raw_parts`.\n+        unsafe {\n+            &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *const Self)\n+        }\n     }\n \n     /// Creates a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n@@ -412,7 +437,10 @@ where\n     /// * The pointed-to range does not fit in the address space\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n-        &mut *(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n+        // SAFETY: The caller must uphold the safety contract for `from_raw_parts_mut`.\n+        unsafe {\n+            &mut *(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n+        }\n     }\n \n     /// Obtain a raw pointer to the first element of this user slice.\n@@ -437,13 +465,12 @@ where\n     /// This function panics if the destination doesn't have the same size as\n     /// the source. This can happen for dynamically-sized types such as slices.\n     pub fn copy_to_enclave_vec(&self, dest: &mut Vec<T>) {\n-        unsafe {\n-            if let Some(missing) = self.len().checked_sub(dest.capacity()) {\n-                dest.reserve(missing)\n-            }\n-            dest.set_len(self.len());\n-            self.copy_to_enclave(&mut dest[..]);\n+        if let Some(missing) = self.len().checked_sub(dest.capacity()) {\n+            dest.reserve(missing)\n         }\n+        // SAFETY: We reserve enough space above.\n+        unsafe { dest.set_len(self.len()) };\n+        self.copy_to_enclave(&mut dest[..]);\n     }\n \n     /// Copies the value from user memory into a vector in enclave memory."}, {"sha": "a6a659df291fc5b4b26d78ba813743392360ee00", "filename": "library/std/src/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -140,7 +140,8 @@ pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n /// Usercall `launch_thread`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub unsafe fn launch_thread() -> IoResult<()> {\n-    raw::launch_thread().from_sgx_result()\n+    // SAFETY: The caller must uphold the safety contract for `launch_thread`.\n+    unsafe { raw::launch_thread().from_sgx_result() }\n }\n \n /// Usercall `exit`. See the ABI documentation for more information."}, {"sha": "b0e6a6aaed7b9c4b1cb9279bb3d2817443f10af3", "filename": "library/std/src/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -33,7 +33,7 @@ pub unsafe fn do_usercall(\n     p4: u64,\n     abort: bool,\n ) -> (u64, u64) {\n-    let UsercallReturn(a, b) = usercall(nr, p1, p2, abort as _, p3, p4);\n+    let UsercallReturn(a, b) = unsafe { usercall(nr, p1, p2, abort as _, p3, p4) };\n     (a, b)\n }\n \n@@ -175,14 +175,14 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n-            ReturnValue::from_registers(stringify!($f), do_usercall(\n-                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n-                RegisterArgument::into_register($n1),\n-                RegisterArgument::into_register($n2),\n-                RegisterArgument::into_register($n3),\n-                RegisterArgument::into_register($n4),\n-                return_type_is_abort!($r)\n-            ))\n+            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n+                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n+                    RegisterArgument::into_register($n1),\n+                    RegisterArgument::into_register($n2),\n+                    RegisterArgument::into_register($n3),\n+                    RegisterArgument::into_register($n4),\n+                    return_type_is_abort!($r)\n+            ) })\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:tt) => (\n@@ -191,14 +191,14 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n-            ReturnValue::from_registers(stringify!($f), do_usercall(\n-                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n-                RegisterArgument::into_register($n1),\n-                RegisterArgument::into_register($n2),\n-                RegisterArgument::into_register($n3),\n-                0,\n-                return_type_is_abort!($r)\n-            ))\n+            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n+                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n+                    RegisterArgument::into_register($n1),\n+                    RegisterArgument::into_register($n2),\n+                    RegisterArgument::into_register($n3),\n+                    0,\n+                    return_type_is_abort!($r)\n+            ) })\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:tt) => (\n@@ -207,13 +207,13 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n-            ReturnValue::from_registers(stringify!($f), do_usercall(\n-                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n-                RegisterArgument::into_register($n1),\n-                RegisterArgument::into_register($n2),\n-                0,0,\n-                return_type_is_abort!($r)\n-            ))\n+            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n+                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n+                    RegisterArgument::into_register($n1),\n+                    RegisterArgument::into_register($n2),\n+                    0,0,\n+                    return_type_is_abort!($r)\n+            ) })\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty) -> $r:tt) => (\n@@ -222,12 +222,12 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1) -> $r {\n-            ReturnValue::from_registers(stringify!($f), do_usercall(\n-                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n-                RegisterArgument::into_register($n1),\n-                0,0,0,\n-                return_type_is_abort!($r)\n-            ))\n+            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n+                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n+                    RegisterArgument::into_register($n1),\n+                    0,0,0,\n+                    return_type_is_abort!($r)\n+            ) })\n         }\n     );\n     (def fn $f:ident() -> $r:tt) => (\n@@ -236,11 +236,11 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f() -> $r {\n-            ReturnValue::from_registers(stringify!($f), do_usercall(\n-                rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n-                0,0,0,0,\n-                return_type_is_abort!($r)\n-            ))\n+            ReturnValue::from_registers(stringify!($f), unsafe { do_usercall(\n+                    rtunwrap!(Some, NonZeroU64::new(Usercalls::$f as Register)),\n+                    0,0,0,0,\n+                    return_type_is_abort!($r)\n+            ) })\n         }\n     );\n     (def fn $f:ident($($n:ident: $t:ty),*)) => ("}, {"sha": "4559ea7cd25408ba455cf48ad93067953af292dd", "filename": "library/std/src/sys/sgx/alloc.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Falloc.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -4,6 +4,10 @@ use super::waitqueue::SpinMutex;\n \n // Using a SpinMutex because we never want to exit the enclave waiting for the\n // allocator.\n+//\n+// The current allocator here is the `dlmalloc` crate which we've got included\n+// in the rust-lang/rust repository as a submodule. The crate is a port of\n+// dlmalloc.c from C to Rust.\n #[cfg_attr(test, linkage = \"available_externally\")]\n #[export_name = \"_ZN16__rust_internals3std3sys3sgx5alloc8DLMALLOCE\"]\n static DLMALLOC: SpinMutex<dlmalloc::Dlmalloc> = SpinMutex::new(dlmalloc::DLMALLOC_INIT);\n@@ -12,22 +16,26 @@ static DLMALLOC: SpinMutex<dlmalloc::Dlmalloc> = SpinMutex::new(dlmalloc::DLMALL\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        DLMALLOC.lock().malloc(layout.size(), layout.align())\n+        // SAFETY: the caller must uphold the safety contract for `malloc`\n+        unsafe { DLMALLOC.lock().malloc(layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        DLMALLOC.lock().calloc(layout.size(), layout.align())\n+        // SAFETY: the caller must uphold the safety contract for `malloc`\n+        unsafe { DLMALLOC.lock().calloc(layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-        DLMALLOC.lock().free(ptr, layout.size(), layout.align())\n+        // SAFETY: the caller must uphold the safety contract for `malloc`\n+        unsafe { DLMALLOC.lock().free(ptr, layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        DLMALLOC.lock().realloc(ptr, layout.size(), layout.align(), new_size)\n+        // SAFETY: the caller must uphold the safety contract for `malloc`\n+        unsafe { DLMALLOC.lock().realloc(ptr, layout.size(), layout.align(), new_size) }\n     }\n }\n \n@@ -36,11 +44,11 @@ unsafe impl GlobalAlloc for System {\n #[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_c_alloc(size: usize, align: usize) -> *mut u8 {\n-    crate::alloc::alloc(Layout::from_size_align_unchecked(size, align))\n+    unsafe { crate::alloc::alloc(Layout::from_size_align_unchecked(size, align)) }\n }\n \n #[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn __rust_c_dealloc(ptr: *mut u8, size: usize, align: usize) {\n-    crate::alloc::dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n+    unsafe { crate::alloc::dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }\n }"}, {"sha": "2d2e692ec7d35e09346d12053ed81dbd62cbcb13", "filename": "library/std/src/sys/sgx/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -13,7 +13,7 @@ type ArgsStore = Vec<OsString>;\n #[cfg_attr(test, allow(dead_code))]\n pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     if argc != 0 {\n-        let args = alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _);\n+        let args = unsafe { alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _) };\n         let args = args\n             .iter()\n             .map(|a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }))"}, {"sha": "55ac052d97508b8bec7c87c72baa127476ebf95b", "filename": "library/std/src/sys/sgx/condvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -29,13 +29,13 @@ impl Condvar {\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n         let guard = self.inner.lock();\n-        WaitQueue::wait(guard, || mutex.unlock());\n-        mutex.lock()\n+        WaitQueue::wait(guard, || unsafe { mutex.unlock() });\n+        unsafe { mutex.lock() }\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let success = WaitQueue::wait_timeout(&self.inner, dur, || mutex.unlock());\n-        mutex.lock();\n+        let success = WaitQueue::wait_timeout(&self.inner, dur, || unsafe { mutex.unlock() });\n+        unsafe { mutex.lock() };\n         success\n     }\n "}, {"sha": "b10bed621dbadeb51466033e5a10f7bb7187f59f", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -2,6 +2,7 @@\n //!\n //! This module contains the facade (aka platform-specific) implementations of\n //! OS level functionality for Fortanix SGX.\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::io::ErrorKind;\n use crate::os::raw::c_char;\n@@ -121,9 +122,9 @@ pub enum Void {}\n \n pub unsafe fn strlen(mut s: *const c_char) -> usize {\n     let mut n = 0;\n-    while *s != 0 {\n+    while unsafe { *s } != 0 {\n         n += 1;\n-        s = s.offset(1);\n+        s = unsafe { s.offset(1) };\n     }\n     return n;\n }"}, {"sha": "0c96e3fcddcdfaae316562176e8f26578d6a30eb", "filename": "library/std/src/sys/sgx/rwlock.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -14,9 +14,12 @@ pub struct RWLock {\n }\n \n // Check at compile time that RWLock size matches C definition (see test_c_rwlock_initializer below)\n+//\n+// # Safety\n+// Never called, as it is a compile time check.\n #[allow(dead_code)]\n unsafe fn rw_lock_size_assert(r: RWLock) {\n-    mem::transmute::<RWLock, [u8; 144]>(r);\n+    unsafe { mem::transmute::<RWLock, [u8; 144]>(r) };\n }\n \n impl RWLock {\n@@ -112,7 +115,7 @@ impl RWLock {\n     pub unsafe fn read_unlock(&self) {\n         let rguard = self.readers.lock();\n         let wguard = self.writer.lock();\n-        self.__read_unlock(rguard, wguard);\n+        unsafe { self.__read_unlock(rguard, wguard) };\n     }\n \n     #[inline]\n@@ -148,7 +151,7 @@ impl RWLock {\n     pub unsafe fn write_unlock(&self) {\n         let rguard = self.readers.lock();\n         let wguard = self.writer.lock();\n-        self.__write_unlock(rguard, wguard);\n+        unsafe { self.__write_unlock(rguard, wguard) };\n     }\n \n     // only used by __rust_rwlock_unlock below\n@@ -158,9 +161,9 @@ impl RWLock {\n         let rguard = self.readers.lock();\n         let wguard = self.writer.lock();\n         if *wguard.lock_var() == true {\n-            self.__write_unlock(rguard, wguard);\n+            unsafe { self.__write_unlock(rguard, wguard) };\n         } else {\n-            self.__read_unlock(rguard, wguard);\n+            unsafe { self.__read_unlock(rguard, wguard) };\n         }\n     }\n \n@@ -179,7 +182,7 @@ pub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n     if p.is_null() {\n         return EINVAL;\n     }\n-    (*p).read();\n+    unsafe { (*p).read() };\n     return 0;\n }\n \n@@ -189,7 +192,7 @@ pub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RWLock) -> i32 {\n     if p.is_null() {\n         return EINVAL;\n     }\n-    (*p).write();\n+    unsafe { (*p).write() };\n     return 0;\n }\n #[cfg(not(test))]\n@@ -198,6 +201,6 @@ pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n     if p.is_null() {\n         return EINVAL;\n     }\n-    (*p).unlock();\n+    unsafe { (*p).unlock() };\n     return 0;\n }"}, {"sha": "548e28a43d646281c0b2ef65742cedc17d2b0980", "filename": "library/std/src/sys/sgx/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fstdio.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -81,7 +81,7 @@ pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n     if s < 0 {\n         return;\n     }\n-    let buf = slice::from_raw_parts(m as *const u8, s as _);\n+    let buf = unsafe { slice::from_raw_parts(m as *const u8, s as _) };\n     if let Ok(s) = str::from_utf8(&buf[..buf.iter().position(|&b| b == 0).unwrap_or(buf.len())]) {\n         eprint!(\"{}\", s);\n     }"}, {"sha": "55ef460cc90c55116acb170c0f992e9d98f12526", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -51,7 +51,7 @@ impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(_stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         let mut queue_lock = task_queue::lock();\n-        usercalls::launch_thread()?;\n+        unsafe { usercalls::launch_thread()? };\n         let (task, handle) = task_queue::Task::new(p);\n         queue_lock.push(task);\n         Ok(Thread(handle))"}, {"sha": "0834d2593fc320735564aea28667e4ccdc7f0447", "filename": "library/std/src/sys/sgx/waitqueue/unsafe_list.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -30,31 +30,34 @@ impl<T> UnsafeList<T> {\n         unsafe { UnsafeList { head_tail: NonNull::new_unchecked(1 as _), head_tail_entry: None } }\n     }\n \n+    /// # Safety\n     unsafe fn init(&mut self) {\n         if self.head_tail_entry.is_none() {\n             self.head_tail_entry = Some(UnsafeListEntry::dummy());\n-            self.head_tail = NonNull::new_unchecked(self.head_tail_entry.as_mut().unwrap());\n-            self.head_tail.as_mut().next = self.head_tail;\n-            self.head_tail.as_mut().prev = self.head_tail;\n+            // SAFETY: `head_tail_entry` must be non-null, which it is because we assign it above.\n+            self.head_tail =\n+                unsafe { NonNull::new_unchecked(self.head_tail_entry.as_mut().unwrap()) };\n+            // SAFETY: `self.head_tail` must meet all requirements for a mutable reference.\n+            unsafe { self.head_tail.as_mut() }.next = self.head_tail;\n+            unsafe { self.head_tail.as_mut() }.prev = self.head_tail;\n         }\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        unsafe {\n-            if self.head_tail_entry.is_some() {\n-                let first = self.head_tail.as_ref().next;\n-                if first == self.head_tail {\n-                    // ,-------> /---------\\ next ---,\n-                    // |         |head_tail|         |\n-                    // `--- prev \\---------/ <-------`\n-                    rtassert!(self.head_tail.as_ref().prev == first);\n-                    true\n-                } else {\n-                    false\n-                }\n-            } else {\n+        if self.head_tail_entry.is_some() {\n+            let first = unsafe { self.head_tail.as_ref() }.next;\n+            if first == self.head_tail {\n+                // ,-------> /---------\\ next ---,\n+                // |         |head_tail|         |\n+                // `--- prev \\---------/ <-------`\n+                // SAFETY: `self.head_tail` must meet all requirements for a reference.\n+                unsafe { rtassert!(self.head_tail.as_ref().prev == first) };\n                 true\n+            } else {\n+                false\n             }\n+        } else {\n+            true\n         }\n     }\n \n@@ -67,7 +70,7 @@ impl<T> UnsafeList<T> {\n     /// care must be taken in the caller of `push` to ensure unwinding does\n     /// not destroy the stack frame containing the entry.\n     pub unsafe fn push<'a>(&mut self, entry: &'a mut UnsafeListEntry<T>) -> &'a T {\n-        self.init();\n+        unsafe { self.init() };\n \n         // BEFORE:\n         //     /---------\\ next ---> /---------\\\n@@ -78,13 +81,15 @@ impl<T> UnsafeList<T> {\n         //     /---------\\ next ---> /-----\\ next ---> /---------\\\n         // ... |prev_tail|           |entry|           |head_tail| ...\n         //     \\---------/ <--- prev \\-----/ <--- prev \\---------/\n-        let mut entry = NonNull::new_unchecked(entry);\n-        let mut prev_tail = mem::replace(&mut self.head_tail.as_mut().prev, entry);\n-        entry.as_mut().prev = prev_tail;\n-        entry.as_mut().next = self.head_tail;\n-        prev_tail.as_mut().next = entry;\n+        let mut entry = unsafe { NonNull::new_unchecked(entry) };\n+        let mut prev_tail = mem::replace(&mut unsafe { self.head_tail.as_mut() }.prev, entry);\n+        // SAFETY: `entry` must meet all requirements for a mutable reference.\n+        unsafe { entry.as_mut() }.prev = prev_tail;\n+        unsafe { entry.as_mut() }.next = self.head_tail;\n+        // SAFETY: `prev_tail` must meet all requirements for a mutable reference.\n+        unsafe { prev_tail.as_mut() }.next = entry;\n         // unwrap ok: always `Some` on non-dummy entries\n-        (*entry.as_ptr()).value.as_ref().unwrap()\n+        unsafe { (*entry.as_ptr()).value.as_ref() }.unwrap()\n     }\n \n     /// Pops an entry from the front of the list.\n@@ -94,7 +99,7 @@ impl<T> UnsafeList<T> {\n     /// The caller must make sure to synchronize ending the borrow of the\n     /// return value and deallocation of the containing entry.\n     pub unsafe fn pop<'a>(&mut self) -> Option<&'a T> {\n-        self.init();\n+        unsafe { self.init() };\n \n         if self.is_empty() {\n             None\n@@ -108,14 +113,14 @@ impl<T> UnsafeList<T> {\n             //     /---------\\ next ---> /------\\\n             // ... |head_tail|           |second| ...\n             //     \\---------/ <--- prev \\------/\n-            let mut first = self.head_tail.as_mut().next;\n-            let mut second = first.as_mut().next;\n-            self.head_tail.as_mut().next = second;\n-            second.as_mut().prev = self.head_tail;\n-            first.as_mut().next = NonNull::dangling();\n-            first.as_mut().prev = NonNull::dangling();\n+            let mut first = unsafe { self.head_tail.as_mut() }.next;\n+            let mut second = unsafe { first.as_mut() }.next;\n+            unsafe { self.head_tail.as_mut() }.next = second;\n+            unsafe { second.as_mut() }.prev = self.head_tail;\n+            unsafe { first.as_mut() }.next = NonNull::dangling();\n+            unsafe { first.as_mut() }.prev = NonNull::dangling();\n             // unwrap ok: always `Some` on non-dummy entries\n-            Some((*first.as_ptr()).value.as_ref().unwrap())\n+            Some(unsafe { (*first.as_ptr()).value.as_ref() }.unwrap())\n         }\n     }\n \n@@ -138,8 +143,9 @@ impl<T> UnsafeList<T> {\n         //     \\----/ <--- prev \\----/\n         let mut prev = entry.prev;\n         let mut next = entry.next;\n-        prev.as_mut().next = next;\n-        next.as_mut().prev = prev;\n+        // SAFETY: `prev` and `next` must meet all requirements for a mutable reference.entry\n+        unsafe { prev.as_mut() }.next = next;\n+        unsafe { next.as_mut() }.prev = prev;\n         entry.next = NonNull::dangling();\n         entry.prev = NonNull::dangling();\n     }"}, {"sha": "c653dee17bc36131c16426d1482f6875bcb35cc2", "filename": "library/std/src/sys/sgx/waitqueue/unsafe_list/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b8d7911a1d329d0d98b90606d8c2cb808af090a/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list%2Ftests.rs?ref=6b8d7911a1d329d0d98b90606d8c2cb808af090a", "patch": "@@ -1,8 +1,10 @@\n use super::*;\n use crate::cell::Cell;\n \n+/// # Safety\n+/// List must be valid.\n unsafe fn assert_empty<T>(list: &mut UnsafeList<T>) {\n-    assert!(list.pop().is_none(), \"assertion failed: list is not empty\");\n+    assert!(unsafe { list.pop() }.is_none(), \"assertion failed: list is not empty\");\n }\n \n #[test]"}]}