{"sha": "89b61ea09f03060ceac3d0a1779dbb4152b6fddd", "node_id": "C_kwDOAAsO6NoAKDg5YjYxZWEwOWYwMzA2MGNlYWMzZDBhMTc3OWRiYjQxNTJiNmZkZGQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-01T05:32:13Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-01T22:06:34Z"}, "message": "Inline and remove `FileSearch::search`.\n\nIt has only a single callsite, and having all the code in one place will\nmake it possible to optimize the search.", "tree": {"sha": "d2d87a42b44b0d1a470b4b17c4b6d2f8cc940872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2d87a42b44b0d1a470b4b17c4b6d2f8cc940872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89b61ea09f03060ceac3d0a1779dbb4152b6fddd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89b61ea09f03060ceac3d0a1779dbb4152b6fddd", "html_url": "https://github.com/rust-lang/rust/commit/89b61ea09f03060ceac3d0a1779dbb4152b6fddd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89b61ea09f03060ceac3d0a1779dbb4152b6fddd/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47b5d95db8abaaf4fdad878ec3b06dfaa2a1d74f", "url": "https://api.github.com/repos/rust-lang/rust/commits/47b5d95db8abaaf4fdad878ec3b06dfaa2a1d74f", "html_url": "https://github.com/rust-lang/rust/commit/47b5d95db8abaaf4fdad878ec3b06dfaa2a1d74f"}], "stats": {"total": 96, "additions": 47, "deletions": 49}, "files": [{"sha": "f65cd73007b3403b8ed43039984ec9d31fab67bf", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/89b61ea09f03060ceac3d0a1779dbb4152b6fddd/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b61ea09f03060ceac3d0a1779dbb4152b6fddd/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=89b61ea09f03060ceac3d0a1779dbb4152b6fddd", "patch": "@@ -394,44 +394,55 @@ impl<'a> CrateLocator<'a> {\n         // of the crate id (path/name/id).\n         //\n         // The goal of this step is to look at as little metadata as possible.\n-        self.filesearch.search(|spf, kind| {\n-            let file = match &spf.file_name_str {\n-                None => return,\n-                Some(file) => file,\n-            };\n-            let (hash, found_kind) = if file.starts_with(&rlib_prefix) && file.ends_with(\".rlib\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n-            } else if file.starts_with(&rlib_prefix) && file.ends_with(\".rmeta\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n-            } else if file.starts_with(&dylib_prefix) && file.ends_with(&self.target.dll_suffix) {\n-                (\n-                    &file[(dylib_prefix.len())..(file.len() - self.target.dll_suffix.len())],\n-                    CrateFlavor::Dylib,\n-                )\n-            } else {\n-                if file.starts_with(&staticlib_prefix)\n-                    && file.ends_with(&self.target.staticlib_suffix)\n+        for search_path in self.filesearch.search_paths() {\n+            debug!(\"searching {}\", search_path.dir.display());\n+            for spf in search_path.files.iter() {\n+                debug!(\"testing {}\", spf.path.display());\n+\n+                let file = match &spf.file_name_str {\n+                    None => continue,\n+                    Some(file) => file,\n+                };\n+                let (hash, found_kind) = if file.starts_with(&rlib_prefix)\n+                    && file.ends_with(\".rlib\")\n                 {\n-                    staticlibs\n-                        .push(CrateMismatch { path: spf.path.clone(), got: \"static\".to_string() });\n-                }\n-                return;\n-            };\n+                    (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n+                } else if file.starts_with(&rlib_prefix) && file.ends_with(\".rmeta\") {\n+                    (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n+                } else if file.starts_with(&dylib_prefix) && file.ends_with(&self.target.dll_suffix)\n+                {\n+                    (\n+                        &file[(dylib_prefix.len())..(file.len() - self.target.dll_suffix.len())],\n+                        CrateFlavor::Dylib,\n+                    )\n+                } else {\n+                    if file.starts_with(&staticlib_prefix)\n+                        && file.ends_with(&self.target.staticlib_suffix)\n+                    {\n+                        staticlibs.push(CrateMismatch {\n+                            path: spf.path.clone(),\n+                            got: \"static\".to_string(),\n+                        });\n+                    }\n+                    continue;\n+                };\n \n-            info!(\"lib candidate: {}\", spf.path.display());\n+                info!(\"lib candidate: {}\", spf.path.display());\n+\n+                let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n+                let path = fs::canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n+                if seen_paths.contains(&path) {\n+                    continue;\n+                };\n+                seen_paths.insert(path.clone());\n+                match found_kind {\n+                    CrateFlavor::Rlib => rlibs.insert(path, search_path.kind),\n+                    CrateFlavor::Rmeta => rmetas.insert(path, search_path.kind),\n+                    CrateFlavor::Dylib => dylibs.insert(path, search_path.kind),\n+                };\n+            }\n+        }\n \n-            let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n-            let path = fs::canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n-            if seen_paths.contains(&path) {\n-                return;\n-            };\n-            seen_paths.insert(path.clone());\n-            match found_kind {\n-                CrateFlavor::Rlib => rlibs.insert(path, kind),\n-                CrateFlavor::Rmeta => rmetas.insert(path, kind),\n-                CrateFlavor::Dylib => dylibs.insert(path, kind),\n-            };\n-        });\n         self.crate_rejections.via_kind.extend(staticlibs);\n \n         // We have now collected all known libraries into a set of candidates"}, {"sha": "9200be363addec569720abb729430f2e64ce633f", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89b61ea09f03060ceac3d0a1779dbb4152b6fddd/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b61ea09f03060ceac3d0a1779dbb4152b6fddd/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=89b61ea09f03060ceac3d0a1779dbb4152b6fddd", "patch": "@@ -5,7 +5,7 @@ use std::fs;\n use std::iter::FromIterator;\n use std::path::{Path, PathBuf};\n \n-use crate::search_paths::{PathKind, SearchPath, SearchPathFile};\n+use crate::search_paths::{PathKind, SearchPath};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use tracing::debug;\n \n@@ -41,19 +41,6 @@ impl<'a> FileSearch<'a> {\n         self.get_lib_path().join(\"self-contained\")\n     }\n \n-    pub fn search<F>(&self, mut pick: F)\n-    where\n-        F: FnMut(&SearchPathFile, PathKind),\n-    {\n-        for search_path in self.search_paths() {\n-            debug!(\"searching {}\", search_path.dir.display());\n-            for spf in search_path.files.iter() {\n-                debug!(\"testing {}\", spf.path.display());\n-                pick(spf, search_path.kind);\n-            }\n-        }\n-    }\n-\n     pub fn new(\n         sysroot: &'a Path,\n         triple: &'a str,"}]}