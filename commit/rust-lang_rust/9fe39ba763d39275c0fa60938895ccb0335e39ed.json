{"sha": "9fe39ba763d39275c0fa60938895ccb0335e39ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZTM5YmE3NjNkMzkyNzVjMGZhNjA5Mzg4OTVjY2IwMzM1ZTM5ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-22T22:34:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-22T22:34:23Z"}, "message": "Auto merge of #1250 - RalfJung:error-context, r=oli-obk\n\ngive some context in error messages\n\n### Some examples for how different errors look now\n\nUnsupported operation:\n```\nerror: unsupported operation: Miri does not support threading\n  --> /home/r/.rustup/toolchains/miri/lib/rustlib/src/rust/src/libstd/sys/unix/thread.rs:68:19\n   |\n68 |         let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Miri does not support threading\n   |\n   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n```\nUnsupported operation that works without isolation:\n```\nerror: unsupported operation: `clock_gettime` not available when isolation is enabled\n   --> /home/r/.rustup/toolchains/miri/lib/rustlib/src/rust/src/libstd/sys/unix/time.rs:349:22\n    |\n349 |         cvt(unsafe { libc::clock_gettime(clock, &mut t.t) }).unwrap();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `clock_gettime` not available when isolation is enabled\n    |\n    = help: pass the flag `-Zmiri-disable-isolation` to disable isolation\n```\nProgram abort:\n```\nerror: program stopped: the evaluated program aborted execution\n   --> /home/r/.rustup/toolchains/miri/lib/rustlib/src/rust/src/libstd/panicking.rs:530:18\n    |\n530 |         unsafe { intrinsics::abort() }\n    |                  ^^^^^^^^^^^^^^^^^^^ the evaluated program aborted execution\n    |\n```\nUB:\n```\nerror: Undefined Behavior: type validation failed: encountered 2, but expected a boolean\n --> tests/compile-fail/validity/invalid_bool.rs:2:23\n  |\n2 |     let _b = unsafe { std::mem::transmute::<u8, bool>(2) }; //~ ERROR encountered 2, but expected a boolean\n  |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 2, but expected a boolean\n  |\n  = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n```\nExperimental UB:\n```\nerror: Undefined Behavior: not granting access to tag <1562> because incompatible item is protected: [Unique for <1567> (call 1189)]\n  --> tests/compile-fail/stacked_borrows/aliasing_mut1.rs:3:1\n   |\n3  | pub fn safe(_x: &mut i32, _y: &mut i32) {} //~ ERROR protect\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <1562> because incompatible item is protected: [Unique for <1567> (call 1189)]\n   |\n   = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\n```\n\nFixes https://github.com/rust-lang/miri/issues/417", "tree": {"sha": "7a0c9be0f86b3fdee62209beb65c79603a12c7b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a0c9be0f86b3fdee62209beb65c79603a12c7b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fe39ba763d39275c0fa60938895ccb0335e39ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe39ba763d39275c0fa60938895ccb0335e39ed", "html_url": "https://github.com/rust-lang/rust/commit/9fe39ba763d39275c0fa60938895ccb0335e39ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fe39ba763d39275c0fa60938895ccb0335e39ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7d2266414565647374f8e25c03854adde09aab2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d2266414565647374f8e25c03854adde09aab2", "html_url": "https://github.com/rust-lang/rust/commit/d7d2266414565647374f8e25c03854adde09aab2"}, {"sha": "6e302b830a8ac07efc1dca3ba1354338801bf7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e302b830a8ac07efc1dca3ba1354338801bf7d4", "html_url": "https://github.com/rust-lang/rust/commit/6e302b830a8ac07efc1dca3ba1354338801bf7d4"}], "stats": {"total": 191, "additions": 123, "deletions": 68}, "files": [{"sha": "a2cdffdf80b3d894c8ec96a0ddfcb5a571ab09d4", "filename": "src/diagnostics.rs", "status": "modified", "additions": 97, "deletions": 45, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=9fe39ba763d39275c0fa60938895ccb0335e39ed", "patch": "@@ -1,75 +1,127 @@\n-use rustc_mir::interpret::InterpErrorInfo;\n use std::cell::RefCell;\n \n+use rustc_span::DUMMY_SP;\n+\n use crate::*;\n \n+/// Details of premature program termination.\n+pub enum TerminationInfo {\n+    Exit(i64),\n+    Abort(Option<String>),\n+    UnsupportedInIsolation(String),\n+    ExperimentalUb { msg: String, url: String }\n+}\n+\n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n     PoppedTrackedPointerTag(Item),\n     CreatedAlloc(AllocId),\n }\n \n /// Emit a custom diagnostic without going through the miri-engine machinery\n-pub fn report_diagnostic<'tcx, 'mir>(\n+pub fn report_error<'tcx, 'mir>(\n     ecx: &InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n     mut e: InterpErrorInfo<'tcx>,\n ) -> Option<i64> {\n-    // Special treatment for some error kinds\n-    let msg = match e.kind {\n-        InterpError::MachineStop(ref info) => {\n+    use InterpError::*;\n+\n+    e.print_backtrace();\n+    let (title, msg, helps) = match e.kind {\n+        MachineStop(info) => {\n             let info = info.downcast_ref::<TerminationInfo>().expect(\"invalid MachineStop payload\");\n-            match info {\n-                TerminationInfo::Exit(code) => return Some(*code),\n-                TerminationInfo::Abort(None) => format!(\"the evaluated program aborted execution\"),\n-                TerminationInfo::Abort(Some(msg)) => format!(\"the evaluated program aborted execution: {}\", msg),\n-            }\n+            use TerminationInfo::*;\n+            let (title, msg) = match info {\n+                Exit(code) => return Some(*code),\n+                Abort(None) =>\n+                    (\"abnormal termination\", format!(\"the evaluated program aborted execution\")),\n+                Abort(Some(msg)) =>\n+                    (\"abnormal termination\", format!(\"the evaluated program aborted execution: {}\", msg)),\n+                UnsupportedInIsolation(msg) =>\n+                    (\"unsupported operation\", format!(\"{}\", msg)),\n+                ExperimentalUb { msg, .. } =>\n+                    (\"Undefined Behavior\", format!(\"{}\", msg)),\n+            };\n+            let helps = match info {\n+                UnsupportedInIsolation(_) =>\n+                    vec![format!(\"pass the flag `-Zmiri-disable-isolation` to disable isolation\")],\n+                ExperimentalUb { url, .. } =>\n+                    vec![\n+                        format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\"),\n+                        format!(\"see {} for further information\", url),\n+                    ],\n+                _ => vec![],\n+            };\n+            (title, msg, helps)\n+        }\n+        _ => {\n+            let (title, msg) = match e.kind {\n+                Unsupported(_) =>\n+                    (\"unsupported operation\", e.to_string()),\n+                UndefinedBehavior(_) =>\n+                    (\"Undefined Behavior\", e.to_string()),\n+                ResourceExhaustion(_) =>\n+                    (\"resource exhaustion\", e.to_string()),\n+                _ =>\n+                    bug!(\"This error should be impossible in Miri: {}\", e),\n+            };\n+            let helps = match e.kind {\n+                Unsupported(UnsupportedOpInfo::NoMirFor(..)) =>\n+                    vec![format!(\"make sure to use a Miri sysroot, which you can prepare with `cargo miri setup`\")],\n+                Unsupported(_) =>\n+                    vec![format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\")],\n+                UndefinedBehavior(_) =>\n+                    vec![\n+                        format!(\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\"),\n+                        format!(\"see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\"),\n+                    ],\n+                _ => vec![],\n+            };\n+            (title, msg, helps)\n         }\n-        err_unsup!(NoMirFor(..)) => format!(\n-            \"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\",\n-            e\n-        ),\n-        InterpError::InvalidProgram(_) => bug!(\"This error should be impossible in Miri: {}\", e),\n-        _ => e.to_string(),\n     };\n-    e.print_backtrace();\n-    report_msg(ecx, msg, true)\n+    report_msg(ecx, &format!(\"{}: {}\", title, msg), msg, &helps, true)\n }\n \n /// Report an error or note (depending on the `error` argument) at the current frame's current statement.\n /// Also emits a full stacktrace of the interpreter stack.\n-pub fn report_msg<'tcx, 'mir>(\n+fn report_msg<'tcx, 'mir>(\n     ecx: &InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n-    msg: String,\n+    title: &str,\n+    span_msg: String,\n+    helps: &[String],\n     error: bool,\n ) -> Option<i64> {\n-    if let Some(frame) = ecx.stack().last() {\n-        let span = frame.current_source_info().unwrap().span;\n-\n-        let mut err = if error {\n-            let msg = format!(\"Miri evaluation error: {}\", msg);\n-            ecx.tcx.sess.struct_span_err(span, msg.as_str())\n+    let span = if let Some(frame) = ecx.stack().last() {\n+        frame.current_source_info().unwrap().span\n+    } else {\n+        DUMMY_SP\n+    };\n+    let mut err = if error {\n+        ecx.tcx.sess.struct_span_err(span, title)\n+    } else {\n+        ecx.tcx.sess.diagnostic().span_note_diag(span, title)\n+    };\n+    err.span_label(span, span_msg);\n+    for help in helps {\n+        err.help(help);\n+    }\n+    // Add backtrace\n+    let frames = ecx.generate_stacktrace(None);\n+    // We iterate with indices because we need to look at the next frame (the caller).\n+    for idx in 0..frames.len() {\n+        let frame_info = &frames[idx];\n+        let call_site_is_local = frames\n+            .get(idx + 1)\n+            .map_or(false, |caller_info| caller_info.instance.def_id().is_local());\n+        if call_site_is_local {\n+            err.span_note(frame_info.call_site, &frame_info.to_string());\n         } else {\n-            ecx.tcx.sess.diagnostic().span_note_diag(span, msg.as_str())\n-        };\n-        let frames = ecx.generate_stacktrace(None);\n-        err.span_label(span, msg);\n-        // We iterate with indices because we need to look at the next frame (the caller).\n-        for idx in 0..frames.len() {\n-            let frame_info = &frames[idx];\n-            let call_site_is_local = frames\n-                .get(idx + 1)\n-                .map_or(false, |caller_info| caller_info.instance.def_id().is_local());\n-            if call_site_is_local {\n-                err.span_note(frame_info.call_site, &frame_info.to_string());\n-            } else {\n-                err.note(&frame_info.to_string());\n-            }\n+            err.note(&frame_info.to_string());\n         }\n-        err.emit();\n-    } else {\n-        ecx.tcx.sess.err(&msg);\n     }\n \n+    err.emit();\n+\n     for (i, frame) in ecx.stack().iter().enumerate() {\n         trace!(\"-------------------\");\n         trace!(\"Frame {}\", i);\n@@ -106,7 +158,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     CreatedAlloc(AllocId(id)) =>\n                         format!(\"created allocation with id {}\", id),\n                 };\n-                report_msg(this, msg, false);\n+                report_msg(this, \"tracking was triggered\", msg, &[], false);\n             }\n         });\n     }"}, {"sha": "d2ca57c39a792c576021e7d2f379980eb0743b4e", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=9fe39ba763d39275c0fa60938895ccb0335e39ed", "patch": "@@ -51,12 +51,6 @@ impl Default for MiriConfig {\n     }\n }\n \n-/// Details of premature program termination.\n-pub enum TerminationInfo {\n-    Exit(i64),\n-    Abort(Option<String>),\n-}\n-\n /// Returns a freshly created `InterpCx`, along with an `MPlaceTy` representing\n /// the location where the return value of the `start` lang item will be\n /// written to.\n@@ -229,6 +223,6 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n             }\n             Some(return_code)\n         }\n-        Err(e) => report_diagnostic(&ecx, e),\n+        Err(e) => report_error(&ecx, e),\n     }\n }"}, {"sha": "ab6e33f231884f1ecea26a53a7041bfbfcfa542d", "filename": "src/helpers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=9fe39ba763d39275c0fa60938895ccb0335e39ed", "patch": "@@ -367,10 +367,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// case.\n     fn check_no_isolation(&self, name: &str) -> InterpResult<'tcx> {\n         if !self.eval_context_ref().machine.communicate {\n-            throw_unsup_format!(\n-                \"`{}` not available when isolation is enabled (pass the flag `-Zmiri-disable-isolation` to disable isolation)\",\n+            throw_machine_stop!(TerminationInfo::UnsupportedInIsolation(format!(\n+                \"`{}` not available when isolation is enabled\",\n                 name,\n-            )\n+            )))\n         }\n         Ok(())\n     }"}, {"sha": "32eb5b41e591962bf94922af4d7bc12369ece3e3", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9fe39ba763d39275c0fa60938895ccb0335e39ed", "patch": "@@ -45,10 +45,10 @@ pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::shims::EvalContextExt as ShimsEvalContextExt;\n \n pub use crate::diagnostics::{\n-    register_diagnostic, report_diagnostic, EvalContextExt as DiagnosticsEvalContextExt,\n-    NonHaltingDiagnostic,\n+    register_diagnostic, report_error, EvalContextExt as DiagnosticsEvalContextExt,\n+    TerminationInfo, NonHaltingDiagnostic,\n };\n-pub use crate::eval::{create_ecx, eval_main, MiriConfig, TerminationInfo};\n+pub use crate::eval::{create_ecx, eval_main, MiriConfig};\n pub use crate::helpers::EvalContextExt as HelpersEvalContextExt;\n pub use crate::machine::{\n     AllocExtra, Evaluator, FrameData, MemoryExtra, MiriEvalContext, MiriEvalContextExt,"}, {"sha": "05b9c478cfea343d4c8735201f851ccfde501c8c", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe39ba763d39275c0fa60938895ccb0335e39ed/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=9fe39ba763d39275c0fa60938895ccb0335e39ed", "patch": "@@ -192,6 +192,15 @@ impl GlobalState {\n     }\n }\n \n+/// Error reporting\n+fn err_sb_ub(msg: String) -> InterpError<'static> {\n+    // FIXME: use `err_machine_stop!` macro, once that exists.\n+    InterpError::MachineStop(Box::new(TerminationInfo::ExperimentalUb {\n+        msg,\n+        url: format!(\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\"),\n+    }))\n+}\n+\n // # Stacked Borrows Core Begin\n \n /// We need to make at least the following things true:\n@@ -272,15 +281,15 @@ impl<'tcx> Stack {\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n                 if let Some(tag) = tag {\n-                    throw_ub!(UbExperimental(format!(\n+                    Err(err_sb_ub(format!(\n                         \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                         tag, item\n-                    )));\n+                    )))?\n                 } else {\n-                    throw_ub!(UbExperimental(format!(\n+                    Err(err_sb_ub(format!(\n                         \"deallocating while item is protected: {:?}\",\n                         item\n-                    )));\n+                    )))?\n                 }\n             }\n         }\n@@ -294,10 +303,10 @@ impl<'tcx> Stack {\n \n         // Step 1: Find granting item.\n         let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n-            err_ub!(UbExperimental(format!(\n+            err_sb_ub(format!(\n                 \"no item granting {} to tag {:?} found in borrow stack.\",\n                 access, tag\n-            ),))\n+            ))\n         })?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n@@ -338,10 +347,10 @@ impl<'tcx> Stack {\n     fn dealloc(&mut self, tag: Tag, global: &GlobalState) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n-            err_ub!(UbExperimental(format!(\n+            err_sb_ub(format!(\n                 \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n                 tag,\n-            )))\n+            ))\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n@@ -363,10 +372,10 @@ impl<'tcx> Stack {\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n         let granting_idx = self.find_granting(access, derived_from)\n-            .ok_or_else(|| err_ub!(UbExperimental(format!(\n+            .ok_or_else(|| err_sb_ub(format!(\n                 \"trying to reborrow for {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\",\n                 new.perm, derived_from,\n-            ))))?;\n+            )))?;\n \n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between"}]}