{"sha": "108b8b6dc707775bd54aeea7820e0d473f556718", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwOGI4YjZkYzcwNzc3NWJkNTRhZWVhNzgyMGUwZDQ3M2Y1NTY3MTg=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2014-06-18T18:25:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-19T00:02:22Z"}, "message": "Deprecate the bytes!() macro.\n\nReplace its usage with byte string literals, except in `bytes!()` tests.\nAlso add a new snapshot, to be able to use the new b\"foo\" syntax.\n\nThe src/etc/2014-06-rewrite-bytes-macros.py script automatically\nrewrites `bytes!()` invocations into byte string literals.\nPass it filenames as arguments to generate a diff that you can inspect,\nor `--apply` followed by filenames to apply the changes in place.\nDiffs can be piped into `tip` or `pygmentize -l diff` for coloring.", "tree": {"sha": "a848b9df4646e3311158381252a211a4b8ee2771", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a848b9df4646e3311158381252a211a4b8ee2771"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/108b8b6dc707775bd54aeea7820e0d473f556718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/108b8b6dc707775bd54aeea7820e0d473f556718", "html_url": "https://github.com/rust-lang/rust/commit/108b8b6dc707775bd54aeea7820e0d473f556718", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/108b8b6dc707775bd54aeea7820e0d473f556718/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abf7e933df0c732f14b5b8906161e74e72cd26ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/abf7e933df0c732f14b5b8906161e74e72cd26ca", "html_url": "https://github.com/rust-lang/rust/commit/abf7e933df0c732f14b5b8906161e74e72cd26ca"}], "stats": {"total": 853, "additions": 498, "deletions": 355}, "files": [{"sha": "ce3c2d7de8095aab75c5ac3a78177508379a53b7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -1269,7 +1269,7 @@ fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> Path {\n \n fn aux_output_dir_name(config: &Config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    match f.filename().map(|s| Vec::from_slice(s).append(bytes!(\".libaux\"))) {\n+    match f.filename().map(|s| Vec::from_slice(s).append(b\".libaux\")) {\n         Some(v) => f.set_filename(v),\n         None => ()\n     }\n@@ -1490,7 +1490,7 @@ fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n         (*p).clone()\n     } else {\n         let stem = p.filestem().unwrap();\n-        p.with_filename(Vec::from_slice(stem).append(bytes!(\"-\")).append(suffix.as_bytes()))\n+        p.with_filename(Vec::from_slice(stem).append(b\"-\").append(suffix.as_bytes()))\n     }\n }\n "}, {"sha": "84fd140a23af4b44fcc22be6fe0ec3aabb78c673", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -76,7 +76,7 @@ character.\n ~~~\n use std::str;\n \n-let x = bytes!(72u8,\"ello \",0xF0,0x90,0x80,\"World!\");\n+let x = b\"Hello \\xF0\\x90\\x80World!\";\n let y = str::from_utf8_lossy(x);\n ~~~\n "}, {"sha": "7e5e5b2e67a43be2c92e2f6d9c78d02b38d3db32", "filename": "src/doc/rust.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -378,6 +378,19 @@ the characters `U+0022` (double-quote) (except when followed by at least as\n many `U+0023` (`#`) characters as were used to start the raw string literal) or\n `U+005C` (`\\`) do not have any special meaning.\n \n+Examples for byte string literals:\n+\n+~~~~\n+b\"foo\"; br\"foo\";                     // foo\n+b\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n+\n+b\"foo #\\\"# bar\";\n+br##\"foo #\"# bar\"##;                 // foo #\"# bar\n+\n+b\"\\x52\"; b\"R\"; br\"R\";                // R\n+b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n+~~~~\n+\n #### Number literals\n \n ~~~~ {.ebnf .gram}"}, {"sha": "ceda4bf6fe253cf69f8d2db4eb2bf390fef2730d", "filename": "src/etc/2014-06-rewrite-bytes-macros.py", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fetc%2F2014-06-rewrite-bytes-macros.py", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fetc%2F2014-06-rewrite-bytes-macros.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2F2014-06-rewrite-bytes-macros.py?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -0,0 +1,138 @@\n+#!/bin/env python\n+#\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+import subprocess\n+import re\n+\n+\n+def main():\n+    if len(sys.argv) <= 1:\n+        print('Usage: %s [ --apply ] filename1.rs filename2.rs ...'\n+              % sys.argv[0])\n+    elif sys.argv[1] == '--apply':\n+        for filename in sys.argv[2:]:\n+            patch(filename)\n+    else:\n+        for filename in sys.argv[1:]:\n+            diff(filename)\n+\n+\n+def patch(filename):\n+    source = read(filename)\n+    rewritten = rewrite_bytes_macros(source)\n+    if rewritten is not None and rewritten != source:\n+        write(filename, rewritten)\n+\n+\n+def diff(filename):\n+    rewritten = rewrite_bytes_macros(read(filename))\n+    if rewritten is not None:\n+        p = subprocess.Popen(['diff', '-u', filename, '-'],\n+                             stdin=subprocess.PIPE)\n+        p.stdin.write(rewritten)\n+        p.stdin.close()\n+        p.wait()\n+\n+\n+def read(filename):\n+    with open(filename, 'rb') as f:\n+        return f.read()\n+\n+\n+def write(filename, content):\n+    with open(filename, 'wb') as f:\n+        f.write(content)\n+\n+\n+def rewrite_bytes_macros(source):\n+    rewritten, num_occurrences = BYTES_MACRO_RE.subn(rewrite_one_macro, source)\n+    if num_occurrences > 0:\n+        return rewritten\n+\n+\n+BYTES_MACRO_RE = re.compile(br'bytes!\\(  (?P<args>  [^)]*  )  \\)', re.VERBOSE)\n+\n+\n+def rewrite_one_macro(match):\n+    try:\n+        bytes = parse_bytes(split_args(match.group('args')))\n+        return b'b\"' + b''.join(map(escape, bytes)) + b'\"'\n+    except SkipThisRewrite:\n+        print('Skipped: %s' % match.group(0).decode('utf8', 'replace'))\n+        return match.group(0)\n+\n+\n+class SkipThisRewrite(Exception):\n+    pass\n+\n+\n+def split_args(args):\n+    previous = b''\n+    for arg in args.split(b','):\n+        if previous:\n+            arg = previous + b',' + arg\n+        if arg.count(b'\"') % 2 == 0:\n+            yield arg\n+            previous = b''\n+        else:\n+            previous = arg\n+    if previous:\n+        yield previous\n+\n+\n+def parse_bytes(args):\n+    for arg in args:\n+        arg = arg.strip()\n+        if (arg.startswith(b'\"') and arg.endswith(b'\"')) or (\n+                arg.startswith(b\"'\") and arg.endswith(b\"'\")):\n+            # Escaped newline means something different in Rust and Python.\n+            if b'\\\\\\n' in arg:\n+                raise SkipThisRewrite\n+            for byte in eval(b'u' + arg).encode('utf8'):\n+                yield ord(byte)\n+        else:\n+            if arg.endswith(b'u8'):\n+                arg = arg[:-2]\n+            # Assume that all Rust integer literals\n+            # are valid Python integer literals\n+            value = int(eval(arg))\n+            assert value <= 0xFF\n+            yield value\n+\n+\n+def escape(byte):\n+    c = chr(byte)\n+    escaped = {\n+        b'\\0': br'\\0',\n+        b'\\t': br'\\t',\n+        b'\\n': br'\\n',\n+        b'\\r': br'\\r',\n+        b'\\'': b'\\\\\\'',\n+        b'\\\\': br'\\\\',\n+    }.get(c)\n+    if escaped is not None:\n+        return escaped\n+    elif b' ' <= c <= b'~':\n+        return chr(byte)\n+    else:\n+        return ('\\\\x%02X' % byte).encode('ascii')\n+\n+\n+if str is not bytes:\n+    # Python 3.x\n+    ord = lambda x: x\n+    chr = lambda x: bytes([x])\n+\n+\n+if __name__ == '__main__':\n+    main()"}, {"sha": "f9826fcd2287ff8e37d39bc2a86a7c93b043a9ff", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -1957,30 +1957,30 @@ mod tests {\n \n     #[test]\n     fn test_starts_with() {\n-        assert!(bytes!(\"foobar\").starts_with(bytes!(\"foo\")));\n-        assert!(!bytes!(\"foobar\").starts_with(bytes!(\"oob\")));\n-        assert!(!bytes!(\"foobar\").starts_with(bytes!(\"bar\")));\n-        assert!(!bytes!(\"foo\").starts_with(bytes!(\"foobar\")));\n-        assert!(!bytes!(\"bar\").starts_with(bytes!(\"foobar\")));\n-        assert!(bytes!(\"foobar\").starts_with(bytes!(\"foobar\")));\n+        assert!(b\"foobar\".starts_with(b\"foo\"));\n+        assert!(!b\"foobar\".starts_with(b\"oob\"));\n+        assert!(!b\"foobar\".starts_with(b\"bar\"));\n+        assert!(!b\"foo\".starts_with(b\"foobar\"));\n+        assert!(!b\"bar\".starts_with(b\"foobar\"));\n+        assert!(b\"foobar\".starts_with(b\"foobar\"));\n         let empty: &[u8] = [];\n         assert!(empty.starts_with(empty));\n-        assert!(!empty.starts_with(bytes!(\"foo\")));\n-        assert!(bytes!(\"foobar\").starts_with(empty));\n+        assert!(!empty.starts_with(b\"foo\"));\n+        assert!(b\"foobar\".starts_with(empty));\n     }\n \n     #[test]\n     fn test_ends_with() {\n-        assert!(bytes!(\"foobar\").ends_with(bytes!(\"bar\")));\n-        assert!(!bytes!(\"foobar\").ends_with(bytes!(\"oba\")));\n-        assert!(!bytes!(\"foobar\").ends_with(bytes!(\"foo\")));\n-        assert!(!bytes!(\"foo\").ends_with(bytes!(\"foobar\")));\n-        assert!(!bytes!(\"bar\").ends_with(bytes!(\"foobar\")));\n-        assert!(bytes!(\"foobar\").ends_with(bytes!(\"foobar\")));\n+        assert!(b\"foobar\".ends_with(b\"bar\"));\n+        assert!(!b\"foobar\".ends_with(b\"oba\"));\n+        assert!(!b\"foobar\".ends_with(b\"foo\"));\n+        assert!(!b\"foo\".ends_with(b\"foobar\"));\n+        assert!(!b\"bar\".ends_with(b\"foobar\"));\n+        assert!(b\"foobar\".ends_with(b\"foobar\"));\n         let empty: &[u8] = [];\n         assert!(empty.ends_with(empty));\n-        assert!(!empty.ends_with(bytes!(\"foo\")));\n-        assert!(bytes!(\"foobar\").ends_with(empty));\n+        assert!(!empty.ends_with(b\"foo\"));\n+        assert!(b\"foobar\".ends_with(empty));\n     }\n \n     #[test]"}, {"sha": "642e7cfc9a36f44be39d5e27ca1177583f6d1df1", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -382,7 +382,7 @@ static TAG_CONT_U8: u8 = 128u8;\n /// # Example\n ///\n /// ```rust\n-/// let input = bytes!(\"Hello \", 0xF0, 0x90, 0x80, \"World\");\n+/// let input = b\"Hello \\xF0\\x90\\x80World\";\n /// let output = std::str::from_utf8_lossy(input);\n /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n /// ```\n@@ -391,7 +391,7 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n         return Slice(unsafe { mem::transmute(v) })\n     }\n \n-    static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n+    static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n     let mut i = 0;\n     let total = v.len();\n     fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n@@ -994,7 +994,7 @@ mod tests {\n     fn test_into_bytes() {\n         let data = \"asdf\".to_string();\n         let buf = data.into_bytes();\n-        assert_eq!(bytes!(\"asdf\"), buf.as_slice());\n+        assert_eq!(b\"asdf\", buf.as_slice());\n     }\n \n     #[test]\n@@ -2050,58 +2050,58 @@ mod tests {\n \n     #[test]\n     fn test_str_from_utf8() {\n-        let xs = bytes!(\"hello\");\n+        let xs = b\"hello\";\n         assert_eq!(from_utf8(xs), Some(\"hello\"));\n \n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n         assert_eq!(from_utf8(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n-        let xs = bytes!(\"hello\", 0xff);\n+        let xs = b\"hello\\xFF\";\n         assert_eq!(from_utf8(xs), None);\n     }\n \n     #[test]\n     fn test_str_from_utf8_owned() {\n-        let xs = Vec::from_slice(bytes!(\"hello\"));\n+        let xs = Vec::from_slice(b\"hello\");\n         assert_eq!(from_utf8_owned(xs), Ok(\"hello\".to_string()));\n \n-        let xs = Vec::from_slice(bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        let xs = Vec::from_slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes());\n         assert_eq!(from_utf8_owned(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_string()));\n \n-        let xs = Vec::from_slice(bytes!(\"hello\", 0xff));\n+        let xs = Vec::from_slice(b\"hello\\xFF\");\n         assert_eq!(from_utf8_owned(xs),\n-                   Err(Vec::from_slice(bytes!(\"hello\", 0xff))));\n+                   Err(Vec::from_slice(b\"hello\\xFF\")));\n     }\n \n     #[test]\n     fn test_str_from_utf8_lossy() {\n-        let xs = bytes!(\"hello\");\n+        let xs = b\"hello\";\n         assert_eq!(from_utf8_lossy(xs), Slice(\"hello\"));\n \n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n         assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n-        let xs = bytes!(\"Hello\", 0xC2, \" There\", 0xFF, \" Goodbye\");\n+        let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD There\\uFFFD Goodbye\".to_string()));\n \n-        let xs = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n+        let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\".to_string()));\n \n-        let xs = bytes!(0xF5, \"foo\", 0xF5, 0x80, \"bar\");\n+        let xs = b\"\\xF5foo\\xF5\\x80bar\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\".to_string()));\n \n-        let xs = bytes!(0xF1, \"foo\", 0xF1, 0x80, \"bar\", 0xF1, 0x80, 0x80, \"baz\");\n+        let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\".to_string()));\n \n-        let xs = bytes!(0xF4, \"foo\", 0xF4, 0x80, \"bar\", 0xF4, 0xBF, \"baz\");\n+        let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\".to_string()));\n \n-        let xs = bytes!(0xF0, 0x80, 0x80, 0x80, \"foo\", 0xF0, 0x90, 0x80, 0x80, \"bar\");\n+        let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n                                                foo\\U00010000bar\".to_string()));\n \n         // surrogates\n-        let xs = bytes!(0xED, 0xA0, 0x80, \"foo\", 0xED, 0xBF, 0xBF, \"bar\");\n+        let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n                                                \\uFFFD\\uFFFD\\uFFFDbar\".to_string()));\n     }\n@@ -2298,8 +2298,8 @@ mod bench {\n     #[bench]\n     fn is_utf8_100_ascii(b: &mut Bencher) {\n \n-        let s = bytes!(\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                        Lorem ipsum dolor sit amet, consectetur. \");\n+        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                  Lorem ipsum dolor sit amet, consectetur. \";\n \n         assert_eq!(100, s.len());\n         b.iter(|| {\n@@ -2309,7 +2309,7 @@ mod bench {\n \n     #[bench]\n     fn is_utf8_100_multibyte(b: &mut Bencher) {\n-        let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n+        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n         assert_eq!(100, s.len());\n         b.iter(|| {\n             is_utf8(s)\n@@ -2318,8 +2318,8 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n-        let s = bytes!(\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                        Lorem ipsum dolor sit amet, consectetur. \");\n+        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                  Lorem ipsum dolor sit amet, consectetur. \";\n \n         assert_eq!(100, s.len());\n         b.iter(|| {\n@@ -2329,7 +2329,7 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n-        let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n+        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n         assert_eq!(100, s.len());\n         b.iter(|| {\n             let _ = from_utf8_lossy(s);\n@@ -2338,7 +2338,7 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_invalid(b: &mut Bencher) {\n-        let s = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n+        let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n         b.iter(|| {\n             let _ = from_utf8_lossy(s);\n         });"}, {"sha": "4744d92436f2b75829dde916f5e8b7a52c6ce20d", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -75,13 +75,13 @@ macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n     fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         let s = self.to_str();\n         writer.write(s.as_bytes()).and_then(|()| {\n-            writer.write(bytes!($suffix))\n+            writer.write($suffix)\n         })\n     }\n }))\n \n-num_repr!(f32, \"f32\")\n-num_repr!(f64, \"f64\")\n+num_repr!(f32, b\"f32\")\n+num_repr!(f64, b\"f64\")\n \n // New implementation using reflect::MovePtr\n "}, {"sha": "edf2becc777608584821035107beb20f7f764454", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -360,7 +360,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n         }).map(|path| root.join(path).to_c_str()).collect()\n     }\n \n@@ -529,7 +529,7 @@ mod tests {\n         let mut reader = FileDesc::new(reader, true);\n         let mut writer = FileDesc::new(writer, true);\n \n-        writer.inner_write(bytes!(\"test\")).ok().unwrap();\n+        writer.inner_write(b\"test\").ok().unwrap();\n         let mut buf = [0u8, ..4];\n         match reader.inner_read(buf) {\n             Ok(4) => {\n@@ -552,7 +552,7 @@ mod tests {\n             assert!(!f.is_null());\n             let mut file = CFile::new(f);\n \n-            file.write(bytes!(\"test\")).ok().unwrap();\n+            file.write(b\"test\").ok().unwrap();\n             let mut buf = [0u8, ..4];\n             let _ = file.seek(0, SeekSet).ok().unwrap();\n             match file.read(buf) {"}, {"sha": "cd9abc70a4ee8cd09690be4ff6a45d276021e39a", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -351,7 +351,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n         }).map(|path| root.join(path).to_c_str()).collect()\n     }\n "}, {"sha": "048e44cd55d78098ee98da8dfebaf3ee1ab05fcd", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -292,9 +292,9 @@ pub struct AsciiGenerator<'a, R> {\n impl<'a, R: Rng> Iterator<char> for AsciiGenerator<'a, R> {\n     fn next(&mut self) -> Option<char> {\n         static GEN_ASCII_STR_CHARSET: &'static [u8] =\n-            bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-                    abcdefghijklmnopqrstuvwxyz\\\n-                    0123456789\");\n+            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+              abcdefghijklmnopqrstuvwxyz\\\n+              0123456789\";\n         Some(*self.rng.choose(GEN_ASCII_STR_CHARSET).unwrap() as char)\n     }\n }"}, {"sha": "c15148f75df2242b9c5915ac113f1ac5d14ec811", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -214,7 +214,7 @@ pub fn rust_path() -> Vec<Path> {\n         env_rust_path.push(cwd.clone());\n     }\n     loop {\n-        if { let f = cwd.filename(); f.is_none() || f.unwrap() == bytes!(\"..\") } {\n+        if { let f = cwd.filename(); f.is_none() || f.unwrap() == b\"..\" } {\n             break\n         }\n         cwd.set_filename(\".rust\");"}, {"sha": "783fdfa4aaec911145cb432fbb8c4fae5f278f74", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -1411,7 +1411,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                 match abs_path.path_relative_from(work_dir) {\n                     Some(ref p) if p.is_relative() => {\n                             // prepend \"./\" if necessary\n-                            let dotdot = bytes!(\"..\");\n+                            let dotdot = b\"..\";\n                             let prefix = &[dotdot[0], ::std::path::SEP_BYTE];\n                             let mut path_bytes = Vec::from_slice(p.as_vec());\n "}, {"sha": "76e604ecfa287569dc0adfc75d23a3860c6695ae", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -602,7 +602,7 @@ fn mkdir(path: &Path) -> io::IoResult<()> {\n // FIXME (#9639): The closure should deal with &[u8] instead of &str\n fn clean_srcpath(src: &[u8], f: |&str|) {\n     let p = Path::new(src);\n-    if p.as_vec() != bytes!(\".\") {\n+    if p.as_vec() != b\".\" {\n         for c in p.str_components().map(|x|x.unwrap()) {\n             if \"..\" == c {\n                 f(\"up\");\n@@ -714,7 +714,7 @@ impl<'a> SourceCollector<'a> {\n         });\n \n         cur.push(Vec::from_slice(p.filename().expect(\"source has no filename\"))\n-                 .append(bytes!(\".html\")));\n+                 .append(b\".html\"));\n         let mut w = BufferedWriter::new(try!(File::create(&cur)));\n \n         let title = format!(\"{} -- source\", cur.filename_display());"}, {"sha": "09ae2b31f6368d2c16d7bdc9d82cb148d98daf4c", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -123,8 +123,8 @@ mod imp {\n             let saved_value = take();\n \n             let expected = vec![\n-                Vec::from_slice(bytes!(\"happy\")),\n-                Vec::from_slice(bytes!(\"today?\")),\n+                Vec::from_slice(b\"happy\"),\n+                Vec::from_slice(b\"today?\"),\n             ];\n \n             put(expected.clone());"}, {"sha": "4a7ac97beed8d6f1060add48110e87b6a37ac58d", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -463,7 +463,7 @@ mod tests {\n     #[test]\n     fn test_str_multistring_parsing() {\n         unsafe {\n-            let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n+            let input = b\"zero\\0one\\0\\0\";\n             let ptr = input.as_ptr();\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n@@ -505,7 +505,7 @@ mod tests {\n             }\n         });\n \n-        let _ = bytes!(\"hello\").to_c_str().with_ref(|buf| {\n+        let _ = b\"hello\".to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n                 assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n@@ -516,7 +516,7 @@ mod tests {\n             }\n         });\n \n-        let _ = bytes!(\"foo\", 0xff).to_c_str().with_ref(|buf| {\n+        let _ = b\"foo\\xFF\".to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*buf.offset(0), 'f' as libc::c_char);\n                 assert_eq!(*buf.offset(1), 'o' as libc::c_char);\n@@ -595,22 +595,22 @@ mod tests {\n     #[test]\n     fn test_as_bytes() {\n         let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(\"hello\", 0));\n+        assert_eq!(c_str.as_bytes(), b\"hello\\0\");\n         let c_str = \"\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(0));\n-        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(\"foo\", 0xff, 0));\n+        assert_eq!(c_str.as_bytes(), b\"\\0\");\n+        let c_str = b\"foo\\xFF\".to_c_str();\n+        assert_eq!(c_str.as_bytes(), b\"foo\\xFF\\0\");\n     }\n \n     #[test]\n     fn test_as_bytes_no_nul() {\n         let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes_no_nul(), bytes!(\"hello\"));\n+        assert_eq!(c_str.as_bytes_no_nul(), b\"hello\");\n         let c_str = \"\".to_c_str();\n         let exp: &[u8] = [];\n         assert_eq!(c_str.as_bytes_no_nul(), exp);\n-        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n-        assert_eq!(c_str.as_bytes_no_nul(), bytes!(\"foo\", 0xff));\n+        let c_str = b\"foo\\xFF\".to_c_str();\n+        assert_eq!(c_str.as_bytes_no_nul(), b\"foo\\xFF\");\n     }\n \n     #[test]\n@@ -633,7 +633,7 @@ mod tests {\n         assert_eq!(c_str.as_str(), Some(\"hello\"));\n         let c_str = \"\".to_c_str();\n         assert_eq!(c_str.as_str(), Some(\"\"));\n-        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n+        let c_str = b\"foo\\xFF\".to_c_str();\n         assert_eq!(c_str.as_str(), None);\n     }\n "}, {"sha": "5c4da38989f11316b8a1ad2820b500528773b78b", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -42,13 +42,13 @@ pub static URL_SAFE: Config =\n pub static MIME: Config =\n     Config {char_set: Standard, pad: true, line_length: Some(76)};\n \n-static STANDARD_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n-                                             \"abcdefghijklmnopqrstuvwxyz\",\n-                                             \"0123456789+/\");\n+static STANDARD_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                                        abcdefghijklmnopqrstuvwxyz\\\n+                                        0123456789+/\";\n \n-static URLSAFE_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n-                                            \"abcdefghijklmnopqrstuvwxyz\",\n-                                            \"0123456789-_\");\n+static URLSAFE_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                                       abcdefghijklmnopqrstuvwxyz\\\n+                                       0123456789-_\";\n \n /// A trait for converting a value to base64 encoding.\n pub trait ToBase64 {\n@@ -193,7 +193,7 @@ impl<'a> FromBase64 for &'a str {\n      * use serialize::base64::{ToBase64, FromBase64, STANDARD};\n      *\n      * fn main () {\n-     *     let hello_str = bytes!(\"Hello, World\").to_base64(STANDARD);\n+     *     let hello_str = b\"Hello, World\".to_base64(STANDARD);\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.as_slice().from_base64();\n      *     if res.is_ok() {"}, {"sha": "44d0606185345be24ff6eea88a2fd849ec48c85e", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -19,7 +19,7 @@ pub trait ToHex {\n     fn to_hex(&self) -> String;\n }\n \n-static CHARS: &'static[u8] = bytes!(\"0123456789abcdef\");\n+static CHARS: &'static[u8] = b\"0123456789abcdef\";\n \n impl<'a> ToHex for &'a [u8] {\n     /**"}, {"sha": "4f355502eb88d3a9d5b742f2e91942722bbc5cdc", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -535,7 +535,7 @@ mod test {\n \n     #[test]\n     fn test_read_line() {\n-        let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n+        let in_buf = MemReader::new(Vec::from_slice(b\"a\\nb\\nc\"));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         assert_eq!(reader.read_line(), Ok(\"a\\n\".to_string()));\n         assert_eq!(reader.read_line(), Ok(\"b\\n\".to_string()));\n@@ -545,7 +545,7 @@ mod test {\n \n     #[test]\n     fn test_lines() {\n-        let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n+        let in_buf = MemReader::new(Vec::from_slice(b\"a\\nb\\nc\"));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n         assert_eq!(it.next(), Some(Ok(\"a\\n\".to_string())));"}, {"sha": "a801dd0e7cb35cd39cf7966862ad3185859c1960", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -35,7 +35,7 @@ let path = Path::new(\"foo.txt\");\n \n // create the file, whether it exists or not\n let mut file = File::create(&path);\n-file.write(bytes!(\"foobar\"));\n+file.write(b\"foobar\");\n # drop(file);\n \n // open the file in read-only mode\n@@ -186,7 +186,7 @@ impl File {\n     /// use std::io::File;\n     ///\n     /// let mut f = File::create(&Path::new(\"foo.txt\"));\n-    /// f.write(bytes!(\"This is a sample file\"));\n+    /// f.write(b\"This is a sample file\");\n     /// # drop(f);\n     /// # ::std::io::fs::unlink(&Path::new(\"foo.txt\"));\n     /// ```\n@@ -1141,7 +1141,7 @@ mod test {\n     iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        check!(File::create(file).write(bytes!(\"foo\")));\n+        check!(File::create(file).write(b\"foo\"));\n         assert!(file.exists());\n         check!(unlink(file));\n         assert!(!file.exists());\n@@ -1253,7 +1253,7 @@ mod test {\n         let canary = d2.join(\"do_not_delete\");\n         check!(mkdir_recursive(&dtt, io::UserRWX));\n         check!(mkdir_recursive(&d2, io::UserRWX));\n-        check!(File::create(&canary).write(bytes!(\"foo\")));\n+        check!(File::create(&canary).write(b\"foo\"));\n         check!(symlink(&d2, &dt.join(\"d2\")));\n         check!(rmdir_recursive(&d1));\n \n@@ -1314,10 +1314,10 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        check!(File::create(&input).write(bytes!(\"hello\")));\n+        check!(File::create(&input).write(b\"hello\"));\n         check!(copy(&input, &out));\n         let contents = check!(File::open(&out).read_to_end());\n-        assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n+        assert_eq!(contents.as_slice(), b\"hello\");\n \n         assert_eq!(check!(input.stat()).perm, check!(out.stat()).perm);\n     })\n@@ -1342,7 +1342,7 @@ mod test {\n         check!(copy(&input, &output));\n \n         assert_eq!(check!(File::open(&output).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"foo\"))));\n+                   (Vec::from_slice(b\"foo\")));\n     })\n \n     iotest!(fn copy_file_src_dir() {\n@@ -1383,7 +1383,7 @@ mod test {\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"foobar\"))));\n+                   (Vec::from_slice(b\"foobar\")));\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n@@ -1418,7 +1418,7 @@ mod test {\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(stat(&out)).size, check!(input.stat()).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"foobar\"))));\n+                   (Vec::from_slice(b\"foobar\")));\n \n         // can't link to yourself\n         match link(&input, &input) {\n@@ -1456,7 +1456,7 @@ mod test {\n         let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n         check!(file.fsync());\n         check!(file.datasync());\n-        check!(file.write(bytes!(\"foo\")));\n+        check!(file.write(b\"foo\"));\n         check!(file.fsync());\n         check!(file.datasync());\n         drop(file);\n@@ -1467,29 +1467,29 @@ mod test {\n         let path = tmpdir.join(\"in.txt\");\n \n         let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n-        check!(file.write(bytes!(\"foo\")));\n+        check!(file.write(b\"foo\"));\n         check!(file.fsync());\n \n         // Do some simple things with truncation\n         assert_eq!(check!(file.stat()).size, 3);\n         check!(file.truncate(10));\n         assert_eq!(check!(file.stat()).size, 10);\n-        check!(file.write(bytes!(\"bar\")));\n+        check!(file.write(b\"bar\"));\n         check!(file.fsync());\n         assert_eq!(check!(file.stat()).size, 10);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"foobar\", 0, 0, 0, 0))));\n+                   (Vec::from_slice(b\"foobar\\0\\0\\0\\0\")));\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n         // past the end of the file).\n         check!(file.truncate(2));\n         assert_eq!(check!(file.stat()).size, 2);\n-        check!(file.write(bytes!(\"wut\")));\n+        check!(file.write(b\"wut\"));\n         check!(file.fsync());\n         assert_eq!(check!(file.stat()).size, 9);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"fo\", 0, 0, 0, 0, \"wut\"))));\n+                   (Vec::from_slice(b\"fo\\0\\0\\0\\0wut\")));\n         drop(file);\n     })\n "}, {"sha": "5eca5361835e36e7295f5d5f66f6ffde1df300c8", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -474,7 +474,7 @@ mod test {\n \n     #[test]\n     fn test_read_char() {\n-        let b = bytes!(\"Vi\u1ec7t\");\n+        let b = b\"Vi\\xE1\\xBB\\x87t\";\n         let mut r = BufReader::new(b);\n         assert_eq!(r.read_char(), Ok('V'));\n         assert_eq!(r.read_char(), Ok('i'));\n@@ -485,7 +485,7 @@ mod test {\n \n     #[test]\n     fn test_read_bad_char() {\n-        let b = bytes!(0x80);\n+        let b = b\"\\x80\";\n         let mut r = BufReader::new(b);\n         assert!(r.read_char().is_err());\n     }"}, {"sha": "d9755cdce1a4fbf1099fac36b541f4fef3f9ca57", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -50,7 +50,7 @@ Some examples of obvious things you might want to do\n     use std::io::File;\n \n     let mut file = File::create(&Path::new(\"message.txt\"));\n-    file.write(bytes!(\"hello, file!\\n\"));\n+    file.write(b\"hello, file!\\n\");\n     # drop(file);\n     # ::std::io::fs::unlink(&Path::new(\"message.txt\"));\n     ```\n@@ -90,7 +90,7 @@ Some examples of obvious things you might want to do\n     # // just stop it running (#11576)\n     # if false {\n     let mut socket = TcpStream::connect(\"127.0.0.1\", 8080).unwrap();\n-    socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));\n+    socket.write(b\"GET / HTTP/1.0\\n\\n\");\n     let response = socket.read_to_end();\n     # }\n     ```\n@@ -151,7 +151,7 @@ while still providing feedback about errors. The basic strategy:\n   to be 'unwrapped' before use.\n \n These features combine in the API to allow for expressions like\n-`File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\"))`\n+`File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\")`\n without having to worry about whether \"diary.txt\" exists or whether\n the write succeeds. As written, if either `new` or `write_line`\n encounters an error then the result of the entire expression will\n@@ -163,7 +163,7 @@ If you wanted to handle the error though you might write:\n # #![allow(unused_must_use)]\n use std::io::File;\n \n-match File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\")) {\n+match File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\") {\n     Ok(()) => (), // succeeded\n     Err(e) => println!(\"failed to write to my diary: {}\", e),\n }\n@@ -1839,55 +1839,55 @@ mod tests {\n \n     #[test]\n     fn test_read_at_least() {\n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([GoodBehavior(uint::MAX)]));\n         let mut buf = [0u8, ..5];\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n         assert!(r.read_at_least(0, buf).is_ok());\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(50), GoodBehavior(uint::MAX)]));\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(1), GoodBehavior(1),\n                                                     BadBehavior(50), GoodBehavior(uint::MAX)]));\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(uint::MAX)]));\n         assert_eq!(r.read_at_least(1, buf).unwrap_err().kind, NoProgress);\n \n-        let mut r = MemReader::new(Vec::from_slice(bytes!(\"hello, world!\")));\n+        let mut r = MemReader::new(Vec::from_slice(b\"hello, world!\"));\n         assert_eq!(r.read_at_least(5, buf).unwrap(), 5);\n         assert_eq!(r.read_at_least(6, buf).unwrap_err().kind, InvalidInput);\n     }\n \n     #[test]\n     fn test_push_at_least() {\n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([GoodBehavior(uint::MAX)]));\n         let mut buf = Vec::new();\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(0, 5, &mut buf).is_ok());\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(50), GoodBehavior(uint::MAX)]));\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(1), GoodBehavior(1),\n                                                     BadBehavior(50), GoodBehavior(uint::MAX)]));\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(uint::MAX)]));\n         assert_eq!(r.push_at_least(1, 5, &mut buf).unwrap_err().kind, NoProgress);\n \n-        let mut r = MemReader::new(Vec::from_slice(bytes!(\"hello, world!\")));\n+        let mut r = MemReader::new(Vec::from_slice(b\"hello, world!\"));\n         assert_eq!(r.push_at_least(5, 1, &mut buf).unwrap_err().kind, InvalidInput);\n     }\n }"}, {"sha": "a968f41a91563ce9c7d7a66bf7a551fa9db94f13", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -52,7 +52,7 @@ impl PipeStream {\n     ///\n     /// fn main() {\n     ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n-    ///     pipe.write(bytes!(\"Hello, stderr!\"));\n+    ///     pipe.write(b\"Hello, stderr!\");\n     /// }\n     /// ```\n     pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {"}, {"sha": "e5a64f785ce9640643911ef9c55fb8a76f44b77c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -22,7 +22,7 @@ about the stream or terminal to which it is attached.\n use std::io;\n \n let mut out = io::stdout();\n-out.write(bytes!(\"Hello, world!\"));\n+out.write(b\"Hello, world!\");\n ```\n \n */"}, {"sha": "dad162d82ad47b798c53fa0b91e99fcd66bdc850", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -463,7 +463,7 @@ pub mod builtin {\n     /// # Example\n     ///\n     /// ```\n-    /// let rust = bytes!(\"r\", 'u', \"st\", 255);\n+    /// let rust = b\"rust\\xFF\";\n     /// assert_eq!(rust[1], 'u' as u8);\n     /// assert_eq!(rust[4], 255);\n     /// ```"}, {"sha": "e55dc165895164a5d07dd29f7137d1c82d878a37", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -219,7 +219,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 let dot = '.' as u8;\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n-                    Some(1) if name == bytes!(\"..\") => name,\n+                    Some(1) if name == b\"..\" => name,\n                     Some(pos) => name.slice_to(pos)\n                 }\n             })\n@@ -242,7 +242,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 let dot = '.' as u8;\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n-                    Some(1) if name == bytes!(\"..\") => None,\n+                    Some(1) if name == b\"..\" => None,\n                     Some(pos) => Some(name.slice_from(pos+1))\n                 }\n             }"}, {"sha": "d98cfb7d8eece0c35396db2b1a5dd2cb48614a6e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 128, "deletions": 137, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -142,7 +142,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n-            None if bytes!(\"..\") == self.repr.as_slice() => {\n+            None if b\"..\" == self.repr.as_slice() => {\n                 let mut v = Vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n@@ -153,7 +153,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -202,34 +202,34 @@ impl GenericPath for Path {\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if bytes!(\"..\") == self.repr.as_slice() => self.repr.as_slice(),\n+            None if b\"..\" == self.repr.as_slice() => self.repr.as_slice(),\n             None => dot_static,\n             Some(0) => self.repr.slice_to(1),\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => self.repr.as_slice(),\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => self.repr.as_slice(),\n             Some(idx) => self.repr.slice_to(idx)\n         }\n     }\n \n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr.as_slice() ||\n-                bytes!(\"..\") == self.repr.as_slice() => None,\n+            None if b\".\" == self.repr.as_slice() ||\n+                b\"..\" == self.repr.as_slice() => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => None,\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => None,\n             Some(0) if self.repr.slice_from(1).is_empty() => None,\n             Some(idx) => Some(self.repr.slice_from(idx+1))\n         }\n     }\n \n     fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr.as_slice() => false,\n+            None if b\".\" == self.repr.as_slice() => false,\n             None => {\n                 self.repr = vec!['.' as u8];\n                 self.sepidx = None;\n                 true\n             }\n-            Some(0) if bytes!(\"/\") == self.repr.as_slice() => false,\n+            Some(0) if b\"/\" == self.repr.as_slice() => false,\n             Some(idx) => {\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n@@ -261,19 +261,19 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = other.components();\n-            if bytes!(\".\") == self.repr.as_slice() {\n+            if b\".\" == self.repr.as_slice() {\n                 return match itb.next() {\n                     None => true,\n-                    Some(b) => b != bytes!(\"..\")\n+                    Some(b) => b != b\"..\"\n                 };\n             }\n             loop {\n                 match (ita.next(), itb.next()) {\n                     (None, _) => break,\n                     (Some(a), Some(b)) if a == b => { continue },\n-                    (Some(a), _) if a == bytes!(\"..\") => {\n+                    (Some(a), _) if a == b\"..\" => {\n                         // if ita contains only .. components, it's an ancestor\n-                        return ita.all(|x| x == bytes!(\"..\"));\n+                        return ita.all(|x| x == b\"..\");\n                     }\n                     _ => return false\n                 }\n@@ -303,8 +303,8 @@ impl GenericPath for Path {\n                     }\n                     (None, _) => comps.push(dot_dot_static),\n                     (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n-                    (Some(a), Some(b)) if b == bytes!(\".\") => comps.push(a),\n-                    (Some(_), Some(b)) if b == bytes!(\"..\") => return None,\n+                    (Some(a), Some(b)) if b == b\".\" => comps.push(a),\n+                    (Some(_), Some(b)) if b == b\"..\" => return None,\n                     (Some(a), Some(_)) => {\n                         comps.push(dot_dot_static);\n                         for _ in itb {\n@@ -425,16 +425,16 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n     let mut changed = false;\n     for comp in v.split(is_sep_byte) {\n         if comp.is_empty() { changed = true }\n-        else if comp == bytes!(\".\") { changed = true }\n-        else if comp == bytes!(\"..\") {\n+        else if comp == b\".\" { changed = true }\n+        else if comp == b\"..\" {\n             if is_abs && comps.is_empty() { changed = true }\n             else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n             else { comps.pop().unwrap(); changed = true }\n         } else { comps.push(comp) }\n     }\n     if changed {\n         if comps.is_empty() && !is_abs {\n-            if v == bytes!(\".\") {\n+            if v == b\".\" {\n                 return None;\n             }\n             comps.push(dot_static);\n@@ -445,8 +445,8 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n     }\n }\n \n-static dot_static: &'static [u8] = bytes!(\".\");\n-static dot_dot_static: &'static [u8] = bytes!(\"..\");\n+static dot_static: &'static [u8] = b\".\";\n+static dot_dot_static: &'static [u8] = b\"..\";\n \n #[cfg(test)]\n mod tests {\n@@ -470,24 +470,15 @@ mod tests {\n         )\n     )\n \n-    macro_rules! b(\n-        ($($arg:expr),+) => (\n-            {\n-                static the_bytes: &'static [u8] = bytes!($($arg),+);\n-                the_bytes\n-            }\n-        )\n-    )\n-\n     #[test]\n     fn test_paths() {\n         let empty: &[u8] = [];\n-        t!(v: Path::new(empty), b!(\".\"));\n-        t!(v: Path::new(b!(\"/\")), b!(\"/\"));\n-        t!(v: Path::new(b!(\"a/b/c\")), b!(\"a/b/c\"));\n-        t!(v: Path::new(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n-        t!(v: Path::new(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n-        let p = Path::new(b!(\"a/b/c\", 0xff));\n+        t!(v: Path::new(empty), b\".\");\n+        t!(v: Path::new(b\"/\"), b\"/\");\n+        t!(v: Path::new(b\"a/b/c\"), b\"a/b/c\");\n+        t!(v: Path::new(b\"a/b/c\\xFF\"), b\"a/b/c\\xFF\");\n+        t!(v: Path::new(b\"\\xFF/../foo\\x80\"), b\"foo\\x80\");\n+        let p = Path::new(b\"a/b/c\\xFF\");\n         assert!(p.as_str() == None);\n \n         t!(s: Path::new(\"\"), \".\");\n@@ -513,18 +504,18 @@ mod tests {\n         t!(s: Path::new(\"foo/../../..\"), \"../..\");\n         t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n \n-        assert_eq!(Path::new(b!(\"foo/bar\")).into_vec().as_slice(), b!(\"foo/bar\"));\n-        assert_eq!(Path::new(b!(\"/foo/../../bar\")).into_vec().as_slice(),\n-                   b!(\"/bar\"));\n+        assert_eq!(Path::new(b\"foo/bar\").into_vec().as_slice(), b\"foo/bar\");\n+        assert_eq!(Path::new(b\"/foo/../../bar\").into_vec().as_slice(),\n+                   b\"/bar\");\n \n-        let p = Path::new(b!(\"foo/bar\", 0x80));\n+        let p = Path::new(b\"foo/bar\\x80\");\n         assert!(p.as_str() == None);\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert!(Path::new_opt(b!(\"foo/bar\", 0)) == None);\n-        t!(v: Path::new_opt(b!(\"foo/bar\")).unwrap(), b!(\"foo/bar\"));\n+        assert!(Path::new_opt(b\"foo/bar\\0\") == None);\n+        t!(v: Path::new_opt(b\"foo/bar\").unwrap(), b\"foo/bar\");\n         assert!(Path::new_opt(\"foo/bar\\0\") == None);\n         t!(s: Path::new_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n     }\n@@ -533,17 +524,17 @@ mod tests {\n     fn test_null_byte() {\n         use task;\n         let result = task::try(proc() {\n-            Path::new(b!(\"foo/bar\", 0))\n+            Path::new(b\"foo/bar\\0\")\n         });\n         assert!(result.is_err());\n \n         let result = task::try(proc() {\n-            Path::new(\"test\").set_filename(b!(\"f\", 0, \"o\"))\n+            Path::new(\"test\").set_filename(b\"f\\0o\")\n         });\n         assert!(result.is_err());\n \n         let result = task::try(proc() {\n-            Path::new(\"test\").push(b!(\"f\", 0, \"o\"));\n+            Path::new(\"test\").push(b\"f\\0o\");\n         });\n         assert!(result.is_err());\n     }\n@@ -559,11 +550,11 @@ mod tests {\n             )\n         )\n         t!(\"foo\", display, \"foo\");\n-        t!(b!(\"foo\", 0x80), display, \"foo\\uFFFD\");\n-        t!(b!(\"foo\", 0xff, \"bar\"), display, \"foo\\uFFFDbar\");\n-        t!(b!(\"foo\", 0xff, \"/bar\"), filename_display, \"bar\");\n-        t!(b!(\"foo/\", 0xff, \"bar\"), filename_display, \"\\uFFFDbar\");\n-        t!(b!(\"/\"), filename_display, \"\");\n+        t!(b\"foo\\x80\", display, \"foo\\uFFFD\");\n+        t!(b\"foo\\xFFbar\", display, \"foo\\uFFFDbar\");\n+        t!(b\"foo\\xFF/bar\", filename_display, \"bar\");\n+        t!(b\"foo/\\xFFbar\", filename_display, \"\\uFFFDbar\");\n+        t!(b\"/\", filename_display, \"\");\n \n         macro_rules! t(\n             ($path:expr, $exp:expr) => (\n@@ -583,11 +574,11 @@ mod tests {\n         )\n \n         t!(\"foo\", \"foo\");\n-        t!(b!(\"foo\", 0x80), \"foo\\uFFFD\");\n-        t!(b!(\"foo\", 0xff, \"bar\"), \"foo\\uFFFDbar\");\n-        t!(b!(\"foo\", 0xff, \"/bar\"), \"bar\", filename);\n-        t!(b!(\"foo/\", 0xff, \"bar\"), \"\\uFFFDbar\", filename);\n-        t!(b!(\"/\"), \"\", filename);\n+        t!(b\"foo\\x80\", \"foo\\uFFFD\");\n+        t!(b\"foo\\xFFbar\", \"foo\\uFFFDbar\");\n+        t!(b\"foo\\xFF/bar\", \"bar\", filename);\n+        t!(b\"foo/\\xFFbar\", \"\\uFFFDbar\", filename);\n+        t!(b\"/\", \"\", filename);\n     }\n \n     #[test]\n@@ -604,13 +595,13 @@ mod tests {\n             )\n         )\n \n-        t!(b!(\"foo\"), \"foo\", \"foo\");\n-        t!(b!(\"foo/bar\"), \"foo/bar\", \"bar\");\n-        t!(b!(\"/\"), \"/\", \"\");\n-        t!(b!(\"foo\", 0xff), \"foo\\uFFFD\", \"foo\\uFFFD\");\n-        t!(b!(\"foo\", 0xff, \"/bar\"), \"foo\\uFFFD/bar\", \"bar\");\n-        t!(b!(\"foo/\", 0xff, \"bar\"), \"foo/\\uFFFDbar\", \"\\uFFFDbar\");\n-        t!(b!(0xff, \"foo/bar\", 0xff), \"\\uFFFDfoo/bar\\uFFFD\", \"bar\\uFFFD\");\n+        t!(b\"foo\", \"foo\", \"foo\");\n+        t!(b\"foo/bar\", \"foo/bar\", \"bar\");\n+        t!(b\"/\", \"/\", \"\");\n+        t!(b\"foo\\xFF\", \"foo\\uFFFD\", \"foo\\uFFFD\");\n+        t!(b\"foo\\xFF/bar\", \"foo\\uFFFD/bar\", \"bar\");\n+        t!(b\"foo/\\xFFbar\", \"foo/\\uFFFDbar\", \"\\uFFFDbar\");\n+        t!(b\"\\xFFfoo/bar\\xFF\", \"\\uFFFDfoo/bar\\uFFFD\", \"bar\\uFFFD\");\n     }\n \n     #[test]\n@@ -638,9 +629,9 @@ mod tests {\n             );\n         )\n \n-        t!(v: b!(\"a/b/c\"), filename, Some(b!(\"c\")));\n-        t!(v: b!(\"a/b/c\", 0xff), filename, Some(b!(\"c\", 0xff)));\n-        t!(v: b!(\"a/b\", 0xff, \"/c\"), filename, Some(b!(\"c\")));\n+        t!(v: b\"a/b/c\", filename, Some(b\"c\"));\n+        t!(v: b\"a/b/c\\xFF\", filename, Some(b\"c\\xFF\"));\n+        t!(v: b\"a/b\\xFF/c\", filename, Some(b\"c\"));\n         t!(s: \"a/b/c\", filename, Some(\"c\"), opt);\n         t!(s: \"/a/b/c\", filename, Some(\"c\"), opt);\n         t!(s: \"a\", filename, Some(\"a\"), opt);\n@@ -650,9 +641,9 @@ mod tests {\n         t!(s: \"..\", filename, None, opt);\n         t!(s: \"../..\", filename, None, opt);\n \n-        t!(v: b!(\"a/b/c\"), dirname, b!(\"a/b\"));\n-        t!(v: b!(\"a/b/c\", 0xff), dirname, b!(\"a/b\"));\n-        t!(v: b!(\"a/b\", 0xff, \"/c\"), dirname, b!(\"a/b\", 0xff));\n+        t!(v: b\"a/b/c\", dirname, b\"a/b\");\n+        t!(v: b\"a/b/c\\xFF\", dirname, b\"a/b\");\n+        t!(v: b\"a/b\\xFF/c\", dirname, b\"a/b\\xFF\");\n         t!(s: \"a/b/c\", dirname, \"a/b\");\n         t!(s: \"/a/b/c\", dirname, \"/a/b\");\n         t!(s: \"a\", dirname, \".\");\n@@ -662,9 +653,9 @@ mod tests {\n         t!(s: \"..\", dirname, \"..\");\n         t!(s: \"../..\", dirname, \"../..\");\n \n-        t!(v: b!(\"hi/there.txt\"), filestem, Some(b!(\"there\")));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), filestem, Some(b!(\"there\", 0x80)));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), filestem, Some(b!(\"there\")));\n+        t!(v: b\"hi/there.txt\", filestem, Some(b\"there\"));\n+        t!(v: b\"hi/there\\x80.txt\", filestem, Some(b\"there\\x80\"));\n+        t!(v: b\"hi/there.t\\x80xt\", filestem, Some(b\"there\"));\n         t!(s: \"hi/there.txt\", filestem, Some(\"there\"), opt);\n         t!(s: \"hi/there\", filestem, Some(\"there\"), opt);\n         t!(s: \"there.txt\", filestem, Some(\"there\"), opt);\n@@ -678,11 +669,11 @@ mod tests {\n         t!(s: \"..\", filestem, None, opt);\n         t!(s: \"../..\", filestem, None, opt);\n \n-        t!(v: b!(\"hi/there.txt\"), extension, Some(b!(\"txt\")));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), extension, Some(b!(\"txt\")));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), extension, Some(b!(\"t\", 0x80, \"xt\")));\n-        t!(v: b!(\"hi/there\"), extension, None);\n-        t!(v: b!(\"hi/there\", 0x80), extension, None);\n+        t!(v: b\"hi/there.txt\", extension, Some(b\"txt\"));\n+        t!(v: b\"hi/there\\x80.txt\", extension, Some(b\"txt\"));\n+        t!(v: b\"hi/there.t\\x80xt\", extension, Some(b\"t\\x80xt\"));\n+        t!(v: b\"hi/there\", extension, None);\n+        t!(v: b\"hi/there\\x80\", extension, None);\n         t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n         t!(s: \"hi/there\", extension, None, opt);\n         t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n@@ -762,9 +753,9 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n-        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n-        t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n+        t!(v: b\"a/b/c\", [b\"d\", b\"e\"], b\"a/b/c/d/e\");\n+        t!(v: b\"a/b/c\", [b\"d\", b\"/e\", b\"f\"], b\"/e/f\");\n+        t!(v: b\"a/b/c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")], b\"a/b/c/d/e\");\n     }\n \n     #[test]\n@@ -778,25 +769,25 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             );\n-            (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n+            (b: $path:expr, $left:expr, $right:expr) => (\n                 {\n-                    let mut p = Path::new(b!($($path),+));\n+                    let mut p = Path::new($path);\n                     let result = p.pop();\n-                    assert!(p.as_vec() == b!($($left),+));\n+                    assert!(p.as_vec() == $left);\n                     assert!(result == $right);\n                 }\n             )\n         )\n \n-        t!(v: [\"a/b/c\"], [\"a/b\"], true);\n-        t!(v: [\"a\"], [\".\"], true);\n-        t!(v: [\".\"], [\".\"], false);\n-        t!(v: [\"/a\"], [\"/\"], true);\n-        t!(v: [\"/\"], [\"/\"], false);\n-        t!(v: [\"a/b/c\", 0x80], [\"a/b\"], true);\n-        t!(v: [\"a/b\", 0x80, \"/c\"], [\"a/b\", 0x80], true);\n-        t!(v: [0xff], [\".\"], true);\n-        t!(v: [\"/\", 0xff], [\"/\"], true);\n+        t!(b: b\"a/b/c\", b\"a/b\", true);\n+        t!(b: b\"a\", b\".\", true);\n+        t!(b: b\".\", b\".\", false);\n+        t!(b: b\"/a\", b\"/\", true);\n+        t!(b: b\"/\", b\"/\", false);\n+        t!(b: b\"a/b/c\\x80\", b\"a/b\", true);\n+        t!(b: b\"a/b\\x80/c\", b\"a/b\\x80\", true);\n+        t!(b: b\"\\xFF\", b\".\", true);\n+        t!(b: b\"/\\xFF\", b\"/\", true);\n         t!(s: \"a/b/c\", \"a/b\", true);\n         t!(s: \"a\", \".\", true);\n         t!(s: \".\", \".\", false);\n@@ -806,15 +797,15 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert!(Path::new(b!(\"a/b/c\")).root_path() == None);\n-        assert!(Path::new(b!(\"/a/b/c\")).root_path() == Some(Path::new(\"/\")));\n+        assert!(Path::new(b\"a/b/c\").root_path() == None);\n+        assert!(Path::new(b\"/a/b/c\").root_path() == Some(Path::new(\"/\")));\n     }\n \n     #[test]\n     fn test_join() {\n-        t!(v: Path::new(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n-        t!(v: Path::new(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n-        t!(v: Path::new(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n+        t!(v: Path::new(b\"a/b/c\").join(b\"..\"), b\"a/b\");\n+        t!(v: Path::new(b\"/a/b/c\").join(b\"d\"), b\"/a/b/c/d\");\n+        t!(v: Path::new(b\"a/\\x80/c\").join(b\"\\xFF\"), b\"a/\\x80/c/\\xFF\");\n         t!(s: Path::new(\"a/b/c\").join(\"..\"), \"a/b\");\n         t!(s: Path::new(\"/a/b/c\").join(\"d\"), \"/a/b/c/d\");\n         t!(s: Path::new(\"a/b\").join(\"c/d\"), \"a/b/c/d\");\n@@ -867,18 +858,18 @@ mod tests {\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n-        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n+        t!(v: b\"a/b/c\", [b\"d\", b\"e\"], b\"a/b/c/d/e\");\n+        t!(v: b\"a/b/c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")], b\"a/b/c/d/e\");\n     }\n \n     #[test]\n     fn test_with_helpers() {\n         let empty: &[u8] = [];\n \n-        t!(v: Path::new(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n-        t!(v: Path::new(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n-        t!(v: Path::new(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n-              b!(\"/\", 0xff, \"/\", 0xcd));\n+        t!(v: Path::new(b\"a/b/c\").with_filename(b\"d\"), b\"a/b/d\");\n+        t!(v: Path::new(b\"a/b/c\\xFF\").with_filename(b\"\\x80\"), b\"a/b/\\x80\");\n+        t!(v: Path::new(b\"/\\xFF/foo\").with_filename(b\"\\xCD\"),\n+              b\"/\\xFF/\\xCD\");\n         t!(s: Path::new(\"a/b/c\").with_filename(\"d\"), \"a/b/d\");\n         t!(s: Path::new(\".\").with_filename(\"foo\"), \"foo\");\n         t!(s: Path::new(\"/a/b/c\").with_filename(\"d\"), \"/a/b/d\");\n@@ -899,13 +890,13 @@ mod tests {\n         t!(s: Path::new(\"..\").with_filename(\"\"), \"..\");\n         t!(s: Path::new(\"../..\").with_filename(\"\"), \"../..\");\n \n-        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n-              b!(\"hi/there\", 0x80, \".exe\"));\n-        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n-              b!(\"hi/there.\", 0xff));\n-        t!(v: Path::new(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n-              b!(\"hi/there\", 0x80, \".\", 0xff));\n-        t!(v: Path::new(b!(\"hi/there.\", 0xff)).with_extension(empty), b!(\"hi/there\"));\n+        t!(v: Path::new(b\"hi/there\\x80.txt\").with_extension(b\"exe\"),\n+              b\"hi/there\\x80.exe\");\n+        t!(v: Path::new(b\"hi/there.txt\\x80\").with_extension(b\"\\xFF\"),\n+              b\"hi/there.\\xFF\");\n+        t!(v: Path::new(b\"hi/there\\x80\").with_extension(b\"\\xFF\"),\n+              b\"hi/there\\x80.\\xFF\");\n+        t!(v: Path::new(b\"hi/there.\\xFF\").with_extension(empty), b\"hi/there\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\"exe\"), \"hi/there.exe\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\"\"), \"hi/there\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\".\"), \"hi/there..\");\n@@ -947,17 +938,17 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a/b/c\"), set_filename, with_filename, b!(\"d\"));\n-        t!(v: b!(\"/\"), set_filename, with_filename, b!(\"foo\"));\n-        t!(v: b!(0x80), set_filename, with_filename, b!(0xff));\n+        t!(v: b\"a/b/c\", set_filename, with_filename, b\"d\");\n+        t!(v: b\"/\", set_filename, with_filename, b\"foo\");\n+        t!(v: b\"\\x80\", set_filename, with_filename, b\"\\xFF\");\n         t!(s: \"a/b/c\", set_filename, with_filename, \"d\");\n         t!(s: \"/\", set_filename, with_filename, \"foo\");\n         t!(s: \".\", set_filename, with_filename, \"foo\");\n         t!(s: \"a/b\", set_filename, with_filename, \"\");\n         t!(s: \"a\", set_filename, with_filename, \"\");\n \n-        t!(v: b!(\"hi/there.txt\"), set_extension, with_extension, b!(\"exe\"));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), set_extension, with_extension, b!(\"exe\", 0xff));\n+        t!(v: b\"hi/there.txt\", set_extension, with_extension, b\"exe\");\n+        t!(v: b\"hi/there.t\\x80xt\", set_extension, with_extension, b\"exe\\xFF\");\n         t!(s: \"hi/there.txt\", set_extension, with_extension, \"exe\");\n         t!(s: \"hi/there.\", set_extension, with_extension, \"txt\");\n         t!(s: \"hi/there\", set_extension, with_extension, \"txt\");\n@@ -1001,10 +992,10 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::new(b!(\"a/b/c\")), Some(b!(\"c\")), b!(\"a/b\"), Some(b!(\"c\")), None);\n-        t!(v: Path::new(b!(\"a/b/\", 0xff)), Some(b!(0xff)), b!(\"a/b\"), Some(b!(0xff)), None);\n-        t!(v: Path::new(b!(\"hi/there.\", 0xff)), Some(b!(\"there.\", 0xff)), b!(\"hi\"),\n-              Some(b!(\"there\")), Some(b!(0xff)));\n+        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n+        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n+        t!(v: Path::new(b\"hi/there.\\xFF\"), Some(b\"there.\\xFF\"), b\"hi\",\n+              Some(b\"there\"), Some(b\"\\xFF\"));\n         t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n         t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n         t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n@@ -1018,16 +1009,16 @@ mod tests {\n         t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n         t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::new(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n-        t!(s: Path::new(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::new(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n+        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::new(b\"a/b/\\xFF.txt\"), None, Some(\"a/b\"), None, Some(\"txt\"));\n+        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), None);\n     }\n \n     #[test]\n     fn test_dir_path() {\n-        t!(v: Path::new(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n-        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n+        t!(v: Path::new(b\"hi/there\\x80\").dir_path(), b\"hi\");\n+        t!(v: Path::new(b\"hi\\xFF/there\").dir_path(), b\"hi\\xFF\");\n         t!(s: Path::new(\"hi/there\").dir_path(), \"hi\");\n         t!(s: Path::new(\"hi\").dir_path(), \".\");\n         t!(s: Path::new(\"/hi\").dir_path(), \"/\");\n@@ -1125,9 +1116,9 @@ mod tests {\n         t!(s: \"/a/b/c\", \"d/e/f\", false);\n         t!(s: \"a/b/c\", \"a/b\", false);\n         t!(s: \"a/b/c\", \"b\", false);\n-        t!(v: b!(\"a/b/c\"), b!(\"b/c\"), true);\n-        t!(v: b!(\"a/b/\", 0xff), b!(0xff), true);\n-        t!(v: b!(\"a/b/\", 0xff), b!(\"b/\", 0xff), true);\n+        t!(v: b\"a/b/c\", b\"b/c\", true);\n+        t!(v: b\"a/b/\\xFF\", b\"\\xFF\", true);\n+        t!(v: b\"a/b/\\xFF\", b\"b/\\xFF\", true);\n     }\n \n     #[test]\n@@ -1192,11 +1183,11 @@ mod tests {\n                             comps, exps);\n                 }\n             );\n-            (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n+            (b: $arg:expr, [$($exp:expr),*]) => (\n                 {\n-                    let path = Path::new(b!($($arg),+));\n+                    let path = Path::new($arg);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n-                    let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n+                    let exp: &[&[u8]] = [$($exp),*];\n                     assert_eq!(comps.as_slice(), exp);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n@@ -1205,9 +1196,9 @@ mod tests {\n             )\n         )\n \n-        t!(v: [\"a/b/c\"], [[\"a\"], [\"b\"], [\"c\"]]);\n-        t!(v: [\"/\", 0xff, \"/a/\", 0x80], [[0xff], [\"a\"], [0x80]]);\n-        t!(v: [\"../../foo\", 0xcd, \"bar\"], [[\"..\"], [\"..\"], [\"foo\", 0xcd, \"bar\"]]);\n+        t!(b: b\"a/b/c\", [b\"a\", b\"b\", b\"c\"]);\n+        t!(b: b\"/\\xFF/a/\\x80\", [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n+        t!(b: b\"../../foo\\xCDbar\", [b\"..\", b\"..\", b\"foo\\xCDbar\"]);\n         t!(s: \"a/b/c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a/b/d\", [\"a\", \"b\", \"d\"]);\n         t!(s: \"a/b/cd\", [\"a\", \"b\", \"cd\"]);\n@@ -1224,9 +1215,9 @@ mod tests {\n     #[test]\n     fn test_str_components() {\n         macro_rules! t(\n-            (v: [$($arg:expr),+], $exp:expr) => (\n+            (b: $arg:expr, $exp:expr) => (\n                 {\n-                    let path = Path::new(b!($($arg),+));\n+                    let path = Path::new($arg);\n                     let comps = path.str_components().collect::<Vec<Option<&str>>>();\n                     let exp: &[Option<&str>] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n@@ -1237,9 +1228,9 @@ mod tests {\n             )\n         )\n \n-        t!(v: [\"a/b/c\"], [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n-        t!(v: [\"/\", 0xff, \"/a/\", 0x80], [None, Some(\"a\"), None]);\n-        t!(v: [\"../../foo\", 0xcd, \"bar\"], [Some(\"..\"), Some(\"..\"), None]);\n+        t!(b: b\"a/b/c\", [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n+        t!(b: b\"/\\xFF/a/\\x80\", [None, Some(\"a\"), None]);\n+        t!(b: b\"../../foo\\xCDbar\", [Some(\"..\"), Some(\"..\"), None]);\n         // str_components is a wrapper around components, so no need to do\n         // the full set of tests\n     }"}, {"sha": "4d6f8d0888f3e489575ac0fcd9a916d1a2c326fb", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 43, "deletions": 64, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -1123,15 +1123,6 @@ mod tests {\n         )\n     )\n \n-    macro_rules! b(\n-        ($($arg:expr),+) => (\n-            {\n-                static the_bytes: &'static [u8] = bytes!($($arg),+);\n-                the_bytes\n-            }\n-        )\n-    )\n-\n     #[test]\n     fn test_parse_prefix() {\n         macro_rules! t(\n@@ -1196,9 +1187,9 @@ mod tests {\n     #[test]\n     fn test_paths() {\n         let empty: &[u8] = [];\n-        t!(v: Path::new(empty), b!(\".\"));\n-        t!(v: Path::new(b!(\"\\\\\")), b!(\"\\\\\"));\n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n+        t!(v: Path::new(empty), b\".\");\n+        t!(v: Path::new(b\"\\\\\"), b\"\\\\\");\n+        t!(v: Path::new(b\"a\\\\b\\\\c\"), b\"a\\\\b\\\\c\");\n \n         t!(s: Path::new(\"\"), \".\");\n         t!(s: Path::new(\"\\\\\"), \"\\\\\");\n@@ -1230,8 +1221,8 @@ mod tests {\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n \n-        assert_eq!(Path::new(b!(\"foo\\\\bar\")).into_vec().as_slice(), b!(\"foo\\\\bar\"));\n-        assert_eq!(Path::new(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec().as_slice(), b!(\"\\\\bar\"));\n+        assert_eq!(Path::new(b\"foo\\\\bar\").into_vec().as_slice(), b\"foo\\\\bar\");\n+        assert_eq!(Path::new(b\"\\\\foo\\\\..\\\\..\\\\bar\").into_vec().as_slice(), b\"\\\\bar\");\n \n         t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n         t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n@@ -1284,9 +1275,9 @@ mod tests {\n \n     #[test]\n     fn test_opt_paths() {\n-        assert!(Path::new_opt(b!(\"foo\\\\bar\", 0)) == None);\n-        assert!(Path::new_opt(b!(\"foo\\\\bar\", 0x80)) == None);\n-        t!(v: Path::new_opt(b!(\"foo\\\\bar\")).unwrap(), b!(\"foo\\\\bar\"));\n+        assert!(Path::new_opt(b\"foo\\\\bar\\0\") == None);\n+        assert!(Path::new_opt(b\"foo\\\\bar\\x80\") == None);\n+        t!(v: Path::new_opt(b\"foo\\\\bar\").unwrap(), b\"foo\\\\bar\");\n         assert!(Path::new_opt(\"foo\\\\bar\\0\") == None);\n         t!(s: Path::new_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n     }\n@@ -1295,38 +1286,38 @@ mod tests {\n     fn test_null_byte() {\n         use task;\n         let result = task::try(proc() {\n-            Path::new(b!(\"foo/bar\", 0))\n+            Path::new(b\"foo/bar\\0\")\n         });\n         assert!(result.is_err());\n \n         let result = task::try(proc() {\n-            Path::new(\"test\").set_filename(b!(\"f\", 0, \"o\"))\n+            Path::new(\"test\").set_filename(b\"f\\0o\")\n         });\n         assert!(result.is_err());\n \n         let result = task::try(proc() {\n-            Path::new(\"test\").push(b!(\"f\", 0, \"o\"));\n+            Path::new(\"test\").push(b\"f\\0o\");\n         });\n         assert!(result.is_err());\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_not_utf8_fail() {\n-        Path::new(b!(\"hello\", 0x80, \".txt\"));\n+        Path::new(b\"hello\\x80.txt\");\n     }\n \n     #[test]\n     fn test_display_str() {\n         let path = Path::new(\"foo\");\n         assert_eq!(path.display().to_str(), \"foo\".to_string());\n-        let path = Path::new(b!(\"\\\\\"));\n+        let path = Path::new(b\"\\\\\");\n         assert_eq!(path.filename_display().to_str(), \"\".to_string());\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_maybe_owned();\n         assert_eq!(mo.as_slice(), \"foo\");\n-        let path = Path::new(b!(\"\\\\\"));\n+        let path = Path::new(b\"\\\\\");\n         let mo = path.filename_display().as_maybe_owned();\n         assert_eq!(mo.as_slice(), \"\");\n     }\n@@ -1377,7 +1368,7 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a\\\\b\\\\c\"), filename, Some(b!(\"c\")));\n+        t!(v: b\"a\\\\b\\\\c\", filename, Some(b\"c\"));\n         t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n         t!(s: \"\\\\a\\\\b\\\\c\", filename_str, \"c\");\n         t!(s: \"a\", filename_str, \"a\");\n@@ -1410,7 +1401,7 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", filename_str, \"b\");\n \n-        t!(v: b!(\"a\\\\b\\\\c\"), dirname, b!(\"a\\\\b\"));\n+        t!(v: b\"a\\\\b\\\\c\", dirname, b\"a\\\\b\");\n         t!(s: \"a\\\\b\\\\c\", dirname_str, \"a\\\\b\");\n         t!(s: \"\\\\a\\\\b\\\\c\", dirname_str, \"\\\\a\\\\b\");\n         t!(s: \"a\", dirname_str, \".\");\n@@ -1441,7 +1432,7 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\foo\", dirname_str, \"\\\\\\\\.\\\\foo\");\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", dirname_str, \"\\\\\\\\?\\\\a\");\n \n-        t!(v: b!(\"hi\\\\there.txt\"), filestem, Some(b!(\"there\")));\n+        t!(v: b\"hi\\\\there.txt\", filestem, Some(b\"there\"));\n         t!(s: \"hi\\\\there.txt\", filestem_str, \"there\");\n         t!(s: \"hi\\\\there\", filestem_str, \"there\");\n         t!(s: \"there.txt\", filestem_str, \"there\");\n@@ -1456,8 +1447,8 @@ mod tests {\n         t!(s: \"..\\\\..\", filestem_str, None, opt);\n         // filestem is based on filename, so we don't need the full set of prefix tests\n \n-        t!(v: b!(\"hi\\\\there.txt\"), extension, Some(b!(\"txt\")));\n-        t!(v: b!(\"hi\\\\there\"), extension, None);\n+        t!(v: b\"hi\\\\there.txt\", extension, Some(b\"txt\"));\n+        t!(v: b\"hi\\\\there\", extension, None);\n         t!(s: \"hi\\\\there.txt\", extension_str, Some(\"txt\"), opt);\n         t!(s: \"hi\\\\there\", extension_str, None, opt);\n         t!(s: \"there.txt\", extension_str, Some(\"txt\"), opt);\n@@ -1583,10 +1574,10 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n-           b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"\\\\e\", b\"f\"], b\"\\\\e\\\\f\");\n+        t!(v: b\"a\\\\b\\\\c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")],\n+           b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n \n     #[test]\n@@ -1604,11 +1595,11 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             );\n-            (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n+            (b: $path:expr, $left:expr, $right:expr) => (\n                 {\n-                    let mut p = Path::new(b!($($path),+));\n+                    let mut p = Path::new($path);\n                     let result = p.pop();\n-                    assert_eq!(p.as_vec(), b!($($left),+));\n+                    assert_eq!(p.as_vec(), $left);\n                     assert!(result == $right);\n                 }\n             )\n@@ -1619,11 +1610,11 @@ mod tests {\n         t!(s: \".\", \".\", false);\n         t!(s: \"\\\\a\", \"\\\\\", true);\n         t!(s: \"\\\\\", \"\\\\\", false);\n-        t!(v: [\"a\\\\b\\\\c\"], [\"a\\\\b\"], true);\n-        t!(v: [\"a\"], [\".\"], true);\n-        t!(v: [\".\"], [\".\"], false);\n-        t!(v: [\"\\\\a\"], [\"\\\\\"], true);\n-        t!(v: [\"\\\\\"], [\"\\\\\"], false);\n+        t!(b: b\"a\\\\b\\\\c\", b\"a\\\\b\", true);\n+        t!(b: b\"a\", b\".\", true);\n+        t!(b: b\".\", b\".\", false);\n+        t!(b: b\"\\\\a\", b\"\\\\\", true);\n+        t!(b: b\"\\\\\", b\"\\\\\", false);\n \n         t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n         t!(s: \"C:\\\\a\", \"C:\\\\\", true);\n@@ -1672,8 +1663,8 @@ mod tests {\n         t!(s: Path::new(\"a\\\\b\").join(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n         t!(s: Path::new(\".\").join(\"a\\\\b\"), \"a\\\\b\");\n         t!(s: Path::new(\"\\\\\").join(\"a\\\\b\"), \"\\\\a\\\\b\");\n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n-        t!(v: Path::new(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n+        t!(v: Path::new(b\"a\\\\b\\\\c\").join(b\"..\"), b\"a\\\\b\");\n+        t!(v: Path::new(b\"\\\\a\\\\b\\\\c\").join(b\"d\"), b\"\\\\a\\\\b\\\\c\\\\d\");\n         // full join testing is covered under test_push_path, so no need for\n         // the full set of prefix tests\n     }\n@@ -1724,9 +1715,9 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n-           b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(v: b\"a\\\\b\\\\c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")],\n+           b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n \n     #[test]\n@@ -1839,15 +1830,15 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a\\\\b\\\\c\"), set_filename, with_filename, b!(\"d\"));\n-        t!(v: b!(\"\\\\\"), set_filename, with_filename, b!(\"foo\"));\n+        t!(v: b\"a\\\\b\\\\c\", set_filename, with_filename, b\"d\");\n+        t!(v: b\"\\\\\", set_filename, with_filename, b\"foo\");\n         t!(s: \"a\\\\b\\\\c\", set_filename, with_filename, \"d\");\n         t!(s: \"\\\\\", set_filename, with_filename, \"foo\");\n         t!(s: \".\", set_filename, with_filename, \"foo\");\n         t!(s: \"a\\\\b\", set_filename, with_filename, \"\");\n         t!(s: \"a\", set_filename, with_filename, \"\");\n \n-        t!(v: b!(\"hi\\\\there.txt\"), set_extension, with_extension, b!(\"exe\"));\n+        t!(v: b\"hi\\\\there.txt\", set_extension, with_extension, b\"exe\");\n         t!(s: \"hi\\\\there.txt\", set_extension, with_extension, \"exe\");\n         t!(s: \"hi\\\\there.\", set_extension, with_extension, \"txt\");\n         t!(s: \"hi\\\\there\", set_extension, with_extension, \"txt\");\n@@ -1894,7 +1885,7 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), Some(b!(\"c\")), b!(\"a\\\\b\"), Some(b!(\"c\")), None);\n+        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n         t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n         t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n         t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n@@ -2250,21 +2241,9 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             );\n-            (v: [$($arg:expr),+], $exp:expr) => (\n-                {\n-                    let path = Path::new(b!($($arg),+));\n-                    let comps = path.str_components().map(|x|x.unwrap()).collect::<Vec<&str>>();\n-                    let exp: &[&str] = $exp;\n-                    assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.str_components().rev().map(|x|x.unwrap())\n-                                .collect::<Vec<&str>>();\n-                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&str>>();\n-                    assert_eq!(comps, exp);\n-                }\n-            )\n         )\n \n-        t!(v: [\"a\\\\b\\\\c\"], [\"a\", \"b\", \"c\"]);\n+        t!(s: b\"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\d\", [\"a\", \"b\", \"d\"]);\n         t!(s: \"a\\\\b\\\\cd\", [\"a\", \"b\", \"cd\"]);\n@@ -2320,8 +2299,8 @@ mod tests {\n             )\n         )\n \n-        t!(s: \"a\\\\b\\\\c\", [b!(\"a\"), b!(\"b\"), b!(\"c\")]);\n-        t!(s: \".\", [b!(\".\")]);\n+        t!(s: \"a\\\\b\\\\c\", [b\"a\", b\"b\", b\"c\"]);\n+        t!(s: \".\", [b\".\"]);\n         // since this is really a wrapper around str_components, those tests suffice\n     }\n "}, {"sha": "658c28f8202720977e7a826a178096c09c899aa3", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -19,6 +19,14 @@ use ext::build::AstBuilder;\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                          -> Box<base::MacResult> {\n+    cx.span_warn(sp, \"`bytes!` is deprecated, use `b\\\"foo\\\"` literals instead\");\n+    cx.parse_sess.span_diagnostic.span_note(sp,\n+        \"see http://doc.rust-lang.org/rust.html#byte-and-byte-string-literals \\\n+         for documentation\");\n+    cx.parse_sess.span_diagnostic.span_note(sp,\n+        \"see https://github.com/rust-lang/rust/blob/master/src/etc/2014-06-rewrite-bytes-macros.py \\\n+         for a automated migration\");\n+\n     // Gather all argument expressions\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n         None => return DummyResult::expr(sp),"}, {"sha": "1a7063c495199b6676c0a4db69b42dfeadddb2c7", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -106,7 +106,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         *dst = (*src).clone();\n     }\n \n-    for c in cap.iter().map(|&x| x) {\n+    for &c in cap.iter() {\n         let cur = c as char;\n         let mut old_state = state;\n         match state {\n@@ -575,25 +575,25 @@ mod test {\n \n     #[test]\n     fn test_basic_setabf() {\n-        let s = bytes!(\"\\\\E[48;5;%p1%dm\");\n+        let s = b\"\\\\E[48;5;%p1%dm\";\n         assert_eq!(expand(s, [Number(1)], &mut Variables::new()).unwrap(),\n-                   bytes!(\"\\\\E[48;5;1m\").iter().map(|x| *x).collect());\n+                   \"\\\\E[48;5;1m\".bytes().collect());\n     }\n \n     #[test]\n     fn test_multiple_int_constants() {\n-        assert_eq!(expand(bytes!(\"%{1}%{2}%d%d\"), [], &mut Variables::new()).unwrap(),\n-                   bytes!(\"21\").iter().map(|x| *x).collect());\n+        assert_eq!(expand(b\"%{1}%{2}%d%d\", [], &mut Variables::new()).unwrap(),\n+                   \"21\".bytes().collect());\n     }\n \n     #[test]\n     fn test_op_i() {\n         let mut vars = Variables::new();\n-        assert_eq!(expand(bytes!(\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\"),\n+        assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n                           [Number(1),Number(2),Number(3)], &mut vars),\n-                   Ok(bytes!(\"123233\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%d%p2%d%i%p1%d%p2%d\"), [], &mut vars),\n-                   Ok(bytes!(\"0011\").iter().map(|x| *x).collect()));\n+                   Ok(\"123233\".bytes().collect()));\n+        assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", [], &mut vars),\n+                   Ok(\"0011\".bytes().collect()));\n     }\n \n     #[test]\n@@ -610,7 +610,7 @@ mod test {\n             } else {\n                 Number(97)\n             };\n-            let res = expand(bytes!(\"%p1\").iter().map(|x| *x).collect::<Vec<_>>()\n+            let res = expand(\"%p1\".bytes().collect::<Vec<_>>()\n                              .append(cap.as_bytes()).as_slice(),\n                              [p],\n                              vars);\n@@ -622,13 +622,13 @@ mod test {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 0 stack entries\", *cap);\n-            let res = expand(bytes!(\"%{1}\").iter().map(|x| *x).collect::<Vec<_>>()\n+            let res = expand(\"%{1}\".bytes().collect::<Vec<_>>()\n                              .append(cap.as_bytes()).as_slice(),\n                               [],\n                               vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 1 stack entry\", *cap);\n-            let res = expand(bytes!(\"%{1}%{2}\").iter().map(|x| *x).collect::<Vec<_>>()\n+            let res = expand(\"%{1}%{2}\".bytes().collect::<Vec<_>>()\n                              .append(cap.as_bytes()).as_slice(),\n                              [],\n                              vars);\n@@ -639,7 +639,7 @@ mod test {\n \n     #[test]\n     fn test_push_bad_param() {\n-        assert!(expand(bytes!(\"%pa\"), [], &mut Variables::new()).is_err());\n+        assert!(expand(b\"%pa\", [], &mut Variables::new()).is_err());\n     }\n \n     #[test]\n@@ -664,39 +664,37 @@ mod test {\n     #[test]\n     fn test_conditionals() {\n         let mut vars = Variables::new();\n-        let s = bytes!(\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\");\n+        let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n         let res = expand(s, [Number(1)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   bytes!(\"\\\\E[31m\").iter().map(|x| *x).collect());\n+                   \"\\\\E[31m\".bytes().collect());\n         let res = expand(s, [Number(8)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   bytes!(\"\\\\E[90m\").iter().map(|x| *x).collect());\n+                   \"\\\\E[90m\".bytes().collect());\n         let res = expand(s, [Number(42)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   bytes!(\"\\\\E[38;5;42m\").iter().map(|x| *x).collect());\n+                   \"\\\\E[38;5;42m\".bytes().collect());\n     }\n \n     #[test]\n     fn test_format() {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n-        assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n+        assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n                           [String(\"foo\".to_string()),\n                            String(\"foo\".to_string()),\n                            String(\"f\".to_string()),\n                            String(\"foo\".to_string())], vars),\n-                   Ok(bytes!(\"foofoo ffo\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_string())], vars),\n-                   Ok(bytes!(\"fo  \").iter().map(|x| *x).collect()));\n-\n-        assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),\n-                   Ok(bytes!(\"1001    1+1\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\"), [Number(15), Number(27)], vars),\n-                   Ok(bytes!(\"17017  001b0X001B\").iter()\n-                                                 .map(|x| *x)\n-                                                 .collect()));\n+                   Ok(\"foofoo ffo\".bytes().collect()));\n+        assert_eq!(expand(b\"%p1%:-4.2s\", [String(\"foo\".to_string())], vars),\n+                   Ok(\"fo  \".bytes().collect()));\n+\n+        assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", [Number(1)], vars),\n+                   Ok(\"1001    1+1\".bytes().collect()));\n+        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\", [Number(15), Number(27)], vars),\n+                   Ok(\"17017  001b0X001B\".bytes().collect()));\n     }\n }"}, {"sha": "916342b67434e01348b66be7ef97016935e43624", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -315,10 +315,10 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_string(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n-    strings.insert(\"bold\".to_string(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n-    strings.insert(\"setaf\".to_string(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n-    strings.insert(\"setab\".to_string(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n+    strings.insert(\"sgr0\".to_string(), Vec::from_slice(b\"\\x1B[0m\"));\n+    strings.insert(\"bold\".to_string(), Vec::from_slice(b\"\\x1B[1m\"));\n+    strings.insert(\"setaf\".to_string(), Vec::from_slice(b\"\\x1B[3%p1%dm\"));\n+    strings.insert(\"setab\".to_string(), Vec::from_slice(b\"\\x1B[4%p1%dm\"));\n     box TermInfo {\n         names: vec!(\"cygwin\".to_string()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),"}, {"sha": "e46c99cf4f0dd9c943ab85acb4381d33e87d165c", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -1,3 +1,11 @@\n+S 2014-06-18 d6736a1\n+  freebsd-x86_64 c1479bb3dc0ae3d8ba9193ff2caf92c805a95c51\n+  linux-i386 bb1543b21235a51e81460b9419e112396ccf1d20\n+  linux-x86_64 08df93f138bc6c9d083d28bb71384fcebf0380c1\n+  macos-i386 d6c0039ad7cbd5959e69c980ecf822e5097bac2c\n+  macos-x86_64 ee54924aa4103d35cf490da004d3cc4e48ca8fb0\n+  winnt-i386 943c99971e82847abe272df58bb7656ac3b91430\n+\n S 2014-06-14 2c6caad\n   freebsd-x86_64 0152ba43f238014f0aede7c29f1c684c21077b0b\n   linux-i386 2eb1897c25abe0d5978ff03171ca943e92666046"}, {"sha": "5f8352d1e5229525c003c8dac7504029aecc208a", "filename": "src/test/compile-fail/macros-nonfatal-errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -22,7 +22,8 @@ enum CantDeriveThose {}\n fn main() {\n     doesnt_exist!(); //~ ERROR\n \n-    bytes!(invalid); //~ ERROR\n+    bytes!(invalid); //~ ERROR non-literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n \n     asm!(invalid); //~ ERROR\n "}, {"sha": "d03696cbbbcc482f92eaecace20738dd0c464367", "filename": "src/test/compile-fail/syntax-extension-bytes-non-ascii-char-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-ascii-char-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-ascii-char-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-ascii-char-literal.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!('\u03bb'); //~ ERROR non-ascii char literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "3a2e104818fd202435c4a5531872b20fc1db54a3", "filename": "src/test/compile-fail/syntax-extension-bytes-non-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-literal.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(foo); //~ ERROR non-literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "8e7c6147758ca9354e544d1879e1182943b5279c", "filename": "src/test/compile-fail/syntax-extension-bytes-too-large-integer-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-integer-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-integer-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-integer-literal.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(1024); //~ ERROR too large integer literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "1a9aa3753eec7747827309818eaa9894d5236a27", "filename": "src/test/compile-fail/syntax-extension-bytes-too-large-u8-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-u8-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-u8-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-u8-literal.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(1024u8); //~ ERROR too large u8 literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "c2d4973594371e326bae074757d8482345971b03", "filename": "src/test/compile-fail/syntax-extension-bytes-too-small-integer-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-integer-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-integer-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-integer-literal.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(-1024); //~ ERROR non-literal in bytes\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "ac33ffb60e294f11ba9df9373f58e980fd045125", "filename": "src/test/compile-fail/syntax-extension-bytes-too-small-u8-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-u8-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-u8-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-u8-literal.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(-1024u8); //~ ERROR non-literal in bytes\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "f6b3659354c5ba4ef231e571588ca0a57d2b679c", "filename": "src/test/compile-fail/syntax-extension-bytes-unsupported-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(45f64); //~ ERROR unsupported literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "fd67b767104d502ed7a27a44f7e91f5360cc91da", "filename": "src/test/run-pass/issue-4333.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4333.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -12,5 +12,5 @@ use std::io;\n \n pub fn main() {\n     let stdout = &mut io::stdout() as &mut io::Writer;\n-    stdout.write(bytes!(\"Hello!\"));\n+    stdout.write(b\"Hello!\");\n }"}, {"sha": "4355bf4127fc4f9c727d679a9cad16269971a985", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -29,7 +29,7 @@ fn test_tempdir() {\n     let path = {\n         let p = TempDir::new_in(&Path::new(\".\"), \"foobar\").unwrap();\n         let p = p.path();\n-        assert!(p.as_vec().ends_with(bytes!(\"foobar\")));\n+        assert!(p.as_vec().ends_with(b\"foobar\"));\n         p.clone()\n     };\n     assert!(!path.exists());"}, {"sha": "55beebbf2bc576534000f91008729a1d0bb6af9a", "filename": "src/test/run-pass/trait-coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b8b6dc707775bd54aeea7820e0d473f556718/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs?ref=108b8b6dc707775bd54aeea7820e0d473f556718", "patch": "@@ -26,7 +26,7 @@ impl Trait for Struct {\n }\n \n fn foo(mut a: Box<Writer>) {\n-    a.write(bytes!(\"Hello\\n\"));\n+    a.write(b\"Hello\\n\");\n }\n \n pub fn main() {"}]}