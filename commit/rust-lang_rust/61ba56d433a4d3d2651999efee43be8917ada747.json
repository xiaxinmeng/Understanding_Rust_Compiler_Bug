{"sha": "61ba56d433a4d3d2651999efee43be8917ada747", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYmE1NmQ0MzNhNGQzZDI2NTE5OTllZmVlNDNiZTg5MTdhZGE3NDc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-28T20:54:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-28T20:54:21Z"}, "message": "Merge #3370\n\n3370: Move insert_use util to utils r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a1e27ccb3c18e4864f271391afa78331dc513b1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1e27ccb3c18e4864f271391afa78331dc513b1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61ba56d433a4d3d2651999efee43be8917ada747", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeWX39CRBK7hj4Ov3rIwAAdHIIAIavybAl9s7lejPBzfu2w/mr\nIrV2QoEBCSgRogMoHrf/tgteM2B8hz7ecEB6dP1R2+J91Y5jvHJCIOHwfkr2lRej\nibU/HCf1AEnxo0x6Ylr8cOg8uujp99ObxJAMGQFhuj7cbF0AhNliJzIaJpXh9XsB\nkfG5BBscZOJdSE2mYywEZkYCNf3/r/BLIN8GCtvTCfRUhxs7qL+gGF7Y4X07A3iV\nAn0fsYhBcHJTF78OUoDzIbllDguP5MmnaMt3jDCIKOBH4Ijh6XICBBzFgRUCKnh8\nnxOxLUNEyjIPNiEQaZULWNWGJLhkwVEfDJ0bbpRHran2GjExLbfL5ENwNN7BJJw=\n=/dFF\n-----END PGP SIGNATURE-----\n", "payload": "tree a1e27ccb3c18e4864f271391afa78331dc513b1f\nparent d2bf2adc272197eafa56f77363edaa6c410b39cf\nparent ff42008679c9b09fc9865fe55eba99d7ed6a0d05\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1582923261 +0000\ncommitter GitHub <noreply@github.com> 1582923261 +0000\n\nMerge #3370\n\n3370: Move insert_use util to utils r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61ba56d433a4d3d2651999efee43be8917ada747", "html_url": "https://github.com/rust-lang/rust/commit/61ba56d433a4d3d2651999efee43be8917ada747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61ba56d433a4d3d2651999efee43be8917ada747/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2bf2adc272197eafa56f77363edaa6c410b39cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bf2adc272197eafa56f77363edaa6c410b39cf", "html_url": "https://github.com/rust-lang/rust/commit/d2bf2adc272197eafa56f77363edaa6c410b39cf"}, {"sha": "ff42008679c9b09fc9865fe55eba99d7ed6a0d05", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff42008679c9b09fc9865fe55eba99d7ed6a0d05", "html_url": "https://github.com/rust-lang/rust/commit/ff42008679c9b09fc9865fe55eba99d7ed6a0d05"}], "stats": {"total": 1071, "additions": 538, "deletions": 533}, "files": [{"sha": "46fbdb5259518abdac20e9729f0c3e6cc8968255", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=61ba56d433a4d3d2651999efee43be8917ada747", "patch": "@@ -1,6 +1,7 @@\n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n-    insert_use_statement, AssistId,\n+    utils::insert_use_statement,\n+    AssistId,\n };\n use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,"}, {"sha": "44f3f5e7f6c5f7df798a31d1cfb1bf46af140ba3", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 18, "deletions": 531, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=61ba56d433a4d3d2651999efee43be8917ada747", "patch": "@@ -1,42 +1,12 @@\n-use hir::{self, ModPath};\n-use ra_syntax::{\n-    ast::{self, NameOwner},\n-    AstNode, Direction, SmolStr,\n-    SyntaxKind::{PATH, PATH_SEGMENT},\n-    SyntaxNode, TextRange, T,\n-};\n-use ra_text_edit::TextEditBuilder;\n+use hir;\n+use ra_syntax::{ast, AstNode, SmolStr, TextRange};\n \n use crate::{\n     assist_ctx::{Assist, AssistCtx},\n+    utils::insert_use_statement,\n     AssistId,\n };\n \n-/// Creates and inserts a use statement for the given path to import.\n-/// The use statement is inserted in the scope most appropriate to the\n-/// the cursor position given, additionally merged with the existing use imports.\n-pub fn insert_use_statement(\n-    // Ideally the position of the cursor, used to\n-    position: &SyntaxNode,\n-    // The statement to use as anchor (last resort)\n-    anchor: &SyntaxNode,\n-    path_to_import: &ModPath,\n-    edit: &mut TextEditBuilder,\n-) {\n-    let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n-    let container = position.ancestors().find_map(|n| {\n-        if let Some(module) = ast::Module::cast(n.clone()) {\n-            return module.item_list().map(|it| it.syntax().clone());\n-        }\n-        ast::SourceFile::cast(n).map(|it| it.syntax().clone())\n-    });\n-\n-    if let Some(container) = container {\n-        let action = best_action_for_target(container, anchor.clone(), &target);\n-        make_assist(&action, &target, edit);\n-    }\n-}\n-\n // Assist: replace_qualified_name_with_use\n //\n // Adds a use statement for a given fully-qualified name.\n@@ -76,507 +46,24 @@ pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist>\n         AssistId(\"replace_qualified_name_with_use\"),\n         \"Replace qualified path with use\",\n         |edit| {\n-            replace_with_use(&position, &path, &segments, edit.text_edit_builder());\n-        },\n-    )\n-}\n-\n-fn collect_path_segments_raw(\n-    segments: &mut Vec<ast::PathSegment>,\n-    mut path: ast::Path,\n-) -> Option<usize> {\n-    let oldlen = segments.len();\n-    loop {\n-        let mut children = path.syntax().children_with_tokens();\n-        let (first, second, third) = (\n-            children.next().map(|n| (n.clone(), n.kind())),\n-            children.next().map(|n| (n.clone(), n.kind())),\n-            children.next().map(|n| (n.clone(), n.kind())),\n-        );\n-        match (first, second, third) {\n-            (Some((subpath, PATH)), Some((_, T![::])), Some((segment, PATH_SEGMENT))) => {\n-                path = ast::Path::cast(subpath.as_node()?.clone())?;\n-                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n-            }\n-            (Some((segment, PATH_SEGMENT)), _, _) => {\n-                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n-                break;\n-            }\n-            (_, _, _) => return None,\n-        }\n-    }\n-    // We need to reverse only the new added segments\n-    let only_new_segments = segments.split_at_mut(oldlen).1;\n-    only_new_segments.reverse();\n-    Some(segments.len() - oldlen)\n-}\n-\n-fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n-    let mut iter = segments.iter();\n-    if let Some(s) = iter.next() {\n-        buf.push_str(s);\n-    }\n-    for s in iter {\n-        buf.push_str(\"::\");\n-        buf.push_str(s);\n-    }\n-}\n-\n-/// Returns the number of common segments.\n-fn compare_path_segments(left: &[SmolStr], right: &[ast::PathSegment]) -> usize {\n-    left.iter().zip(right).take_while(|(l, r)| compare_path_segment(l, r)).count()\n-}\n-\n-fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n-    if let Some(kb) = b.kind() {\n-        match kb {\n-            ast::PathSegmentKind::Name(nameref_b) => a == nameref_b.text(),\n-            ast::PathSegmentKind::SelfKw => a == \"self\",\n-            ast::PathSegmentKind::SuperKw => a == \"super\",\n-            ast::PathSegmentKind::CrateKw => a == \"crate\",\n-            ast::PathSegmentKind::Type { .. } => false, // not allowed in imports\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n-fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n-    a == b.text()\n-}\n-\n-#[derive(Clone, Debug)]\n-enum ImportAction {\n-    Nothing,\n-    // Add a brand new use statement.\n-    AddNewUse {\n-        anchor: Option<SyntaxNode>, // anchor node\n-        add_after_anchor: bool,\n-    },\n-\n-    // To split an existing use statement creating a nested import.\n-    AddNestedImport {\n-        // how may segments matched with the target path\n-        common_segments: usize,\n-        path_to_split: ast::Path,\n-        // the first segment of path_to_split we want to add into the new nested list\n-        first_segment_to_split: Option<ast::PathSegment>,\n-        // Wether to add 'self' in addition to the target path\n-        add_self: bool,\n-    },\n-    // To add the target path to an existing nested import tree list.\n-    AddInTreeList {\n-        common_segments: usize,\n-        // The UseTreeList where to add the target path\n-        tree_list: ast::UseTreeList,\n-        add_self: bool,\n-    },\n-}\n-\n-impl ImportAction {\n-    fn add_new_use(anchor: Option<SyntaxNode>, add_after_anchor: bool) -> Self {\n-        ImportAction::AddNewUse { anchor, add_after_anchor }\n-    }\n-\n-    fn add_nested_import(\n-        common_segments: usize,\n-        path_to_split: ast::Path,\n-        first_segment_to_split: Option<ast::PathSegment>,\n-        add_self: bool,\n-    ) -> Self {\n-        ImportAction::AddNestedImport {\n-            common_segments,\n-            path_to_split,\n-            first_segment_to_split,\n-            add_self,\n-        }\n-    }\n-\n-    fn add_in_tree_list(\n-        common_segments: usize,\n-        tree_list: ast::UseTreeList,\n-        add_self: bool,\n-    ) -> Self {\n-        ImportAction::AddInTreeList { common_segments, tree_list, add_self }\n-    }\n-\n-    fn better(left: ImportAction, right: ImportAction) -> ImportAction {\n-        if left.is_better(&right) {\n-            left\n-        } else {\n-            right\n-        }\n-    }\n-\n-    fn is_better(&self, other: &ImportAction) -> bool {\n-        match (self, other) {\n-            (ImportAction::Nothing, _) => true,\n-            (ImportAction::AddInTreeList { .. }, ImportAction::Nothing) => false,\n-            (\n-                ImportAction::AddNestedImport { common_segments: n, .. },\n-                ImportAction::AddInTreeList { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddInTreeList { common_segments: n, .. },\n-                ImportAction::AddNestedImport { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddInTreeList { common_segments: n, .. },\n-                ImportAction::AddInTreeList { common_segments: m, .. },\n-            )\n-            | (\n-                ImportAction::AddNestedImport { common_segments: n, .. },\n-                ImportAction::AddNestedImport { common_segments: m, .. },\n-            ) => n > m,\n-            (ImportAction::AddInTreeList { .. }, _) => true,\n-            (ImportAction::AddNestedImport { .. }, ImportAction::Nothing) => false,\n-            (ImportAction::AddNestedImport { .. }, _) => true,\n-            (ImportAction::AddNewUse { .. }, _) => false,\n-        }\n-    }\n-}\n-\n-// Find out the best ImportAction to import target path against current_use_tree.\n-// If current_use_tree has a nested import the function gets called recursively on every UseTree inside a UseTreeList.\n-fn walk_use_tree_for_best_action(\n-    current_path_segments: &mut Vec<ast::PathSegment>, // buffer containing path segments\n-    current_parent_use_tree_list: Option<ast::UseTreeList>, // will be Some value if we are in a nested import\n-    current_use_tree: ast::UseTree, // the use tree we are currently examinating\n-    target: &[SmolStr],             // the path we want to import\n-) -> ImportAction {\n-    // We save the number of segments in the buffer so we can restore the correct segments\n-    // before returning. Recursive call will add segments so we need to delete them.\n-    let prev_len = current_path_segments.len();\n-\n-    let tree_list = current_use_tree.use_tree_list();\n-    let alias = current_use_tree.alias();\n-\n-    let path = match current_use_tree.path() {\n-        Some(path) => path,\n-        None => {\n-            // If the use item don't have a path, it means it's broken (syntax error)\n-            return ImportAction::add_new_use(\n-                current_use_tree\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(ast::UseItem::cast)\n-                    .map(|it| it.syntax().clone()),\n-                true,\n-            );\n-        }\n-    };\n-\n-    // This can happen only if current_use_tree is a direct child of a UseItem\n-    if let Some(name) = alias.and_then(|it| it.name()) {\n-        if compare_path_segment_with_name(&target[0], &name) {\n-            return ImportAction::Nothing;\n-        }\n-    }\n-\n-    collect_path_segments_raw(current_path_segments, path.clone());\n-\n-    // We compare only the new segments added in the line just above.\n-    // The first prev_len segments were already compared in 'parent' recursive calls.\n-    let left = target.split_at(prev_len).1;\n-    let right = current_path_segments.split_at(prev_len).1;\n-    let common = compare_path_segments(left, &right);\n-    let mut action = match common {\n-        0 => ImportAction::add_new_use(\n-            // e.g: target is std::fmt and we can have\n-            // use foo::bar\n-            // We add a brand new use statement\n-            current_use_tree\n-                .syntax()\n-                .ancestors()\n-                .find_map(ast::UseItem::cast)\n-                .map(|it| it.syntax().clone()),\n-            true,\n-        ),\n-        common if common == left.len() && left.len() == right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // 1- use std::fmt;\n-            // 2- use std::fmt::{ ... }\n-            if let Some(list) = tree_list {\n-                // In case 2 we need to add self to the nested list\n-                // unless it's already there\n-                let has_self = list.use_trees().map(|it| it.path()).any(|p| {\n-                    p.and_then(|it| it.segment())\n-                        .and_then(|it| it.kind())\n-                        .filter(|k| *k == ast::PathSegmentKind::SelfKw)\n-                        .is_some()\n-                });\n-\n-                if has_self {\n-                    ImportAction::Nothing\n-                } else {\n-                    ImportAction::add_in_tree_list(current_path_segments.len(), list, true)\n-                }\n-            } else {\n-                // Case 1\n-                ImportAction::Nothing\n-            }\n-        }\n-        common if common != left.len() && left.len() == right.len() => {\n-            // e.g: target is std::fmt and we have\n-            // use std::io;\n-            // We need to split.\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                false,\n-            )\n-        }\n-        common if common == right.len() && left.len() > right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // 1- use std;\n-            // 2- use std::{ ... };\n-\n-            // fallback action\n-            let mut better_action = ImportAction::add_new_use(\n-                current_use_tree\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(ast::UseItem::cast)\n-                    .map(|it| it.syntax().clone()),\n-                true,\n+            let path_to_import = hir_path.mod_path().clone();\n+            insert_use_statement(\n+                &position,\n+                &path.syntax(),\n+                &path_to_import,\n+                edit.text_edit_builder(),\n             );\n-            if let Some(list) = tree_list {\n-                // Case 2, check recursively if the path is already imported in the nested list\n-                for u in list.use_trees() {\n-                    let child_action = walk_use_tree_for_best_action(\n-                        current_path_segments,\n-                        Some(list.clone()),\n-                        u,\n-                        target,\n-                    );\n-                    if child_action.is_better(&better_action) {\n-                        better_action = child_action;\n-                        if let ImportAction::Nothing = better_action {\n-                            return better_action;\n-                        }\n-                    }\n-                }\n-            } else {\n-                // Case 1, split adding self\n-                better_action = ImportAction::add_nested_import(prev_len + common, path, None, true)\n-            }\n-            better_action\n-        }\n-        common if common == left.len() && left.len() < right.len() => {\n-            // e.g: target is std::fmt and we can have\n-            // use std::fmt::Debug;\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                true,\n-            )\n-        }\n-        common if common < left.len() && common < right.len() => {\n-            // e.g: target is std::fmt::nested::Debug\n-            // use std::fmt::Display\n-            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n-            ImportAction::add_nested_import(\n-                prev_len + common,\n-                path,\n-                Some(segments_to_split[0].clone()),\n-                false,\n-            )\n-        }\n-        _ => unreachable!(),\n-    };\n-\n-    // If we are inside a UseTreeList adding a use statement become adding to the existing\n-    // tree list.\n-    action = match (current_parent_use_tree_list, action.clone()) {\n-        (Some(use_tree_list), ImportAction::AddNewUse { .. }) => {\n-            ImportAction::add_in_tree_list(prev_len, use_tree_list, false)\n-        }\n-        (_, _) => action,\n-    };\n-\n-    // We remove the segments added\n-    current_path_segments.truncate(prev_len);\n-    action\n-}\n-\n-fn best_action_for_target(\n-    container: SyntaxNode,\n-    anchor: SyntaxNode,\n-    target: &[SmolStr],\n-) -> ImportAction {\n-    let mut storage = Vec::with_capacity(16); // this should be the only allocation\n-    let best_action = container\n-        .children()\n-        .filter_map(ast::UseItem::cast)\n-        .filter_map(|it| it.use_tree())\n-        .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n-        .fold(None, |best, a| match best {\n-            Some(best) => Some(ImportAction::better(best, a)),\n-            None => Some(a),\n-        });\n-\n-    match best_action {\n-        Some(action) => action,\n-        None => {\n-            // We have no action and no UseItem was found in container so we find\n-            // another item and we use it as anchor.\n-            // If there are no items above, we choose the target path itself as anchor.\n-            // todo: we should include even whitespace blocks as anchor candidates\n-            let anchor = container\n-                .children()\n-                .find(|n| n.text_range().start() < anchor.text_range().start())\n-                .or_else(|| Some(anchor));\n-\n-            let add_after_anchor = anchor\n-                .clone()\n-                .and_then(ast::Attr::cast)\n-                .map(|attr| attr.kind() == ast::AttrKind::Inner)\n-                .unwrap_or(false);\n-            ImportAction::add_new_use(anchor, add_after_anchor)\n-        }\n-    }\n-}\n-\n-fn make_assist(action: &ImportAction, target: &[SmolStr], edit: &mut TextEditBuilder) {\n-    match action {\n-        ImportAction::AddNewUse { anchor, add_after_anchor } => {\n-            make_assist_add_new_use(anchor, *add_after_anchor, target, edit)\n-        }\n-        ImportAction::AddInTreeList { common_segments, tree_list, add_self } => {\n-            // We know that the fist n segments already exists in the use statement we want\n-            // to modify, so we want to add only the last target.len() - n segments.\n-            let segments_to_add = target.split_at(*common_segments).1;\n-            make_assist_add_in_tree_list(tree_list, segments_to_add, *add_self, edit)\n-        }\n-        ImportAction::AddNestedImport {\n-            common_segments,\n-            path_to_split,\n-            first_segment_to_split,\n-            add_self,\n-        } => {\n-            let segments_to_add = target.split_at(*common_segments).1;\n-            make_assist_add_nested_import(\n-                path_to_split,\n-                first_segment_to_split,\n-                segments_to_add,\n-                *add_self,\n-                edit,\n-            )\n-        }\n-        _ => {}\n-    }\n-}\n \n-fn make_assist_add_new_use(\n-    anchor: &Option<SyntaxNode>,\n-    after: bool,\n-    target: &[SmolStr],\n-    edit: &mut TextEditBuilder,\n-) {\n-    if let Some(anchor) = anchor {\n-        let indent = ra_fmt::leading_indent(anchor);\n-        let mut buf = String::new();\n-        if after {\n-            buf.push_str(\"\\n\");\n-            if let Some(spaces) = &indent {\n-                buf.push_str(spaces);\n-            }\n-        }\n-        buf.push_str(\"use \");\n-        fmt_segments_raw(target, &mut buf);\n-        buf.push_str(\";\");\n-        if !after {\n-            buf.push_str(\"\\n\\n\");\n-            if let Some(spaces) = &indent {\n-                buf.push_str(&spaces);\n+            if let Some(last) = path.segment() {\n+                // Here we are assuming the assist will provide a correct use statement\n+                // so we can delete the path qualifier\n+                edit.delete(TextRange::from_to(\n+                    path.syntax().text_range().start(),\n+                    last.syntax().text_range().start(),\n+                ));\n             }\n-        }\n-        let position = if after { anchor.text_range().end() } else { anchor.text_range().start() };\n-        edit.insert(position, buf);\n-    }\n-}\n-\n-fn make_assist_add_in_tree_list(\n-    tree_list: &ast::UseTreeList,\n-    target: &[SmolStr],\n-    add_self: bool,\n-    edit: &mut TextEditBuilder,\n-) {\n-    let last = tree_list.use_trees().last();\n-    if let Some(last) = last {\n-        let mut buf = String::new();\n-        let comma = last.syntax().siblings(Direction::Next).find(|n| n.kind() == T![,]);\n-        let offset = if let Some(comma) = comma {\n-            comma.text_range().end()\n-        } else {\n-            buf.push_str(\",\");\n-            last.syntax().text_range().end()\n-        };\n-        if add_self {\n-            buf.push_str(\" self\")\n-        } else {\n-            buf.push_str(\" \");\n-        }\n-        fmt_segments_raw(target, &mut buf);\n-        edit.insert(offset, buf);\n-    } else {\n-    }\n-}\n-\n-fn make_assist_add_nested_import(\n-    path: &ast::Path,\n-    first_segment_to_split: &Option<ast::PathSegment>,\n-    target: &[SmolStr],\n-    add_self: bool,\n-    edit: &mut TextEditBuilder,\n-) {\n-    let use_tree = path.syntax().ancestors().find_map(ast::UseTree::cast);\n-    if let Some(use_tree) = use_tree {\n-        let (start, add_colon_colon) = if let Some(first_segment_to_split) = first_segment_to_split\n-        {\n-            (first_segment_to_split.syntax().text_range().start(), false)\n-        } else {\n-            (use_tree.syntax().text_range().end(), true)\n-        };\n-        let end = use_tree.syntax().text_range().end();\n-\n-        let mut buf = String::new();\n-        if add_colon_colon {\n-            buf.push_str(\"::\");\n-        }\n-        buf.push_str(\"{\");\n-        if add_self {\n-            buf.push_str(\"self, \");\n-        }\n-        fmt_segments_raw(target, &mut buf);\n-        if !target.is_empty() {\n-            buf.push_str(\", \");\n-        }\n-        edit.insert(start, buf);\n-        edit.insert(end, \"}\".to_string());\n-    }\n-}\n-\n-fn replace_with_use(\n-    container: &SyntaxNode,\n-    path: &ast::Path,\n-    target: &[SmolStr],\n-    edit: &mut TextEditBuilder,\n-) {\n-    let action = best_action_for_target(container.clone(), path.syntax().clone(), target);\n-    make_assist(&action, target, edit);\n-    if let Some(last) = path.segment() {\n-        // Here we are assuming the assist will provide a correct use statement\n-        // so we can delete the path qualifier\n-        edit.delete(TextRange::from_to(\n-            path.syntax().text_range().start(),\n-            last.syntax().text_range().start(),\n-        ));\n-    }\n+        },\n+    )\n }\n \n fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {"}, {"sha": "deeada2de52868c20204fa21a7cebac90bec2255", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=61ba56d433a4d3d2651999efee43be8917ada747", "patch": "@@ -18,7 +18,6 @@ use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n \n pub(crate) use crate::assist_ctx::{Assist, AssistCtx, AssistHandler};\n-pub use crate::handlers::replace_qualified_name_with_use::insert_use_statement;\n use hir::Semantics;\n \n /// Unique identifier of the assist, should not be shown to the user"}, {"sha": "d544caee7b159f40344ea507b1827e65e47eefc9", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=61ba56d433a4d3d2651999efee43be8917ada747", "patch": "@@ -1,4 +1,5 @@\n //! Assorted functions shared by several assists.\n+pub(crate) mod insert_use;\n \n use hir::Semantics;\n use ra_ide_db::RootDatabase;\n@@ -8,6 +9,8 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashSet;\n \n+pub use insert_use::insert_use_statement;\n+\n pub fn get_missing_impl_items(\n     sema: &Semantics<RootDatabase>,\n     impl_block: &ast::ImplBlock,"}, {"sha": "7ae3440ca3d0e68bde69646176a162498ea6f4f4", "filename": "crates/ra_assists/src/utils/insert_use.rs", "status": "added", "additions": 515, "deletions": 0, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ba56d433a4d3d2651999efee43be8917ada747/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs?ref=61ba56d433a4d3d2651999efee43be8917ada747", "patch": "@@ -0,0 +1,515 @@\n+//! Handle syntactic aspects of inserting a new `use`.\n+\n+use hir::{self, ModPath};\n+use ra_syntax::{\n+    ast::{self, NameOwner},\n+    AstNode, Direction, SmolStr,\n+    SyntaxKind::{PATH, PATH_SEGMENT},\n+    SyntaxNode, T,\n+};\n+use ra_text_edit::TextEditBuilder;\n+\n+/// Creates and inserts a use statement for the given path to import.\n+/// The use statement is inserted in the scope most appropriate to the\n+/// the cursor position given, additionally merged with the existing use imports.\n+pub fn insert_use_statement(\n+    // Ideally the position of the cursor, used to\n+    position: &SyntaxNode,\n+    // The statement to use as anchor (last resort)\n+    anchor: &SyntaxNode,\n+    path_to_import: &ModPath,\n+    edit: &mut TextEditBuilder,\n+) {\n+    let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n+    let container = position.ancestors().find_map(|n| {\n+        if let Some(module) = ast::Module::cast(n.clone()) {\n+            return module.item_list().map(|it| it.syntax().clone());\n+        }\n+        ast::SourceFile::cast(n).map(|it| it.syntax().clone())\n+    });\n+\n+    if let Some(container) = container {\n+        let action = best_action_for_target(container, anchor.clone(), &target);\n+        make_assist(&action, &target, edit);\n+    }\n+}\n+\n+fn collect_path_segments_raw(\n+    segments: &mut Vec<ast::PathSegment>,\n+    mut path: ast::Path,\n+) -> Option<usize> {\n+    let oldlen = segments.len();\n+    loop {\n+        let mut children = path.syntax().children_with_tokens();\n+        let (first, second, third) = (\n+            children.next().map(|n| (n.clone(), n.kind())),\n+            children.next().map(|n| (n.clone(), n.kind())),\n+            children.next().map(|n| (n.clone(), n.kind())),\n+        );\n+        match (first, second, third) {\n+            (Some((subpath, PATH)), Some((_, T![::])), Some((segment, PATH_SEGMENT))) => {\n+                path = ast::Path::cast(subpath.as_node()?.clone())?;\n+                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n+            }\n+            (Some((segment, PATH_SEGMENT)), _, _) => {\n+                segments.push(ast::PathSegment::cast(segment.as_node()?.clone())?);\n+                break;\n+            }\n+            (_, _, _) => return None,\n+        }\n+    }\n+    // We need to reverse only the new added segments\n+    let only_new_segments = segments.split_at_mut(oldlen).1;\n+    only_new_segments.reverse();\n+    Some(segments.len() - oldlen)\n+}\n+\n+fn fmt_segments_raw(segments: &[SmolStr], buf: &mut String) {\n+    let mut iter = segments.iter();\n+    if let Some(s) = iter.next() {\n+        buf.push_str(s);\n+    }\n+    for s in iter {\n+        buf.push_str(\"::\");\n+        buf.push_str(s);\n+    }\n+}\n+\n+/// Returns the number of common segments.\n+fn compare_path_segments(left: &[SmolStr], right: &[ast::PathSegment]) -> usize {\n+    left.iter().zip(right).take_while(|(l, r)| compare_path_segment(l, r)).count()\n+}\n+\n+fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n+    if let Some(kb) = b.kind() {\n+        match kb {\n+            ast::PathSegmentKind::Name(nameref_b) => a == nameref_b.text(),\n+            ast::PathSegmentKind::SelfKw => a == \"self\",\n+            ast::PathSegmentKind::SuperKw => a == \"super\",\n+            ast::PathSegmentKind::CrateKw => a == \"crate\",\n+            ast::PathSegmentKind::Type { .. } => false, // not allowed in imports\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn compare_path_segment_with_name(a: &SmolStr, b: &ast::Name) -> bool {\n+    a == b.text()\n+}\n+\n+#[derive(Clone, Debug)]\n+enum ImportAction {\n+    Nothing,\n+    // Add a brand new use statement.\n+    AddNewUse {\n+        anchor: Option<SyntaxNode>, // anchor node\n+        add_after_anchor: bool,\n+    },\n+\n+    // To split an existing use statement creating a nested import.\n+    AddNestedImport {\n+        // how may segments matched with the target path\n+        common_segments: usize,\n+        path_to_split: ast::Path,\n+        // the first segment of path_to_split we want to add into the new nested list\n+        first_segment_to_split: Option<ast::PathSegment>,\n+        // Wether to add 'self' in addition to the target path\n+        add_self: bool,\n+    },\n+    // To add the target path to an existing nested import tree list.\n+    AddInTreeList {\n+        common_segments: usize,\n+        // The UseTreeList where to add the target path\n+        tree_list: ast::UseTreeList,\n+        add_self: bool,\n+    },\n+}\n+\n+impl ImportAction {\n+    fn add_new_use(anchor: Option<SyntaxNode>, add_after_anchor: bool) -> Self {\n+        ImportAction::AddNewUse { anchor, add_after_anchor }\n+    }\n+\n+    fn add_nested_import(\n+        common_segments: usize,\n+        path_to_split: ast::Path,\n+        first_segment_to_split: Option<ast::PathSegment>,\n+        add_self: bool,\n+    ) -> Self {\n+        ImportAction::AddNestedImport {\n+            common_segments,\n+            path_to_split,\n+            first_segment_to_split,\n+            add_self,\n+        }\n+    }\n+\n+    fn add_in_tree_list(\n+        common_segments: usize,\n+        tree_list: ast::UseTreeList,\n+        add_self: bool,\n+    ) -> Self {\n+        ImportAction::AddInTreeList { common_segments, tree_list, add_self }\n+    }\n+\n+    fn better(left: ImportAction, right: ImportAction) -> ImportAction {\n+        if left.is_better(&right) {\n+            left\n+        } else {\n+            right\n+        }\n+    }\n+\n+    fn is_better(&self, other: &ImportAction) -> bool {\n+        match (self, other) {\n+            (ImportAction::Nothing, _) => true,\n+            (ImportAction::AddInTreeList { .. }, ImportAction::Nothing) => false,\n+            (\n+                ImportAction::AddNestedImport { common_segments: n, .. },\n+                ImportAction::AddInTreeList { common_segments: m, .. },\n+            )\n+            | (\n+                ImportAction::AddInTreeList { common_segments: n, .. },\n+                ImportAction::AddNestedImport { common_segments: m, .. },\n+            )\n+            | (\n+                ImportAction::AddInTreeList { common_segments: n, .. },\n+                ImportAction::AddInTreeList { common_segments: m, .. },\n+            )\n+            | (\n+                ImportAction::AddNestedImport { common_segments: n, .. },\n+                ImportAction::AddNestedImport { common_segments: m, .. },\n+            ) => n > m,\n+            (ImportAction::AddInTreeList { .. }, _) => true,\n+            (ImportAction::AddNestedImport { .. }, ImportAction::Nothing) => false,\n+            (ImportAction::AddNestedImport { .. }, _) => true,\n+            (ImportAction::AddNewUse { .. }, _) => false,\n+        }\n+    }\n+}\n+\n+// Find out the best ImportAction to import target path against current_use_tree.\n+// If current_use_tree has a nested import the function gets called recursively on every UseTree inside a UseTreeList.\n+fn walk_use_tree_for_best_action(\n+    current_path_segments: &mut Vec<ast::PathSegment>, // buffer containing path segments\n+    current_parent_use_tree_list: Option<ast::UseTreeList>, // will be Some value if we are in a nested import\n+    current_use_tree: ast::UseTree, // the use tree we are currently examinating\n+    target: &[SmolStr],             // the path we want to import\n+) -> ImportAction {\n+    // We save the number of segments in the buffer so we can restore the correct segments\n+    // before returning. Recursive call will add segments so we need to delete them.\n+    let prev_len = current_path_segments.len();\n+\n+    let tree_list = current_use_tree.use_tree_list();\n+    let alias = current_use_tree.alias();\n+\n+    let path = match current_use_tree.path() {\n+        Some(path) => path,\n+        None => {\n+            // If the use item don't have a path, it means it's broken (syntax error)\n+            return ImportAction::add_new_use(\n+                current_use_tree\n+                    .syntax()\n+                    .ancestors()\n+                    .find_map(ast::UseItem::cast)\n+                    .map(|it| it.syntax().clone()),\n+                true,\n+            );\n+        }\n+    };\n+\n+    // This can happen only if current_use_tree is a direct child of a UseItem\n+    if let Some(name) = alias.and_then(|it| it.name()) {\n+        if compare_path_segment_with_name(&target[0], &name) {\n+            return ImportAction::Nothing;\n+        }\n+    }\n+\n+    collect_path_segments_raw(current_path_segments, path.clone());\n+\n+    // We compare only the new segments added in the line just above.\n+    // The first prev_len segments were already compared in 'parent' recursive calls.\n+    let left = target.split_at(prev_len).1;\n+    let right = current_path_segments.split_at(prev_len).1;\n+    let common = compare_path_segments(left, &right);\n+    let mut action = match common {\n+        0 => ImportAction::add_new_use(\n+            // e.g: target is std::fmt and we can have\n+            // use foo::bar\n+            // We add a brand new use statement\n+            current_use_tree\n+                .syntax()\n+                .ancestors()\n+                .find_map(ast::UseItem::cast)\n+                .map(|it| it.syntax().clone()),\n+            true,\n+        ),\n+        common if common == left.len() && left.len() == right.len() => {\n+            // e.g: target is std::fmt and we can have\n+            // 1- use std::fmt;\n+            // 2- use std::fmt::{ ... }\n+            if let Some(list) = tree_list {\n+                // In case 2 we need to add self to the nested list\n+                // unless it's already there\n+                let has_self = list.use_trees().map(|it| it.path()).any(|p| {\n+                    p.and_then(|it| it.segment())\n+                        .and_then(|it| it.kind())\n+                        .filter(|k| *k == ast::PathSegmentKind::SelfKw)\n+                        .is_some()\n+                });\n+\n+                if has_self {\n+                    ImportAction::Nothing\n+                } else {\n+                    ImportAction::add_in_tree_list(current_path_segments.len(), list, true)\n+                }\n+            } else {\n+                // Case 1\n+                ImportAction::Nothing\n+            }\n+        }\n+        common if common != left.len() && left.len() == right.len() => {\n+            // e.g: target is std::fmt and we have\n+            // use std::io;\n+            // We need to split.\n+            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n+            ImportAction::add_nested_import(\n+                prev_len + common,\n+                path,\n+                Some(segments_to_split[0].clone()),\n+                false,\n+            )\n+        }\n+        common if common == right.len() && left.len() > right.len() => {\n+            // e.g: target is std::fmt and we can have\n+            // 1- use std;\n+            // 2- use std::{ ... };\n+\n+            // fallback action\n+            let mut better_action = ImportAction::add_new_use(\n+                current_use_tree\n+                    .syntax()\n+                    .ancestors()\n+                    .find_map(ast::UseItem::cast)\n+                    .map(|it| it.syntax().clone()),\n+                true,\n+            );\n+            if let Some(list) = tree_list {\n+                // Case 2, check recursively if the path is already imported in the nested list\n+                for u in list.use_trees() {\n+                    let child_action = walk_use_tree_for_best_action(\n+                        current_path_segments,\n+                        Some(list.clone()),\n+                        u,\n+                        target,\n+                    );\n+                    if child_action.is_better(&better_action) {\n+                        better_action = child_action;\n+                        if let ImportAction::Nothing = better_action {\n+                            return better_action;\n+                        }\n+                    }\n+                }\n+            } else {\n+                // Case 1, split adding self\n+                better_action = ImportAction::add_nested_import(prev_len + common, path, None, true)\n+            }\n+            better_action\n+        }\n+        common if common == left.len() && left.len() < right.len() => {\n+            // e.g: target is std::fmt and we can have\n+            // use std::fmt::Debug;\n+            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n+            ImportAction::add_nested_import(\n+                prev_len + common,\n+                path,\n+                Some(segments_to_split[0].clone()),\n+                true,\n+            )\n+        }\n+        common if common < left.len() && common < right.len() => {\n+            // e.g: target is std::fmt::nested::Debug\n+            // use std::fmt::Display\n+            let segments_to_split = current_path_segments.split_at(prev_len + common).1;\n+            ImportAction::add_nested_import(\n+                prev_len + common,\n+                path,\n+                Some(segments_to_split[0].clone()),\n+                false,\n+            )\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    // If we are inside a UseTreeList adding a use statement become adding to the existing\n+    // tree list.\n+    action = match (current_parent_use_tree_list, action.clone()) {\n+        (Some(use_tree_list), ImportAction::AddNewUse { .. }) => {\n+            ImportAction::add_in_tree_list(prev_len, use_tree_list, false)\n+        }\n+        (_, _) => action,\n+    };\n+\n+    // We remove the segments added\n+    current_path_segments.truncate(prev_len);\n+    action\n+}\n+\n+fn best_action_for_target(\n+    container: SyntaxNode,\n+    anchor: SyntaxNode,\n+    target: &[SmolStr],\n+) -> ImportAction {\n+    let mut storage = Vec::with_capacity(16); // this should be the only allocation\n+    let best_action = container\n+        .children()\n+        .filter_map(ast::UseItem::cast)\n+        .filter_map(|it| it.use_tree())\n+        .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n+        .fold(None, |best, a| match best {\n+            Some(best) => Some(ImportAction::better(best, a)),\n+            None => Some(a),\n+        });\n+\n+    match best_action {\n+        Some(action) => action,\n+        None => {\n+            // We have no action and no UseItem was found in container so we find\n+            // another item and we use it as anchor.\n+            // If there are no items above, we choose the target path itself as anchor.\n+            // todo: we should include even whitespace blocks as anchor candidates\n+            let anchor = container\n+                .children()\n+                .find(|n| n.text_range().start() < anchor.text_range().start())\n+                .or_else(|| Some(anchor));\n+\n+            let add_after_anchor = anchor\n+                .clone()\n+                .and_then(ast::Attr::cast)\n+                .map(|attr| attr.kind() == ast::AttrKind::Inner)\n+                .unwrap_or(false);\n+            ImportAction::add_new_use(anchor, add_after_anchor)\n+        }\n+    }\n+}\n+\n+fn make_assist(action: &ImportAction, target: &[SmolStr], edit: &mut TextEditBuilder) {\n+    match action {\n+        ImportAction::AddNewUse { anchor, add_after_anchor } => {\n+            make_assist_add_new_use(anchor, *add_after_anchor, target, edit)\n+        }\n+        ImportAction::AddInTreeList { common_segments, tree_list, add_self } => {\n+            // We know that the fist n segments already exists in the use statement we want\n+            // to modify, so we want to add only the last target.len() - n segments.\n+            let segments_to_add = target.split_at(*common_segments).1;\n+            make_assist_add_in_tree_list(tree_list, segments_to_add, *add_self, edit)\n+        }\n+        ImportAction::AddNestedImport {\n+            common_segments,\n+            path_to_split,\n+            first_segment_to_split,\n+            add_self,\n+        } => {\n+            let segments_to_add = target.split_at(*common_segments).1;\n+            make_assist_add_nested_import(\n+                path_to_split,\n+                first_segment_to_split,\n+                segments_to_add,\n+                *add_self,\n+                edit,\n+            )\n+        }\n+        _ => {}\n+    }\n+}\n+\n+fn make_assist_add_new_use(\n+    anchor: &Option<SyntaxNode>,\n+    after: bool,\n+    target: &[SmolStr],\n+    edit: &mut TextEditBuilder,\n+) {\n+    if let Some(anchor) = anchor {\n+        let indent = ra_fmt::leading_indent(anchor);\n+        let mut buf = String::new();\n+        if after {\n+            buf.push_str(\"\\n\");\n+            if let Some(spaces) = &indent {\n+                buf.push_str(spaces);\n+            }\n+        }\n+        buf.push_str(\"use \");\n+        fmt_segments_raw(target, &mut buf);\n+        buf.push_str(\";\");\n+        if !after {\n+            buf.push_str(\"\\n\\n\");\n+            if let Some(spaces) = &indent {\n+                buf.push_str(&spaces);\n+            }\n+        }\n+        let position = if after { anchor.text_range().end() } else { anchor.text_range().start() };\n+        edit.insert(position, buf);\n+    }\n+}\n+\n+fn make_assist_add_in_tree_list(\n+    tree_list: &ast::UseTreeList,\n+    target: &[SmolStr],\n+    add_self: bool,\n+    edit: &mut TextEditBuilder,\n+) {\n+    let last = tree_list.use_trees().last();\n+    if let Some(last) = last {\n+        let mut buf = String::new();\n+        let comma = last.syntax().siblings(Direction::Next).find(|n| n.kind() == T![,]);\n+        let offset = if let Some(comma) = comma {\n+            comma.text_range().end()\n+        } else {\n+            buf.push_str(\",\");\n+            last.syntax().text_range().end()\n+        };\n+        if add_self {\n+            buf.push_str(\" self\")\n+        } else {\n+            buf.push_str(\" \");\n+        }\n+        fmt_segments_raw(target, &mut buf);\n+        edit.insert(offset, buf);\n+    } else {\n+    }\n+}\n+\n+fn make_assist_add_nested_import(\n+    path: &ast::Path,\n+    first_segment_to_split: &Option<ast::PathSegment>,\n+    target: &[SmolStr],\n+    add_self: bool,\n+    edit: &mut TextEditBuilder,\n+) {\n+    let use_tree = path.syntax().ancestors().find_map(ast::UseTree::cast);\n+    if let Some(use_tree) = use_tree {\n+        let (start, add_colon_colon) = if let Some(first_segment_to_split) = first_segment_to_split\n+        {\n+            (first_segment_to_split.syntax().text_range().start(), false)\n+        } else {\n+            (use_tree.syntax().text_range().end(), true)\n+        };\n+        let end = use_tree.syntax().text_range().end();\n+\n+        let mut buf = String::new();\n+        if add_colon_colon {\n+            buf.push_str(\"::\");\n+        }\n+        buf.push_str(\"{\");\n+        if add_self {\n+            buf.push_str(\"self, \");\n+        }\n+        fmt_segments_raw(target, &mut buf);\n+        if !target.is_empty() {\n+            buf.push_str(\", \");\n+        }\n+        edit.insert(start, buf);\n+        edit.insert(end, \"}\".to_string());\n+    }\n+}"}]}