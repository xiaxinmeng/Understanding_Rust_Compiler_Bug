{"sha": "cccfa8acc450631fe9520abbe40360927ce1961d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjY2ZhOGFjYzQ1MDYzMWZlOTUyMGFiYmU0MDM2MDkyN2NlMTk2MWQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T00:45:54Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-30T17:19:25Z"}, "message": "Add test cases for select", "tree": {"sha": "a3da9ad6278aa30a7e22a2f789916e7c5eac9d1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3da9ad6278aa30a7e22a2f789916e7c5eac9d1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cccfa8acc450631fe9520abbe40360927ce1961d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cccfa8acc450631fe9520abbe40360927ce1961d", "html_url": "https://github.com/rust-lang/rust/commit/cccfa8acc450631fe9520abbe40360927ce1961d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cccfa8acc450631fe9520abbe40360927ce1961d/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f34fadd126ce9ffcd5a79c3ad5d06ad58c6fd8a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f34fadd126ce9ffcd5a79c3ad5d06ad58c6fd8a8", "html_url": "https://github.com/rust-lang/rust/commit/f34fadd126ce9ffcd5a79c3ad5d06ad58c6fd8a8"}], "stats": {"total": 254, "additions": 254, "deletions": 0}, "files": [{"sha": "c2e471a338625d294ee810bbcaec84a4af5425eb", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/cccfa8acc450631fe9520abbe40360927ce1961d/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cccfa8acc450631fe9520abbe40360927ce1961d/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=cccfa8acc450631fe9520abbe40360927ce1961d", "patch": "@@ -100,3 +100,231 @@ pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n }\n \n */\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use option::*;\n+    use rt::comm::*;\n+    use rt::test::*;\n+    use vec::*;\n+    use comm::GenericChan;\n+    use task;\n+    use cell::Cell;\n+\n+    #[test] #[ignore(cfg(windows))] #[should_fail]\n+    fn select_doesnt_get_trolled() {\n+        select::<PortOne<()>>([]);\n+    }\n+\n+    /* non-blocking select tests */\n+\n+    #[cfg(test)]\n+    fn select_helper(num_ports: uint, send_on_chans: &[uint]) {\n+        // Unfortunately this does not actually test the block_on early-break\n+        // codepath in select -- racing between the sender and the receiver in\n+        // separate tasks is necessary to get around the optimistic check.\n+        let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n+        let mut dead_chans = ~[];\n+        let mut ports = ports;\n+        for chans.consume_iter().enumerate().advance |(i, chan)| {\n+            if send_on_chans.contains(&i) {\n+                chan.send(());\n+            } else {\n+                dead_chans.push(chan);\n+            }\n+        }\n+        let ready_index = select(ports);\n+        assert!(send_on_chans.contains(&ready_index));\n+        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n+        let _ = dead_chans;\n+\n+        // Same thing with streams instead.\n+        // FIXME(#7971): This should be in a macro but borrowck isn't smart enough.\n+        let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n+        let mut dead_chans = ~[];\n+        let mut ports = ports;\n+        for chans.consume_iter().enumerate().advance |(i, chan)| {\n+            if send_on_chans.contains(&i) {\n+                chan.send(());\n+            } else {\n+                dead_chans.push(chan);\n+            }\n+        }\n+        let ready_index = select(ports);\n+        assert!(send_on_chans.contains(&ready_index));\n+        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n+        let _ = dead_chans;\n+    }\n+\n+    #[test]\n+    fn select_one() {\n+        do run_in_newsched_task { select_helper(1, [0]) }\n+    }\n+\n+    #[test]\n+    fn select_two() {\n+        // NB. I would like to have a test that tests the first one that is\n+        // ready is the one that's returned, but that can't be reliably tested\n+        // with the randomized behaviour of optimistic_check.\n+        do run_in_newsched_task { select_helper(2, [1]) }\n+        do run_in_newsched_task { select_helper(2, [0]) }\n+        do run_in_newsched_task { select_helper(2, [1,0]) }\n+    }\n+\n+    #[test]\n+    fn select_a_lot() {\n+        do run_in_newsched_task { select_helper(12, [7,8,9]) }\n+    }\n+\n+    #[test]\n+    fn select_stream() {\n+        use util;\n+        use comm::GenericChan;\n+\n+        // Sends 10 buffered packets, and uses select to retrieve them all.\n+        // Puts the port in a different spot in the vector each time.\n+        do run_in_newsched_task {\n+            let (ports, _) = unzip(from_fn(10, |_| stream()));\n+            let (port, chan) = stream();\n+            for 10.times { chan.send(31337); }\n+            let mut ports = ports;\n+            let mut port = Some(port);\n+            let order = [5u,0,4,3,2,6,9,8,7,1];\n+            for order.iter().advance |&index| {\n+                // put the port in the vector at any index\n+                util::swap(port.get_mut_ref(), &mut ports[index]);\n+                assert!(select(ports) == index);\n+                // get it back out\n+                util::swap(port.get_mut_ref(), &mut ports[index]);\n+                // NB. Not recv(), because optimistic_check randomly fails.\n+                let (data, new_port) = port.take_unwrap().recv_ready().unwrap();\n+                assert!(data == 31337);\n+                port = Some(new_port);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn select_unkillable() {\n+        do run_in_newsched_task {\n+            unsafe { do task::unkillable { select_helper(2, [1]) } }\n+        }\n+    }\n+\n+    /* blocking select tests */\n+\n+    #[test]\n+    fn select_blocking() {\n+        select_blocking_helper(true);\n+        select_blocking_helper(false);\n+\n+        fn select_blocking_helper(killable: bool) {\n+            do run_in_newsched_task {\n+                let (p1,_c) = oneshot();\n+                let (p2,c2) = oneshot();\n+                let mut ports = [p1,p2];\n+\n+                let (p3,c3) = oneshot();\n+                let (p4,c4) = oneshot();\n+\n+                let x = Cell::new((c2, p3, c4));\n+                do task::spawn {\n+                    let (c2, p3, c4) = x.take();\n+                    p3.recv();   // handshake parent\n+                    c4.send(()); // normal receive\n+                    task::yield();\n+                    c2.send(()); // select receive\n+                }\n+\n+                // Try to block before child sends on c2.\n+                c3.send(());\n+                p4.recv();\n+                if killable {\n+                    assert!(select(ports) == 1);\n+                } else {\n+                    unsafe { do task::unkillable { assert!(select(ports) == 1); } }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn select_racing_senders() {\n+        static NUM_CHANS: uint = 10;\n+\n+        select_racing_senders_helper(true,  ~[0,1,2,3,4,5,6,7,8,9]);\n+        select_racing_senders_helper(false, ~[0,1,2,3,4,5,6,7,8,9]);\n+        select_racing_senders_helper(true,  ~[0,1,2]);\n+        select_racing_senders_helper(false, ~[0,1,2]);\n+        select_racing_senders_helper(true,  ~[3,4,5,6]);\n+        select_racing_senders_helper(false, ~[3,4,5,6]);\n+        select_racing_senders_helper(true,  ~[7,8,9]);\n+        select_racing_senders_helper(false, ~[7,8,9]);\n+\n+        fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n+            use uint;\n+            use rt::test::spawntask_random;\n+\n+            do run_in_newsched_task {\n+                // A bit of stress, since ordinarily this is just smoke and mirrors.\n+                for 4.times {\n+                    let send_on_chans = send_on_chans.clone();\n+                    do task::spawn {\n+                        let mut ports = ~[];\n+                        for uint::range(0, NUM_CHANS) |i| {\n+                            let (p,c) = oneshot();\n+                            ports.push(p);\n+                            if send_on_chans.contains(&i) {\n+                                let c = Cell::new(c);\n+                                do spawntask_random {\n+                                    task::yield();\n+                                    c.take().send(());\n+                                }\n+                            }\n+                        }\n+                        // nondeterministic result, but should succeed\n+                        if killable {\n+                            select(ports);\n+                        } else {\n+                            unsafe { do task::unkillable { select(ports); } }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test] #[ignore(cfg(windows))]\n+    fn select_killed() {\n+        do run_in_newsched_task {\n+            let (success_p, success_c) = oneshot::<bool>();\n+            let success_c = Cell::new(success_c);\n+            do task::try {\n+                unsafe {\n+                    let success_c = Cell::new(success_c.take());\n+                    do task::unkillable {\n+                        let (p,c) = oneshot();\n+                        let c = Cell::new(c);\n+                        do task::spawn {\n+                            let (dead_ps, dead_cs) = unzip(from_fn(5, |_| oneshot::<()>()));\n+                            let mut ports = dead_ps;\n+                            select(ports); // should get killed; nothing should leak\n+                            c.take().send(()); // must not happen\n+                            // Make sure dead_cs doesn't get closed until after select.\n+                            let _ = dead_cs;\n+                        }\n+                        do task::spawn {\n+                            fail!(); // should kill sibling awake\n+                        }\n+\n+                        // wait for killed selector to close (NOT send on) its c.\n+                        // hope to send 'true'.\n+                        success_c.take().send(p.try_recv().is_none());\n+                    }\n+                }\n+            };\n+            assert!(success_p.recv());\n+        }\n+    }\n+}"}, {"sha": "16bbd33136cc532be64dc6e3b994e3270064cd91", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cccfa8acc450631fe9520abbe40360927ce1961d/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cccfa8acc450631fe9520abbe40360927ce1961d/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=cccfa8acc450631fe9520abbe40360927ce1961d", "patch": "@@ -444,6 +444,32 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn arclike_newN() {\n+        // Tests that the many-refcounts-at-once constructors don't leak.\n+        let _ = UnsafeAtomicRcBox::new2(~~\"hello\");\n+        let x = UnsafeAtomicRcBox::newN(~~\"hello\", 0);\n+        assert_eq!(x.len(), 0)\n+        let x = UnsafeAtomicRcBox::newN(~~\"hello\", 1);\n+        assert_eq!(x.len(), 1)\n+        let x = UnsafeAtomicRcBox::newN(~~\"hello\", 10);\n+        assert_eq!(x.len(), 10)\n+    }\n+\n+    #[test]\n+    fn arclike_cloneN() {\n+        // Tests that the many-refcounts-at-once special-clone doesn't leak.\n+        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = x.cloneN(0);\n+        assert_eq!(x.len(), 0);\n+        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = x.cloneN(1);\n+        assert_eq!(x.len(), 1);\n+        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = x.cloneN(10);\n+        assert_eq!(x.len(), 10);\n+    }\n+\n     #[test]\n     fn arclike_unwrap_basic() {\n         unsafe {"}]}