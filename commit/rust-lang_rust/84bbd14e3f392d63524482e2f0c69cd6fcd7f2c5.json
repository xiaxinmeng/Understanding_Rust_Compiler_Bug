{"sha": "84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YmJkMTRlM2YzOTJkNjM1MjQ0ODJlMmYwYzY5Y2Q2ZmNkN2YyYzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-14T03:02:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-14T03:02:58Z"}, "message": "Auto merge of #43972 - TobiasSchaffner:std_clean, r=alexcrichton\n\n Add the libstd-modifications needed for the L4Re target\n\nThis commit adds the needed modifications to compile the std crate for the L4 Runtime environment (L4Re).\n\nA target for the L4Re was introduced in commit: c151220a84e40b65e45308cc0f3bbea4466d3acf\n\nIn many aspects implementations for linux also apply for the L4Re microkernel.\n\nSome uncommon characteristics had to be resolved:\n * L4Re has no network funktionality\n * L4Re has a maximum stacksize of 1Mb for threads\n * L4Re has no uid or gid\n\nCo-authored-by: Sebastian Humenda <sebastian.humenda@tu-dresden.de>", "tree": {"sha": "245c38d385167096343d83f9884d37275c349e27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/245c38d385167096343d83f9884d37275c349e27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "html_url": "https://github.com/rust-lang/rust/commit/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ca653b170c235ad01a83d89fcb18b1f8b6a3b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ca653b170c235ad01a83d89fcb18b1f8b6a3b0", "html_url": "https://github.com/rust-lang/rust/commit/d1ca653b170c235ad01a83d89fcb18b1f8b6a3b0"}, {"sha": "b2b50635172254777d16d0fc6112e6d5b68b63f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b50635172254777d16d0fc6112e6d5b68b63f2", "html_url": "https://github.com/rust-lang/rust/commit/b2b50635172254777d16d0fc6112e6d5b68b63f2"}], "stats": {"total": 585, "additions": 538, "deletions": 47}, "files": [{"sha": "95848f9622deccc9cbadcd5d3a4faef01a90ead4", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -1 +1 @@\n-Subproject commit 04a5e75c99dc92afab490c38fcbbeac9b4bc8104\n+Subproject commit 95848f9622deccc9cbadcd5d3a4faef01a90ead4"}, {"sha": "b460bd90f173558f10ef3080b48c995529dc7cb5", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -27,7 +27,7 @@ pub use sys::unix_ext as unix;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys::windows_ext as windows;\n \n-#[cfg(any(dox, target_os = \"linux\"))]\n+#[cfg(any(dox, target_os = \"linux\", target_os = \"l4re\"))]\n #[doc(cfg(target_os = \"linux\"))]\n pub mod linux;\n "}, {"sha": "95439640f7cc5c5000fbf98091a29cdf84b733a7", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -21,6 +21,7 @@ use fmt;\n                                        target_arch = \"s390x\")),\n           all(target_os = \"android\", any(target_arch = \"aarch64\",\n                                          target_arch = \"arm\")),\n+          all(target_os = \"l4re\", target_arch = \"x86_64\"),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n #[cfg(not(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n@@ -30,6 +31,7 @@ use fmt;\n                                            target_arch = \"s390x\")),\n               all(target_os = \"android\", any(target_arch = \"aarch64\",\n                                              target_arch = \"arm\")),\n+              all(target_os = \"l4re\", target_arch = \"x86_64\"),\n               all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;"}, {"sha": "c4aad8d86f8b1f5e4b6fba452c4eb64e9476cf6d", "filename": "src/libstd/sys/redox/thread.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -16,6 +16,8 @@ use sys_common::thread::start_thread;\n use sys::{cvt, syscall};\n use time::Duration;\n \n+pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n+\n pub struct Thread {\n     id: usize,\n }"}, {"sha": "72169773df596ee977e384d37513e7515ecbe17b", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -65,6 +65,7 @@ impl DoubleEndedIterator for Args {\n           target_os = \"solaris\",\n           target_os = \"emscripten\",\n           target_os = \"haiku\",\n+          target_os = \"l4re\",\n           target_os = \"fuchsia\"))]\n mod imp {\n     use os::unix::prelude::*;"}, {"sha": "89a44b976578363f1d439d87cf0c0420c4dbd0d4", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -38,10 +38,16 @@ impl Condvar {\n         Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n     }\n \n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"l4re\",\n+              target_os = \"android\"))]\n     pub unsafe fn init(&mut self) {}\n \n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\")))]\n+    #[cfg(not(any(target_os = \"macos\",\n+                  target_os = \"ios\",\n+                  target_os = \"l4re\",\n+                  target_os = \"android\")))]\n     pub unsafe fn init(&mut self) {\n         use mem;\n         let mut attr: libc::pthread_condattr_t = mem::uninitialized();"}, {"sha": "3d9a06bedd57cc74898803dc17764547c7e5ad6d", "filename": "src/libstd/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -182,3 +182,14 @@ pub mod os {\n     pub const EXE_SUFFIX: &'static str = \"\";\n     pub const EXE_EXTENSION: &'static str = \"\";\n }\n+\n+#[cfg(target_os = \"l4re\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"l4re\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}"}, {"sha": "5dafc3251e7551e10f6c68573b479a16cd2efbf6", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -144,6 +144,7 @@ impl FileDesc {\n                   target_os = \"solaris\",\n                   target_os = \"emscripten\",\n                   target_os = \"fuchsia\",\n+                  target_os = \"l4re\",\n                   target_os = \"haiku\")))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n@@ -155,6 +156,7 @@ impl FileDesc {\n               target_os = \"solaris\",\n               target_os = \"emscripten\",\n               target_os = \"fuchsia\",\n+              target_os = \"l4re\",\n               target_os = \"haiku\"))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {"}, {"sha": "13112fc1fa5904e6d6b4f8bfcda702893b2c056b", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -23,19 +23,21 @@ use sys::time::SystemTime;\n use sys::{cvt, cvt_r};\n use sys_common::{AsInner, FromInner};\n \n-#[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n+#[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"l4re\"))]\n use libc::{stat64, fstat64, lstat64, off64_t, ftruncate64, lseek64, dirent64, readdir64_r, open64};\n #[cfg(target_os = \"android\")]\n use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, lseek64,\n            dirent as dirent64, open as open64};\n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"emscripten\",\n+              target_os = \"l4re\",\n               target_os = \"android\")))]\n use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off_t as off64_t,\n            ftruncate as ftruncate64, lseek as lseek64, dirent as dirent64, open as open64};\n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"emscripten\",\n               target_os = \"solaris\",\n+              target_os = \"l4re\",\n               target_os = \"fuchsia\")))]\n use libc::{readdir_r as readdir64_r};\n \n@@ -316,6 +318,7 @@ impl DirEntry {\n               target_os = \"android\",\n               target_os = \"solaris\",\n               target_os = \"haiku\",\n+              target_os = \"l4re\",\n               target_os = \"fuchsia\"))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -346,6 +349,7 @@ impl DirEntry {\n     #[cfg(any(target_os = \"android\",\n               target_os = \"linux\",\n               target_os = \"emscripten\",\n+              target_os = \"l4re\",\n               target_os = \"haiku\"))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe {"}, {"sha": "21218489679393a92a655bf0012caa5ad242f962", "filename": "src/libstd/sys/unix/l4re.rs", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fl4re.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -0,0 +1,441 @@\n+// Copyright 2016-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! unimpl {\n+    () => (return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));)\n+}\n+\n+pub mod net {\n+    #![allow(warnings)]\n+    use fmt;\n+    use io;\n+    use libc;\n+    use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+    use sys_common::{AsInner, FromInner, IntoInner};\n+    use sys::fd::FileDesc;\n+    use time::Duration;\n+\n+\n+    pub extern crate libc as netc;\n+\n+    pub struct Socket(FileDesc);\n+    impl Socket {\n+        pub fn new(_: &SocketAddr, _: libc::c_int) -> io::Result<Socket> {\n+            unimpl!();\n+        }\n+\n+        pub fn new_raw(_: libc::c_int, _: libc::c_int) -> io::Result<Socket> {\n+            unimpl!();\n+        }\n+\n+        pub fn new_pair(_: libc::c_int, _: libc::c_int) -> io::Result<(Socket, Socket)> {\n+            unimpl!();\n+        }\n+\n+        pub fn connect_timeout(&self, _: &SocketAddr, _: Duration) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn accept(&self, _: *mut libc::sockaddr, _: *mut libc::socklen_t)\n+                  -> io::Result<Socket> {\n+            unimpl!();\n+        }\n+\n+        pub fn duplicate(&self) -> io::Result<Socket> {\n+            unimpl!();\n+        }\n+\n+        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_timeout(&self, _: Option<Duration>, _: libc::c_int) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn timeout(&self, _: libc::c_int) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn nodelay(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl AsInner<libc::c_int> for Socket {\n+        fn as_inner(&self) -> &libc::c_int { self.0.as_inner() }\n+    }\n+\n+    impl FromInner<libc::c_int> for Socket {\n+        fn from_inner(fd: libc::c_int) -> Socket { Socket(FileDesc::new(fd)) }\n+    }\n+\n+    impl IntoInner<libc::c_int> for Socket {\n+        fn into_inner(self) -> libc::c_int { self.0.into_raw() }\n+    }\n+\n+    pub struct TcpStream {\n+        inner: Socket,\n+    }\n+\n+    impl TcpStream {\n+        pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+            unimpl!();\n+        }\n+\n+        pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket(&self) -> &Socket { &self.inner }\n+\n+        pub fn into_socket(self) -> Socket { self.inner }\n+\n+        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn duplicate(&self) -> io::Result<TcpStream> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn nodelay(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn ttl(&self) -> io::Result<u32> {\n+            unimpl!();\n+        }\n+\n+        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl FromInner<Socket> for TcpStream {\n+        fn from_inner(socket: Socket) -> TcpStream {\n+            TcpStream { inner: socket }\n+        }\n+    }\n+\n+    impl fmt::Debug for TcpStream {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f, \"No networking support available on L4Re\")\n+        }\n+    }\n+\n+    pub struct TcpListener {\n+        inner: Socket,\n+    }\n+\n+    impl TcpListener {\n+        pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket(&self) -> &Socket { &self.inner }\n+\n+        pub fn into_socket(self) -> Socket { self.inner }\n+\n+        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn duplicate(&self) -> io::Result<TcpListener> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn ttl(&self) -> io::Result<u32> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn only_v6(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl FromInner<Socket> for TcpListener {\n+        fn from_inner(socket: Socket) -> TcpListener {\n+            TcpListener { inner: socket }\n+        }\n+    }\n+\n+    impl fmt::Debug for TcpListener {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f, \"No networking support available on L4Re.\")\n+        }\n+    }\n+\n+    pub struct UdpSocket {\n+        inner: Socket,\n+    }\n+\n+    impl UdpSocket {\n+        pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+            unimpl!();\n+        }\n+\n+        pub fn socket(&self) -> &Socket { &self.inner }\n+\n+        pub fn into_socket(self) -> Socket { self.inner }\n+\n+        pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+            unimpl!();\n+        }\n+\n+        pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+            unimpl!();\n+        }\n+\n+        pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn broadcast(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+            unimpl!();\n+        }\n+\n+        pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                             -> io::Result<()> {\n+                                 unimpl!();\n+        }\n+\n+        pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                             -> io::Result<()> {\n+                                 unimpl!();\n+        }\n+\n+        pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                              -> io::Result<()> {\n+                                  unimpl!();\n+        }\n+\n+        pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                              -> io::Result<()> {\n+                                  unimpl!();\n+        }\n+\n+        pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn ttl(&self) -> io::Result<u32> {\n+            unimpl!();\n+        }\n+\n+        pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+            unimpl!();\n+        }\n+\n+        pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+            unimpl!();\n+        }\n+\n+        pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+            unimpl!();\n+        }\n+\n+        pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+            unimpl!();\n+        }\n+    }\n+\n+    impl FromInner<Socket> for UdpSocket {\n+        fn from_inner(socket: Socket) -> UdpSocket {\n+            UdpSocket { inner: socket }\n+        }\n+    }\n+\n+    impl fmt::Debug for UdpSocket {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            write!(f, \"No networking support on L4Re available.\")\n+        }\n+    }\n+\n+    pub struct LookupHost {\n+        original: *mut libc::addrinfo,\n+        cur: *mut libc::addrinfo,\n+    }\n+\n+    impl Iterator for LookupHost {\n+        type Item = SocketAddr;\n+        fn next(&mut self) -> Option<SocketAddr> {\n+            None\n+        }\n+    }\n+\n+    unsafe impl Sync for LookupHost {}\n+    unsafe impl Send for LookupHost {}\n+\n+    pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n+        unimpl!();\n+    }\n+}\n+"}, {"sha": "1b3f1000b77bbdf681b31946e1cf482678305e21", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -28,6 +28,7 @@ use libc;\n #[cfg(all(not(dox), target_os = \"solaris\"))]   pub use os::solaris as platform;\n #[cfg(all(not(dox), target_os = \"emscripten\"))] pub use os::emscripten as platform;\n #[cfg(all(not(dox), target_os = \"fuchsia\"))]   pub use os::fuchsia as platform;\n+#[cfg(all(not(dox), target_os = \"l4re\"))]      pub use os::linux as platform;\n \n #[macro_use]\n pub mod weak;\n@@ -44,7 +45,12 @@ pub mod fd;\n pub mod fs;\n pub mod memchr;\n pub mod mutex;\n+#[cfg(not(target_os = \"l4re\"))]\n pub mod net;\n+#[cfg(target_os = \"l4re\")]\n+mod l4re;\n+#[cfg(target_os = \"l4re\")]\n+pub use self::l4re::net;\n pub mod os;\n pub mod os_str;\n pub mod path;"}, {"sha": "5ef98d247105e6e1a36e9f59484bf76f4ac97aff", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -38,7 +38,10 @@ static ENV_LOCK: Mutex = Mutex::new();\n \n extern {\n     #[cfg(not(target_os = \"dragonfly\"))]\n-    #[cfg_attr(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"fuchsia\"),\n+    #[cfg_attr(any(target_os = \"linux\",\n+                   target_os = \"emscripten\",\n+                   target_os = \"fuchsia\",\n+                   target_os = \"l4re\"),\n                link_name = \"__errno_location\")]\n     #[cfg_attr(any(target_os = \"bitrig\",\n                    target_os = \"netbsd\",\n@@ -346,10 +349,10 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     }\n }\n \n-#[cfg(target_os = \"fuchsia\")]\n+#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     use io::ErrorKind;\n-    Err(io::Error::new(ErrorKind::Other, \"Not yet implemented on fuchsia\"))\n+    Err(io::Error::new(ErrorKind::Other, \"Not yet implemented!\"))\n }\n \n pub struct Env {"}, {"sha": "870db8200273eb84e543bbda841519eada1f46b3", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -160,20 +160,22 @@ impl Command {\n             t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n         }\n \n-        if let Some(u) = self.get_gid() {\n-            t!(cvt(libc::setgid(u as gid_t)));\n-        }\n-        if let Some(u) = self.get_uid() {\n-            // When dropping privileges from root, the `setgroups` call\n-            // will remove any extraneous groups. If we don't call this,\n-            // then even though our uid has dropped, we may still have\n-            // groups that enable us to do super-user things. This will\n-            // fail if we aren't root, so don't bother checking the\n-            // return value, this is just done as an optimistic\n-            // privilege dropping function.\n-            let _ = libc::setgroups(0, ptr::null());\n+        if cfg!(not(any(target_os = \"l4re\"))) {\n+            if let Some(u) = self.get_gid() {\n+                t!(cvt(libc::setgid(u as gid_t)));\n+            }\n+            if let Some(u) = self.get_uid() {\n+                // When dropping privileges from root, the `setgroups` call\n+                // will remove any extraneous groups. If we don't call this,\n+                // then even though our uid has dropped, we may still have\n+                // groups that enable us to do super-user things. This will\n+                // fail if we aren't root, so don't bother checking the\n+                // return value, this is just done as an optimistic\n+                // privilege dropping function.\n+                let _ = libc::setgroups(0, ptr::null());\n \n-            t!(cvt(libc::setuid(u as uid_t)));\n+                t!(cvt(libc::setuid(u as uid_t)));\n+            }\n         }\n         if let Some(ref cwd) = *self.get_cwd() {\n             t!(cvt(libc::chdir(cwd.as_ptr())));"}, {"sha": "6c4a332429646be75c156884d409d8c090c7bdb3", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -20,6 +20,11 @@ use time::Duration;\n \n use sys_common::thread::*;\n \n+#[cfg(not(target_os = \"l4re\"))]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n+#[cfg(target_os = \"l4re\")]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n+\n pub struct Thread {\n     id: libc::pthread_t,\n }\n@@ -52,6 +57,7 @@ impl Thread {\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n+\n         match pthread_attr_setstacksize(&mut attr,\n                                         stack_size) {\n             0 => {}\n@@ -131,6 +137,7 @@ impl Thread {\n     #[cfg(any(target_env = \"newlib\",\n               target_os = \"solaris\",\n               target_os = \"haiku\",\n+              target_os = \"l4re\",\n               target_os = \"emscripten\"))]\n     pub fn set_name(_name: &CStr) {\n         // Newlib, Illumos, Haiku, and Emscripten have no way to set a thread name.\n@@ -226,7 +233,7 @@ pub mod guard {\n     }\n \n     #[cfg(any(target_os = \"android\", target_os = \"freebsd\",\n-              target_os = \"linux\", target_os = \"netbsd\"))]\n+              target_os = \"linux\", target_os = \"netbsd\", target_os = \"l4re\"))]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = ::mem::zeroed();\n@@ -328,7 +335,7 @@ pub mod guard {\n     }\n \n     #[cfg(any(target_os = \"android\", target_os = \"freebsd\",\n-              target_os = \"linux\", target_os = \"netbsd\"))]\n+              target_os = \"linux\", target_os = \"netbsd\", target_os = \"l4re\"))]\n     pub unsafe fn current() -> Option<usize> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = ::mem::zeroed();"}, {"sha": "6aea9d1fb560f118379fe7d0c4c8dbd7c26ece2a", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -19,6 +19,8 @@ use sys::handle::Handle;\n use sys_common::thread::*;\n use time::Duration;\n \n+pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n+\n pub struct Thread {\n     handle: Handle\n }"}, {"sha": "d7654ce9300b377d124000a0c1de02dd92673a64", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -44,10 +44,10 @@ pub mod thread_local;\n pub mod util;\n pub mod wtf8;\n \n-#[cfg(target_os = \"redox\")]\n+#[cfg(any(target_os = \"redox\", target_os = \"l4re\"))]\n pub use sys::net;\n \n-#[cfg(not(target_os = \"redox\"))]\n+#[cfg(not(any(target_os = \"redox\", target_os = \"l4re\")))]\n pub mod net;\n \n #[cfg(feature = \"backtrace\")]"}, {"sha": "19dc841b9b5024961abb1eea38c84d22d1fc6693", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -24,22 +24,22 @@ use time::Duration;\n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\",\n           target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"solaris\", target_os = \"haiku\"))]\n+          target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\"))]\n use sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n #[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"ios\", target_os = \"macos\",\n               target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"solaris\", target_os = \"haiku\")))]\n+              target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\")))]\n use sys::net::netc::IPV6_ADD_MEMBERSHIP;\n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\",\n           target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"solaris\", target_os = \"haiku\"))]\n+          target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\"))]\n use sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n #[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"ios\", target_os = \"macos\",\n               target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"solaris\", target_os = \"haiku\")))]\n+              target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\")))]\n use sys::net::netc::IPV6_DROP_MEMBERSHIP;\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\","}, {"sha": "87fb34a9dec06459f95806377a451db8bbc27648", "filename": "src/libstd/sys_common/thread.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys_common%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys_common%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use env;\n use alloc::boxed::FnBox;\n use libc;\n+use sync::atomic::{self, Ordering};\n use sys::stack_overflow;\n+use sys::thread as imp;\n \n pub unsafe fn start_thread(main: *mut libc::c_void) {\n     // Next, set up our stack overflow handler which may get triggered if we run\n@@ -20,3 +23,18 @@ pub unsafe fn start_thread(main: *mut libc::c_void) {\n     // Finally, let's run some code.\n     Box::from_raw(main as *mut Box<FnBox()>)()\n }\n+\n+pub fn min_stack() -> usize {\n+    static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n+    match MIN.load(Ordering::SeqCst) {\n+        0 => {}\n+        n => return n - 1,\n+    }\n+    let amt = env::var(\"RUST_MIN_STACK\").ok().and_then(|s| s.parse().ok());\n+    let amt = amt.unwrap_or(imp::DEFAULT_MIN_STACK_SIZE);\n+\n+    // 0 is our sentinel value, so ensure that we'll never see 0 after\n+    // initialization has run\n+    MIN.store(amt + 1, Ordering::SeqCst);\n+    amt\n+}"}, {"sha": "a391c7cc6ef0c959c2e25eaf0bddf175cbb59cec", "filename": "src/libstd/sys_common/util.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys_common%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fsys_common%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Futil.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -8,27 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use env;\n use fmt;\n use io::prelude::*;\n-use sync::atomic::{self, Ordering};\n use sys::stdio::Stderr;\n use thread;\n \n-pub fn min_stack() -> usize {\n-    static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n-    match MIN.load(Ordering::SeqCst) {\n-        0 => {}\n-        n => return n - 1,\n-    }\n-    let amt = env::var(\"RUST_MIN_STACK\").ok().and_then(|s| s.parse().ok());\n-    let amt = amt.unwrap_or(2 * 1024 * 1024);\n-    // 0 is our sentinel value, so ensure that we'll never see 0 after\n-    // initialization has run\n-    MIN.store(amt + 1, Ordering::SeqCst);\n-    amt\n-}\n-\n pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }"}, {"sha": "ca01eaefcaef4c8ac7ebb4a7b453d3e2f4390429", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=84bbd14e3f392d63524482e2f0c69cd6fcd7f2c5", "patch": "@@ -174,7 +174,7 @@ use sync::{Mutex, Condvar, Arc};\n use sys::thread as imp;\n use sys_common::mutex;\n use sys_common::thread_info;\n-use sys_common::util;\n+use sys_common::thread;\n use sys_common::{AsInner, IntoInner};\n use time::Duration;\n \n@@ -374,7 +374,7 @@ impl Builder {\n     {\n         let Builder { name, stack_size } = self;\n \n-        let stack_size = stack_size.unwrap_or_else(util::min_stack);\n+        let stack_size = stack_size.unwrap_or_else(thread::min_stack);\n \n         let my_thread = Thread::new(name);\n         let their_thread = my_thread.clone();"}]}