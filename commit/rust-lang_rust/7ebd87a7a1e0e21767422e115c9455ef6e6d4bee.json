{"sha": "7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYmQ4N2E3YTFlMGUyMTc2NzQyMmUxMTVjOTQ1NWVmNmU2ZDRiZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-08T20:03:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-08T20:03:23Z"}, "message": "Auto merge of #72021 - Dylan-DPC:rollup-1w61ihk, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #71581 (Unify lints handling in rustdoc)\n - #71710 (Test for zero-sized function items not ICEing)\n - #71970 (Improve bitcode generation for Apple platforms)\n - #71975 (Reduce `TypedArena` creations in `check_match`.)\n - #72003 (allow wasm target for rustc-ap-rustc_span)\n - #72017 (Work around ICEs during cross-compilation for target, ast, & attr)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8bfde566d305049b907775c161502e30584ae41e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bfde566d305049b907775c161502e30584ae41e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "html_url": "https://github.com/rust-lang/rust/commit/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b805396bf46dce972692a6846ce2ad8481c5f85", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b805396bf46dce972692a6846ce2ad8481c5f85", "html_url": "https://github.com/rust-lang/rust/commit/7b805396bf46dce972692a6846ce2ad8481c5f85"}, {"sha": "827ec49c233f6d0182c83a6123cc3fa639220da2", "url": "https://api.github.com/repos/rust-lang/rust/commits/827ec49c233f6d0182c83a6123cc3fa639220da2", "html_url": "https://github.com/rust-lang/rust/commit/827ec49c233f6d0182c83a6123cc3fa639220da2"}], "stats": {"total": 439, "additions": 253, "deletions": 186}, "files": [{"sha": "cb3118cba23dd9a0a1b378f09055dc0275561f98", "filename": "src/librustc_ast/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_ast%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_ast%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Flib.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -19,6 +19,10 @@\n #![feature(unicode_internals)]\n #![recursion_limit = \"256\"]\n \n+// FIXME(#56935): Work around ICEs during cross-compilation.\n+#[allow(unused)]\n+extern crate rustc_macros;\n+\n #[macro_export]\n macro_rules! unwrap_or {\n     ($opt:expr, $default:expr) => {"}, {"sha": "5754bb48d24e1c4785d2b9f92512243277be0f3f", "filename": "src/librustc_attr/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_attr%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_attr%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Flib.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -6,6 +6,10 @@\n \n #![feature(or_patterns)]\n \n+// FIXME(#56935): Work around ICEs during cross-compilation.\n+#[allow(unused)]\n+extern crate rustc_macros;\n+\n mod builtin;\n \n pub use builtin::*;"}, {"sha": "e261ac654467954c11442f22cdf3b25ca380ae71", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -651,10 +651,8 @@ pub(crate) unsafe fn codegen(\n                     \"LLVM_module_codegen_embed_bitcode\",\n                     &module.name[..],\n                 );\n-                embed_bitcode(cgcx, llcx, llmod, Some(data));\n+                embed_bitcode(cgcx, llcx, llmod, &config.bc_cmdline, data);\n             }\n-        } else if config.emit_obj == EmitObj::ObjectCode(BitcodeSection::Marker) {\n-            embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n         if config.emit_ir {\n@@ -777,8 +775,8 @@ pub(crate) unsafe fn codegen(\n /// * __LLVM,__cmdline\n ///\n /// It appears *both* of these sections are necessary to get the linker to\n-/// recognize what's going on. For us though we just always throw in an empty\n-/// cmdline section.\n+/// recognize what's going on. A suitable cmdline value is taken from the\n+/// target spec.\n ///\n /// Furthermore debug/O1 builds don't actually embed bitcode but rather just\n /// embed an empty section.\n@@ -789,9 +787,10 @@ unsafe fn embed_bitcode(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     llcx: &llvm::Context,\n     llmod: &llvm::Module,\n-    bitcode: Option<&[u8]>,\n+    cmdline: &str,\n+    bitcode: &[u8],\n ) {\n-    let llconst = common::bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n+    let llconst = common::bytes_in_context(llcx, bitcode);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n         common::val_ty(llconst),\n@@ -800,14 +799,15 @@ unsafe fn embed_bitcode(\n     llvm::LLVMSetInitializer(llglobal, llconst);\n \n     let is_apple = cgcx.opts.target_triple.triple().contains(\"-ios\")\n-        || cgcx.opts.target_triple.triple().contains(\"-darwin\");\n+        || cgcx.opts.target_triple.triple().contains(\"-darwin\")\n+        || cgcx.opts.target_triple.triple().contains(\"-tvos\");\n \n     let section = if is_apple { \"__LLVM,__bitcode\\0\" } else { \".llvmbc\\0\" };\n     llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n \n-    let llconst = common::bytes_in_context(llcx, &[]);\n+    let llconst = common::bytes_in_context(llcx, cmdline.as_bytes());\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n         common::val_ty(llconst),"}, {"sha": "21eb56f12b97117b8d495b9c079016a3cd564855", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -68,10 +68,6 @@ pub enum BitcodeSection {\n     // No bitcode section.\n     None,\n \n-    // An empty bitcode section (to placate tools such as the iOS linker that\n-    // require this section even if they don't use it).\n-    Marker,\n-\n     // A full, uncompressed bitcode section.\n     Full,\n }\n@@ -101,6 +97,7 @@ pub struct ModuleConfig {\n     pub emit_ir: bool,\n     pub emit_asm: bool,\n     pub emit_obj: EmitObj,\n+    pub bc_cmdline: String,\n \n     // Miscellaneous flags.  These are mostly copied from command-line\n     // options.\n@@ -147,14 +144,8 @@ impl ModuleConfig {\n             || sess.opts.cg.linker_plugin_lto.enabled()\n         {\n             EmitObj::Bitcode\n-        } else if need_crate_bitcode_for_rlib(sess) {\n-            let force_full = need_crate_bitcode_for_rlib(sess);\n-            match sess.opts.optimize {\n-                config::OptLevel::No | config::OptLevel::Less if !force_full => {\n-                    EmitObj::ObjectCode(BitcodeSection::Marker)\n-                }\n-                _ => EmitObj::ObjectCode(BitcodeSection::Full),\n-            }\n+        } else if need_bitcode_in_object(sess) {\n+            EmitObj::ObjectCode(BitcodeSection::Full)\n         } else {\n             EmitObj::ObjectCode(BitcodeSection::None)\n         };\n@@ -211,6 +202,7 @@ impl ModuleConfig {\n                 false\n             ),\n             emit_obj,\n+            bc_cmdline: sess.target.target.options.bitcode_llvm_cmdline.clone(),\n \n             verify_llvm_ir: sess.verify_llvm_ir(),\n             no_prepopulate_passes: sess.opts.cg.no_prepopulate_passes,\n@@ -372,10 +364,12 @@ pub struct CompiledModules {\n     pub allocator_module: Option<CompiledModule>,\n }\n \n-fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n-    sess.opts.cg.embed_bitcode\n+fn need_bitcode_in_object(sess: &Session) -> bool {\n+    let requested_for_rlib = sess.opts.cg.embed_bitcode\n         && sess.crate_types.borrow().contains(&CrateType::Rlib)\n-        && sess.opts.output_types.contains_key(&OutputType::Exe)\n+        && sess.opts.output_types.contains_key(&OutputType::Exe);\n+    let forced_by_target = sess.target.target.options.forces_embed_bitcode;\n+    requested_for_rlib || forced_by_target\n }\n \n fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {"}, {"sha": "cdafb63f1ebc17d20ee528038e0b2b1b00c2172d", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -580,22 +580,11 @@ crate struct MatchCheckCtxt<'a, 'tcx> {\n     /// outside it's module and should not be matchable with an empty match\n     /// statement.\n     crate module: DefId,\n-    param_env: ty::ParamEnv<'tcx>,\n+    crate param_env: ty::ParamEnv<'tcx>,\n     crate pattern_arena: &'a TypedArena<Pat<'tcx>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n-    crate fn create_and_enter<R>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        module: DefId,\n-        f: impl FnOnce(MatchCheckCtxt<'_, 'tcx>) -> R,\n-    ) -> R {\n-        let pattern_arena = TypedArena::default();\n-\n-        f(MatchCheckCtxt { tcx, param_env, module, pattern_arena: &pattern_arena })\n-    }\n-\n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n         if self.tcx.features().exhaustive_patterns {\n             self.tcx.is_ty_uninhabited_from(self.module, ty, self.param_env)"}, {"sha": "0f22288437ca198dec8f5d601e71eb7a5404f55d", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 86, "deletions": 81, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -1,9 +1,9 @@\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack};\n-\n use super::{PatCtxt, PatKind, PatternError};\n \n+use arena::TypedArena;\n use rustc_ast::ast::Mutability;\n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -17,7 +17,6 @@ use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERN\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::{sym, Span};\n-\n use std::slice;\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n@@ -26,8 +25,12 @@ crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n         Some(id) => tcx.hir().body_owned_by(tcx.hir().as_local_hir_id(id)),\n     };\n \n-    let mut visitor =\n-        MatchVisitor { tcx, tables: tcx.body_tables(body_id), param_env: tcx.param_env(def_id) };\n+    let mut visitor = MatchVisitor {\n+        tcx,\n+        tables: tcx.body_tables(body_id),\n+        param_env: tcx.param_env(def_id),\n+        pattern_arena: TypedArena::default(),\n+    };\n     visitor.visit_body(tcx.hir().body(body_id));\n }\n \n@@ -39,6 +42,7 @@ struct MatchVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    pattern_arena: TypedArena<super::Pat<'tcx>>,\n }\n \n impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n@@ -143,9 +147,13 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         (pattern, pattern_ty)\n     }\n \n-    fn check_in_cx(&self, hir_id: HirId, f: impl FnOnce(MatchCheckCtxt<'_, 'tcx>)) {\n-        let module = self.tcx.parent_module(hir_id);\n-        MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module.to_def_id(), |cx| f(cx));\n+    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'_, 'tcx> {\n+        MatchCheckCtxt {\n+            tcx: self.tcx,\n+            param_env: self.param_env,\n+            module: self.tcx.parent_module(hir_id).to_def_id(),\n+            pattern_arena: &self.pattern_arena,\n+        }\n     }\n \n     fn check_match(\n@@ -159,91 +167,88 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n         }\n \n-        self.check_in_cx(scrut.hir_id, |ref mut cx| {\n-            let mut have_errors = false;\n+        let mut cx = self.new_cx(scrut.hir_id);\n \n-            let inlined_arms: Vec<_> = arms\n-                .iter()\n-                .map(|hir::Arm { pat, guard, .. }| {\n-                    (self.lower_pattern(cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n-                })\n-                .collect();\n+        let mut have_errors = false;\n \n-            // Bail out early if inlining failed.\n-            if have_errors {\n-                return;\n-            }\n+        let inlined_arms: Vec<_> = arms\n+            .iter()\n+            .map(|hir::Arm { pat, guard, .. }| {\n+                (self.lower_pattern(&mut cx, pat, &mut have_errors).0, pat.hir_id, guard.is_some())\n+            })\n+            .collect();\n+\n+        // Bail out early if inlining failed.\n+        if have_errors {\n+            return;\n+        }\n \n-            // Fourth, check for unreachable arms.\n-            let matrix = check_arms(cx, &inlined_arms, source);\n+        // Fourth, check for unreachable arms.\n+        let matrix = check_arms(&mut cx, &inlined_arms, source);\n \n-            // Fifth, check if the match is exhaustive.\n-            let scrut_ty = self.tables.node_type(scrut.hir_id);\n-            // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n-            // since an empty matrix can occur when there are arms, if those arms all have guards.\n-            let is_empty_match = inlined_arms.is_empty();\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n-        })\n+        // Fifth, check if the match is exhaustive.\n+        let scrut_ty = self.tables.node_type(scrut.hir_id);\n+        // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n+        // since an empty matrix can occur when there are arms, if those arms all have guards.\n+        let is_empty_match = inlined_arms.is_empty();\n+        check_exhaustive(&mut cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n-        self.check_in_cx(pat.hir_id, |ref mut cx| {\n-            let (pattern, pattern_ty) = self.lower_pattern(cx, pat, &mut false);\n-            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n-\n-            let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n-                Ok(_) => return,\n-                Err(err) => err,\n-            };\n-\n-            let joined_patterns = joined_uncovered_patterns(&witnesses);\n-            let mut err = struct_span_err!(\n-                self.tcx.sess,\n-                pat.span,\n-                E0005,\n-                \"refutable pattern in {}: {} not covered\",\n-                origin,\n-                joined_patterns\n-            );\n-            let suggest_if_let = match &pat.kind {\n-                hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                    if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n-                {\n-                    const_not_var(&mut err, cx.tcx, pat, path);\n-                    false\n-                }\n-                _ => {\n-                    err.span_label(\n-                        pat.span,\n-                        pattern_not_covered_label(&witnesses, &joined_patterns),\n-                    );\n-                    true\n-                }\n-            };\n+        let mut cx = self.new_cx(pat.hir_id);\n \n-            if let (Some(span), true) = (sp, suggest_if_let) {\n-                err.note(\n-                    \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                     an `enum` with only one variant\",\n-                );\n-                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"you might want to use `if let` to ignore the variant that isn't matched\",\n-                        format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n-                err.note(\n-                    \"for more information, visit \\\n-                     https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n+        let (pattern, pattern_ty) = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n+\n+        let witnesses = match check_not_useful(&mut cx, pattern_ty, &pats, pat.hir_id) {\n+            Ok(_) => return,\n+            Err(err) => err,\n+        };\n+\n+        let joined_patterns = joined_uncovered_patterns(&witnesses);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            pat.span,\n+            E0005,\n+            \"refutable pattern in {}: {} not covered\",\n+            origin,\n+            joined_patterns\n+        );\n+        let suggest_if_let = match &pat.kind {\n+            hir::PatKind::Path(hir::QPath::Resolved(None, path))\n+                if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+            {\n+                const_not_var(&mut err, cx.tcx, pat, path);\n+                false\n+            }\n+            _ => {\n+                err.span_label(pat.span, pattern_not_covered_label(&witnesses, &joined_patterns));\n+                true\n+            }\n+        };\n+\n+        if let (Some(span), true) = (sp, suggest_if_let) {\n+            err.note(\n+                \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n+                 an `enum` with only one variant\",\n+            );\n+            if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                err.span_suggestion(\n+                    span,\n+                    \"you might want to use `if let` to ignore the variant that isn't matched\",\n+                    format!(\"if {} {{ /* */ }}\", &snippet[..snippet.len() - 1]),\n+                    Applicability::HasPlaceholders,\n                 );\n             }\n+            err.note(\n+                \"for more information, visit \\\n+                 https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n+            );\n+        }\n \n-            adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n-            err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n-            err.emit();\n-        });\n+        adt_defined_here(&mut cx, &mut err, pattern_ty, &witnesses);\n+        err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n+        err.emit();\n     }\n }\n "}, {"sha": "dd7ba5cb6fc0c4f6a5b1350db5b02fd9074096d4", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -14,6 +14,10 @@\n #![feature(optin_builtin_traits)]\n #![feature(specialization)]\n \n+// FIXME(#56935): Work around ICEs during cross-compilation.\n+#[allow(unused)]\n+extern crate rustc_macros;\n+\n use rustc_data_structures::AtomicRef;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};"}, {"sha": "a0229a5daf0dc478ace1e8ea155f1edc2c5e64a6", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -17,6 +17,10 @@\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n \n+// FIXME(#56935): Work around ICEs during cross-compilation.\n+#[allow(unused)]\n+extern crate rustc_macros;\n+\n #[macro_use]\n extern crate log;\n "}, {"sha": "eac2c3e6aa40c672c7dae945756ce667b434f53d", "filename": "src/librustc_target/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_apple_ios.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -19,6 +19,18 @@ pub fn target() -> TargetResult {\n             eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n+            forces_embed_bitcode: true,\n+            // Taken from a clang build on Xcode 11.4.1.\n+            // These arguments are not actually invoked - they just have\n+            // to look right to pass App Store validation.\n+            bitcode_llvm_cmdline: \"-triple\\0\\\n+                arm64-apple-ios11.0.0\\0\\\n+                -emit-obj\\0\\\n+                -disable-llvm-passes\\0\\\n+                -target-abi\\0\\\n+                darwinpcs\\0\\\n+                -Os\\0\"\n+                .to_string(),\n             ..base\n         },\n     })"}, {"sha": "f1cd14ffd11a6a7ea89b8f726335636f06cd50a7", "filename": "src/librustc_target/spec/aarch64_apple_tvos.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_apple_tvos.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> TargetResult {\n             eliminate_frame_pointer: false,\n             max_atomic_width: Some(128),\n             abi_blacklist: super::arm_base::abi_blacklist(),\n+            forces_embed_bitcode: true,\n             ..base\n         },\n     })"}, {"sha": "51dce9e144caa359f2c294b9aa0aa481473b4f04", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -783,6 +783,10 @@ pub struct TargetOptions {\n     // If we give emcc .o files that are actually .bc files it\n     // will 'just work'.\n     pub obj_is_bitcode: bool,\n+    /// Whether the target requires that emitted object code includes bitcode.\n+    pub forces_embed_bitcode: bool,\n+    /// Content of the LLVM cmdline section associated with embedded bitcode.\n+    pub bitcode_llvm_cmdline: String,\n \n     /// Don't use this field; instead use the `.min_atomic_width()` method.\n     pub min_atomic_width: Option<u64>,\n@@ -939,6 +943,8 @@ impl Default for TargetOptions {\n             allow_asm: true,\n             has_elf_tls: false,\n             obj_is_bitcode: false,\n+            forces_embed_bitcode: false,\n+            bitcode_llvm_cmdline: String::new(),\n             min_atomic_width: None,\n             max_atomic_width: None,\n             atomic_cas: true,\n@@ -1278,6 +1284,8 @@ impl Target {\n         key!(main_needs_argc_argv, bool);\n         key!(has_elf_tls, bool);\n         key!(obj_is_bitcode, bool);\n+        key!(forces_embed_bitcode, bool);\n+        key!(bitcode_llvm_cmdline);\n         key!(max_atomic_width, Option<u64>);\n         key!(min_atomic_width, Option<u64>);\n         key!(atomic_cas, bool);\n@@ -1505,6 +1513,8 @@ impl ToJson for Target {\n         target_option_val!(main_needs_argc_argv);\n         target_option_val!(has_elf_tls);\n         target_option_val!(obj_is_bitcode);\n+        target_option_val!(forces_embed_bitcode);\n+        target_option_val!(bitcode_llvm_cmdline);\n         target_option_val!(min_atomic_width);\n         target_option_val!(max_atomic_width);\n         target_option_val!(atomic_cas);"}, {"sha": "51ad1f04340489007b488985a6367ce0b880df84", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -204,6 +204,56 @@ pub fn new_handler(\n     )\n }\n \n+/// This function is used to setup the lint initialization. By default, in rustdoc, everything\n+/// is \"allowed\". Depending if we run in test mode or not, we want some of them to be at their\n+/// default level. For example, the \"INVALID_CODEBLOCK_ATTRIBUTE\" lint is activated in both\n+/// modes.\n+///\n+/// A little detail easy to forget is that there is a way to set the lint level for all lints\n+/// through the \"WARNINGS\" lint. To prevent this to happen, we set it back to its \"normal\" level\n+/// inside this function.\n+///\n+/// It returns a tuple containing:\n+///  * Vector of tuples of lints' name and their associated \"max\" level\n+///  * HashMap of lint id with their associated \"max\" level\n+pub fn init_lints<F>(\n+    mut whitelisted_lints: Vec<String>,\n+    lint_opts: Vec<(String, lint::Level)>,\n+    filter_call: F,\n+) -> (Vec<(String, lint::Level)>, FxHashMap<lint::LintId, lint::Level>)\n+where\n+    F: Fn(&lint::Lint) -> Option<(String, lint::Level)>,\n+{\n+    let warnings_lint_name = lint::builtin::WARNINGS.name;\n+\n+    whitelisted_lints.push(warnings_lint_name.to_owned());\n+    whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n+\n+    let lints = || {\n+        lint::builtin::HardwiredLints::get_lints()\n+            .into_iter()\n+            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n+    };\n+\n+    let lint_opts = lints()\n+        .filter_map(|lint| if lint.name == warnings_lint_name { None } else { filter_call(lint) })\n+        .chain(lint_opts.into_iter())\n+        .collect::<Vec<_>>();\n+\n+    let lint_caps = lints()\n+        .filter_map(|lint| {\n+            // We don't want to whitelist *all* lints so let's\n+            // ignore those ones.\n+            if whitelisted_lints.iter().any(|l| lint.name == l) {\n+                None\n+            } else {\n+                Some((lint::LintId::of(lint), lint::Allow))\n+            }\n+        })\n+        .collect();\n+    (lint_opts, lint_caps)\n+}\n+\n pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions) {\n     // Parse, resolve, and typecheck the given crate.\n \n@@ -247,7 +297,6 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let input = Input::File(input);\n \n     let intra_link_resolution_failure_name = lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE.name;\n-    let warnings_lint_name = lint::builtin::WARNINGS.name;\n     let missing_docs = rustc_lint::builtin::MISSING_DOCS.name;\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n     let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;\n@@ -256,8 +305,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let mut whitelisted_lints = vec![\n-        warnings_lint_name.to_owned(),\n+    let whitelisted_lints = vec![\n         intra_link_resolution_failure_name.to_owned(),\n         missing_docs.to_owned(),\n         missing_doc_example.to_owned(),\n@@ -266,39 +314,15 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         invalid_codeblock_attribute_name.to_owned(),\n     ];\n \n-    whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n-\n-    let lints = || {\n-        lint::builtin::HardwiredLints::get_lints()\n-            .into_iter()\n-            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n-    };\n-\n-    let lint_opts = lints()\n-        .filter_map(|lint| {\n-            if lint.name == warnings_lint_name\n-                || lint.name == intra_link_resolution_failure_name\n-                || lint.name == invalid_codeblock_attribute_name\n-            {\n-                None\n-            } else {\n-                Some((lint.name_lower(), lint::Allow))\n-            }\n-        })\n-        .chain(lint_opts.into_iter())\n-        .collect::<Vec<_>>();\n-\n-    let lint_caps = lints()\n-        .filter_map(|lint| {\n-            // We don't want to whitelist *all* lints so let's\n-            // ignore those ones.\n-            if whitelisted_lints.iter().any(|l| lint.name == l) {\n-                None\n-            } else {\n-                Some((lint::LintId::of(lint), lint::Allow))\n-            }\n-        })\n-        .collect();\n+    let (lint_opts, lint_caps) = init_lints(whitelisted_lints, lint_opts, |lint| {\n+        if lint.name == intra_link_resolution_failure_name\n+            || lint.name == invalid_codeblock_attribute_name\n+        {\n+            None\n+        } else {\n+            Some((lint.name_lower(), lint::Allow))\n+        }\n+    });\n \n     let crate_types =\n         if proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };"}, {"sha": "4a9ad39e2362e173d0d9aa985462f68422bc1978", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -28,6 +28,7 @@ use std::str;\n \n use crate::clean::Attributes;\n use crate::config::Options;\n+use crate::core::init_lints;\n use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n use crate::passes::span_of_attrs;\n \n@@ -45,44 +46,19 @@ pub struct TestOptions {\n pub fn run(options: Options) -> i32 {\n     let input = config::Input::File(options.input.clone());\n \n-    let warnings_lint_name = lint::builtin::WARNINGS.name;\n     let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE.name;\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n-    let mut whitelisted_lints =\n-        vec![warnings_lint_name.to_owned(), invalid_codeblock_attribute_name.to_owned()];\n+    let whitelisted_lints = vec![invalid_codeblock_attribute_name.to_owned()];\n \n-    whitelisted_lints.extend(options.lint_opts.iter().map(|(lint, _)| lint).cloned());\n-\n-    let lints = || {\n-        lint::builtin::HardwiredLints::get_lints()\n-            .into_iter()\n-            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n-    };\n-\n-    let lint_opts = lints()\n-        .filter_map(|lint| {\n-            if lint.name == warnings_lint_name || lint.name == invalid_codeblock_attribute_name {\n-                None\n-            } else {\n-                Some((lint.name_lower(), lint::Allow))\n-            }\n-        })\n-        .chain(options.lint_opts.clone().into_iter())\n-        .collect::<Vec<_>>();\n-\n-    let lint_caps = lints()\n-        .filter_map(|lint| {\n-            // We don't want to whitelist *all* lints so let's\n-            // ignore those ones.\n-            if whitelisted_lints.iter().any(|l| lint.name == l) {\n-                None\n-            } else {\n-                Some((lint::LintId::of(lint), lint::Allow))\n-            }\n-        })\n-        .collect();\n+    let (lint_opts, lint_caps) = init_lints(whitelisted_lints, options.lint_opts.clone(), |lint| {\n+        if lint.name == invalid_codeblock_attribute_name {\n+            None\n+        } else {\n+            Some((lint.name_lower(), lint::Allow))\n+        }\n+    });\n \n     let crate_types =\n         if options.proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };"}, {"sha": "4193210b8bd3bbbe1f87c062cf8d8988049699e8", "filename": "src/test/ui/unsized-locals/issue-30276-feature-flagged.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -0,0 +1,7 @@\n+#![feature(unsized_locals)]\n+\n+struct Test([i32]);\n+\n+fn main() {\n+    let _x: fn(_) -> Test = Test;\n+} //~^the size for values of type `[i32]` cannot be known at compilation time"}, {"sha": "35f63a91b2b531885b57bc084ea2ac852ea6d1d2", "filename": "src/test/ui/unsized-locals/issue-30276-feature-flagged.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276-feature-flagged.stderr?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the size for values of type `[i32]` cannot be known at compilation time\n+  --> $DIR/issue-30276-feature-flagged.rs:6:29\n+   |\n+LL |     let _x: fn(_) -> Test = Test;\n+   |                             ^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: within `Test`, the trait `std::marker::Sized` is not implemented for `[i32]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required because it appears within the type `Test`\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9c4bf062a40e9d5ec66eedf954e14223dc9c9250", "filename": "src/test/ui/unsized-locals/issue-30276.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.rs?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -0,0 +1,5 @@\n+struct Test([i32]);\n+\n+fn main() {\n+    let _x: fn(_) -> Test = Test;\n+} //~^the size for values of type `[i32]` cannot be known at compilation time"}, {"sha": "d42fddb3a4a26aec1c22f9aa4e5cf5678d21ad40", "filename": "src/test/ui/unsized-locals/issue-30276.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-30276.stderr?ref=7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the size for values of type `[i32]` cannot be known at compilation time\n+  --> $DIR/issue-30276.rs:4:29\n+   |\n+LL |     let _x: fn(_) -> Test = Test;\n+   |                             ^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[i32]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all function arguments must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}