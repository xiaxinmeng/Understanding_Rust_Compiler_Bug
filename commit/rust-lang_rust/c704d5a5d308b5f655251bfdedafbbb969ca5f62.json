{"sha": "c704d5a5d308b5f655251bfdedafbbb969ca5f62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MDRkNWE1ZDMwOGI1ZjY1NTI1MWJmZGVkYWZiYmI5NjljYTVmNjI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-23T11:38:36Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-23T11:38:36Z"}, "message": "Clean up some confused shuffling of def_ids in resolve.rs", "tree": {"sha": "3d10d737710214395c628c0c9e2288f0a135f1b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d10d737710214395c628c0c9e2288f0a135f1b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c704d5a5d308b5f655251bfdedafbbb969ca5f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c704d5a5d308b5f655251bfdedafbbb969ca5f62", "html_url": "https://github.com/rust-lang/rust/commit/c704d5a5d308b5f655251bfdedafbbb969ca5f62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c704d5a5d308b5f655251bfdedafbbb969ca5f62/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "562afef2169482dd00b93fc1d5b4e736ab5b120e", "url": "https://api.github.com/repos/rust-lang/rust/commits/562afef2169482dd00b93fc1d5b4e736ab5b120e", "html_url": "https://github.com/rust-lang/rust/commit/562afef2169482dd00b93fc1d5b4e736ab5b120e"}], "stats": {"total": 65, "additions": 31, "deletions": 34}, "files": [{"sha": "121a0c8d7f3b4c3d08c6bc1328078df4bfb58253", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c704d5a5d308b5f655251bfdedafbbb969ca5f62/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c704d5a5d308b5f655251bfdedafbbb969ca5f62/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=c704d5a5d308b5f655251bfdedafbbb969ca5f62", "patch": "@@ -37,7 +37,7 @@ enum scope {\n     scope_loop(@ast::local), // there's only 1 decl per loop.\n     scope_block(ast::blk, @mutable uint, @mutable uint),\n     scope_arm(ast::arm),\n-    scope_method(ast::node_id, [ast::ty_param]),\n+    scope_method(node_id, [ast::ty_param]),\n }\n \n type scopes = list<scope>;\n@@ -47,7 +47,7 @@ fn top_scope() -> scopes {\n }\n \n enum import_state {\n-    todo(ast::node_id, ast::ident, @[ast::ident], span, scopes),\n+    todo(ast::ident, @[ast::ident], span, scopes),\n     is_glob(@[ast::ident], scopes, span),\n     resolving(span),\n     resolved(option<def>, /* value */\n@@ -126,16 +126,16 @@ type env =\n     {cstore: cstore::cstore,\n      def_map: def_map,\n      ast_map: ast_map::map,\n-     imports: hashmap<ast::node_id, import_state>,\n+     imports: hashmap<node_id, import_state>,\n      mutable exp_map: exp_map,\n-     mod_map: hashmap<ast::node_id, @indexed_mod>,\n-     block_map: hashmap<ast::node_id, [glob_imp_def]>,\n+     mod_map: hashmap<node_id, @indexed_mod>,\n+     block_map: hashmap<node_id, [glob_imp_def]>,\n      ext_map: ext_map,\n      impl_map: impl_map,\n      impl_cache: impl_cache,\n      ext_cache: ext_hash,\n      used_imports: {mutable track: bool,\n-                    mutable data: [ast::node_id]},\n+                    mutable data: [node_id]},\n      mutable reported: [{ident: str, sc: scope}],\n      mutable ignored_imports: [node_id],\n      mutable current_tp: option<uint>,\n@@ -233,14 +233,14 @@ fn map_crate(e: @env, c: @ast::crate) {\n         iter_effective_import_paths(*i) { |vp|\n             alt vp.node {\n               ast::view_path_simple(name, path, id) {\n-                e.imports.insert(id, todo(id, name, path, vp.span, sc));\n+                e.imports.insert(id, todo(name, path, vp.span, sc));\n               }\n               ast::view_path_glob(path, id) {\n                 e.imports.insert(id, is_glob(path, sc, vp.span));\n               }\n               ast::view_path_list(mod_path, idents, _) {\n                 for ident in idents {\n-                    let t = todo(ident.node.id, ident.node.name,\n+                    let t = todo(ident.node.name,\n                                  @(*mod_path + [ident.node.name]),\n                                  ident.span, sc);\n                     e.imports.insert(ident.node.id, t);\n@@ -355,12 +355,11 @@ fn resolve_imports(e: env) {\n     e.used_imports.track = true;\n     loop {\n         let mut done = true;\n-        e.imports.values {|v|\n+        e.imports.items {|id, v|\n             alt check v {\n-              todo(node_id, name, path, span, scopes) {\n+              todo(name, path, span, scopes) {\n                 done = false;\n-                resolve_import(e, local_def(node_id), name, *path, span,\n-                               scopes);\n+                resolve_import(e, id, name, *path, span, scopes);\n               }\n               resolved(_, _, _, _, _, _) | is_glob(_, _, _) { }\n             }\n@@ -699,7 +698,7 @@ fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n }\n \n // Import resolution\n-fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n+fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n                   ids: [ast::ident], sp: codemap::span, sc: scopes) {\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: fn(namespace) -> option<def>,\n@@ -758,13 +757,13 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     }\n     // This function has cleanup code at the end. Do not return without going\n     // through that.\n-    e.imports.insert(defid.node, resolving(sp));\n-    let mut ignored = find_imports_after(e, defid.node, sc);\n+    e.imports.insert(n_id, resolving(sp));\n+    let mut ignored = find_imports_after(e, n_id, sc);\n     e.ignored_imports <-> ignored;\n     let n_idents = vec::len(ids);\n     let end_id = ids[n_idents - 1u];\n     if n_idents == 1u {\n-        register(e, defid.node, in_scope(sc), sp, name,\n+        register(e, n_id, in_scope(sc), sp, name,\n                  {|ns| lookup_in_scope(e, sc, sp, end_id, ns, true) }, []);\n     } else {\n         alt lookup_in_scope(e, sc, sp, ids[0], ns_module, true) {\n@@ -777,7 +776,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                 if i == n_idents - 1u {\n                     let mut impls = [];\n                     find_impls_in_mod(e, dcur, impls, some(end_id));\n-                    register(e, defid.node, in_mod(dcur), sp, name, {|ns|\n+                    register(e, n_id, in_mod(dcur), sp, name, {|ns|\n                         lookup_in_mod(e, dcur, sp, end_id, ns, outside)\n                     }, impls);\n                     break;\n@@ -801,9 +800,9 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     // If we couldn't resolve the import, don't leave it in a partially\n     // resolved state, to avoid having it reported later as a cyclic\n     // import\n-    alt e.imports.find(defid.node) {\n+    alt e.imports.find(n_id) {\n       some(resolving(sp)) {\n-        e.imports.insert(defid.node, resolved(none, none, none, @[], \"\", sp));\n+        e.imports.insert(n_id, resolved(none, none, none, @[], \"\", sp));\n       }\n       _ { }\n     }\n@@ -1259,15 +1258,14 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                 alt vp.node {\n                   ast::view_path_simple(ident, _, id) {\n                     if is_import && name == ident {\n-                        ret lookup_import(e, local_def(id), ns);\n+                        ret lookup_import(e, id, ns);\n                     }\n                   }\n \n                   ast::view_path_list(path, idents, _) {\n                     for ident in idents {\n                         if name == ident.node.name {\n-                            let def = local_def(ident.node.id);\n-                            ret lookup_import(e, def, ns);\n+                            ret lookup_import(e, ident.node.id, ns);\n                         }\n                     }\n                   }\n@@ -1389,21 +1387,21 @@ fn found_view_item(e: env, id: node_id) -> option<def> {\n     }\n }\n \n-fn lookup_import(e: env, defid: def_id, ns: namespace) -> option<def> {\n+fn lookup_import(e: env, n_id: node_id, ns: namespace) -> option<def> {\n     // Imports are simply ignored when resolving themselves.\n-    if vec::contains(e.ignored_imports, defid.node) { ret none; }\n-    alt e.imports.get(defid.node) {\n-      todo(node_id, name, path, span, scopes) {\n-        resolve_import(e, local_def(node_id), name, *path, span, scopes);\n-        ret lookup_import(e, defid, ns);\n+    if vec::contains(e.ignored_imports, n_id) { ret none; }\n+    alt e.imports.get(n_id) {\n+      todo(name, path, span, scopes) {\n+        resolve_import(e, n_id, name, *path, span, scopes);\n+        ret lookup_import(e, n_id, ns);\n       }\n       resolving(sp) {\n         e.sess.span_err(sp, \"cyclic import\");\n         ret none;\n       }\n       resolved(val, typ, md, _, _, _) {\n         if e.used_imports.track {\n-            e.used_imports.data += [defid.node];\n+            e.used_imports.data += [n_id];\n         }\n         ret alt ns { ns_val { val } ns_type { typ } ns_module { md } };\n       }\n@@ -1537,7 +1535,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n       mie_view_item(_, id, _) {\n          if ns == ns_module { ret found_view_item(e, id); }\n       }\n-      mie_import_ident(id, _) { ret lookup_import(e, local_def(id), ns); }\n+      mie_import_ident(id, _) { ret lookup_import(e, id, ns); }\n       mie_item(item) { ret found_def_item(item, ns); }\n       mie_enum_variant(variant_idx, variants, parent_id, parent_span) {\n          alt ns {\n@@ -2146,13 +2144,12 @@ fn resolve_impls(e: @env, c: @ast::crate) {\n \n fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n                            &impls: [@_impl], sc: option<iscopes>) {\n-    fn lookup_imported_impls(e: env, id: ast::node_id,\n+    fn lookup_imported_impls(e: env, id: node_id,\n                              act: fn(@[@_impl])) {\n         alt e.imports.get(id) {\n           resolved(_, _, _, is, _, _) { act(is); }\n-          todo(node_id, name, path, span, scopes) {\n-            resolve_import(e, local_def(node_id), name, *path, span,\n-                           scopes);\n+          todo(name, path, span, scopes) {\n+            resolve_import(e, id, name, *path, span, scopes);\n             alt check e.imports.get(id) {\n               resolved(_, _, _, is, _, _) { act(is); }\n             }"}]}