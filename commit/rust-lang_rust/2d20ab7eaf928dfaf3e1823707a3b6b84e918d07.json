{"sha": "2d20ab7eaf928dfaf3e1823707a3b6b84e918d07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjBhYjdlYWY5MjhkZmFmM2UxODIzNzA3YTNiNmI4NGU5MThkMDc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-29T18:18:41Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-29T18:18:41Z"}, "message": "Rewrite all_super_trait_refs as an iterator\n\nDoesn't fix the bug I was trying to fix, but now that I did it anyway it\nseems fine to keep.", "tree": {"sha": "472c16ab18b9abe63306524a59b26715d3d9ef2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/472c16ab18b9abe63306524a59b26715d3d9ef2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d20ab7eaf928dfaf3e1823707a3b6b84e918d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d20ab7eaf928dfaf3e1823707a3b6b84e918d07", "html_url": "https://github.com/rust-lang/rust/commit/2d20ab7eaf928dfaf3e1823707a3b6b84e918d07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d20ab7eaf928dfaf3e1823707a3b6b84e918d07/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b384cfcb81ae0db541cfe02213e9d95041b77362", "url": "https://api.github.com/repos/rust-lang/rust/commits/b384cfcb81ae0db541cfe02213e9d95041b77362", "html_url": "https://github.com/rust-lang/rust/commit/b384cfcb81ae0db541cfe02213e9d95041b77362"}], "stats": {"total": 52, "additions": 34, "deletions": 18}, "files": [{"sha": "2f490fb92026656ec512f8720a35ec846be6172c", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2d20ab7eaf928dfaf3e1823707a3b6b84e918d07/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d20ab7eaf928dfaf3e1823707a3b6b84e918d07/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=2d20ab7eaf928dfaf3e1823707a3b6b84e918d07", "patch": "@@ -1,6 +1,8 @@\n //! Helper functions for working with def, which don't need to be a separate\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n \n+use std::iter;\n+\n use chalk_ir::{fold::Shift, BoundVar, DebruijnIndex};\n use hir_def::{\n     db::DefDatabase,\n@@ -14,8 +16,12 @@ use hir_def::{\n     AssocContainerId, GenericDefId, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n use hir_expand::name::{name, Name};\n+use rustc_hash::FxHashSet;\n \n-use crate::{db::HirDatabase, Interner, Substitution, TraitRef, TraitRefExt, TyKind, WhereClause};\n+use crate::{\n+    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, TyKind,\n+    WhereClause,\n+};\n \n fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n@@ -102,33 +108,43 @@ pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n /// `all_super_traits` is that we keep track of type parameters; for example if\n /// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n /// `Self: OtherTrait<i32>`.\n-pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> Vec<TraitRef> {\n-    // FIXME: replace by Chalk's `super_traits`, maybe make this a query\n+pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> SuperTraits {\n+    SuperTraits { db, seen: iter::once(trait_ref.trait_id).collect(), stack: vec![trait_ref] }\n+}\n \n-    // we need to take care a bit here to avoid infinite loops in case of cycles\n-    // (i.e. if we have `trait A: B; trait B: A;`)\n-    let mut result = vec![trait_ref];\n-    let mut i = 0;\n-    while i < result.len() {\n-        let t = &result[i];\n-        // yeah this is quadratic, but trait hierarchies should be flat\n-        // enough that this doesn't matter\n-        for tt in direct_super_trait_refs(db, t) {\n-            if !result.iter().any(|tr| tr.trait_id == tt.trait_id) {\n-                result.push(tt);\n-            }\n+pub(super) struct SuperTraits<'a> {\n+    db: &'a dyn HirDatabase,\n+    stack: Vec<TraitRef>,\n+    seen: FxHashSet<ChalkTraitId>,\n+}\n+\n+impl<'a> SuperTraits<'a> {\n+    fn elaborate(&mut self, trait_ref: &TraitRef) {\n+        let mut trait_refs = direct_super_trait_refs(self.db, trait_ref);\n+        trait_refs.retain(|tr| !self.seen.contains(&tr.trait_id));\n+        self.stack.extend(trait_refs);\n+    }\n+}\n+\n+impl<'a> Iterator for SuperTraits<'a> {\n+    type Item = TraitRef;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(next) = self.stack.pop() {\n+            self.elaborate(&next);\n+            Some(next)\n+        } else {\n+            None\n         }\n-        i += 1;\n     }\n-    result\n }\n \n pub(super) fn associated_type_by_name_including_super_traits(\n     db: &dyn HirDatabase,\n     trait_ref: TraitRef,\n     name: &Name,\n ) -> Option<(TraitRef, TypeAliasId)> {\n-    all_super_trait_refs(db, trait_ref).into_iter().find_map(|t| {\n+    all_super_trait_refs(db, trait_ref).find_map(|t| {\n         let assoc_type = db.trait_data(t.hir_trait_id()).associated_type_by_name(name)?;\n         Some((t, assoc_type))\n     })"}]}