{"sha": "ee9cd7bb6ac4ffd03d00549bff8285ed7ca0ea5b", "node_id": "C_kwDOAAsO6NoAKGVlOWNkN2JiNmFjNGZmZDAzZDAwNTQ5YmZmODI4NWVkN2NhMGVhNWI", "commit": {"author": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2022-01-21T15:28:23Z"}, "committer": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2022-02-14T15:56:37Z"}, "message": "Add a stack-`pin!`-ning macro to the `pin` module.\n\nAdd a type annotation to improve error messages with type mismatches\n\nAdd a link to the temporary-lifetime-extension section of the reference", "tree": {"sha": "a724106ee7d32d9a74f0fbbdf9f223b2448be90a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a724106ee7d32d9a74f0fbbdf9f223b2448be90a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee9cd7bb6ac4ffd03d00549bff8285ed7ca0ea5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee9cd7bb6ac4ffd03d00549bff8285ed7ca0ea5b", "html_url": "https://github.com/rust-lang/rust/commit/ee9cd7bb6ac4ffd03d00549bff8285ed7ca0ea5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee9cd7bb6ac4ffd03d00549bff8285ed7ca0ea5b/comments", "author": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b321742c6c27494897a88cd5ac17ac20aa3469a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b321742c6c27494897a88cd5ac17ac20aa3469a1", "html_url": "https://github.com/rust-lang/rust/commit/b321742c6c27494897a88cd5ac17ac20aa3469a1"}], "stats": {"total": 242, "additions": 242, "deletions": 0}, "files": [{"sha": "450ff752dab0513728521485ab94cba61a3820a7", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/ee9cd7bb6ac4ffd03d00549bff8285ed7ca0ea5b/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee9cd7bb6ac4ffd03d00549bff8285ed7ca0ea5b/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=ee9cd7bb6ac4ffd03d00549bff8285ed7ca0ea5b", "patch": "@@ -909,3 +909,245 @@ impl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n+\n+/// Constructs a <code>[Pin]<[&mut] T></code>, by pinning[^1] a `value: T` _locally_[^2]\n+/// (\u2260 [in the heap][`Box::pin`]).\n+///\n+/// [^1]: If the (type `T` of the) given value does not implement [`Unpin`], then this\n+/// effectively pins the `value` in memory, where it will be unable to be moved.\n+/// Otherwise, <code>[Pin]<[&mut] T></code> behaves like <code>[&mut] T</code>, and operations such\n+/// as [`mem::replace()`][crate::mem::replace] will allow extracting that value, and therefore,\n+/// moving it.\n+/// See [the `Unpin` section of the `pin` module][self#unpin] for more info.\n+///\n+/// [^2]: This is usually dubbed \"stack\"-pinning. And whilst local values are almost always located\n+/// in the stack (_e.g._, when within the body of a non-`async` function), the truth is that inside\n+/// the body of an `async fn` or block \u2014more generally, the body of a generator\u2014 any locals crossing\n+/// an `.await` point \u2014a `yield` point\u2014 end up being part of the state captured by the `Future` \u2014by\n+/// the `Generator`\u2014, and thus will be stored wherever that one is.\n+///\n+/// ## Examples\n+///\n+/// ### Basic usage\n+///\n+/// ```rust\n+/// #![feature(pin_macro)]\n+/// # use core::marker::PhantomPinned as Foo;\n+/// use core::pin::{pin, Pin};\n+///\n+/// fn stuff(foo: Pin<&mut Foo>) {\n+///     // \u2026\n+///     # let _ = foo;\n+/// }\n+///\n+/// let pinned_foo = pin!(Foo { /* \u2026 */ });\n+/// stuff(pinned_foo);\n+/// // or, directly:\n+/// stuff(pin!(Foo { /* \u2026 */ }));\n+/// ```\n+///\n+/// ### Manually polling a `Future` (wihout `Unpin` bounds)\n+///\n+/// ```rust\n+/// #![feature(pin_macro)]\n+/// use std::{\n+///     future::Future,\n+///     pin::pin,\n+///     task::{Context, Poll},\n+///     thread,\n+/// };\n+/// # use std::{sync::Arc, task::Wake, thread::Thread};\n+///\n+/// # /// A waker that wakes up the current thread when called.\n+/// # struct ThreadWaker(Thread);\n+/// #\n+/// # impl Wake for ThreadWaker {\n+/// #     fn wake(self: Arc<Self>) {\n+/// #         self.0.unpark();\n+/// #     }\n+/// # }\n+/// #\n+/// /// Runs a future to completion.\n+/// fn block_on<Fut: Future>(fut: Fut) -> Fut::Output {\n+///     let waker_that_unparks_thread = // \u2026\n+///         # Arc::new(ThreadWaker(thread::current())).into();\n+///     let mut cx = Context::from_waker(&waker_that_unparks_thread);\n+///     // Pin the future so it can be polled.\n+///     let mut pinned_fut = pin!(fut);\n+///     loop {\n+///         match pinned_fut.as_mut().poll(&mut cx) {\n+///             Poll::Pending => thread::park(),\n+///             Poll::Ready(res) => return res,\n+///         }\n+///     }\n+/// }\n+/// #\n+/// # assert_eq!(42, block_on(async { 42 }));\n+/// ```\n+///\n+/// ### With `Generator`s\n+///\n+/// ```rust\n+/// #![feature(generators, generator_trait, pin_macro)]\n+/// use core::{\n+///     ops::{Generator, GeneratorState},\n+///     pin::pin,\n+/// };\n+///\n+/// fn generator_fn() -> impl Generator<Yield = usize, Return = ()> /* not Unpin */ {\n+///  // Allow generator to be self-referential (not `Unpin`)\n+///  // vvvvvv        so that locals can cross yield points.\n+///     static || {\n+///         let foo = String::from(\"foo\"); // --+\n+///         yield 0;                         // | <- crosses yield point!\n+///         println!(\"{}\", &foo); // <----------+\n+///         yield foo.len();\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut generator = pin!(generator_fn());\n+///     match generator.as_mut().resume(()) {\n+///         GeneratorState::Yielded(0) => {},\n+///         _ => unreachable!(),\n+///     }\n+///     match generator.as_mut().resume(()) {\n+///         GeneratorState::Yielded(3) => {},\n+///         _ => unreachable!(),\n+///     }\n+///     match generator.resume(()) {\n+///         GeneratorState::Yielded(_) => unreachable!(),\n+///         GeneratorState::Complete(()) => {},\n+///     }\n+/// }\n+/// ```\n+///\n+/// ## Remarks\n+///\n+/// Precisely because a value is pinned to local storage, the resulting <code>[Pin]<[&mut] T></code>\n+/// reference ends up borrowing a local tied to that block: it can't escape it.\n+///\n+/// The following, for instance, fails to compile:\n+///\n+/// ```rust,compile_fail\n+/// #![feature(pin_macro)]\n+/// use core::pin::{pin, Pin};\n+/// # use core::{marker::PhantomPinned as Foo, mem::drop as stuff};\n+///\n+/// let x: Pin<&mut Foo> = {\n+///     let x: Pin<&mut Foo> = pin!(Foo { /* \u2026 */ });\n+///     x\n+/// }; // <- Foo is dropped\n+/// stuff(x); // Error: use of dropped value\n+/// ```\n+///\n+/// <details><summary>Error message</summary>\n+///\n+/// ```rust\n+/// # const _IGNORE: &str = stringify! {\n+/// error[E0716]: temporary value dropped while borrowed\n+///   --> src/main.rs:9:28\n+///    |\n+/// 8  | let x: Pin<&mut Foo> = {\n+///    |     - borrow later stored here\n+/// 9  |     let x: Pin<&mut Foo> = pin!(Foo { /* \u2026 */ });\n+///    |                            ^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+/// 10 |     x\n+/// 11 | }; // <- Foo is dropped\n+///    | - temporary value is freed at the end of this statement\n+///    |\n+///    = note: consider using a let binding to create a longer lived value\n+/// # };\n+/// ```\n+///\n+/// </details>\n+///\n+/// This makes [`pin!`] **unsuitable to pin values when intending to _return_ them**. Instead, the\n+/// value is expected to be passed around _unpinned_ until the point where it is to be consumed,\n+/// where it is then useful and even sensible to pin the value locally using [`pin!`].\n+///\n+/// If you really need to return a pinned value, consider using [`Box::pin`] instead.\n+///\n+/// On the other hand, pinning to the stack[<sup>2</sup>](#fn2) using [`pin!`] is likely to be\n+/// cheaper than pinning into a fresh heap allocation using [`Box::pin`]. Moreover, by virtue of not\n+/// even needing an allocator, [`pin!`] is the main non-`unsafe` `#![no_std]`-compatible [`Pin`]\n+/// constructor.\n+///\n+/// [`Box::pin`]: ../../std/boxed/struct.Box.html#method.pin\n+#[unstable(feature = \"pin_macro\", issue = \"93178\")]\n+pub macro pin($value:expr $(,)?) {\n+    // This is `Pin::new_unchecked(&mut { $value })`, so, for starters, let's\n+    // review such a hypothetical macro (that any user-code could define):\n+    //\n+    // ```rust\n+    // macro_rules! pin {( $value:expr ) => (\n+    //     match &mut { $value } { at_value => unsafe { // Do not wrap `$value` in an `unsafe` block.\n+    //         $crate::pin::Pin::<&mut _>::new_unchecked(at_value)\n+    //     }}\n+    // )}\n+    // ```\n+    //\n+    // Safety:\n+    //   - `type P = &mut _`. There are thus no pathological `Deref{,Mut}` impls\n+    //     that would break `Pin`'s invariants.\n+    //   - `{ $value }` is braced, making it a _block expression_, thus **moving**\n+    //     the given `$value`, and making it _become an **anonymous** temporary_.\n+    //     By virtue of being anonynomous, it can no longer be accessed, thus\n+    //     preventing any attemps to `mem::replace` it or `mem::forget` it, _etc._\n+    //\n+    // This gives us a `pin!` definition that is sound, and which works, but only\n+    // in certain scenarios:\n+    //   - If the `pin!(value)` expression is _directly_ fed to a function call:\n+    //     `let poll = pin!(fut).poll(cx);`\n+    //   - If the `pin!(value)` expression is part of a scrutinee:\n+    //     ```rust\n+    //     match pin!(fut) { pinned_fut => {\n+    //         pinned_fut.as_mut().poll(...);\n+    //         pinned_fut.as_mut().poll(...);\n+    //     }} // <- `fut` is dropped here.\n+    //     ```\n+    // Alas, it doesn't work for the more straight-forward use-case: `let` bindings.\n+    // ```rust\n+    // let pinned_fut = pin!(fut); // <- temporary value is freed at the end of this statement\n+    // pinned_fut.poll(...) // error[E0716]: temporary value dropped while borrowed\n+    //                      // note: consider using a `let` binding to create a longer lived value\n+    // ```\n+    //   - Issues such as this one are the ones motivating https://github.com/rust-lang/rfcs/pull/66\n+    //\n+    // This makes such a macro incredibly unergonomic in practice, and the reason most macros\n+    // out there had to take the path of being a statement/binding macro (_e.g._, `pin!(future);`)\n+    // instead of featuring the more intuitive ergonomics of an expression macro.\n+    //\n+    // Luckily, there is a way to avoid the problem. Indeed, the problem stems from the fact that a\n+    // temporary is dropped at the end of its enclosing statement when it is part of the parameters\n+    // given to function call, which has precisely been the case with our `Pin::new_unchecked()`!\n+    // For instance,\n+    // ```rust\n+    // let p = Pin::new_unchecked(&mut <temporary>);\n+    // ```\n+    // becomes:\n+    // ```rust\n+    // let p = { let mut anon = <temporary>; &mut anon };\n+    // ```\n+    //\n+    // However, when using a literal braced struct to construct the value, references to temporaries\n+    // can then be taken. This makes Rust change the lifespan of such temporaries so that they are,\n+    // instead, dropped _at the end of the enscoping block_.\n+    // For instance,\n+    // ```rust\n+    // let p = Pin { pointer: &mut <temporary> };\n+    // ```\n+    // becomes:\n+    // ```rust\n+    // let mut anon = <temporary>;\n+    // let p = Pin { pointer: &mut anon };\n+    // ```\n+    // which is *exactly* what we want.\n+    //\n+    // See https://doc.rust-lang.org/1.58.1/reference/destructors.html#temporary-lifetime-extension\n+    // for more info.\n+    //\n+    // Finally, we don't hit problems _w.r.t._ the privacy of the `pointer` field, or the\n+    // unqualified `Pin` name, thanks to `decl_macro`s being _fully_ hygienic (`def_site` hygiene).\n+    Pin::<&mut _> { pointer: &mut { $value } }\n+}"}]}