{"sha": "a30ea013f5b88f136438931328ee859ee4e5eff3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMGVhMDEzZjViODhmMTM2NDM4OTMxMzI4ZWU4NTllZTRlNWVmZjM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-17T02:45:05Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-30T04:33:22Z"}, "message": "Handle supertrait calls in default methods\n\nAdd a new method_super origin for supertrait methods. Also make\ncoherence create a table that maps pairs of trait IDs and self types\nto impl IDs, so that it's possible to check a supertrait method\nknowing only its index in its trait's methods (without knowing all\nsupertraits for a given trait).\n\nr=nmatsakis and graydon -- with hope, we'll revamp all of this code as\nper #4678, but for now this fixes the bug.\n\nCloses #3979", "tree": {"sha": "09ef3f359c3a4d9ab71196c2b5a0a3d1b1cb49b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09ef3f359c3a4d9ab71196c2b5a0a3d1b1cb49b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a30ea013f5b88f136438931328ee859ee4e5eff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a30ea013f5b88f136438931328ee859ee4e5eff3", "html_url": "https://github.com/rust-lang/rust/commit/a30ea013f5b88f136438931328ee859ee4e5eff3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a30ea013f5b88f136438931328ee859ee4e5eff3/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b927e48a26036f62299fe51b7c70141482dbf041", "url": "https://api.github.com/repos/rust-lang/rust/commits/b927e48a26036f62299fe51b7c70141482dbf041", "html_url": "https://github.com/rust-lang/rust/commit/b927e48a26036f62299fe51b7c70141482dbf041"}], "stats": {"total": 428, "additions": 354, "deletions": 74}, "files": [{"sha": "9e0b07dd9ee7981b44f8f30091e5e1f3a2f0e125", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -564,7 +564,7 @@ impl method_origin: tr {\n     fn tr(xcx: extended_decode_ctxt) -> method_origin {\n         match self {\n           typeck::method_static(did) => {\n-            typeck::method_static(did.tr(xcx))\n+              typeck::method_static(did.tr(xcx))\n           }\n           typeck::method_param(ref mp) => {\n             typeck::method_param(\n@@ -575,10 +575,13 @@ impl method_origin: tr {\n             )\n           }\n           typeck::method_trait(did, m, vstore) => {\n-            typeck::method_trait(did.tr(xcx), m, vstore)\n+              typeck::method_trait(did.tr(xcx), m, vstore)\n           }\n           typeck::method_self(did, m) => {\n-            typeck::method_self(did.tr(xcx), m)\n+              typeck::method_self(did.tr(xcx), m)\n+          }\n+          typeck::method_super(trait_did, m) => {\n+              typeck::method_super(trait_did.tr(xcx), m)\n           }\n         }\n     }"}, {"sha": "fcc75e8867b28be85e8823b784c1394fa7aab1c8", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -16,7 +16,8 @@ use core::prelude::*;\n \n use middle::ty::{ty_struct, ty_enum};\n use middle::ty;\n-use middle::typeck::{method_map, method_origin, method_param, method_self};\n+use middle::typeck::{method_map, method_origin, method_param, method_self,\n+                     method_super};\n use middle::typeck::{method_static, method_trait};\n \n use core::dvec::DVec;\n@@ -138,7 +139,8 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                  _\n             }) |\n             method_trait(trait_id, method_num, _) |\n-            method_self(trait_id, method_num) => {\n+            method_self(trait_id, method_num) |\n+            method_super(trait_id, method_num) => {\n                 if trait_id.crate == local_crate {\n                     match tcx.items.find(trait_id.node) {\n                         Some(node_item(item, _)) => {"}, {"sha": "0ee3e3e451a9eada85662478c0f2b6f1e3b79b19", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -193,6 +193,29 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                                              method_name);\n             origin = typeck::method_static(method_id);\n         }\n+        typeck::method_super(trait_id, method_index) => {\n+            // <self_ty> is the self type for this method call\n+            let self_ty = node_id_type(bcx, self.id);\n+            let tcx = bcx.tcx();\n+            // <impl_id> is the ID of the implementation of\n+            // trait <trait_id> for type <self_ty>\n+            let impl_id = ty::get_impl_id(tcx, trait_id, self_ty);\n+            // Get the supertrait's methods\n+            let supertrait_methods = ty::trait_methods(tcx, trait_id);\n+            // Make sure to fail with a readable error message if\n+            // there's some internal error here\n+            if !(method_index < supertrait_methods.len()) {\n+                tcx.sess.bug(~\"trans_method_callee: supertrait method \\\n+                               index is out of bounds\");\n+            }\n+            // Get the method name using the method index in the origin\n+            let method_name = supertrait_methods[method_index].ident;\n+            // Now that we know the impl ID, we can look up the method\n+            // ID from its name\n+            origin = typeck::method_static(method_with_name(bcx.ccx(),\n+                                              impl_id,\n+                                              method_name));\n+        }\n         typeck::method_static(*) | typeck::method_param(*) |\n         typeck::method_trait(*) => {}\n     }\n@@ -236,8 +259,8 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                                vstore,\n                                mentry.explicit_self)\n         }\n-        typeck::method_self(*) => {\n-            fail ~\"method_self should have been handled above\"\n+        typeck::method_self(*) | typeck::method_super(*) => {\n+            fail ~\"method_self or method_super should have been handled above\"\n         }\n     }\n }"}, {"sha": "f8c175389a79d19a68c3dc1dca247c81e85baeb0", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -312,7 +312,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n         let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n-        let mut i = 0u;\n+        let mut i = 0;\n         vec::map2(*bounds, substs, |bounds, subst| {\n             let mut v = ~[];\n             for bounds.each |bound| {"}, {"sha": "39f3aecfcd44eed86501572a3d32f26fc3c48c81", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -239,7 +239,8 @@ fn mark_for_method_call(cx: ctx, e_id: node_id, callee_id: node_id) {\n           }) => {\n             cx.uses[param] |= use_tydesc;\n           }\n-          typeck::method_trait(*) | typeck::method_self(*) => (),\n+          typeck::method_trait(*) | typeck::method_self(*)\n+              | typeck::method_super(*) => (),\n         }\n     }\n }"}, {"sha": "4458777ff1fe2c7abb4eb2c0d38cbdcfce4cfe0f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -243,6 +243,7 @@ export iter_bound_traits_and_supertraits;\n export count_traits_and_supertraits;\n export IntVarValue, IntType, UintType;\n export creader_cache_key;\n+export get_impl_id;\n \n // Data types\n \n@@ -486,6 +487,9 @@ type ctxt =\n \n       // Records the value mode (read, copy, or move) for every value.\n       value_modes: HashMap<ast::node_id, ValueMode>,\n+\n+      // Maps a trait onto a mapping from self-ty to impl\n+      trait_impls: HashMap<ast::def_id, HashMap<t, @Impl>>\n       };\n \n enum tbox_flag {\n@@ -1051,7 +1055,9 @@ fn mk_ctxt(s: session::Session,\n       supertraits: HashMap(),\n       destructor_for_type: HashMap(),\n       destructors: HashMap(),\n-      value_modes: HashMap()}\n+      value_modes: HashMap(),\n+      trait_impls: HashMap()\n+     }\n }\n \n \n@@ -3130,7 +3136,8 @@ fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n               trait_id: trt_id,\n               method_num: n_mth, _}) |\n           typeck::method_trait(trt_id, n_mth, _) |\n-          typeck::method_self(trt_id, n_mth) => {\n+          typeck::method_self(trt_id, n_mth) |\n+          typeck::method_super(trt_id, n_mth) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n@@ -4372,9 +4379,14 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n \n // Iterate over a type parameter's bounded traits and any supertraits\n // of those traits, ignoring kinds.\n+// Here, the supertraits are the transitive closure of the supertrait\n+// relation on the supertraits from each bounded trait's constraint\n+// list.\n fn iter_bound_traits_and_supertraits(tcx: ctxt,\n                                      bounds: param_bounds,\n                                      f: &fn(t) -> bool) {\n+    let mut fin = false;\n+\n     for bounds.each |bound| {\n \n         let bound_trait_ty = match *bound {\n@@ -4386,34 +4398,45 @@ fn iter_bound_traits_and_supertraits(tcx: ctxt,\n             }\n         };\n \n-        let mut worklist = ~[];\n-\n-        let init_trait_ty = bound_trait_ty;\n-\n-        worklist.push(init_trait_ty);\n-\n+        let mut supertrait_map = HashMap();\n+        let mut seen_def_ids = ~[];\n         let mut i = 0;\n-        while i < worklist.len() {\n-            let init_trait_ty = worklist[i];\n-            i += 1;\n-\n-            let init_trait_id = match ty_to_def_id(init_trait_ty) {\n-                Some(id) => id,\n-                None => tcx.sess.bug(\n-                    ~\"trait type should have def_id\")\n-            };\n-\n-            // Add supertraits to worklist\n-            let supertraits = trait_supertraits(tcx,\n-                                                init_trait_id);\n-            for supertraits.each |supertrait| {\n-                worklist.push(supertrait.tpt.ty);\n-            }\n-\n-            if !f(init_trait_ty) {\n-                return;\n+        let trait_ty_id = ty_to_def_id(bound_trait_ty).expect(\n+            ~\"iter_trait_ty_supertraits got a non-trait type\");\n+        let mut trait_ty = bound_trait_ty;\n+\n+        debug!(\"iter_bound_traits_and_supertraits: trait_ty = %s\",\n+               ty_to_str(tcx, trait_ty));\n+\n+        // Add the given trait ty to the hash map\n+        supertrait_map.insert(trait_ty_id, trait_ty);\n+        seen_def_ids.push(trait_ty_id);\n+\n+        if f(trait_ty) {\n+            // Add all the supertraits to the hash map,\n+            // executing <f> on each of them\n+            while i < supertrait_map.size() && !fin {\n+                let init_trait_id = seen_def_ids[i];\n+                i += 1;\n+                 // Add supertraits to supertrait_map\n+                let supertraits = trait_supertraits(tcx, init_trait_id);\n+                for supertraits.each |supertrait| {\n+                    let super_t = supertrait.tpt.ty;\n+                    let d_id = ty_to_def_id(super_t).expect(\"supertrait \\\n+                        should be a trait ty\");\n+                    if !supertrait_map.contains_key(d_id) {\n+                        supertrait_map.insert(d_id, super_t);\n+                        trait_ty = super_t;\n+                        seen_def_ids.push(d_id);\n+                    }\n+                    debug!(\"A super_t = %s\", ty_to_str(tcx, trait_ty));\n+                    if !f(trait_ty) {\n+                        fin = true;\n+                    }\n+                }\n             }\n-        }\n+        };\n+        fin = false;\n     }\n }\n \n@@ -4428,6 +4451,22 @@ fn count_traits_and_supertraits(tcx: ctxt,\n     return total;\n }\n \n+// Given a trait and a type, returns the impl of that type\n+fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n+    match tcx.trait_impls.find(trait_id) {\n+        Some(ty_to_impl) => match ty_to_impl.find(self_ty) {\n+            Some(the_impl) => the_impl.did,\n+            None => // try autoderef!\n+                match deref(tcx, self_ty, false) {\n+                    Some(some_ty) => get_impl_id(tcx, trait_id, some_ty.ty),\n+                    None => tcx.sess.bug(~\"get_impl_id: no impl of trait for \\\n+                                           this type\")\n+            }\n+        },\n+        None => tcx.sess.bug(~\"get_impl_id: trait isn't in trait_impls\")\n+    }\n+}\n+\n impl mt : cmp::Eq {\n     pure fn eq(&self, other: &mt) -> bool {\n         (*self).ty == (*other).ty && (*self).mutbl == (*other).mutbl"}, {"sha": "5c012f474ab399747e26022e612bf53ecfebedf4", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 70, "deletions": 32, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -93,7 +93,7 @@ use middle::typeck::check;\n use middle::typeck::coherence::get_base_type_def_id;\n use middle::typeck::infer;\n use middle::typeck::{method_map_entry, method_origin, method_param};\n-use middle::typeck::{method_self, method_static, method_trait};\n+use middle::typeck::{method_self, method_static, method_trait, method_super};\n use util::common::indenter;\n use util::ppaux::expr_repr;\n \n@@ -543,33 +543,67 @@ pub impl LookupContext {\n                                           did: def_id,\n                                           substs: &ty::substs) {\n         let tcx = self.tcx();\n-        let methods = ty::trait_methods(tcx, did);  // XXX: Inherited methods.\n-        let index;\n+        // First, try self methods\n+        let mut method = None;\n+        let methods = ty::trait_methods(tcx, did);\n+        let mut index = None;\n+        let mut trait_did = None;\n         match vec::position(*methods, |m| m.ident == self.m_name) {\n-            Some(i) => index = i,\n-            None => return\n+            Some(i) => {\n+                index = Some(i);\n+                trait_did = Some(did);\n+                method = Some((methods[i].self_ty, methods[i].tps.len()));\n+            }\n+            None => ()\n         }\n-        let method = &methods[index];\n-\n-        let rcvr_substs = substs {\n-            self_ty: Some(self_ty),\n-            ../*bad*/copy *substs\n-        };\n-        let (rcvr_ty, rcvr_substs) =\n-            self.create_rcvr_ty_and_substs_for_method(\n-                method.self_ty,\n-                self_ty,\n-                move rcvr_substs,\n-                TransformTypeNormally);\n+        // No method found yet? Check each supertrait\n+        if method.is_none() {\n+            for ty::trait_supertraits(tcx, did).each() |trait_ref| {\n+                let supertrait_methods =\n+                    ty::trait_methods(tcx, trait_ref.def_id);\n+                match vec::position(*supertrait_methods,\n+                                    |m| m.ident == self.m_name) {\n+                    Some(i) => {\n+                        index = Some(i);\n+                        trait_did = Some(trait_ref.def_id);\n+                        method = Some((supertrait_methods[i].self_ty,\n+                                       supertrait_methods[i].tps.len()));\n+                        break;\n+                    }\n+                    None => ()\n+                }\n+            }\n+        }\n+        match (method, index, trait_did) {\n+            (Some((method_self_ty, method_num_tps)),\n+             Some(index), Some(trait_did)) => {\n \n-        self.inherent_candidates.push(Candidate {\n-            rcvr_ty: rcvr_ty,\n-            rcvr_substs: move rcvr_substs,\n-            explicit_self: method.self_ty,\n-            num_method_tps: method.tps.len(),\n-            self_mode: get_mode_from_self_type(method.self_ty),\n-            origin: method_self(did, index)\n-        });\n+                // We've found a method -- return it\n+                let rcvr_substs = substs { self_ty: Some(self_ty),\n+                                          ..copy *substs };\n+                let (rcvr_ty, rcvr_substs) =\n+                    self.create_rcvr_ty_and_substs_for_method(\n+                        method_self_ty,\n+                        self_ty,\n+                        move rcvr_substs,\n+                        TransformTypeNormally);\n+                let origin = if trait_did == did {\n+                    method_self(trait_did, index)\n+                }\n+                else {\n+                    method_super(trait_did, index)\n+                };\n+                self.inherent_candidates.push(Candidate {\n+                    rcvr_ty: rcvr_ty,\n+                    rcvr_substs: move rcvr_substs,\n+                    explicit_self: method_self_ty,\n+                    num_method_tps: method_num_tps,\n+                    self_mode: get_mode_from_self_type(method_self_ty),\n+                    origin: origin\n+                });\n+            }\n+            _ => return\n+        }\n     }\n \n     fn push_inherent_impl_candidates_for_type(did: def_id) {\n@@ -1111,7 +1145,8 @@ pub impl LookupContext {\n          * vtable and hence cannot be monomorphized. */\n \n         match candidate.origin {\n-            method_static(*) | method_param(*) | method_self(*) => {\n+            method_static(*) | method_param(*) |\n+                method_self(*) | method_super(*) => {\n                 return; // not a call to a trait instance\n             }\n             method_trait(*) => {}\n@@ -1135,7 +1170,8 @@ pub impl LookupContext {\n         // No code can call the finalize method explicitly.\n         let bad;\n         match candidate.origin {\n-            method_static(method_id) | method_self(method_id, _) => {\n+            method_static(method_id) | method_self(method_id, _)\n+                | method_super(method_id, _) => {\n                 bad = self.tcx().destructors.contains_key(method_id);\n             }\n             method_param(method_param { trait_id: trait_id, _ }) |\n@@ -1165,7 +1201,8 @@ pub impl LookupContext {\n             method_param(ref mp) => {\n                 type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n             }\n-            method_trait(did, idx, _) | method_self(did, idx) => {\n+            method_trait(did, idx, _) | method_self(did, idx) |\n+                method_super(did, idx) => {\n                 type_of_trait_method(self.tcx(), did, idx)\n             }\n         };\n@@ -1186,17 +1223,18 @@ pub impl LookupContext {\n             method_param(ref mp) => {\n                 self.report_param_candidate(idx, (*mp).trait_id)\n             }\n-            method_trait(trait_did, _, _) | method_self(trait_did, _) => {\n+            method_trait(trait_did, _, _) | method_self(trait_did, _)\n+                | method_super(trait_did, _) => {\n                 self.report_param_candidate(idx, trait_did)\n             }\n         }\n     }\n \n     fn report_static_candidate(&self, idx: uint, did: def_id) {\n         let span = if did.crate == ast::local_crate {\n-            match self.tcx().items.get(did.node) {\n-              ast_map::node_method(m, _, _) => m.span,\n-              _ => fail ~\"report_static_candidate: bad item\"\n+            match self.tcx().items.find(did.node) {\n+              Some(ast_map::node_method(m, _, _)) => m.span,\n+              _ => fail fmt!(\"report_static_candidate: bad item %?\", did)\n             }\n         } else {\n             self.expr.span"}, {"sha": "334b2f46c3bb9e979726e97f48a1b5561932265b", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -429,6 +429,11 @@ pub impl CoherenceChecker {\n             let implementation_a = a;\n             let polytype_a =\n                 self.get_self_type_for_implementation(implementation_a);\n+\n+            // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n+            // and that impl is <implementation_a>\"\n+            self.add_impl_for_trait(trait_def_id, polytype_a.ty,\n+                                    implementation_a);\n             do self.iter_impls_of_trait(trait_def_id) |b| {\n                 let implementation_b = b;\n \n@@ -451,6 +456,24 @@ pub impl CoherenceChecker {\n         }\n     }\n \n+    // Adds an impl of trait trait_t for self type self_t; that impl\n+    // is the_impl\n+    fn add_impl_for_trait(trait_t: def_id, self_t: t, the_impl: @Impl) {\n+        debug!(\"Adding impl %? of %? for %s\",\n+               the_impl.did, trait_t,\n+               ty_to_str(self.crate_context.tcx, self_t));\n+        match self.crate_context.tcx.trait_impls.find(trait_t) {\n+            None => {\n+                let m = HashMap();\n+                m.insert(self_t, the_impl);\n+                self.crate_context.tcx.trait_impls.insert(trait_t, m);\n+            }\n+            Some(m) => {\n+                m.insert(self_t, the_impl);\n+            }\n+        }\n+    }\n+\n     fn iter_impls_of_trait(trait_def_id: def_id,\n                            f: &fn(@Impl)) {\n "}, {"sha": "bc84b957865890ac78d34b0a237b2860340d4e24", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -91,6 +91,12 @@ pub mod coherence;\n #[auto_encode]\n #[auto_decode]\n pub enum method_origin {\n+    // supertrait method invoked on \"self\" inside a default method\n+    // first field is supertrait ID;\n+    // second field is method index (relative to the *supertrait*\n+    // method list)\n+    method_super(ast::def_id, uint),\n+\n     // fully statically resolved method\n     method_static(ast::def_id),\n \n@@ -101,7 +107,8 @@ pub enum method_origin {\n     method_trait(ast::def_id, uint, ty::vstore),\n \n     // method invoked on \"self\" inside a default method\n-    method_self(ast::def_id, uint),\n+    method_self(ast::def_id, uint)\n+\n }\n \n // details for a method invoked with a receiver whose type is a type parameter"}, {"sha": "bf3167f605114c57def81cf1373e542a6e90b2a5", "filename": "src/test/auxiliary/issue_3979_traits.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[link(name = \"issue_3979_traits\",\n+       vers = \"0.1\")];\n+\n+#[crate_type = \"lib\"];\n+\n+trait Positioned {\n+  fn SetX(&self, int);\n+  fn X(&self) -> int;\n+}\n+\n+#[allow(default_methods)]\n+trait Movable: Positioned {\n+  fn translate(&self, dx: int) {\n+    self.SetX(self.X() + dx);\n+  }\n+}"}, {"sha": "7cc2bb49ef70daa4c0189dfb52da27718d50cba8", "filename": "src/test/run-pass/issue-3979-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Frun-pass%2Fissue-3979-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Frun-pass%2Fissue-3979-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979-2.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait A {\n+    fn a_method();\n+}\n+\n+trait B: A {\n+    fn b_method();\n+}\n+\n+trait C: B {\n+    fn c_method() {\n+        self.a_method();\n+    }\n+}\n+\n+fn main() {}\n+"}, {"sha": "7261b74a7fafde172fe24445553ca07d0544c7ab", "filename": "src/test/run-pass/issue-3979-generics.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test\n+trait Positioned<S> {\n+  fn SetX(&self, S);\n+  fn X(&self) -> S;\n+}\n+\n+#[allow(default_methods)]\n+trait Movable<S, T>: Positioned<T> {\n+  fn translate(&self, dx: T) {\n+    self.SetX(self.X() + dx);\n+  }\n+}\n+\n+struct Point { mut x: int, mut y: int }\n+\n+impl Point: Positioned<int> {\n+    fn SetX(&self, x: int) {\n+        self.x = x;\n+    }\n+    fn X(&self) -> int {\n+        self.x\n+    }\n+}\n+\n+impl Point: Movable<int, int>;\n+\n+fn main() {\n+    let p = Point{ x: 1, y: 2};\n+    p.translate(3);\n+    assert p.X() == 4;\n+}"}, {"sha": "bd48950534a5dd56dd100c310af06007da7a622d", "filename": "src/test/run-pass/issue-3979-xcrate.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Frun-pass%2Fissue-3979-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Frun-pass%2Fissue-3979-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979-xcrate.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test // tjc: ???\n+// aux-build:issue_3979_traits.rs\n+extern mod issue_3979_traits;\n+use issue_3979_traits::*;\n+\n+struct Point { mut x: int, mut y: int }\n+\n+impl Point: Positioned {\n+    fn SetX(&self, x: int) {\n+        self.x = x;\n+    }\n+    fn X(&self) -> int {\n+        self.x\n+    }\n+}\n+\n+impl Point: Movable;\n+\n+fn main() {\n+    let p = Point{ x: 1, y: 2};\n+    p.translate(3);\n+    assert p.X() == 4;\n+}"}, {"sha": "2c680d178b2607a3938d42b248ea00fcc34c314c", "filename": "src/test/run-pass/issue-3979.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Frun-pass%2Fissue-3979.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30ea013f5b88f136438931328ee859ee4e5eff3/src%2Ftest%2Frun-pass%2Fissue-3979.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979.rs?ref=a30ea013f5b88f136438931328ee859ee4e5eff3", "patch": "@@ -8,15 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n trait Positioned {\n-  fn SetX(int);\n+  fn SetX(&self, int);\n+  fn X(&self) -> int;\n }\n \n+#[allow(default_methods)]\n trait Movable: Positioned {\n-  fn translate(dx: int) {\n+  fn translate(&self, dx: int) {\n     self.SetX(self.X() + dx);\n   }\n }\n \n-fn main() {}\n+struct Point { mut x: int, mut y: int }\n+\n+impl Point: Positioned {\n+    fn SetX(&self, x: int) {\n+        self.x = x;\n+    }\n+    fn X(&self) -> int {\n+        self.x\n+    }\n+}\n+\n+impl Point: Movable;\n+\n+fn main() {\n+    let p = Point{ x: 1, y: 2};\n+    p.translate(3);\n+    assert p.X() == 4;\n+}"}]}